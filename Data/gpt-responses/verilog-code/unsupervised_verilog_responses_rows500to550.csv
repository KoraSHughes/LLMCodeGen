,Unnamed: 0,repo_name,Code,unasserted,assertions,num_assertions,variables,num_vars,prompt,prompt_len,gpt
500,2852,nickg/nvc,"entity alias3 is
end entity;

architecture test of alias3 is
    type int_array is array (integer range <>) of integer;

    function cut(x : int_array; low, high: integer) return int_array is
        alias a : int_array(1 to x'length) is x;
    begin
        return a(low to high);
    end function;

    signal s : int_array(1 to 5) := (1, 2, 3, 4, 5);
begin

    process is
        variable x : int_array(1 to 5) := (1, 2, 3, 4, 5);
        variable y : int_array(4 downto 0) := (4, 3, 2, 1, 0);
        alias sa : int_array(4 downto 0) is x;
    begin
        assert x(2 to 4) = (2, 3, 4);
        assert sa(3 downto 1) = (2, 3, 4);
        assert cut(x, 2, 3) = (2, 3);
        assert cut(y, 1, 2) = (4, 3);
        wait;
    end process;

end architecture;
","
entity alias3 is
end entity;

architecture test of alias3 is
    type int_array is array (integer range <>) of integer;

    function cut(x : int_array; low, high: integer) return int_array is
        alias a : int_array(1 to x'length) is x;
    begin
        return a(low to high);
    end function;

    signal s : int_array(1 to 5) := (1, 2, 3, 4, 5);
begin

    process is
        variable x : int_array(1 to 5) := (1, 2, 3, 4, 5);
        variable y : int_array(4 downto 0) := (4, 3, 2, 1, 0);
        alias sa : int_array(4 downto 0) is x;
    begin
        wait;
    end process;

end architecture;
","['x(2 to 4) = (2, 3, 4);', 'sa(3 downto 1) = (2, 3, 4);', 'cut(x, 2, 3) = (2, 3);', 'cut(y, 1, 2) = (4, 3);']",4,['range <>) of integer'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
['range <>) of integer']
*Code:

entity alias3 is
end entity;

architecture test of alias3 is
    type int_array is array (integer range <>) of integer;

    function cut(x : int_array; low, high: integer) return int_array is
        alias a : int_array(1 to x'length) is x;
    begin
        return a(low to high);
    end function;

    signal s : int_array(1 to 5) := (1, 2, 3, 4, 5);
begin

    process is
        variable x : int_array(1 to 5) := (1, 2, 3, 4, 5);
        variable y : int_array(4 downto 0) := (4, 3, 2, 1, 0);
        alias sa : int_array(4 downto 0) is x;
    begin
        wait;
    end process;

end architecture;
",2105,"[None, 'x', 5, ""The size of input x in function cut should not exceed 5""],
[None, 'high', 'low', ""The high index in function cut should be greater than or equal to the low index""],
[None, 'cut(x, low, high)', 'x', ""The function cut should not change the size of the input array x""],
[None, 's', 5, ""The signal s should have a size of 5""],
[None, 'sa', 5, ""The variable sa in the process should have a size of 5""],
[None, 'y', 5, ""The variable y in the process should have a size of 5""]"
501,2853,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc737.vhd,v 1.2 2001-10-26 16:30:04 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

entity c01s01b01x01p04n01i00737ent_a is
  generic (
    constant gc1 : in integer;
    constant gc2 : in real;
    constant gc3 : in boolean
    );
  port ( signal cent1 : in bit;
         signal cent2 : in bit
         );
end c01s01b01x01p04n01i00737ent_a;

architecture c01s01b01x01p04n01i00737arch_a of c01s01b01x01p04n01i00737ent_a is
begin
  p0: process
  begin
    wait for 1 ns;
    if (gc1 = 5) AND (gc2 = 0.1234) AND (gc3) then
      assert FALSE 
        report ""***PASSED TEST: c01s01b01x01p04n01i00737""
        severity NOTE;
    else
      assert FALSE
        report ""***FAILED TEST: c01s01b01x01p04n01i00737 - Simple generic association in component instantiation (type conversion done on actual in generic map failed).""
        severity ERROR;
    end if;
    wait;
  end process;
end c01s01b01x01p04n01i00737arch_a;


ENTITY c01s01b01x01p04n01i00737ent IS
  generic ( constant gen_con : integer := 7 );
  port ( signal ee1 : in bit;
         signal ee2 : in bit;
         signal eo1 : out bit
         );
END c01s01b01x01p04n01i00737ent;

ARCHITECTURE c01s01b01x01p04n01i00737arch OF c01s01b01x01p04n01i00737ent IS
  constant    c1 : integer    := 33;
  constant    c2 : real    := 1.23557;
  constant    c3 : boolean    := FALSE;
  signal       s1 : integer;
  signal       s2 : integer;
  signal       s3 : integer;

  component comp1
    generic (
      constant dgc1 : integer;
      constant dgc2 : real;
      constant dgc3 : boolean
      );
    port ( signal dcent1 : in bit;
           signal dcent2 : in bit
           );
  end component;
  
  for u1 : comp1 use
    entity work.c01s01b01x01p04n01i00737ent_a(c01s01b01x01p04n01i00737_arch_a)
    generic map (dgc1, dgc2, dgc3)
    port map ( dcent1, dcent2 );

  function BoolToInt(bin : boolean) return integer is
  begin
    if bin then
      return 5;
    else
      return 99;
    end if;
  end;
  
  function IntegerToReal(iin : integer) return real is
  begin
    return 0.1234;
  end;
  
  function BitToBool(bin : bit) return boolean is
  begin
    if (bin = '1') then
      return TRUE;
    else
      return FALSE;
    end if;
  end;

BEGIN
  
  u1 : comp1
    generic map (BoolToInt(TRUE), IntegerToReal(1234), BitToBool('1'))
    port map (ee1,ee2);

END c01s01b01x01p04n01i00737arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc737.vhd,v 1.2 2001-10-26 16:30:04 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

entity c01s01b01x01p04n01i00737ent_a is
  generic (
    constant gc1 : in integer;
    constant gc2 : in real;
    constant gc3 : in boolean
    );
  port ( signal cent1 : in bit;
         signal cent2 : in bit
         );
end c01s01b01x01p04n01i00737ent_a;

architecture c01s01b01x01p04n01i00737arch_a of c01s01b01x01p04n01i00737ent_a is
begin
  p0: process
  begin
    wait for 1 ns;
    if (gc1 = 5) AND (gc2 = 0.1234) AND (gc3) then
        report ""***PASSED TEST: c01s01b01x01p04n01i00737""
        severity NOTE;
    else
        report ""***FAILED TEST: c01s01b01x01p04n01i00737 - Simple generic association in component instantiation (type conversion done on actual in generic map failed).""
        severity ERROR;
    end if;
    wait;
  end process;
end c01s01b01x01p04n01i00737arch_a;


ENTITY c01s01b01x01p04n01i00737ent IS
  generic ( constant gen_con : integer := 7 );
  port ( signal ee1 : in bit;
         signal ee2 : in bit;
         signal eo1 : out bit
         );
END c01s01b01x01p04n01i00737ent;

ARCHITECTURE c01s01b01x01p04n01i00737arch OF c01s01b01x01p04n01i00737ent IS
  constant    c1 : integer    := 33;
  constant    c2 : real    := 1.23557;
  constant    c3 : boolean    := FALSE;
  signal       s1 : integer;
  signal       s2 : integer;
  signal       s3 : integer;

  component comp1
    generic (
      constant dgc1 : integer;
      constant dgc2 : real;
      constant dgc3 : boolean
      );
    port ( signal dcent1 : in bit;
           signal dcent2 : in bit
           );
  end component;
  
  for u1 : comp1 use
    entity work.c01s01b01x01p04n01i00737ent_a(c01s01b01x01p04n01i00737_arch_a)
    generic map (dgc1, dgc2, dgc3)
    port map ( dcent1, dcent2 );

  function BoolToInt(bin : boolean) return integer is
  begin
    if bin then
      return 5;
    else
      return 99;
    end if;
  end;
  
  function IntegerToReal(iin : integer) return real is
  begin
    return 0.1234;
  end;
  
  function BitToBool(bin : bit) return boolean is
  begin
    if (bin = '1') then
      return TRUE;
    else
      return FALSE;
    end if;
  end;

BEGIN
  
  u1 : comp1
    generic map (BoolToInt(TRUE), IntegerToReal(1234), BitToBool('1'))
    port map (ee1,ee2);

END c01s01b01x01p04n01i00737arch;
","['FALSE', 'FALSE']",2,"[':= 7 )', ':= 1.23557', ':= 33']",3,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 7 )', ':= 1.23557', ':= 33']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc737.vhd,v 1.2 2001-10-26 16:30:04 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

entity c01s01b01x01p04n01i00737ent_a is
  generic (
    constant gc1 : in integer;
    constant gc2 : in real;
    constant gc3 : in boolean
    );
  port ( signal cent1 : in bit;
         signal cent2 : in bit
         );
end c01s01b01x01p04n01i00737ent_a;

architecture c01s01b01x01p04n01i00737arch_a of c01s01b01x01p04n01i00737ent_a is
begin
  p0: process
  begin
    wait for 1 ns;
    if (gc1 = 5) AND (gc2 = 0.1234) AND (gc3) then
        report ""***PASSED TEST: c01s01b01x01p04n01i00737""
        severity NOTE;
    else
        report ""***FAILED TEST: c01s01b01x01p04n01i00737 - Simple generic association in component instantiation (type conversion done on actual in generic map failed).""
        severity ERROR;
    end if;
    wait;
  end process;
end c01s01b01x01p04n01i00737arch_a;


ENTITY c01s01b01x01p04n01i00737ent IS
  generic ( constant gen_con : integer := 7 );
  port ( signal ee1 : in bit;
         signal ee2 : in bit;
         signal eo1 : out bit
         );
END c01s01b01x01p04n01i00737ent;

ARCHITECTURE c01s01b01x01p04n01i00737arch OF c01s01b01x01p04n01i00737ent IS
  constant    c1 : integer    := 33;
  constant    c2 : real    := 1.23557;
  constant    c3 : boolean    := FALSE;
  signal       s1 : integer;
  signal       s2 : integer;
  signal       s3 : integer;

  component comp1
    generic (
      constant dgc1 : integer;
      constant dgc2 : real;
      constant dgc3 : boolean
      );
    port ( signal dcent1 : in bit;
           signal dcent2 : in bit
           );
  end component;
  
  for u1 : comp1 use
    entity work.c01s01b01x01p04n01i00737ent_a(c01s01b01x01p04n01i00737_arch_a)
    generic map (dgc1, dgc2, dgc3)
    port map ( dcent1, dcent2 );

  function BoolToInt(bin : boolean) return integer is
  begin
    if bin then
      return 5;
    else
      return 99;
    end if;
  end;
  
  function IntegerToReal(iin : integer) return real is
  begin
    return 0.1234;
  end;
  
  function BitToBool(bin : bit) return boolean is
  begin
    if (bin = '1') then
      return TRUE;
    else
      return FALSE;
    end if;
  end;

BEGIN
  
  u1 : comp1
    generic map (BoolToInt(TRUE), IntegerToReal(1234), BitToBool('1'))
    port map (ee1,ee2);

END c01s01b01x01p04n01i00737arch;
",4916,"Based on the given Verilog code, here are some assertions that can be generated:

1) [1, gc1, 5, ""gc1 should be equal to 5 at the start of the process""]
This can be denoted by the assertion:
assert @(posedge clk) gc1 == 5 else $display ""gc1 should be equal to 5 at the start of the process"";

2) [1, gc2, 0.1234, ""gc2 should be equal to 0.1234 at the start of the process""]
This can be denoted by the assertion:
assert @(posedge clk) gc2 == 0.1234 else $display ""gc2 should be equal to 0.1234 at the start of the process"";

3) [1, gen_con, 7, ""gen_con should be equal to 7 at the start of the process""]
This can be denoted by the assertion:
assert @(posedge clk) gen_con == 7 else $display ""gen_con should be equal to 7 at the start of the process"";

4) [1, c1, 33, ""c1 should be equal to 33 at the start of the process""]
This can be denoted by the assertion:
assert @(posedge clk) c1 == 33 else $display(""c1 should be equal to 33 at the start of the process"");

5) [1, BoolToInt(TRUE), 5, ""Function BoolToInt converted TRUE to 5 correctly""]
This can be denoted by the assertion:
assert @(posedge clk) BoolToInt(TRUE) == 5 else $display ""Function BoolToInt converted TRUE to 5 correctly"";

6) [1, IntegerToReal(1234), 0.1234, ""Function IntegerToReal converted 1234 to 0.1234 correctly""]
This can be denoted by the assertion:
assert @(posedge clk) IntegerToReal(1234) == 0.1234 else $display ""Function IntegerToReal converted 1234 to 0.1234 correctly"";

7) [1, BitToBool('1'), TRUE, ""Function BitToBool converted '1' to TRUE correctly""]
This can be denoted by the assertion:
assert @(posedge clk) BitToBool('1') == TRUE else $display ""Function BitToBool converted '1' to TRUE correctly"";
"
502,2855,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1305.vhd,v 1.2 2001-10-26 16:30:09 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s04b00x00p06n01i01305ent IS
END c08s04b00x00p06n01i01305ent;

ARCHITECTURE c08s04b00x00p06n01i01305arch OF c08s04b00x00p06n01i01305ent IS
  component COMP_1
    port (A: in BIT; D : out BIT);
  end component;
  signal   X : integer := 5;
BEGIN
  TESTING: PROCESS
  BEGIN
    COMP_1 <= X;
    wait for 1 ns;
    assert FALSE 
      report ""***FAILED TEST: c08s04b00x00p06n01i01305 - A component name can not used on the left-hand side of a signal assignment."" 
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s04b00x00p06n01i01305arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1305.vhd,v 1.2 2001-10-26 16:30:09 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s04b00x00p06n01i01305ent IS
END c08s04b00x00p06n01i01305ent;

ARCHITECTURE c08s04b00x00p06n01i01305arch OF c08s04b00x00p06n01i01305ent IS
  component COMP_1
    port (A: in BIT; D : out BIT);
  end component;
  signal   X : integer := 5;
BEGIN
  TESTING: PROCESS
  BEGIN
    COMP_1 <= X;
    wait for 1 ns;
      report ""***FAILED TEST: c08s04b00x00p06n01i01305 - A component name can not used on the left-hand side of a signal assignment."" 
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s04b00x00p06n01i01305arch;
",['FALSE'],1,"[':= 5', 'nt.""']",2,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 5', 'nt.""']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1305.vhd,v 1.2 2001-10-26 16:30:09 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s04b00x00p06n01i01305ent IS
END c08s04b00x00p06n01i01305ent;

ARCHITECTURE c08s04b00x00p06n01i01305arch OF c08s04b00x00p06n01i01305ent IS
  component COMP_1
    port (A: in BIT; D : out BIT);
  end component;
  signal   X : integer := 5;
BEGIN
  TESTING: PROCESS
  BEGIN
    COMP_1 <= X;
    wait for 1 ns;
      report ""***FAILED TEST: c08s04b00x00p06n01i01305 - A component name can not used on the left-hand side of a signal assignment."" 
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s04b00x00p06n01i01305arch;
",3207,"The given code seems to be in VHDL, not Verilog. Hence, assertions cannot be made for Verilog. Please provide Verilog code for generating assertions."
503,2868,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2610.vhd,v 1.2 2001-10-26 16:30:20 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c13s03b01x00p02n01i02610ent IS
END c13s03b01x00p02n01i02610ent;

ARCHITECTURE c13s03b01x00p02n01i02610arch OF c13s03b01x00p02n01i02610ent IS

BEGIN
  TESTING: PROCESS
    variable k| : integer := 0;
  BEGIN
    assert FALSE 
      report ""***FAILED TEST: c13s03b01x00p02n01i02610 - Identifier can not end with '|'.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c13s03b01x00p02n01i02610arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2610.vhd,v 1.2 2001-10-26 16:30:20 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c13s03b01x00p02n01i02610ent IS
END c13s03b01x00p02n01i02610ent;

ARCHITECTURE c13s03b01x00p02n01i02610arch OF c13s03b01x00p02n01i02610ent IS

BEGIN
  TESTING: PROCESS
    variable k| : integer := 0;
  BEGIN
      report ""***FAILED TEST: c13s03b01x00p02n01i02610 - Identifier can not end with '|'.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c13s03b01x00p02n01i02610arch;
",['FALSE'],1,[':= 0'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 0']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2610.vhd,v 1.2 2001-10-26 16:30:20 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c13s03b01x00p02n01i02610ent IS
END c13s03b01x00p02n01i02610ent;

ARCHITECTURE c13s03b01x00p02n01i02610arch OF c13s03b01x00p02n01i02610ent IS

BEGIN
  TESTING: PROCESS
    variable k| : integer := 0;
  BEGIN
      report ""***FAILED TEST: c13s03b01x00p02n01i02610 - Identifier can not end with '|'.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c13s03b01x00p02n01i02610arch;
",3052,"The input does not appear to include any particular variables, code segments or control structures that need assertions to test. The VHDL code presented is mainly an error report process with a variable `k|` initialized as `0`. Hence, there doesn't appear to be any necessary assertions to add."
504,2876,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1343.vhd,v 1.2 2001-10-26 16:29:40 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s04b01x00p04n01i01343ent IS
END c08s04b01x00p04n01i01343ent;

ARCHITECTURE c08s04b01x00p04n01i01343arch OF c08s04b01x00p04n01i01343ent IS
  signal X : integer := 0;
BEGIN
  TESTING: PROCESS
  BEGIN
    X <= 15 after 1 hr;
    wait for 1 hr;
    assert NOT( X=15 ) 
      report ""***PASSED TEST: c08s04b01x00p04n01i01343"" 
      severity NOTE;
    assert ( X=15 ) 
      report ""***FAILED TEST: c08s04b01x00p04n01i01343 - Predefined TIME unit hr as the base type of the time expression test failed.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s04b01x00p04n01i01343arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1343.vhd,v 1.2 2001-10-26 16:29:40 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s04b01x00p04n01i01343ent IS
END c08s04b01x00p04n01i01343ent;

ARCHITECTURE c08s04b01x00p04n01i01343arch OF c08s04b01x00p04n01i01343ent IS
  signal X : integer := 0;
BEGIN
  TESTING: PROCESS
  BEGIN
    X <= 15 after 1 hr;
    wait for 1 hr;
      report ""***PASSED TEST: c08s04b01x00p04n01i01343"" 
      severity NOTE;
      report ""***FAILED TEST: c08s04b01x00p04n01i01343 - Predefined TIME unit hr as the base type of the time expression test failed.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s04b01x00p04n01i01343arch;
","['NOT( X=15 )', '( X=15 )']",2,[':= 0'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 0']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1343.vhd,v 1.2 2001-10-26 16:29:40 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s04b01x00p04n01i01343ent IS
END c08s04b01x00p04n01i01343ent;

ARCHITECTURE c08s04b01x00p04n01i01343arch OF c08s04b01x00p04n01i01343ent IS
  signal X : integer := 0;
BEGIN
  TESTING: PROCESS
  BEGIN
    X <= 15 after 1 hr;
    wait for 1 hr;
      report ""***PASSED TEST: c08s04b01x00p04n01i01343"" 
      severity NOTE;
      report ""***FAILED TEST: c08s04b01x00p04n01i01343 - Predefined TIME unit hr as the base type of the time expression test failed.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s04b01x00p04n01i01343arch;
",3211,"This is VHDL code, not a Verilog. Therefore, it's not possible to generate Verilog-based assertions for this input."
505,2895,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc455.vhd,v 1.2 2001-10-26 16:29:54 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY model IS
  PORT
    (
      F1:  OUT     integer := 3;
      F2:  INOUT    integer := 3;
      F3:  IN    integer
      );
END model;

architecture model of model is
begin
  process
  begin
    wait for 1 ns;
    assert F3= 3
      report""wrong initialization of F3 through type conversion"" severity failure;
    assert F2 = 3
      report""wrong initialization of F2 through type conversion"" severity failure;
    wait;
  end process;
end;


ENTITY c03s02b01x01p19n01i00455ent IS
END c03s02b01x01p19n01i00455ent;

ARCHITECTURE c03s02b01x01p19n01i00455arch OF c03s02b01x01p19n01i00455ent IS

  subtype    word is bit_vector(0 to  15);

  constant C77 : word := (others => '0');

  function complex_scalar(s : word) return integer is
  begin
    return 3;
  end complex_scalar;
  function scalar_complex(s : integer) return word is
  begin
    return C77;
  end scalar_complex;
  component model1
    PORT
      (    
        F1:  OUT     integer;
        F2:  INOUT    integer;
        F3:  IN    integer
        );
  end component;
  for T1 : model1 use entity work.model(model);

  signal S1 : word;
  signal S2 : word;
  signal S3 : word := C77;
BEGIN
  T1: model1
    port map (
      scalar_complex(F1) => S1,
      scalar_complex(F2) => complex_scalar(S2),
      F3 => complex_scalar(S3)
      );
  TESTING: PROCESS
  BEGIN
    wait for 1 ns;
    assert NOT((S1 = C77) and (S2 = C77)) 
      report ""***PASSED TEST: c03s02b01x01p19n01i00455"" 
      severity NOTE;
    assert ((S1 = C77) and (S2 = C77)) 
      report ""***FAILED TEST: c03s02b01x01p19n01i00455 - For an interface object of mode out, buffer, inout, or linkage, if the formal part includes a type conversion function, then the parameter subtype of that function must be a constrained array subtype.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c03s02b01x01p19n01i00455arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc455.vhd,v 1.2 2001-10-26 16:29:54 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY model IS
  PORT
    (
      F1:  OUT     integer := 3;
      F2:  INOUT    integer := 3;
      F3:  IN    integer
      );
END model;

architecture model of model is
begin
  process
  begin
    wait for 1 ns;
      report""wrong initialization of F3 through type conversion"" severity failure;
      report""wrong initialization of F2 through type conversion"" severity failure;
    wait;
  end process;
end;


ENTITY c03s02b01x01p19n01i00455ent IS
END c03s02b01x01p19n01i00455ent;

ARCHITECTURE c03s02b01x01p19n01i00455arch OF c03s02b01x01p19n01i00455ent IS

  subtype    word is bit_vector(0 to  15);

  constant C77 : word := (others => '0');

  function complex_scalar(s : word) return integer is
  begin
    return 3;
  end complex_scalar;
  function scalar_complex(s : integer) return word is
  begin
    return C77;
  end scalar_complex;
  component model1
    PORT
      (    
        F1:  OUT     integer;
        F2:  INOUT    integer;
        F3:  IN    integer
        );
  end component;
  for T1 : model1 use entity work.model(model);

  signal S1 : word;
  signal S2 : word;
  signal S3 : word := C77;
BEGIN
  T1: model1
    port map (
      scalar_complex(F1) => S1,
      scalar_complex(F2) => complex_scalar(S2),
      F3 => complex_scalar(S3)
      );
  TESTING: PROCESS
  BEGIN
    wait for 1 ns;
      report ""***PASSED TEST: c03s02b01x01p19n01i00455"" 
      severity NOTE;
      report ""***FAILED TEST: c03s02b01x01p19n01i00455 - For an interface object of mode out, buffer, inout, or linkage, if the formal part includes a type conversion function, then the parameter subtype of that function must be a constrained array subtype.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c03s02b01x01p19n01i00455arch;
","['F3= 3', 'F2 = 3', 'NOT((S1 = C77) and (S2 = C77))', '((S1 = C77) and (S2 = C77))']",4,"[')', ':= 3']",2,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[')', ':= 3']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc455.vhd,v 1.2 2001-10-26 16:29:54 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY model IS
  PORT
    (
      F1:  OUT     integer := 3;
      F2:  INOUT    integer := 3;
      F3:  IN    integer
      );
END model;

architecture model of model is
begin
  process
  begin
    wait for 1 ns;
      report""wrong initialization of F3 through type conversion"" severity failure;
      report""wrong initialization of F2 through type conversion"" severity failure;
    wait;
  end process;
end;


ENTITY c03s02b01x01p19n01i00455ent IS
END c03s02b01x01p19n01i00455ent;

ARCHITECTURE c03s02b01x01p19n01i00455arch OF c03s02b01x01p19n01i00455ent IS

  subtype    word is bit_vector(0 to  15);

  constant C77 : word := (others => '0');

  function complex_scalar(s : word) return integer is
  begin
    return 3;
  end complex_scalar;
  function scalar_complex(s : integer) return word is
  begin
    return C77;
  end scalar_complex;
  component model1
    PORT
      (    
        F1:  OUT     integer;
        F2:  INOUT    integer;
        F3:  IN    integer
        );
  end component;
  for T1 : model1 use entity work.model(model);

  signal S1 : word;
  signal S2 : word;
  signal S3 : word := C77;
BEGIN
  T1: model1
    port map (
      scalar_complex(F1) => S1,
      scalar_complex(F2) => complex_scalar(S2),
      F3 => complex_scalar(S3)
      );
  TESTING: PROCESS
  BEGIN
    wait for 1 ns;
      report ""***PASSED TEST: c03s02b01x01p19n01i00455"" 
      severity NOTE;
      report ""***FAILED TEST: c03s02b01x01p19n01i00455 - For an interface object of mode out, buffer, inout, or linkage, if the formal part includes a type conversion function, then the parameter subtype of that function must be a constrained array subtype.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c03s02b01x01p19n01i00455arch;
",4408,"['1 ns', 'F1', 3, ""Asserting the initialization and output size of F1""],
['1 ns', 'F2', 3, ""Asserting the initialization and bi-directional size of F2""],
['1 ns', 'F3', None, ""Asserting the input size of F3""],
['1 ns', 'S1', 'word', ""Asserting the size of the signal S1""],
['1 ns', 'S2', 'word', ""Asserting the size of the signal S2""],
['1 ns', 'S3', 'C77', ""Asserting the initialization and size of the signal S3""],
['1 ns', 'scalar_complex(F1)', 'S1', ""Asserting functional mapping of F1 to S1""],
['1 ns', 'scalar_complex(F2)', 'complex_scalar(S2)', ""Asserting functional mapping and conversion of F2 to S2""],
['1 ns', 'F3', 'complex_scalar(S3)', ""Asserting functional mapping and conversion of F3 to S3""]"
506,2901,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1763.vhd,v 1.2 2001-10-26 16:29:43 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c09s05b02x00p01n01i01763ent IS
END c09s05b02x00p01n01i01763ent;

ARCHITECTURE c09s05b02x00p01n01i01763arch OF c09s05b02x00p01n01i01763ent IS
  type   t_wlogic  is (U, D, Z0, Z1, ZDX, DZX, ZX);
  signal count : integer ;
  signal ECLK  : t_wlogic;
  signal ECLK2 : t_wlogic;
  signal ECL   : integer := 1;
BEGIN
  count <=    0 after  0 ns,   
              1 after 10 ns,
              2 after 20 ns,
              3 after 30 ns,
              4 after 40 ns,
              5 after 50 ns,
              6 after 60 ns;
  ----------------------------------------------------------------------
  WITH count SELECT
    ECLK <=    transport 
    U   after 1 ns WHEN 0,
    D   after 1 ns WHEN 1,
    Z0  after 1 ns WHEN 2,
    Z1  after 1 ns WHEN 3,
    ZDX after 1 ns WHEN 4,
    DZX after 1 ns WHEN 5,
    ZX  after 1 ns WHEN OTHERS;
  TESTING: PROCESS(count)
  BEGIN
    case count is
      WHEN 0      => ECLK2 <= transport U   after 1 ns;
      WHEN 1      => ECLK2 <= transport D   after 1 ns;
      WHEN 2      => ECLK2 <= transport Z0  after 1 ns;
      WHEN 3      => ECLK2 <= transport Z1  after 1 ns;
      WHEN 4      => ECLK2 <= transport ZDX after 1 ns;
      WHEN 5      => ECLK2 <= transport DZX after 1 ns;
      WHEN OTHERS   => ECLK2 <= transport ZX  after 1 ns;
    end case;
  END PROCESS TESTING;
  PROCESS(ECLK,ECLK2)
  BEGIN
    if    now =  0 ns then
      NULL;
    elsif   (now =  1 ns) and (ECLK /= ECLK2) then
      assert FALSE
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif   (now = 11 ns) and (ECLK /= ECLK2) then
      assert FALSE
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif    (now = 21 ns) and (ECLK /= ECLK2) then
      assert FALSE
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif   (now = 31 ns) and (ECLK /= ECLK2) then
      assert FALSE
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif   (now = 41 ns) and (ECLK /= ECLK2) then
      assert FALSE
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif   (now = 51 ns) and (ECLK /= ECLK2) then
      assert FALSE
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif   (now = 61 ns) and (ECLK /= ECLK2) then
      assert FALSE
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    end if;
  END PROCESS;
  PROCESS(ECLK,ECLK2)
  BEGIN
    if    (now > 60 ns) and (ECL = 1) then
      assert FALSE 
        report ""***PASSED TEST: c09s05b02x00p01n01i01763""
        severity NOTE;
    elsif   (now > 60 ns) and (ECL = 0) then
      assert FALSE 
        report ""***FAILED TEST: c09s05b02x00p01n01i01763 - The transport selected signal assignment represents a process statement in which the signal transform is a case statement.""
        severity ERROR;
    end if;
  END PROCESS;

END c09s05b02x00p01n01i01763arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1763.vhd,v 1.2 2001-10-26 16:29:43 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c09s05b02x00p01n01i01763ent IS
END c09s05b02x00p01n01i01763ent;

ARCHITECTURE c09s05b02x00p01n01i01763arch OF c09s05b02x00p01n01i01763ent IS
  type   t_wlogic  is (U, D, Z0, Z1, ZDX, DZX, ZX);
  signal count : integer ;
  signal ECLK  : t_wlogic;
  signal ECLK2 : t_wlogic;
  signal ECL   : integer := 1;
BEGIN
  count <=    0 after  0 ns,   
              1 after 10 ns,
              2 after 20 ns,
              3 after 30 ns,
              4 after 40 ns,
              5 after 50 ns,
              6 after 60 ns;
  ----------------------------------------------------------------------
  WITH count SELECT
    ECLK <=    transport 
    U   after 1 ns WHEN 0,
    D   after 1 ns WHEN 1,
    Z0  after 1 ns WHEN 2,
    Z1  after 1 ns WHEN 3,
    ZDX after 1 ns WHEN 4,
    DZX after 1 ns WHEN 5,
    ZX  after 1 ns WHEN OTHERS;
  TESTING: PROCESS(count)
  BEGIN
    case count is
      WHEN 0      => ECLK2 <= transport U   after 1 ns;
      WHEN 1      => ECLK2 <= transport D   after 1 ns;
      WHEN 2      => ECLK2 <= transport Z0  after 1 ns;
      WHEN 3      => ECLK2 <= transport Z1  after 1 ns;
      WHEN 4      => ECLK2 <= transport ZDX after 1 ns;
      WHEN 5      => ECLK2 <= transport DZX after 1 ns;
      WHEN OTHERS   => ECLK2 <= transport ZX  after 1 ns;
    end case;
  END PROCESS TESTING;
  PROCESS(ECLK,ECLK2)
  BEGIN
    if    now =  0 ns then
      NULL;
    elsif   (now =  1 ns) and (ECLK /= ECLK2) then
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif   (now = 11 ns) and (ECLK /= ECLK2) then
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif    (now = 21 ns) and (ECLK /= ECLK2) then
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif   (now = 31 ns) and (ECLK /= ECLK2) then
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif   (now = 41 ns) and (ECLK /= ECLK2) then
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif   (now = 51 ns) and (ECLK /= ECLK2) then
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif   (now = 61 ns) and (ECLK /= ECLK2) then
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    end if;
  END PROCESS;
  PROCESS(ECLK,ECLK2)
  BEGIN
    if    (now > 60 ns) and (ECL = 1) then
        report ""***PASSED TEST: c09s05b02x00p01n01i01763""
        severity NOTE;
    elsif   (now > 60 ns) and (ECL = 0) then
        report ""***FAILED TEST: c09s05b02x00p01n01i01763 - The transport selected signal assignment represents a process statement in which the signal transform is a case statement.""
        severity ERROR;
    end if;
  END PROCESS;

END c09s05b02x00p01n01i01763arch;
","['FALSE', 'FALSE', 'FALSE', 'FALSE', 'FALSE', 'FALSE', 'FALSE', 'FALSE', 'FALSE']",9,"['', ':= 1', 'nt']",3,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
['', ':= 1', 'nt']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1763.vhd,v 1.2 2001-10-26 16:29:43 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c09s05b02x00p01n01i01763ent IS
END c09s05b02x00p01n01i01763ent;

ARCHITECTURE c09s05b02x00p01n01i01763arch OF c09s05b02x00p01n01i01763ent IS
  type   t_wlogic  is (U, D, Z0, Z1, ZDX, DZX, ZX);
  signal count : integer ;
  signal ECLK  : t_wlogic;
  signal ECLK2 : t_wlogic;
  signal ECL   : integer := 1;
BEGIN
  count <=    0 after  0 ns,   
              1 after 10 ns,
              2 after 20 ns,
              3 after 30 ns,
              4 after 40 ns,
              5 after 50 ns,
              6 after 60 ns;
  ----------------------------------------------------------------------
  WITH count SELECT
    ECLK <=    transport 
    U   after 1 ns WHEN 0,
    D   after 1 ns WHEN 1,
    Z0  after 1 ns WHEN 2,
    Z1  after 1 ns WHEN 3,
    ZDX after 1 ns WHEN 4,
    DZX after 1 ns WHEN 5,
    ZX  after 1 ns WHEN OTHERS;
  TESTING: PROCESS(count)
  BEGIN
    case count is
      WHEN 0      => ECLK2 <= transport U   after 1 ns;
      WHEN 1      => ECLK2 <= transport D   after 1 ns;
      WHEN 2      => ECLK2 <= transport Z0  after 1 ns;
      WHEN 3      => ECLK2 <= transport Z1  after 1 ns;
      WHEN 4      => ECLK2 <= transport ZDX after 1 ns;
      WHEN 5      => ECLK2 <= transport DZX after 1 ns;
      WHEN OTHERS   => ECLK2 <= transport ZX  after 1 ns;
    end case;
  END PROCESS TESTING;
  PROCESS(ECLK,ECLK2)
  BEGIN
    if    now =  0 ns then
      NULL;
    elsif   (now =  1 ns) and (ECLK /= ECLK2) then
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif   (now = 11 ns) and (ECLK /= ECLK2) then
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif    (now = 21 ns) and (ECLK /= ECLK2) then
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif   (now = 31 ns) and (ECLK /= ECLK2) then
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif   (now = 41 ns) and (ECLK /= ECLK2) then
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif   (now = 51 ns) and (ECLK /= ECLK2) then
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    elsif   (now = 61 ns) and (ECLK /= ECLK2) then
        report ""FAILED TEST"" 
        severity ERROR;
      ECL <= 0;
    end if;
  END PROCESS;
  PROCESS(ECLK,ECLK2)
  BEGIN
    if    (now > 60 ns) and (ECL = 1) then
        report ""***PASSED TEST: c09s05b02x00p01n01i01763""
        severity NOTE;
    elsif   (now > 60 ns) and (ECL = 0) then
        report ""***FAILED TEST: c09s05b02x00p01n01i01763 - The transport selected signal assignment represents a process statement in which the signal transform is a case statement.""
        severity ERROR;
    end if;
  END PROCESS;

END c09s05b02x00p01n01i01763arch;
",5399,"Based on the given Verilog code, there are few test assertions that can be made:

1) ['now', 0, None, ""At time zero 'now' variable should not be null.""] 
 - This assertion executes in all clock cycles and checks if the 'now' time variable is not null at the start of the system. In the code provided, this is achieved with 'if now = 0 ns then NULL;'

2) ['ECLK', 'ECLK2', None, ""Both ECLK and ECLK2 should be of same value in each clock cycle""]
 - This assertion checks if the two signals, ECLK and ECLK2, are equal at every instance once the system starts functioning. The timing of this assertion is checked at every nanoseconds starting from 1 to 61 with a delay of 10 ns.

3) ['ECL', 0, None, ""ECL should be zero whenever ECLK != ECLK2 to represent a fault""]
 - This assertion will be checked only when the system has started and not at time zero. It checks if ECL is zero whenever ECLK is unequal to ECLK2, symbolizing a failed test.

4) ['ECL', 1, None, ""ECL should be one to represent a passed test""]
 - This assertion will be checked only when the system has started, and not at time zero. It asserts that ECL is one symbolizing a passed test.

Please note that, though 'now' is not explicitly defined as a variable, it is inherently available in Verilog to denote the current time/hardware event. The terms 'ns' denote 'nanoseconds', a unit of time measurement in Verilog.
"
507,2902,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1913.vhd,v 1.2 2001-10-26 16:30:14 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c07s02b01x00p01n01i01913ent IS
END c07s02b01x00p01n01i01913ent;

ARCHITECTURE c07s02b01x00p01n01i01913arch OF c07s02b01x00p01n01i01913ent IS

BEGIN
  TESTING: PROCESS
    variable x : integer := 3;
    variable y : integer := 5;
    variable z : integer := 9;
  BEGIN
    if ((x and y) and (y or z)) then
    end if;  -- logical operators defined only for BIT and BOOLEAN.
    assert FALSE 
      report ""***FAILED TEST: c07s02b01x00p01n01i01913 - Logical operators  defined only for predefined types BIT and BOOLEAN.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c07s02b01x00p01n01i01913arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1913.vhd,v 1.2 2001-10-26 16:30:14 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c07s02b01x00p01n01i01913ent IS
END c07s02b01x00p01n01i01913ent;

ARCHITECTURE c07s02b01x00p01n01i01913arch OF c07s02b01x00p01n01i01913ent IS

BEGIN
  TESTING: PROCESS
    variable x : integer := 3;
    variable y : integer := 5;
    variable z : integer := 9;
  BEGIN
    if ((x and y) and (y or z)) then
    end if;  -- logical operators defined only for BIT and BOOLEAN.
      report ""***FAILED TEST: c07s02b01x00p01n01i01913 - Logical operators  defined only for predefined types BIT and BOOLEAN.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c07s02b01x00p01n01i01913arch;
",['FALSE'],1,"[':= 5', ':= 9', ':= 3']",3,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 5', ':= 9', ':= 3']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1913.vhd,v 1.2 2001-10-26 16:30:14 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c07s02b01x00p01n01i01913ent IS
END c07s02b01x00p01n01i01913ent;

ARCHITECTURE c07s02b01x00p01n01i01913arch OF c07s02b01x00p01n01i01913ent IS

BEGIN
  TESTING: PROCESS
    variable x : integer := 3;
    variable y : integer := 5;
    variable z : integer := 9;
  BEGIN
    if ((x and y) and (y or z)) then
    end if;  -- logical operators defined only for BIT and BOOLEAN.
      report ""***FAILED TEST: c07s02b01x00p01n01i01913 - Logical operators  defined only for predefined types BIT and BOOLEAN.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c07s02b01x00p01n01i01913arch;
",3271,"Based on the given Verilog code, the assertions made would be as follows:

1. ['TESTING: PROCESS', 'x', 3, ""Variable 'x' should be initialized to integer 3""]
2. ['TESTING: PROCESS', 'y', 5, ""Variable 'y' should be initialized to integer 5""]
3. ['TESTING: PROCESS', 'z', 9, ""Variable 'z' should be initialized to integer 9""]"
508,2907,nickg/nvc,"entity driving is
    port ( i : in integer;
           o : out integer );
end entity;

architecture test of driving is
    signal x : integer;
begin

    p1: process is
        variable v : integer;
    begin
        x <= 1;
        assert x'driving;               -- OK
        assert v'driving;               -- Error
        assert o'driving;               -- OK
        assert i'driving;               -- Error
        wait;
    end process;

end architecture;
","
entity driving is
    port ( i : in integer;
           o : out integer );
end entity;

architecture test of driving is
    signal x : integer;
begin

    p1: process is
        variable v : integer;
    begin
        x <= 1;
        wait;
    end process;

end architecture;
","[""x'driving;               -- OK"", ""v'driving;               -- Error"", ""o'driving;               -- OK"", ""i'driving;               -- Error""]",4,[')'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[')']
*Code:

entity driving is
    port ( i : in integer;
           o : out integer );
end entity;

architecture test of driving is
    signal x : integer;
begin

    p1: process is
        variable v : integer;
    begin
        x <= 1;
        wait;
    end process;

end architecture;
",1756,"[""every cycle"", 'i', None, ""Inputs should be able to accept all necessary inputs""],
[""every cycle"", 'o', None, ""Output should be of the correct size""],
[""every cycle"", 'x', 1, ""x should be assigned the value of 1 every cycle""],
[""start of process p1"", 'v', None, ""v should be able to accept all necessary inputs""],"
509,2909,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1194.vhd,v 1.2 2001-10-26 16:30:07 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s01b00x00p05n01i01194ent IS
END c08s01b00x00p05n01i01194ent;

ARCHITECTURE c08s01b00x00p05n01i01194arch OF c08s01b00x00p05n01i01194ent IS
  signal k : integer := 0;
BEGIN
  TESTING: PROCESS
  BEGIN
    k <= 5 after 5 ns;
    wait on k untli (k = 5);
    assert FALSE
      report ""***FAILED TEST: c08s01b00x00p05n01i01194 - Reserved word 'until' is misspelled""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s01b00x00p05n01i01194arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1194.vhd,v 1.2 2001-10-26 16:30:07 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s01b00x00p05n01i01194ent IS
END c08s01b00x00p05n01i01194ent;

ARCHITECTURE c08s01b00x00p05n01i01194arch OF c08s01b00x00p05n01i01194ent IS
  signal k : integer := 0;
BEGIN
  TESTING: PROCESS
  BEGIN
    k <= 5 after 5 ns;
    wait on k untli (k = 5);
      report ""***FAILED TEST: c08s01b00x00p05n01i01194 - Reserved word 'until' is misspelled""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s01b00x00p05n01i01194arch;
",['FALSE'],1,[':= 0'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 0']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1194.vhd,v 1.2 2001-10-26 16:30:07 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s01b00x00p05n01i01194ent IS
END c08s01b00x00p05n01i01194ent;

ARCHITECTURE c08s01b00x00p05n01i01194arch OF c08s01b00x00p05n01i01194ent IS
  signal k : integer := 0;
BEGIN
  TESTING: PROCESS
  BEGIN
    k <= 5 after 5 ns;
    wait on k untli (k = 5);
      report ""***FAILED TEST: c08s01b00x00p05n01i01194 - Reserved word 'until' is misspelled""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s01b00x00p05n01i01194arch;
",3101,"[""after 5 ns"", k, 5, ""k should be equal to 5 after 5 ns""],
[""wait on k"", k, None, ""k is expected to change its state""],
[""(k = 5)"", k, 5, ""k should eventually be equal to 5""]"
510,2913,plessl/zippy,"------------------------------------------------------------------------------
-- Testbench for schedulectrl.vhd
--
-- Project    : 
-- File       : tb_schedulectrl.vhd
-- Author     : Rolf Enzler  <enzler@ife.ee.ethz.ch>
-- Company    : Swiss Federal Institute of Technology (ETH) Zurich
-- Created    : 2003-10-17
-- Last changed: $LastChangedDate: 2004-10-05 17:10:36 +0200 (Tue, 05 Oct 2004) $
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.componentsPkg.all;
use work.auxPkg.all;

entity tb_ScheduleCtrl is
end tb_ScheduleCtrl;

architecture arch of tb_ScheduleCtrl is

  -- simulation stuff
  constant CLK_PERIOD : time    := 100 ns;
  signal   ccount     : integer := 1;

  type   tbstatusType is (rst, idle, done ,fsm_idle, fsm_startswitch,
                          fsm_runswitch, fsm_run, fsm_last);
  signal tbStatus : tbstatusType := idle;

  -- general control signals
  signal ClkxC  : std_logic := '1';
  signal RstxRB : std_logic;

  -- DUT signals
  signal StartxEI   : std_logic;
  signal RunningxSI : std_logic;
  signal LastxSI    : std_logic;
  signal SwitchxEO  : std_logic;
  signal BusyxSO    : std_logic;

begin  -- arch

  ----------------------------------------------------------------------------
  -- device under test
  ----------------------------------------------------------------------------
  dut : ScheduleCtrl
    port map (
      ClkxC      => ClkxC,
      RstxRB     => RstxRB,
      StartxEI   => StartxEI,
      RunningxSI => RunningxSI,
      LastxSI    => LastxSI,
      SwitchxEO  => SwitchxEO,
      BusyxSO    => BusyxSO);


  ----------------------------------------------------------------------------
  -- stimuli
  ----------------------------------------------------------------------------
  stimuliTb : process

    procedure init_stimuli (
      signal StartxEI   : out std_logic;
      signal RunningxSI : out std_logic;
      signal LastxSI    : out std_logic
      ) is
    begin
      StartxEI   <= '0';
      RunningxSI <= '0';
      LastxSI    <= '0';
    end init_stimuli;

  begin  -- process stimuliTb

    tbStatus <= rst;
    init_stimuli(StartxEI, RunningxSI, LastxSI);

    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '0');
    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '1');
    tbStatus <= idle;
    wait for CLK_PERIOD*0.25;

    tbStatus <= idle;
    init_stimuli(StartxEI, RunningxSI, LastxSI);
    wait for CLK_PERIOD;

    tbStatus   <= fsm_idle;
    RunningxSI <= '0';
    LastxSI    <= '0';
    wait for CLK_PERIOD;
    RunningxSI <= '1';
    LastxSI    <= '0';
    wait for CLK_PERIOD;
    RunningxSI <= '0';
    LastxSI    <= '1';
    wait for CLK_PERIOD;
    RunningxSI <= '1';
    LastxSI    <= '1';
    wait for CLK_PERIOD;

    tbStatus <= idle;
    init_stimuli(StartxEI, RunningxSI, LastxSI);
    wait for CLK_PERIOD;

    tbStatus   <= fsm_startswitch;
    StartxEI   <= '1';
    wait for CLK_PERIOD;
    tbStatus   <= fsm_run;
    StartxEI   <= '0';
    RunningxSI <= '1';                  -- supposed to go high
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= fsm_runswitch;
    StartxEI   <= '0';
    RunningxSI <= '0';                  -- goes low
    wait for CLK_PERIOD;
    tbStatus   <= fsm_run;
    StartxEI   <= '0';
    RunningxSI <= '1';                  -- supposed to go high
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
  
    tbStatus <= fsm_last;
    StartxEI   <= '0';
    RunningxSI <= '0';                  -- goes low
    LastxSI    <= '1';                  -- is high
    wait for CLK_PERIOD;
    tbStatus   <= fsm_idle;
    StartxEI   <= '0';
    RunningxSI <= '0';
    LastxSI    <= '1';                  -- is high
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;


    tbStatus <= done;
    init_stimuli(StartxEI, RunningxSI, LastxSI);
    wait for CLK_PERIOD;

    -- stop simulation
    wait until (ClkxC'event and ClkxC = '1');
    assert false
      report ""stimuli processed; sim. terminated after "" & int2str(ccount) &
      "" cycles""
      severity failure;
    
  end process stimuliTb;

  ----------------------------------------------------------------------------
  -- clock and reset generation
  ----------------------------------------------------------------------------
  ClkxC  <= not ClkxC after CLK_PERIOD/2;
  RstxRB <= '0', '1'  after CLK_PERIOD*1.25;

  ----------------------------------------------------------------------------
  -- cycle counter
  ----------------------------------------------------------------------------
  cyclecounter : process (ClkxC)
  begin
    if (ClkxC'event and ClkxC = '1') then
      ccount <= ccount + 1;
    end if;
  end process cyclecounter;

end arch;
","
------------------------------------------------------------------------------
-- Testbench for schedulectrl.vhd
--
-- Project    : 
-- File       : tb_schedulectrl.vhd
-- Author     : Rolf Enzler  <enzler@ife.ee.ethz.ch>
-- Company    : Swiss Federal Institute of Technology (ETH) Zurich
-- Created    : 2003-10-17
-- Last changed: $LastChangedDate: 2004-10-05 17:10:36 +0200 (Tue, 05 Oct 2004) $
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.componentsPkg.all;
use work.auxPkg.all;

entity tb_ScheduleCtrl is
end tb_ScheduleCtrl;

architecture arch of tb_ScheduleCtrl is

  -- simulation stuff
  constant CLK_PERIOD : time    := 100 ns;
  signal   ccount     : integer := 1;

  type   tbstatusType is (rst, idle, done ,fsm_idle, fsm_startswitch,
                          fsm_runswitch, fsm_run, fsm_last);
  signal tbStatus : tbstatusType := idle;

  -- general control signals
  signal ClkxC  : std_logic := '1';
  signal RstxRB : std_logic;

  -- DUT signals
  signal StartxEI   : std_logic;
  signal RunningxSI : std_logic;
  signal LastxSI    : std_logic;
  signal SwitchxEO  : std_logic;
  signal BusyxSO    : std_logic;

begin  -- arch

  ----------------------------------------------------------------------------
  -- device under test
  ----------------------------------------------------------------------------
  dut : ScheduleCtrl
    port map (
      ClkxC      => ClkxC,
      RstxRB     => RstxRB,
      StartxEI   => StartxEI,
      RunningxSI => RunningxSI,
      LastxSI    => LastxSI,
      SwitchxEO  => SwitchxEO,
      BusyxSO    => BusyxSO);


  ----------------------------------------------------------------------------
  -- stimuli
  ----------------------------------------------------------------------------
  stimuliTb : process

    procedure init_stimuli (
      signal StartxEI   : out std_logic;
      signal RunningxSI : out std_logic;
      signal LastxSI    : out std_logic
      ) is
    begin
      StartxEI   <= '0';
      RunningxSI <= '0';
      LastxSI    <= '0';
    end init_stimuli;

  begin  -- process stimuliTb

    tbStatus <= rst;
    init_stimuli(StartxEI, RunningxSI, LastxSI);

    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '0');
    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '1');
    tbStatus <= idle;
    wait for CLK_PERIOD*0.25;

    tbStatus <= idle;
    init_stimuli(StartxEI, RunningxSI, LastxSI);
    wait for CLK_PERIOD;

    tbStatus   <= fsm_idle;
    RunningxSI <= '0';
    LastxSI    <= '0';
    wait for CLK_PERIOD;
    RunningxSI <= '1';
    LastxSI    <= '0';
    wait for CLK_PERIOD;
    RunningxSI <= '0';
    LastxSI    <= '1';
    wait for CLK_PERIOD;
    RunningxSI <= '1';
    LastxSI    <= '1';
    wait for CLK_PERIOD;

    tbStatus <= idle;
    init_stimuli(StartxEI, RunningxSI, LastxSI);
    wait for CLK_PERIOD;

    tbStatus   <= fsm_startswitch;
    StartxEI   <= '1';
    wait for CLK_PERIOD;
    tbStatus   <= fsm_run;
    StartxEI   <= '0';
    RunningxSI <= '1';                  -- supposed to go high
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= fsm_runswitch;
    StartxEI   <= '0';
    RunningxSI <= '0';                  -- goes low
    wait for CLK_PERIOD;
    tbStatus   <= fsm_run;
    StartxEI   <= '0';
    RunningxSI <= '1';                  -- supposed to go high
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
  
    tbStatus <= fsm_last;
    StartxEI   <= '0';
    RunningxSI <= '0';                  -- goes low
    LastxSI    <= '1';                  -- is high
    wait for CLK_PERIOD;
    tbStatus   <= fsm_idle;
    StartxEI   <= '0';
    RunningxSI <= '0';
    LastxSI    <= '1';                  -- is high
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;


    tbStatus <= done;
    init_stimuli(StartxEI, RunningxSI, LastxSI);
    wait for CLK_PERIOD;

    -- stop simulation
    wait until (ClkxC'event and ClkxC = '1');
      report ""stimuli processed; sim. terminated after "" & int2str(ccount) &
      "" cycles""
      severity failure;
    
  end process stimuliTb;

  ----------------------------------------------------------------------------
  -- clock and reset generation
  ----------------------------------------------------------------------------
  ClkxC  <= not ClkxC after CLK_PERIOD/2;
  RstxRB <= '0', '1'  after CLK_PERIOD*1.25;

  ----------------------------------------------------------------------------
  -- cycle counter
  ----------------------------------------------------------------------------
  cyclecounter : process (ClkxC)
  begin
    if (ClkxC'event and ClkxC = '1') then
      ccount <= ccount + 1;
    end if;
  end process cyclecounter;

end arch;
",['false'],1,"[':= 100 ns', ':= 1']",2,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 100 ns', ':= 1']
*Code:

------------------------------------------------------------------------------
-- Testbench for schedulectrl.vhd
--
-- Project    : 
-- File       : tb_schedulectrl.vhd
-- Author     : Rolf Enzler  <enzler@ife.ee.ethz.ch>
-- Company    : Swiss Federal Institute of Technology (ETH) Zurich
-- Created    : 2003-10-17
-- Last changed: $LastChangedDate: 2004-10-05 17:10:36 +0200 (Tue, 05 Oct 2004) $
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.componentsPkg.all;
use work.auxPkg.all;

entity tb_ScheduleCtrl is
end tb_ScheduleCtrl;

architecture arch of tb_ScheduleCtrl is

  -- simulation stuff
  constant CLK_PERIOD : time    := 100 ns;
  signal   ccount     : integer := 1;

  type   tbstatusType is (rst, idle, done ,fsm_idle, fsm_startswitch,
                          fsm_runswitch, fsm_run, fsm_last);
  signal tbStatus : tbstatusType := idle;

  -- general control signals
  signal ClkxC  : std_logic := '1';
  signal RstxRB : std_logic;

  -- DUT signals
  signal StartxEI   : std_logic;
  signal RunningxSI : std_logic;
  signal LastxSI    : std_logic;
  signal SwitchxEO  : std_logic;
  signal BusyxSO    : std_logic;

begin  -- arch

  ----------------------------------------------------------------------------
  -- device under test
  ----------------------------------------------------------------------------
  dut : ScheduleCtrl
    port map (
      ClkxC      => ClkxC,
      RstxRB     => RstxRB,
      StartxEI   => StartxEI,
      RunningxSI => RunningxSI,
      LastxSI    => LastxSI,
      SwitchxEO  => SwitchxEO,
      BusyxSO    => BusyxSO);


  ----------------------------------------------------------------------------
  -- stimuli
  ----------------------------------------------------------------------------
  stimuliTb : process

    procedure init_stimuli (
      signal StartxEI   : out std_logic;
      signal RunningxSI : out std_logic;
      signal LastxSI    : out std_logic
      ) is
    begin
      StartxEI   <= '0';
      RunningxSI <= '0';
      LastxSI    <= '0';
    end init_stimuli;

  begin  -- process stimuliTb

    tbStatus <= rst;
    init_stimuli(StartxEI, RunningxSI, LastxSI);

    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '0');
    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '1');
    tbStatus <= idle;
    wait for CLK_PERIOD*0.25;

    tbStatus <= idle;
    init_stimuli(StartxEI, RunningxSI, LastxSI);
    wait for CLK_PERIOD;

    tbStatus   <= fsm_idle;
    RunningxSI <= '0';
    LastxSI    <= '0';
    wait for CLK_PERIOD;
    RunningxSI <= '1';
    LastxSI    <= '0';
    wait for CLK_PERIOD;
    RunningxSI <= '0';
    LastxSI    <= '1';
    wait for CLK_PERIOD;
    RunningxSI <= '1';
    LastxSI    <= '1';
    wait for CLK_PERIOD;

    tbStatus <= idle;
    init_stimuli(StartxEI, RunningxSI, LastxSI);
    wait for CLK_PERIOD;

    tbStatus   <= fsm_startswitch;
    StartxEI   <= '1';
    wait for CLK_PERIOD;
    tbStatus   <= fsm_run;
    StartxEI   <= '0';
    RunningxSI <= '1';                  -- supposed to go high
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= fsm_runswitch;
    StartxEI   <= '0';
    RunningxSI <= '0';                  -- goes low
    wait for CLK_PERIOD;
    tbStatus   <= fsm_run;
    StartxEI   <= '0';
    RunningxSI <= '1';                  -- supposed to go high
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
  
    tbStatus <= fsm_last;
    StartxEI   <= '0';
    RunningxSI <= '0';                  -- goes low
    LastxSI    <= '1';                  -- is high
    wait for CLK_PERIOD;
    tbStatus   <= fsm_idle;
    StartxEI   <= '0';
    RunningxSI <= '0';
    LastxSI    <= '1';                  -- is high
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;


    tbStatus <= done;
    init_stimuli(StartxEI, RunningxSI, LastxSI);
    wait for CLK_PERIOD;

    -- stop simulation
    wait until (ClkxC'event and ClkxC = '1');
      report ""stimuli processed; sim. terminated after "" & int2str(ccount) &
      "" cycles""
      severity failure;
    
  end process stimuliTb;

  ----------------------------------------------------------------------------
  -- clock and reset generation
  ----------------------------------------------------------------------------
  ClkxC  <= not ClkxC after CLK_PERIOD/2;
  RstxRB <= '0', '1'  after CLK_PERIOD*1.25;

  ----------------------------------------------------------------------------
  -- cycle counter
  ----------------------------------------------------------------------------
  cyclecounter : process (ClkxC)
  begin
    if (ClkxC'event and ClkxC = '1') then
      ccount <= ccount + 1;
    end if;
  end process cyclecounter;

end arch;
",6261,"[1, 'StartxEI', 1, ""Assert that StartxEI can take in all possible binary inputs""],
[1, 'RunningxSI', 1, ""Assert that RunningxSI can take in all possible binary inputs""],
[1, 'LastxSI', 1, ""Assert that LastxSI can take in all possible binary inputs""],
[1, 'SwitchxEO', 1, ""Assert that SwitchxEO can take in all possible binary inputs""],
[1, 'BusyxSO', 1, ""Assert that BusyxSO can take in all possible binary inputs""],
[1, 'ClkxC', 1, ""Assert that ClkxC can take in all possible binary inputs""],
[1, 'RstxRB', 1, ""Assert that RstxRB can take in all possible binary inputs""],
[1, 'tbStatus', 8, ""Assert that tbStatus can have 8 different states (rst, idle, done, fsm_idle, fsm_startswitch, fsm_runswitch, fsm_run, fsm_last)""],
[1, 'ccount', None, ""Assert that ccount is incrementing properly after each ClkxC cycle""],
[CLK_PERIOD, 'ClkxC', 2, ""Assert that ClkxC signal oscillates every CLK_PERIOD""],
[CLK_PERIOD*1.25, 'RstxRB', 2, ""Assert that RstxRB is reset after CLK_PERIOD*1.25""]"
511,2918,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1638.vhd,v 1.2 2001-10-26 16:30:11 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s12b00x00p05n03i01638ent IS
END c08s12b00x00p05n03i01638ent;

ARCHITECTURE c08s12b00x00p05n03i01638arch OF c08s12b00x00p05n03i01638ent IS

BEGIN
  TESTING: PROCESS
    function f1(in1:real) return integer is
    begin
      exit;
    end;
    variable k : integer := 0;
  BEGIN
    k := f1(1.2);
    assert FALSE 
      report ""***FAILED TEST: c08s12b00x00p05n03i01638 - A function must be completed by a return statement""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s12b00x00p05n03i01638arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1638.vhd,v 1.2 2001-10-26 16:30:11 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s12b00x00p05n03i01638ent IS
END c08s12b00x00p05n03i01638ent;

ARCHITECTURE c08s12b00x00p05n03i01638arch OF c08s12b00x00p05n03i01638ent IS

BEGIN
  TESTING: PROCESS
    function f1(in1:real) return integer is
    begin
      exit;
    end;
    variable k : integer := 0;
  BEGIN
    k := f1(1.2);
      report ""***FAILED TEST: c08s12b00x00p05n03i01638 - A function must be completed by a return statement""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s12b00x00p05n03i01638arch;
",['FALSE'],1,[':= 0'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 0']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1638.vhd,v 1.2 2001-10-26 16:30:11 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s12b00x00p05n03i01638ent IS
END c08s12b00x00p05n03i01638ent;

ARCHITECTURE c08s12b00x00p05n03i01638arch OF c08s12b00x00p05n03i01638ent IS

BEGIN
  TESTING: PROCESS
    function f1(in1:real) return integer is
    begin
      exit;
    end;
    variable k : integer := 0;
  BEGIN
    k := f1(1.2);
      report ""***FAILED TEST: c08s12b00x00p05n03i01638 - A function must be completed by a return statement""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s12b00x00p05n03i01638arch;
",3162,"As the provided Verilog code does not define explicit inputs and outputs, it's not possible to derive assertions based on the provided criteria. The function ""f1"" does not provide any return values and there is no explicit handling of different sizes of output. Because there are no specified clocks or related components, defining timing related assertions is also not feasible. Please provide a Verilog code snippet with clear inputs, outputs and clock, that would allow generating relevant assertions."
512,2922,Xero-Hige/LuGus-VHDL,"library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity preprocessor_tb is
end entity;

architecture preprocessor_tb_arq of preprocessor_tb is

	signal x_in : std_logic_vector(31 downto 0) := (others => '0');
	signal y_in : std_logic_vector(31 downto 0) := (others => '0');
	signal angle_in : std_logic_vector(31 downto 0) := (others => '0');
	signal x_out : std_logic_vector(31 downto 0) := (others => '0');
	signal y_out : std_logic_vector(31 downto 0) := (others => '0');
	signal angle_out : std_logic_vector(31 downto 0) := (others => '0');

	component preprocessor is
		generic(TOTAL_BITS: integer := 32);
    port(
      x_in: in std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0');
      y_in: in std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0');
      angle_in : in std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0');
      x_out: out std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0');
      y_out: out std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0');
      angle_out: out std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0')
    );
	end component;

begin

	preprocessor_0 : preprocessor
		generic map(TOTAL_BITS => 32)
		port map(
			x_in => x_in,
			y_in	=> y_in,
			angle_in => angle_in,
			x_out => x_out,
			y_out => y_out,
			angle_out => angle_out
		);

	process
		type pattern_type is record
			xi : std_logic_vector(31 downto 0);
			yi : std_logic_vector(31 downto 0);
			ai : std_logic_vector(31 downto 0);
			xo : std_logic_vector(31 downto 0);
			yo : std_logic_vector(31 downto 0);
			ao : std_logic_vector(31 downto 0);
		end record;
		--  The patterns to apply.
		type pattern_array is array (natural range <>) of pattern_type;
		constant patterns : pattern_array := (
			(""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000"",	
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000""),
			(""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000"",	
			 ""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000""),
			(""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000001000101"",	
			 ""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000001000101""),
			(""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000001100000"",	
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000001"",
			 ""00000000000000000000000000000110""),
			(""00000000000000000000000000000000"",
			 ""00000000000000000000000000000001"",
			 ""00000000000000000000000001100000"",	
			 ""11111111111111111111111111111111"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000110""),
			(""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""11111111111111111111111110100000"",	
			 ""00000000000000000000000000000000"",
			 ""11111111111111111111111111111111"",
			 ""11111111111111111111111111111010"")

		);

	begin
		for i in patterns'range loop
			--  Set the inputs.
			x_in <= patterns(i).xi;
			y_in <= patterns(i).yi;
			angle_in <= patterns(i).ai;

			wait for 1 ns;

			assert patterns(i).xo = x_out	 report ""BAD X, GOT: "" & integer'image(to_integer(signed(x_out)));
			assert patterns(i).yo = y_out report ""BAD Y, GOT: "" & integer'image(to_integer(signed(y_out)));
			assert patterns(i).ao = angle_out report ""BAD ANGLE, GOT: "" & integer'image(to_integer(signed(angle_out)));
			--  Check the outputs.
		end loop;
		assert false report ""end of test"" severity note;
		wait;
	end process;
end;
","
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity preprocessor_tb is
end entity;

architecture preprocessor_tb_arq of preprocessor_tb is

	signal x_in : std_logic_vector(31 downto 0) := (others => '0');
	signal y_in : std_logic_vector(31 downto 0) := (others => '0');
	signal angle_in : std_logic_vector(31 downto 0) := (others => '0');
	signal x_out : std_logic_vector(31 downto 0) := (others => '0');
	signal y_out : std_logic_vector(31 downto 0) := (others => '0');
	signal angle_out : std_logic_vector(31 downto 0) := (others => '0');

	component preprocessor is
		generic(TOTAL_BITS: integer := 32);
    port(
      x_in: in std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0');
      y_in: in std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0');
      angle_in : in std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0');
      x_out: out std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0');
      y_out: out std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0');
      angle_out: out std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0')
    );
	end component;

begin

	preprocessor_0 : preprocessor
		generic map(TOTAL_BITS => 32)
		port map(
			x_in => x_in,
			y_in	=> y_in,
			angle_in => angle_in,
			x_out => x_out,
			y_out => y_out,
			angle_out => angle_out
		);

	process
		type pattern_type is record
			xi : std_logic_vector(31 downto 0);
			yi : std_logic_vector(31 downto 0);
			ai : std_logic_vector(31 downto 0);
			xo : std_logic_vector(31 downto 0);
			yo : std_logic_vector(31 downto 0);
			ao : std_logic_vector(31 downto 0);
		end record;
		--  The patterns to apply.
		type pattern_array is array (natural range <>) of pattern_type;
		constant patterns : pattern_array := (
			(""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000"",	
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000""),
			(""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000"",	
			 ""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000""),
			(""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000001000101"",	
			 ""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000001000101""),
			(""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000001100000"",	
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000001"",
			 ""00000000000000000000000000000110""),
			(""00000000000000000000000000000000"",
			 ""00000000000000000000000000000001"",
			 ""00000000000000000000000001100000"",	
			 ""11111111111111111111111111111111"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000110""),
			(""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""11111111111111111111111110100000"",	
			 ""00000000000000000000000000000000"",
			 ""11111111111111111111111111111111"",
			 ""11111111111111111111111111111010"")

		);

	begin
		for i in patterns'range loop
			--  Set the inputs.
			x_in <= patterns(i).xi;
			y_in <= patterns(i).yi;
			angle_in <= patterns(i).ai;

			wait for 1 ns;

			--  Check the outputs.
		end loop;
		wait;
	end process;
end;
","['patterns(i).xo = x_out\t report ""BAD X, GOT: "" & integer\'image(to_integer(signed(x_out)));', 'patterns(i).yo = y_out report ""BAD Y, GOT: "" & integer\'image(to_integer(signed(y_out)));', 'patterns(i).ao = angle_out report ""BAD ANGLE, GOT: "" & integer\'image(to_integer(signed(angle_out)));', 'false report ""end of test"" severity note;']",4,[':= 32)'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 32)']
*Code:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity preprocessor_tb is
end entity;

architecture preprocessor_tb_arq of preprocessor_tb is

	signal x_in : std_logic_vector(31 downto 0) := (others => '0');
	signal y_in : std_logic_vector(31 downto 0) := (others => '0');
	signal angle_in : std_logic_vector(31 downto 0) := (others => '0');
	signal x_out : std_logic_vector(31 downto 0) := (others => '0');
	signal y_out : std_logic_vector(31 downto 0) := (others => '0');
	signal angle_out : std_logic_vector(31 downto 0) := (others => '0');

	component preprocessor is
		generic(TOTAL_BITS: integer := 32);
    port(
      x_in: in std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0');
      y_in: in std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0');
      angle_in : in std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0');
      x_out: out std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0');
      y_out: out std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0');
      angle_out: out std_logic_vector(TOTAL_BITS - 1 downto 0) := (others => '0')
    );
	end component;

begin

	preprocessor_0 : preprocessor
		generic map(TOTAL_BITS => 32)
		port map(
			x_in => x_in,
			y_in	=> y_in,
			angle_in => angle_in,
			x_out => x_out,
			y_out => y_out,
			angle_out => angle_out
		);

	process
		type pattern_type is record
			xi : std_logic_vector(31 downto 0);
			yi : std_logic_vector(31 downto 0);
			ai : std_logic_vector(31 downto 0);
			xo : std_logic_vector(31 downto 0);
			yo : std_logic_vector(31 downto 0);
			ao : std_logic_vector(31 downto 0);
		end record;
		--  The patterns to apply.
		type pattern_array is array (natural range <>) of pattern_type;
		constant patterns : pattern_array := (
			(""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000"",	
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000""),
			(""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000"",	
			 ""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000000""),
			(""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000001000101"",	
			 ""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000001000101""),
			(""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000001100000"",	
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000001"",
			 ""00000000000000000000000000000110""),
			(""00000000000000000000000000000000"",
			 ""00000000000000000000000000000001"",
			 ""00000000000000000000000001100000"",	
			 ""11111111111111111111111111111111"",
			 ""00000000000000000000000000000000"",
			 ""00000000000000000000000000000110""),
			(""00000000000000000000000000000001"",
			 ""00000000000000000000000000000000"",
			 ""11111111111111111111111110100000"",	
			 ""00000000000000000000000000000000"",
			 ""11111111111111111111111111111111"",
			 ""11111111111111111111111111111010"")

		);

	begin
		for i in patterns'range loop
			--  Set the inputs.
			x_in <= patterns(i).xi;
			y_in <= patterns(i).yi;
			angle_in <= patterns(i).ai;

			wait for 1 ns;

			--  Check the outputs.
		end loop;
		wait;
	end process;
end;
",4950,"[
[""preprocessor_0"", ""x_in"", ""TOTAL_BITS-1"", ""Assert that x_in input can accept all necessary bits""],
[""preprocessor_0"", ""y_in"", ""TOTAL_BITS-1"", ""Assert that y_in input can accept all necessary bits""],
[""preprocessor_0"", ""angle_in"", ""TOTAL_BITS-1"", ""Assert that angle_in input can accept all necessary bits""],
[""preprocessor_0"", ""x_out"", ""TOTAL_BITS-1"", ""Assert that x_out output is of the right size""],
[""preprocessor_0"", ""y_out"", ""TOTAL_BITS-1"", ""Assert that y_out output is of the right size""],
[""preprocessor_0"", ""angle_out"", ""TOTAL_BITS-1"", ""Assert that angle_out output is of the right size""]
]"
513,2931,APastorG/APG,"/***************************************************************************************************
/
/  Author:     Antonio Pastor González
/  ¯¯¯¯¯¯
/
/  Date:       
/  ¯¯¯¯
/
/  Version:    
/  ¯¯¯¯¯¯¯
/
/  Notes:
/  ¯¯¯¯¯
/     This design makes use of some features from VHDL-2008, all of which have been implemented by
/  Altera and Xilinx in their software.
/     A 3 space tab is used throughout the document
/
/
/  Description:
/  ¯¯¯¯¯¯¯¯¯¯¯
/
 **************************************************************************************************/

library ieee;
   use ieee.numeric_std.all;
   use ieee.std_logic_1164.all;
   use ieee.math_real.all;

library work;
   use work.fixed_float_types.all;
   use work.fixed_generic_pkg.all;
   use work.common_data_types_pkg.all;
   use work.common_pkg.all;

/*================================================================================================*/
/*================================================================================================*/
/*================================================================================================*/

entity butterfly_core_s is
	
	generic(
      SPEED_opt    : T_speed;
      EXTEND_opt   : boolean;
      RANGE1_LEFT  : positive;
      RANGE1_RIGHT : positive;
      RANGE2_LEFT  : integer;
      RANGE2_RIGHT : integer
	);

   port(
      clk    : in  std_ulogic;
      input  : in  u_sfixed_v;
      output : out u_sfixed_v(RANGE1_LEFT to RANGE1_RIGHT)(ite(EXTEND_opt,
                                                               RANGE2_LEFT+1,
                                                               RANGE2_LEFT)
                                                           downto
                                                           RANGE2_RIGHT)
   );

end entity;

/*================================================================================================*/
/*================================================================================================*/
/*================================================================================================*/

architecture butterfly_core_s_1 of butterfly_core_s is

/*================================================================================================*/
/*================================================================================================*/

begin

   assert integer(2.0**log2(real(input'length))) = 2**integer(log2(real(input'length)))
      report ""ERROR in module butterfly: the size of the input signal is not a power of 2""
      severity error;

   generate_butterfly:
   for i in output'low  to output'low+input'length/2-1 generate
      begin
         generate_pipeline:
         if is_pipelined(positions => 1,
                         speed => SPEED_opt,
                         position => 1) generate
            begin
               process (clk) is
               begin
                  if rising_edge(clk) then
                     output(i) <= resize(input(i) + input(i+input'length/2), output(i));
                     output(i+input'length/2) <= resize(input(i) - input(i+input'length/2), output(i));
                  end if;
               end process;
            end;
         else generate
            begin
               output(i) <= resize(input(i) + input(i+input'length/2), output(i));
               output(i+input'length/2) <= resize(input(i) - input(i+input'length/2), output(i));
            end;
         end generate;
      end;
   end generate;


end architecture;","
/***************************************************************************************************
/
/  Author:     Antonio Pastor González
/  ¯¯¯¯¯¯
/
/  Date:       
/  ¯¯¯¯
/
/  Version:    
/  ¯¯¯¯¯¯¯
/
/  Notes:
/  ¯¯¯¯¯
/     This design makes use of some features from VHDL-2008, all of which have been implemented by
/  Altera and Xilinx in their software.
/     A 3 space tab is used throughout the document
/
/
/  Description:
/  ¯¯¯¯¯¯¯¯¯¯¯
/
 **************************************************************************************************/

library ieee;
   use ieee.numeric_std.all;
   use ieee.std_logic_1164.all;
   use ieee.math_real.all;

library work;
   use work.fixed_float_types.all;
   use work.fixed_generic_pkg.all;
   use work.common_data_types_pkg.all;
   use work.common_pkg.all;

/*================================================================================================*/
/*================================================================================================*/
/*================================================================================================*/

entity butterfly_core_s is
	
	generic(
      SPEED_opt    : T_speed;
      EXTEND_opt   : boolean;
      RANGE1_LEFT  : positive;
      RANGE1_RIGHT : positive;
      RANGE2_LEFT  : integer;
      RANGE2_RIGHT : integer
	);

   port(
      clk    : in  std_ulogic;
      input  : in  u_sfixed_v;
      output : out u_sfixed_v(RANGE1_LEFT to RANGE1_RIGHT)(ite(EXTEND_opt,
                                                               RANGE2_LEFT+1,
                                                               RANGE2_LEFT)
                                                           downto
                                                           RANGE2_RIGHT)
   );

end entity;

/*================================================================================================*/
/*================================================================================================*/
/*================================================================================================*/

architecture butterfly_core_s_1 of butterfly_core_s is

/*================================================================================================*/
/*================================================================================================*/

begin

      report ""ERROR in module butterfly: the size of the input signal is not a power of 2""
      severity error;

   generate_butterfly:
   for i in output'low  to output'low+input'length/2-1 generate
      begin
         generate_pipeline:
         if is_pipelined(positions => 1,
                         speed => SPEED_opt,
                         position => 1) generate
            begin
               process (clk) is
               begin
                  if rising_edge(clk) then
                     output(i) <= resize(input(i) + input(i+input'length/2), output(i));
                     output(i+input'length/2) <= resize(input(i) - input(i+input'length/2), output(i));
                  end if;
               end process;
            end;
         else generate
            begin
               output(i) <= resize(input(i) + input(i+input'length/2), output(i));
               output(i+input'length/2) <= resize(input(i) - input(i+input'length/2), output(i));
            end;
         end generate;
      end;
   end generate;


end architecture;","[""integer(2.0**log2(real(input'length))) = 2**integer(log2(real(input'length)))""]",1,[')'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[')']
*Code:

/***************************************************************************************************
/
/  Author:     Antonio Pastor González
/  ¯¯¯¯¯¯
/
/  Date:       
/  ¯¯¯¯
/
/  Version:    
/  ¯¯¯¯¯¯¯
/
/  Notes:
/  ¯¯¯¯¯
/     This design makes use of some features from VHDL-2008, all of which have been implemented by
/  Altera and Xilinx in their software.
/     A 3 space tab is used throughout the document
/
/
/  Description:
/  ¯¯¯¯¯¯¯¯¯¯¯
/
 **************************************************************************************************/

library ieee;
   use ieee.numeric_std.all;
   use ieee.std_logic_1164.all;
   use ieee.math_real.all;

library work;
   use work.fixed_float_types.all;
   use work.fixed_generic_pkg.all;
   use work.common_data_types_pkg.all;
   use work.common_pkg.all;

/*================================================================================================*/
/*================================================================================================*/
/*================================================================================================*/

entity butterfly_core_s is
	
	generic(
      SPEED_opt    : T_speed;
      EXTEND_opt   : boolean;
      RANGE1_LEFT  : positive;
      RANGE1_RIGHT : positive;
      RANGE2_LEFT  : integer;
      RANGE2_RIGHT : integer
	);

   port(
      clk    : in  std_ulogic;
      input  : in  u_sfixed_v;
      output : out u_sfixed_v(RANGE1_LEFT to RANGE1_RIGHT)(ite(EXTEND_opt,
                                                               RANGE2_LEFT+1,
                                                               RANGE2_LEFT)
                                                           downto
                                                           RANGE2_RIGHT)
   );

end entity;

/*================================================================================================*/
/*================================================================================================*/
/*================================================================================================*/

architecture butterfly_core_s_1 of butterfly_core_s is

/*================================================================================================*/
/*================================================================================================*/

begin

      report ""ERROR in module butterfly: the size of the input signal is not a power of 2""
      severity error;

   generate_butterfly:
   for i in output'low  to output'low+input'length/2-1 generate
      begin
         generate_pipeline:
         if is_pipelined(positions => 1,
                         speed => SPEED_opt,
                         position => 1) generate
            begin
               process (clk) is
               begin
                  if rising_edge(clk) then
                     output(i) <= resize(input(i) + input(i+input'length/2), output(i));
                     output(i+input'length/2) <= resize(input(i) - input(i+input'length/2), output(i));
                  end if;
               end process;
            end;
         else generate
            begin
               output(i) <= resize(input(i) + input(i+input'length/2), output(i));
               output(i+input'length/2) <= resize(input(i) - input(i+input'length/2), output(i));
            end;
         end generate;
      end;
   end generate;


end architecture;",4914,"[1, 'clk', True, ""CLK should be True at the next clock cycle to indicate an active state""],
[1, 'input', 'input\'length', ""Ensure the input is of expected size at the next clock cycle""],
[1, 'output', 'output\'range', ""Ensure the output is within the range at the next clock cycle""],
[1, 'input(i)', 'output(i)', ""The input(i) should be resized to match output(i) at the next clock cycle""],
[1, 'input(i+input\'length/2)', 'output(i+input\'length/2)', ""The input(i+input'length/2) should be resized to match output(i+input'length/2) at the next clock cycle""]"
514,2932,peteut/ghdl,"
-- Copyright (C) Clifton Labs.  All rights reserved.

-- CLIFTON LABS MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE
-- SUITABILITY OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT
-- NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
-- PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  CLIFTON LABS SHALL NOT BE
-- LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, RESULT
-- OF USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.

-- By using or copying this Software, Licensee agrees to abide by the
-- intellectual property laws, and all other applicable laws of the U.S.,
-- and the terms of this license.

-- You may modify, distribute, and use the software contained in this
-- package under the terms of the GNU General Public License as published
-- by the Free Software Foundation; version 2 of the License.

-- You should have received a copy of the GNU General Public License along
-- with this software; if not, write to the Free Software Foundation, Inc.,
-- 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

entity integer_array_write is
end integer_array_write;

architecture test0 of integer_array_write is

  type integer_array_type is array (0 to 9) of integer;

  constant integer_array : integer_array_type := (0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
  type integer_array_file is file of integer_array_type;

begin
  doit: process
    file fileout : integer_array_file open write_mode is ""integer_array_write.out"";
  begin
    write(fileout, integer_array);

    assert false
      report ""PASSED TEST: integer_array_write.""
      severity note;
    wait;
  end process;

end test0;
","

-- Copyright (C) Clifton Labs.  All rights reserved.

-- CLIFTON LABS MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE
-- SUITABILITY OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT
-- NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
-- PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  CLIFTON LABS SHALL NOT BE
-- LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, RESULT
-- OF USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.

-- By using or copying this Software, Licensee agrees to abide by the
-- intellectual property laws, and all other applicable laws of the U.S.,
-- and the terms of this license.

-- You may modify, distribute, and use the software contained in this
-- package under the terms of the GNU General Public License as published
-- by the Free Software Foundation; version 2 of the License.

-- You should have received a copy of the GNU General Public License along
-- with this software; if not, write to the Free Software Foundation, Inc.,
-- 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

entity integer_array_write is
end integer_array_write;

architecture test0 of integer_array_write is

  type integer_array_type is array (0 to 9) of integer;

  constant integer_array : integer_array_type := (0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
  type integer_array_file is file of integer_array_type;

begin
  doit: process
    file fileout : integer_array_file open write_mode is ""integer_array_write.out"";
  begin
    write(fileout, integer_array);

      report ""PASSED TEST: integer_array_write.""
      severity note;
    wait;
  end process;

end test0;
",['false'],1,"['laws,']",1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
['laws,']
*Code:


-- Copyright (C) Clifton Labs.  All rights reserved.

-- CLIFTON LABS MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE
-- SUITABILITY OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT
-- NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
-- PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  CLIFTON LABS SHALL NOT BE
-- LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, RESULT
-- OF USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.

-- By using or copying this Software, Licensee agrees to abide by the
-- intellectual property laws, and all other applicable laws of the U.S.,
-- and the terms of this license.

-- You may modify, distribute, and use the software contained in this
-- package under the terms of the GNU General Public License as published
-- by the Free Software Foundation; version 2 of the License.

-- You should have received a copy of the GNU General Public License along
-- with this software; if not, write to the Free Software Foundation, Inc.,
-- 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

entity integer_array_write is
end integer_array_write;

architecture test0 of integer_array_write is

  type integer_array_type is array (0 to 9) of integer;

  constant integer_array : integer_array_type := (0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
  type integer_array_file is file of integer_array_type;

begin
  doit: process
    file fileout : integer_array_file open write_mode is ""integer_array_write.out"";
  begin
    write(fileout, integer_array);

      report ""PASSED TEST: integer_array_write.""
      severity note;
    wait;
  end process;

end test0;
",3123,"['doit', integer_array, None, ""Check if all necessary integer inputs are present for the doit process""],
['doit', integer_array_file, None, ""Check if outputs are proper size for the doit process""]"
515,2942,hiyuh/nvc,"entity e is
end entity;

architecture a of e is
    signal x : integer := -3 * 4 + 2;
    type t is range -5 to 11 - 3;
    constant c : integer := +4 + 1;
    signal y : t;
    type int_array is array (integer range <>) of integer;
    constant a1 : int_array(1 to 5) := (1, 2, 3, 4, 5);
    constant a2 : int_array(1 to 7) := (2 to 3 => 6, others => 5);
    constant a3 : int_array(1 to 9) := (8 => 24, others => 0);
    constant a4 : int_array(5 downto 1) := (1, 2, 3, 4, 5);
    constant a5 : int_array(5 downto 1) := (5 downto 3 => -1, others => 1);
begin

    process is
        variable b : boolean;
    begin
        x <= c / 2;
        y <= t'high;
        y <= t'left;
        b := t'right = 8;
        b := (t'right - t'left) = 2;
        b := t'high /= 2;
        b := true and true;
        b := true and false;
        b := true or false;
        b := true xor true;
        b := not true;
        b := not false;
        b := true xnor false;
        b := false nand false;
        b := false nor true;
        b := 7 > 5 and 6 < 2;
        x <= a1(2);
        x <= a2(1);
        x <= a2(3);
        x <= a3(8);
        x <= a1'length;
        x <= a4(2);
        x <= a5(4);
        x <= 2 ** 4;
    end process;

    process is
    begin
        if true then
            x <= 1;
        end if;
        if false then
            x <= 5;
        end if;
        if false then
            null;
        else
            x <= 5;
        end if;
        while false loop
            null;
        end loop;
        if true then
            x <= 1;
            x <= 5;
            null;
        end if;
    end process;

    process is
        variable r : real;
        variable b : boolean;
    begin
        r := 1.0 + 0.0;
        r := 1.5 * 4.0;
        r := 2.0 / 2.0;
        b := 4.6 > 1.2;
    end process;

    process
        variable k  : time;
    begin
    end process;

    process
        type int2_vec is array (66 to 67) of integer;
    begin
        assert a1'length = 5;
        assert a1'low(1) = 1;
        assert a1'high(1) = 5;
        assert a1'left = 1;
        assert a1'right = 5;
        assert int2_vec'length = 2;
        assert int2_vec'low = 66;
    end process;

    process is
    begin
        case 1 is
            when 1 => null;
            when others => report ""bang"";
        end case;
    end process;

    process is
        variable r : real;
    begin
        r := 1.5 * 2;
        r := 3 * 0.2;
        r := 5.0 / 2;
    end process;

    process is
        constant one : bit := '1';
        variable b   : boolean;
    begin
        b := one = '1';
        b := '0' /= one;
    end process;

end architecture;
","
entity e is
end entity;

architecture a of e is
    signal x : integer := -3 * 4 + 2;
    type t is range -5 to 11 - 3;
    constant c : integer := +4 + 1;
    signal y : t;
    type int_array is array (integer range <>) of integer;
    constant a1 : int_array(1 to 5) := (1, 2, 3, 4, 5);
    constant a2 : int_array(1 to 7) := (2 to 3 => 6, others => 5);
    constant a3 : int_array(1 to 9) := (8 => 24, others => 0);
    constant a4 : int_array(5 downto 1) := (1, 2, 3, 4, 5);
    constant a5 : int_array(5 downto 1) := (5 downto 3 => -1, others => 1);
begin

    process is
        variable b : boolean;
    begin
        x <= c / 2;
        y <= t'high;
        y <= t'left;
        b := t'right = 8;
        b := (t'right - t'left) = 2;
        b := t'high /= 2;
        b := true and true;
        b := true and false;
        b := true or false;
        b := true xor true;
        b := not true;
        b := not false;
        b := true xnor false;
        b := false nand false;
        b := false nor true;
        b := 7 > 5 and 6 < 2;
        x <= a1(2);
        x <= a2(1);
        x <= a2(3);
        x <= a3(8);
        x <= a1'length;
        x <= a4(2);
        x <= a5(4);
        x <= 2 ** 4;
    end process;

    process is
    begin
        if true then
            x <= 1;
        end if;
        if false then
            x <= 5;
        end if;
        if false then
            null;
        else
            x <= 5;
        end if;
        while false loop
            null;
        end loop;
        if true then
            x <= 1;
            x <= 5;
            null;
        end if;
    end process;

    process is
        variable r : real;
        variable b : boolean;
    begin
        r := 1.0 + 0.0;
        r := 1.5 * 4.0;
        r := 2.0 / 2.0;
        b := 4.6 > 1.2;
    end process;

    process
        variable k  : time;
    begin
    end process;

    process
        type int2_vec is array (66 to 67) of integer;
    begin
    end process;

    process is
    begin
        case 1 is
            when 1 => null;
            when others => report ""bang"";
        end case;
    end process;

    process is
        variable r : real;
    begin
        r := 1.5 * 2;
        r := 3 * 0.2;
        r := 5.0 / 2;
    end process;

    process is
        constant one : bit := '1';
        variable b   : boolean;
    begin
        b := one = '1';
        b := '0' /= one;
    end process;

end architecture;
","[""a1'length = 5;"", ""a1'low(1) = 1;"", ""a1'high(1) = 5;"", ""a1'left = 1;"", ""a1'right = 5;"", ""int2_vec'length = 2;"", ""int2_vec'low = 66;""]",7,"[':= +4 + 1', ':= -3 * 4 + 2', 'range <>) of integer']",3,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= +4 + 1', ':= -3 * 4 + 2', 'range <>) of integer']
*Code:

entity e is
end entity;

architecture a of e is
    signal x : integer := -3 * 4 + 2;
    type t is range -5 to 11 - 3;
    constant c : integer := +4 + 1;
    signal y : t;
    type int_array is array (integer range <>) of integer;
    constant a1 : int_array(1 to 5) := (1, 2, 3, 4, 5);
    constant a2 : int_array(1 to 7) := (2 to 3 => 6, others => 5);
    constant a3 : int_array(1 to 9) := (8 => 24, others => 0);
    constant a4 : int_array(5 downto 1) := (1, 2, 3, 4, 5);
    constant a5 : int_array(5 downto 1) := (5 downto 3 => -1, others => 1);
begin

    process is
        variable b : boolean;
    begin
        x <= c / 2;
        y <= t'high;
        y <= t'left;
        b := t'right = 8;
        b := (t'right - t'left) = 2;
        b := t'high /= 2;
        b := true and true;
        b := true and false;
        b := true or false;
        b := true xor true;
        b := not true;
        b := not false;
        b := true xnor false;
        b := false nand false;
        b := false nor true;
        b := 7 > 5 and 6 < 2;
        x <= a1(2);
        x <= a2(1);
        x <= a2(3);
        x <= a3(8);
        x <= a1'length;
        x <= a4(2);
        x <= a5(4);
        x <= 2 ** 4;
    end process;

    process is
    begin
        if true then
            x <= 1;
        end if;
        if false then
            x <= 5;
        end if;
        if false then
            null;
        else
            x <= 5;
        end if;
        while false loop
            null;
        end loop;
        if true then
            x <= 1;
            x <= 5;
            null;
        end if;
    end process;

    process is
        variable r : real;
        variable b : boolean;
    begin
        r := 1.0 + 0.0;
        r := 1.5 * 4.0;
        r := 2.0 / 2.0;
        b := 4.6 > 1.2;
    end process;

    process
        variable k  : time;
    begin
    end process;

    process
        type int2_vec is array (66 to 67) of integer;
    begin
    end process;

    process is
    begin
        case 1 is
            when 1 => null;
            when others => report ""bang"";
        end case;
    end process;

    process is
        variable r : real;
    begin
        r := 1.5 * 2;
        r := 3 * 0.2;
        r := 5.0 / 2;
    end process;

    process is
        constant one : bit := '1';
        variable b   : boolean;
    begin
        b := one = '1';
        b := '0' /= one;
    end process;

end architecture;
",3983,"[['x', int, None, 'x is an integer and thus should only hold integer values'],
 ['b', bool, None, 'b is a boolean and should only hold True or False'],
 ['r', float, None, 'r is a real number and should be able to hold floating point values'],
 ['c', 5, None, 'c is a constant that is set to 5'],
 ['t', None, None, 't should always be a type in the range -5 to 11 - 3'],
 ['y', 't', None, 'y should always be a value which is a valid member of type t'],
 ['a1', list, None, 'a1 should be an array of integers from 1 to 5'],
 ['a2', list, None, 'a2 should be an array of integers with specific values set and others defaulting to 5'],
 ['a3', list, None, 'a3 should be an array of integers with 8 set to 24 and others defaulting to 0'],
 ['a4', list, None, 'a4 should be an array of integers from 5 downto 1'],
 ['a5', list, None, 'a5 should be an array of integers from 5 downto 1 with values from 5 downto 3 set to -1 and others defaulting to 1'],
 ['b', bool, None, 'b should hold the result of logical operations on booleans'],
 ['x', 'c/2', 't\'high', 'x should be able to hold various assigned values including half of c or the highest value of t'],
 ['k', 'time', None, 'k should be able to hold time values'],
 ['int2_vec', list, None, 'int2_vec should be an array of integers from 66 to 67'],
 ['one', 'bit', None, 'one should be constant bit value 1'],
 ['b', bool, None, 'b should hold the comparison result between bit and character']]"
516,2943,daniw/add,"-------------------------------------------------------------------------------
-- Company    :  HSLU
-- Engineer   :  Gai, Waj
-- 
-- Create Date:  28-Mar-11 
-- Project    :  RT Video Lab 1: Exercise 1
-- Description:  Testbench for 5-tap FIR filter
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library std; use std.textio.all;
             
entity fir_1d_tb IS
end fir_1d_tb;

architecture behavior of fir_1d_tb is

  -- Component Declaration for the Unit Under Test (UUT)
  component fir_1d_dir is
    generic
      (IN_DW, OUT_DW, COEF_DW, TAPS, DELAY : integer);
  port
    (ce_1     : in  std_logic;          -- clock enable
     clk_1    : in  std_logic;          -- clock
     load     : in  std_logic;          -- load coeff pulse
     coef     : in  std_logic_vector;   -- coefficients
     din      : in  std_logic_vector;   -- data input
     out_data : out std_logic_vector    -- filtered output data
     );
  end component;
    
  -- clock frequency definition
  constant clk_freq : real := 100.0;                  -- 100 MHz
  constant t_clk    : time := 1000.0/clk_freq * 1 ns; -- one clock period
       
  -- define delays for timing-simulation
  constant t_stim : time := 0.25*t_clk; -- delay time for stimuli application
  constant t_prop : time := 0.25*t_clk; -- propagation delay for UUT mimic

  -- design parameters
  constant IN_DW 	: integer := 8;
  constant OUT_DW	: integer := 19;
  constant COEF_DW: integer := 7;
  constant TAPS	: integer := 5;
  constant DELAY	: integer := 8;  -- adapt to adjust filter latency!!!

  -- inputs signals
  signal clk      : std_logic := '0';
  signal load 	  : std_logic := '0';
  signal coef	  : std_logic_vector(COEF_DW-1 downto 0) := (others => '0');
  signal din 	  : std_logic_vector(IN_DW-1 downto 0) := (others => '0');
  
  -- outputs signals
  signal out_data : std_logic_vector(OUT_DW-1 downto 0) := (others => '0');

  -- local testbench control signals
  signal err_cnt : natural := 0;

  -- I/O files
  -- Expeceted responses are generated for the middle row of the corresponding
  -- filter mask, which correspnds to the following coefficients:
  -- Filter        : b0   b1   b2   b3   b4
  ------------------------------------------
  -- 1_Identity    :  0    0    1    0    0
  -- 2_Edge        :  0   -1    8   -1    0
  -- 3_SobelX      :  0    2    0   -2    0
  -- 4_SobelY      :  0    0    0    0    0  
  -- 5_SobelXY     :  0   -1    0    1    0
  -- 6_Blur        :  1    0    0    0    1 
  -- 7_Smooth      :  1    5   44    5    1  
  -- 8_Sharpen     :  0   -2   32   -2    0
  -- 9_Gaussian    :  2    4    8    4    2
  ------------------------------------------
  constant mask_type : string := ""9_Gaussian"";
  file f_stimuli   : text is in ""../1x5_Filter/"" & mask_type & ""/FIR_IN.txt"";
  file f_exp_resp  : text is in ""../1x5_Filter/"" & mask_type & ""/FIR_OUT.txt"";
  file f_act_resp  : text is out ""../1x5_Filter/"" & mask_type & ""/FIR_VHDL_OUT.txt"";
                                  
begin

  -- Instantiate the Unit Under Test 
  uut : fir_1d_dir
    generic map (
      IN_DW   => IN_DW,
      OUT_DW  => OUT_DW,
      COEF_DW => COEF_DW,
      TAPS    => TAPS,
      DELAY   => DELAY
      )
    port map (
      ce_1     => '1',
      clk_1    => clk,
      load     => load,
      coef     => coef,
      din      => din,
      out_data => out_data
      );
  
  -- Clock generation
  p_clk :process
  begin
    wait for t_clk/2;
    clk <= not clk;
  end process;

  -- apply stimuli to UUT
  p_stim:process(clk)
    variable inline : line;
    variable char   : character;
  begin
    if clk'event and clk = '1' then
      if not endfile(f_stimuli) then
        readline(f_stimuli,inline);
        for k in IN_DW-1 downto 0 loop
          read(inline,char);
          if char = '0' then
            din(k) <= '0' after t_stim; 
          else
            din(k) <= '1' after t_stim;
          end if;
        end loop;
      else
        -- end of simulation
        assert false report ""******** End of simulation : "" &
                            ""Total Number of Mismatches detected = "" &
                            integer'image(err_cnt) &
                            "" ********""
          severity failure;
      end if;
    end if;
  end process;

  -- compare expected with actual responses and write output file
  p_check: process(clk)
    variable line_exp, line_act : line;
    variable str_exp, str_act   : string(OUT_DW downto 1);
    variable do_check : boolean;
  begin
    if clk'event and clk = '1' then
      do_check := true;
      -- read expected value from file
      readline(f_exp_resp,line_exp);
      for k in OUT_DW-1 downto 0 loop
        -- get all bits in actual output
        if out_data(k) = '0' then
          str_act(k+1) := '0';
        elsif out_data(k) = '1' then
          str_act(k+1) := '1';
        else
          -- skip checking when output data is 'U'
          do_check := false;
        end if;
        write(line_act,str_act(k+1));
        -- get all bits in expected output
        read(line_exp,str_exp(k+1));
      end loop;
      -- write actual value to file
      writeline(f_act_resp,line_act);
      -- compare actual and expected output vector
      if do_check and not (str_exp = str_act) then
        assert false report ""expected: "" & str_exp & ""  actual: "" & str_act severity note;
        err_cnt <= err_cnt + 1;
      end if;
    end if;
  end process;

end;
","
-------------------------------------------------------------------------------
-- Company    :  HSLU
-- Engineer   :  Gai, Waj
-- 
-- Create Date:  28-Mar-11 
-- Project    :  RT Video Lab 1: Exercise 1
-- Description:  Testbench for 5-tap FIR filter
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library std; use std.textio.all;
             
entity fir_1d_tb IS
end fir_1d_tb;

architecture behavior of fir_1d_tb is

  -- Component Declaration for the Unit Under Test (UUT)
  component fir_1d_dir is
    generic
      (IN_DW, OUT_DW, COEF_DW, TAPS, DELAY : integer);
  port
    (ce_1     : in  std_logic;          -- clock enable
     clk_1    : in  std_logic;          -- clock
     load     : in  std_logic;          -- load coeff pulse
     coef     : in  std_logic_vector;   -- coefficients
     din      : in  std_logic_vector;   -- data input
     out_data : out std_logic_vector    -- filtered output data
     );
  end component;
    
  -- clock frequency definition
  constant clk_freq : real := 100.0;                  -- 100 MHz
  constant t_clk    : time := 1000.0/clk_freq * 1 ns; -- one clock period
       
  -- define delays for timing-simulation
  constant t_stim : time := 0.25*t_clk; -- delay time for stimuli application
  constant t_prop : time := 0.25*t_clk; -- propagation delay for UUT mimic

  -- design parameters
  constant IN_DW 	: integer := 8;
  constant OUT_DW	: integer := 19;
  constant COEF_DW: integer := 7;
  constant TAPS	: integer := 5;
  constant DELAY	: integer := 8;  -- adapt to adjust filter latency!!!

  -- inputs signals
  signal clk      : std_logic := '0';
  signal load 	  : std_logic := '0';
  signal coef	  : std_logic_vector(COEF_DW-1 downto 0) := (others => '0');
  signal din 	  : std_logic_vector(IN_DW-1 downto 0) := (others => '0');
  
  -- outputs signals
  signal out_data : std_logic_vector(OUT_DW-1 downto 0) := (others => '0');

  -- local testbench control signals
  signal err_cnt : natural := 0;

  -- I/O files
  -- Expeceted responses are generated for the middle row of the corresponding
  -- filter mask, which correspnds to the following coefficients:
  -- Filter        : b0   b1   b2   b3   b4
  ------------------------------------------
  -- 1_Identity    :  0    0    1    0    0
  -- 2_Edge        :  0   -1    8   -1    0
  -- 3_SobelX      :  0    2    0   -2    0
  -- 4_SobelY      :  0    0    0    0    0  
  -- 5_SobelXY     :  0   -1    0    1    0
  -- 6_Blur        :  1    0    0    0    1 
  -- 7_Smooth      :  1    5   44    5    1  
  -- 8_Sharpen     :  0   -2   32   -2    0
  -- 9_Gaussian    :  2    4    8    4    2
  ------------------------------------------
  constant mask_type : string := ""9_Gaussian"";
  file f_stimuli   : text is in ""../1x5_Filter/"" & mask_type & ""/FIR_IN.txt"";
  file f_exp_resp  : text is in ""../1x5_Filter/"" & mask_type & ""/FIR_OUT.txt"";
  file f_act_resp  : text is out ""../1x5_Filter/"" & mask_type & ""/FIR_VHDL_OUT.txt"";
                                  
begin

  -- Instantiate the Unit Under Test 
  uut : fir_1d_dir
    generic map (
      IN_DW   => IN_DW,
      OUT_DW  => OUT_DW,
      COEF_DW => COEF_DW,
      TAPS    => TAPS,
      DELAY   => DELAY
      )
    port map (
      ce_1     => '1',
      clk_1    => clk,
      load     => load,
      coef     => coef,
      din      => din,
      out_data => out_data
      );
  
  -- Clock generation
  p_clk :process
  begin
    wait for t_clk/2;
    clk <= not clk;
  end process;

  -- apply stimuli to UUT
  p_stim:process(clk)
    variable inline : line;
    variable char   : character;
  begin
    if clk'event and clk = '1' then
      if not endfile(f_stimuli) then
        readline(f_stimuli,inline);
        for k in IN_DW-1 downto 0 loop
          read(inline,char);
          if char = '0' then
            din(k) <= '0' after t_stim; 
          else
            din(k) <= '1' after t_stim;
          end if;
        end loop;
      else
        -- end of simulation
                            ""Total Number of Mismatches detected = "" &
                            integer'image(err_cnt) &
                            "" ********""
          severity failure;
      end if;
    end if;
  end process;

  -- compare expected with actual responses and write output file
  p_check: process(clk)
    variable line_exp, line_act : line;
    variable str_exp, str_act   : string(OUT_DW downto 1);
    variable do_check : boolean;
  begin
    if clk'event and clk = '1' then
      do_check := true;
      -- read expected value from file
      readline(f_exp_resp,line_exp);
      for k in OUT_DW-1 downto 0 loop
        -- get all bits in actual output
        if out_data(k) = '0' then
          str_act(k+1) := '0';
        elsif out_data(k) = '1' then
          str_act(k+1) := '1';
        else
          -- skip checking when output data is 'U'
          do_check := false;
        end if;
        write(line_act,str_act(k+1));
        -- get all bits in expected output
        read(line_exp,str_exp(k+1));
      end loop;
      -- write actual value to file
      writeline(f_act_resp,line_act);
      -- compare actual and expected output vector
      if do_check and not (str_exp = str_act) then
        err_cnt <= err_cnt + 1;
      end if;
    end if;
  end process;

end;
","['false report ""******** End of simulation : "" &', 'false report ""expected: "" & str_exp & ""  actual: "" & str_act severity note;']",2,"[':= 8', ':= 7', ':= 19', ':= 1000.0/clk_freq * 1 ns', ':= 5', ':= 100.0', ':= 0.25*t_clk']",7,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 8', ':= 7', ':= 19', ':= 1000.0/clk_freq * 1 ns', ':= 5', ':= 100.0', ':= 0.25*t_clk']
*Code:

-------------------------------------------------------------------------------
-- Company    :  HSLU
-- Engineer   :  Gai, Waj
-- 
-- Create Date:  28-Mar-11 
-- Project    :  RT Video Lab 1: Exercise 1
-- Description:  Testbench for 5-tap FIR filter
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library std; use std.textio.all;
             
entity fir_1d_tb IS
end fir_1d_tb;

architecture behavior of fir_1d_tb is

  -- Component Declaration for the Unit Under Test (UUT)
  component fir_1d_dir is
    generic
      (IN_DW, OUT_DW, COEF_DW, TAPS, DELAY : integer);
  port
    (ce_1     : in  std_logic;          -- clock enable
     clk_1    : in  std_logic;          -- clock
     load     : in  std_logic;          -- load coeff pulse
     coef     : in  std_logic_vector;   -- coefficients
     din      : in  std_logic_vector;   -- data input
     out_data : out std_logic_vector    -- filtered output data
     );
  end component;
    
  -- clock frequency definition
  constant clk_freq : real := 100.0;                  -- 100 MHz
  constant t_clk    : time := 1000.0/clk_freq * 1 ns; -- one clock period
       
  -- define delays for timing-simulation
  constant t_stim : time := 0.25*t_clk; -- delay time for stimuli application
  constant t_prop : time := 0.25*t_clk; -- propagation delay for UUT mimic

  -- design parameters
  constant IN_DW 	: integer := 8;
  constant OUT_DW	: integer := 19;
  constant COEF_DW: integer := 7;
  constant TAPS	: integer := 5;
  constant DELAY	: integer := 8;  -- adapt to adjust filter latency!!!

  -- inputs signals
  signal clk      : std_logic := '0';
  signal load 	  : std_logic := '0';
  signal coef	  : std_logic_vector(COEF_DW-1 downto 0) := (others => '0');
  signal din 	  : std_logic_vector(IN_DW-1 downto 0) := (others => '0');
  
  -- outputs signals
  signal out_data : std_logic_vector(OUT_DW-1 downto 0) := (others => '0');

  -- local testbench control signals
  signal err_cnt : natural := 0;

  -- I/O files
  -- Expeceted responses are generated for the middle row of the corresponding
  -- filter mask, which correspnds to the following coefficients:
  -- Filter        : b0   b1   b2   b3   b4
  ------------------------------------------
  -- 1_Identity    :  0    0    1    0    0
  -- 2_Edge        :  0   -1    8   -1    0
  -- 3_SobelX      :  0    2    0   -2    0
  -- 4_SobelY      :  0    0    0    0    0  
  -- 5_SobelXY     :  0   -1    0    1    0
  -- 6_Blur        :  1    0    0    0    1 
  -- 7_Smooth      :  1    5   44    5    1  
  -- 8_Sharpen     :  0   -2   32   -2    0
  -- 9_Gaussian    :  2    4    8    4    2
  ------------------------------------------
  constant mask_type : string := ""9_Gaussian"";
  file f_stimuli   : text is in ""../1x5_Filter/"" & mask_type & ""/FIR_IN.txt"";
  file f_exp_resp  : text is in ""../1x5_Filter/"" & mask_type & ""/FIR_OUT.txt"";
  file f_act_resp  : text is out ""../1x5_Filter/"" & mask_type & ""/FIR_VHDL_OUT.txt"";
                                  
begin

  -- Instantiate the Unit Under Test 
  uut : fir_1d_dir
    generic map (
      IN_DW   => IN_DW,
      OUT_DW  => OUT_DW,
      COEF_DW => COEF_DW,
      TAPS    => TAPS,
      DELAY   => DELAY
      )
    port map (
      ce_1     => '1',
      clk_1    => clk,
      load     => load,
      coef     => coef,
      din      => din,
      out_data => out_data
      );
  
  -- Clock generation
  p_clk :process
  begin
    wait for t_clk/2;
    clk <= not clk;
  end process;

  -- apply stimuli to UUT
  p_stim:process(clk)
    variable inline : line;
    variable char   : character;
  begin
    if clk'event and clk = '1' then
      if not endfile(f_stimuli) then
        readline(f_stimuli,inline);
        for k in IN_DW-1 downto 0 loop
          read(inline,char);
          if char = '0' then
            din(k) <= '0' after t_stim; 
          else
            din(k) <= '1' after t_stim;
          end if;
        end loop;
      else
        -- end of simulation
                            ""Total Number of Mismatches detected = "" &
                            integer'image(err_cnt) &
                            "" ********""
          severity failure;
      end if;
    end if;
  end process;

  -- compare expected with actual responses and write output file
  p_check: process(clk)
    variable line_exp, line_act : line;
    variable str_exp, str_act   : string(OUT_DW downto 1);
    variable do_check : boolean;
  begin
    if clk'event and clk = '1' then
      do_check := true;
      -- read expected value from file
      readline(f_exp_resp,line_exp);
      for k in OUT_DW-1 downto 0 loop
        -- get all bits in actual output
        if out_data(k) = '0' then
          str_act(k+1) := '0';
        elsif out_data(k) = '1' then
          str_act(k+1) := '1';
        else
          -- skip checking when output data is 'U'
          do_check := false;
        end if;
        write(line_act,str_act(k+1));
        -- get all bits in expected output
        read(line_exp,str_exp(k+1));
      end loop;
      -- write actual value to file
      writeline(f_act_resp,line_act);
      -- compare actual and expected output vector
      if do_check and not (str_exp = str_act) then
        err_cnt <= err_cnt + 1;
      end if;
    end if;
  end process;

end;
",6946,"[':= 8', 'IN_DW', None, ""Input data width should be 8 bits""]
[':= 19', 'OUT_DW', None, ""Output data width should be 19 bits""]
[':= 7', 'COEF_DW', None,""Coefficients data width should be 7 bits""]
[':= 5', 'TAPS', None, ""Number of taps in filter should be 5""]
[':= 8', 'DELAY', None, ""Delay in the filter should be 8""]
[':= 100.0', 'clk_freq', None, ""Clock frequency should be 100 MHz""]
[':= 1000.0/clk_freq * 1 ns', 't_clk', None, ""Clock period should be 10 ns""]
[':= 0.25*t_clk', 't_stim', None, ""Delay time for stimuli application should be 0.0025 s""]
[':= 0.25*t_clk', 't_prop', None, ""Propagation delay for UUT mimic should be 0.0025 s""]"
517,2944,FlatTargetInk/UMD_RISC-16G5,"--------------------------------------------------------------------------------
-- Company: UMASS DARTMOUTH
-- Engineer: Christopher Parks
--
-- Create Date:   13:20:29 03/25/2016
-- Design Name:   
-- Module Name:   Z:/Xilinx/RegisterBank2/RegisterBank_tb.vhd
-- Project Name:  RegisterBank
-- Target Device:  
-- Tool versions:  
-- Description:   
-- 
-- VHDL Test Bench Created by ISE for module: RegisterBank
-- 
-- Dependencies:
-- 
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
--
-- Notes: 
-- This testbench has been automatically generated using types std_logic and
-- std_logic_vector for the ports of the unit under test.  Xilinx recommends
-- that these types always be used for the top-level I/O of a design in order
-- to guarantee that the testbench will bind correctly to the post-implementation 
-- simulation model.
--------------------------------------------------------------------------------
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
 
-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
USE ieee.numeric_std.ALL;
 
ENTITY RegisterBank_tb IS
END RegisterBank_tb;
 
ARCHITECTURE behavior OF RegisterBank_tb IS 
 
    -- Component Declaration for the Unit Under Test (UUT)
 
    COMPONENT RegisterBank
    PORT(
         RAddr : IN  std_logic_vector(3 downto 0);
         RBddr : IN  std_logic_vector(3 downto 0);
         RWddr : IN  std_logic_vector(3 downto 0);
         DATAIN : IN  std_logic_vector(15 downto 0);
         clk : IN  std_logic;
         R : IN  std_logic;
         W : IN  std_logic;
         RAout : OUT  std_logic_vector(15 downto 0);
         RBout : OUT  std_logic_vector(15 downto 0)
        );
    END COMPONENT;
    

   --Inputs
   signal RAddr : std_logic_vector(3 downto 0) := (others => '0');
   signal RBddr : std_logic_vector(3 downto 0) := (others => '0');
   signal RWddr : std_logic_vector(3 downto 0) := (others => '0');
   signal DATAIN : std_logic_vector(15 downto 0) := (others => '0');
   signal clk : std_logic := '0';
   signal R : std_logic := '0';
   signal W : std_logic := '0';

 	--Outputs
   signal RAout : std_logic_vector(15 downto 0);
   signal RBout : std_logic_vector(15 downto 0);

   -- Clock period definitions
   constant clk_period : time := 10 ns;
 
BEGIN
 
	-- Instantiate the Unit Under Test (UUT)
   uut: RegisterBank PORT MAP (
          RAddr => RAddr,
          RBddr => RBddr,
          RWddr => RWddr,
          DATAIN => DATAIN,
          clk => clk,
          R => R,
          W => W,
          RAout => RAout,
          RBout => RBout
        );

   -- Clock process definitions
   clk_process :process
   begin
		clk <= '0';
		wait for clk_period/2;
		clk <= '1';
		wait for clk_period/2;
   end process;
 

   -- Stimulus process
   stim_proc: process
   begin		
      -- hold reset state for 100 ns.
      wait for 100 ns;	

      wait for clk_period*10;
		
      -- insert stimulus here 
		
		W <= '1'; -- Enable write
		wait for clk_period;
		
		for i in 0 to 15 loop
			RWddr <= std_logic_vector(to_unsigned(i, RWddr'length));
			wait for clk_period;
			DATAIN <= std_logic_vector(to_unsigned(i,DATAIN'length));
			wait for clk_period;
		end loop;
		
		W <= '0';
		R <= '1';
		wait for clk_period;
		
		for i in 0 to 14 loop
			RAddr <= std_logic_vector(to_unsigned(i,RAddr'length));
			RBddr <= std_logic_vector(to_unsigned(i+1,RBddr'length));
			wait for clk_period;
			assert (RAout(3 downto 0) = RAddr) report ""wrong value"" severity error;
			assert (RBout(3 downto 0) = RBddr) report ""wrong value"" severity error;
		end loop;
      wait;
   end process;

END;
","
--------------------------------------------------------------------------------
-- Company: UMASS DARTMOUTH
-- Engineer: Christopher Parks
--
-- Create Date:   13:20:29 03/25/2016
-- Design Name:   
-- Module Name:   Z:/Xilinx/RegisterBank2/RegisterBank_tb.vhd
-- Project Name:  RegisterBank
-- Target Device:  
-- Tool versions:  
-- Description:   
-- 
-- VHDL Test Bench Created by ISE for module: RegisterBank
-- 
-- Dependencies:
-- 
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
--
-- Notes: 
-- This testbench has been automatically generated using types std_logic and
-- std_logic_vector for the ports of the unit under test.  Xilinx recommends
-- that these types always be used for the top-level I/O of a design in order
-- to guarantee that the testbench will bind correctly to the post-implementation 
-- simulation model.
--------------------------------------------------------------------------------
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
 
-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
USE ieee.numeric_std.ALL;
 
ENTITY RegisterBank_tb IS
END RegisterBank_tb;
 
ARCHITECTURE behavior OF RegisterBank_tb IS 
 
    -- Component Declaration for the Unit Under Test (UUT)
 
    COMPONENT RegisterBank
    PORT(
         RAddr : IN  std_logic_vector(3 downto 0);
         RBddr : IN  std_logic_vector(3 downto 0);
         RWddr : IN  std_logic_vector(3 downto 0);
         DATAIN : IN  std_logic_vector(15 downto 0);
         clk : IN  std_logic;
         R : IN  std_logic;
         W : IN  std_logic;
         RAout : OUT  std_logic_vector(15 downto 0);
         RBout : OUT  std_logic_vector(15 downto 0)
        );
    END COMPONENT;
    

   --Inputs
   signal RAddr : std_logic_vector(3 downto 0) := (others => '0');
   signal RBddr : std_logic_vector(3 downto 0) := (others => '0');
   signal RWddr : std_logic_vector(3 downto 0) := (others => '0');
   signal DATAIN : std_logic_vector(15 downto 0) := (others => '0');
   signal clk : std_logic := '0';
   signal R : std_logic := '0';
   signal W : std_logic := '0';

 	--Outputs
   signal RAout : std_logic_vector(15 downto 0);
   signal RBout : std_logic_vector(15 downto 0);

   -- Clock period definitions
   constant clk_period : time := 10 ns;
 
BEGIN
 
	-- Instantiate the Unit Under Test (UUT)
   uut: RegisterBank PORT MAP (
          RAddr => RAddr,
          RBddr => RBddr,
          RWddr => RWddr,
          DATAIN => DATAIN,
          clk => clk,
          R => R,
          W => W,
          RAout => RAout,
          RBout => RBout
        );

   -- Clock process definitions
   clk_process :process
   begin
		clk <= '0';
		wait for clk_period/2;
		clk <= '1';
		wait for clk_period/2;
   end process;
 

   -- Stimulus process
   stim_proc: process
   begin		
      -- hold reset state for 100 ns.
      wait for 100 ns;	

      wait for clk_period*10;
		
      -- insert stimulus here 
		
		W <= '1'; -- Enable write
		wait for clk_period;
		
		for i in 0 to 15 loop
			RWddr <= std_logic_vector(to_unsigned(i, RWddr'length));
			wait for clk_period;
			DATAIN <= std_logic_vector(to_unsigned(i,DATAIN'length));
			wait for clk_period;
		end loop;
		
		W <= '0';
		R <= '1';
		wait for clk_period;
		
		for i in 0 to 14 loop
			RAddr <= std_logic_vector(to_unsigned(i,RAddr'length));
			RBddr <= std_logic_vector(to_unsigned(i+1,RBddr'length));
			wait for clk_period;
		end loop;
      wait;
   end process;

END;
","['(RAout(3 downto 0) = RAddr) report ""wrong value"" severity error;', '(RBout(3 downto 0) = RBddr) report ""wrong value"" severity error;']",2,[':= 10 ns'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 10 ns']
*Code:

--------------------------------------------------------------------------------
-- Company: UMASS DARTMOUTH
-- Engineer: Christopher Parks
--
-- Create Date:   13:20:29 03/25/2016
-- Design Name:   
-- Module Name:   Z:/Xilinx/RegisterBank2/RegisterBank_tb.vhd
-- Project Name:  RegisterBank
-- Target Device:  
-- Tool versions:  
-- Description:   
-- 
-- VHDL Test Bench Created by ISE for module: RegisterBank
-- 
-- Dependencies:
-- 
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
--
-- Notes: 
-- This testbench has been automatically generated using types std_logic and
-- std_logic_vector for the ports of the unit under test.  Xilinx recommends
-- that these types always be used for the top-level I/O of a design in order
-- to guarantee that the testbench will bind correctly to the post-implementation 
-- simulation model.
--------------------------------------------------------------------------------
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
 
-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
USE ieee.numeric_std.ALL;
 
ENTITY RegisterBank_tb IS
END RegisterBank_tb;
 
ARCHITECTURE behavior OF RegisterBank_tb IS 
 
    -- Component Declaration for the Unit Under Test (UUT)
 
    COMPONENT RegisterBank
    PORT(
         RAddr : IN  std_logic_vector(3 downto 0);
         RBddr : IN  std_logic_vector(3 downto 0);
         RWddr : IN  std_logic_vector(3 downto 0);
         DATAIN : IN  std_logic_vector(15 downto 0);
         clk : IN  std_logic;
         R : IN  std_logic;
         W : IN  std_logic;
         RAout : OUT  std_logic_vector(15 downto 0);
         RBout : OUT  std_logic_vector(15 downto 0)
        );
    END COMPONENT;
    

   --Inputs
   signal RAddr : std_logic_vector(3 downto 0) := (others => '0');
   signal RBddr : std_logic_vector(3 downto 0) := (others => '0');
   signal RWddr : std_logic_vector(3 downto 0) := (others => '0');
   signal DATAIN : std_logic_vector(15 downto 0) := (others => '0');
   signal clk : std_logic := '0';
   signal R : std_logic := '0';
   signal W : std_logic := '0';

 	--Outputs
   signal RAout : std_logic_vector(15 downto 0);
   signal RBout : std_logic_vector(15 downto 0);

   -- Clock period definitions
   constant clk_period : time := 10 ns;
 
BEGIN
 
	-- Instantiate the Unit Under Test (UUT)
   uut: RegisterBank PORT MAP (
          RAddr => RAddr,
          RBddr => RBddr,
          RWddr => RWddr,
          DATAIN => DATAIN,
          clk => clk,
          R => R,
          W => W,
          RAout => RAout,
          RBout => RBout
        );

   -- Clock process definitions
   clk_process :process
   begin
		clk <= '0';
		wait for clk_period/2;
		clk <= '1';
		wait for clk_period/2;
   end process;
 

   -- Stimulus process
   stim_proc: process
   begin		
      -- hold reset state for 100 ns.
      wait for 100 ns;	

      wait for clk_period*10;
		
      -- insert stimulus here 
		
		W <= '1'; -- Enable write
		wait for clk_period;
		
		for i in 0 to 15 loop
			RWddr <= std_logic_vector(to_unsigned(i, RWddr'length));
			wait for clk_period;
			DATAIN <= std_logic_vector(to_unsigned(i,DATAIN'length));
			wait for clk_period;
		end loop;
		
		W <= '0';
		R <= '1';
		wait for clk_period;
		
		for i in 0 to 14 loop
			RAddr <= std_logic_vector(to_unsigned(i,RAddr'length));
			RBddr <= std_logic_vector(to_unsigned(i+1,RBddr'length));
			wait for clk_period;
		end loop;
      wait;
   end process;

END;
",5116,"Based on the inputs provided in the Verilog code, the following assertions would suit them:

1. ['clk', clk_period, None, ""clk should always take in clk_period""]
2. ['clk', RAddr, 4, ""RAddr input should be of size 4 bits""]
3. ['clk', RBddr, 4, ""RBddr input should be of size 4 bits""]
4. ['clk', RWddr, 4, ""RWddr input should be of size 4 bits""]
5. ['clk', DATAIN, 16, ""DATAIN input should be of size 16 bits""]
6. ['clk', R, None, ""R should always be able to take in a value""]
7. ['clk', W, None, ""W should always be able to take in a value""]
8. ['clk', RAout, 16, ""RAout output should always be of size 16 bits""]
9. ['clk', RBout, 16, ""RBout output should always be of size 16 bits""]

These assertions check that the necessary inputs (RAddr, RBddr, RWddr, DATAIN, R, and W) can indeed be taken into the system, and that the outputs (RAout and RBout) are always of the correct size (16 bits). The clk_period assertion verifies the timing function of the clock."
518,2947,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc621.vhd,v 1.3 2001-10-29 02:12:45 paw Exp $
-- $Revision: 1.3 $
--
-- ---------------------------------------------------------------------


--                 ****************************               --
-- Ported to VHDL 93 by port93.pl - Tue Nov  5 16:37:45 1996  --
--                 ****************************               --



--                 ****************************                   --
-- Reversed to VHDL 87 by reverse87.pl - Tue Nov  5 11:26:07 1996  --
--                 ****************************                    --



--                 ****************************               --
-- Ported to VHDL 93 by port93.pl - Mon Nov  4 17:36:24 1996  --
--                 ****************************               --



ENTITY c03s04b01x00p01n01i00621ent IS
END c03s04b01x00p01n01i00621ent;

ARCHITECTURE c03s04b01x00p01n01i00621arch OF c03s04b01x00p01n01i00621ent IS
  type boolean_vector     is array (natural range <>) of boolean;
  type severity_level_vector is array (natural range <>) of severity_level;
  type integer_vector     is array (natural range <>) of integer;
  type real_vector        is array (natural range <>) of real;
  type time_vector        is array (natural range <>) of time;
  type natural_vector     is array (natural range <>) of natural;
  type positive_vector    is array (natural range <>) of positive;
  
  subtype boolean_vector_st       is boolean_vector(0 to 15);
  subtype severity_level_vector_st is  severity_level_vector(0 to 15);
  subtype integer_vector_st       is  integer_vector(0 to 15);
  subtype real_vector_st          is  real_vector(0 to 15);
  subtype time_vector_st          is  time_vector(0 to 15);
  subtype natural_vector_st       is  natural_vector(0 to 15);
  subtype positive_vector_st      is  positive_vector(0 to 15);
  
  type record_array_st is record
                            a:boolean_vector_st;
                            b:severity_level_vector_st;
                            c:integer_vector_st;
                            d:real_vector_st;
                            e:time_vector_st;
                            f:natural_vector_st;
                            g:positive_vector_st;
                          end record;
  type record_array_st_file is file of record_array_st;
  
  constant C1 : boolean   := true;
  constant C4 : severity_level    := note;
  constant C5 : integer   := 3;
  constant C6 : real      := 3.0;
  constant C7 : time      := 3 ns;
  constant C8 : natural   := 3;
  constant C9 : positive  := 3;
  
  constant C28 : boolean_vector_st        :=(others => C1);
  constant C29 : severity_level_vector_st :=(others => C4);
  constant C30 : integer_vector_st        :=(others => C5);
  constant C31 : real_vector_st           :=(others => C6);
  constant C32 : time_vector_st           :=(others => C7);
  constant C33 : natural_vector_st        :=(others => C8);
  constant C34 : positive_vector_st       :=(others => C9);
  
  constant C35 : record_array_st  := (C28,C29,C30,C31,C32,C33,C34);
  signal       k    : integer := 0;
BEGIN
  TESTING: PROCESS
    file filein    : record_array_st_file open read_mode is ""iofile.34"";
    variable  v    : record_array_st;
  BEGIN
    for i in 1 to 100 loop
      assert(endfile(filein) = false) report""end of file reached before expected"";
      read(filein,v);
      if (v /= C35) then
        k <= 1;
      end if;
    end loop;
    wait for 1 ns;
    assert NOT(k = 0)
      report ""***PASSED TEST: c03s04b01x00p01n01i00621""
      severity NOTE;
    assert (k = 0)
      report ""***FAILED TEST: c03s04b01x00p01n01i00621 - File reading operation (record_array_st file type) failed.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c03s04b01x00p01n01i00621arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc621.vhd,v 1.3 2001-10-29 02:12:45 paw Exp $
-- $Revision: 1.3 $
--
-- ---------------------------------------------------------------------


--                 ****************************               --
-- Ported to VHDL 93 by port93.pl - Tue Nov  5 16:37:45 1996  --
--                 ****************************               --



--                 ****************************                   --
-- Reversed to VHDL 87 by reverse87.pl - Tue Nov  5 11:26:07 1996  --
--                 ****************************                    --



--                 ****************************               --
-- Ported to VHDL 93 by port93.pl - Mon Nov  4 17:36:24 1996  --
--                 ****************************               --



ENTITY c03s04b01x00p01n01i00621ent IS
END c03s04b01x00p01n01i00621ent;

ARCHITECTURE c03s04b01x00p01n01i00621arch OF c03s04b01x00p01n01i00621ent IS
  type boolean_vector     is array (natural range <>) of boolean;
  type severity_level_vector is array (natural range <>) of severity_level;
  type integer_vector     is array (natural range <>) of integer;
  type real_vector        is array (natural range <>) of real;
  type time_vector        is array (natural range <>) of time;
  type natural_vector     is array (natural range <>) of natural;
  type positive_vector    is array (natural range <>) of positive;
  
  subtype boolean_vector_st       is boolean_vector(0 to 15);
  subtype severity_level_vector_st is  severity_level_vector(0 to 15);
  subtype integer_vector_st       is  integer_vector(0 to 15);
  subtype real_vector_st          is  real_vector(0 to 15);
  subtype time_vector_st          is  time_vector(0 to 15);
  subtype natural_vector_st       is  natural_vector(0 to 15);
  subtype positive_vector_st      is  positive_vector(0 to 15);
  
  type record_array_st is record
                            a:boolean_vector_st;
                            b:severity_level_vector_st;
                            c:integer_vector_st;
                            d:real_vector_st;
                            e:time_vector_st;
                            f:natural_vector_st;
                            g:positive_vector_st;
                          end record;
  type record_array_st_file is file of record_array_st;
  
  constant C1 : boolean   := true;
  constant C4 : severity_level    := note;
  constant C5 : integer   := 3;
  constant C6 : real      := 3.0;
  constant C7 : time      := 3 ns;
  constant C8 : natural   := 3;
  constant C9 : positive  := 3;
  
  constant C28 : boolean_vector_st        :=(others => C1);
  constant C29 : severity_level_vector_st :=(others => C4);
  constant C30 : integer_vector_st        :=(others => C5);
  constant C31 : real_vector_st           :=(others => C6);
  constant C32 : time_vector_st           :=(others => C7);
  constant C33 : natural_vector_st        :=(others => C8);
  constant C34 : positive_vector_st       :=(others => C9);
  
  constant C35 : record_array_st  := (C28,C29,C30,C31,C32,C33,C34);
  signal       k    : integer := 0;
BEGIN
  TESTING: PROCESS
    file filein    : record_array_st_file open read_mode is ""iofile.34"";
    variable  v    : record_array_st;
  BEGIN
    for i in 1 to 100 loop
      read(filein,v);
      if (v /= C35) then
        k <= 1;
      end if;
    end loop;
    wait for 1 ns;
      report ""***PASSED TEST: c03s04b01x00p01n01i00621""
      severity NOTE;
      report ""***FAILED TEST: c03s04b01x00p01n01i00621 - File reading operation (record_array_st file type) failed.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c03s04b01x00p01n01i00621arch;
","['(endfile(filein) = false) report""end of file reached before expected"";', 'NOT(k = 0)', '(k = 0)']",3,"[':= 0', ':= 3 ns', ':= 3', ':= 3.0']",4,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 0', ':= 3 ns', ':= 3', ':= 3.0']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc621.vhd,v 1.3 2001-10-29 02:12:45 paw Exp $
-- $Revision: 1.3 $
--
-- ---------------------------------------------------------------------


--                 ****************************               --
-- Ported to VHDL 93 by port93.pl - Tue Nov  5 16:37:45 1996  --
--                 ****************************               --



--                 ****************************                   --
-- Reversed to VHDL 87 by reverse87.pl - Tue Nov  5 11:26:07 1996  --
--                 ****************************                    --



--                 ****************************               --
-- Ported to VHDL 93 by port93.pl - Mon Nov  4 17:36:24 1996  --
--                 ****************************               --



ENTITY c03s04b01x00p01n01i00621ent IS
END c03s04b01x00p01n01i00621ent;

ARCHITECTURE c03s04b01x00p01n01i00621arch OF c03s04b01x00p01n01i00621ent IS
  type boolean_vector     is array (natural range <>) of boolean;
  type severity_level_vector is array (natural range <>) of severity_level;
  type integer_vector     is array (natural range <>) of integer;
  type real_vector        is array (natural range <>) of real;
  type time_vector        is array (natural range <>) of time;
  type natural_vector     is array (natural range <>) of natural;
  type positive_vector    is array (natural range <>) of positive;
  
  subtype boolean_vector_st       is boolean_vector(0 to 15);
  subtype severity_level_vector_st is  severity_level_vector(0 to 15);
  subtype integer_vector_st       is  integer_vector(0 to 15);
  subtype real_vector_st          is  real_vector(0 to 15);
  subtype time_vector_st          is  time_vector(0 to 15);
  subtype natural_vector_st       is  natural_vector(0 to 15);
  subtype positive_vector_st      is  positive_vector(0 to 15);
  
  type record_array_st is record
                            a:boolean_vector_st;
                            b:severity_level_vector_st;
                            c:integer_vector_st;
                            d:real_vector_st;
                            e:time_vector_st;
                            f:natural_vector_st;
                            g:positive_vector_st;
                          end record;
  type record_array_st_file is file of record_array_st;
  
  constant C1 : boolean   := true;
  constant C4 : severity_level    := note;
  constant C5 : integer   := 3;
  constant C6 : real      := 3.0;
  constant C7 : time      := 3 ns;
  constant C8 : natural   := 3;
  constant C9 : positive  := 3;
  
  constant C28 : boolean_vector_st        :=(others => C1);
  constant C29 : severity_level_vector_st :=(others => C4);
  constant C30 : integer_vector_st        :=(others => C5);
  constant C31 : real_vector_st           :=(others => C6);
  constant C32 : time_vector_st           :=(others => C7);
  constant C33 : natural_vector_st        :=(others => C8);
  constant C34 : positive_vector_st       :=(others => C9);
  
  constant C35 : record_array_st  := (C28,C29,C30,C31,C32,C33,C34);
  signal       k    : integer := 0;
BEGIN
  TESTING: PROCESS
    file filein    : record_array_st_file open read_mode is ""iofile.34"";
    variable  v    : record_array_st;
  BEGIN
    for i in 1 to 100 loop
      read(filein,v);
      if (v /= C35) then
        k <= 1;
      end if;
    end loop;
    wait for 1 ns;
      report ""***PASSED TEST: c03s04b01x00p01n01i00621""
      severity NOTE;
      report ""***FAILED TEST: c03s04b01x00p01n01i00621 - File reading operation (record_array_st file type) failed.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c03s04b01x00p01n01i00621arch;
",6171,"Based on the provided input, below are the relevant assertions:

[1, k, None, ""Ensuring k is updated correctly when v is not equal to C35""]

The constraints set in the question prevent further assertions from being created for this code sample."
519,2953,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2096.vhd,v 1.2 2001-10-26 16:29:45 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c07s02b04x00p20n01i02096ent IS
END c07s02b04x00p20n01i02096ent;

ARCHITECTURE c07s02b04x00p20n01i02096arch OF c07s02b04x00p20n01i02096ent IS
  TYPE     boolean_v    is array (integer range <>) of boolean;
  SUBTYPE    boolean_4     is boolean_v (1 to 4);
  SUBTYPE    boolean_8     is boolean_v (1 to 8);

  constant l_operand : boolean_4 := (true,false,true,false);
  constant r_operand : boolean_4 := (false,false,true,true);
BEGIN
  l : block
    generic ( info : boolean_8 );
    generic map ( l_operand & r_operand );
  begin
    assert NOT(info = (true,false,true,false,false,false,true,true))
      report ""***PASSED TEST: c07s02b04x00p20n01i02096""
      severity NOTE;
    assert (info = (true,false,true,false,false,false,true,true))
      report ""***FAILED TEST: c07s02b04x00p20n01i02096 - Constant concatenation did not succeed.""
      severity ERROR;
  end block;

END c07s02b04x00p20n01i02096arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2096.vhd,v 1.2 2001-10-26 16:29:45 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c07s02b04x00p20n01i02096ent IS
END c07s02b04x00p20n01i02096ent;

ARCHITECTURE c07s02b04x00p20n01i02096arch OF c07s02b04x00p20n01i02096ent IS
  TYPE     boolean_v    is array (integer range <>) of boolean;
  SUBTYPE    boolean_4     is boolean_v (1 to 4);
  SUBTYPE    boolean_8     is boolean_v (1 to 8);

  constant l_operand : boolean_4 := (true,false,true,false);
  constant r_operand : boolean_4 := (false,false,true,true);
BEGIN
  l : block
    generic ( info : boolean_8 );
    generic map ( l_operand & r_operand );
  begin
      report ""***PASSED TEST: c07s02b04x00p20n01i02096""
      severity NOTE;
      report ""***FAILED TEST: c07s02b04x00p20n01i02096 - Constant concatenation did not succeed.""
      severity ERROR;
  end block;

END c07s02b04x00p20n01i02096arch;
","['NOT(info = (true,false,true,false,false,false,true,true))', '(info = (true,false,true,false,false,false,true,true))']",2,['range <>) of boolean'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
['range <>) of boolean']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2096.vhd,v 1.2 2001-10-26 16:29:45 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c07s02b04x00p20n01i02096ent IS
END c07s02b04x00p20n01i02096ent;

ARCHITECTURE c07s02b04x00p20n01i02096arch OF c07s02b04x00p20n01i02096ent IS
  TYPE     boolean_v    is array (integer range <>) of boolean;
  SUBTYPE    boolean_4     is boolean_v (1 to 4);
  SUBTYPE    boolean_8     is boolean_v (1 to 8);

  constant l_operand : boolean_4 := (true,false,true,false);
  constant r_operand : boolean_4 := (false,false,true,true);
BEGIN
  l : block
    generic ( info : boolean_8 );
    generic map ( l_operand & r_operand );
  begin
      report ""***PASSED TEST: c07s02b04x00p20n01i02096""
      severity NOTE;
      report ""***FAILED TEST: c07s02b04x00p20n01i02096 - Constant concatenation did not succeed.""
      severity ERROR;
  end block;

END c07s02b04x00p20n01i02096arch;
",3456,"[""1st cycle"", ""boolean_4"", 4, ""Type boolean arrays with the range of 1 to 4 should have the size of 4""],
[""1st cycle"", ""boolean_8"", 8, ""Type boolean arrays with the range of 1 to 8 should have the size of 8""],
[""1st cycle"", ""l_operand"", 4, ""The size of l_operand must be equal to the size of its data type, boolean_4""],
[""1st cycle"", ""r_operand"", 4, ""The size of r_operand must be equal to the size of its data type, boolean_4""],
[""1st cycle"", ""info"", 8, ""The size of info must be equal to the size of its data type, boolean_8""]"
520,2954,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1632.vhd,v 1.2 2001-10-26 16:30:11 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s12b00x00p05n01i01632ent IS
END c08s12b00x00p05n01i01632ent;

ARCHITECTURE c08s12b00x00p05n01i01632arch OF c08s12b00x00p05n01i01632ent IS

BEGIN
  TESTING: PROCESS
    function f1(in1:real) return integer is
    begin
      return(1.2);
    end f1;
    variable k : integer := 0;
  BEGIN
    k := f1(1.5);
    assert FALSE 
      report ""***FAILED TEST: c08s12b00x00p05n01i01632 - The return type must be the same base tyep declared in the specification of the function.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s12b00x00p05n01i01632arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1632.vhd,v 1.2 2001-10-26 16:30:11 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s12b00x00p05n01i01632ent IS
END c08s12b00x00p05n01i01632ent;

ARCHITECTURE c08s12b00x00p05n01i01632arch OF c08s12b00x00p05n01i01632ent IS

BEGIN
  TESTING: PROCESS
    function f1(in1:real) return integer is
    begin
      return(1.2);
    end f1;
    variable k : integer := 0;
  BEGIN
    k := f1(1.5);
      report ""***FAILED TEST: c08s12b00x00p05n01i01632 - The return type must be the same base tyep declared in the specification of the function.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s12b00x00p05n01i01632arch;
",['FALSE'],1,[':= 0'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 0']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1632.vhd,v 1.2 2001-10-26 16:30:11 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s12b00x00p05n01i01632ent IS
END c08s12b00x00p05n01i01632ent;

ARCHITECTURE c08s12b00x00p05n01i01632arch OF c08s12b00x00p05n01i01632ent IS

BEGIN
  TESTING: PROCESS
    function f1(in1:real) return integer is
    begin
      return(1.2);
    end f1;
    variable k : integer := 0;
  BEGIN
    k := f1(1.5);
      report ""***FAILED TEST: c08s12b00x00p05n01i01632 - The return type must be the same base tyep declared in the specification of the function.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s12b00x00p05n01i01632arch;
",3211,"The input seems to be VHDL code, not Verilog. Therefore, assertions can't be generated for it in the format described for Verilog. Please provide a Verilog code snippet to generate the appropriate assertions."
521,2976,peteut/ghdl,"
-- Copyright (C) 1996 Morgan Kaufmann Publishers, Inc

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: ch_03_fg_03_09.vhd,v 1.3 2001-10-26 16:29:33 paw Exp $
-- $Revision: 1.3 $
--
-- ---------------------------------------------------------------------

entity edge_triggered_register is
  port ( clock : in bit; 
         d_in : in real;  d_out : out real );
end entity edge_triggered_register;

architecture check_timing of edge_triggered_register is
begin

  store_and_check : process (clock) is
                                      variable stored_value : real;
                                    variable pulse_start : time;
  begin
    case clock is
      when '1' =>
        pulse_start := now;
        stored_value := d_in;
        d_out <= stored_value;
      when '0' =>
        assert now = 0 ns or (now - pulse_start) >= 5 ns
          report ""clock pulse too short""; 
    end case;
  end process store_and_check;

end architecture check_timing;
","

-- Copyright (C) 1996 Morgan Kaufmann Publishers, Inc

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: ch_03_fg_03_09.vhd,v 1.3 2001-10-26 16:29:33 paw Exp $
-- $Revision: 1.3 $
--
-- ---------------------------------------------------------------------

entity edge_triggered_register is
  port ( clock : in bit; 
         d_in : in real;  d_out : out real );
end entity edge_triggered_register;

architecture check_timing of edge_triggered_register is
begin

  store_and_check : process (clock) is
                                      variable stored_value : real;
                                    variable pulse_start : time;
  begin
    case clock is
      when '1' =>
        pulse_start := now;
        stored_value := d_in;
        d_out <= stored_value;
      when '0' =>
          report ""clock pulse too short""; 
    end case;
  end process store_and_check;

end architecture check_timing;
",['now = 0 ns or (now - pulse_start) >= 5 ns'],1,[')'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[')']
*Code:


-- Copyright (C) 1996 Morgan Kaufmann Publishers, Inc

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: ch_03_fg_03_09.vhd,v 1.3 2001-10-26 16:29:33 paw Exp $
-- $Revision: 1.3 $
--
-- ---------------------------------------------------------------------

entity edge_triggered_register is
  port ( clock : in bit; 
         d_in : in real;  d_out : out real );
end entity edge_triggered_register;

architecture check_timing of edge_triggered_register is
begin

  store_and_check : process (clock) is
                                      variable stored_value : real;
                                    variable pulse_start : time;
  begin
    case clock is
      when '1' =>
        pulse_start := now;
        stored_value := d_in;
        d_out <= stored_value;
      when '0' =>
          report ""clock pulse too short""; 
    end case;
  end process store_and_check;

end architecture check_timing;
",3158,"[""clock"", True, None, ""Clock should always be a legitimate value as it is necessary for the function""],
[""d_in"", ""real"", None, ""d_in should always be a real number for the function to properly execute""],
[""d_out"", ""real"", None, ""d_out should always be a real number as it is coded to be one""],
[""stored_value"", ""real"", None, ""stored_value is coded to be 'real' so should always be one""],
[""pulse_start"", ""time"", None, ""pulse_start is coded to be 'time' so should always be one""]"
522,2981,emogenet/ghdl,"entity call5 is
end;

architecture behav of call5 is
  procedure inc (p : inout integer) is
  begin
    wait for 1 ns;
    p := p + 1;
  end inc;
begin
  process
    variable v : integer := 2;
  begin
    inc (v);
    wait for 2 ns;
    inc (v);
    assert not (v = 4) report ""SUCCESS"";
    wait;
  end process;
 
end behav;
","
entity call5 is
end;

architecture behav of call5 is
  procedure inc (p : inout integer) is
  begin
    wait for 1 ns;
    p := p + 1;
  end inc;
begin
  process
    variable v : integer := 2;
  begin
    inc (v);
    wait for 2 ns;
    inc (v);
    wait;
  end process;
 
end behav;
","['not (v = 4) report ""SUCCESS"";']",1,[':= 2'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 2']
*Code:

entity call5 is
end;

architecture behav of call5 is
  procedure inc (p : inout integer) is
  begin
    wait for 1 ns;
    p := p + 1;
  end inc;
begin
  process
    variable v : integer := 2;
  begin
    inc (v);
    wait for 2 ns;
    inc (v);
    wait;
  end process;
 
end behav;
",1767,"[""2 ns"", ""v"", ""3"", ""v should increment by 1 after 2 ns""]
[""4 ns"", ""v"", ""4"", ""v should increment by 1 again after an additional 2 ns""]"
523,2987,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1752.vhd,v 1.2 2001-10-26 16:30:12 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c09s05b00x00p25n01i01752ent IS
  generic (g1: integer := 12);
  port (
    input1: in  bit ;
    input2: in  bit ;
    clk   : in  boolean;
    output: out bit);
END c09s05b00x00p25n01i01752ent;

ARCHITECTURE c09s05b00x00p25n01i01752arch OF c09s05b00x00p25n01i01752ent IS
  type a is array (1 to 4) of boolean;
  signal i    :  a;
BEGIN
  (i(g1), i(2), i(3), i(4)) <= a'(true, false, false, true);
  -- Failure_here : i(g1) is not a locally static name
  TESTING: PROCESS
  BEGIN
    assert FALSE 
      report ""***FAILED TEST: c09s05b00x00p25n01i01752 - Only locally static signal names may contain here."" 
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c09s05b00x00p25n01i01752arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1752.vhd,v 1.2 2001-10-26 16:30:12 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c09s05b00x00p25n01i01752ent IS
  generic (g1: integer := 12);
  port (
    input1: in  bit ;
    input2: in  bit ;
    clk   : in  boolean;
    output: out bit);
END c09s05b00x00p25n01i01752ent;

ARCHITECTURE c09s05b00x00p25n01i01752arch OF c09s05b00x00p25n01i01752ent IS
  type a is array (1 to 4) of boolean;
  signal i    :  a;
BEGIN
  (i(g1), i(2), i(3), i(4)) <= a'(true, false, false, true);
  -- Failure_here : i(g1) is not a locally static name
  TESTING: PROCESS
  BEGIN
      report ""***FAILED TEST: c09s05b00x00p25n01i01752 - Only locally static signal names may contain here."" 
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c09s05b00x00p25n01i01752arch;
",['FALSE'],1,[':= 12)'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 12)']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1752.vhd,v 1.2 2001-10-26 16:30:12 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c09s05b00x00p25n01i01752ent IS
  generic (g1: integer := 12);
  port (
    input1: in  bit ;
    input2: in  bit ;
    clk   : in  boolean;
    output: out bit);
END c09s05b00x00p25n01i01752ent;

ARCHITECTURE c09s05b00x00p25n01i01752arch OF c09s05b00x00p25n01i01752ent IS
  type a is array (1 to 4) of boolean;
  signal i    :  a;
BEGIN
  (i(g1), i(2), i(3), i(4)) <= a'(true, false, false, true);
  -- Failure_here : i(g1) is not a locally static name
  TESTING: PROCESS
  BEGIN
      report ""***FAILED TEST: c09s05b00x00p25n01i01752 - Only locally static signal names may contain here."" 
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c09s05b00x00p25n01i01752arch;
",3346,"The input provided does not contain sufficient data or context for the generation of assertions based on the given criteria. The input code is not written in Verilog but VHDL, which is a different hardware description language. The variables are not clearly identified and the code lacks components related to functions or outputs, which are necessary for creating meaningful assertions. Therefore, no assertions can be provided based on the current input. Please provide a different and more specific piece of Verilog code."
524,2998,huukit/logicsynth,"-------------------------------------------------------------------------------
-- Title      : TIE-50206, Exercise 04
-- Project    : 
-------------------------------------------------------------------------------
-- File       : multi_port_adder.vhd
-- Author     : Tuomas Huuki, Jonas Nikula
-- Company    : TUT
-- Created    : 09.11.2015
-- Platform   : 
-- Standard   : VHDL'87
-------------------------------------------------------------------------------
-- Description: Fourth excercise.
-------------------------------------------------------------------------------
-- Copyright (c) 2015 
-------------------------------------------------------------------------------
-- Revisions  :
-- Date        Version  Author      Description
-- 09.11.2015  1.0      tuhu        Created
-- 23.11.2015  1.1      nikulaj     Added bonus feature
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;

entity multi_port_adder is -- Multi port adder definition.
    generic
    (
        operand_width_g : integer := 16; -- Specify default value for both.
        num_of_operands_g : integer := 4
    );
    port
    (
        clk         : in std_logic; -- Clock signal.
        rst_n       : in std_logic; -- Reset, active low.
        operands_in : in std_logic_vector((operand_width_g * num_of_operands_g) - 1 downto 0); -- Operand inputs
        sum_out     : out std_logic_vector(operand_width_g - 1 downto 0) -- Calculation result.
    );
end multi_port_adder;

architecture structural of multi_port_adder is -- Structural declaration utilizing the adder component.

    component adder -- Declare component.
        generic
        (
        operand_width_g : integer 
    );                          
    port
    ( -- See component for definitions of signals.
        clk     : in std_logic;                               
        rst_n   : in std_logic;                                     
        a_in    : in std_logic_vector(operand_width_g - 1 downto 0); 
        b_in    : in std_logic_vector(operand_width_g - 1 downto 0); 
        sum_out : out std_logic_vector(operand_width_g downto 0) 
    );
    end component;

    type calculation_values_arr is array (0 to 2*num_of_operands_g - 2) -- Declare new type for all values.
    of std_logic_vector(operand_width_g downto 0);

    signal values_r : calculation_values_arr; -- All calculation values (inputs and outputs).


begin -- structural

    assert ((num_of_operands_g mod 2) = 0) report -- Make sure the number of operands is a factor of 2.
    ""failure: num_of_operands_g is not a factor of 2!"" severity failure;

    inputs_to_arr:      -- This signal assignment can't be done sequentially in a process, so it's done in a for...generate structure.
    for I in 0 to (num_of_operands_g - 1) generate

        values_r(I)(operand_width_g - 1 downto 0) <= operands_in((I+1)*operand_width_g - 1 downto I*operand_width_g);
        values_r(I)(operand_width_g) <= '0';    -- fill up the missing bit (the above assignment is 4 <= 3).

    end generate inputs_to_arr;

    adders:
    for I in 0 to num_of_operands_g - 2 generate    -- Generating the adders

        adder_arr : adder
        generic map
        (
            operand_width_g => operand_width_g
        )
        port map
        (
            clk     => clk,
            rst_n   => rst_n,
            a_in    => values_r(I*2)(operand_width_g - 1 downto 0),
            b_in    => values_r(I*2 + 1)(operand_width_g - 1 downto 0),
            sum_out => values_r(num_of_operands_g + I)
        );

    end generate adders;

    sum_out <= values_r(values_r'length - 1)(operand_width_g - 1 downto 0); -- The final result is the last element in the value array.


end structural;
","
-------------------------------------------------------------------------------
-- Title      : TIE-50206, Exercise 04
-- Project    : 
-------------------------------------------------------------------------------
-- File       : multi_port_adder.vhd
-- Author     : Tuomas Huuki, Jonas Nikula
-- Company    : TUT
-- Created    : 09.11.2015
-- Platform   : 
-- Standard   : VHDL'87
-------------------------------------------------------------------------------
-- Description: Fourth excercise.
-------------------------------------------------------------------------------
-- Copyright (c) 2015 
-------------------------------------------------------------------------------
-- Revisions  :
-- Date        Version  Author      Description
-- 09.11.2015  1.0      tuhu        Created
-- 23.11.2015  1.1      nikulaj     Added bonus feature
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;

entity multi_port_adder is -- Multi port adder definition.
    generic
    (
        operand_width_g : integer := 16; -- Specify default value for both.
        num_of_operands_g : integer := 4
    );
    port
    (
        clk         : in std_logic; -- Clock signal.
        rst_n       : in std_logic; -- Reset, active low.
        operands_in : in std_logic_vector((operand_width_g * num_of_operands_g) - 1 downto 0); -- Operand inputs
        sum_out     : out std_logic_vector(operand_width_g - 1 downto 0) -- Calculation result.
    );
end multi_port_adder;

architecture structural of multi_port_adder is -- Structural declaration utilizing the adder component.

    component adder -- Declare component.
        generic
        (
        operand_width_g : integer 
    );                          
    port
    ( -- See component for definitions of signals.
        clk     : in std_logic;                               
        rst_n   : in std_logic;                                     
        a_in    : in std_logic_vector(operand_width_g - 1 downto 0); 
        b_in    : in std_logic_vector(operand_width_g - 1 downto 0); 
        sum_out : out std_logic_vector(operand_width_g downto 0) 
    );
    end component;

    type calculation_values_arr is array (0 to 2*num_of_operands_g - 2) -- Declare new type for all values.
    of std_logic_vector(operand_width_g downto 0);

    signal values_r : calculation_values_arr; -- All calculation values (inputs and outputs).


begin -- structural

    ""failure: num_of_operands_g is not a factor of 2!"" severity failure;

    inputs_to_arr:      -- This signal assignment can't be done sequentially in a process, so it's done in a for...generate structure.
    for I in 0 to (num_of_operands_g - 1) generate

        values_r(I)(operand_width_g - 1 downto 0) <= operands_in((I+1)*operand_width_g - 1 downto I*operand_width_g);
        values_r(I)(operand_width_g) <= '0';    -- fill up the missing bit (the above assignment is 4 <= 3).

    end generate inputs_to_arr;

    adders:
    for I in 0 to num_of_operands_g - 2 generate    -- Generating the adders

        adder_arr : adder
        generic map
        (
            operand_width_g => operand_width_g
        )
        port map
        (
            clk     => clk,
            rst_n   => rst_n,
            a_in    => values_r(I*2)(operand_width_g - 1 downto 0),
            b_in    => values_r(I*2 + 1)(operand_width_g - 1 downto 0),
            sum_out => values_r(num_of_operands_g + I)
        );

    end generate adders;

    sum_out <= values_r(values_r'length - 1)(operand_width_g - 1 downto 0); -- The final result is the last element in the value array.


end structural;
",['((num_of_operands_g mod 2) = 0) report -- Make sure the number of operands is a factor of 2.'],1,"[':= 16', ')', 'nt']",3,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 16', ')', 'nt']
*Code:

-------------------------------------------------------------------------------
-- Title      : TIE-50206, Exercise 04
-- Project    : 
-------------------------------------------------------------------------------
-- File       : multi_port_adder.vhd
-- Author     : Tuomas Huuki, Jonas Nikula
-- Company    : TUT
-- Created    : 09.11.2015
-- Platform   : 
-- Standard   : VHDL'87
-------------------------------------------------------------------------------
-- Description: Fourth excercise.
-------------------------------------------------------------------------------
-- Copyright (c) 2015 
-------------------------------------------------------------------------------
-- Revisions  :
-- Date        Version  Author      Description
-- 09.11.2015  1.0      tuhu        Created
-- 23.11.2015  1.1      nikulaj     Added bonus feature
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;

entity multi_port_adder is -- Multi port adder definition.
    generic
    (
        operand_width_g : integer := 16; -- Specify default value for both.
        num_of_operands_g : integer := 4
    );
    port
    (
        clk         : in std_logic; -- Clock signal.
        rst_n       : in std_logic; -- Reset, active low.
        operands_in : in std_logic_vector((operand_width_g * num_of_operands_g) - 1 downto 0); -- Operand inputs
        sum_out     : out std_logic_vector(operand_width_g - 1 downto 0) -- Calculation result.
    );
end multi_port_adder;

architecture structural of multi_port_adder is -- Structural declaration utilizing the adder component.

    component adder -- Declare component.
        generic
        (
        operand_width_g : integer 
    );                          
    port
    ( -- See component for definitions of signals.
        clk     : in std_logic;                               
        rst_n   : in std_logic;                                     
        a_in    : in std_logic_vector(operand_width_g - 1 downto 0); 
        b_in    : in std_logic_vector(operand_width_g - 1 downto 0); 
        sum_out : out std_logic_vector(operand_width_g downto 0) 
    );
    end component;

    type calculation_values_arr is array (0 to 2*num_of_operands_g - 2) -- Declare new type for all values.
    of std_logic_vector(operand_width_g downto 0);

    signal values_r : calculation_values_arr; -- All calculation values (inputs and outputs).


begin -- structural

    ""failure: num_of_operands_g is not a factor of 2!"" severity failure;

    inputs_to_arr:      -- This signal assignment can't be done sequentially in a process, so it's done in a for...generate structure.
    for I in 0 to (num_of_operands_g - 1) generate

        values_r(I)(operand_width_g - 1 downto 0) <= operands_in((I+1)*operand_width_g - 1 downto I*operand_width_g);
        values_r(I)(operand_width_g) <= '0';    -- fill up the missing bit (the above assignment is 4 <= 3).

    end generate inputs_to_arr;

    adders:
    for I in 0 to num_of_operands_g - 2 generate    -- Generating the adders

        adder_arr : adder
        generic map
        (
            operand_width_g => operand_width_g
        )
        port map
        (
            clk     => clk,
            rst_n   => rst_n,
            a_in    => values_r(I*2)(operand_width_g - 1 downto 0),
            b_in    => values_r(I*2 + 1)(operand_width_g - 1 downto 0),
            sum_out => values_r(num_of_operands_g + I)
        );

    end generate adders;

    sum_out <= values_r(values_r'length - 1)(operand_width_g - 1 downto 0); -- The final result is the last element in the value array.


end structural;
",5170,"[""clk"", ""operands_in"", True, ""The function receives necessary input operands every clock cycle""],
[""operand_width_g"", ""operand_width_g * num_of_operands_g"", True, ""Ensure operands' width corresponds with the number of operands""],
[""clk"", ""sum_out"", True, ""The function outputs sum every clock cycle""],
[""operand_width_g"", len(""sum_out""), True, ""The output sum size should be equal to operand width""],
[""num_of_operands_g"", ""num_of_operands_g - 1"", False, ""num_of_operands_g should be at least 2""],
[""operand_width_g"", 16, True, ""operand_width_g should default to 16 when not defined""],
[""num_of_operands_g"", 4, True, ""num_of_operands_g should default to 4 when not defined""],
[""clk"", ""rst_n"", True, ""Reset signal should be present every clock cycle""],
[""values_r"", None, None, ""Must contain all values calculated during the operations""],
[""aignals.values_r"", ""adders.a_in"", True, ""a_in should be equal to calculation values incremental I""],
[""signals.values_r"", ""adders.b_in"", True, ""b_in should be equal to calculation values incremental I+1""],
[""signals.values_r"", ""sum_out"", True, ""The last value in calculation values array should be equal to sum_out""]"
525,3006,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1040.vhd,v 1.2 2001-10-26 16:29:38 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c06s04b00x00p03n01i01040ent IS
END c06s04b00x00p03n01i01040ent;

ARCHITECTURE c06s04b00x00p03n01i01040arch OF c06s04b00x00p03n01i01040ent IS
  type A is array (1 to 10) of integer;
  function foo (f:integer :=  3) return A is
    variable v: A := (1,2,3,4,5,6,7,8,9,10);
  begin
    return v;
  end foo;
BEGIN
  TESTING: PROCESS
    variable k : integer := 0;
  BEGIN
    k := foo(3)(3);
    assert NOT( k=3 )
      report ""***PASSED TEST: c06s04b00x00p03n01i01040""
      severity NOTE;
    assert ( k=3 )
      report ""***FAILED TEST: c06s04b00x00p03n01i01040 - The prefix of an indexed name must be appropriate for an array type.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c06s04b00x00p03n01i01040arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1040.vhd,v 1.2 2001-10-26 16:29:38 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c06s04b00x00p03n01i01040ent IS
END c06s04b00x00p03n01i01040ent;

ARCHITECTURE c06s04b00x00p03n01i01040arch OF c06s04b00x00p03n01i01040ent IS
  type A is array (1 to 10) of integer;
  function foo (f:integer :=  3) return A is
    variable v: A := (1,2,3,4,5,6,7,8,9,10);
  begin
    return v;
  end foo;
BEGIN
  TESTING: PROCESS
    variable k : integer := 0;
  BEGIN
    k := foo(3)(3);
      report ""***PASSED TEST: c06s04b00x00p03n01i01040""
      severity NOTE;
      report ""***FAILED TEST: c06s04b00x00p03n01i01040 - The prefix of an indexed name must be appropriate for an array type.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c06s04b00x00p03n01i01040arch;
","['NOT( k=3 )', '( k=3 )']",2,[':= 0'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 0']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1040.vhd,v 1.2 2001-10-26 16:29:38 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c06s04b00x00p03n01i01040ent IS
END c06s04b00x00p03n01i01040ent;

ARCHITECTURE c06s04b00x00p03n01i01040arch OF c06s04b00x00p03n01i01040ent IS
  type A is array (1 to 10) of integer;
  function foo (f:integer :=  3) return A is
    variable v: A := (1,2,3,4,5,6,7,8,9,10);
  begin
    return v;
  end foo;
BEGIN
  TESTING: PROCESS
    variable k : integer := 0;
  BEGIN
    k := foo(3)(3);
      report ""***PASSED TEST: c06s04b00x00p03n01i01040""
      severity NOTE;
      report ""***FAILED TEST: c06s04b00x00p03n01i01040 - The prefix of an indexed name must be appropriate for an array type.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c06s04b00x00p03n01i01040arch;
",3346,"Based on the provided Verilog code, we cannot generate proper assertion as Verilog code provided is almost a skeleton and does not contain enough variables or logical processes. However, based on the general usage in the code, an example of an assertion could be:

[""every cycle"", ""k"", 0, ""Variable 'k' must initialize to 0 at the start of every cycle""]

This would be equal to adding the assertion in Verilog:

always @(posedge clk)
  if (k !== 0) $display(""Variable 'k' must initialize to 0 at the start of every cycle"");

Please note that 'clk' is not defined in the provided code, and is used merely for demonstration purposes. The assertion is based on the assumption of a clock signal to make it compatible with the example provided. A proper assertion can only be made when the full working Verilog code is provided."
526,3007,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2172.vhd,v 1.2 2001-10-26 16:29:46 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c07s02b05x00p01n01i02172ent IS
END c07s02b05x00p01n01i02172ent;

ARCHITECTURE c07s02b05x00p01n01i02172arch OF c07s02b05x00p01n01i02172ent IS

BEGIN
  TESTING: PROCESS
    constant x1: integer := + 10;
  BEGIN
    assert NOT(x1=10) 
      report ""***PASSED TEST: c07s02b05x00p01n01i02172"" 
      severity NOTE;
    assert (x1=10) 
      report ""***FAILED TEST: c07s02b05x00p01n01i02172 - Signs - can be used with only numeric types.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c07s02b05x00p01n01i02172arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2172.vhd,v 1.2 2001-10-26 16:29:46 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c07s02b05x00p01n01i02172ent IS
END c07s02b05x00p01n01i02172ent;

ARCHITECTURE c07s02b05x00p01n01i02172arch OF c07s02b05x00p01n01i02172ent IS

BEGIN
  TESTING: PROCESS
    constant x1: integer := + 10;
  BEGIN
      report ""***PASSED TEST: c07s02b05x00p01n01i02172"" 
      severity NOTE;
      report ""***FAILED TEST: c07s02b05x00p01n01i02172 - Signs - can be used with only numeric types.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c07s02b05x00p01n01i02172arch;
","['NOT(x1=10)', '(x1=10)']",2,[':= + 10'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= + 10']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2172.vhd,v 1.2 2001-10-26 16:29:46 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c07s02b05x00p01n01i02172ent IS
END c07s02b05x00p01n01i02172ent;

ARCHITECTURE c07s02b05x00p01n01i02172arch OF c07s02b05x00p01n01i02172ent IS

BEGIN
  TESTING: PROCESS
    constant x1: integer := + 10;
  BEGIN
      report ""***PASSED TEST: c07s02b05x00p01n01i02172"" 
      severity NOTE;
      report ""***FAILED TEST: c07s02b05x00p01n01i02172 - Signs - can be used with only numeric types.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c07s02b05x00p01n01i02172arch;
",3147,"[':= + 10', x1, 10, ""Variable x1 should be always equal to integer value +10""]"
527,3008,nickg/nvc,"entity assign2 is
end entity;

architecture test of assign2 is
begin

    process is
        variable x : bit_vector(7 downto 0) := (1 => '1', others => '0');
    begin
        assert x(0) = '0';
        assert x(1) = '1';
        assert x(4) = x(5);
        x(2) := '1';
        assert x(2) = '1';
        wait;
    end process;
    
end architecture;
","
entity assign2 is
end entity;

architecture test of assign2 is
begin

    process is
        variable x : bit_vector(7 downto 0) := (1 => '1', others => '0');
    begin
        x(2) := '1';
        wait;
    end process;
    
end architecture;
","[""x(0) = '0';"", ""x(1) = '1';"", 'x(4) = x(5);', ""x(2) = '1';""]",4,['is'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
['is']
*Code:

entity assign2 is
end entity;

architecture test of assign2 is
begin

    process is
        variable x : bit_vector(7 downto 0) := (1 => '1', others => '0');
    begin
        x(2) := '1';
        wait;
    end process;
    
end architecture;
",1725,"[""begin"", ""x"", 8, ""Bit vector 'x' should have 8 bits as its size is being declared in the 'begin' of the process""],
[""begin"", ""x(2)"", ""1"", ""The third bit of 'x' should be equal to 1 as it is being assigned in the 'begin' of the process""]"
528,3012,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2591.vhd,v 1.2 2001-10-26 16:30:20 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c13s03b01x00p02n01i02591ent IS
END c13s03b01x00p02n01i02591ent;

ARCHITECTURE c13s03b01x00p02n01i02591arch OF c13s03b01x00p02n01i02591ent IS

BEGIN
  TESTING: PROCESS
    variable k- : integer := 0;
  BEGIN
    assert FALSE 
      report ""***FAILED TEST: c13s03b01x00p02n01i02591 - Identifier can not end with '-'.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c13s03b01x00p02n01i02591arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2591.vhd,v 1.2 2001-10-26 16:30:20 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c13s03b01x00p02n01i02591ent IS
END c13s03b01x00p02n01i02591ent;

ARCHITECTURE c13s03b01x00p02n01i02591arch OF c13s03b01x00p02n01i02591ent IS

BEGIN
  TESTING: PROCESS
    variable k- : integer := 0;
  BEGIN
      report ""***FAILED TEST: c13s03b01x00p02n01i02591 - Identifier can not end with '-'.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c13s03b01x00p02n01i02591arch;
",['FALSE'],1,[':= 0'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 0']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2591.vhd,v 1.2 2001-10-26 16:30:20 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c13s03b01x00p02n01i02591ent IS
END c13s03b01x00p02n01i02591ent;

ARCHITECTURE c13s03b01x00p02n01i02591arch OF c13s03b01x00p02n01i02591ent IS

BEGIN
  TESTING: PROCESS
    variable k- : integer := 0;
  BEGIN
      report ""***FAILED TEST: c13s03b01x00p02n01i02591 - Identifier can not end with '-'.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c13s03b01x00p02n01i02591arch;
",3052,"Since the provided code is written in VHDL and not in Verilog, it's not possible to generate assertions for Verilog. However, the existing code does not perform any data processing or operations that would result in a new output from a specific input. Also, there is no indication that the value of the variable 'k-' is used or modified anywhere, aside from its initial assignment. Hence, no assertions can be made in this case. 

If the code were in Verilog and had more meaningful variables and operations, it would be possible to create some assertions. In VHDL, similar functionalities can be obtained using 'assert' statements, but the meaning and usage would depend on the specific processing being performed and the requirements in each case."
529,3013,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc3180.vhd,v 1.2 2001-10-26 16:29:52 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c14s01b00x00p78n01i03180ent IS
END c14s01b00x00p78n01i03180ent;

ARCHITECTURE c14s01b00x00p78n01i03180arch OF c14s01b00x00p78n01i03180ent IS
  subtype fourbit is integer range 0 to 15;
  subtype roufbit is integer range 15 downto 0;
BEGIN
  TESTING: PROCESS
  BEGIN
    assert NOT(    fourbit'leftof(15) = 14   and
                   roufbit'leftof(0) = 1   )
      report ""***PASSED TEST: c14s01b00x00p78n01i03180""
      severity NOTE;
    assert (    fourbit'leftof(15) = 14   and
                roufbit'leftof(0) = 1   )
      report ""***FAILED TEST: c14s01b00x00p78n01i03180 - Predefined attribute LEFTOF for integer subtype test failed.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c14s01b00x00p78n01i03180arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc3180.vhd,v 1.2 2001-10-26 16:29:52 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c14s01b00x00p78n01i03180ent IS
END c14s01b00x00p78n01i03180ent;

ARCHITECTURE c14s01b00x00p78n01i03180arch OF c14s01b00x00p78n01i03180ent IS
  subtype fourbit is integer range 0 to 15;
  subtype roufbit is integer range 15 downto 0;
BEGIN
  TESTING: PROCESS
  BEGIN
                   roufbit'leftof(0) = 1   )
      report ""***PASSED TEST: c14s01b00x00p78n01i03180""
      severity NOTE;
                roufbit'leftof(0) = 1   )
      report ""***FAILED TEST: c14s01b00x00p78n01i03180 - Predefined attribute LEFTOF for integer subtype test failed.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c14s01b00x00p78n01i03180arch;
","[""NOT(    fourbit'leftof(15) = 14   and"", ""(    fourbit'leftof(15) = 14   and""]",2,"['range 15 downto 0', 'range 0 to 15']",2,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
['range 15 downto 0', 'range 0 to 15']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc3180.vhd,v 1.2 2001-10-26 16:29:52 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c14s01b00x00p78n01i03180ent IS
END c14s01b00x00p78n01i03180ent;

ARCHITECTURE c14s01b00x00p78n01i03180arch OF c14s01b00x00p78n01i03180ent IS
  subtype fourbit is integer range 0 to 15;
  subtype roufbit is integer range 15 downto 0;
BEGIN
  TESTING: PROCESS
  BEGIN
                   roufbit'leftof(0) = 1   )
      report ""***PASSED TEST: c14s01b00x00p78n01i03180""
      severity NOTE;
                roufbit'leftof(0) = 1   )
      report ""***FAILED TEST: c14s01b00x00p78n01i03180 - Predefined attribute LEFTOF for integer subtype test failed.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c14s01b00x00p78n01i03180arch;
",3333,"Since this code does not use a clock cycle and also does not contain any explicit boolean variables, the timing and target of the assertions will be None. However, the code makes use of integer ranges 'fourbit' and 'roufbit', so the assertions will involve these variables.

Assertion 1:
[None, 'fourbit', None, ""'fourbit' should be in the range 0 to 15""]

Reasoning: This assertions is to ensure that the subtype 'fourbit' is within the defined integer range of 0 to 15. This is crucial for the correct functioning of the code.

Assertion 2:
[None, 'roufbit', None, ""'roufbit' should be in the range 15 downto 0""]

Reasoning: This assertion verifies that the subtype 'roufbit' is within its declared integer range, that is from 15 downto 0. Correct integer range of 'roufbit' is important for the operation of the code.

Please note that these are logical assertions, actual implementation may require separate coding or a supporting framework."
530,3015,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc735.vhd,v 1.2 2001-10-26 16:30:27 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

package c01s01b01x00p05n01i00735pkg is
  type actype is access integer;
end c01s01b01x00p05n01i00735pkg;

use work.c01s01b01x00p05n01i00735pkg.all;
entity c01s01b01x00p05n01i00735ent_a is
  generic (
    constant gc1 : integer;
    constant gc2 : actype;
    constant gc3 : integer
    );
  port ( signal cent1 : in bit;
         signal cent2 : in bit
         );
end c01s01b01x00p05n01i00735ent_a;

architecture arch of c01s01b01x00p05n01i00735ent_a is
begin
  assert false 
    report ""FAIL: should not compile"";
end arch;

use work.c01s01b01x00p05n01i00735pkg.all;
ENTITY c01s01b01x00p05n01i00735ent IS
  generic ( constant gen_con : natural := 7 );
  port ( signal ee1 : in bit;
         signal ee2 : in bit;
         signal eo1 : out bit
         );
END c01s01b01x00p05n01i00735ent;

ARCHITECTURE c01s01b01x00p05n01i00735arch OF c01s01b01x00p05n01i00735ent IS

  signal s1 : integer;
  signal s2 : natural;
  signal s3 : positive;

  component comp1
    generic (
      constant dgc1 : integer;
      constant dgc2 : actype;
      constant dgc3 : integer
      );
    port ( signal dcent1 : in bit;
           signal dcent2 : in bit
           );
  end component;

  for u1 : comp1 use
    entity work.c01s01b01x00p05n01i00735ent_a
    generic map (dgc1, dgc2.all, dgc3)
    port map ( dcent1, dcent2 );

BEGIN

  u1 : comp1
    generic map (acint,3,3)
    port map (ee1,ee2);

  TESTING: PROCESS
  BEGIN
    assert FALSE 
      report ""***FAILED TEST: c01s01b01x00p05n01i00735 - Formal generic can not be of type access."" 
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c01s01b01x00p05n01i00735arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc735.vhd,v 1.2 2001-10-26 16:30:27 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

package c01s01b01x00p05n01i00735pkg is
  type actype is access integer;
end c01s01b01x00p05n01i00735pkg;

use work.c01s01b01x00p05n01i00735pkg.all;
entity c01s01b01x00p05n01i00735ent_a is
  generic (
    constant gc1 : integer;
    constant gc2 : actype;
    constant gc3 : integer
    );
  port ( signal cent1 : in bit;
         signal cent2 : in bit
         );
end c01s01b01x00p05n01i00735ent_a;

architecture arch of c01s01b01x00p05n01i00735ent_a is
begin
    report ""FAIL: should not compile"";
end arch;

use work.c01s01b01x00p05n01i00735pkg.all;
ENTITY c01s01b01x00p05n01i00735ent IS
  generic ( constant gen_con : natural := 7 );
  port ( signal ee1 : in bit;
         signal ee2 : in bit;
         signal eo1 : out bit
         );
END c01s01b01x00p05n01i00735ent;

ARCHITECTURE c01s01b01x00p05n01i00735arch OF c01s01b01x00p05n01i00735ent IS

  signal s1 : integer;
  signal s2 : natural;
  signal s3 : positive;

  component comp1
    generic (
      constant dgc1 : integer;
      constant dgc2 : actype;
      constant dgc3 : integer
      );
    port ( signal dcent1 : in bit;
           signal dcent2 : in bit
           );
  end component;

  for u1 : comp1 use
    entity work.c01s01b01x00p05n01i00735ent_a
    generic map (dgc1, dgc2.all, dgc3)
    port map ( dcent1, dcent2 );

BEGIN

  u1 : comp1
    generic map (acint,3,3)
    port map (ee1,ee2);

  TESTING: PROCESS
  BEGIN
      report ""***FAILED TEST: c01s01b01x00p05n01i00735 - Formal generic can not be of type access."" 
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c01s01b01x00p05n01i00735arch;
","['false', 'FALSE']",2,[')'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[')']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc735.vhd,v 1.2 2001-10-26 16:30:27 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

package c01s01b01x00p05n01i00735pkg is
  type actype is access integer;
end c01s01b01x00p05n01i00735pkg;

use work.c01s01b01x00p05n01i00735pkg.all;
entity c01s01b01x00p05n01i00735ent_a is
  generic (
    constant gc1 : integer;
    constant gc2 : actype;
    constant gc3 : integer
    );
  port ( signal cent1 : in bit;
         signal cent2 : in bit
         );
end c01s01b01x00p05n01i00735ent_a;

architecture arch of c01s01b01x00p05n01i00735ent_a is
begin
    report ""FAIL: should not compile"";
end arch;

use work.c01s01b01x00p05n01i00735pkg.all;
ENTITY c01s01b01x00p05n01i00735ent IS
  generic ( constant gen_con : natural := 7 );
  port ( signal ee1 : in bit;
         signal ee2 : in bit;
         signal eo1 : out bit
         );
END c01s01b01x00p05n01i00735ent;

ARCHITECTURE c01s01b01x00p05n01i00735arch OF c01s01b01x00p05n01i00735ent IS

  signal s1 : integer;
  signal s2 : natural;
  signal s3 : positive;

  component comp1
    generic (
      constant dgc1 : integer;
      constant dgc2 : actype;
      constant dgc3 : integer
      );
    port ( signal dcent1 : in bit;
           signal dcent2 : in bit
           );
  end component;

  for u1 : comp1 use
    entity work.c01s01b01x00p05n01i00735ent_a
    generic map (dgc1, dgc2.all, dgc3)
    port map ( dcent1, dcent2 );

BEGIN

  u1 : comp1
    generic map (acint,3,3)
    port map (ee1,ee2);

  TESTING: PROCESS
  BEGIN
      report ""***FAILED TEST: c01s01b01x00p05n01i00735 - Formal generic can not be of type access."" 
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c01s01b01x00p05n01i00735arch;
",4238,"Given that the provided code is written in VHDL and the format is not quite compatible with the task instructions, creating assertions following these guidelines may not be viable.

Regardless, for the VHDL Code, it would be possible to write some form of assertions in VHDL, such as the following:

1. Assert that the inputs to the entity are of type 'bit':

```vhdl
assert cent1'range = 2
     report ""Entity input cent1 is not of type bit"" severity note;
assert cent2'range = 2
     report ""Entity input cent2 is not of type bit"" severity note;
```
2. Verify that the output of the 'c01s01b01x00p05n01i00735arch' entity is only a single bit:

```vhdl
assert eo1'range = 1
     report ""Output eo1 is not a single bit"" severity note;
```
In a direct application of the task instructions, the generated output for these assertions would look like:

1. [cent1, 2, None, ""Entity input cent1 should be of type bit""]
2. [cent2, 2, None, ""Entity input cent2 should be of type bit""]
3. [eo1, 1, None, ""Output eo1 should be a single bit""]

However, these outputs are best-compatible with something like python code, not VHDL, and would require modifying the VHDL code syntax to fit the format in an unusal way."
531,3025,parallella/parallella-lcd-fpga,"--------------------------------------------------------------------------------
--
-- FIFO Generator Core Demo Testbench 
--
--------------------------------------------------------------------------------
--
-- (c) Copyright 2009 - 2010 Xilinx, Inc. All rights reserved.
-- 
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
-- 
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE ""AS IS"" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
-- 
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, ""Critical
-- Applications""). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
-- 
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--------------------------------------------------------------------------------
--
-- Filename: system_axi_vdma_0_wrapper_fifo_generator_v9_3_tb.vhd
--
-- Description:
--   This is the demo testbench top file for fifo_generator core.
--
--------------------------------------------------------------------------------
-- Library Declarations
--------------------------------------------------------------------------------
LIBRARY ieee;
LIBRARY std;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.ALL;
USE IEEE.std_logic_arith.ALL;
USE IEEE.std_logic_misc.ALL;
USE ieee.numeric_std.ALL;
USE ieee.std_logic_textio.ALL;
USE std.textio.ALL;

LIBRARY work;
USE work.system_axi_vdma_0_wrapper_fifo_generator_v9_3_pkg.ALL;

ENTITY system_axi_vdma_0_wrapper_fifo_generator_v9_3_tb IS
END ENTITY;


ARCHITECTURE system_axi_vdma_0_wrapper_fifo_generator_v9_3_arch OF system_axi_vdma_0_wrapper_fifo_generator_v9_3_tb IS
 SIGNAL  status              : STD_LOGIC_VECTOR(7 DOWNTO 0) := ""00000000"";
 SIGNAL  wr_clk              : STD_LOGIC;
 SIGNAL  reset 	             : STD_LOGIC;
 SIGNAL  sim_done            : STD_LOGIC := '0';
 SIGNAL  end_of_sim          : STD_LOGIC_VECTOR(4 DOWNTO 0) := (OTHERS => '0');
 -- Write and Read clock periods
 CONSTANT wr_clk_period_by_2 : TIME := 100 ns;
 -- Procedures to display strings
 PROCEDURE disp_str(CONSTANT str:IN STRING) IS
    variable dp_l : line := null;   
 BEGIN
  write(dp_l,str);
  writeline(output,dp_l);
 END PROCEDURE;
 
 PROCEDURE disp_hex(signal hex:IN STD_LOGIC_VECTOR(7 DOWNTO 0)) IS
    variable dp_lx : line := null;   
 BEGIN
  hwrite(dp_lx,hex);
  writeline(output,dp_lx);
 END PROCEDURE;

BEGIN
  
  -- Generation of clock

  PROCESS BEGIN
    WAIT FOR 200 ns; -- Wait for global reset
    WHILE 1 = 1 LOOP
      wr_clk <= '0';
      WAIT FOR wr_clk_period_by_2;
      wr_clk <= '1'; 
      WAIT FOR wr_clk_period_by_2;
    END LOOP;
  END PROCESS;
  
  -- Generation of Reset
  
  PROCESS BEGIN
    reset <= '1';
    WAIT FOR 2100 ns;
    reset <= '0';
    WAIT;
  END PROCESS;
  
  
  -- Error message printing based on STATUS signal from system_axi_vdma_0_wrapper_fifo_generator_v9_3_synth

  PROCESS(status)
  BEGIN
    IF(status /= ""0"" AND status /= ""1"") THEN
      disp_str(""STATUS:"");
      disp_hex(status);
    END IF;

    IF(status(7) = '1') THEN
      assert false
       report ""Data mismatch found""
       severity error;
    END IF;

    IF(status(1) = '1') THEN
    END IF;
    
    
    IF(status(3) = '1') THEN
      assert false
       report ""Almost Empty flag Mismatch/timeout""
       severity error;
    END IF;
    
    IF(status(5) = '1') THEN
      assert false
       report ""Empty flag Mismatch/timeout""
       severity error;
    END IF;

    IF(status(6) = '1') THEN
      assert false
       report ""Full Flag Mismatch/timeout""
       severity error;
    END IF;
  END PROCESS;


  PROCESS 
  BEGIN
    wait until sim_done = '1';
    IF(status /= ""0"" AND status /= ""1"") THEN
      assert false
      report ""Simulation failed""
      severity failure;
    ELSE
      assert false
      report ""Test Completed Successfully""
      severity failure;
    END IF;
  END PROCESS;
  
  PROCESS
  BEGIN
    wait for 400 ms;
    assert false
    report ""Test bench timed out""
    severity failure;
  END PROCESS;

  -- Instance of system_axi_vdma_0_wrapper_fifo_generator_v9_3_synth
  
  system_axi_vdma_0_wrapper_fifo_generator_v9_3_synth_inst:system_axi_vdma_0_wrapper_fifo_generator_v9_3_synth
   GENERIC MAP(
              FREEZEON_ERROR => 0,
 	      TB_STOP_CNT    => 2,
 	      TB_SEED        => 70 
 	      )
  PORT MAP(
	   CLK           => wr_clk,
	   RESET         => reset,
	   SIM_DONE      => sim_done,
           STATUS        => status
	  );

END ARCHITECTURE;
","
--------------------------------------------------------------------------------
--
-- FIFO Generator Core Demo Testbench 
--
--------------------------------------------------------------------------------
--
-- (c) Copyright 2009 - 2010 Xilinx, Inc. All rights reserved.
-- 
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
-- 
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE ""AS IS"" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
-- 
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, ""Critical
-- Applications""). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
-- 
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--------------------------------------------------------------------------------
--
-- Filename: system_axi_vdma_0_wrapper_fifo_generator_v9_3_tb.vhd
--
-- Description:
--   This is the demo testbench top file for fifo_generator core.
--
--------------------------------------------------------------------------------
-- Library Declarations
--------------------------------------------------------------------------------
LIBRARY ieee;
LIBRARY std;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.ALL;
USE IEEE.std_logic_arith.ALL;
USE IEEE.std_logic_misc.ALL;
USE ieee.numeric_std.ALL;
USE ieee.std_logic_textio.ALL;
USE std.textio.ALL;

LIBRARY work;
USE work.system_axi_vdma_0_wrapper_fifo_generator_v9_3_pkg.ALL;

ENTITY system_axi_vdma_0_wrapper_fifo_generator_v9_3_tb IS
END ENTITY;


ARCHITECTURE system_axi_vdma_0_wrapper_fifo_generator_v9_3_arch OF system_axi_vdma_0_wrapper_fifo_generator_v9_3_tb IS
 SIGNAL  status              : STD_LOGIC_VECTOR(7 DOWNTO 0) := ""00000000"";
 SIGNAL  wr_clk              : STD_LOGIC;
 SIGNAL  reset 	             : STD_LOGIC;
 SIGNAL  sim_done            : STD_LOGIC := '0';
 SIGNAL  end_of_sim          : STD_LOGIC_VECTOR(4 DOWNTO 0) := (OTHERS => '0');
 -- Write and Read clock periods
 CONSTANT wr_clk_period_by_2 : TIME := 100 ns;
 -- Procedures to display strings
 PROCEDURE disp_str(CONSTANT str:IN STRING) IS
    variable dp_l : line := null;   
 BEGIN
  write(dp_l,str);
  writeline(output,dp_l);
 END PROCEDURE;
 
 PROCEDURE disp_hex(signal hex:IN STD_LOGIC_VECTOR(7 DOWNTO 0)) IS
    variable dp_lx : line := null;   
 BEGIN
  hwrite(dp_lx,hex);
  writeline(output,dp_lx);
 END PROCEDURE;

BEGIN
  
  -- Generation of clock

  PROCESS BEGIN
    WAIT FOR 200 ns; -- Wait for global reset
    WHILE 1 = 1 LOOP
      wr_clk <= '0';
      WAIT FOR wr_clk_period_by_2;
      wr_clk <= '1'; 
      WAIT FOR wr_clk_period_by_2;
    END LOOP;
  END PROCESS;
  
  -- Generation of Reset
  
  PROCESS BEGIN
    reset <= '1';
    WAIT FOR 2100 ns;
    reset <= '0';
    WAIT;
  END PROCESS;
  
  
  -- Error message printing based on STATUS signal from system_axi_vdma_0_wrapper_fifo_generator_v9_3_synth

  PROCESS(status)
  BEGIN
    IF(status /= ""0"" AND status /= ""1"") THEN
      disp_str(""STATUS:"");
      disp_hex(status);
    END IF;

    IF(status(7) = '1') THEN
       report ""Data mismatch found""
       severity error;
    END IF;

    IF(status(1) = '1') THEN
    END IF;
    
    
    IF(status(3) = '1') THEN
       report ""Almost Empty flag Mismatch/timeout""
       severity error;
    END IF;
    
    IF(status(5) = '1') THEN
       report ""Empty flag Mismatch/timeout""
       severity error;
    END IF;

    IF(status(6) = '1') THEN
       report ""Full Flag Mismatch/timeout""
       severity error;
    END IF;
  END PROCESS;


  PROCESS 
  BEGIN
    wait until sim_done = '1';
    IF(status /= ""0"" AND status /= ""1"") THEN
      report ""Simulation failed""
      severity failure;
    ELSE
      report ""Test Completed Successfully""
      severity failure;
    END IF;
  END PROCESS;
  
  PROCESS
  BEGIN
    wait for 400 ms;
    report ""Test bench timed out""
    severity failure;
  END PROCESS;

  -- Instance of system_axi_vdma_0_wrapper_fifo_generator_v9_3_synth
  
  system_axi_vdma_0_wrapper_fifo_generator_v9_3_synth_inst:system_axi_vdma_0_wrapper_fifo_generator_v9_3_synth
   GENERIC MAP(
              FREEZEON_ERROR => 0,
 	      TB_STOP_CNT    => 2,
 	      TB_SEED        => 70 
 	      )
  PORT MAP(
	   CLK           => wr_clk,
	   RESET         => reset,
	   SIM_DONE      => sim_done,
           STATUS        => status
	  );

END ARCHITECTURE;
","['false', 'false', 'false', 'false', 'false', 'false', 'false']",7,['or'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
['or']
*Code:

--------------------------------------------------------------------------------
--
-- FIFO Generator Core Demo Testbench 
--
--------------------------------------------------------------------------------
--
-- (c) Copyright 2009 - 2010 Xilinx, Inc. All rights reserved.
-- 
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
-- 
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE ""AS IS"" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
-- 
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, ""Critical
-- Applications""). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
-- 
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--------------------------------------------------------------------------------
--
-- Filename: system_axi_vdma_0_wrapper_fifo_generator_v9_3_tb.vhd
--
-- Description:
--   This is the demo testbench top file for fifo_generator core.
--
--------------------------------------------------------------------------------
-- Library Declarations
--------------------------------------------------------------------------------
LIBRARY ieee;
LIBRARY std;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.ALL;
USE IEEE.std_logic_arith.ALL;
USE IEEE.std_logic_misc.ALL;
USE ieee.numeric_std.ALL;
USE ieee.std_logic_textio.ALL;
USE std.textio.ALL;

LIBRARY work;
USE work.system_axi_vdma_0_wrapper_fifo_generator_v9_3_pkg.ALL;

ENTITY system_axi_vdma_0_wrapper_fifo_generator_v9_3_tb IS
END ENTITY;


ARCHITECTURE system_axi_vdma_0_wrapper_fifo_generator_v9_3_arch OF system_axi_vdma_0_wrapper_fifo_generator_v9_3_tb IS
 SIGNAL  status              : STD_LOGIC_VECTOR(7 DOWNTO 0) := ""00000000"";
 SIGNAL  wr_clk              : STD_LOGIC;
 SIGNAL  reset 	             : STD_LOGIC;
 SIGNAL  sim_done            : STD_LOGIC := '0';
 SIGNAL  end_of_sim          : STD_LOGIC_VECTOR(4 DOWNTO 0) := (OTHERS => '0');
 -- Write and Read clock periods
 CONSTANT wr_clk_period_by_2 : TIME := 100 ns;
 -- Procedures to display strings
 PROCEDURE disp_str(CONSTANT str:IN STRING) IS
    variable dp_l : line := null;   
 BEGIN
  write(dp_l,str);
  writeline(output,dp_l);
 END PROCEDURE;
 
 PROCEDURE disp_hex(signal hex:IN STD_LOGIC_VECTOR(7 DOWNTO 0)) IS
    variable dp_lx : line := null;   
 BEGIN
  hwrite(dp_lx,hex);
  writeline(output,dp_lx);
 END PROCEDURE;

BEGIN
  
  -- Generation of clock

  PROCESS BEGIN
    WAIT FOR 200 ns; -- Wait for global reset
    WHILE 1 = 1 LOOP
      wr_clk <= '0';
      WAIT FOR wr_clk_period_by_2;
      wr_clk <= '1'; 
      WAIT FOR wr_clk_period_by_2;
    END LOOP;
  END PROCESS;
  
  -- Generation of Reset
  
  PROCESS BEGIN
    reset <= '1';
    WAIT FOR 2100 ns;
    reset <= '0';
    WAIT;
  END PROCESS;
  
  
  -- Error message printing based on STATUS signal from system_axi_vdma_0_wrapper_fifo_generator_v9_3_synth

  PROCESS(status)
  BEGIN
    IF(status /= ""0"" AND status /= ""1"") THEN
      disp_str(""STATUS:"");
      disp_hex(status);
    END IF;

    IF(status(7) = '1') THEN
       report ""Data mismatch found""
       severity error;
    END IF;

    IF(status(1) = '1') THEN
    END IF;
    
    
    IF(status(3) = '1') THEN
       report ""Almost Empty flag Mismatch/timeout""
       severity error;
    END IF;
    
    IF(status(5) = '1') THEN
       report ""Empty flag Mismatch/timeout""
       severity error;
    END IF;

    IF(status(6) = '1') THEN
       report ""Full Flag Mismatch/timeout""
       severity error;
    END IF;
  END PROCESS;


  PROCESS 
  BEGIN
    wait until sim_done = '1';
    IF(status /= ""0"" AND status /= ""1"") THEN
      report ""Simulation failed""
      severity failure;
    ELSE
      report ""Test Completed Successfully""
      severity failure;
    END IF;
  END PROCESS;
  
  PROCESS
  BEGIN
    wait for 400 ms;
    report ""Test bench timed out""
    severity failure;
  END PROCESS;

  -- Instance of system_axi_vdma_0_wrapper_fifo_generator_v9_3_synth
  
  system_axi_vdma_0_wrapper_fifo_generator_v9_3_synth_inst:system_axi_vdma_0_wrapper_fifo_generator_v9_3_synth
   GENERIC MAP(
              FREEZEON_ERROR => 0,
 	      TB_STOP_CNT    => 2,
 	      TB_SEED        => 70 
 	      )
  PORT MAP(
	   CLK           => wr_clk,
	   RESET         => reset,
	   SIM_DONE      => sim_done,
           STATUS        => status
	  );

END ARCHITECTURE;
",7540,"Based on the provided Verilog code, here are the assertion checks that can be applied:

1) Assert that 'wr_clk' and 'reset' can accept boolean values since they are STD_LOGIC type variables.
2) Assert that 'status' is 8 bit long since it's a STD_LOGIC_VECTOR from 7 DOWNTO 0.
3) Assert that 'sim_done' can take boolean values, as it's of STD_LOGIC type.

However, we can't provide these assertions in the way they are usually provided in the format of the language you specified before, i.e. (timing, subject_variable, target, reasoning), since these details aren't specified in the Verilog code. 

In code form, they might look like the following:

```verilog
// Assertion for 'wr_clk'
always@(wr_clk) begin
    assert(wr_clk == 1'b0 || wr_clk == 1'b1)
        else $display(""Error: wr_clk should be a boolean value"");
end

// Assertion for 'reset'
always@(reset) begin
    assert(reset == 1'b0 || reset == 1'b1)
        else $display(""Error: reset should be a boolean value"");
end

// Assertion for 'status'
always@(status) begin
    assert($countones(status) <= 8)
        else $display(""Error: status should be 8 bit long"");
end

// Assertion for 'sim_done'
always@(sim_done) begin
    assert(sim_done == 1'b0 || sim_done == 1'b1)
        else $display(""Error: sim_done should be a boolean value"");
end
```

Please note that the actual syntax to use depends on your RTL simulation tool. It's also important to note that Verilog is not a high level programming language like Python or C++, but a hardware description language. Its assertions do not work the same way as high level language assertions. Also, in this context, the timing is usually managed implicitly by the clock edges and not usually embedded within assertion statements."
532,3027,nickg/nvc,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version.

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details.

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

-- ---------------------------------------------------------------------
--
-- $Id: tc1488.vhd,v 1.2 2001-10-26 16:29:41 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY vests4 IS
END vests4;

ARCHITECTURE c08s08b00x00p04n03i01488arch OF vests4 IS

BEGIN
  TESTING: PROCESS
    variable m : integer := 7;
    variable k : integer := 0;
  BEGIN
    case m is
      when integer'Low to -11 | 6 to 100 =>   k := 5;
      when others    =>   NULL;
    end case;
    assert NOT( k = 5 )
      report ""***PASSED TEST: c08s08b00x00p04n03i01488""
      severity NOTE;
    assert ( k = 5 )
      report ""***FAILED TEST: c08s08b00x00p04n03i01488 - Each choice in a case statement alternative must be of the same type as the expression.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s08b00x00p04n03i01488arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version.

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details.

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

-- ---------------------------------------------------------------------
--
-- $Id: tc1488.vhd,v 1.2 2001-10-26 16:29:41 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY vests4 IS
END vests4;

ARCHITECTURE c08s08b00x00p04n03i01488arch OF vests4 IS

BEGIN
  TESTING: PROCESS
    variable m : integer := 7;
    variable k : integer := 0;
  BEGIN
    case m is
      when integer'Low to -11 | 6 to 100 =>   k := 5;
      when others    =>   NULL;
    end case;
      report ""***PASSED TEST: c08s08b00x00p04n03i01488""
      severity NOTE;
      report ""***FAILED TEST: c08s08b00x00p04n03i01488 - Each choice in a case statement alternative must be of the same type as the expression.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s08b00x00p04n03i01488arch;
","['NOT( k = 5 )', '( k = 5 )']",2,"[':= 0', ':= 7']",2,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 0', ':= 7']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version.

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details.

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

-- ---------------------------------------------------------------------
--
-- $Id: tc1488.vhd,v 1.2 2001-10-26 16:29:41 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY vests4 IS
END vests4;

ARCHITECTURE c08s08b00x00p04n03i01488arch OF vests4 IS

BEGIN
  TESTING: PROCESS
    variable m : integer := 7;
    variable k : integer := 0;
  BEGIN
    case m is
      when integer'Low to -11 | 6 to 100 =>   k := 5;
      when others    =>   NULL;
    end case;
      report ""***PASSED TEST: c08s08b00x00p04n03i01488""
      severity NOTE;
      report ""***FAILED TEST: c08s08b00x00p04n03i01488 - Each choice in a case statement alternative must be of the same type as the expression.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s08b00x00p04n03i01488arch;
",3270,"The given Verilog code does not define a conventional synchronous design with clock signals and port maps, i.e., it does not explicitly define input or output sizes. Hence, it is challenging to apply the assertion criteria provided in the preamble. 

However, if you're looking to add assertions based on the code's present structure here's an indicative list:

['TESTING process', m, 7, ""m should be initialized as 7 at the start of TESTING process""]
['TESTING process', k, 0, ""k should be initialized as 0 at the start of TESTING process""]
['TESTING process', k, 5, ""k should be equal to 5 when m is within the range of integer'Low to -11 or 6 to 100""]"
533,3047,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1220.vhd,v 1.2 2001-10-26 16:29:39 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s01b00x00p27n01i01220ent IS
END c08s01b00x00p27n01i01220ent;

ARCHITECTURE c08s01b00x00p27n01i01220arch OF c08s01b00x00p27n01i01220ent IS

BEGIN
  TESTING: PROCESS
    variable y : time := 0 ns;
  BEGIN
    y := now;
    wait for 20 ns;
    y := now - y;
    assert NOT( y = 20 ns )
      report ""***PASSED TEST: c08s01b00x00p27n01i01220""
      severity NOTE;
    assert ( y = 20 ns )
      report ""***FAILED TEST: c08s01b00x00p27n01i01220 - The suspended process does not resume immediately after the timeout interval has expired.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s01b00x00p27n01i01220arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1220.vhd,v 1.2 2001-10-26 16:29:39 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s01b00x00p27n01i01220ent IS
END c08s01b00x00p27n01i01220ent;

ARCHITECTURE c08s01b00x00p27n01i01220arch OF c08s01b00x00p27n01i01220ent IS

BEGIN
  TESTING: PROCESS
    variable y : time := 0 ns;
  BEGIN
    y := now;
    wait for 20 ns;
    y := now - y;
      report ""***PASSED TEST: c08s01b00x00p27n01i01220""
      severity NOTE;
      report ""***FAILED TEST: c08s01b00x00p27n01i01220 - The suspended process does not resume immediately after the timeout interval has expired.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s01b00x00p27n01i01220arch;
","['NOT( y = 20 ns )', '( y = 20 ns )']",2,[':= 0 ns'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 0 ns']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1220.vhd,v 1.2 2001-10-26 16:29:39 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s01b00x00p27n01i01220ent IS
END c08s01b00x00p27n01i01220ent;

ARCHITECTURE c08s01b00x00p27n01i01220arch OF c08s01b00x00p27n01i01220ent IS

BEGIN
  TESTING: PROCESS
    variable y : time := 0 ns;
  BEGIN
    y := now;
    wait for 20 ns;
    y := now - y;
      report ""***PASSED TEST: c08s01b00x00p27n01i01220""
      severity NOTE;
      report ""***FAILED TEST: c08s01b00x00p27n01i01220 - The suspended process does not resume immediately after the timeout interval has expired.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s01b00x00p27n01i01220arch;
",3240,"Given that the input doesn't provide specific variable states and transitions, no assertions can be generated based on the given criteria. The code, written on VHDL rather than Verilog, seems to be a test setup that doesn't include variables for the intended flow of the function. Please provide appropriate Verilog code snippets for the assertion generation."
534,3049,nickg/nvc,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version.

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details.

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

-- ---------------------------------------------------------------------
--
-- $Id: tc2094.vhd,v 1.2 2001-10-26 16:29:45 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY vests9 IS
END vests9;

ARCHITECTURE c07s02b04x00p20n01i02094arch OF vests9 IS

  TYPE  boolean_v is array (integer range <>) of boolean;
  SUBTYPE boolean_4  is boolean_v (1 to 4);
  SUBTYPE boolean_8  is boolean_v (1 to 8);

  FUNCTION return_array RETURN boolean_4 is
    constant l_operand : boolean_4 := (true,false,true,false);
  begin
    RETURN l_operand;
  end return_array;

BEGIN
  l : block
    generic ( info : boolean_8 );
    generic map ( return_array & return_array );
  begin
    assert NOT(info = (true,false,true,false,true,false,true,false))
      report ""***PASSED TEST: c07s02b04x00p20n01i02094""
      severity NOTE;
    assert (info = (true,false,true,false,true,false,true,false))
      report ""***FAILED TEST: c07s02b04x00p20n01i02094 - Function array concatenation did not succeed.""
      severity ERROR;
  end block;

END c07s02b04x00p20n01i02094arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version.

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details.

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

-- ---------------------------------------------------------------------
--
-- $Id: tc2094.vhd,v 1.2 2001-10-26 16:29:45 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY vests9 IS
END vests9;

ARCHITECTURE c07s02b04x00p20n01i02094arch OF vests9 IS

  TYPE  boolean_v is array (integer range <>) of boolean;
  SUBTYPE boolean_4  is boolean_v (1 to 4);
  SUBTYPE boolean_8  is boolean_v (1 to 8);

  FUNCTION return_array RETURN boolean_4 is
    constant l_operand : boolean_4 := (true,false,true,false);
  begin
    RETURN l_operand;
  end return_array;

BEGIN
  l : block
    generic ( info : boolean_8 );
    generic map ( return_array & return_array );
  begin
      report ""***PASSED TEST: c07s02b04x00p20n01i02094""
      severity NOTE;
      report ""***FAILED TEST: c07s02b04x00p20n01i02094 - Function array concatenation did not succeed.""
      severity ERROR;
  end block;

END c07s02b04x00p20n01i02094arch;
","['NOT(info = (true,false,true,false,true,false,true,false))', '(info = (true,false,true,false,true,false,true,false))']",2,['range <>) of boolean'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
['range <>) of boolean']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version.

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details.

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

-- ---------------------------------------------------------------------
--
-- $Id: tc2094.vhd,v 1.2 2001-10-26 16:29:45 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY vests9 IS
END vests9;

ARCHITECTURE c07s02b04x00p20n01i02094arch OF vests9 IS

  TYPE  boolean_v is array (integer range <>) of boolean;
  SUBTYPE boolean_4  is boolean_v (1 to 4);
  SUBTYPE boolean_8  is boolean_v (1 to 8);

  FUNCTION return_array RETURN boolean_4 is
    constant l_operand : boolean_4 := (true,false,true,false);
  begin
    RETURN l_operand;
  end return_array;

BEGIN
  l : block
    generic ( info : boolean_8 );
    generic map ( return_array & return_array );
  begin
      report ""***PASSED TEST: c07s02b04x00p20n01i02094""
      severity NOTE;
      report ""***FAILED TEST: c07s02b04x00p20n01i02094 - Function array concatenation did not succeed.""
      severity ERROR;
  end block;

END c07s02b04x00p20n01i02094arch;
",3421,"[""l_operand"", boolean_4, None, ""l_operand should return an array of boolean_4 size""],
[""info"", boolean_8, None, ""info should accommodate an array of boolean_8 size""]"
535,3051,schmr/grlib,"------------------------------------------------------------------------------
--  This file is a part of the GRLIB VHDL IP LIBRARY
--  Copyright (C) 2003 - 2008, Gaisler Research
--  Copyright (C) 2008 - 2014, Aeroflex Gaisler
--
--  This program is free software; you can redistribute it and/or modify
--  it under the terms of the GNU General Public License as published by
--  the Free Software Foundation; either version 2 of the License, or
--  (at your option) any later version.
--
--  This program is distributed in the hope that it will be useful,
--  but WITHOUT ANY WARRANTY; without even the implied warranty of
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--  GNU General Public License for more details.
--
--  You should have received a copy of the GNU General Public License
--  along with this program; if not, write to the Free Software
--  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
-----------------------------------------------------------------------------
-- Entity: 	syncram128bw
-- File:	syncram128bw.vhd
-- Author:	Jiri Gaisler - Gaisler Research
-- Description:	128-bit syncronous 1-port ram with 8-bit write strobes
--		and tech selection
------------------------------------------------------------------------------

library ieee;
library techmap;
use ieee.std_logic_1164.all;
use techmap.gencomp.all;
library grlib;
use grlib.config.all;
use grlib.config_types.all;
use grlib.stdlib.all;

entity syncram128bw is
  generic (tech : integer := 0; abits : integer := 6; testen : integer := 0; custombits: integer := 1);
  port (
    clk     : in  std_ulogic;
    address : in  std_logic_vector (abits -1 downto 0);
    datain  : in  std_logic_vector (127 downto 0);
    dataout : out std_logic_vector (127 downto 0);
    enable  : in  std_logic_vector (15 downto 0);
    write   : in  std_logic_vector (15 downto 0);
    testin  : in  std_logic_vector (TESTIN_WIDTH-1 downto 0) := testin_none;
    customclk: in std_ulogic := '0';
    customin : in std_logic_vector(16*custombits-1 downto 0) := (others => '0');
    customout:out std_logic_vector(16*custombits-1 downto 0));
end;

architecture rtl of syncram128bw is

  component unisim_syncram128bw
  generic ( abits : integer := 9);
  port (
    clk     : in  std_ulogic;
    address : in  std_logic_vector (abits -1 downto 0);
    datain  : in  std_logic_vector (127 downto 0);
    dataout : out std_logic_vector (127 downto 0);
    enable  : in  std_logic_vector (15 downto 0);
    write   : in  std_logic_vector (15 downto 0)
  );
  end component;

  component altera_syncram128bw
  generic ( abits : integer := 9);
  port (
    clk     : in std_ulogic;
    address : in std_logic_vector (abits -1 downto 0);
    datain  : in std_logic_vector (127 downto 0);
    dataout : out std_logic_vector (127 downto 0);
    enable  : in  std_logic_vector (15 downto 0);
    write   : in  std_logic_vector (15 downto 0)
  );
  end component;

  component tm65gplus_syncram128bw
  generic ( abits : integer := 9);
  port (
    clk     : in  std_ulogic;
    address : in  std_logic_vector (abits -1 downto 0);
    datain  : in  std_logic_vector (127 downto 0);
    dataout : out std_logic_vector (127 downto 0);
    enable  : in  std_logic_vector (15 downto 0);
    write   : in  std_logic_vector (15 downto 0);
    testin  : in  std_logic_vector (3 downto 0) := ""0000""
  );
  end component;

  component ut90nhbd_syncram128bw
  generic ( abits : integer := 9);
  port (
    clk     : in  std_ulogic;
    address : in  std_logic_vector (abits -1 downto 0);
    datain  : in  std_logic_vector (127 downto 0);
    dataout : out std_logic_vector (127 downto 0);
    enable  : in  std_logic_vector (15 downto 0);
    write   : in  std_logic_vector (15 downto 0);
    tdbn    : in  std_ulogic
  );
  end component;

  signal xenable, xwrite : std_logic_vector(15 downto 0);
  signal custominx,customoutx: std_logic_vector(syncram_customif_maxwidth downto 0);

begin

  xenable <= enable when testen=0 or testin(TESTIN_WIDTH-2)='0' else (others => '0');
  xwrite <= write when testen=0 or testin(TESTIN_WIDTH-2)='0' else (others => '0');

  custominx(custominx'high downto custombits) <= (others => '0');
  custominx(custombits-1 downto 0) <= customin(custombits-1 downto 0);

  nocust: if syncram_has_customif(tech)=0 or has_sram128bw(tech)=0 generate
    customoutx <= (others => '0');
  end generate;
  
  s64 : if has_sram128bw(tech) = 1 generate
    xc2v : if (is_unisim(tech) = 1) generate 
      x0 : unisim_syncram128bw generic map (abits)
         port map (clk, address, datain, dataout, xenable, xwrite);
    end generate;
    alt : if (tech = stratix2) or (tech = stratix3) or (tech = stratix4) or 
	(tech = cyclone3) or (tech = altera) generate
      x0 : altera_syncram128bw generic map (abits)
         port map (clk, address, datain, dataout, xenable, xwrite);
    end generate;
    tm65: if tech = tm65gplus generate
      x0 : tm65gplus_syncram128bw generic map (abits)
         port map (clk, address, datain, dataout, xenable, xwrite, testin);
    end generate;
    ut09: if tech = ut90 generate
      x0 : ut90nhbd_syncram128bw generic map (abits)
         port map (clk, address, datain, dataout, xenable, xwrite, testin(TESTIN_WIDTH-3));
    end generate;

    customout(16*custombits-1 downto custombits) <= (others => '0');
    customout(custombits-1 downto 0) <= customoutx(custombits-1 downto 0);

-- pragma translate_off
    dmsg : if GRLIB_CONFIG_ARRAY(grlib_debug_level) >= 2 generate
      x : process
      begin
        assert false report ""syncram128bw: "" & tost(2**abits) & ""x128"" &
         "" ("" & tech_table(tech) & "")""
        severity note;
        wait;
      end process;
    end generate;
-- pragma translate_on
  end generate;

  nos64 : if has_sram128bw(tech) = 0 generate
    rx : for i in 0 to 15 generate
      x0 : syncram generic map (tech, abits, 8, testen, custombits)
         port map (clk, address, datain(i*8+7 downto i*8), 
	    dataout(i*8+7 downto i*8), enable(i), write(i), testin,
                   customclk, customin((i+1)*custombits-1 downto i*custombits),
                   customout((i+1)*custombits-1 downto i*custombits));
    end generate;
  end generate;

end;

","
------------------------------------------------------------------------------
--  This file is a part of the GRLIB VHDL IP LIBRARY
--  Copyright (C) 2003 - 2008, Gaisler Research
--  Copyright (C) 2008 - 2014, Aeroflex Gaisler
--
--  This program is free software; you can redistribute it and/or modify
--  it under the terms of the GNU General Public License as published by
--  the Free Software Foundation; either version 2 of the License, or
--  (at your option) any later version.
--
--  This program is distributed in the hope that it will be useful,
--  but WITHOUT ANY WARRANTY; without even the implied warranty of
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--  GNU General Public License for more details.
--
--  You should have received a copy of the GNU General Public License
--  along with this program; if not, write to the Free Software
--  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
-----------------------------------------------------------------------------
-- Entity: 	syncram128bw
-- File:	syncram128bw.vhd
-- Author:	Jiri Gaisler - Gaisler Research
-- Description:	128-bit syncronous 1-port ram with 8-bit write strobes
--		and tech selection
------------------------------------------------------------------------------

library ieee;
library techmap;
use ieee.std_logic_1164.all;
use techmap.gencomp.all;
library grlib;
use grlib.config.all;
use grlib.config_types.all;
use grlib.stdlib.all;

entity syncram128bw is
  generic (tech : integer := 0; abits : integer := 6; testen : integer := 0; custombits: integer := 1);
  port (
    clk     : in  std_ulogic;
    address : in  std_logic_vector (abits -1 downto 0);
    datain  : in  std_logic_vector (127 downto 0);
    dataout : out std_logic_vector (127 downto 0);
    enable  : in  std_logic_vector (15 downto 0);
    write   : in  std_logic_vector (15 downto 0);
    testin  : in  std_logic_vector (TESTIN_WIDTH-1 downto 0) := testin_none;
    customclk: in std_ulogic := '0';
    customin : in std_logic_vector(16*custombits-1 downto 0) := (others => '0');
    customout:out std_logic_vector(16*custombits-1 downto 0));
end;

architecture rtl of syncram128bw is

  component unisim_syncram128bw
  generic ( abits : integer := 9);
  port (
    clk     : in  std_ulogic;
    address : in  std_logic_vector (abits -1 downto 0);
    datain  : in  std_logic_vector (127 downto 0);
    dataout : out std_logic_vector (127 downto 0);
    enable  : in  std_logic_vector (15 downto 0);
    write   : in  std_logic_vector (15 downto 0)
  );
  end component;

  component altera_syncram128bw
  generic ( abits : integer := 9);
  port (
    clk     : in std_ulogic;
    address : in std_logic_vector (abits -1 downto 0);
    datain  : in std_logic_vector (127 downto 0);
    dataout : out std_logic_vector (127 downto 0);
    enable  : in  std_logic_vector (15 downto 0);
    write   : in  std_logic_vector (15 downto 0)
  );
  end component;

  component tm65gplus_syncram128bw
  generic ( abits : integer := 9);
  port (
    clk     : in  std_ulogic;
    address : in  std_logic_vector (abits -1 downto 0);
    datain  : in  std_logic_vector (127 downto 0);
    dataout : out std_logic_vector (127 downto 0);
    enable  : in  std_logic_vector (15 downto 0);
    write   : in  std_logic_vector (15 downto 0);
    testin  : in  std_logic_vector (3 downto 0) := ""0000""
  );
  end component;

  component ut90nhbd_syncram128bw
  generic ( abits : integer := 9);
  port (
    clk     : in  std_ulogic;
    address : in  std_logic_vector (abits -1 downto 0);
    datain  : in  std_logic_vector (127 downto 0);
    dataout : out std_logic_vector (127 downto 0);
    enable  : in  std_logic_vector (15 downto 0);
    write   : in  std_logic_vector (15 downto 0);
    tdbn    : in  std_ulogic
  );
  end component;

  signal xenable, xwrite : std_logic_vector(15 downto 0);
  signal custominx,customoutx: std_logic_vector(syncram_customif_maxwidth downto 0);

begin

  xenable <= enable when testen=0 or testin(TESTIN_WIDTH-2)='0' else (others => '0');
  xwrite <= write when testen=0 or testin(TESTIN_WIDTH-2)='0' else (others => '0');

  custominx(custominx'high downto custombits) <= (others => '0');
  custominx(custombits-1 downto 0) <= customin(custombits-1 downto 0);

  nocust: if syncram_has_customif(tech)=0 or has_sram128bw(tech)=0 generate
    customoutx <= (others => '0');
  end generate;
  
  s64 : if has_sram128bw(tech) = 1 generate
    xc2v : if (is_unisim(tech) = 1) generate 
      x0 : unisim_syncram128bw generic map (abits)
         port map (clk, address, datain, dataout, xenable, xwrite);
    end generate;
    alt : if (tech = stratix2) or (tech = stratix3) or (tech = stratix4) or 
	(tech = cyclone3) or (tech = altera) generate
      x0 : altera_syncram128bw generic map (abits)
         port map (clk, address, datain, dataout, xenable, xwrite);
    end generate;
    tm65: if tech = tm65gplus generate
      x0 : tm65gplus_syncram128bw generic map (abits)
         port map (clk, address, datain, dataout, xenable, xwrite, testin);
    end generate;
    ut09: if tech = ut90 generate
      x0 : ut90nhbd_syncram128bw generic map (abits)
         port map (clk, address, datain, dataout, xenable, xwrite, testin(TESTIN_WIDTH-3));
    end generate;

    customout(16*custombits-1 downto custombits) <= (others => '0');
    customout(custombits-1 downto 0) <= customoutx(custombits-1 downto 0);

-- pragma translate_off
    dmsg : if GRLIB_CONFIG_ARRAY(grlib_debug_level) >= 2 generate
      x : process
      begin
         "" ("" & tech_table(tech) & "")""
        severity note;
        wait;
      end process;
    end generate;
-- pragma translate_on
  end generate;

  nos64 : if has_sram128bw(tech) = 0 generate
    rx : for i in 0 to 15 generate
      x0 : syncram generic map (tech, abits, 8, testen, custombits)
         port map (clk, address, datain(i*8+7 downto i*8), 
	    dataout(i*8+7 downto i*8), enable(i), write(i), testin,
                   customclk, customin((i+1)*custombits-1 downto i*custombits),
                   customout((i+1)*custombits-1 downto i*custombits));
    end generate;
  end generate;

end;

","['false report ""syncram128bw: "" & tost(2**abits) & ""x128"" &']",1,"[':= 0', ':= 1)', ':= 9)', ':= 6']",4,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 0', ':= 1)', ':= 9)', ':= 6']
*Code:

------------------------------------------------------------------------------
--  This file is a part of the GRLIB VHDL IP LIBRARY
--  Copyright (C) 2003 - 2008, Gaisler Research
--  Copyright (C) 2008 - 2014, Aeroflex Gaisler
--
--  This program is free software; you can redistribute it and/or modify
--  it under the terms of the GNU General Public License as published by
--  the Free Software Foundation; either version 2 of the License, or
--  (at your option) any later version.
--
--  This program is distributed in the hope that it will be useful,
--  but WITHOUT ANY WARRANTY; without even the implied warranty of
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--  GNU General Public License for more details.
--
--  You should have received a copy of the GNU General Public License
--  along with this program; if not, write to the Free Software
--  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
-----------------------------------------------------------------------------
-- Entity: 	syncram128bw
-- File:	syncram128bw.vhd
-- Author:	Jiri Gaisler - Gaisler Research
-- Description:	128-bit syncronous 1-port ram with 8-bit write strobes
--		and tech selection
------------------------------------------------------------------------------

library ieee;
library techmap;
use ieee.std_logic_1164.all;
use techmap.gencomp.all;
library grlib;
use grlib.config.all;
use grlib.config_types.all;
use grlib.stdlib.all;

entity syncram128bw is
  generic (tech : integer := 0; abits : integer := 6; testen : integer := 0; custombits: integer := 1);
  port (
    clk     : in  std_ulogic;
    address : in  std_logic_vector (abits -1 downto 0);
    datain  : in  std_logic_vector (127 downto 0);
    dataout : out std_logic_vector (127 downto 0);
    enable  : in  std_logic_vector (15 downto 0);
    write   : in  std_logic_vector (15 downto 0);
    testin  : in  std_logic_vector (TESTIN_WIDTH-1 downto 0) := testin_none;
    customclk: in std_ulogic := '0';
    customin : in std_logic_vector(16*custombits-1 downto 0) := (others => '0');
    customout:out std_logic_vector(16*custombits-1 downto 0));
end;

architecture rtl of syncram128bw is

  component unisim_syncram128bw
  generic ( abits : integer := 9);
  port (
    clk     : in  std_ulogic;
    address : in  std_logic_vector (abits -1 downto 0);
    datain  : in  std_logic_vector (127 downto 0);
    dataout : out std_logic_vector (127 downto 0);
    enable  : in  std_logic_vector (15 downto 0);
    write   : in  std_logic_vector (15 downto 0)
  );
  end component;

  component altera_syncram128bw
  generic ( abits : integer := 9);
  port (
    clk     : in std_ulogic;
    address : in std_logic_vector (abits -1 downto 0);
    datain  : in std_logic_vector (127 downto 0);
    dataout : out std_logic_vector (127 downto 0);
    enable  : in  std_logic_vector (15 downto 0);
    write   : in  std_logic_vector (15 downto 0)
  );
  end component;

  component tm65gplus_syncram128bw
  generic ( abits : integer := 9);
  port (
    clk     : in  std_ulogic;
    address : in  std_logic_vector (abits -1 downto 0);
    datain  : in  std_logic_vector (127 downto 0);
    dataout : out std_logic_vector (127 downto 0);
    enable  : in  std_logic_vector (15 downto 0);
    write   : in  std_logic_vector (15 downto 0);
    testin  : in  std_logic_vector (3 downto 0) := ""0000""
  );
  end component;

  component ut90nhbd_syncram128bw
  generic ( abits : integer := 9);
  port (
    clk     : in  std_ulogic;
    address : in  std_logic_vector (abits -1 downto 0);
    datain  : in  std_logic_vector (127 downto 0);
    dataout : out std_logic_vector (127 downto 0);
    enable  : in  std_logic_vector (15 downto 0);
    write   : in  std_logic_vector (15 downto 0);
    tdbn    : in  std_ulogic
  );
  end component;

  signal xenable, xwrite : std_logic_vector(15 downto 0);
  signal custominx,customoutx: std_logic_vector(syncram_customif_maxwidth downto 0);

begin

  xenable <= enable when testen=0 or testin(TESTIN_WIDTH-2)='0' else (others => '0');
  xwrite <= write when testen=0 or testin(TESTIN_WIDTH-2)='0' else (others => '0');

  custominx(custominx'high downto custombits) <= (others => '0');
  custominx(custombits-1 downto 0) <= customin(custombits-1 downto 0);

  nocust: if syncram_has_customif(tech)=0 or has_sram128bw(tech)=0 generate
    customoutx <= (others => '0');
  end generate;
  
  s64 : if has_sram128bw(tech) = 1 generate
    xc2v : if (is_unisim(tech) = 1) generate 
      x0 : unisim_syncram128bw generic map (abits)
         port map (clk, address, datain, dataout, xenable, xwrite);
    end generate;
    alt : if (tech = stratix2) or (tech = stratix3) or (tech = stratix4) or 
	(tech = cyclone3) or (tech = altera) generate
      x0 : altera_syncram128bw generic map (abits)
         port map (clk, address, datain, dataout, xenable, xwrite);
    end generate;
    tm65: if tech = tm65gplus generate
      x0 : tm65gplus_syncram128bw generic map (abits)
         port map (clk, address, datain, dataout, xenable, xwrite, testin);
    end generate;
    ut09: if tech = ut90 generate
      x0 : ut90nhbd_syncram128bw generic map (abits)
         port map (clk, address, datain, dataout, xenable, xwrite, testin(TESTIN_WIDTH-3));
    end generate;

    customout(16*custombits-1 downto custombits) <= (others => '0');
    customout(custombits-1 downto 0) <= customoutx(custombits-1 downto 0);

-- pragma translate_off
    dmsg : if GRLIB_CONFIG_ARRAY(grlib_debug_level) >= 2 generate
      x : process
      begin
         "" ("" & tech_table(tech) & "")""
        severity note;
        wait;
      end process;
    end generate;
-- pragma translate_on
  end generate;

  nos64 : if has_sram128bw(tech) = 0 generate
    rx : for i in 0 to 15 generate
      x0 : syncram generic map (tech, abits, 8, testen, custombits)
         port map (clk, address, datain(i*8+7 downto i*8), 
	    dataout(i*8+7 downto i*8), enable(i), write(i), testin,
                   customclk, customin((i+1)*custombits-1 downto i*custombits),
                   customout((i+1)*custombits-1 downto i*custombits));
    end generate;
  end generate;

end;

",7687,"["":= 0"", ""datain"", 128, ""datain should be 128 bits wide""],
["":= 0"", ""dataout"", 128, ""dataout should be 128 bits wide""],
["":= 0"", ""enable"", 16, ""enable should be 16 bits wide""],
["":= 0"", ""write"", 16, ""write should be 16 bits wide""],
["":= 0"", ""address"", ""6"", ""address should be 6 bits wide""],
["":= 1)"", ""clk"", None, ""a clock signal is expected""],
[""clk"", ""enable"", None, ""the enable signal should always be available""],
[""clk"", ""write"", None, ""the write signal should always be available""],
[""clk"", ""datain"", None, ""the datain signal should always be available""],
[""clk"", ""address"", None, ""the address signal should always be available""]"
536,3059,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2589.vhd,v 1.2 2001-10-26 16:30:20 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c13s03b01x00p02n01i02589ent IS
END c13s03b01x00p02n01i02589ent;

ARCHITECTURE c13s03b01x00p02n01i02589arch OF c13s03b01x00p02n01i02589ent IS

BEGIN
  TESTING: PROCESS
    variable k+ : integer := 0;
  BEGIN
    assert FALSE 
      report ""***FAILED TEST: c13s03b01x00p02n01i02589 - Identifier can not end with '+'.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c13s03b01x00p02n01i02589arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2589.vhd,v 1.2 2001-10-26 16:30:20 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c13s03b01x00p02n01i02589ent IS
END c13s03b01x00p02n01i02589ent;

ARCHITECTURE c13s03b01x00p02n01i02589arch OF c13s03b01x00p02n01i02589ent IS

BEGIN
  TESTING: PROCESS
    variable k+ : integer := 0;
  BEGIN
      report ""***FAILED TEST: c13s03b01x00p02n01i02589 - Identifier can not end with '+'.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c13s03b01x00p02n01i02589arch;
",['FALSE'],1,[':= 0'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 0']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2589.vhd,v 1.2 2001-10-26 16:30:20 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c13s03b01x00p02n01i02589ent IS
END c13s03b01x00p02n01i02589ent;

ARCHITECTURE c13s03b01x00p02n01i02589arch OF c13s03b01x00p02n01i02589ent IS

BEGIN
  TESTING: PROCESS
    variable k+ : integer := 0;
  BEGIN
      report ""***FAILED TEST: c13s03b01x00p02n01i02589 - Identifier can not end with '+'.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c13s03b01x00p02n01i02589arch;
",3052,"The given code appears to be VHDL, not Verilog. As such, assertions might also be VHDL, not the provided format. Unfortunately, the format is only for Verilog assertions, which are different from VHDL assertions. Furthermore, given the code, there is no explicit variable interaction or output size to assert. All it does is initialize an integer variable and output a failure message. An assertion for this would not be very meaningful, if even possible, as the code doesn't seem complete or be performing meaningful actions beyond error handling. 

Apologies for any inconvenience, but I'm only capable of adding assertions in the format specified for Verilog code or other similar formats. Nonetheless, if you are seeking to add assertions for VHDL here, the format and methodology to do so would be different and we don't have any interactions or sizes at disposal to perform checks via an assertion."
537,3063,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1558.vhd,v 1.2 2001-10-26 16:29:42 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s10b00x00p03n01i01558ent IS
END c08s10b00x00p03n01i01558ent;

ARCHITECTURE c08s10b00x00p03n01i01558arch OF c08s10b00x00p03n01i01558ent IS

BEGIN
  TESTING: PROCESS
    variable k : integer := 0;
  BEGIN
    L : for i in 1 to 10 loop
      next L;
      k := 5;
    end loop;
    assert NOT( k=0 )
      report ""***PASSED TEST: c08s10b00x00p03n01i01558""
      severity NOTE;
    assert ( k=0 )
      report ""***FAILED TEST: c08s10b00x00p03n01i01558 - a next statement with a loop label is allowed inside a labeled loop""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s10b00x00p03n01i01558arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1558.vhd,v 1.2 2001-10-26 16:29:42 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s10b00x00p03n01i01558ent IS
END c08s10b00x00p03n01i01558ent;

ARCHITECTURE c08s10b00x00p03n01i01558arch OF c08s10b00x00p03n01i01558ent IS

BEGIN
  TESTING: PROCESS
    variable k : integer := 0;
  BEGIN
    L : for i in 1 to 10 loop
      next L;
      k := 5;
    end loop;
      report ""***PASSED TEST: c08s10b00x00p03n01i01558""
      severity NOTE;
      report ""***FAILED TEST: c08s10b00x00p03n01i01558 - a next statement with a loop label is allowed inside a labeled loop""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s10b00x00p03n01i01558arch;
","['NOT( k=0 )', '( k=0 )']",2,[':= 0'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 0']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1558.vhd,v 1.2 2001-10-26 16:29:42 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c08s10b00x00p03n01i01558ent IS
END c08s10b00x00p03n01i01558ent;

ARCHITECTURE c08s10b00x00p03n01i01558arch OF c08s10b00x00p03n01i01558ent IS

BEGIN
  TESTING: PROCESS
    variable k : integer := 0;
  BEGIN
    L : for i in 1 to 10 loop
      next L;
      k := 5;
    end loop;
      report ""***PASSED TEST: c08s10b00x00p03n01i01558""
      severity NOTE;
      report ""***FAILED TEST: c08s10b00x00p03n01i01558 - a next statement with a loop label is allowed inside a labeled loop""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c08s10b00x00p03n01i01558arch;
",3235,"Without knowing the size of the integer variable 'k' and without any specified inputs or outputs, it isn't possible to generate assertions. This piece of code doesn't provide enough information to create assertions related to its functionality according to the rules specified."
538,3076,wfjm/w11,"-- $Id: rb_mon_sb.vhd 1181 2019-07-08 17:00:50Z mueller $
-- SPDX-License-Identifier: GPL-3.0-or-later
-- Copyright 2007-2014 by Walter F.J. Mueller <W.F.J.Mueller@gsi.de>
--
------------------------------------------------------------------------------
-- Module Name:    rb_mon_sb - sim
-- Description:    simbus wrapper for rbus monitor (for tb's)
--
-- Dependencies:   simbus
--                 simlib/simclkcnt
--                 rb_mon
-- Test bench:     -
-- Tool versions:  xst 8.2-14.7; ghdl 0.18-0.31
--
-- Revision History: 
-- Date         Rev Version  Comment
-- 2014-08-28   588   4.0    use new rlink v4 iface and 4 bit STAT
-- 2011-12-23   444   3.1    use simclkcnt instead of simbus global
-- 2010-12-22   346   3.0    renamed rritb_rbmon_sb -> rb_mon_sb
-- 2010-06-05   301   2.0.2  renamed _rpmon -> _rbmon
-- 2010-05-02   287   2.0.1  rename RP_STAT->RB_STAT,AP_LAM->RB_LAM
--                           drop RP_IINT signal from interfaces
--                           use sbcntl_sbf_cpmon def
-- 2008-08-24   162   2.0    with new rb_mreq/rb_sres interface
-- 2007-12-23   105   1.2    added AP_LAM display
-- 2007-11-24    98   1.1    added RP_IINT support
-- 2007-08-27    76   1.0    Initial version 
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

use work.slvtypes.all;
use work.simlib.all;
use work.simbus.all;
use work.rblib.all;

entity rb_mon_sb is                     -- simbus wrapper for rbus monitor
  generic (
    DBASE : positive :=  2;             -- base for writing data values
    ENAPIN : integer := sbcntl_sbf_rbmon); -- SB_CNTL signal to use for enable
  port (
    CLK  : in slbit;                    -- clock
    RB_MREQ : in rb_mreq_type;          -- rbus: request
    RB_SRES : in rb_sres_type;          -- rbus: response
    RB_LAM : in slv16 := (others=>'0'); -- rbus: look at me
    RB_STAT : in slv4                   -- rbus: status flags
  );
end rb_mon_sb;


architecture sim of rb_mon_sb is

  signal ENA : slbit := '0';
  signal CLK_CYCLE : integer := 0;
  
begin

  assert ENAPIN>=SB_CNTL'low and ENAPIN<=SB_CNTL'high
    report ""assert(ENAPIN in SB_CNTL'range)"" severity failure;

  CLKCNT : simclkcnt port map (CLK => CLK, CLK_CYCLE => CLK_CYCLE);

  ENA <= to_x01(SB_CNTL(ENAPIN));
  
  RBMON : rb_mon
    generic map (
      DBASE => DBASE)
    port map (
      CLK       => CLK,
      CLK_CYCLE => CLK_CYCLE,
      ENA       => ENA,
      RB_MREQ   => RB_MREQ,
      RB_SRES   => RB_SRES,
      RB_LAM    => RB_LAM,
      RB_STAT   => RB_STAT
    );
  
end sim;
","
-- $Id: rb_mon_sb.vhd 1181 2019-07-08 17:00:50Z mueller $
-- SPDX-License-Identifier: GPL-3.0-or-later
-- Copyright 2007-2014 by Walter F.J. Mueller <W.F.J.Mueller@gsi.de>
--
------------------------------------------------------------------------------
-- Module Name:    rb_mon_sb - sim
-- Description:    simbus wrapper for rbus monitor (for tb's)
--
-- Dependencies:   simbus
--                 simlib/simclkcnt
--                 rb_mon
-- Test bench:     -
-- Tool versions:  xst 8.2-14.7; ghdl 0.18-0.31
--
-- Revision History: 
-- Date         Rev Version  Comment
-- 2014-08-28   588   4.0    use new rlink v4 iface and 4 bit STAT
-- 2011-12-23   444   3.1    use simclkcnt instead of simbus global
-- 2010-12-22   346   3.0    renamed rritb_rbmon_sb -> rb_mon_sb
-- 2010-06-05   301   2.0.2  renamed _rpmon -> _rbmon
-- 2010-05-02   287   2.0.1  rename RP_STAT->RB_STAT,AP_LAM->RB_LAM
--                           drop RP_IINT signal from interfaces
--                           use sbcntl_sbf_cpmon def
-- 2008-08-24   162   2.0    with new rb_mreq/rb_sres interface
-- 2007-12-23   105   1.2    added AP_LAM display
-- 2007-11-24    98   1.1    added RP_IINT support
-- 2007-08-27    76   1.0    Initial version 
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

use work.slvtypes.all;
use work.simlib.all;
use work.simbus.all;
use work.rblib.all;

entity rb_mon_sb is                     -- simbus wrapper for rbus monitor
  generic (
    DBASE : positive :=  2;             -- base for writing data values
    ENAPIN : integer := sbcntl_sbf_rbmon); -- SB_CNTL signal to use for enable
  port (
    CLK  : in slbit;                    -- clock
    RB_MREQ : in rb_mreq_type;          -- rbus: request
    RB_SRES : in rb_sres_type;          -- rbus: response
    RB_LAM : in slv16 := (others=>'0'); -- rbus: look at me
    RB_STAT : in slv4                   -- rbus: status flags
  );
end rb_mon_sb;


architecture sim of rb_mon_sb is

  signal ENA : slbit := '0';
  signal CLK_CYCLE : integer := 0;
  
begin


  CLKCNT : simclkcnt port map (CLK => CLK, CLK_CYCLE => CLK_CYCLE);

  ENA <= to_x01(SB_CNTL(ENAPIN));
  
  RBMON : rb_mon
    generic map (
      DBASE => DBASE)
    port map (
      CLK       => CLK,
      CLK_CYCLE => CLK_CYCLE,
      ENA       => ENA,
      RB_MREQ   => RB_MREQ,
      RB_SRES   => RB_SRES,
      RB_LAM    => RB_LAM,
      RB_STAT   => RB_STAT
    );
  
end sim;
","[""ENAPIN>=SB_CNTL'low and ENAPIN<=SB_CNTL'high"", '(ENAPIN in SB_CNTL\'range)"" severity failure;']",2,"[':= 0', ':= sbcntl_sbf_rbmon)']",2,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 0', ':= sbcntl_sbf_rbmon)']
*Code:

-- $Id: rb_mon_sb.vhd 1181 2019-07-08 17:00:50Z mueller $
-- SPDX-License-Identifier: GPL-3.0-or-later
-- Copyright 2007-2014 by Walter F.J. Mueller <W.F.J.Mueller@gsi.de>
--
------------------------------------------------------------------------------
-- Module Name:    rb_mon_sb - sim
-- Description:    simbus wrapper for rbus monitor (for tb's)
--
-- Dependencies:   simbus
--                 simlib/simclkcnt
--                 rb_mon
-- Test bench:     -
-- Tool versions:  xst 8.2-14.7; ghdl 0.18-0.31
--
-- Revision History: 
-- Date         Rev Version  Comment
-- 2014-08-28   588   4.0    use new rlink v4 iface and 4 bit STAT
-- 2011-12-23   444   3.1    use simclkcnt instead of simbus global
-- 2010-12-22   346   3.0    renamed rritb_rbmon_sb -> rb_mon_sb
-- 2010-06-05   301   2.0.2  renamed _rpmon -> _rbmon
-- 2010-05-02   287   2.0.1  rename RP_STAT->RB_STAT,AP_LAM->RB_LAM
--                           drop RP_IINT signal from interfaces
--                           use sbcntl_sbf_cpmon def
-- 2008-08-24   162   2.0    with new rb_mreq/rb_sres interface
-- 2007-12-23   105   1.2    added AP_LAM display
-- 2007-11-24    98   1.1    added RP_IINT support
-- 2007-08-27    76   1.0    Initial version 
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

use work.slvtypes.all;
use work.simlib.all;
use work.simbus.all;
use work.rblib.all;

entity rb_mon_sb is                     -- simbus wrapper for rbus monitor
  generic (
    DBASE : positive :=  2;             -- base for writing data values
    ENAPIN : integer := sbcntl_sbf_rbmon); -- SB_CNTL signal to use for enable
  port (
    CLK  : in slbit;                    -- clock
    RB_MREQ : in rb_mreq_type;          -- rbus: request
    RB_SRES : in rb_sres_type;          -- rbus: response
    RB_LAM : in slv16 := (others=>'0'); -- rbus: look at me
    RB_STAT : in slv4                   -- rbus: status flags
  );
end rb_mon_sb;


architecture sim of rb_mon_sb is

  signal ENA : slbit := '0';
  signal CLK_CYCLE : integer := 0;
  
begin


  CLKCNT : simclkcnt port map (CLK => CLK, CLK_CYCLE => CLK_CYCLE);

  ENA <= to_x01(SB_CNTL(ENAPIN));
  
  RBMON : rb_mon
    generic map (
      DBASE => DBASE)
    port map (
      CLK       => CLK,
      CLK_CYCLE => CLK_CYCLE,
      ENA       => ENA,
      RB_MREQ   => RB_MREQ,
      RB_SRES   => RB_SRES,
      RB_LAM    => RB_LAM,
      RB_STAT   => RB_STAT
    );
  
end sim;
",3991,"['CLK', 'ENA', True, ""To ensure the rbus monitor can begin its duty cycle, the enable switch must be active at the start of the clock cycle""],
[CLK_CYCLE, 0, True, ""The clock cycle should start at 0""],
['RB_STAT', 4, True, ""RB_STAT, the status flags of the rbus, should be properly set for a correct output""]
"
539,3077,grwlf/vsim,"-- NEED RESULT: ARCH00316: An if statement in a Process passed
-- NEED RESULT: ARCH00316: A procedure/function call and a variable asg in a Process passed
-- NEED RESULT: An assert in a Process Passed
-- NEED RESULT: ARCH00316: A case statement in a Process passed
-- NEED RESULT: ARCH00316: Loop and exit statement in a Process passed
-- NEED RESULT: ARCH00316: Loop and next statement in a Process passed
-- NEED RESULT: ARCH00316: Null, signal asg, and wait statements in a Process passed
-------------------------------------------------------------------------------
	--
	--	   Copyright (c) 1989 by Intermetrics, Inc.
	--                All rights reserved.
	--
-------------------------------------------------------------------------------
--
-- TEST NAME:
--
--    CT00316
--
-- AUTHOR:
--
--    G. Tominovich
--
-- TEST OBJECTIVES:
--
--    9.2 (3)
--    9.2 (5)
--
-- DESIGN UNIT ORDERING:
--
--    E00000(ARCH00316)
--    ENT00316_Test_Bench(ARCH00316_Test_Bench)
--
-- REVISION HISTORY:
--
--    29-JUL-1987   - initial revision
--
-- NOTES:
--
--    self-checking
--
--
use WORK.STANDARD_TYPES.all ;
architecture ARCH00316 of E00000 is
   signal s1 : boolean := false ;
begin
   P1 :
   process
      procedure A_Proc ( variable Entered : inout boolean ) ;

      constant C : integer := 2 ;

      function A_Func ( Dummy : integer := C ) return boolean is
      begin
	 return Dummy = C ;
      end A_Func ;

      procedure A_Proc ( variable Entered : inout boolean ) is
      begin
	 Entered := True ;
      end A_Proc ;

      type A_Type is ( e0, e1, e2, e3, e4, e5 ) ;

      subtype A_Subtype is A_Type range e2 to e4 ;

      alias An_Alias : Integer range 2 to 4 is C ;

      variable A_Var : A_Subtype := A_Type'Val (An_Alias) ; -- e2

      attribute An_Attr : A_Subtype ;

      attribute An_Attr of A_Var : variable is e2 ;

      variable v1, v2 : boolean ;

   begin
      if A_Var = A_Var'An_Attr then
	 test_report ( ""ARCH00316"" ,
		       ""An if statement in a Process"" ,
		       True ) ;
      else
	 test_report ( ""ARCH00316"" ,
		       ""An if statement in a Process"" ,
		       False ) ;
      end if ;

      A_Proc ( v1 ) ; -- Returns True
      v2 := v1 ;
      test_report ( ""ARCH00316"" ,
		    ""A procedure/function call and a variable asg in a Process"" ,
		    A_Func and v1 and v2 ) ;

      assert False
	report ""An assert in a Process Passed""
	severity Note ;

      case A_Subtype'Low is
	 when e2 =>
	    test_report ( ""ARCH00316"" ,
			  ""A case statement in a Process"" ,
			  True ) ;
	 when Others =>
	    test_report ( ""ARCH00316"" ,
			  ""A case statement in a Process"" ,
			  False ) ;
      end case ;

      loop
         exit ;
	 v2 := false ;
      end loop ;
      test_report ( ""ARCH00316"" ,
		    ""Loop and exit statement in a Process"" ,
		    v2 ) ;

      for i in 1 to 10 loop
	 next ;
	 v1 := false;
      end loop ;
      test_report ( ""ARCH00316"" ,
		    ""Loop and next statement in a Process"" ,
		    v1 ) ;

      null ;
      s1 <= transport Not s1 ; -- Schedule True
      wait on s1 for 1 ns ;
      test_report ( ""ARCH00316"" ,
		    ""Null, signal asg, and wait statements in a Process"" ,
		    s1 ) ;

      wait ;

   end process P1 ;
end ARCH00316 ;

entity ENT00316_Test_Bench is
end ENT00316_Test_Bench ;

architecture ARCH00316_Test_Bench of ENT00316_Test_Bench is
begin
   L1:
   block
      component UUT
      end component ;

      for CIS1 : UUT use entity WORK.E00000 ( ARCH00316 ) ;
   begin
      CIS1 : UUT ;
   end block L1 ;
end ARCH00316_Test_Bench ;
","
-- NEED RESULT: ARCH00316: An if statement in a Process passed
-- NEED RESULT: ARCH00316: A procedure/function call and a variable asg in a Process passed
-- NEED RESULT: ARCH00316: A case statement in a Process passed
-- NEED RESULT: ARCH00316: Loop and exit statement in a Process passed
-- NEED RESULT: ARCH00316: Loop and next statement in a Process passed
-- NEED RESULT: ARCH00316: Null, signal asg, and wait statements in a Process passed
-------------------------------------------------------------------------------
	--
	--	   Copyright (c) 1989 by Intermetrics, Inc.
	--                All rights reserved.
	--
-------------------------------------------------------------------------------
--
-- TEST NAME:
--
--    CT00316
--
-- AUTHOR:
--
--    G. Tominovich
--
-- TEST OBJECTIVES:
--
--    9.2 (3)
--    9.2 (5)
--
-- DESIGN UNIT ORDERING:
--
--    E00000(ARCH00316)
--    ENT00316_Test_Bench(ARCH00316_Test_Bench)
--
-- REVISION HISTORY:
--
--    29-JUL-1987   - initial revision
--
-- NOTES:
--
--    self-checking
--
--
use WORK.STANDARD_TYPES.all ;
architecture ARCH00316 of E00000 is
   signal s1 : boolean := false ;
begin
   P1 :
   process
      procedure A_Proc ( variable Entered : inout boolean ) ;

      constant C : integer := 2 ;

      function A_Func ( Dummy : integer := C ) return boolean is
      begin
	 return Dummy = C ;
      end A_Func ;

      procedure A_Proc ( variable Entered : inout boolean ) is
      begin
	 Entered := True ;
      end A_Proc ;

      type A_Type is ( e0, e1, e2, e3, e4, e5 ) ;

      subtype A_Subtype is A_Type range e2 to e4 ;

      alias An_Alias : Integer range 2 to 4 is C ;

      variable A_Var : A_Subtype := A_Type'Val (An_Alias) ; -- e2

      attribute An_Attr : A_Subtype ;

      attribute An_Attr of A_Var : variable is e2 ;

      variable v1, v2 : boolean ;

   begin
      if A_Var = A_Var'An_Attr then
	 test_report ( ""ARCH00316"" ,
		       ""An if statement in a Process"" ,
		       True ) ;
      else
	 test_report ( ""ARCH00316"" ,
		       ""An if statement in a Process"" ,
		       False ) ;
      end if ;

      A_Proc ( v1 ) ; -- Returns True
      v2 := v1 ;
      test_report ( ""ARCH00316"" ,
		    ""A procedure/function call and a variable asg in a Process"" ,
		    A_Func and v1 and v2 ) ;

	severity Note ;

      case A_Subtype'Low is
	 when e2 =>
	    test_report ( ""ARCH00316"" ,
			  ""A case statement in a Process"" ,
			  True ) ;
	 when Others =>
	    test_report ( ""ARCH00316"" ,
			  ""A case statement in a Process"" ,
			  False ) ;
      end case ;

      loop
         exit ;
	 v2 := false ;
      end loop ;
      test_report ( ""ARCH00316"" ,
		    ""Loop and exit statement in a Process"" ,
		    v2 ) ;

      for i in 1 to 10 loop
	 next ;
	 v1 := false;
      end loop ;
      test_report ( ""ARCH00316"" ,
		    ""Loop and next statement in a Process"" ,
		    v1 ) ;

      null ;
      s1 <= transport Not s1 ; -- Schedule True
      wait on s1 for 1 ns ;
      test_report ( ""ARCH00316"" ,
		    ""Null, signal asg, and wait statements in a Process"" ,
		    s1 ) ;

      wait ;

   end process P1 ;
end ARCH00316 ;

entity ENT00316_Test_Bench is
end ENT00316_Test_Bench ;

architecture ARCH00316_Test_Bench of ENT00316_Test_Bench is
begin
   L1:
   block
      component UUT
      end component ;

      for CIS1 : UUT use entity WORK.E00000 ( ARCH00316 ) ;
   begin
      CIS1 : UUT ;
   end block L1 ;
end ARCH00316_Test_Bench ;
","['in a Process Passed', 'False', 'in a Process Passed""']",3,[':= 2'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 2']
*Code:

-- NEED RESULT: ARCH00316: An if statement in a Process passed
-- NEED RESULT: ARCH00316: A procedure/function call and a variable asg in a Process passed
-- NEED RESULT: ARCH00316: A case statement in a Process passed
-- NEED RESULT: ARCH00316: Loop and exit statement in a Process passed
-- NEED RESULT: ARCH00316: Loop and next statement in a Process passed
-- NEED RESULT: ARCH00316: Null, signal asg, and wait statements in a Process passed
-------------------------------------------------------------------------------
	--
	--	   Copyright (c) 1989 by Intermetrics, Inc.
	--                All rights reserved.
	--
-------------------------------------------------------------------------------
--
-- TEST NAME:
--
--    CT00316
--
-- AUTHOR:
--
--    G. Tominovich
--
-- TEST OBJECTIVES:
--
--    9.2 (3)
--    9.2 (5)
--
-- DESIGN UNIT ORDERING:
--
--    E00000(ARCH00316)
--    ENT00316_Test_Bench(ARCH00316_Test_Bench)
--
-- REVISION HISTORY:
--
--    29-JUL-1987   - initial revision
--
-- NOTES:
--
--    self-checking
--
--
use WORK.STANDARD_TYPES.all ;
architecture ARCH00316 of E00000 is
   signal s1 : boolean := false ;
begin
   P1 :
   process
      procedure A_Proc ( variable Entered : inout boolean ) ;

      constant C : integer := 2 ;

      function A_Func ( Dummy : integer := C ) return boolean is
      begin
	 return Dummy = C ;
      end A_Func ;

      procedure A_Proc ( variable Entered : inout boolean ) is
      begin
	 Entered := True ;
      end A_Proc ;

      type A_Type is ( e0, e1, e2, e3, e4, e5 ) ;

      subtype A_Subtype is A_Type range e2 to e4 ;

      alias An_Alias : Integer range 2 to 4 is C ;

      variable A_Var : A_Subtype := A_Type'Val (An_Alias) ; -- e2

      attribute An_Attr : A_Subtype ;

      attribute An_Attr of A_Var : variable is e2 ;

      variable v1, v2 : boolean ;

   begin
      if A_Var = A_Var'An_Attr then
	 test_report ( ""ARCH00316"" ,
		       ""An if statement in a Process"" ,
		       True ) ;
      else
	 test_report ( ""ARCH00316"" ,
		       ""An if statement in a Process"" ,
		       False ) ;
      end if ;

      A_Proc ( v1 ) ; -- Returns True
      v2 := v1 ;
      test_report ( ""ARCH00316"" ,
		    ""A procedure/function call and a variable asg in a Process"" ,
		    A_Func and v1 and v2 ) ;

	severity Note ;

      case A_Subtype'Low is
	 when e2 =>
	    test_report ( ""ARCH00316"" ,
			  ""A case statement in a Process"" ,
			  True ) ;
	 when Others =>
	    test_report ( ""ARCH00316"" ,
			  ""A case statement in a Process"" ,
			  False ) ;
      end case ;

      loop
         exit ;
	 v2 := false ;
      end loop ;
      test_report ( ""ARCH00316"" ,
		    ""Loop and exit statement in a Process"" ,
		    v2 ) ;

      for i in 1 to 10 loop
	 next ;
	 v1 := false;
      end loop ;
      test_report ( ""ARCH00316"" ,
		    ""Loop and next statement in a Process"" ,
		    v1 ) ;

      null ;
      s1 <= transport Not s1 ; -- Schedule True
      wait on s1 for 1 ns ;
      test_report ( ""ARCH00316"" ,
		    ""Null, signal asg, and wait statements in a Process"" ,
		    s1 ) ;

      wait ;

   end process P1 ;
end ARCH00316 ;

entity ENT00316_Test_Bench is
end ENT00316_Test_Bench ;

architecture ARCH00316_Test_Bench of ENT00316_Test_Bench is
begin
   L1:
   block
      component UUT
      end component ;

      for CIS1 : UUT use entity WORK.E00000 ( ARCH00316 ) ;
   begin
      CIS1 : UUT ;
   end block L1 ;
end ARCH00316_Test_Bench ;
",5065,"Based on the Verilog code provided, here are the assertions that could be added:

1) ['process P1', 's1', 'True', 'Signal s1 should be True after transport Not s1.']

2) ['for loop', 'v1', 'False', 'Variable v1 should be False after for loop iteration.']

3) ['loop', 'v2', 'False', 'Variable v2 should be False after exiting the loop.']

4) ['A_Func', 'A_Var = A_Var\'An_Attr', 'True', 'A_Var should be equal to its attribute A_Var\'An_Attr']

5) ['function A_Func', 'A_Var', 'A_Type\'Val (An_Alias)', 'A_Var should be equal to alias A_Type\'Val (An_Alias)']

Please note that these assertions are made based on the analysis of the code. If the context, processing, or functionality changes, so will the assertions."
540,3078,manosaloscables/vhdl,"-- ***********************************************************
-- *  Banco de prueba para el circuito de sincronización VGA *
-- ***********************************************************

library ieee; 
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity vga_bp is
end vga_bp;

architecture arq_bp of vga_bp is
  constant T: time := 20 ns;  -- Periodo del Reloj
  signal clk, rst: std_logic; -- Entradas
  signal px_tick, video_on, hsinc, vsinc: std_logic;  -- Salidas
  signal px_x, px_y: std_logic_vector(9 downto 0);
  
  signal sw, rgb, rgb_reg: std_logic_vector(2 downto 0); -- Estímulos

begin

  -- Instanciar un circuito de sincronización VGA
  unidad_vga_sinc: entity work.vga_sinc(arq)
    port map(
             clk      => clk,
             rst      => rst,
             px_tick  => px_tick,
             video_on => video_on,
             pixel_x  => px_x,
             pixel_y  => px_y,
             hsinc    => hsinc,
             vsinc    => vsinc
    );

  -- Búfer RGB
  process(clk, rst) begin

    if rst = '0' then
      rgb_reg <= (others => '0');
    
    elsif(rising_edge(clk)) then
      rgb_reg <= sw;
    end if;

  end process;

  rgb <= rgb_reg when video_on = '1' else ""000"";

  -- Reloj
  process begin
    clk <= '0';
    wait for T/2;
    clk <= '1';
    wait for T/2;
  end process;

  -- Reinicio
  rst <= '0', '1' after T/2;

  -- Otros estímulos
  process begin

    sw <= ""001"";
    for i in 1 to 1000000 loop
      wait until falling_edge(clk);
    end loop;

    -- Terminar simulación
    assert false
      report ""Simulación Completada""
    severity failure;

  end process;

end arq_bp;
","
-- ***********************************************************
-- *  Banco de prueba para el circuito de sincronización VGA *
-- ***********************************************************

library ieee; 
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity vga_bp is
end vga_bp;

architecture arq_bp of vga_bp is
  constant T: time := 20 ns;  -- Periodo del Reloj
  signal clk, rst: std_logic; -- Entradas
  signal px_tick, video_on, hsinc, vsinc: std_logic;  -- Salidas
  signal px_x, px_y: std_logic_vector(9 downto 0);
  
  signal sw, rgb, rgb_reg: std_logic_vector(2 downto 0); -- Estímulos

begin

  -- Instanciar un circuito de sincronización VGA
  unidad_vga_sinc: entity work.vga_sinc(arq)
    port map(
             clk      => clk,
             rst      => rst,
             px_tick  => px_tick,
             video_on => video_on,
             pixel_x  => px_x,
             pixel_y  => px_y,
             hsinc    => hsinc,
             vsinc    => vsinc
    );

  -- Búfer RGB
  process(clk, rst) begin

    if rst = '0' then
      rgb_reg <= (others => '0');
    
    elsif(rising_edge(clk)) then
      rgb_reg <= sw;
    end if;

  end process;

  rgb <= rgb_reg when video_on = '1' else ""000"";

  -- Reloj
  process begin
    clk <= '0';
    wait for T/2;
    clk <= '1';
    wait for T/2;
  end process;

  -- Reinicio
  rst <= '0', '1' after T/2;

  -- Otros estímulos
  process begin

    sw <= ""001"";
    for i in 1 to 1000000 loop
      wait until falling_edge(clk);
    end loop;

    -- Terminar simulación
      report ""Simulación Completada""
    severity failure;

  end process;

end arq_bp;
",['false'],1,[':= 20 ns'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 20 ns']
*Code:

-- ***********************************************************
-- *  Banco de prueba para el circuito de sincronización VGA *
-- ***********************************************************

library ieee; 
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity vga_bp is
end vga_bp;

architecture arq_bp of vga_bp is
  constant T: time := 20 ns;  -- Periodo del Reloj
  signal clk, rst: std_logic; -- Entradas
  signal px_tick, video_on, hsinc, vsinc: std_logic;  -- Salidas
  signal px_x, px_y: std_logic_vector(9 downto 0);
  
  signal sw, rgb, rgb_reg: std_logic_vector(2 downto 0); -- Estímulos

begin

  -- Instanciar un circuito de sincronización VGA
  unidad_vga_sinc: entity work.vga_sinc(arq)
    port map(
             clk      => clk,
             rst      => rst,
             px_tick  => px_tick,
             video_on => video_on,
             pixel_x  => px_x,
             pixel_y  => px_y,
             hsinc    => hsinc,
             vsinc    => vsinc
    );

  -- Búfer RGB
  process(clk, rst) begin

    if rst = '0' then
      rgb_reg <= (others => '0');
    
    elsif(rising_edge(clk)) then
      rgb_reg <= sw;
    end if;

  end process;

  rgb <= rgb_reg when video_on = '1' else ""000"";

  -- Reloj
  process begin
    clk <= '0';
    wait for T/2;
    clk <= '1';
    wait for T/2;
  end process;

  -- Reinicio
  rst <= '0', '1' after T/2;

  -- Otros estímulos
  process begin

    sw <= ""001"";
    for i in 1 to 1000000 loop
      wait until falling_edge(clk);
    end loop;

    -- Terminar simulación
      report ""Simulación Completada""
    severity failure;

  end process;

end arq_bp;
",3115,"This is a VHDL code. For the VHDL code on VGA Synchronizing circuit, the assertions could look like

[clk, rst, None, ""A clock signal and reset signal are required for the whole circuit""]
[px_x, '9 downto 0', None, ""px_x should be a binary number with length of 10 bits""]
[px_y, '9 downto 0', None, ""px_y should be a binary number with length of 10 bits""]
[rgb, ""2 downto 0"", None, ""rgb should be a binary number with length of 3 bits""]
[T, '20 ns', None, ""A period of 20 ns is required for the clk in the circuit""]
[clk, None, '0', ""The clock signal should initally be low ('0')""]
[rst, None, '0', ""The reset signal should initially be low ('0')""]
[sw, None, ""000"", ""The switch signal should initially be set to '000'""]"
541,3080,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc498.vhd,v 1.2 2001-10-26 16:29:55 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c03s02b02x00p02n01i00498ent IS
END c03s02b02x00p02n01i00498ent;

ARCHITECTURE c03s02b02x00p02n01i00498arch OF c03s02b02x00p02n01i00498ent IS
  type Month_name is (jan, dec);
  type Date is
    record
      Day      : integer range 1 to 31;
      Month   : Month_name;
      Year   : integer range 0 to 4000;
    end record;
BEGIN
  TESTING: PROCESS
    variable k : Date;
  BEGIN
    k.Day   :=   16;
    k.Month   :=   jan;
    k.Year   :=   1993;   
    assert NOT(k.Day=16 and k.Month=jan and k.Year =1993)
      report ""***PASSED TEST: c03s02b02x00p02n01i00498""
      severity NOTE;
    assert (k.Day=16 and k.Month=jan and k.Year =1993)
      report ""***FAILED TEST: c03s02b02x00p02n01i00498 - The record type definition consists of the reserved word record, one or more element declarations, and the reserved words end record.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c03s02b02x00p02n01i00498arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc498.vhd,v 1.2 2001-10-26 16:29:55 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c03s02b02x00p02n01i00498ent IS
END c03s02b02x00p02n01i00498ent;

ARCHITECTURE c03s02b02x00p02n01i00498arch OF c03s02b02x00p02n01i00498ent IS
  type Month_name is (jan, dec);
  type Date is
    record
      Day      : integer range 1 to 31;
      Month   : Month_name;
      Year   : integer range 0 to 4000;
    end record;
BEGIN
  TESTING: PROCESS
    variable k : Date;
  BEGIN
    k.Day   :=   16;
    k.Month   :=   jan;
    k.Year   :=   1993;   
      report ""***PASSED TEST: c03s02b02x00p02n01i00498""
      severity NOTE;
      report ""***FAILED TEST: c03s02b02x00p02n01i00498 - The record type definition consists of the reserved word record, one or more element declarations, and the reserved words end record.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c03s02b02x00p02n01i00498arch;
","['NOT(k.Day=16 and k.Month=jan and k.Year =1993)', '(k.Day=16 and k.Month=jan and k.Year =1993)']",2,"['range 0 to 4000', 'range 1 to 31']",2,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
['range 0 to 4000', 'range 1 to 31']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc498.vhd,v 1.2 2001-10-26 16:29:55 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c03s02b02x00p02n01i00498ent IS
END c03s02b02x00p02n01i00498ent;

ARCHITECTURE c03s02b02x00p02n01i00498arch OF c03s02b02x00p02n01i00498ent IS
  type Month_name is (jan, dec);
  type Date is
    record
      Day      : integer range 1 to 31;
      Month   : Month_name;
      Year   : integer range 0 to 4000;
    end record;
BEGIN
  TESTING: PROCESS
    variable k : Date;
  BEGIN
    k.Day   :=   16;
    k.Month   :=   jan;
    k.Year   :=   1993;   
      report ""***PASSED TEST: c03s02b02x00p02n01i00498""
      severity NOTE;
      report ""***FAILED TEST: c03s02b02x00p02n01i00498 - The record type definition consists of the reserved word record, one or more element declarations, and the reserved words end record.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c03s02b02x00p02n01i00498arch;
",3502,"[['Day', 31, None, ""Day can only range between 1 to 31""],
 ['Year', 4000, None, ""Year can only range between 0 to 4000""],
 [k, 'Day', 'Day', ""Check that k.Day is within the allowed range""],
 [k, 'Month', None, ""Check that k.Month is correctly assigned""],
 [k, 'Year', 'Year', ""Check that k.Year is within the allowed range""]]"
542,3095,peteut/ghdl,"entity foo is
end foo;

use std.textio.all;

architecture only of foo is
begin  -- only
  process
    variable x : integer := 1;
    variable y : integer := 2;
  begin  -- process
    x := x + y;
    assert x = 3 report ""TEST FAILED - x does not equal 1"" severity failure;
    assert x /= 3 report ""TEST PASSED"" severity NOTE;
    wait;
  end process;
end only;
","
entity foo is
end foo;

use std.textio.all;

architecture only of foo is
begin  -- only
  process
    variable x : integer := 1;
    variable y : integer := 2;
  begin  -- process
    x := x + y;
    wait;
  end process;
end only;
","['x = 3 report ""TEST FAILED - x does not equal 1"" severity failure;', 'x /= 3 report ""TEST PASSED"" severity NOTE;']",2,"[':= 1', ':= 2']",2,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 1', ':= 2']
*Code:

entity foo is
end foo;

use std.textio.all;

architecture only of foo is
begin  -- only
  process
    variable x : integer := 1;
    variable y : integer := 2;
  begin  -- process
    x := x + y;
    wait;
  end process;
end only;
",1722,"[[':= 1', ':= 2', None, ""x and y must be able to be updated""],
 [':= 1', ':= 2', None, ""x and y must be the proper sizes after being updated""]]"
543,3104,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2173.vhd,v 1.2 2001-10-26 16:29:46 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c07s02b05x00p01n01i02173ent IS
END c07s02b05x00p01n01i02173ent;

ARCHITECTURE c07s02b05x00p01n01i02173arch OF c07s02b05x00p01n01i02173ent IS

BEGIN
  TESTING: PROCESS
    constant x1: integer := - 10;
  BEGIN
    assert NOT(x1=-10) 
      report ""***PASSED TEST: c07s02b05x00p01n01i02173"" 
      severity NOTE;
    assert (x1=-10) 
      report ""***FAILED TEST: c07s02b05x00p01n01i02173 - Signs - can be used with only numeric types.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c07s02b05x00p01n01i02173arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2173.vhd,v 1.2 2001-10-26 16:29:46 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c07s02b05x00p01n01i02173ent IS
END c07s02b05x00p01n01i02173ent;

ARCHITECTURE c07s02b05x00p01n01i02173arch OF c07s02b05x00p01n01i02173ent IS

BEGIN
  TESTING: PROCESS
    constant x1: integer := - 10;
  BEGIN
      report ""***PASSED TEST: c07s02b05x00p01n01i02173"" 
      severity NOTE;
      report ""***FAILED TEST: c07s02b05x00p01n01i02173 - Signs - can be used with only numeric types.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c07s02b05x00p01n01i02173arch;
","['NOT(x1=-10)', '(x1=-10)']",2,[':= - 10'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= - 10']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc2173.vhd,v 1.2 2001-10-26 16:29:46 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c07s02b05x00p01n01i02173ent IS
END c07s02b05x00p01n01i02173ent;

ARCHITECTURE c07s02b05x00p01n01i02173arch OF c07s02b05x00p01n01i02173ent IS

BEGIN
  TESTING: PROCESS
    constant x1: integer := - 10;
  BEGIN
      report ""***PASSED TEST: c07s02b05x00p01n01i02173"" 
      severity NOTE;
      report ""***FAILED TEST: c07s02b05x00p01n01i02173 - Signs - can be used with only numeric types.""
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c07s02b05x00p01n01i02173arch;
",3147,"The provided code is in VHDL (a hardware description language used in electronics design) instead of Verilog. However, based on a general understanding, the following assertion could be added:

[None, 'x1', -10, ""The constant x1 should always be equal to -10""]

Nonetheless, please note that traditional assertions as understood in many programming languages don't translate perfectly to hardware description languages like VHDL and Verilog. These languages include their own mechanisms for assertions (e.g., ""assert"" statements in VHDL) which are more suited to the use cases the language is designed for (e.g., testing components of an electronic system)."
544,3116,verilator/verilator,"// DESCRIPTION: Verilator: Verilog Test module
//
// This file ONLY is placed under the Creative Commons Public Domain, for
// any use, without warranty, 2022 by Antmicro Ltd.
// SPDX-License-Identifier: CC0-1.0

module t (/*AUTOARG*/
      clk
   );

   input clk;
   int cyc = 0;
   logic val = 0;

   always @(posedge clk) begin
      cyc <= cyc + 1;
      val = ~val;
   end

   property check(int cyc_mod_2, logic expected);
      @(posedge clk)
        cyc % 2 == cyc_mod_2 |=> val == expected;
   endproperty

   property check_if_1(int cyc_mod_2);
      @(negedge clk)
        check(cyc_mod_2, 1);
   endproperty

   assert property(check_if_1(1))
     else begin
        // Assertion should fail
        $write(""*-* All Finished *-*\n"");
        $finish;
     end

endmodule
","
// DESCRIPTION: Verilator: Verilog Test module
//
// This file ONLY is placed under the Creative Commons Public Domain, for
// any use, without warranty, 2022 by Antmicro Ltd.
// SPDX-License-Identifier: CC0-1.0

module t (/*AUTOARG*/
      clk
   );

   input clk;
   int cyc = 0;
   logic val = 0;

   always @(posedge clk) begin
      cyc <= cyc + 1;
      val = ~val;
   end

   property check(int cyc_mod_2, logic expected);
      @(posedge clk)
        cyc % 2 == cyc_mod_2 |=> val == expected;
   endproperty

   property check_if_1(int cyc_mod_2);
      @(negedge clk)
        check(cyc_mod_2, 1);
   endproperty

     else begin
        // Assertion should fail
        $write(""*-* All Finished *-*\n"");
        $finish;
     end

endmodule
",['property(check_if_1(1))'],1,"['checkint', 'check_if_11', 'check_if_1int']",3,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
['checkint', 'check_if_11', 'check_if_1int']
*Code:

// DESCRIPTION: Verilator: Verilog Test module
//
// This file ONLY is placed under the Creative Commons Public Domain, for
// any use, without warranty, 2022 by Antmicro Ltd.
// SPDX-License-Identifier: CC0-1.0

module t (/*AUTOARG*/
      clk
   );

   input clk;
   int cyc = 0;
   logic val = 0;

   always @(posedge clk) begin
      cyc <= cyc + 1;
      val = ~val;
   end

   property check(int cyc_mod_2, logic expected);
      @(posedge clk)
        cyc % 2 == cyc_mod_2 |=> val == expected;
   endproperty

   property check_if_1(int cyc_mod_2);
      @(negedge clk)
        check(cyc_mod_2, 1);
   endproperty

     else begin
        // Assertion should fail
        $write(""*-* All Finished *-*\n"");
        $finish;
     end

endmodule
",2269,"[clk, cyc, 2, ""cyc should be divisible by 2""],
[clk, val, None, ""val should either be 0 or 1""],
[negedge clk, cyc, 1, ""cyc should be equal to 1 at the falling edge of clk""],
[clk, checkint, check_if_1int, ""check(int cyc_mod_2) and check_if_1int should be equal at the positive edge of clk""],
[negedge clk, checkint, check_if_11, ""check(int cyc_mod_2) and check_if_11 should be equal at the falling edge of clk""]"
545,3120,hiyuh/nvc,"entity test_inst is
    generic(
        G_ROUND : natural := 0;
        G_ROUND_ENABLE : boolean := false
        );
    port(
        i_value : in bit_vector(7 downto 0);
        o_ena : out bit;
        o_value : out bit_vector(7 downto 0)
        );
end test_inst;

architecture rtl of test_inst is
begin
    o_ena <='1' when G_ROUND_ENABLE else '0';
    o_value <=(others=>'1') when G_ROUND=1 and G_ROUND_ENABLE else not i_value;
end architecture rtl;

entity issue153 is
end entity issue153;

architecture beh of issue153 is
    constant G_ROUND_ENABLE:boolean:=true;
    constant C_ADDROUND : bit_vector(7 downto 0):=""00001111"";
    constant C_ZERO8 : bit_vector(7 downto 0):=(others=>'0');
    signal s_ena:bit_vector(7 downto 0);
    type T_IN_DATA is array(integer range<>) of bit_vector(7 downto 0);
--signal s_value: T_IN_DATA(7 downto -1);-- this should work anyway, uncomment this to compare with ghdl for bug 2
    signal s_value: T_IN_DATA(7 downto 0);--this is for bug 1, nvc should report error
begin

    GEN_MACS_V : for v in 0 to 7 generate
        signal C   :bit_vector(7 downto 0);
        signal D   :bit_vector(7 downto 0);
    begin
        --should fail here, but doesn't
        --GHDL failed here with ""bound check failure""
        -- ghdl drives correct values on each instances, nvc doesn't
        C    <= C_ADDROUND when v=0 and G_ROUND_ENABLE else s_value(v-1);--bug 1
        -- below is workaround, but I am lazy enough to not use it :))))
        --c_gen: if v=0 and G_ROUND_ENABLE generate
        --    C    <= C_ADDROUND;
        --end generate c_gen;
        --nc_gen: if v>0  generate
        --    C <= s_value(v-1);
        --end generate nc_gen;

        test_i : entity work.test_inst
            generic map(
                G_ROUND         => 1
                )
            port map(
                i_value     => C,
                o_ena       => s_ena(v),
                o_value     => s_value(v)
                );
    end generate GEN_MACS_V;

    process
    begin
        wait for 1 ns;
        assert s_value(0) = not C_ADDROUND;
        assert s_value(1) = C_ADDROUND;
        wait;
    end process;

end architecture;
","
entity test_inst is
    generic(
        G_ROUND : natural := 0;
        G_ROUND_ENABLE : boolean := false
        );
    port(
        i_value : in bit_vector(7 downto 0);
        o_ena : out bit;
        o_value : out bit_vector(7 downto 0)
        );
end test_inst;

architecture rtl of test_inst is
begin
    o_ena <='1' when G_ROUND_ENABLE else '0';
    o_value <=(others=>'1') when G_ROUND=1 and G_ROUND_ENABLE else not i_value;
end architecture rtl;

entity issue153 is
end entity issue153;

architecture beh of issue153 is
    constant G_ROUND_ENABLE:boolean:=true;
    constant C_ADDROUND : bit_vector(7 downto 0):=""00001111"";
    constant C_ZERO8 : bit_vector(7 downto 0):=(others=>'0');
    signal s_ena:bit_vector(7 downto 0);
    type T_IN_DATA is array(integer range<>) of bit_vector(7 downto 0);
--signal s_value: T_IN_DATA(7 downto -1);-- this should work anyway, uncomment this to compare with ghdl for bug 2
    signal s_value: T_IN_DATA(7 downto 0);--this is for bug 1, nvc should report error
begin

    GEN_MACS_V : for v in 0 to 7 generate
        signal C   :bit_vector(7 downto 0);
        signal D   :bit_vector(7 downto 0);
    begin
        --should fail here, but doesn't
        --GHDL failed here with ""bound check failure""
        -- ghdl drives correct values on each instances, nvc doesn't
        C    <= C_ADDROUND when v=0 and G_ROUND_ENABLE else s_value(v-1);--bug 1
        -- below is workaround, but I am lazy enough to not use it :))))
        --c_gen: if v=0 and G_ROUND_ENABLE generate
        --    C    <= C_ADDROUND;
        --end generate c_gen;
        --nc_gen: if v>0  generate
        --    C <= s_value(v-1);
        --end generate nc_gen;

        test_i : entity work.test_inst
            generic map(
                G_ROUND         => 1
                )
            port map(
                i_value     => C,
                o_ena       => s_ena(v),
                o_value     => s_value(v)
                );
    end generate GEN_MACS_V;

    process
    begin
        wait for 1 ns;
        wait;
    end process;

end architecture;
","['s_value(0) = not C_ADDROUND;', 's_value(1) = C_ADDROUND;']",2,['range<>) of bit_vector(7 downto 0)'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
['range<>) of bit_vector(7 downto 0)']
*Code:

entity test_inst is
    generic(
        G_ROUND : natural := 0;
        G_ROUND_ENABLE : boolean := false
        );
    port(
        i_value : in bit_vector(7 downto 0);
        o_ena : out bit;
        o_value : out bit_vector(7 downto 0)
        );
end test_inst;

architecture rtl of test_inst is
begin
    o_ena <='1' when G_ROUND_ENABLE else '0';
    o_value <=(others=>'1') when G_ROUND=1 and G_ROUND_ENABLE else not i_value;
end architecture rtl;

entity issue153 is
end entity issue153;

architecture beh of issue153 is
    constant G_ROUND_ENABLE:boolean:=true;
    constant C_ADDROUND : bit_vector(7 downto 0):=""00001111"";
    constant C_ZERO8 : bit_vector(7 downto 0):=(others=>'0');
    signal s_ena:bit_vector(7 downto 0);
    type T_IN_DATA is array(integer range<>) of bit_vector(7 downto 0);
--signal s_value: T_IN_DATA(7 downto -1);-- this should work anyway, uncomment this to compare with ghdl for bug 2
    signal s_value: T_IN_DATA(7 downto 0);--this is for bug 1, nvc should report error
begin

    GEN_MACS_V : for v in 0 to 7 generate
        signal C   :bit_vector(7 downto 0);
        signal D   :bit_vector(7 downto 0);
    begin
        --should fail here, but doesn't
        --GHDL failed here with ""bound check failure""
        -- ghdl drives correct values on each instances, nvc doesn't
        C    <= C_ADDROUND when v=0 and G_ROUND_ENABLE else s_value(v-1);--bug 1
        -- below is workaround, but I am lazy enough to not use it :))))
        --c_gen: if v=0 and G_ROUND_ENABLE generate
        --    C    <= C_ADDROUND;
        --end generate c_gen;
        --nc_gen: if v>0  generate
        --    C <= s_value(v-1);
        --end generate nc_gen;

        test_i : entity work.test_inst
            generic map(
                G_ROUND         => 1
                )
            port map(
                i_value     => C,
                o_ena       => s_ena(v),
                o_value     => s_value(v)
                );
    end generate GEN_MACS_V;

    process
    begin
        wait for 1 ns;
        wait;
    end process;

end architecture;
",3608,"Based on the given Verilog code, the following assertions could be justified:

1) ['0', 'i_value', 'bit_vector(7 downto 0)', 'i_value should be of size 8 bits in order to fit into bit_vector(7 downto 0)']
Reasoning: The i_value input in the test_inst module should be of size 8 bits to match with its declared format (bit_vector(7 downto 0)).

2) ['0', 'o_ena', 'bit', 'o_ena should be a single bit']
Reasoning: The output 'o_ena' is declared as 'out bit' in the 'test_inst' module, which means it should be a single bit.

3) ['0', 'o_value', 'bit_vector(7 downto 0)', 'o_value should be of size 8 bits in order to fit into bit_vector(7 downto 0)']
Reasoning: The o_value output in the test_inst module should be of size 8 bits to match with its declared format (bit_vector(7 downto 0)).

4) ['0', 'C', 'bit_vector(7 downto 0)', 'C should be of size 8 bits in order to fit into bit_vector(7 downto 0)']
Reasoning: The internal signal C within the generate loop should be of size 8 bits to match with its declared format (bit_vector(7 downto 0)).

5) ['0', 'D', 'bit_vector(7 downto 0)', 'D should be of size 8 bits in order to fit into bit_vector(7 downto 0)']
Reasoning: The internal signal D within the generate loop should be of size 8 bits to match with its declared format (bit_vector(7 downto 0)).

6) ['0', 'G_ROUND_ENABLE', 'boolean', 'G_ROUND_ENABLE should be boolean']
Reasoning: The G_ROUND_ENABLE is used in conditional statements, so it must be a boolean variable."
546,3121,peteut/ghdl,"
-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1750.vhd,v 1.2 2001-10-26 16:30:12 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c09s05b00x00p21n01i01750ent IS
  generic (g1: integer := 12);
  port (
    input1: in  bit ;
    input2: in  bit ;
    clk   : in  boolean;
    output: out bit);
END c09s05b00x00p21n01i01750ent;

ARCHITECTURE c09s05b00x00p21n01i01750arch OF c09s05b00x00p21n01i01750ent IS
  type boolvec is array (positive range <>) of boolean;
  function F (BB: boolvec) return boolean is
  begin
    return TRUE;
  end;
  
  signal i :  F boolean bus;
  signal k :  boolean ;
BEGIN
  i <= transport k;  -- Failure_here
  -- i is a guarded target while the statement is not a guarded assignment
  TESTING: PROCESS
  BEGIN
    assert FALSE 
      report ""***FAILED TEST: c09s05b00x00p21n01i01750 - Ungarded signal can not assign to a guarded signal."" 
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c09s05b00x00p21n01i01750arch;
","

-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1750.vhd,v 1.2 2001-10-26 16:30:12 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c09s05b00x00p21n01i01750ent IS
  generic (g1: integer := 12);
  port (
    input1: in  bit ;
    input2: in  bit ;
    clk   : in  boolean;
    output: out bit);
END c09s05b00x00p21n01i01750ent;

ARCHITECTURE c09s05b00x00p21n01i01750arch OF c09s05b00x00p21n01i01750ent IS
  type boolvec is array (positive range <>) of boolean;
  function F (BB: boolvec) return boolean is
  begin
    return TRUE;
  end;
  
  signal i :  F boolean bus;
  signal k :  boolean ;
BEGIN
  i <= transport k;  -- Failure_here
  -- i is a guarded target while the statement is not a guarded assignment
  TESTING: PROCESS
  BEGIN
      report ""***FAILED TEST: c09s05b00x00p21n01i01750 - Ungarded signal can not assign to a guarded signal."" 
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c09s05b00x00p21n01i01750arch;
",['FALSE'],1,"['o', 'nt', ':= 12)']",3,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
['o', 'nt', ':= 12)']
*Code:


-- Copyright (C) 2001 Bill Billowitch.

-- Some of the work to develop this test suite was done with Air Force
-- support.  The Air Force and Bill Billowitch assume no
-- responsibilities for this software.

-- This file is part of VESTs (Vhdl tESTs).

-- VESTs is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the
-- Free Software Foundation; either version 2 of the License, or (at
-- your option) any later version. 

-- VESTs is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details. 

-- You should have received a copy of the GNU General Public License
-- along with VESTs; if not, write to the Free Software Foundation,
-- Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

-- ---------------------------------------------------------------------
--
-- $Id: tc1750.vhd,v 1.2 2001-10-26 16:30:12 paw Exp $
-- $Revision: 1.2 $
--
-- ---------------------------------------------------------------------

ENTITY c09s05b00x00p21n01i01750ent IS
  generic (g1: integer := 12);
  port (
    input1: in  bit ;
    input2: in  bit ;
    clk   : in  boolean;
    output: out bit);
END c09s05b00x00p21n01i01750ent;

ARCHITECTURE c09s05b00x00p21n01i01750arch OF c09s05b00x00p21n01i01750ent IS
  type boolvec is array (positive range <>) of boolean;
  function F (BB: boolvec) return boolean is
  begin
    return TRUE;
  end;
  
  signal i :  F boolean bus;
  signal k :  boolean ;
BEGIN
  i <= transport k;  -- Failure_here
  -- i is a guarded target while the statement is not a guarded assignment
  TESTING: PROCESS
  BEGIN
      report ""***FAILED TEST: c09s05b00x00p21n01i01750 - Ungarded signal can not assign to a guarded signal."" 
      severity ERROR;
    wait;
  END PROCESS TESTING;

END c09s05b00x00p21n01i01750arch;
",3484,"This is a VHDL code, not a Verilog code. VHDL and Verilog are two different hardware description languages and they have different syntax and constructs. Therefore, I can't generate Verilog assertions for a VHDL code.
Please provide a Verilog code for me to generate the assertions."
547,3125,plessl/zippy,"------------------------------------------------------------------------------
-- Testbench for cycledncntr.vhd
--
-- Project    : 
-- File       : tb_cycledncntr.vhd
-- Author     : Rolf Enzler  <enzler@ife.ee.ethz.ch>
-- Company    : Swiss Federal Institute of Technology (ETH) Zurich
-- Created    : 2002/06/26
-- Last changed: $LastChangedDate: 2004-10-05 17:10:36 +0200 (Tue, 05 Oct 2004) $
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.componentsPkg.all;
use work.auxPkg.all;

entity tb_CycleDnCntr is

end tb_CycleDnCntr;


architecture arch of tb_CycleDnCntr is

  constant CNTWIDTH : integer := 8;     -- Counter width

  -- simulation stuff
  constant CLK_PERIOD : time    := 100 ns;
  signal   ccount     : integer := 1;

  type   tbstatusType is (rst, idle, load, countdown, done);
  signal tbStatus : tbstatusType := idle;

  -- general control signals
  signal ClkxC  : std_logic := '1';
  signal RstxRB : std_logic;

  -- DUT I/O signals
  signal LoadxE : std_logic;
  signal CinxD  : std_logic_vector(CNTWIDTH-1 downto 0);
  signal OnxS   : std_logic;
  signal CoutxD : std_logic_vector(CNTWIDTH-1 downto 0);
  
begin  -- arch

  ----------------------------------------------------------------------------
  -- device under test
  ----------------------------------------------------------------------------
  dut : CycleDnCntr
    generic map (
      CNTWIDTH => CNTWIDTH)
    port map (
      ClkxC   => ClkxC,
      RstxRB  => RstxRB,
      LoadxEI => LoadxE,
      CinxDI  => CinxD,
      OnxSO   => OnxS,
      CoutxDO => CoutxD);

  ----------------------------------------------------------------------------
  -- stimuli
  ----------------------------------------------------------------------------
  stimuliTb : process
  begin  -- process stimuliTb

    tbStatus <= rst;
    LoadxE   <= '0';
    CinxD    <= std_logic_vector(to_unsigned(0, CNTWIDTH));

    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '0');
    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '1');
    tbStatus <= idle;
    wait for CLK_PERIOD*0.25;

    tbStatus <= load;                   -- load start value
    LoadxE   <= '1';
    CinxD    <= std_logic_vector(to_unsigned(9, CNTWIDTH));
    wait for CLK_PERIOD;

    tbStatus <= countdown;              -- countdown
    LoadxE   <= '0';
    CinxD    <= std_logic_vector(to_unsigned(0, CNTWIDTH));
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= load;                   -- load start value
    LoadxE   <= '1';                    -- (should *not* be loaded)
    CinxD    <= std_logic_vector(to_unsigned(9, CNTWIDTH));
    wait for CLK_PERIOD;

    tbStatus <= countdown;              -- countdown
    LoadxE   <= '0';
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= load;                   -- load start value
    LoadxE   <= '1';
    CinxD    <= std_logic_vector(to_unsigned(4, CNTWIDTH));
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    LoadxE   <= '0';
    tbStatus <= countdown;              -- countdown

    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= done;                   -- done
    LoadxE   <= '0';
    CinxD    <= std_logic_vector(to_unsigned(0, CNTWIDTH));
    wait for CLK_PERIOD;

    -- stop simulation
    wait until (ClkxC'event and ClkxC = '1');
    assert false
      report ""stimuli processed; sim. terminated after "" & int2str(ccount) &
      "" cycles""
      severity failure;
    
  end process stimuliTb;

  ----------------------------------------------------------------------------
  -- clock and reset generation
  ----------------------------------------------------------------------------
  ClkxC  <= not ClkxC after CLK_PERIOD/2;
  RstxRB <= '0', '1'  after CLK_PERIOD*1.25;

  ----------------------------------------------------------------------------
  -- cycle counter
  ----------------------------------------------------------------------------
  cyclecounter : process (ClkxC)
  begin
    if (ClkxC'event and ClkxC = '1') then
      ccount <= ccount + 1;
    end if;
  end process cyclecounter;

end arch;
","
------------------------------------------------------------------------------
-- Testbench for cycledncntr.vhd
--
-- Project    : 
-- File       : tb_cycledncntr.vhd
-- Author     : Rolf Enzler  <enzler@ife.ee.ethz.ch>
-- Company    : Swiss Federal Institute of Technology (ETH) Zurich
-- Created    : 2002/06/26
-- Last changed: $LastChangedDate: 2004-10-05 17:10:36 +0200 (Tue, 05 Oct 2004) $
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.componentsPkg.all;
use work.auxPkg.all;

entity tb_CycleDnCntr is

end tb_CycleDnCntr;


architecture arch of tb_CycleDnCntr is

  constant CNTWIDTH : integer := 8;     -- Counter width

  -- simulation stuff
  constant CLK_PERIOD : time    := 100 ns;
  signal   ccount     : integer := 1;

  type   tbstatusType is (rst, idle, load, countdown, done);
  signal tbStatus : tbstatusType := idle;

  -- general control signals
  signal ClkxC  : std_logic := '1';
  signal RstxRB : std_logic;

  -- DUT I/O signals
  signal LoadxE : std_logic;
  signal CinxD  : std_logic_vector(CNTWIDTH-1 downto 0);
  signal OnxS   : std_logic;
  signal CoutxD : std_logic_vector(CNTWIDTH-1 downto 0);
  
begin  -- arch

  ----------------------------------------------------------------------------
  -- device under test
  ----------------------------------------------------------------------------
  dut : CycleDnCntr
    generic map (
      CNTWIDTH => CNTWIDTH)
    port map (
      ClkxC   => ClkxC,
      RstxRB  => RstxRB,
      LoadxEI => LoadxE,
      CinxDI  => CinxD,
      OnxSO   => OnxS,
      CoutxDO => CoutxD);

  ----------------------------------------------------------------------------
  -- stimuli
  ----------------------------------------------------------------------------
  stimuliTb : process
  begin  -- process stimuliTb

    tbStatus <= rst;
    LoadxE   <= '0';
    CinxD    <= std_logic_vector(to_unsigned(0, CNTWIDTH));

    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '0');
    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '1');
    tbStatus <= idle;
    wait for CLK_PERIOD*0.25;

    tbStatus <= load;                   -- load start value
    LoadxE   <= '1';
    CinxD    <= std_logic_vector(to_unsigned(9, CNTWIDTH));
    wait for CLK_PERIOD;

    tbStatus <= countdown;              -- countdown
    LoadxE   <= '0';
    CinxD    <= std_logic_vector(to_unsigned(0, CNTWIDTH));
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= load;                   -- load start value
    LoadxE   <= '1';                    -- (should *not* be loaded)
    CinxD    <= std_logic_vector(to_unsigned(9, CNTWIDTH));
    wait for CLK_PERIOD;

    tbStatus <= countdown;              -- countdown
    LoadxE   <= '0';
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= load;                   -- load start value
    LoadxE   <= '1';
    CinxD    <= std_logic_vector(to_unsigned(4, CNTWIDTH));
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    LoadxE   <= '0';
    tbStatus <= countdown;              -- countdown

    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= done;                   -- done
    LoadxE   <= '0';
    CinxD    <= std_logic_vector(to_unsigned(0, CNTWIDTH));
    wait for CLK_PERIOD;

    -- stop simulation
    wait until (ClkxC'event and ClkxC = '1');
      report ""stimuli processed; sim. terminated after "" & int2str(ccount) &
      "" cycles""
      severity failure;
    
  end process stimuliTb;

  ----------------------------------------------------------------------------
  -- clock and reset generation
  ----------------------------------------------------------------------------
  ClkxC  <= not ClkxC after CLK_PERIOD/2;
  RstxRB <= '0', '1'  after CLK_PERIOD*1.25;

  ----------------------------------------------------------------------------
  -- cycle counter
  ----------------------------------------------------------------------------
  cyclecounter : process (ClkxC)
  begin
    if (ClkxC'event and ClkxC = '1') then
      ccount <= ccount + 1;
    end if;
  end process cyclecounter;

end arch;
",['false'],1,"[':= 100 ns', ':= 1', ':= 8']",3,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 100 ns', ':= 1', ':= 8']
*Code:

------------------------------------------------------------------------------
-- Testbench for cycledncntr.vhd
--
-- Project    : 
-- File       : tb_cycledncntr.vhd
-- Author     : Rolf Enzler  <enzler@ife.ee.ethz.ch>
-- Company    : Swiss Federal Institute of Technology (ETH) Zurich
-- Created    : 2002/06/26
-- Last changed: $LastChangedDate: 2004-10-05 17:10:36 +0200 (Tue, 05 Oct 2004) $
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.componentsPkg.all;
use work.auxPkg.all;

entity tb_CycleDnCntr is

end tb_CycleDnCntr;


architecture arch of tb_CycleDnCntr is

  constant CNTWIDTH : integer := 8;     -- Counter width

  -- simulation stuff
  constant CLK_PERIOD : time    := 100 ns;
  signal   ccount     : integer := 1;

  type   tbstatusType is (rst, idle, load, countdown, done);
  signal tbStatus : tbstatusType := idle;

  -- general control signals
  signal ClkxC  : std_logic := '1';
  signal RstxRB : std_logic;

  -- DUT I/O signals
  signal LoadxE : std_logic;
  signal CinxD  : std_logic_vector(CNTWIDTH-1 downto 0);
  signal OnxS   : std_logic;
  signal CoutxD : std_logic_vector(CNTWIDTH-1 downto 0);
  
begin  -- arch

  ----------------------------------------------------------------------------
  -- device under test
  ----------------------------------------------------------------------------
  dut : CycleDnCntr
    generic map (
      CNTWIDTH => CNTWIDTH)
    port map (
      ClkxC   => ClkxC,
      RstxRB  => RstxRB,
      LoadxEI => LoadxE,
      CinxDI  => CinxD,
      OnxSO   => OnxS,
      CoutxDO => CoutxD);

  ----------------------------------------------------------------------------
  -- stimuli
  ----------------------------------------------------------------------------
  stimuliTb : process
  begin  -- process stimuliTb

    tbStatus <= rst;
    LoadxE   <= '0';
    CinxD    <= std_logic_vector(to_unsigned(0, CNTWIDTH));

    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '0');
    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '1');
    tbStatus <= idle;
    wait for CLK_PERIOD*0.25;

    tbStatus <= load;                   -- load start value
    LoadxE   <= '1';
    CinxD    <= std_logic_vector(to_unsigned(9, CNTWIDTH));
    wait for CLK_PERIOD;

    tbStatus <= countdown;              -- countdown
    LoadxE   <= '0';
    CinxD    <= std_logic_vector(to_unsigned(0, CNTWIDTH));
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= load;                   -- load start value
    LoadxE   <= '1';                    -- (should *not* be loaded)
    CinxD    <= std_logic_vector(to_unsigned(9, CNTWIDTH));
    wait for CLK_PERIOD;

    tbStatus <= countdown;              -- countdown
    LoadxE   <= '0';
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= load;                   -- load start value
    LoadxE   <= '1';
    CinxD    <= std_logic_vector(to_unsigned(4, CNTWIDTH));
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    LoadxE   <= '0';
    tbStatus <= countdown;              -- countdown

    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= done;                   -- done
    LoadxE   <= '0';
    CinxD    <= std_logic_vector(to_unsigned(0, CNTWIDTH));
    wait for CLK_PERIOD;

    -- stop simulation
    wait until (ClkxC'event and ClkxC = '1');
      report ""stimuli processed; sim. terminated after "" & int2str(ccount) &
      "" cycles""
      severity failure;
    
  end process stimuliTb;

  ----------------------------------------------------------------------------
  -- clock and reset generation
  ----------------------------------------------------------------------------
  ClkxC  <= not ClkxC after CLK_PERIOD/2;
  RstxRB <= '0', '1'  after CLK_PERIOD*1.25;

  ----------------------------------------------------------------------------
  -- cycle counter
  ----------------------------------------------------------------------------
  cyclecounter : process (ClkxC)
  begin
    if (ClkxC'event and ClkxC = '1') then
      ccount <= ccount + 1;
    end if;
  end process cyclecounter;

end arch;
",5923,"[':= 100 ns', 'CLK_PERIOD', None, ""Assert that the clock period is correctly set for the simulation""]
[':= 1', 'ccount', None, ""Assert that the cycle count starts at 1""]
[':= 8', 'CNTWIDTH', None, ""Assert that the counter width is set correctly""]
['tbStatus', 'idle', 'LoadxE + CinxD', ""Assert that both LoadxE and CinxD signals are idle at the beginning""]
['ClkxC', '1', None, ""ClkxC should always be equal to 1""]
['RstxRB', '0', None, ""Initially RstxRB should be 0, assert the reset state""]
['RstxRB', '1', 'RstxRB', ""RstxRB should be 1 after reset""]
['tbStatus', 'load', ['LoadxE', 'CinxD'], ""Assert that both LoadxE and CinxD signals are loading values""]
['tbStatus', 'countdown', ['LoadxE', 'CinxD'], ""Assert that both LoadxE and CinxD signals are counting down""]
['tbStatus', 'done', ['LoadxE', 'CinxD'], ""Assert that both LoadxE and CinxD signals are done when tbStatus is done""]
['ClkxC', '1', 'ClkxC', ""Assert that ClkxC is equal to 1 when the simulation stops""]
['CoutxD', 'CNTWIDTH-1', 'CinxD', ""Assert that output count CoutxD equals CNTWIDTH-1 down to the CinxD""]"
548,3130,plessl/zippy,"------------------------------------------------------------------------------
-- Testbench for cclkgating.vhd
--
-- Project    : 
-- File       : tb_cclkgating.vhd
-- Author     : Rolf Enzler  <enzler@ife.ee.ethz.ch>
-- Company    : Swiss Federal Institute of Technology (ETH) Zurich
-- Created    : 2002/06/26
-- Last changed: $LastChangedDate: 2004-10-05 17:10:36 +0200 (Tue, 05 Oct 2004) $
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.componentsPkg.all;
use work.auxPkg.all;

entity tb_CClkGating is

end tb_CClkGating;

architecture arch of tb_CClkGating is

  -- simulation stuff
  constant CLK_PERIOD : time    := 100 ns;
  signal   ccount     : integer := 1;

  type   tbstatusType is (rst, idle, en, dis, done);
  signal tbStatus : tbstatusType := idle;

  -- general control signals
  signal ClkxC  : std_logic := '1';
  signal RstxRB : std_logic;

  -- data/control signals
  signal EnxE     : std_logic;
  signal CClockxC : std_logic;

begin  -- arch

  ----------------------------------------------------------------------------
  -- device under test
  ----------------------------------------------------------------------------
  dut : CClkGating
    port map (
      EnxEI     => EnxE,
      MClockxCI => ClkxC,
      CClockxCO => CClockxC);

  ----------------------------------------------------------------------------
  -- stimuli
  ----------------------------------------------------------------------------
  stimuliTb : process
  begin  -- process stimuliTb

    tbStatus <= rst;
    EnxE <= '0';

    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '0');
    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '1');
    tbStatus <= idle;
    wait for CLK_PERIOD*0.25;

    tbStatus <= en;                 -- enable
    EnxE <= '1';
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= dis;                 -- disable
    EnxE <= '0';
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= done;                   -- done
    EnxE <= '0';
    wait for CLK_PERIOD;

    -- stop simulation
    wait until (ClkxC'event and ClkxC = '1');
    assert false
      report ""stimuli processed; sim. terminated after "" & int2str(ccount) &
      "" cycles""
      severity failure;
    
  end process stimuliTb;

  ----------------------------------------------------------------------------
  -- clock and reset generation
  ----------------------------------------------------------------------------
  ClkxC  <= not ClkxC after CLK_PERIOD/2;
  RstxRB <= '0', '1'  after CLK_PERIOD*1.25;

  ----------------------------------------------------------------------------
  -- cycle counter
  ----------------------------------------------------------------------------
  cyclecounter : process (ClkxC)
  begin
    if (ClkxC'event and ClkxC = '1') then
      ccount <= ccount + 1;
    end if;
  end process cyclecounter;

end arch;
","
------------------------------------------------------------------------------
-- Testbench for cclkgating.vhd
--
-- Project    : 
-- File       : tb_cclkgating.vhd
-- Author     : Rolf Enzler  <enzler@ife.ee.ethz.ch>
-- Company    : Swiss Federal Institute of Technology (ETH) Zurich
-- Created    : 2002/06/26
-- Last changed: $LastChangedDate: 2004-10-05 17:10:36 +0200 (Tue, 05 Oct 2004) $
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.componentsPkg.all;
use work.auxPkg.all;

entity tb_CClkGating is

end tb_CClkGating;

architecture arch of tb_CClkGating is

  -- simulation stuff
  constant CLK_PERIOD : time    := 100 ns;
  signal   ccount     : integer := 1;

  type   tbstatusType is (rst, idle, en, dis, done);
  signal tbStatus : tbstatusType := idle;

  -- general control signals
  signal ClkxC  : std_logic := '1';
  signal RstxRB : std_logic;

  -- data/control signals
  signal EnxE     : std_logic;
  signal CClockxC : std_logic;

begin  -- arch

  ----------------------------------------------------------------------------
  -- device under test
  ----------------------------------------------------------------------------
  dut : CClkGating
    port map (
      EnxEI     => EnxE,
      MClockxCI => ClkxC,
      CClockxCO => CClockxC);

  ----------------------------------------------------------------------------
  -- stimuli
  ----------------------------------------------------------------------------
  stimuliTb : process
  begin  -- process stimuliTb

    tbStatus <= rst;
    EnxE <= '0';

    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '0');
    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '1');
    tbStatus <= idle;
    wait for CLK_PERIOD*0.25;

    tbStatus <= en;                 -- enable
    EnxE <= '1';
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= dis;                 -- disable
    EnxE <= '0';
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= done;                   -- done
    EnxE <= '0';
    wait for CLK_PERIOD;

    -- stop simulation
    wait until (ClkxC'event and ClkxC = '1');
      report ""stimuli processed; sim. terminated after "" & int2str(ccount) &
      "" cycles""
      severity failure;
    
  end process stimuliTb;

  ----------------------------------------------------------------------------
  -- clock and reset generation
  ----------------------------------------------------------------------------
  ClkxC  <= not ClkxC after CLK_PERIOD/2;
  RstxRB <= '0', '1'  after CLK_PERIOD*1.25;

  ----------------------------------------------------------------------------
  -- cycle counter
  ----------------------------------------------------------------------------
  cyclecounter : process (ClkxC)
  begin
    if (ClkxC'event and ClkxC = '1') then
      ccount <= ccount + 1;
    end if;
  end process cyclecounter;

end arch;
",['false'],1,"[':= 100 ns', ':= 1']",2,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
[':= 100 ns', ':= 1']
*Code:

------------------------------------------------------------------------------
-- Testbench for cclkgating.vhd
--
-- Project    : 
-- File       : tb_cclkgating.vhd
-- Author     : Rolf Enzler  <enzler@ife.ee.ethz.ch>
-- Company    : Swiss Federal Institute of Technology (ETH) Zurich
-- Created    : 2002/06/26
-- Last changed: $LastChangedDate: 2004-10-05 17:10:36 +0200 (Tue, 05 Oct 2004) $
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.componentsPkg.all;
use work.auxPkg.all;

entity tb_CClkGating is

end tb_CClkGating;

architecture arch of tb_CClkGating is

  -- simulation stuff
  constant CLK_PERIOD : time    := 100 ns;
  signal   ccount     : integer := 1;

  type   tbstatusType is (rst, idle, en, dis, done);
  signal tbStatus : tbstatusType := idle;

  -- general control signals
  signal ClkxC  : std_logic := '1';
  signal RstxRB : std_logic;

  -- data/control signals
  signal EnxE     : std_logic;
  signal CClockxC : std_logic;

begin  -- arch

  ----------------------------------------------------------------------------
  -- device under test
  ----------------------------------------------------------------------------
  dut : CClkGating
    port map (
      EnxEI     => EnxE,
      MClockxCI => ClkxC,
      CClockxCO => CClockxC);

  ----------------------------------------------------------------------------
  -- stimuli
  ----------------------------------------------------------------------------
  stimuliTb : process
  begin  -- process stimuliTb

    tbStatus <= rst;
    EnxE <= '0';

    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '0');
    wait until (ClkxC'event and ClkxC = '1' and RstxRB = '1');
    tbStatus <= idle;
    wait for CLK_PERIOD*0.25;

    tbStatus <= en;                 -- enable
    EnxE <= '1';
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= dis;                 -- disable
    EnxE <= '0';
    wait for CLK_PERIOD;
    wait for CLK_PERIOD;

    tbStatus <= done;                   -- done
    EnxE <= '0';
    wait for CLK_PERIOD;

    -- stop simulation
    wait until (ClkxC'event and ClkxC = '1');
      report ""stimuli processed; sim. terminated after "" & int2str(ccount) &
      "" cycles""
      severity failure;
    
  end process stimuliTb;

  ----------------------------------------------------------------------------
  -- clock and reset generation
  ----------------------------------------------------------------------------
  ClkxC  <= not ClkxC after CLK_PERIOD/2;
  RstxRB <= '0', '1'  after CLK_PERIOD*1.25;

  ----------------------------------------------------------------------------
  -- cycle counter
  ----------------------------------------------------------------------------
  cyclecounter : process (ClkxC)
  begin
    if (ClkxC'event and ClkxC = '1') then
      ccount <= ccount + 1;
    end if;
  end process cyclecounter;

end arch;
",4542,"['after CLK_PERIOD', 'EnxE', '1', ""EnxE should be set to 1 after one clock period""],
['after CLK_PERIOD*0.25', 'tbStatus', 'idle', ""tbStatus should be idle after 0.25 of a clock period""],
['after CLK_PERIOD*5', 'EnxE', '0', ""EnxE should be set to 0 after five clock periods""],
['after CLK_PERIOD', 'tbStatus', 'done', ""tbStatus should be done after one clock period""],
['after CLK_PERIOD/2', 'RstxRB', '1', ""RstxRB should be set to 1 after half of a clock period""],
[CLK_PERIOD, 'ccount', 'ccount + 1', ""ccount should increment by 1 after each clock period""]"
549,3167,SylvainLesne/openPOWERLINK_V2,"--! @file dpRam-bhv-a.vhd
--
--! @brief Dual Port Ram Register Transfer Level Architecture
--
--! @details This is the DPRAM intended for synthesis on Xilinx Spartan 6 only.
--!          It is specific for the openMAC descriptor DPRAM which require
--!          simultaneous write/read from the same address.
--!          Timing as follows [clk-cycles]: write=0 / read=1
--! @note Note that only port B reads valid data reliably!
--
-------------------------------------------------------------------------------
-- Architecture : rtl
-------------------------------------------------------------------------------
--
--    (c) B&R, 2015
--
--    Redistribution and use in source and binary forms, with or without
--    modification, are permitted provided that the following conditions
--    are met:
--
--    1. Redistributions of source code must retain the above copyright
--       notice, this list of conditions and the following disclaimer.
--
--    2. Redistributions in binary form must reproduce the above copyright
--       notice, this list of conditions and the following disclaimer in the
--       documentation and/or other materials provided with the distribution.
--
--    3. Neither the name of B&R nor the names of its
--       contributors may be used to endorse or promote products derived
--       from this software without prior written permission. For written
--       permission, please contact office@br-automation.com
--
--    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
--    ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
--    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
--    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
--    COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
--    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
--    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
--    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
--    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
--    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
--    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
--    POSSIBILITY OF SUCH DAMAGE.
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

--! Common library
library libcommon;
--! Use common library global package
use libcommon.global.all;

architecture rtl of dpRamOpenmac is
    --! Width of a byte
    constant cByte      : natural := 8;
    --! Address width (used to generate size depending on address width)
    constant cAddrWidth : natural := iAddress_A'length;
    --! RAM size
    constant cRamSize   : natural := 2**cAddrWidth;

    --! Type for data port
    subtype tDataPort is std_logic_vector(gWordWidth-1 downto 0);
    --! RAM type with given size
    type tRam is array (cRamSize-1 downto 0) of tDataPort;

    --! Shared variable to model and synthesize a DPR
    shared variable vDpram : tRam := (others => (others => cInactivated));

    --! Port A readport
    signal readdataA    : tDataPort;
    --! Port B readport
    signal readdataB    : tDataPort;
begin
    assert (gInitFile = ""UNUSED"")
    report ""Memory initialization is not supported in this architecture!""
    severity warning;

    -- assign readdata to ports
    oReaddata_A <= readdataA;
    oReaddata_B <= readdataB;

    --! This process describes port A of the DPRAM. The write process considers
    --! iWriteEnable_A and iByteenable_A. The read process is done with every
    --! rising iClk_A edge.
    PORTA : process(iClk_A)
    begin
        if rising_edge(iClk_A) then
            if iEnable_A = cActivated then
                ---------------------------------------------------------------
                -- Set write port A to READ_FIRST to enable reliable read at
                -- port B!

                -- read word from DPRAM
                readdataA <= vDpram(to_integer(unsigned(iAddress_A)));
                ---------------------------------------------------------------

                if iWriteEnable_A = cActivated then
                    for i in iByteenable_A'range loop
                        if iByteenable_A(i) = cActivated then
                            -- write byte to DPRAM
                            vDpram(to_integer(unsigned(iAddress_A)))(
                                (i+1)*cByte-1 downto i*cByte
                            ) := iWritedata_A(
                                (i+1)*cByte-1 downto i*cByte
                            );
                        end if; --byteenable
                    end loop;
                end if; --writeenable
            end if; --enable
        end if;
    end process PORTA;

    --! This process describes port B of the DPRAM. The write process considers
    --! iWriteEnable_B and iByteenable_B. The read process is done with every
    --! rising iClk_B edge.
    PORTB : process(iClk_B)
    begin
        if rising_edge(iClk_B) then
            if iEnable_B = cActivated then
                if iWriteEnable_B = cActivated then
                    for i in iByteenable_B'range loop
                        if iByteenable_B(i) = cActivated then
                            -- write byte to DPRAM
                            vDpram(to_integer(unsigned(iAddress_B)))(
                                (i+1)*cByte-1 downto i*cByte
                            ) := iWritedata_B(
                                (i+1)*cByte-1 downto i*cByte
                            );
                        end if; --byteenable
                    end loop;
                end if; --writeenable
                -- read word from DPRAM
                readdataB <= vDpram(to_integer(unsigned(iAddress_B)));
            end if; --enable
        end if;
    end process PORTB;
end architecture rtl;
","
--! @file dpRam-bhv-a.vhd
--
--! @brief Dual Port Ram Register Transfer Level Architecture
--
--! @details This is the DPRAM intended for synthesis on Xilinx Spartan 6 only.
--!          It is specific for the openMAC descriptor DPRAM which require
--!          simultaneous write/read from the same address.
--!          Timing as follows [clk-cycles]: write=0 / read=1
--! @note Note that only port B reads valid data reliably!
--
-------------------------------------------------------------------------------
-- Architecture : rtl
-------------------------------------------------------------------------------
--
--    (c) B&R, 2015
--
--    Redistribution and use in source and binary forms, with or without
--    modification, are permitted provided that the following conditions
--    are met:
--
--    1. Redistributions of source code must retain the above copyright
--       notice, this list of conditions and the following disclaimer.
--
--    2. Redistributions in binary form must reproduce the above copyright
--       notice, this list of conditions and the following disclaimer in the
--       documentation and/or other materials provided with the distribution.
--
--    3. Neither the name of B&R nor the names of its
--       contributors may be used to endorse or promote products derived
--       from this software without prior written permission. For written
--       permission, please contact office@br-automation.com
--
--    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
--    ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
--    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
--    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
--    COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
--    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
--    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
--    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
--    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
--    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
--    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
--    POSSIBILITY OF SUCH DAMAGE.
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

--! Common library
library libcommon;
--! Use common library global package
use libcommon.global.all;

architecture rtl of dpRamOpenmac is
    --! Width of a byte
    constant cByte      : natural := 8;
    --! Address width (used to generate size depending on address width)
    constant cAddrWidth : natural := iAddress_A'length;
    --! RAM size
    constant cRamSize   : natural := 2**cAddrWidth;

    --! Type for data port
    subtype tDataPort is std_logic_vector(gWordWidth-1 downto 0);
    --! RAM type with given size
    type tRam is array (cRamSize-1 downto 0) of tDataPort;

    --! Shared variable to model and synthesize a DPR
    shared variable vDpram : tRam := (others => (others => cInactivated));

    --! Port A readport
    signal readdataA    : tDataPort;
    --! Port B readport
    signal readdataB    : tDataPort;
begin
    report ""Memory initialization is not supported in this architecture!""
    severity warning;

    -- assign readdata to ports
    oReaddata_A <= readdataA;
    oReaddata_B <= readdataB;

    --! This process describes port A of the DPRAM. The write process considers
    --! iWriteEnable_A and iByteenable_A. The read process is done with every
    --! rising iClk_A edge.
    PORTA : process(iClk_A)
    begin
        if rising_edge(iClk_A) then
            if iEnable_A = cActivated then
                ---------------------------------------------------------------
                -- Set write port A to READ_FIRST to enable reliable read at
                -- port B!

                -- read word from DPRAM
                readdataA <= vDpram(to_integer(unsigned(iAddress_A)));
                ---------------------------------------------------------------

                if iWriteEnable_A = cActivated then
                    for i in iByteenable_A'range loop
                        if iByteenable_A(i) = cActivated then
                            -- write byte to DPRAM
                            vDpram(to_integer(unsigned(iAddress_A)))(
                                (i+1)*cByte-1 downto i*cByte
                            ) := iWritedata_A(
                                (i+1)*cByte-1 downto i*cByte
                            );
                        end if; --byteenable
                    end loop;
                end if; --writeenable
            end if; --enable
        end if;
    end process PORTA;

    --! This process describes port B of the DPRAM. The write process considers
    --! iWriteEnable_B and iByteenable_B. The read process is done with every
    --! rising iClk_B edge.
    PORTB : process(iClk_B)
    begin
        if rising_edge(iClk_B) then
            if iEnable_B = cActivated then
                if iWriteEnable_B = cActivated then
                    for i in iByteenable_B'range loop
                        if iByteenable_B(i) = cActivated then
                            -- write byte to DPRAM
                            vDpram(to_integer(unsigned(iAddress_B)))(
                                (i+1)*cByte-1 downto i*cByte
                            ) := iWritedata_B(
                                (i+1)*cByte-1 downto i*cByte
                            );
                        end if; --byteenable
                    end loop;
                end if; --writeenable
                -- read word from DPRAM
                readdataB <= vDpram(to_integer(unsigned(iAddress_B)));
            end if; --enable
        end if;
    end process PORTB;
end architecture rtl;
","['(gInitFile = ""UNUSED"")']",1,['eaddata'],1,"You are a helpful bot that adds assertions to pieces of Verilog code.
You will be given a string of code presented in the format:
*Variables:
...
*Code:
...
Generate assertions based on the following criteria:
1) Assert that the function can take in all inputs necessary to complete the process
2) Assert that all outputs are of the proper sizes.

Your response should ONLY be a list of assertions in the format:
[timing, subject_variable, target, reasoning]
 -timing is the clock cycle(s) at which the assertion is checked relative to the present cycle
 -subject_variable and target can ONLY be variables present in the code, integers, booleans, or None
 -reasoning is a short decription of why the assertion was made

Here is an example of what your input will look like and what you should return:
Example Input:
*Variables:
[clkstart, pr1, cStart, sr1]
*Code:
assign clkstart = clk && gGate;
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clkstart) cStart |-> sr1;
endproperty

sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty
Example Output:
[clkstart, cStart, sr1, ""cStart should be equal to sr1 at the start of every clock cycle""]
Which would be the same as adding the assertion:
assert @(posedge clkstart) cStart |-> sr1 else $display(""cStart should be equal to sr1 at the start of every clock cycle"");


Here is the actual input you should provide assertions for:
*Variables:
['eaddata']
*Code:

--! @file dpRam-bhv-a.vhd
--
--! @brief Dual Port Ram Register Transfer Level Architecture
--
--! @details This is the DPRAM intended for synthesis on Xilinx Spartan 6 only.
--!          It is specific for the openMAC descriptor DPRAM which require
--!          simultaneous write/read from the same address.
--!          Timing as follows [clk-cycles]: write=0 / read=1
--! @note Note that only port B reads valid data reliably!
--
-------------------------------------------------------------------------------
-- Architecture : rtl
-------------------------------------------------------------------------------
--
--    (c) B&R, 2015
--
--    Redistribution and use in source and binary forms, with or without
--    modification, are permitted provided that the following conditions
--    are met:
--
--    1. Redistributions of source code must retain the above copyright
--       notice, this list of conditions and the following disclaimer.
--
--    2. Redistributions in binary form must reproduce the above copyright
--       notice, this list of conditions and the following disclaimer in the
--       documentation and/or other materials provided with the distribution.
--
--    3. Neither the name of B&R nor the names of its
--       contributors may be used to endorse or promote products derived
--       from this software without prior written permission. For written
--       permission, please contact office@br-automation.com
--
--    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
--    ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
--    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
--    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
--    COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
--    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
--    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
--    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
--    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
--    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
--    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
--    POSSIBILITY OF SUCH DAMAGE.
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

--! Common library
library libcommon;
--! Use common library global package
use libcommon.global.all;

architecture rtl of dpRamOpenmac is
    --! Width of a byte
    constant cByte      : natural := 8;
    --! Address width (used to generate size depending on address width)
    constant cAddrWidth : natural := iAddress_A'length;
    --! RAM size
    constant cRamSize   : natural := 2**cAddrWidth;

    --! Type for data port
    subtype tDataPort is std_logic_vector(gWordWidth-1 downto 0);
    --! RAM type with given size
    type tRam is array (cRamSize-1 downto 0) of tDataPort;

    --! Shared variable to model and synthesize a DPR
    shared variable vDpram : tRam := (others => (others => cInactivated));

    --! Port A readport
    signal readdataA    : tDataPort;
    --! Port B readport
    signal readdataB    : tDataPort;
begin
    report ""Memory initialization is not supported in this architecture!""
    severity warning;

    -- assign readdata to ports
    oReaddata_A <= readdataA;
    oReaddata_B <= readdataB;

    --! This process describes port A of the DPRAM. The write process considers
    --! iWriteEnable_A and iByteenable_A. The read process is done with every
    --! rising iClk_A edge.
    PORTA : process(iClk_A)
    begin
        if rising_edge(iClk_A) then
            if iEnable_A = cActivated then
                ---------------------------------------------------------------
                -- Set write port A to READ_FIRST to enable reliable read at
                -- port B!

                -- read word from DPRAM
                readdataA <= vDpram(to_integer(unsigned(iAddress_A)));
                ---------------------------------------------------------------

                if iWriteEnable_A = cActivated then
                    for i in iByteenable_A'range loop
                        if iByteenable_A(i) = cActivated then
                            -- write byte to DPRAM
                            vDpram(to_integer(unsigned(iAddress_A)))(
                                (i+1)*cByte-1 downto i*cByte
                            ) := iWritedata_A(
                                (i+1)*cByte-1 downto i*cByte
                            );
                        end if; --byteenable
                    end loop;
                end if; --writeenable
            end if; --enable
        end if;
    end process PORTA;

    --! This process describes port B of the DPRAM. The write process considers
    --! iWriteEnable_B and iByteenable_B. The read process is done with every
    --! rising iClk_B edge.
    PORTB : process(iClk_B)
    begin
        if rising_edge(iClk_B) then
            if iEnable_B = cActivated then
                if iWriteEnable_B = cActivated then
                    for i in iByteenable_B'range loop
                        if iByteenable_B(i) = cActivated then
                            -- write byte to DPRAM
                            vDpram(to_integer(unsigned(iAddress_B)))(
                                (i+1)*cByte-1 downto i*cByte
                            ) := iWritedata_B(
                                (i+1)*cByte-1 downto i*cByte
                            );
                        end if; --byteenable
                    end loop;
                end if; --writeenable
                -- read word from DPRAM
                readdataB <= vDpram(to_integer(unsigned(iAddress_B)));
            end if; --enable
        end if;
    end process PORTB;
end architecture rtl;
",7410,"[""iClk_A"", iEnable_A, None, ""iEnable_A should be activated at the start of each cycle.""],
[""iClk_A"", iWriteEnable_A, None, ""iWriteEnable_A should be activated at the start of each cycle when writing.""],
[""iClk_A"", iByteenable_A, None, ""iByteenable_A should be activated at the start of each cycle during the writing process.""],
[""iClk_B"", iEnable_B, None, ""iEnable_B should be activated at the start of each cycle.""],
[""iClk_B"", iWriteEnable_B, None, ""iWriteEnable_B should be activated at the start of each cycle when writing.""],
[""iClk_B"", iByteenable_B, None, ""iByteenable_B should be activated at the start of each cycle during the writing process.""],
[""iClk_A"", readdataA, tDataPort, ""readdataA should be of type tDataPort and updated at every cycle.""],
[""iClk_B"", readdataB, tDataPort, ""readdataB should be of type tDataPort and updated at every cycle.""]"
