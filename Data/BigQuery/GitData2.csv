repo_name,content,assertions,variables,unasserted_content
sydney-linux-user-group-dependencies/python-pyrss2gen,"# unittest?  What's that?
#
# You'll need Mark Pilgrim's feed_parser, from
#  http://diveintomark.org/projects/feed_parser/
# The test takes a structure, converts it to XML,
# reads it back using feed_parser, and compares
# the two stuctures.  feed_parser doesn't handle
# everything, so I needed to filter some items.
# I also haven't tested everything.

import datetime
import PyRSS2Gen
import feedparser

rss = PyRSS2Gen.RSS2(
    ""This is a test"",
    ""http://www.dalkescientific.com/"",
    ""To be or not to be.  That is the question."",

    language = ""en-US"",
    copyright = ""Copyright (c) 2003, by me"",
    managingEditor = ""here@there (everywhere)"",
    webMaster = ""Spider Man"",
    pubDate = datetime.datetime(2000, 11, 20, 23, 45, 19),
    lastBuildDate = datetime.datetime(2001, 12, 25, 22, 51, 49),
    categories = [""live"", ""love"", ""larf"", ""loaf""],

    cloud = PyRSS2Gen.Cloud(""rpc.sys.com"", 80, ""/RPC2"", ""pingMe"", ""soap""),
                       
    ttl = 10,
    image = PyRSS2Gen.Image(""http://there/"", ""THERE!"", ""link?"",
                            25, 94, ""some description""),
    rating = ""For all audiences"",

    textInput = PyRSS2Gen.TextInput(""Qwerty"", ""Shrdlu"", ""Etaoin"",
                                    ""http://some/link""),
    skipDays = PyRSS2Gen.SkipDays([""Monday"", ""Thursday""]),
    skipHours = PyRSS2Gen.SkipHours([0, 5, 22]),

    items = [PyRSS2Gen.RSSItem(
                ""Chapter 1"", ""http://xe.com/"",
                ""How to convert money."",
                author = ""x@xe"",
                # categories
                comments = ""http://slashdot.org"",
                # enclosure
                guid = ""http://asdfghjk/"",
                pubDate = datetime.datetime(1999, 1, 30),
                source = PyRSS2Gen.Source(""ftp://x.y/"",
                                          ""Quotes of the Day""),
                          
                ),
             PyRSS2Gen.RSSItem(""Chapter 2"", ""http://acm.org/"",
                               ""AT&T is <Ma Bell>."",
                               guid = PyRSS2Gen.Guid(guid = ""12345"", isPermaLink = False),
                               ),
             ])

def _convert_to_liberal(obj):
    if isinstance(obj, basestring):
        return obj
    elif isinstance(obj, int):
        return str(obj)
    elif isinstance(obj, datetime.datetime):
        return PyRSS2Gen._format_date(obj)
    else:
        d = {}
        for k, v in obj.__dict__.items():
            if v is None:
                continue
            if k == ""element_attrs"":
                d.update(v)
            elif k in (""categories"", ""days"", ""hours"", ""author"",
                       ""comments"", ""source""):
                # feedparser doesn't handle these
                continue
            elif k == ""guid"" and not isinstance(v, str):
                d[k] = v.guid
            else:
                if k == ""pubDate"":
                    k = ""date""
                d[k] = _convert_to_liberal(v)
        return d
        

def to_liberal(rss):
    d = {""encoding"": ""iso-8859-1""}  # a bit of a hack
    channel = d[""channel""] = {}
    items = rss.__dict__.items() # enforce an (arbitrary) order
    items.sort()                 # (feedparser result depends on the
    for k, v in items:           # order of the elements.)
        if v is None:
            continue
        if k in (""categories"", ""docs"", ""generator"", ""cloud"", ""ttl"",
                 ""image"", ""rating"", ""textInput"", ""skipDays"", ""skipHours""):
            # feedparser doesn't handle these
            pass
        elif k != ""items"":
            # Why the changes?
            if k == ""copyright"":
                k = ""rights""
            elif k == ""lastBuildDate"":
                k = ""date""
            elif k in (""webMaster"", ""managingEditor""):
                k = ""creator""   # order dependent!
            elif k in (""pubDate"", ""lastBuildDate""):
                if ""date"" in channel:
                    # lastBuildDate has priority
                    if k == ""pubDate"":
                        continue
                k = ""date""  # also order dependent
            channel[k] = _convert_to_liberal(v)
        
    items = [_convert_to_liberal(item) for item in rss.items]
    d[""items""] = items

    return d

s = rss.to_xml()
import cStringIO as StringIO
f = StringIO.StringIO(s)
result = feedparser.parse(f)
##print result
##print ""==========""
##print to_liberal(rss)

result2 = to_liberal(rss)
assert result == result2

execfile(""example.py"")

# Check a few things new to 1.0

def EQ(x, y):
    if not (x == y):
        raise AssertionError( (x, y) )

class RecordingHandler:
    def __init__(self):
        self.events = []
    def startElement(self, tag, d):
        self.events.append( (""SE"", tag, d) )
    def characters(self, text):
        self.events.append( (""C"", text) )
    def endElement(self, tag):
        self.events.append( (""EE"", tag) )

def publish_it(obj):
    h = RecordingHandler()
    obj.publish(h)
    return h.events

obj = PyRSS2Gen.Enclosure(""http://example.com"", 5, ""text/plain"")
EQ(publish_it(obj), [(""SE"", ""enclosure"", {""url"": ""http://example.com"",
                                          ""length"": ""5"",
                                          ""type"": ""text/plain""}),
                     (""EE"", ""enclosure""),
                     ])

obj = PyRSS2Gen.Guid(""ABCDEF"", False)
EQ(publish_it(obj), [(""SE"", ""guid"", {""isPermaLink"": ""false""}),
                     (""C"", ""ABCDEF""),
                     (""EE"", ""guid""),
                     ])
","[['result', '==', 'result2']]","['rss', 'language', 'copyright', 'managingEditor', 'webMaster', 'pubDate', 'lastBuildDate', 'categories', 'cloud', 'ttl', 'image', 'rating', 'textInput', 'skipDays', 'skipHours', 'items', 'author', 'comments', 'guid', 'source', 'obj', 'd', 'd[k]', 'k', 'channel', 'channel[k]', 'd[""items""]', 's', 'f', 'result', 'result2', 'x', 'y', 'self.events', 'tag', 'text', 'h']","# unittest?  What's that?
#
# You'll need Mark Pilgrim's feed_parser, from
#  http://diveintomark.org/projects/feed_parser/
# The test takes a structure, converts it to XML,
# reads it back using feed_parser, and compares
# the two stuctures.  feed_parser doesn't handle
# everything, so I needed to filter some items.
# I also haven't tested everything.

import datetime
import PyRSS2Gen
import feedparser

rss = PyRSS2Gen.RSS2(
    ""This is a test"",
    ""http://www.dalkescientific.com/"",
    ""To be or not to be.  That is the question."",

    language = ""en-US"",
    copyright = ""Copyright (c) 2003, by me"",
    managingEditor = ""here@there (everywhere)"",
    webMaster = ""Spider Man"",
    pubDate = datetime.datetime(2000, 11, 20, 23, 45, 19),
    lastBuildDate = datetime.datetime(2001, 12, 25, 22, 51, 49),
    categories = [""live"", ""love"", ""larf"", ""loaf""],

    cloud = PyRSS2Gen.Cloud(""rpc.sys.com"", 80, ""/RPC2"", ""pingMe"", ""soap""),
                       
    ttl = 10,
    image = PyRSS2Gen.Image(""http://there/"", ""THERE!"", ""link?"",
                            25, 94, ""some description""),
    rating = ""For all audiences"",

    textInput = PyRSS2Gen.TextInput(""Qwerty"", ""Shrdlu"", ""Etaoin"",
                                    ""http://some/link""),
    skipDays = PyRSS2Gen.SkipDays([""Monday"", ""Thursday""]),
    skipHours = PyRSS2Gen.SkipHours([0, 5, 22]),

    items = [PyRSS2Gen.RSSItem(
                ""Chapter 1"", ""http://xe.com/"",
                ""How to convert money."",
                author = ""x@xe"",
                # categories
                comments = ""http://slashdot.org"",
                # enclosure
                guid = ""http://asdfghjk/"",
                pubDate = datetime.datetime(1999, 1, 30),
                source = PyRSS2Gen.Source(""ftp://x.y/"",
                                          ""Quotes of the Day""),
                          
                ),
             PyRSS2Gen.RSSItem(""Chapter 2"", ""http://acm.org/"",
                               ""AT&T is <Ma Bell>."",
                               guid = PyRSS2Gen.Guid(guid = ""12345"", isPermaLink = False),
                               ),
             ])

def _convert_to_liberal(obj):
    if isinstance(obj, basestring):
        return obj
    elif isinstance(obj, int):
        return str(obj)
    elif isinstance(obj, datetime.datetime):
        return PyRSS2Gen._format_date(obj)
    else:
        d = {}
        for k, v in obj.__dict__.items():
            if v is None:
                continue
            if k == ""element_attrs"":
                d.update(v)
            elif k in (""categories"", ""days"", ""hours"", ""author"",
                       ""comments"", ""source""):
                # feedparser doesn't handle these
                continue
            elif k == ""guid"" and not isinstance(v, str):
                d[k] = v.guid
            else:
                if k == ""pubDate"":
                    k = ""date""
                d[k] = _convert_to_liberal(v)
        return d
        

def to_liberal(rss):
    d = {""encoding"": ""iso-8859-1""}  # a bit of a hack
    channel = d[""channel""] = {}
    items = rss.__dict__.items() # enforce an (arbitrary) order
    items.sort()                 # (feedparser result depends on the
    for k, v in items:           # order of the elements.)
        if v is None:
            continue
        if k in (""categories"", ""docs"", ""generator"", ""cloud"", ""ttl"",
                 ""image"", ""rating"", ""textInput"", ""skipDays"", ""skipHours""):
            # feedparser doesn't handle these
            pass
        elif k != ""items"":
            # Why the changes?
            if k == ""copyright"":
                k = ""rights""
            elif k == ""lastBuildDate"":
                k = ""date""
            elif k in (""webMaster"", ""managingEditor""):
                k = ""creator""   # order dependent!
            elif k in (""pubDate"", ""lastBuildDate""):
                if ""date"" in channel:
                    # lastBuildDate has priority
                    if k == ""pubDate"":
                        continue
                k = ""date""  # also order dependent
            channel[k] = _convert_to_liberal(v)
        
    items = [_convert_to_liberal(item) for item in rss.items]
    d[""items""] = items

    return d

s = rss.to_xml()
import cStringIO as StringIO
f = StringIO.StringIO(s)
result = feedparser.parse(f)
##print result
##print ""==========""
##print to_liberal(rss)

result2 = to_liberal(rss)

execfile(""example.py"")

# Check a few things new to 1.0

def EQ(x, y):
    if not (x == y):
        raise AssertionError( (x, y) )

class RecordingHandler:
    def __init__(self):
        self.events = []
    def startElement(self, tag, d):
        self.events.append( (""SE"", tag, d) )
    def characters(self, text):
        self.events.append( (""C"", text) )
    def endElement(self, tag):
        self.events.append( (""EE"", tag) )

def publish_it(obj):
    h = RecordingHandler()
    obj.publish(h)
    return h.events

obj = PyRSS2Gen.Enclosure(""http://example.com"", 5, ""text/plain"")
EQ(publish_it(obj), [(""SE"", ""enclosure"", {""url"": ""http://example.com"",
                                          ""length"": ""5"",
                                          ""type"": ""text/plain""}),
                     (""EE"", ""enclosure""),
                     ])

obj = PyRSS2Gen.Guid(""ABCDEF"", False)
EQ(publish_it(obj), [(""SE"", ""guid"", {""isPermaLink"": ""false""}),
                     (""C"", ""ABCDEF""),
                     (""EE"", ""guid""),
                     ])
"
krafczyk/spack,"# -*- coding: utf-8 -*-
""""""
    jinja2.lexer
    ~~~~~~~~~~~~

    This module implements a Jinja / Python combination lexer. The
    `Lexer` class provided by this module is used to do some preprocessing
    for Jinja.

    On the one hand it filters out invalid operators like the bitshift
    operators we don't allow in templates. On the other hand it separates
    template code and python code in expressions.

    :copyright: (c) 2017 by the Jinja Team.
    :license: BSD, see LICENSE for more details.
""""""
import re
from collections import deque
from operator import itemgetter

from jinja2._compat import implements_iterator, intern, iteritems, text_type
from jinja2.exceptions import TemplateSyntaxError
from jinja2.utils import LRUCache

# cache for the lexers. Exists in order to be able to have multiple
# environments with the same lexer
_lexer_cache = LRUCache(50)

# static regular expressions
whitespace_re = re.compile(r'\s+', re.U)
string_re = re.compile(r""('([^'\\]*(?:\\.[^'\\]*)*)'""
                       r'|""([^""\\]*(?:\\.[^""\\]*)*)"")', re.S)
integer_re = re.compile(r'\d+')

try:
    # check if this Python supports Unicode identifiers
    compile('föö', '<unknown>', 'eval')
except SyntaxError:
    # no Unicode support, use ASCII identifiers
    name_re = re.compile(r'[a-zA-Z_][a-zA-Z0-9_]*')
    check_ident = False
else:
    # Unicode support, build a pattern to match valid characters, and set flag
    # to use str.isidentifier to validate during lexing
    from jinja2 import _identifier
    name_re = re.compile(r'[\w{0}]+'.format(_identifier.pattern))
    check_ident = True
    # remove the pattern from memory after building the regex
    import sys
    del sys.modules['jinja2._identifier']
    import jinja2
    del jinja2._identifier
    del _identifier

float_re = re.compile(r'(?<!\.)\d+\.\d+')
newline_re = re.compile(r'(\r\n|\r|\n)')

# internal the tokens and keep references to them
TOKEN_ADD = intern('add')
TOKEN_ASSIGN = intern('assign')
TOKEN_COLON = intern('colon')
TOKEN_COMMA = intern('comma')
TOKEN_DIV = intern('div')
TOKEN_DOT = intern('dot')
TOKEN_EQ = intern('eq')
TOKEN_FLOORDIV = intern('floordiv')
TOKEN_GT = intern('gt')
TOKEN_GTEQ = intern('gteq')
TOKEN_LBRACE = intern('lbrace')
TOKEN_LBRACKET = intern('lbracket')
TOKEN_LPAREN = intern('lparen')
TOKEN_LT = intern('lt')
TOKEN_LTEQ = intern('lteq')
TOKEN_MOD = intern('mod')
TOKEN_MUL = intern('mul')
TOKEN_NE = intern('ne')
TOKEN_PIPE = intern('pipe')
TOKEN_POW = intern('pow')
TOKEN_RBRACE = intern('rbrace')
TOKEN_RBRACKET = intern('rbracket')
TOKEN_RPAREN = intern('rparen')
TOKEN_SEMICOLON = intern('semicolon')
TOKEN_SUB = intern('sub')
TOKEN_TILDE = intern('tilde')
TOKEN_WHITESPACE = intern('whitespace')
TOKEN_FLOAT = intern('float')
TOKEN_INTEGER = intern('integer')
TOKEN_NAME = intern('name')
TOKEN_STRING = intern('string')
TOKEN_OPERATOR = intern('operator')
TOKEN_BLOCK_BEGIN = intern('block_begin')
TOKEN_BLOCK_END = intern('block_end')
TOKEN_VARIABLE_BEGIN = intern('variable_begin')
TOKEN_VARIABLE_END = intern('variable_end')
TOKEN_RAW_BEGIN = intern('raw_begin')
TOKEN_RAW_END = intern('raw_end')
TOKEN_COMMENT_BEGIN = intern('comment_begin')
TOKEN_COMMENT_END = intern('comment_end')
TOKEN_COMMENT = intern('comment')
TOKEN_LINESTATEMENT_BEGIN = intern('linestatement_begin')
TOKEN_LINESTATEMENT_END = intern('linestatement_end')
TOKEN_LINECOMMENT_BEGIN = intern('linecomment_begin')
TOKEN_LINECOMMENT_END = intern('linecomment_end')
TOKEN_LINECOMMENT = intern('linecomment')
TOKEN_DATA = intern('data')
TOKEN_INITIAL = intern('initial')
TOKEN_EOF = intern('eof')

# bind operators to token types
operators = {
    '+':            TOKEN_ADD,
    '-':            TOKEN_SUB,
    '/':            TOKEN_DIV,
    '//':           TOKEN_FLOORDIV,
    '*':            TOKEN_MUL,
    '%':            TOKEN_MOD,
    '**':           TOKEN_POW,
    '~':            TOKEN_TILDE,
    '[':            TOKEN_LBRACKET,
    ']':            TOKEN_RBRACKET,
    '(':            TOKEN_LPAREN,
    ')':            TOKEN_RPAREN,
    '{':            TOKEN_LBRACE,
    '}':            TOKEN_RBRACE,
    '==':           TOKEN_EQ,
    '!=':           TOKEN_NE,
    '>':            TOKEN_GT,
    '>=':           TOKEN_GTEQ,
    '<':            TOKEN_LT,
    '<=':           TOKEN_LTEQ,
    '=':            TOKEN_ASSIGN,
    '.':            TOKEN_DOT,
    ':':            TOKEN_COLON,
    '|':            TOKEN_PIPE,
    ',':            TOKEN_COMMA,
    ';':            TOKEN_SEMICOLON
}

reverse_operators = dict([(v, k) for k, v in iteritems(operators)])
assert len(operators) == len(reverse_operators), 'operators dropped'
operator_re = re.compile('(%s)' % '|'.join(re.escape(x) for x in
                         sorted(operators, key=lambda x: -len(x))))

ignored_tokens = frozenset([TOKEN_COMMENT_BEGIN, TOKEN_COMMENT,
                            TOKEN_COMMENT_END, TOKEN_WHITESPACE,
                            TOKEN_LINECOMMENT_BEGIN, TOKEN_LINECOMMENT_END,
                            TOKEN_LINECOMMENT])
ignore_if_empty = frozenset([TOKEN_WHITESPACE, TOKEN_DATA,
                             TOKEN_COMMENT, TOKEN_LINECOMMENT])


def _describe_token_type(token_type):
    if token_type in reverse_operators:
        return reverse_operators[token_type]
    return {
        TOKEN_COMMENT_BEGIN:        'begin of comment',
        TOKEN_COMMENT_END:          'end of comment',
        TOKEN_COMMENT:              'comment',
        TOKEN_LINECOMMENT:          'comment',
        TOKEN_BLOCK_BEGIN:          'begin of statement block',
        TOKEN_BLOCK_END:            'end of statement block',
        TOKEN_VARIABLE_BEGIN:       'begin of print statement',
        TOKEN_VARIABLE_END:         'end of print statement',
        TOKEN_LINESTATEMENT_BEGIN:  'begin of line statement',
        TOKEN_LINESTATEMENT_END:    'end of line statement',
        TOKEN_DATA:                 'template data / text',
        TOKEN_EOF:                  'end of template'
    }.get(token_type, token_type)


def describe_token(token):
    """"""Returns a description of the token.""""""
    if token.type == 'name':
        return token.value
    return _describe_token_type(token.type)


def describe_token_expr(expr):
    """"""Like `describe_token` but for token expressions.""""""
    if ':' in expr:
        type, value = expr.split(':', 1)
        if type == 'name':
            return value
    else:
        type = expr
    return _describe_token_type(type)


def count_newlines(value):
    """"""Count the number of newline characters in the string.  This is
    useful for extensions that filter a stream.
    """"""
    return len(newline_re.findall(value))


def compile_rules(environment):
    """"""Compiles all the rules from the environment into a list of rules.""""""
    e = re.escape
    rules = [
        (len(environment.comment_start_string), 'comment',
         e(environment.comment_start_string)),
        (len(environment.block_start_string), 'block',
         e(environment.block_start_string)),
        (len(environment.variable_start_string), 'variable',
         e(environment.variable_start_string))
    ]

    if environment.line_statement_prefix is not None:
        rules.append((len(environment.line_statement_prefix), 'linestatement',
                      r'^[ \t\v]*' + e(environment.line_statement_prefix)))
    if environment.line_comment_prefix is not None:
        rules.append((len(environment.line_comment_prefix), 'linecomment',
                      r'(?:^|(?<=\S))[^\S\r\n]*' +
                      e(environment.line_comment_prefix)))

    return [x[1:] for x in sorted(rules, reverse=True)]


class Failure(object):
    """"""Class that raises a `TemplateSyntaxError` if called.
    Used by the `Lexer` to specify known errors.
    """"""

    def __init__(self, message, cls=TemplateSyntaxError):
        self.message = message
        self.error_class = cls

    def __call__(self, lineno, filename):
        raise self.error_class(self.message, lineno, filename)


class Token(tuple):
    """"""Token class.""""""
    __slots__ = ()
    lineno, type, value = (property(itemgetter(x)) for x in range(3))

    def __new__(cls, lineno, type, value):
        return tuple.__new__(cls, (lineno, intern(str(type)), value))

    def __str__(self):
        if self.type in reverse_operators:
            return reverse_operators[self.type]
        elif self.type == 'name':
            return self.value
        return self.type

    def test(self, expr):
        """"""Test a token against a token expression.  This can either be a
        token type or ``'token_type:token_value'``.  This can only test
        against string values and types.
        """"""
        # here we do a regular string equality check as test_any is usually
        # passed an iterable of not interned strings.
        if self.type == expr:
            return True
        elif ':' in expr:
            return expr.split(':', 1) == [self.type, self.value]
        return False

    def test_any(self, *iterable):
        """"""Test against multiple token expressions.""""""
        for expr in iterable:
            if self.test(expr):
                return True
        return False

    def __repr__(self):
        return 'Token(%r, %r, %r)' % (
            self.lineno,
            self.type,
            self.value
        )


@implements_iterator
class TokenStreamIterator(object):
    """"""The iterator for tokenstreams.  Iterate over the stream
    until the eof token is reached.
    """"""

    def __init__(self, stream):
        self.stream = stream

    def __iter__(self):
        return self

    def __next__(self):
        token = self.stream.current
        if token.type is TOKEN_EOF:
            self.stream.close()
            raise StopIteration()
        next(self.stream)
        return token


@implements_iterator
class TokenStream(object):
    """"""A token stream is an iterable that yields :class:`Token`\\s.  The
    parser however does not iterate over it but calls :meth:`next` to go
    one token ahead.  The current active token is stored as :attr:`current`.
    """"""

    def __init__(self, generator, name, filename):
        self._iter = iter(generator)
        self._pushed = deque()
        self.name = name
        self.filename = filename
        self.closed = False
        self.current = Token(1, TOKEN_INITIAL, '')
        next(self)

    def __iter__(self):
        return TokenStreamIterator(self)

    def __bool__(self):
        return bool(self._pushed) or self.current.type is not TOKEN_EOF
    __nonzero__ = __bool__  # py2

    eos = property(lambda x: not x, doc=""Are we at the end of the stream?"")

    def push(self, token):
        """"""Push a token back to the stream.""""""
        self._pushed.append(token)

    def look(self):
        """"""Look at the next token.""""""
        old_token = next(self)
        result = self.current
        self.push(result)
        self.current = old_token
        return result

    def skip(self, n=1):
        """"""Got n tokens ahead.""""""
        for x in range(n):
            next(self)

    def next_if(self, expr):
        """"""Perform the token test and return the token if it matched.
        Otherwise the return value is `None`.
        """"""
        if self.current.test(expr):
            return next(self)

    def skip_if(self, expr):
        """"""Like :meth:`next_if` but only returns `True` or `False`.""""""
        return self.next_if(expr) is not None

    def __next__(self):
        """"""Go one token ahead and return the old one.

        Use the built-in :func:`next` instead of calling this directly.
        """"""
        rv = self.current
        if self._pushed:
            self.current = self._pushed.popleft()
        elif self.current.type is not TOKEN_EOF:
            try:
                self.current = next(self._iter)
            except StopIteration:
                self.close()
        return rv

    def close(self):
        """"""Close the stream.""""""
        self.current = Token(self.current.lineno, TOKEN_EOF, '')
        self._iter = None
        self.closed = True

    def expect(self, expr):
        """"""Expect a given token type and return it.  This accepts the same
        argument as :meth:`jinja2.lexer.Token.test`.
        """"""
        if not self.current.test(expr):
            expr = describe_token_expr(expr)
            if self.current.type is TOKEN_EOF:
                raise TemplateSyntaxError('unexpected end of template, '
                                          'expected %r.' % expr,
                                          self.current.lineno,
                                          self.name, self.filename)
            raise TemplateSyntaxError(""expected token %r, got %r"" %
                                      (expr, describe_token(self.current)),
                                      self.current.lineno,
                                      self.name, self.filename)
        try:
            return self.current
        finally:
            next(self)


def get_lexer(environment):
    """"""Return a lexer which is probably cached.""""""
    key = (environment.block_start_string,
           environment.block_end_string,
           environment.variable_start_string,
           environment.variable_end_string,
           environment.comment_start_string,
           environment.comment_end_string,
           environment.line_statement_prefix,
           environment.line_comment_prefix,
           environment.trim_blocks,
           environment.lstrip_blocks,
           environment.newline_sequence,
           environment.keep_trailing_newline)
    lexer = _lexer_cache.get(key)
    if lexer is None:
        lexer = Lexer(environment)
        _lexer_cache[key] = lexer
    return lexer


class Lexer(object):
    """"""Class that implements a lexer for a given environment. Automatically
    created by the environment class, usually you don't have to do that.

    Note that the lexer is not automatically bound to an environment.
    Multiple environments can share the same lexer.
    """"""

    def __init__(self, environment):
        # shortcuts
        c = lambda x: re.compile(x, re.M | re.S)
        e = re.escape

        # lexing rules for tags
        tag_rules = [
            (whitespace_re, TOKEN_WHITESPACE, None),
            (float_re, TOKEN_FLOAT, None),
            (integer_re, TOKEN_INTEGER, None),
            (name_re, TOKEN_NAME, None),
            (string_re, TOKEN_STRING, None),
            (operator_re, TOKEN_OPERATOR, None)
        ]

        # assemble the root lexing rule. because ""|"" is ungreedy
        # we have to sort by length so that the lexer continues working
        # as expected when we have parsing rules like <% for block and
        # <%= for variables. (if someone wants asp like syntax)
        # variables are just part of the rules if variable processing
        # is required.
        root_tag_rules = compile_rules(environment)

        # block suffix if trimming is enabled
        block_suffix_re = environment.trim_blocks and '\\n?' or ''

        # strip leading spaces if lstrip_blocks is enabled
        prefix_re = {}
        if environment.lstrip_blocks:
            # use '{%+' to manually disable lstrip_blocks behavior
            no_lstrip_re = e('+')
            # detect overlap between block and variable or comment strings
            block_diff = c(r'^%s(.*)' % e(environment.block_start_string))
            # make sure we don't mistake a block for a variable or a comment
            m = block_diff.match(environment.comment_start_string)
            no_lstrip_re += m and r'|%s' % e(m.group(1)) or ''
            m = block_diff.match(environment.variable_start_string)
            no_lstrip_re += m and r'|%s' % e(m.group(1)) or ''

            # detect overlap between comment and variable strings
            comment_diff = c(r'^%s(.*)' % e(environment.comment_start_string))
            m = comment_diff.match(environment.variable_start_string)
            no_variable_re = m and r'(?!%s)' % e(m.group(1)) or ''

            lstrip_re = r'^[ \t]*'
            block_prefix_re = r'%s%s(?!%s)|%s\+?' % (
                    lstrip_re,
                    e(environment.block_start_string),
                    no_lstrip_re,
                    e(environment.block_start_string),
                    )
            comment_prefix_re = r'%s%s%s|%s\+?' % (
                    lstrip_re,
                    e(environment.comment_start_string),
                    no_variable_re,
                    e(environment.comment_start_string),
                    )
            prefix_re['block'] = block_prefix_re
            prefix_re['comment'] = comment_prefix_re
        else:
            block_prefix_re = '%s' % e(environment.block_start_string)

        self.newline_sequence = environment.newline_sequence
        self.keep_trailing_newline = environment.keep_trailing_newline

        # global lexing rules
        self.rules = {
            'root': [
                # directives
                (c('(.*?)(?:%s)' % '|'.join(
                    [r'(?P<raw_begin>(?:\s*%s\-|%s)\s*raw\s*(?:\-%s\s*|%s))' % (
                        e(environment.block_start_string),
                        block_prefix_re,
                        e(environment.block_end_string),
                        e(environment.block_end_string)
                    )] + [
                        r'(?P<%s_begin>\s*%s\-|%s)' % (n, r, prefix_re.get(n,r))
                        for n, r in root_tag_rules
                    ])), (TOKEN_DATA, '#bygroup'), '#bygroup'),
                # data
                (c('.+'), TOKEN_DATA, None)
            ],
            # comments
            TOKEN_COMMENT_BEGIN: [
                (c(r'(.*?)((?:\-%s\s*|%s)%s)' % (
                    e(environment.comment_end_string),
                    e(environment.comment_end_string),
                    block_suffix_re
                )), (TOKEN_COMMENT, TOKEN_COMMENT_END), '#pop'),
                (c('(.)'), (Failure('Missing end of comment tag'),), None)
            ],
            # blocks
            TOKEN_BLOCK_BEGIN: [
                (c(r'(?:\-%s\s*|%s)%s' % (
                    e(environment.block_end_string),
                    e(environment.block_end_string),
                    block_suffix_re
                )), TOKEN_BLOCK_END, '#pop'),
            ] + tag_rules,
            # variables
            TOKEN_VARIABLE_BEGIN: [
                (c(r'\-%s\s*|%s' % (
                    e(environment.variable_end_string),
                    e(environment.variable_end_string)
                )), TOKEN_VARIABLE_END, '#pop')
            ] + tag_rules,
            # raw block
            TOKEN_RAW_BEGIN: [
                (c(r'(.*?)((?:\s*%s\-|%s)\s*endraw\s*(?:\-%s\s*|%s%s))' % (
                    e(environment.block_start_string),
                    block_prefix_re,
                    e(environment.block_end_string),
                    e(environment.block_end_string),
                    block_suffix_re
                )), (TOKEN_DATA, TOKEN_RAW_END), '#pop'),
                (c('(.)'), (Failure('Missing end of raw directive'),), None)
            ],
            # line statements
            TOKEN_LINESTATEMENT_BEGIN: [
                (c(r'\s*(\n|$)'), TOKEN_LINESTATEMENT_END, '#pop')
            ] + tag_rules,
            # line comments
            TOKEN_LINECOMMENT_BEGIN: [
                (c(r'(.*?)()(?=\n|$)'), (TOKEN_LINECOMMENT,
                 TOKEN_LINECOMMENT_END), '#pop')
            ]
        }

    def _normalize_newlines(self, value):
        """"""Called for strings and template data to normalize it to unicode.""""""
        return newline_re.sub(self.newline_sequence, value)

    def tokenize(self, source, name=None, filename=None, state=None):
        """"""Calls tokeniter + tokenize and wraps it in a token stream.
        """"""
        stream = self.tokeniter(source, name, filename, state)
        return TokenStream(self.wrap(stream, name, filename), name, filename)

    def wrap(self, stream, name=None, filename=None):
        """"""This is called with the stream as returned by `tokenize` and wraps
        every token in a :class:`Token` and converts the value.
        """"""
        for lineno, token, value in stream:
            if token in ignored_tokens:
                continue
            elif token == 'linestatement_begin':
                token = 'block_begin'
            elif token == 'linestatement_end':
                token = 'block_end'
            # we are not interested in those tokens in the parser
            elif token in ('raw_begin', 'raw_end'):
                continue
            elif token == 'data':
                value = self._normalize_newlines(value)
            elif token == 'keyword':
                token = value
            elif token == 'name':
                value = str(value)
                if check_ident and not value.isidentifier():
                    raise TemplateSyntaxError(
                        'Invalid character in identifier',
                        lineno, name, filename)
            elif token == 'string':
                # try to unescape string
                try:
                    value = self._normalize_newlines(value[1:-1]) \
                        .encode('ascii', 'backslashreplace') \
                        .decode('unicode-escape')
                except Exception as e:
                    msg = str(e).split(':')[-1].strip()
                    raise TemplateSyntaxError(msg, lineno, name, filename)
            elif token == 'integer':
                value = int(value)
            elif token == 'float':
                value = float(value)
            elif token == 'operator':
                token = operators[value]
            yield Token(lineno, token, value)

    def tokeniter(self, source, name, filename=None, state=None):
        """"""This method tokenizes the text and returns the tokens in a
        generator.  Use this method if you just want to tokenize a template.
        """"""
        source = text_type(source)
        lines = source.splitlines()
        if self.keep_trailing_newline and source:
            for newline in ('\r\n', '\r', '\n'):
                if source.endswith(newline):
                    lines.append('')
                    break
        source = '\n'.join(lines)
        pos = 0
        lineno = 1
        stack = ['root']
        if state is not None and state != 'root':
            assert state in ('variable', 'block'), 'invalid state'
            stack.append(state + '_begin')
        else:
            state = 'root'
        statetokens = self.rules[stack[-1]]
        source_length = len(source)

        balancing_stack = []

        while 1:
            # tokenizer loop
            for regex, tokens, new_state in statetokens:
                m = regex.match(source, pos)
                # if no match we try again with the next rule
                if m is None:
                    continue

                # we only match blocks and variables if braces / parentheses
                # are balanced. continue parsing with the lower rule which
                # is the operator rule. do this only if the end tags look
                # like operators
                if balancing_stack and \
                   tokens in ('variable_end', 'block_end',
                              'linestatement_end'):
                    continue

                # tuples support more options
                if isinstance(tokens, tuple):
                    for idx, token in enumerate(tokens):
                        # failure group
                        if token.__class__ is Failure:
                            raise token(lineno, filename)
                        # bygroup is a bit more complex, in that case we
                        # yield for the current token the first named
                        # group that matched
                        elif token == '#bygroup':
                            for key, value in iteritems(m.groupdict()):
                                if value is not None:
                                    yield lineno, key, value
                                    lineno += value.count('\n')
                                    break
                            else:
                                raise RuntimeError('%r wanted to resolve '
                                                   'the token dynamically'
                                                   ' but no group matched'
                                                   % regex)
                        # normal group
                        else:
                            data = m.group(idx + 1)
                            if data or token not in ignore_if_empty:
                                yield lineno, token, data
                            lineno += data.count('\n')

                # strings as token just are yielded as it.
                else:
                    data = m.group()
                    # update brace/parentheses balance
                    if tokens == 'operator':
                        if data == '{':
                            balancing_stack.append('}')
                        elif data == '(':
                            balancing_stack.append(')')
                        elif data == '[':
                            balancing_stack.append(']')
                        elif data in ('}', ')', ']'):
                            if not balancing_stack:
                                raise TemplateSyntaxError('unexpected \'%s\'' %
                                                          data, lineno, name,
                                                          filename)
                            expected_op = balancing_stack.pop()
                            if expected_op != data:
                                raise TemplateSyntaxError('unexpected \'%s\', '
                                                          'expected \'%s\'' %
                                                          (data, expected_op),
                                                          lineno, name,
                                                          filename)
                    # yield items
                    if data or tokens not in ignore_if_empty:
                        yield lineno, tokens, data
                    lineno += data.count('\n')

                # fetch new position into new variable so that we can check
                # if there is a internal parsing error which would result
                # in an infinite loop
                pos2 = m.end()

                # handle state changes
                if new_state is not None:
                    # remove the uppermost state
                    if new_state == '#pop':
                        stack.pop()
                    # resolve the new state by group checking
                    elif new_state == '#bygroup':
                        for key, value in iteritems(m.groupdict()):
                            if value is not None:
                                stack.append(key)
                                break
                        else:
                            raise RuntimeError('%r wanted to resolve the '
                                               'new state dynamically but'
                                               ' no group matched' %
                                               regex)
                    # direct state name given
                    else:
                        stack.append(new_state)
                    statetokens = self.rules[stack[-1]]
                # we are still at the same position and no stack change.
                # this means a loop without break condition, avoid that and
                # raise error
                elif pos2 == pos:
                    raise RuntimeError('%r yielded empty string without '
                                       'stack change' % regex)
                # publish new function and start again
                pos = pos2
                break
            # if loop terminated without break we haven't found a single match
            # either we are at the end of the file or we have a problem
            else:
                # end of text
                if pos >= source_length:
                    return
                # something went wrong
                raise TemplateSyntaxError('unexpected char %r at %d' %
                                          (source[pos], pos), lineno,
                                          name, filename)
","[['len(operat', '==', 'True'], ['s)', '==', 'len(reverse_operat'], ['s)', '==', 'True'], ['state', 'in', ""('variable'""]]","['_lexer_cache', 'whitespace_re', 'string_re', 'integer_re', 'name_re', 'check_ident', 'float_re', 'newline_re', 'TOKEN_ADD', 'TOKEN_ASSIGN', 'TOKEN_COLON', 'TOKEN_COMMA', 'TOKEN_DIV', 'TOKEN_DOT', 'TOKEN_EQ', 'TOKEN_FLOORDIV', 'TOKEN_GT', 'TOKEN_GTEQ', 'TOKEN_LBRACE', 'TOKEN_LBRACKET', 'TOKEN_LPAREN', 'TOKEN_LT', 'TOKEN_LTEQ', 'TOKEN_MOD', 'TOKEN_MUL', 'TOKEN_NE', 'TOKEN_PIPE', 'TOKEN_POW', 'TOKEN_RBRACE', 'TOKEN_RBRACKET', 'TOKEN_RPAREN', 'TOKEN_SEMICOLON', 'TOKEN_SUB', 'TOKEN_TILDE', 'TOKEN_WHITESPACE', 'TOKEN_FLOAT', 'TOKEN_INTEGER', 'TOKEN_NAME', 'TOKEN_STRING', 'TOKEN_OPERATOR', 'TOKEN_BLOCK_BEGIN', 'TOKEN_BLOCK_END', 'TOKEN_VARIABLE_BEGIN', 'TOKEN_VARIABLE_END', 'TOKEN_RAW_BEGIN', 'TOKEN_RAW_END', 'TOKEN_COMMENT_BEGIN', 'TOKEN_COMMENT_END', 'TOKEN_COMMENT', 'TOKEN_LINESTATEMENT_BEGIN', 'TOKEN_LINESTATEMENT_END', 'TOKEN_LINECOMMENT_BEGIN', 'TOKEN_LINECOMMENT_END', 'TOKEN_LINECOMMENT', 'TOKEN_DATA', 'TOKEN_INITIAL', 'TOKEN_EOF', 'operators', 'reverse_operators', 'operator_re', 'ignored_tokens', 'ignore_if_empty', 'token_type', 'token', 'expr', 'type', 'value', 'environment', 'e', 'rules', 'message', 'cls', 'self.message', 'self.error_class', 'lineno', 'filename', '__slots__', '*iterable', 'stream', 'self.stream', 'generator', 'name', 'self._iter', 'self._pushed', 'self.name', 'self.filename', 'self.closed', 'self.current', '__nonzero__', 'eos', 'old_token', 'result', 'n', 'rv', 'key', 'lexer', '_lexer_cache[key]', 'c', 'tag_rules', 'root_tag_rules', 'block_suffix_re', 'prefix_re', 'no_lstrip_re', 'block_diff', 'm', 'comment_diff', 'no_variable_re', 'lstrip_re', 'block_prefix_re', 'comment_prefix_re', ""prefix_re['block']"", ""prefix_re['comment']"", 'self.newline_sequence', 'self.keep_trailing_newline', 'self.rules', 'source', 'state', 'msg', 'lines', 'pos', 'stack', 'statetokens', 'source_length', 'balancing_stack', 'data', 'expected_op', 'pos2']","# -*- coding: utf-8 -*-
""""""
    jinja2.lexer
    ~~~~~~~~~~~~

    This module implements a Jinja / Python combination lexer. The
    `Lexer` class provided by this module is used to do some preprocessing
    for Jinja.

    On the one hand it filters out invalid operators like the bitshift
    operators we don't allow in templates. On the other hand it separates
    template code and python code in expressions.

    :copyright: (c) 2017 by the Jinja Team.
    :license: BSD, see LICENSE for more details.
""""""
import re
from collections import deque
from operator import itemgetter

from jinja2._compat import implements_iterator, intern, iteritems, text_type
from jinja2.exceptions import TemplateSyntaxError
from jinja2.utils import LRUCache

# cache for the lexers. Exists in order to be able to have multiple
# environments with the same lexer
_lexer_cache = LRUCache(50)

# static regular expressions
whitespace_re = re.compile(r'\s+', re.U)
string_re = re.compile(r""('([^'\\]*(?:\\.[^'\\]*)*)'""
                       r'|""([^""\\]*(?:\\.[^""\\]*)*)"")', re.S)
integer_re = re.compile(r'\d+')

try:
    # check if this Python supports Unicode identifiers
    compile('föö', '<unknown>', 'eval')
except SyntaxError:
    # no Unicode support, use ASCII identifiers
    name_re = re.compile(r'[a-zA-Z_][a-zA-Z0-9_]*')
    check_ident = False
else:
    # Unicode support, build a pattern to match valid characters, and set flag
    # to use str.isidentifier to validate during lexing
    from jinja2 import _identifier
    name_re = re.compile(r'[\w{0}]+'.format(_identifier.pattern))
    check_ident = True
    # remove the pattern from memory after building the regex
    import sys
    del sys.modules['jinja2._identifier']
    import jinja2
    del jinja2._identifier
    del _identifier

float_re = re.compile(r'(?<!\.)\d+\.\d+')
newline_re = re.compile(r'(\r\n|\r|\n)')

# internal the tokens and keep references to them
TOKEN_ADD = intern('add')
TOKEN_ASSIGN = intern('assign')
TOKEN_COLON = intern('colon')
TOKEN_COMMA = intern('comma')
TOKEN_DIV = intern('div')
TOKEN_DOT = intern('dot')
TOKEN_EQ = intern('eq')
TOKEN_FLOORDIV = intern('floordiv')
TOKEN_GT = intern('gt')
TOKEN_GTEQ = intern('gteq')
TOKEN_LBRACE = intern('lbrace')
TOKEN_LBRACKET = intern('lbracket')
TOKEN_LPAREN = intern('lparen')
TOKEN_LT = intern('lt')
TOKEN_LTEQ = intern('lteq')
TOKEN_MOD = intern('mod')
TOKEN_MUL = intern('mul')
TOKEN_NE = intern('ne')
TOKEN_PIPE = intern('pipe')
TOKEN_POW = intern('pow')
TOKEN_RBRACE = intern('rbrace')
TOKEN_RBRACKET = intern('rbracket')
TOKEN_RPAREN = intern('rparen')
TOKEN_SEMICOLON = intern('semicolon')
TOKEN_SUB = intern('sub')
TOKEN_TILDE = intern('tilde')
TOKEN_WHITESPACE = intern('whitespace')
TOKEN_FLOAT = intern('float')
TOKEN_INTEGER = intern('integer')
TOKEN_NAME = intern('name')
TOKEN_STRING = intern('string')
TOKEN_OPERATOR = intern('operator')
TOKEN_BLOCK_BEGIN = intern('block_begin')
TOKEN_BLOCK_END = intern('block_end')
TOKEN_VARIABLE_BEGIN = intern('variable_begin')
TOKEN_VARIABLE_END = intern('variable_end')
TOKEN_RAW_BEGIN = intern('raw_begin')
TOKEN_RAW_END = intern('raw_end')
TOKEN_COMMENT_BEGIN = intern('comment_begin')
TOKEN_COMMENT_END = intern('comment_end')
TOKEN_COMMENT = intern('comment')
TOKEN_LINESTATEMENT_BEGIN = intern('linestatement_begin')
TOKEN_LINESTATEMENT_END = intern('linestatement_end')
TOKEN_LINECOMMENT_BEGIN = intern('linecomment_begin')
TOKEN_LINECOMMENT_END = intern('linecomment_end')
TOKEN_LINECOMMENT = intern('linecomment')
TOKEN_DATA = intern('data')
TOKEN_INITIAL = intern('initial')
TOKEN_EOF = intern('eof')

# bind operators to token types
operators = {
    '+':            TOKEN_ADD,
    '-':            TOKEN_SUB,
    '/':            TOKEN_DIV,
    '//':           TOKEN_FLOORDIV,
    '*':            TOKEN_MUL,
    '%':            TOKEN_MOD,
    '**':           TOKEN_POW,
    '~':            TOKEN_TILDE,
    '[':            TOKEN_LBRACKET,
    ']':            TOKEN_RBRACKET,
    '(':            TOKEN_LPAREN,
    ')':            TOKEN_RPAREN,
    '{':            TOKEN_LBRACE,
    '}':            TOKEN_RBRACE,
    '==':           TOKEN_EQ,
    '!=':           TOKEN_NE,
    '>':            TOKEN_GT,
    '>=':           TOKEN_GTEQ,
    '<':            TOKEN_LT,
    '<=':           TOKEN_LTEQ,
    '=':            TOKEN_ASSIGN,
    '.':            TOKEN_DOT,
    ':':            TOKEN_COLON,
    '|':            TOKEN_PIPE,
    ',':            TOKEN_COMMA,
    ';':            TOKEN_SEMICOLON
}

reverse_operators = dict([(v, k) for k, v in iteritems(operators)])
operator_re = re.compile('(%s)' % '|'.join(re.escape(x) for x in
                         sorted(operators, key=lambda x: -len(x))))

ignored_tokens = frozenset([TOKEN_COMMENT_BEGIN, TOKEN_COMMENT,
                            TOKEN_COMMENT_END, TOKEN_WHITESPACE,
                            TOKEN_LINECOMMENT_BEGIN, TOKEN_LINECOMMENT_END,
                            TOKEN_LINECOMMENT])
ignore_if_empty = frozenset([TOKEN_WHITESPACE, TOKEN_DATA,
                             TOKEN_COMMENT, TOKEN_LINECOMMENT])


def _describe_token_type(token_type):
    if token_type in reverse_operators:
        return reverse_operators[token_type]
    return {
        TOKEN_COMMENT_BEGIN:        'begin of comment',
        TOKEN_COMMENT_END:          'end of comment',
        TOKEN_COMMENT:              'comment',
        TOKEN_LINECOMMENT:          'comment',
        TOKEN_BLOCK_BEGIN:          'begin of statement block',
        TOKEN_BLOCK_END:            'end of statement block',
        TOKEN_VARIABLE_BEGIN:       'begin of print statement',
        TOKEN_VARIABLE_END:         'end of print statement',
        TOKEN_LINESTATEMENT_BEGIN:  'begin of line statement',
        TOKEN_LINESTATEMENT_END:    'end of line statement',
        TOKEN_DATA:                 'template data / text',
        TOKEN_EOF:                  'end of template'
    }.get(token_type, token_type)


def describe_token(token):
    """"""Returns a description of the token.""""""
    if token.type == 'name':
        return token.value
    return _describe_token_type(token.type)


def describe_token_expr(expr):
    """"""Like `describe_token` but for token expressions.""""""
    if ':' in expr:
        type, value = expr.split(':', 1)
        if type == 'name':
            return value
    else:
        type = expr
    return _describe_token_type(type)


def count_newlines(value):
    """"""Count the number of newline characters in the string.  This is
    useful for extensions that filter a stream.
    """"""
    return len(newline_re.findall(value))


def compile_rules(environment):
    """"""Compiles all the rules from the environment into a list of rules.""""""
    e = re.escape
    rules = [
        (len(environment.comment_start_string), 'comment',
         e(environment.comment_start_string)),
        (len(environment.block_start_string), 'block',
         e(environment.block_start_string)),
        (len(environment.variable_start_string), 'variable',
         e(environment.variable_start_string))
    ]

    if environment.line_statement_prefix is not None:
        rules.append((len(environment.line_statement_prefix), 'linestatement',
                      r'^[ \t\v]*' + e(environment.line_statement_prefix)))
    if environment.line_comment_prefix is not None:
        rules.append((len(environment.line_comment_prefix), 'linecomment',
                      r'(?:^|(?<=\S))[^\S\r\n]*' +
                      e(environment.line_comment_prefix)))

    return [x[1:] for x in sorted(rules, reverse=True)]


class Failure(object):
    """"""Class that raises a `TemplateSyntaxError` if called.
    Used by the `Lexer` to specify known errors.
    """"""

    def __init__(self, message, cls=TemplateSyntaxError):
        self.message = message
        self.error_class = cls

    def __call__(self, lineno, filename):
        raise self.error_class(self.message, lineno, filename)


class Token(tuple):
    """"""Token class.""""""
    __slots__ = ()
    lineno, type, value = (property(itemgetter(x)) for x in range(3))

    def __new__(cls, lineno, type, value):
        return tuple.__new__(cls, (lineno, intern(str(type)), value))

    def __str__(self):
        if self.type in reverse_operators:
            return reverse_operators[self.type]
        elif self.type == 'name':
            return self.value
        return self.type

    def test(self, expr):
        """"""Test a token against a token expression.  This can either be a
        token type or ``'token_type:token_value'``.  This can only test
        against string values and types.
        """"""
        # here we do a regular string equality check as test_any is usually
        # passed an iterable of not interned strings.
        if self.type == expr:
            return True
        elif ':' in expr:
            return expr.split(':', 1) == [self.type, self.value]
        return False

    def test_any(self, *iterable):
        """"""Test against multiple token expressions.""""""
        for expr in iterable:
            if self.test(expr):
                return True
        return False

    def __repr__(self):
        return 'Token(%r, %r, %r)' % (
            self.lineno,
            self.type,
            self.value
        )


@implements_iterator
class TokenStreamIterator(object):
    """"""The iterator for tokenstreams.  Iterate over the stream
    until the eof token is reached.
    """"""

    def __init__(self, stream):
        self.stream = stream

    def __iter__(self):
        return self

    def __next__(self):
        token = self.stream.current
        if token.type is TOKEN_EOF:
            self.stream.close()
            raise StopIteration()
        next(self.stream)
        return token


@implements_iterator
class TokenStream(object):
    """"""A token stream is an iterable that yields :class:`Token`\\s.  The
    parser however does not iterate over it but calls :meth:`next` to go
    one token ahead.  The current active token is stored as :attr:`current`.
    """"""

    def __init__(self, generator, name, filename):
        self._iter = iter(generator)
        self._pushed = deque()
        self.name = name
        self.filename = filename
        self.closed = False
        self.current = Token(1, TOKEN_INITIAL, '')
        next(self)

    def __iter__(self):
        return TokenStreamIterator(self)

    def __bool__(self):
        return bool(self._pushed) or self.current.type is not TOKEN_EOF
    __nonzero__ = __bool__  # py2

    eos = property(lambda x: not x, doc=""Are we at the end of the stream?"")

    def push(self, token):
        """"""Push a token back to the stream.""""""
        self._pushed.append(token)

    def look(self):
        """"""Look at the next token.""""""
        old_token = next(self)
        result = self.current
        self.push(result)
        self.current = old_token
        return result

    def skip(self, n=1):
        """"""Got n tokens ahead.""""""
        for x in range(n):
            next(self)

    def next_if(self, expr):
        """"""Perform the token test and return the token if it matched.
        Otherwise the return value is `None`.
        """"""
        if self.current.test(expr):
            return next(self)

    def skip_if(self, expr):
        """"""Like :meth:`next_if` but only returns `True` or `False`.""""""
        return self.next_if(expr) is not None

    def __next__(self):
        """"""Go one token ahead and return the old one.

        Use the built-in :func:`next` instead of calling this directly.
        """"""
        rv = self.current
        if self._pushed:
            self.current = self._pushed.popleft()
        elif self.current.type is not TOKEN_EOF:
            try:
                self.current = next(self._iter)
            except StopIteration:
                self.close()
        return rv

    def close(self):
        """"""Close the stream.""""""
        self.current = Token(self.current.lineno, TOKEN_EOF, '')
        self._iter = None
        self.closed = True

    def expect(self, expr):
        """"""Expect a given token type and return it.  This accepts the same
        argument as :meth:`jinja2.lexer.Token.test`.
        """"""
        if not self.current.test(expr):
            expr = describe_token_expr(expr)
            if self.current.type is TOKEN_EOF:
                raise TemplateSyntaxError('unexpected end of template, '
                                          'expected %r.' % expr,
                                          self.current.lineno,
                                          self.name, self.filename)
            raise TemplateSyntaxError(""expected token %r, got %r"" %
                                      (expr, describe_token(self.current)),
                                      self.current.lineno,
                                      self.name, self.filename)
        try:
            return self.current
        finally:
            next(self)


def get_lexer(environment):
    """"""Return a lexer which is probably cached.""""""
    key = (environment.block_start_string,
           environment.block_end_string,
           environment.variable_start_string,
           environment.variable_end_string,
           environment.comment_start_string,
           environment.comment_end_string,
           environment.line_statement_prefix,
           environment.line_comment_prefix,
           environment.trim_blocks,
           environment.lstrip_blocks,
           environment.newline_sequence,
           environment.keep_trailing_newline)
    lexer = _lexer_cache.get(key)
    if lexer is None:
        lexer = Lexer(environment)
        _lexer_cache[key] = lexer
    return lexer


class Lexer(object):
    """"""Class that implements a lexer for a given environment. Automatically
    created by the environment class, usually you don't have to do that.

    Note that the lexer is not automatically bound to an environment.
    Multiple environments can share the same lexer.
    """"""

    def __init__(self, environment):
        # shortcuts
        c = lambda x: re.compile(x, re.M | re.S)
        e = re.escape

        # lexing rules for tags
        tag_rules = [
            (whitespace_re, TOKEN_WHITESPACE, None),
            (float_re, TOKEN_FLOAT, None),
            (integer_re, TOKEN_INTEGER, None),
            (name_re, TOKEN_NAME, None),
            (string_re, TOKEN_STRING, None),
            (operator_re, TOKEN_OPERATOR, None)
        ]

        # assemble the root lexing rule. because ""|"" is ungreedy
        # we have to sort by length so that the lexer continues working
        # as expected when we have parsing rules like <% for block and
        # <%= for variables. (if someone wants asp like syntax)
        # variables are just part of the rules if variable processing
        # is required.
        root_tag_rules = compile_rules(environment)

        # block suffix if trimming is enabled
        block_suffix_re = environment.trim_blocks and '\\n?' or ''

        # strip leading spaces if lstrip_blocks is enabled
        prefix_re = {}
        if environment.lstrip_blocks:
            # use '{%+' to manually disable lstrip_blocks behavior
            no_lstrip_re = e('+')
            # detect overlap between block and variable or comment strings
            block_diff = c(r'^%s(.*)' % e(environment.block_start_string))
            # make sure we don't mistake a block for a variable or a comment
            m = block_diff.match(environment.comment_start_string)
            no_lstrip_re += m and r'|%s' % e(m.group(1)) or ''
            m = block_diff.match(environment.variable_start_string)
            no_lstrip_re += m and r'|%s' % e(m.group(1)) or ''

            # detect overlap between comment and variable strings
            comment_diff = c(r'^%s(.*)' % e(environment.comment_start_string))
            m = comment_diff.match(environment.variable_start_string)
            no_variable_re = m and r'(?!%s)' % e(m.group(1)) or ''

            lstrip_re = r'^[ \t]*'
            block_prefix_re = r'%s%s(?!%s)|%s\+?' % (
                    lstrip_re,
                    e(environment.block_start_string),
                    no_lstrip_re,
                    e(environment.block_start_string),
                    )
            comment_prefix_re = r'%s%s%s|%s\+?' % (
                    lstrip_re,
                    e(environment.comment_start_string),
                    no_variable_re,
                    e(environment.comment_start_string),
                    )
            prefix_re['block'] = block_prefix_re
            prefix_re['comment'] = comment_prefix_re
        else:
            block_prefix_re = '%s' % e(environment.block_start_string)

        self.newline_sequence = environment.newline_sequence
        self.keep_trailing_newline = environment.keep_trailing_newline

        # global lexing rules
        self.rules = {
            'root': [
                # directives
                (c('(.*?)(?:%s)' % '|'.join(
                    [r'(?P<raw_begin>(?:\s*%s\-|%s)\s*raw\s*(?:\-%s\s*|%s))' % (
                        e(environment.block_start_string),
                        block_prefix_re,
                        e(environment.block_end_string),
                        e(environment.block_end_string)
                    )] + [
                        r'(?P<%s_begin>\s*%s\-|%s)' % (n, r, prefix_re.get(n,r))
                        for n, r in root_tag_rules
                    ])), (TOKEN_DATA, '#bygroup'), '#bygroup'),
                # data
                (c('.+'), TOKEN_DATA, None)
            ],
            # comments
            TOKEN_COMMENT_BEGIN: [
                (c(r'(.*?)((?:\-%s\s*|%s)%s)' % (
                    e(environment.comment_end_string),
                    e(environment.comment_end_string),
                    block_suffix_re
                )), (TOKEN_COMMENT, TOKEN_COMMENT_END), '#pop'),
                (c('(.)'), (Failure('Missing end of comment tag'),), None)
            ],
            # blocks
            TOKEN_BLOCK_BEGIN: [
                (c(r'(?:\-%s\s*|%s)%s' % (
                    e(environment.block_end_string),
                    e(environment.block_end_string),
                    block_suffix_re
                )), TOKEN_BLOCK_END, '#pop'),
            ] + tag_rules,
            # variables
            TOKEN_VARIABLE_BEGIN: [
                (c(r'\-%s\s*|%s' % (
                    e(environment.variable_end_string),
                    e(environment.variable_end_string)
                )), TOKEN_VARIABLE_END, '#pop')
            ] + tag_rules,
            # raw block
            TOKEN_RAW_BEGIN: [
                (c(r'(.*?)((?:\s*%s\-|%s)\s*endraw\s*(?:\-%s\s*|%s%s))' % (
                    e(environment.block_start_string),
                    block_prefix_re,
                    e(environment.block_end_string),
                    e(environment.block_end_string),
                    block_suffix_re
                )), (TOKEN_DATA, TOKEN_RAW_END), '#pop'),
                (c('(.)'), (Failure('Missing end of raw directive'),), None)
            ],
            # line statements
            TOKEN_LINESTATEMENT_BEGIN: [
                (c(r'\s*(\n|$)'), TOKEN_LINESTATEMENT_END, '#pop')
            ] + tag_rules,
            # line comments
            TOKEN_LINECOMMENT_BEGIN: [
                (c(r'(.*?)()(?=\n|$)'), (TOKEN_LINECOMMENT,
                 TOKEN_LINECOMMENT_END), '#pop')
            ]
        }

    def _normalize_newlines(self, value):
        """"""Called for strings and template data to normalize it to unicode.""""""
        return newline_re.sub(self.newline_sequence, value)

    def tokenize(self, source, name=None, filename=None, state=None):
        """"""Calls tokeniter + tokenize and wraps it in a token stream.
        """"""
        stream = self.tokeniter(source, name, filename, state)
        return TokenStream(self.wrap(stream, name, filename), name, filename)

    def wrap(self, stream, name=None, filename=None):
        """"""This is called with the stream as returned by `tokenize` and wraps
        every token in a :class:`Token` and converts the value.
        """"""
        for lineno, token, value in stream:
            if token in ignored_tokens:
                continue
            elif token == 'linestatement_begin':
                token = 'block_begin'
            elif token == 'linestatement_end':
                token = 'block_end'
            # we are not interested in those tokens in the parser
            elif token in ('raw_begin', 'raw_end'):
                continue
            elif token == 'data':
                value = self._normalize_newlines(value)
            elif token == 'keyword':
                token = value
            elif token == 'name':
                value = str(value)
                if check_ident and not value.isidentifier():
                    raise TemplateSyntaxError(
                        'Invalid character in identifier',
                        lineno, name, filename)
            elif token == 'string':
                # try to unescape string
                try:
                    value = self._normalize_newlines(value[1:-1]) \
                        .encode('ascii', 'backslashreplace') \
                        .decode('unicode-escape')
                except Exception as e:
                    msg = str(e).split(':')[-1].strip()
                    raise TemplateSyntaxError(msg, lineno, name, filename)
            elif token == 'integer':
                value = int(value)
            elif token == 'float':
                value = float(value)
            elif token == 'operator':
                token = operators[value]
            yield Token(lineno, token, value)

    def tokeniter(self, source, name, filename=None, state=None):
        """"""This method tokenizes the text and returns the tokens in a
        generator.  Use this method if you just want to tokenize a template.
        """"""
        source = text_type(source)
        lines = source.splitlines()
        if self.keep_trailing_newline and source:
            for newline in ('\r\n', '\r', '\n'):
                if source.endswith(newline):
                    lines.append('')
                    break
        source = '\n'.join(lines)
        pos = 0
        lineno = 1
        stack = ['root']
        if state is not None and state != 'root':
            stack.append(state + '_begin')
        else:
            state = 'root'
        statetokens = self.rules[stack[-1]]
        source_length = len(source)

        balancing_stack = []

        while 1:
            # tokenizer loop
            for regex, tokens, new_state in statetokens:
                m = regex.match(source, pos)
                # if no match we try again with the next rule
                if m is None:
                    continue

                # we only match blocks and variables if braces / parentheses
                # are balanced. continue parsing with the lower rule which
                # is the operator rule. do this only if the end tags look
                # like operators
                if balancing_stack and \
                   tokens in ('variable_end', 'block_end',
                              'linestatement_end'):
                    continue

                # tuples support more options
                if isinstance(tokens, tuple):
                    for idx, token in enumerate(tokens):
                        # failure group
                        if token.__class__ is Failure:
                            raise token(lineno, filename)
                        # bygroup is a bit more complex, in that case we
                        # yield for the current token the first named
                        # group that matched
                        elif token == '#bygroup':
                            for key, value in iteritems(m.groupdict()):
                                if value is not None:
                                    yield lineno, key, value
                                    lineno += value.count('\n')
                                    break
                            else:
                                raise RuntimeError('%r wanted to resolve '
                                                   'the token dynamically'
                                                   ' but no group matched'
                                                   % regex)
                        # normal group
                        else:
                            data = m.group(idx + 1)
                            if data or token not in ignore_if_empty:
                                yield lineno, token, data
                            lineno += data.count('\n')

                # strings as token just are yielded as it.
                else:
                    data = m.group()
                    # update brace/parentheses balance
                    if tokens == 'operator':
                        if data == '{':
                            balancing_stack.append('}')
                        elif data == '(':
                            balancing_stack.append(')')
                        elif data == '[':
                            balancing_stack.append(']')
                        elif data in ('}', ')', ']'):
                            if not balancing_stack:
                                raise TemplateSyntaxError('unexpected \'%s\'' %
                                                          data, lineno, name,
                                                          filename)
                            expected_op = balancing_stack.pop()
                            if expected_op != data:
                                raise TemplateSyntaxError('unexpected \'%s\', '
                                                          'expected \'%s\'' %
                                                          (data, expected_op),
                                                          lineno, name,
                                                          filename)
                    # yield items
                    if data or tokens not in ignore_if_empty:
                        yield lineno, tokens, data
                    lineno += data.count('\n')

                # fetch new position into new variable so that we can check
                # if there is a internal parsing error which would result
                # in an infinite loop
                pos2 = m.end()

                # handle state changes
                if new_state is not None:
                    # remove the uppermost state
                    if new_state == '#pop':
                        stack.pop()
                    # resolve the new state by group checking
                    elif new_state == '#bygroup':
                        for key, value in iteritems(m.groupdict()):
                            if value is not None:
                                stack.append(key)
                                break
                        else:
                            raise RuntimeError('%r wanted to resolve the '
                                               'new state dynamically but'
                                               ' no group matched' %
                                               regex)
                    # direct state name given
                    else:
                        stack.append(new_state)
                    statetokens = self.rules[stack[-1]]
                # we are still at the same position and no stack change.
                # this means a loop without break condition, avoid that and
                # raise error
                elif pos2 == pos:
                    raise RuntimeError('%r yielded empty string without '
                                       'stack change' % regex)
                # publish new function and start again
                pos = pos2
                break
            # if loop terminated without break we haven't found a single match
            # either we are at the end of the file or we have a problem
            else:
                # end of text
                if pos >= source_length:
                    return
                # something went wrong
                raise TemplateSyntaxError('unexpected char %r at %d' %
                                          (source[pos], pos), lineno,
                                          name, filename)
"
feroda/lessons-python4beginners,"import pytest

import fibonacci
import custom_exception

def test_fibonacci():
	print(""Test Fibonacci 1 started"")
	
	array = fibonacci.run(0, 5)
	
	assert array[0] == 0
	assert array[1] == 1
	assert array[2] == 1
	assert array[3] == 2
	assert array[4] == 3
	assert array[5] == 5
	
def test_exception_when_start_is_negative():
	print(""Test Fibonacci exception fired when start number is minor than zero"")
	
	with pytest.raises(custom_exception.NegativeNumberException):
		fibonacci.run(-1, 5)
		
def test_input_start_must_be_number():
	with pytest.raises(TypeError):
		fibonacci.run(""ciao"", 5)
		
def test_input_end_must_be_number():
	with pytest.raises(TypeError):
		fibonacci.run(0, ""Ciao"")
		
		
def test_start_cannot_be_more_than_end():
	with pytest.raises(custom_exception.InvalidNumberProvidedException):
		fibonacci.run(7,5)","[['array[0]', '==', '0'], ['array[1]', '==', '1'], ['array[2]', '==', '1'], ['array[3]', '==', '2'], ['array[4]', '==', '3'], ['array[5]', '==', '5']]",['array'],"import pytest

import fibonacci
import custom_exception

def test_fibonacci():
	print(""Test Fibonacci 1 started"")
	
	array = fibonacci.run(0, 5)
	
	
def test_exception_when_start_is_negative():
	print(""Test Fibonacci exception fired when start number is minor than zero"")
	
	with pytest.raises(custom_exception.NegativeNumberException):
		fibonacci.run(-1, 5)
		
def test_input_start_must_be_number():
	with pytest.raises(TypeError):
		fibonacci.run(""ciao"", 5)
		
def test_input_end_must_be_number():
	with pytest.raises(TypeError):
		fibonacci.run(0, ""Ciao"")
		
		
def test_start_cannot_be_more_than_end():
	with pytest.raises(custom_exception.InvalidNumberProvidedException):
		fibonacci.run(7,5)"
dpmatthews/cylc,"# -*- coding: utf-8 -*-
""""""
    jinja2.lexer
    ~~~~~~~~~~~~

    This module implements a Jinja / Python combination lexer. The
    `Lexer` class provided by this module is used to do some preprocessing
    for Jinja.

    On the one hand it filters out invalid operators like the bitshift
    operators we don't allow in templates. On the other hand it separates
    template code and python code in expressions.

    :copyright: (c) 2017 by the Jinja Team.
    :license: BSD, see LICENSE for more details.
""""""
import re
from collections import deque
from operator import itemgetter

from jinja2._compat import implements_iterator, intern, iteritems, text_type
from jinja2.exceptions import TemplateSyntaxError
from jinja2.utils import LRUCache

# cache for the lexers. Exists in order to be able to have multiple
# environments with the same lexer
_lexer_cache = LRUCache(50)

# static regular expressions
whitespace_re = re.compile(r'\s+', re.U)
string_re = re.compile(r""('([^'\\]*(?:\\.[^'\\]*)*)'""
                       r'|""([^""\\]*(?:\\.[^""\\]*)*)"")', re.S)
integer_re = re.compile(r'\d+')

try:
    # check if this Python supports Unicode identifiers
    compile('föö', '<unknown>', 'eval')
except SyntaxError:
    # no Unicode support, use ASCII identifiers
    name_re = re.compile(r'[a-zA-Z_][a-zA-Z0-9_]*')
    check_ident = False
else:
    # Unicode support, build a pattern to match valid characters, and set flag
    # to use str.isidentifier to validate during lexing
    from jinja2 import _identifier
    name_re = re.compile(r'[\w{0}]+'.format(_identifier.pattern))
    check_ident = True
    # remove the pattern from memory after building the regex
    import sys
    del sys.modules['jinja2._identifier']
    import jinja2
    del jinja2._identifier
    del _identifier

float_re = re.compile(r'(?<!\.)\d+\.\d+')
newline_re = re.compile(r'(\r\n|\r|\n)')

# internal the tokens and keep references to them
TOKEN_ADD = intern('add')
TOKEN_ASSIGN = intern('assign')
TOKEN_COLON = intern('colon')
TOKEN_COMMA = intern('comma')
TOKEN_DIV = intern('div')
TOKEN_DOT = intern('dot')
TOKEN_EQ = intern('eq')
TOKEN_FLOORDIV = intern('floordiv')
TOKEN_GT = intern('gt')
TOKEN_GTEQ = intern('gteq')
TOKEN_LBRACE = intern('lbrace')
TOKEN_LBRACKET = intern('lbracket')
TOKEN_LPAREN = intern('lparen')
TOKEN_LT = intern('lt')
TOKEN_LTEQ = intern('lteq')
TOKEN_MOD = intern('mod')
TOKEN_MUL = intern('mul')
TOKEN_NE = intern('ne')
TOKEN_PIPE = intern('pipe')
TOKEN_POW = intern('pow')
TOKEN_RBRACE = intern('rbrace')
TOKEN_RBRACKET = intern('rbracket')
TOKEN_RPAREN = intern('rparen')
TOKEN_SEMICOLON = intern('semicolon')
TOKEN_SUB = intern('sub')
TOKEN_TILDE = intern('tilde')
TOKEN_WHITESPACE = intern('whitespace')
TOKEN_FLOAT = intern('float')
TOKEN_INTEGER = intern('integer')
TOKEN_NAME = intern('name')
TOKEN_STRING = intern('string')
TOKEN_OPERATOR = intern('operator')
TOKEN_BLOCK_BEGIN = intern('block_begin')
TOKEN_BLOCK_END = intern('block_end')
TOKEN_VARIABLE_BEGIN = intern('variable_begin')
TOKEN_VARIABLE_END = intern('variable_end')
TOKEN_RAW_BEGIN = intern('raw_begin')
TOKEN_RAW_END = intern('raw_end')
TOKEN_COMMENT_BEGIN = intern('comment_begin')
TOKEN_COMMENT_END = intern('comment_end')
TOKEN_COMMENT = intern('comment')
TOKEN_LINESTATEMENT_BEGIN = intern('linestatement_begin')
TOKEN_LINESTATEMENT_END = intern('linestatement_end')
TOKEN_LINECOMMENT_BEGIN = intern('linecomment_begin')
TOKEN_LINECOMMENT_END = intern('linecomment_end')
TOKEN_LINECOMMENT = intern('linecomment')
TOKEN_DATA = intern('data')
TOKEN_INITIAL = intern('initial')
TOKEN_EOF = intern('eof')

# bind operators to token types
operators = {
    '+':            TOKEN_ADD,
    '-':            TOKEN_SUB,
    '/':            TOKEN_DIV,
    '//':           TOKEN_FLOORDIV,
    '*':            TOKEN_MUL,
    '%':            TOKEN_MOD,
    '**':           TOKEN_POW,
    '~':            TOKEN_TILDE,
    '[':            TOKEN_LBRACKET,
    ']':            TOKEN_RBRACKET,
    '(':            TOKEN_LPAREN,
    ')':            TOKEN_RPAREN,
    '{':            TOKEN_LBRACE,
    '}':            TOKEN_RBRACE,
    '==':           TOKEN_EQ,
    '!=':           TOKEN_NE,
    '>':            TOKEN_GT,
    '>=':           TOKEN_GTEQ,
    '<':            TOKEN_LT,
    '<=':           TOKEN_LTEQ,
    '=':            TOKEN_ASSIGN,
    '.':            TOKEN_DOT,
    ':':            TOKEN_COLON,
    '|':            TOKEN_PIPE,
    ',':            TOKEN_COMMA,
    ';':            TOKEN_SEMICOLON
}

reverse_operators = dict([(v, k) for k, v in iteritems(operators)])
assert len(operators) == len(reverse_operators), 'operators dropped'
operator_re = re.compile('(%s)' % '|'.join(re.escape(x) for x in
                         sorted(operators, key=lambda x: -len(x))))

ignored_tokens = frozenset([TOKEN_COMMENT_BEGIN, TOKEN_COMMENT,
                            TOKEN_COMMENT_END, TOKEN_WHITESPACE,
                            TOKEN_LINECOMMENT_BEGIN, TOKEN_LINECOMMENT_END,
                            TOKEN_LINECOMMENT])
ignore_if_empty = frozenset([TOKEN_WHITESPACE, TOKEN_DATA,
                             TOKEN_COMMENT, TOKEN_LINECOMMENT])


def _describe_token_type(token_type):
    if token_type in reverse_operators:
        return reverse_operators[token_type]
    return {
        TOKEN_COMMENT_BEGIN:        'begin of comment',
        TOKEN_COMMENT_END:          'end of comment',
        TOKEN_COMMENT:              'comment',
        TOKEN_LINECOMMENT:          'comment',
        TOKEN_BLOCK_BEGIN:          'begin of statement block',
        TOKEN_BLOCK_END:            'end of statement block',
        TOKEN_VARIABLE_BEGIN:       'begin of print statement',
        TOKEN_VARIABLE_END:         'end of print statement',
        TOKEN_LINESTATEMENT_BEGIN:  'begin of line statement',
        TOKEN_LINESTATEMENT_END:    'end of line statement',
        TOKEN_DATA:                 'template data / text',
        TOKEN_EOF:                  'end of template'
    }.get(token_type, token_type)


def describe_token(token):
    """"""Returns a description of the token.""""""
    if token.type == 'name':
        return token.value
    return _describe_token_type(token.type)


def describe_token_expr(expr):
    """"""Like `describe_token` but for token expressions.""""""
    if ':' in expr:
        type, value = expr.split(':', 1)
        if type == 'name':
            return value
    else:
        type = expr
    return _describe_token_type(type)


def count_newlines(value):
    """"""Count the number of newline characters in the string.  This is
    useful for extensions that filter a stream.
    """"""
    return len(newline_re.findall(value))


def compile_rules(environment):
    """"""Compiles all the rules from the environment into a list of rules.""""""
    e = re.escape
    rules = [
        (len(environment.comment_start_string), 'comment',
         e(environment.comment_start_string)),
        (len(environment.block_start_string), 'block',
         e(environment.block_start_string)),
        (len(environment.variable_start_string), 'variable',
         e(environment.variable_start_string))
    ]

    if environment.line_statement_prefix is not None:
        rules.append((len(environment.line_statement_prefix), 'linestatement',
                      r'^[ \t\v]*' + e(environment.line_statement_prefix)))
    if environment.line_comment_prefix is not None:
        rules.append((len(environment.line_comment_prefix), 'linecomment',
                      r'(?:^|(?<=\S))[^\S\r\n]*' +
                      e(environment.line_comment_prefix)))

    return [x[1:] for x in sorted(rules, reverse=True)]


class Failure(object):
    """"""Class that raises a `TemplateSyntaxError` if called.
    Used by the `Lexer` to specify known errors.
    """"""

    def __init__(self, message, cls=TemplateSyntaxError):
        self.message = message
        self.error_class = cls

    def __call__(self, lineno, filename):
        raise self.error_class(self.message, lineno, filename)


class Token(tuple):
    """"""Token class.""""""
    __slots__ = ()
    lineno, type, value = (property(itemgetter(x)) for x in range(3))

    def __new__(cls, lineno, type, value):
        return tuple.__new__(cls, (lineno, intern(str(type)), value))

    def __str__(self):
        if self.type in reverse_operators:
            return reverse_operators[self.type]
        elif self.type == 'name':
            return self.value
        return self.type

    def test(self, expr):
        """"""Test a token against a token expression.  This can either be a
        token type or ``'token_type:token_value'``.  This can only test
        against string values and types.
        """"""
        # here we do a regular string equality check as test_any is usually
        # passed an iterable of not interned strings.
        if self.type == expr:
            return True
        elif ':' in expr:
            return expr.split(':', 1) == [self.type, self.value]
        return False

    def test_any(self, *iterable):
        """"""Test against multiple token expressions.""""""
        for expr in iterable:
            if self.test(expr):
                return True
        return False

    def __repr__(self):
        return 'Token(%r, %r, %r)' % (
            self.lineno,
            self.type,
            self.value
        )


@implements_iterator
class TokenStreamIterator(object):
    """"""The iterator for tokenstreams.  Iterate over the stream
    until the eof token is reached.
    """"""

    def __init__(self, stream):
        self.stream = stream

    def __iter__(self):
        return self

    def __next__(self):
        token = self.stream.current
        if token.type is TOKEN_EOF:
            self.stream.close()
            raise StopIteration()
        next(self.stream)
        return token


@implements_iterator
class TokenStream(object):
    """"""A token stream is an iterable that yields :class:`Token`\\s.  The
    parser however does not iterate over it but calls :meth:`next` to go
    one token ahead.  The current active token is stored as :attr:`current`.
    """"""

    def __init__(self, generator, name, filename):
        self._iter = iter(generator)
        self._pushed = deque()
        self.name = name
        self.filename = filename
        self.closed = False
        self.current = Token(1, TOKEN_INITIAL, '')
        next(self)

    def __iter__(self):
        return TokenStreamIterator(self)

    def __bool__(self):
        return bool(self._pushed) or self.current.type is not TOKEN_EOF
    __nonzero__ = __bool__  # py2

    eos = property(lambda x: not x, doc=""Are we at the end of the stream?"")

    def push(self, token):
        """"""Push a token back to the stream.""""""
        self._pushed.append(token)

    def look(self):
        """"""Look at the next token.""""""
        old_token = next(self)
        result = self.current
        self.push(result)
        self.current = old_token
        return result

    def skip(self, n=1):
        """"""Got n tokens ahead.""""""
        for x in range(n):
            next(self)

    def next_if(self, expr):
        """"""Perform the token test and return the token if it matched.
        Otherwise the return value is `None`.
        """"""
        if self.current.test(expr):
            return next(self)

    def skip_if(self, expr):
        """"""Like :meth:`next_if` but only returns `True` or `False`.""""""
        return self.next_if(expr) is not None

    def __next__(self):
        """"""Go one token ahead and return the old one.

        Use the built-in :func:`next` instead of calling this directly.
        """"""
        rv = self.current
        if self._pushed:
            self.current = self._pushed.popleft()
        elif self.current.type is not TOKEN_EOF:
            try:
                self.current = next(self._iter)
            except StopIteration:
                self.close()
        return rv

    def close(self):
        """"""Close the stream.""""""
        self.current = Token(self.current.lineno, TOKEN_EOF, '')
        self._iter = None
        self.closed = True

    def expect(self, expr):
        """"""Expect a given token type and return it.  This accepts the same
        argument as :meth:`jinja2.lexer.Token.test`.
        """"""
        if not self.current.test(expr):
            expr = describe_token_expr(expr)
            if self.current.type is TOKEN_EOF:
                raise TemplateSyntaxError('unexpected end of template, '
                                          'expected %r.' % expr,
                                          self.current.lineno,
                                          self.name, self.filename)
            raise TemplateSyntaxError(""expected token %r, got %r"" %
                                      (expr, describe_token(self.current)),
                                      self.current.lineno,
                                      self.name, self.filename)
        try:
            return self.current
        finally:
            next(self)


def get_lexer(environment):
    """"""Return a lexer which is probably cached.""""""
    key = (environment.block_start_string,
           environment.block_end_string,
           environment.variable_start_string,
           environment.variable_end_string,
           environment.comment_start_string,
           environment.comment_end_string,
           environment.line_statement_prefix,
           environment.line_comment_prefix,
           environment.trim_blocks,
           environment.lstrip_blocks,
           environment.newline_sequence,
           environment.keep_trailing_newline)
    lexer = _lexer_cache.get(key)
    if lexer is None:
        lexer = Lexer(environment)
        _lexer_cache[key] = lexer
    return lexer


class Lexer(object):
    """"""Class that implements a lexer for a given environment. Automatically
    created by the environment class, usually you don't have to do that.

    Note that the lexer is not automatically bound to an environment.
    Multiple environments can share the same lexer.
    """"""

    def __init__(self, environment):
        # shortcuts
        c = lambda x: re.compile(x, re.M | re.S)
        e = re.escape

        # lexing rules for tags
        tag_rules = [
            (whitespace_re, TOKEN_WHITESPACE, None),
            (float_re, TOKEN_FLOAT, None),
            (integer_re, TOKEN_INTEGER, None),
            (name_re, TOKEN_NAME, None),
            (string_re, TOKEN_STRING, None),
            (operator_re, TOKEN_OPERATOR, None)
        ]

        # assemble the root lexing rule. because ""|"" is ungreedy
        # we have to sort by length so that the lexer continues working
        # as expected when we have parsing rules like <% for block and
        # <%= for variables. (if someone wants asp like syntax)
        # variables are just part of the rules if variable processing
        # is required.
        root_tag_rules = compile_rules(environment)

        # block suffix if trimming is enabled
        block_suffix_re = environment.trim_blocks and '\\n?' or ''

        # strip leading spaces if lstrip_blocks is enabled
        prefix_re = {}
        if environment.lstrip_blocks:
            # use '{%+' to manually disable lstrip_blocks behavior
            no_lstrip_re = e('+')
            # detect overlap between block and variable or comment strings
            block_diff = c(r'^%s(.*)' % e(environment.block_start_string))
            # make sure we don't mistake a block for a variable or a comment
            m = block_diff.match(environment.comment_start_string)
            no_lstrip_re += m and r'|%s' % e(m.group(1)) or ''
            m = block_diff.match(environment.variable_start_string)
            no_lstrip_re += m and r'|%s' % e(m.group(1)) or ''

            # detect overlap between comment and variable strings
            comment_diff = c(r'^%s(.*)' % e(environment.comment_start_string))
            m = comment_diff.match(environment.variable_start_string)
            no_variable_re = m and r'(?!%s)' % e(m.group(1)) or ''

            lstrip_re = r'^[ \t]*'
            block_prefix_re = r'%s%s(?!%s)|%s\+?' % (
                    lstrip_re,
                    e(environment.block_start_string),
                    no_lstrip_re,
                    e(environment.block_start_string),
                    )
            comment_prefix_re = r'%s%s%s|%s\+?' % (
                    lstrip_re,
                    e(environment.comment_start_string),
                    no_variable_re,
                    e(environment.comment_start_string),
                    )
            prefix_re['block'] = block_prefix_re
            prefix_re['comment'] = comment_prefix_re
        else:
            block_prefix_re = '%s' % e(environment.block_start_string)

        self.newline_sequence = environment.newline_sequence
        self.keep_trailing_newline = environment.keep_trailing_newline

        # global lexing rules
        self.rules = {
            'root': [
                # directives
                (c('(.*?)(?:%s)' % '|'.join(
                    [r'(?P<raw_begin>(?:\s*%s\-|%s)\s*raw\s*(?:\-%s\s*|%s))' % (
                        e(environment.block_start_string),
                        block_prefix_re,
                        e(environment.block_end_string),
                        e(environment.block_end_string)
                    )] + [
                        r'(?P<%s_begin>\s*%s\-|%s)' % (n, r, prefix_re.get(n,r))
                        for n, r in root_tag_rules
                    ])), (TOKEN_DATA, '#bygroup'), '#bygroup'),
                # data
                (c('.+'), TOKEN_DATA, None)
            ],
            # comments
            TOKEN_COMMENT_BEGIN: [
                (c(r'(.*?)((?:\-%s\s*|%s)%s)' % (
                    e(environment.comment_end_string),
                    e(environment.comment_end_string),
                    block_suffix_re
                )), (TOKEN_COMMENT, TOKEN_COMMENT_END), '#pop'),
                (c('(.)'), (Failure('Missing end of comment tag'),), None)
            ],
            # blocks
            TOKEN_BLOCK_BEGIN: [
                (c(r'(?:\-%s\s*|%s)%s' % (
                    e(environment.block_end_string),
                    e(environment.block_end_string),
                    block_suffix_re
                )), TOKEN_BLOCK_END, '#pop'),
            ] + tag_rules,
            # variables
            TOKEN_VARIABLE_BEGIN: [
                (c(r'\-%s\s*|%s' % (
                    e(environment.variable_end_string),
                    e(environment.variable_end_string)
                )), TOKEN_VARIABLE_END, '#pop')
            ] + tag_rules,
            # raw block
            TOKEN_RAW_BEGIN: [
                (c(r'(.*?)((?:\s*%s\-|%s)\s*endraw\s*(?:\-%s\s*|%s%s))' % (
                    e(environment.block_start_string),
                    block_prefix_re,
                    e(environment.block_end_string),
                    e(environment.block_end_string),
                    block_suffix_re
                )), (TOKEN_DATA, TOKEN_RAW_END), '#pop'),
                (c('(.)'), (Failure('Missing end of raw directive'),), None)
            ],
            # line statements
            TOKEN_LINESTATEMENT_BEGIN: [
                (c(r'\s*(\n|$)'), TOKEN_LINESTATEMENT_END, '#pop')
            ] + tag_rules,
            # line comments
            TOKEN_LINECOMMENT_BEGIN: [
                (c(r'(.*?)()(?=\n|$)'), (TOKEN_LINECOMMENT,
                 TOKEN_LINECOMMENT_END), '#pop')
            ]
        }

    def _normalize_newlines(self, value):
        """"""Called for strings and template data to normalize it to unicode.""""""
        return newline_re.sub(self.newline_sequence, value)

    def tokenize(self, source, name=None, filename=None, state=None):
        """"""Calls tokeniter + tokenize and wraps it in a token stream.
        """"""
        stream = self.tokeniter(source, name, filename, state)
        return TokenStream(self.wrap(stream, name, filename), name, filename)

    def wrap(self, stream, name=None, filename=None):
        """"""This is called with the stream as returned by `tokenize` and wraps
        every token in a :class:`Token` and converts the value.
        """"""
        for lineno, token, value in stream:
            if token in ignored_tokens:
                continue
            elif token == 'linestatement_begin':
                token = 'block_begin'
            elif token == 'linestatement_end':
                token = 'block_end'
            # we are not interested in those tokens in the parser
            elif token in ('raw_begin', 'raw_end'):
                continue
            elif token == 'data':
                value = self._normalize_newlines(value)
            elif token == 'keyword':
                token = value
            elif token == 'name':
                value = str(value)
                if check_ident and not value.isidentifier():
                    raise TemplateSyntaxError(
                        'Invalid character in identifier',
                        lineno, name, filename)
            elif token == 'string':
                # try to unescape string
                try:
                    value = self._normalize_newlines(value[1:-1]) \
                        .encode('ascii', 'backslashreplace') \
                        .decode('unicode-escape')
                except Exception as e:
                    msg = str(e).split(':')[-1].strip()
                    raise TemplateSyntaxError(msg, lineno, name, filename)
            elif token == 'integer':
                value = int(value)
            elif token == 'float':
                value = float(value)
            elif token == 'operator':
                token = operators[value]
            yield Token(lineno, token, value)

    def tokeniter(self, source, name, filename=None, state=None):
        """"""This method tokenizes the text and returns the tokens in a
        generator.  Use this method if you just want to tokenize a template.
        """"""
        source = text_type(source)
        lines = source.splitlines()
        if self.keep_trailing_newline and source:
            for newline in ('\r\n', '\r', '\n'):
                if source.endswith(newline):
                    lines.append('')
                    break
        source = '\n'.join(lines)
        pos = 0
        lineno = 1
        stack = ['root']
        if state is not None and state != 'root':
            assert state in ('variable', 'block'), 'invalid state'
            stack.append(state + '_begin')
        else:
            state = 'root'
        statetokens = self.rules[stack[-1]]
        source_length = len(source)

        balancing_stack = []

        while 1:
            # tokenizer loop
            for regex, tokens, new_state in statetokens:
                m = regex.match(source, pos)
                # if no match we try again with the next rule
                if m is None:
                    continue

                # we only match blocks and variables if braces / parentheses
                # are balanced. continue parsing with the lower rule which
                # is the operator rule. do this only if the end tags look
                # like operators
                if balancing_stack and \
                   tokens in ('variable_end', 'block_end',
                              'linestatement_end'):
                    continue

                # tuples support more options
                if isinstance(tokens, tuple):
                    for idx, token in enumerate(tokens):
                        # failure group
                        if token.__class__ is Failure:
                            raise token(lineno, filename)
                        # bygroup is a bit more complex, in that case we
                        # yield for the current token the first named
                        # group that matched
                        elif token == '#bygroup':
                            for key, value in iteritems(m.groupdict()):
                                if value is not None:
                                    yield lineno, key, value
                                    lineno += value.count('\n')
                                    break
                            else:
                                raise RuntimeError('%r wanted to resolve '
                                                   'the token dynamically'
                                                   ' but no group matched'
                                                   % regex)
                        # normal group
                        else:
                            data = m.group(idx + 1)
                            if data or token not in ignore_if_empty:
                                yield lineno, token, data
                            lineno += data.count('\n')

                # strings as token just are yielded as it.
                else:
                    data = m.group()
                    # update brace/parentheses balance
                    if tokens == 'operator':
                        if data == '{':
                            balancing_stack.append('}')
                        elif data == '(':
                            balancing_stack.append(')')
                        elif data == '[':
                            balancing_stack.append(']')
                        elif data in ('}', ')', ']'):
                            if not balancing_stack:
                                raise TemplateSyntaxError('unexpected \'%s\'' %
                                                          data, lineno, name,
                                                          filename)
                            expected_op = balancing_stack.pop()
                            if expected_op != data:
                                raise TemplateSyntaxError('unexpected \'%s\', '
                                                          'expected \'%s\'' %
                                                          (data, expected_op),
                                                          lineno, name,
                                                          filename)
                    # yield items
                    if data or tokens not in ignore_if_empty:
                        yield lineno, tokens, data
                    lineno += data.count('\n')

                # fetch new position into new variable so that we can check
                # if there is a internal parsing error which would result
                # in an infinite loop
                pos2 = m.end()

                # handle state changes
                if new_state is not None:
                    # remove the uppermost state
                    if new_state == '#pop':
                        stack.pop()
                    # resolve the new state by group checking
                    elif new_state == '#bygroup':
                        for key, value in iteritems(m.groupdict()):
                            if value is not None:
                                stack.append(key)
                                break
                        else:
                            raise RuntimeError('%r wanted to resolve the '
                                               'new state dynamically but'
                                               ' no group matched' %
                                               regex)
                    # direct state name given
                    else:
                        stack.append(new_state)
                    statetokens = self.rules[stack[-1]]
                # we are still at the same position and no stack change.
                # this means a loop without break condition, avoid that and
                # raise error
                elif pos2 == pos:
                    raise RuntimeError('%r yielded empty string without '
                                       'stack change' % regex)
                # publish new function and start again
                pos = pos2
                break
            # if loop terminated without break we haven't found a single match
            # either we are at the end of the file or we have a problem
            else:
                # end of text
                if pos >= source_length:
                    return
                # something went wrong
                raise TemplateSyntaxError('unexpected char %r at %d' %
                                          (source[pos], pos), lineno,
                                          name, filename)
","[['len(operat', '==', 'True'], ['s)', '==', 'len(reverse_operat'], ['s)', '==', 'True'], ['state', 'in', ""('variable'""]]","['_lexer_cache', 'whitespace_re', 'string_re', 'integer_re', 'name_re', 'check_ident', 'float_re', 'newline_re', 'TOKEN_ADD', 'TOKEN_ASSIGN', 'TOKEN_COLON', 'TOKEN_COMMA', 'TOKEN_DIV', 'TOKEN_DOT', 'TOKEN_EQ', 'TOKEN_FLOORDIV', 'TOKEN_GT', 'TOKEN_GTEQ', 'TOKEN_LBRACE', 'TOKEN_LBRACKET', 'TOKEN_LPAREN', 'TOKEN_LT', 'TOKEN_LTEQ', 'TOKEN_MOD', 'TOKEN_MUL', 'TOKEN_NE', 'TOKEN_PIPE', 'TOKEN_POW', 'TOKEN_RBRACE', 'TOKEN_RBRACKET', 'TOKEN_RPAREN', 'TOKEN_SEMICOLON', 'TOKEN_SUB', 'TOKEN_TILDE', 'TOKEN_WHITESPACE', 'TOKEN_FLOAT', 'TOKEN_INTEGER', 'TOKEN_NAME', 'TOKEN_STRING', 'TOKEN_OPERATOR', 'TOKEN_BLOCK_BEGIN', 'TOKEN_BLOCK_END', 'TOKEN_VARIABLE_BEGIN', 'TOKEN_VARIABLE_END', 'TOKEN_RAW_BEGIN', 'TOKEN_RAW_END', 'TOKEN_COMMENT_BEGIN', 'TOKEN_COMMENT_END', 'TOKEN_COMMENT', 'TOKEN_LINESTATEMENT_BEGIN', 'TOKEN_LINESTATEMENT_END', 'TOKEN_LINECOMMENT_BEGIN', 'TOKEN_LINECOMMENT_END', 'TOKEN_LINECOMMENT', 'TOKEN_DATA', 'TOKEN_INITIAL', 'TOKEN_EOF', 'operators', 'reverse_operators', 'operator_re', 'ignored_tokens', 'ignore_if_empty', 'token_type', 'token', 'expr', 'type', 'value', 'environment', 'e', 'rules', 'message', 'cls', 'self.message', 'self.error_class', 'lineno', 'filename', '__slots__', '*iterable', 'stream', 'self.stream', 'generator', 'name', 'self._iter', 'self._pushed', 'self.name', 'self.filename', 'self.closed', 'self.current', '__nonzero__', 'eos', 'old_token', 'result', 'n', 'rv', 'key', 'lexer', '_lexer_cache[key]', 'c', 'tag_rules', 'root_tag_rules', 'block_suffix_re', 'prefix_re', 'no_lstrip_re', 'block_diff', 'm', 'comment_diff', 'no_variable_re', 'lstrip_re', 'block_prefix_re', 'comment_prefix_re', ""prefix_re['block']"", ""prefix_re['comment']"", 'self.newline_sequence', 'self.keep_trailing_newline', 'self.rules', 'source', 'state', 'msg', 'lines', 'pos', 'stack', 'statetokens', 'source_length', 'balancing_stack', 'data', 'expected_op', 'pos2']","# -*- coding: utf-8 -*-
""""""
    jinja2.lexer
    ~~~~~~~~~~~~

    This module implements a Jinja / Python combination lexer. The
    `Lexer` class provided by this module is used to do some preprocessing
    for Jinja.

    On the one hand it filters out invalid operators like the bitshift
    operators we don't allow in templates. On the other hand it separates
    template code and python code in expressions.

    :copyright: (c) 2017 by the Jinja Team.
    :license: BSD, see LICENSE for more details.
""""""
import re
from collections import deque
from operator import itemgetter

from jinja2._compat import implements_iterator, intern, iteritems, text_type
from jinja2.exceptions import TemplateSyntaxError
from jinja2.utils import LRUCache

# cache for the lexers. Exists in order to be able to have multiple
# environments with the same lexer
_lexer_cache = LRUCache(50)

# static regular expressions
whitespace_re = re.compile(r'\s+', re.U)
string_re = re.compile(r""('([^'\\]*(?:\\.[^'\\]*)*)'""
                       r'|""([^""\\]*(?:\\.[^""\\]*)*)"")', re.S)
integer_re = re.compile(r'\d+')

try:
    # check if this Python supports Unicode identifiers
    compile('föö', '<unknown>', 'eval')
except SyntaxError:
    # no Unicode support, use ASCII identifiers
    name_re = re.compile(r'[a-zA-Z_][a-zA-Z0-9_]*')
    check_ident = False
else:
    # Unicode support, build a pattern to match valid characters, and set flag
    # to use str.isidentifier to validate during lexing
    from jinja2 import _identifier
    name_re = re.compile(r'[\w{0}]+'.format(_identifier.pattern))
    check_ident = True
    # remove the pattern from memory after building the regex
    import sys
    del sys.modules['jinja2._identifier']
    import jinja2
    del jinja2._identifier
    del _identifier

float_re = re.compile(r'(?<!\.)\d+\.\d+')
newline_re = re.compile(r'(\r\n|\r|\n)')

# internal the tokens and keep references to them
TOKEN_ADD = intern('add')
TOKEN_ASSIGN = intern('assign')
TOKEN_COLON = intern('colon')
TOKEN_COMMA = intern('comma')
TOKEN_DIV = intern('div')
TOKEN_DOT = intern('dot')
TOKEN_EQ = intern('eq')
TOKEN_FLOORDIV = intern('floordiv')
TOKEN_GT = intern('gt')
TOKEN_GTEQ = intern('gteq')
TOKEN_LBRACE = intern('lbrace')
TOKEN_LBRACKET = intern('lbracket')
TOKEN_LPAREN = intern('lparen')
TOKEN_LT = intern('lt')
TOKEN_LTEQ = intern('lteq')
TOKEN_MOD = intern('mod')
TOKEN_MUL = intern('mul')
TOKEN_NE = intern('ne')
TOKEN_PIPE = intern('pipe')
TOKEN_POW = intern('pow')
TOKEN_RBRACE = intern('rbrace')
TOKEN_RBRACKET = intern('rbracket')
TOKEN_RPAREN = intern('rparen')
TOKEN_SEMICOLON = intern('semicolon')
TOKEN_SUB = intern('sub')
TOKEN_TILDE = intern('tilde')
TOKEN_WHITESPACE = intern('whitespace')
TOKEN_FLOAT = intern('float')
TOKEN_INTEGER = intern('integer')
TOKEN_NAME = intern('name')
TOKEN_STRING = intern('string')
TOKEN_OPERATOR = intern('operator')
TOKEN_BLOCK_BEGIN = intern('block_begin')
TOKEN_BLOCK_END = intern('block_end')
TOKEN_VARIABLE_BEGIN = intern('variable_begin')
TOKEN_VARIABLE_END = intern('variable_end')
TOKEN_RAW_BEGIN = intern('raw_begin')
TOKEN_RAW_END = intern('raw_end')
TOKEN_COMMENT_BEGIN = intern('comment_begin')
TOKEN_COMMENT_END = intern('comment_end')
TOKEN_COMMENT = intern('comment')
TOKEN_LINESTATEMENT_BEGIN = intern('linestatement_begin')
TOKEN_LINESTATEMENT_END = intern('linestatement_end')
TOKEN_LINECOMMENT_BEGIN = intern('linecomment_begin')
TOKEN_LINECOMMENT_END = intern('linecomment_end')
TOKEN_LINECOMMENT = intern('linecomment')
TOKEN_DATA = intern('data')
TOKEN_INITIAL = intern('initial')
TOKEN_EOF = intern('eof')

# bind operators to token types
operators = {
    '+':            TOKEN_ADD,
    '-':            TOKEN_SUB,
    '/':            TOKEN_DIV,
    '//':           TOKEN_FLOORDIV,
    '*':            TOKEN_MUL,
    '%':            TOKEN_MOD,
    '**':           TOKEN_POW,
    '~':            TOKEN_TILDE,
    '[':            TOKEN_LBRACKET,
    ']':            TOKEN_RBRACKET,
    '(':            TOKEN_LPAREN,
    ')':            TOKEN_RPAREN,
    '{':            TOKEN_LBRACE,
    '}':            TOKEN_RBRACE,
    '==':           TOKEN_EQ,
    '!=':           TOKEN_NE,
    '>':            TOKEN_GT,
    '>=':           TOKEN_GTEQ,
    '<':            TOKEN_LT,
    '<=':           TOKEN_LTEQ,
    '=':            TOKEN_ASSIGN,
    '.':            TOKEN_DOT,
    ':':            TOKEN_COLON,
    '|':            TOKEN_PIPE,
    ',':            TOKEN_COMMA,
    ';':            TOKEN_SEMICOLON
}

reverse_operators = dict([(v, k) for k, v in iteritems(operators)])
operator_re = re.compile('(%s)' % '|'.join(re.escape(x) for x in
                         sorted(operators, key=lambda x: -len(x))))

ignored_tokens = frozenset([TOKEN_COMMENT_BEGIN, TOKEN_COMMENT,
                            TOKEN_COMMENT_END, TOKEN_WHITESPACE,
                            TOKEN_LINECOMMENT_BEGIN, TOKEN_LINECOMMENT_END,
                            TOKEN_LINECOMMENT])
ignore_if_empty = frozenset([TOKEN_WHITESPACE, TOKEN_DATA,
                             TOKEN_COMMENT, TOKEN_LINECOMMENT])


def _describe_token_type(token_type):
    if token_type in reverse_operators:
        return reverse_operators[token_type]
    return {
        TOKEN_COMMENT_BEGIN:        'begin of comment',
        TOKEN_COMMENT_END:          'end of comment',
        TOKEN_COMMENT:              'comment',
        TOKEN_LINECOMMENT:          'comment',
        TOKEN_BLOCK_BEGIN:          'begin of statement block',
        TOKEN_BLOCK_END:            'end of statement block',
        TOKEN_VARIABLE_BEGIN:       'begin of print statement',
        TOKEN_VARIABLE_END:         'end of print statement',
        TOKEN_LINESTATEMENT_BEGIN:  'begin of line statement',
        TOKEN_LINESTATEMENT_END:    'end of line statement',
        TOKEN_DATA:                 'template data / text',
        TOKEN_EOF:                  'end of template'
    }.get(token_type, token_type)


def describe_token(token):
    """"""Returns a description of the token.""""""
    if token.type == 'name':
        return token.value
    return _describe_token_type(token.type)


def describe_token_expr(expr):
    """"""Like `describe_token` but for token expressions.""""""
    if ':' in expr:
        type, value = expr.split(':', 1)
        if type == 'name':
            return value
    else:
        type = expr
    return _describe_token_type(type)


def count_newlines(value):
    """"""Count the number of newline characters in the string.  This is
    useful for extensions that filter a stream.
    """"""
    return len(newline_re.findall(value))


def compile_rules(environment):
    """"""Compiles all the rules from the environment into a list of rules.""""""
    e = re.escape
    rules = [
        (len(environment.comment_start_string), 'comment',
         e(environment.comment_start_string)),
        (len(environment.block_start_string), 'block',
         e(environment.block_start_string)),
        (len(environment.variable_start_string), 'variable',
         e(environment.variable_start_string))
    ]

    if environment.line_statement_prefix is not None:
        rules.append((len(environment.line_statement_prefix), 'linestatement',
                      r'^[ \t\v]*' + e(environment.line_statement_prefix)))
    if environment.line_comment_prefix is not None:
        rules.append((len(environment.line_comment_prefix), 'linecomment',
                      r'(?:^|(?<=\S))[^\S\r\n]*' +
                      e(environment.line_comment_prefix)))

    return [x[1:] for x in sorted(rules, reverse=True)]


class Failure(object):
    """"""Class that raises a `TemplateSyntaxError` if called.
    Used by the `Lexer` to specify known errors.
    """"""

    def __init__(self, message, cls=TemplateSyntaxError):
        self.message = message
        self.error_class = cls

    def __call__(self, lineno, filename):
        raise self.error_class(self.message, lineno, filename)


class Token(tuple):
    """"""Token class.""""""
    __slots__ = ()
    lineno, type, value = (property(itemgetter(x)) for x in range(3))

    def __new__(cls, lineno, type, value):
        return tuple.__new__(cls, (lineno, intern(str(type)), value))

    def __str__(self):
        if self.type in reverse_operators:
            return reverse_operators[self.type]
        elif self.type == 'name':
            return self.value
        return self.type

    def test(self, expr):
        """"""Test a token against a token expression.  This can either be a
        token type or ``'token_type:token_value'``.  This can only test
        against string values and types.
        """"""
        # here we do a regular string equality check as test_any is usually
        # passed an iterable of not interned strings.
        if self.type == expr:
            return True
        elif ':' in expr:
            return expr.split(':', 1) == [self.type, self.value]
        return False

    def test_any(self, *iterable):
        """"""Test against multiple token expressions.""""""
        for expr in iterable:
            if self.test(expr):
                return True
        return False

    def __repr__(self):
        return 'Token(%r, %r, %r)' % (
            self.lineno,
            self.type,
            self.value
        )


@implements_iterator
class TokenStreamIterator(object):
    """"""The iterator for tokenstreams.  Iterate over the stream
    until the eof token is reached.
    """"""

    def __init__(self, stream):
        self.stream = stream

    def __iter__(self):
        return self

    def __next__(self):
        token = self.stream.current
        if token.type is TOKEN_EOF:
            self.stream.close()
            raise StopIteration()
        next(self.stream)
        return token


@implements_iterator
class TokenStream(object):
    """"""A token stream is an iterable that yields :class:`Token`\\s.  The
    parser however does not iterate over it but calls :meth:`next` to go
    one token ahead.  The current active token is stored as :attr:`current`.
    """"""

    def __init__(self, generator, name, filename):
        self._iter = iter(generator)
        self._pushed = deque()
        self.name = name
        self.filename = filename
        self.closed = False
        self.current = Token(1, TOKEN_INITIAL, '')
        next(self)

    def __iter__(self):
        return TokenStreamIterator(self)

    def __bool__(self):
        return bool(self._pushed) or self.current.type is not TOKEN_EOF
    __nonzero__ = __bool__  # py2

    eos = property(lambda x: not x, doc=""Are we at the end of the stream?"")

    def push(self, token):
        """"""Push a token back to the stream.""""""
        self._pushed.append(token)

    def look(self):
        """"""Look at the next token.""""""
        old_token = next(self)
        result = self.current
        self.push(result)
        self.current = old_token
        return result

    def skip(self, n=1):
        """"""Got n tokens ahead.""""""
        for x in range(n):
            next(self)

    def next_if(self, expr):
        """"""Perform the token test and return the token if it matched.
        Otherwise the return value is `None`.
        """"""
        if self.current.test(expr):
            return next(self)

    def skip_if(self, expr):
        """"""Like :meth:`next_if` but only returns `True` or `False`.""""""
        return self.next_if(expr) is not None

    def __next__(self):
        """"""Go one token ahead and return the old one.

        Use the built-in :func:`next` instead of calling this directly.
        """"""
        rv = self.current
        if self._pushed:
            self.current = self._pushed.popleft()
        elif self.current.type is not TOKEN_EOF:
            try:
                self.current = next(self._iter)
            except StopIteration:
                self.close()
        return rv

    def close(self):
        """"""Close the stream.""""""
        self.current = Token(self.current.lineno, TOKEN_EOF, '')
        self._iter = None
        self.closed = True

    def expect(self, expr):
        """"""Expect a given token type and return it.  This accepts the same
        argument as :meth:`jinja2.lexer.Token.test`.
        """"""
        if not self.current.test(expr):
            expr = describe_token_expr(expr)
            if self.current.type is TOKEN_EOF:
                raise TemplateSyntaxError('unexpected end of template, '
                                          'expected %r.' % expr,
                                          self.current.lineno,
                                          self.name, self.filename)
            raise TemplateSyntaxError(""expected token %r, got %r"" %
                                      (expr, describe_token(self.current)),
                                      self.current.lineno,
                                      self.name, self.filename)
        try:
            return self.current
        finally:
            next(self)


def get_lexer(environment):
    """"""Return a lexer which is probably cached.""""""
    key = (environment.block_start_string,
           environment.block_end_string,
           environment.variable_start_string,
           environment.variable_end_string,
           environment.comment_start_string,
           environment.comment_end_string,
           environment.line_statement_prefix,
           environment.line_comment_prefix,
           environment.trim_blocks,
           environment.lstrip_blocks,
           environment.newline_sequence,
           environment.keep_trailing_newline)
    lexer = _lexer_cache.get(key)
    if lexer is None:
        lexer = Lexer(environment)
        _lexer_cache[key] = lexer
    return lexer


class Lexer(object):
    """"""Class that implements a lexer for a given environment. Automatically
    created by the environment class, usually you don't have to do that.

    Note that the lexer is not automatically bound to an environment.
    Multiple environments can share the same lexer.
    """"""

    def __init__(self, environment):
        # shortcuts
        c = lambda x: re.compile(x, re.M | re.S)
        e = re.escape

        # lexing rules for tags
        tag_rules = [
            (whitespace_re, TOKEN_WHITESPACE, None),
            (float_re, TOKEN_FLOAT, None),
            (integer_re, TOKEN_INTEGER, None),
            (name_re, TOKEN_NAME, None),
            (string_re, TOKEN_STRING, None),
            (operator_re, TOKEN_OPERATOR, None)
        ]

        # assemble the root lexing rule. because ""|"" is ungreedy
        # we have to sort by length so that the lexer continues working
        # as expected when we have parsing rules like <% for block and
        # <%= for variables. (if someone wants asp like syntax)
        # variables are just part of the rules if variable processing
        # is required.
        root_tag_rules = compile_rules(environment)

        # block suffix if trimming is enabled
        block_suffix_re = environment.trim_blocks and '\\n?' or ''

        # strip leading spaces if lstrip_blocks is enabled
        prefix_re = {}
        if environment.lstrip_blocks:
            # use '{%+' to manually disable lstrip_blocks behavior
            no_lstrip_re = e('+')
            # detect overlap between block and variable or comment strings
            block_diff = c(r'^%s(.*)' % e(environment.block_start_string))
            # make sure we don't mistake a block for a variable or a comment
            m = block_diff.match(environment.comment_start_string)
            no_lstrip_re += m and r'|%s' % e(m.group(1)) or ''
            m = block_diff.match(environment.variable_start_string)
            no_lstrip_re += m and r'|%s' % e(m.group(1)) or ''

            # detect overlap between comment and variable strings
            comment_diff = c(r'^%s(.*)' % e(environment.comment_start_string))
            m = comment_diff.match(environment.variable_start_string)
            no_variable_re = m and r'(?!%s)' % e(m.group(1)) or ''

            lstrip_re = r'^[ \t]*'
            block_prefix_re = r'%s%s(?!%s)|%s\+?' % (
                    lstrip_re,
                    e(environment.block_start_string),
                    no_lstrip_re,
                    e(environment.block_start_string),
                    )
            comment_prefix_re = r'%s%s%s|%s\+?' % (
                    lstrip_re,
                    e(environment.comment_start_string),
                    no_variable_re,
                    e(environment.comment_start_string),
                    )
            prefix_re['block'] = block_prefix_re
            prefix_re['comment'] = comment_prefix_re
        else:
            block_prefix_re = '%s' % e(environment.block_start_string)

        self.newline_sequence = environment.newline_sequence
        self.keep_trailing_newline = environment.keep_trailing_newline

        # global lexing rules
        self.rules = {
            'root': [
                # directives
                (c('(.*?)(?:%s)' % '|'.join(
                    [r'(?P<raw_begin>(?:\s*%s\-|%s)\s*raw\s*(?:\-%s\s*|%s))' % (
                        e(environment.block_start_string),
                        block_prefix_re,
                        e(environment.block_end_string),
                        e(environment.block_end_string)
                    )] + [
                        r'(?P<%s_begin>\s*%s\-|%s)' % (n, r, prefix_re.get(n,r))
                        for n, r in root_tag_rules
                    ])), (TOKEN_DATA, '#bygroup'), '#bygroup'),
                # data
                (c('.+'), TOKEN_DATA, None)
            ],
            # comments
            TOKEN_COMMENT_BEGIN: [
                (c(r'(.*?)((?:\-%s\s*|%s)%s)' % (
                    e(environment.comment_end_string),
                    e(environment.comment_end_string),
                    block_suffix_re
                )), (TOKEN_COMMENT, TOKEN_COMMENT_END), '#pop'),
                (c('(.)'), (Failure('Missing end of comment tag'),), None)
            ],
            # blocks
            TOKEN_BLOCK_BEGIN: [
                (c(r'(?:\-%s\s*|%s)%s' % (
                    e(environment.block_end_string),
                    e(environment.block_end_string),
                    block_suffix_re
                )), TOKEN_BLOCK_END, '#pop'),
            ] + tag_rules,
            # variables
            TOKEN_VARIABLE_BEGIN: [
                (c(r'\-%s\s*|%s' % (
                    e(environment.variable_end_string),
                    e(environment.variable_end_string)
                )), TOKEN_VARIABLE_END, '#pop')
            ] + tag_rules,
            # raw block
            TOKEN_RAW_BEGIN: [
                (c(r'(.*?)((?:\s*%s\-|%s)\s*endraw\s*(?:\-%s\s*|%s%s))' % (
                    e(environment.block_start_string),
                    block_prefix_re,
                    e(environment.block_end_string),
                    e(environment.block_end_string),
                    block_suffix_re
                )), (TOKEN_DATA, TOKEN_RAW_END), '#pop'),
                (c('(.)'), (Failure('Missing end of raw directive'),), None)
            ],
            # line statements
            TOKEN_LINESTATEMENT_BEGIN: [
                (c(r'\s*(\n|$)'), TOKEN_LINESTATEMENT_END, '#pop')
            ] + tag_rules,
            # line comments
            TOKEN_LINECOMMENT_BEGIN: [
                (c(r'(.*?)()(?=\n|$)'), (TOKEN_LINECOMMENT,
                 TOKEN_LINECOMMENT_END), '#pop')
            ]
        }

    def _normalize_newlines(self, value):
        """"""Called for strings and template data to normalize it to unicode.""""""
        return newline_re.sub(self.newline_sequence, value)

    def tokenize(self, source, name=None, filename=None, state=None):
        """"""Calls tokeniter + tokenize and wraps it in a token stream.
        """"""
        stream = self.tokeniter(source, name, filename, state)
        return TokenStream(self.wrap(stream, name, filename), name, filename)

    def wrap(self, stream, name=None, filename=None):
        """"""This is called with the stream as returned by `tokenize` and wraps
        every token in a :class:`Token` and converts the value.
        """"""
        for lineno, token, value in stream:
            if token in ignored_tokens:
                continue
            elif token == 'linestatement_begin':
                token = 'block_begin'
            elif token == 'linestatement_end':
                token = 'block_end'
            # we are not interested in those tokens in the parser
            elif token in ('raw_begin', 'raw_end'):
                continue
            elif token == 'data':
                value = self._normalize_newlines(value)
            elif token == 'keyword':
                token = value
            elif token == 'name':
                value = str(value)
                if check_ident and not value.isidentifier():
                    raise TemplateSyntaxError(
                        'Invalid character in identifier',
                        lineno, name, filename)
            elif token == 'string':
                # try to unescape string
                try:
                    value = self._normalize_newlines(value[1:-1]) \
                        .encode('ascii', 'backslashreplace') \
                        .decode('unicode-escape')
                except Exception as e:
                    msg = str(e).split(':')[-1].strip()
                    raise TemplateSyntaxError(msg, lineno, name, filename)
            elif token == 'integer':
                value = int(value)
            elif token == 'float':
                value = float(value)
            elif token == 'operator':
                token = operators[value]
            yield Token(lineno, token, value)

    def tokeniter(self, source, name, filename=None, state=None):
        """"""This method tokenizes the text and returns the tokens in a
        generator.  Use this method if you just want to tokenize a template.
        """"""
        source = text_type(source)
        lines = source.splitlines()
        if self.keep_trailing_newline and source:
            for newline in ('\r\n', '\r', '\n'):
                if source.endswith(newline):
                    lines.append('')
                    break
        source = '\n'.join(lines)
        pos = 0
        lineno = 1
        stack = ['root']
        if state is not None and state != 'root':
            stack.append(state + '_begin')
        else:
            state = 'root'
        statetokens = self.rules[stack[-1]]
        source_length = len(source)

        balancing_stack = []

        while 1:
            # tokenizer loop
            for regex, tokens, new_state in statetokens:
                m = regex.match(source, pos)
                # if no match we try again with the next rule
                if m is None:
                    continue

                # we only match blocks and variables if braces / parentheses
                # are balanced. continue parsing with the lower rule which
                # is the operator rule. do this only if the end tags look
                # like operators
                if balancing_stack and \
                   tokens in ('variable_end', 'block_end',
                              'linestatement_end'):
                    continue

                # tuples support more options
                if isinstance(tokens, tuple):
                    for idx, token in enumerate(tokens):
                        # failure group
                        if token.__class__ is Failure:
                            raise token(lineno, filename)
                        # bygroup is a bit more complex, in that case we
                        # yield for the current token the first named
                        # group that matched
                        elif token == '#bygroup':
                            for key, value in iteritems(m.groupdict()):
                                if value is not None:
                                    yield lineno, key, value
                                    lineno += value.count('\n')
                                    break
                            else:
                                raise RuntimeError('%r wanted to resolve '
                                                   'the token dynamically'
                                                   ' but no group matched'
                                                   % regex)
                        # normal group
                        else:
                            data = m.group(idx + 1)
                            if data or token not in ignore_if_empty:
                                yield lineno, token, data
                            lineno += data.count('\n')

                # strings as token just are yielded as it.
                else:
                    data = m.group()
                    # update brace/parentheses balance
                    if tokens == 'operator':
                        if data == '{':
                            balancing_stack.append('}')
                        elif data == '(':
                            balancing_stack.append(')')
                        elif data == '[':
                            balancing_stack.append(']')
                        elif data in ('}', ')', ']'):
                            if not balancing_stack:
                                raise TemplateSyntaxError('unexpected \'%s\'' %
                                                          data, lineno, name,
                                                          filename)
                            expected_op = balancing_stack.pop()
                            if expected_op != data:
                                raise TemplateSyntaxError('unexpected \'%s\', '
                                                          'expected \'%s\'' %
                                                          (data, expected_op),
                                                          lineno, name,
                                                          filename)
                    # yield items
                    if data or tokens not in ignore_if_empty:
                        yield lineno, tokens, data
                    lineno += data.count('\n')

                # fetch new position into new variable so that we can check
                # if there is a internal parsing error which would result
                # in an infinite loop
                pos2 = m.end()

                # handle state changes
                if new_state is not None:
                    # remove the uppermost state
                    if new_state == '#pop':
                        stack.pop()
                    # resolve the new state by group checking
                    elif new_state == '#bygroup':
                        for key, value in iteritems(m.groupdict()):
                            if value is not None:
                                stack.append(key)
                                break
                        else:
                            raise RuntimeError('%r wanted to resolve the '
                                               'new state dynamically but'
                                               ' no group matched' %
                                               regex)
                    # direct state name given
                    else:
                        stack.append(new_state)
                    statetokens = self.rules[stack[-1]]
                # we are still at the same position and no stack change.
                # this means a loop without break condition, avoid that and
                # raise error
                elif pos2 == pos:
                    raise RuntimeError('%r yielded empty string without '
                                       'stack change' % regex)
                # publish new function and start again
                pos = pos2
                break
            # if loop terminated without break we haven't found a single match
            # either we are at the end of the file or we have a problem
            else:
                # end of text
                if pos >= source_length:
                    return
                # something went wrong
                raise TemplateSyntaxError('unexpected char %r at %d' %
                                          (source[pos], pos), lineno,
                                          name, filename)
"
mike0sv/spark,"#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the ""License""); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import sys
import warnings
import json

if sys.version >= '3':
    basestring = str
    long = int

from pyspark import copy_func, since
from pyspark.context import SparkContext
from pyspark.rdd import ignore_unicode_prefix
from pyspark.sql.types import *

__all__ = [""Column""]


def _create_column_from_literal(literal):
    sc = SparkContext._active_spark_context
    return sc._jvm.functions.lit(literal)


def _create_column_from_name(name):
    sc = SparkContext._active_spark_context
    return sc._jvm.functions.col(name)


def _to_java_column(col):
    if isinstance(col, Column):
        jcol = col._jc
    else:
        jcol = _create_column_from_name(col)
    return jcol


def _to_seq(sc, cols, converter=None):
    """"""
    Convert a list of Column (or names) into a JVM Seq of Column.

    An optional `converter` could be used to convert items in `cols`
    into JVM Column objects.
    """"""
    if converter:
        cols = [converter(c) for c in cols]
    return sc._jvm.PythonUtils.toSeq(cols)


def _to_list(sc, cols, converter=None):
    """"""
    Convert a list of Column (or names) into a JVM (Scala) List of Column.

    An optional `converter` could be used to convert items in `cols`
    into JVM Column objects.
    """"""
    if converter:
        cols = [converter(c) for c in cols]
    return sc._jvm.PythonUtils.toList(cols)


def _unary_op(name, doc=""unary operator""):
    """""" Create a method for given unary operator """"""
    def _(self):
        jc = getattr(self._jc, name)()
        return Column(jc)
    _.__doc__ = doc
    return _


def _func_op(name, doc=''):
    def _(self):
        sc = SparkContext._active_spark_context
        jc = getattr(sc._jvm.functions, name)(self._jc)
        return Column(jc)
    _.__doc__ = doc
    return _


def _bin_func_op(name, reverse=False, doc=""binary function""):
    def _(self, other):
        sc = SparkContext._active_spark_context
        fn = getattr(sc._jvm.functions, name)
        jc = other._jc if isinstance(other, Column) else _create_column_from_literal(other)
        njc = fn(self._jc, jc) if not reverse else fn(jc, self._jc)
        return Column(njc)
    _.__doc__ = doc
    return _


def _bin_op(name, doc=""binary operator""):
    """""" Create a method for given binary operator
    """"""
    def _(self, other):
        jc = other._jc if isinstance(other, Column) else other
        njc = getattr(self._jc, name)(jc)
        return Column(njc)
    _.__doc__ = doc
    return _


def _reverse_op(name, doc=""binary operator""):
    """""" Create a method for binary operator (this object is on right side)
    """"""
    def _(self, other):
        jother = _create_column_from_literal(other)
        jc = getattr(jother, name)(self._jc)
        return Column(jc)
    _.__doc__ = doc
    return _


class Column(object):

    """"""
    A column in a DataFrame.

    :class:`Column` instances can be created by::

        # 1. Select a column out of a DataFrame

        df.colName
        df[""colName""]

        # 2. Create from an expression
        df.colName + 1
        1 / df.colName

    .. versionadded:: 1.3
    """"""

    def __init__(self, jc):
        self._jc = jc

    # arithmetic operators
    __neg__ = _func_op(""negate"")
    __add__ = _bin_op(""plus"")
    __sub__ = _bin_op(""minus"")
    __mul__ = _bin_op(""multiply"")
    __div__ = _bin_op(""divide"")
    __truediv__ = _bin_op(""divide"")
    __mod__ = _bin_op(""mod"")
    __radd__ = _bin_op(""plus"")
    __rsub__ = _reverse_op(""minus"")
    __rmul__ = _bin_op(""multiply"")
    __rdiv__ = _reverse_op(""divide"")
    __rtruediv__ = _reverse_op(""divide"")
    __rmod__ = _reverse_op(""mod"")
    __pow__ = _bin_func_op(""pow"")
    __rpow__ = _bin_func_op(""pow"", reverse=True)

    # logistic operators
    __eq__ = _bin_op(""equalTo"")
    __ne__ = _bin_op(""notEqual"")
    __lt__ = _bin_op(""lt"")
    __le__ = _bin_op(""leq"")
    __ge__ = _bin_op(""geq"")
    __gt__ = _bin_op(""gt"")

    _eqNullSafe_doc = """"""
    Equality test that is safe for null values.

    :param other: a value or :class:`Column`

    >>> from pyspark.sql import Row
    >>> df1 = spark.createDataFrame([
    ...     Row(id=1, value='foo'),
    ...     Row(id=2, value=None)
    ... ])
    >>> df1.select(
    ...     df1['value'] == 'foo',
    ...     df1['value'].eqNullSafe('foo'),
    ...     df1['value'].eqNullSafe(None)
    ... ).show()
    +-------------+---------------+----------------+
    |(value = foo)|(value <=> foo)|(value <=> NULL)|
    +-------------+---------------+----------------+
    |         true|           true|           false|
    |         null|          false|            true|
    +-------------+---------------+----------------+
    >>> df2 = spark.createDataFrame([
    ...     Row(value = 'bar'),
    ...     Row(value = None)
    ... ])
    >>> df1.join(df2, df1[""value""] == df2[""value""]).count()
    0
    >>> df1.join(df2, df1[""value""].eqNullSafe(df2[""value""])).count()
    1
    >>> df2 = spark.createDataFrame([
    ...     Row(id=1, value=float('NaN')),
    ...     Row(id=2, value=42.0),
    ...     Row(id=3, value=None)
    ... ])
    >>> df2.select(
    ...     df2['value'].eqNullSafe(None),
    ...     df2['value'].eqNullSafe(float('NaN')),
    ...     df2['value'].eqNullSafe(42.0)
    ... ).show()
    +----------------+---------------+----------------+
    |(value <=> NULL)|(value <=> NaN)|(value <=> 42.0)|
    +----------------+---------------+----------------+
    |           false|           true|           false|
    |           false|          false|            true|
    |            true|          false|           false|
    +----------------+---------------+----------------+

    .. note:: Unlike Pandas, PySpark doesn't consider NaN values to be NULL.
       See the `NaN Semantics`_ for details.
    .. _NaN Semantics:
       https://spark.apache.org/docs/latest/sql-programming-guide.html#nan-semantics
    .. versionadded:: 2.3.0
    """"""
    eqNullSafe = _bin_op(""eqNullSafe"", _eqNullSafe_doc)

    # `and`, `or`, `not` cannot be overloaded in Python,
    # so use bitwise operators as boolean operators
    __and__ = _bin_op('and')
    __or__ = _bin_op('or')
    __invert__ = _func_op('not')
    __rand__ = _bin_op(""and"")
    __ror__ = _bin_op(""or"")

    # container operators
    def __contains__(self, item):
        raise ValueError(""Cannot apply 'in' operator against a column: please use 'contains' ""
                         ""in a string column or 'array_contains' function for an array column."")

    # bitwise operators
    _bitwiseOR_doc = """"""
    Compute bitwise OR of this expression with another expression.

    :param other: a value or :class:`Column` to calculate bitwise or(|) against
                  this :class:`Column`.

    >>> from pyspark.sql import Row
    >>> df = spark.createDataFrame([Row(a=170, b=75)])
    >>> df.select(df.a.bitwiseOR(df.b)).collect()
    [Row((a | b)=235)]
    """"""
    _bitwiseAND_doc = """"""
    Compute bitwise AND of this expression with another expression.

    :param other: a value or :class:`Column` to calculate bitwise and(&) against
                  this :class:`Column`.

    >>> from pyspark.sql import Row
    >>> df = spark.createDataFrame([Row(a=170, b=75)])
    >>> df.select(df.a.bitwiseAND(df.b)).collect()
    [Row((a & b)=10)]
    """"""
    _bitwiseXOR_doc = """"""
    Compute bitwise XOR of this expression with another expression.

    :param other: a value or :class:`Column` to calculate bitwise xor(^) against
                  this :class:`Column`.

    >>> from pyspark.sql import Row
    >>> df = spark.createDataFrame([Row(a=170, b=75)])
    >>> df.select(df.a.bitwiseXOR(df.b)).collect()
    [Row((a ^ b)=225)]
    """"""

    bitwiseOR = _bin_op(""bitwiseOR"", _bitwiseOR_doc)
    bitwiseAND = _bin_op(""bitwiseAND"", _bitwiseAND_doc)
    bitwiseXOR = _bin_op(""bitwiseXOR"", _bitwiseXOR_doc)

    @since(1.3)
    def getItem(self, key):
        """"""
        An expression that gets an item at position ``ordinal`` out of a list,
        or gets an item by key out of a dict.

        >>> df = spark.createDataFrame([([1, 2], {""key"": ""value""})], [""l"", ""d""])
        >>> df.select(df.l.getItem(0), df.d.getItem(""key"")).show()
        +----+------+
        |l[0]|d[key]|
        +----+------+
        |   1| value|
        +----+------+
        >>> df.select(df.l[0], df.d[""key""]).show()
        +----+------+
        |l[0]|d[key]|
        +----+------+
        |   1| value|
        +----+------+
        """"""
        return self[key]

    @since(1.3)
    def getField(self, name):
        """"""
        An expression that gets a field by name in a StructField.

        >>> from pyspark.sql import Row
        >>> df = spark.createDataFrame([Row(r=Row(a=1, b=""b""))])
        >>> df.select(df.r.getField(""b"")).show()
        +---+
        |r.b|
        +---+
        |  b|
        +---+
        >>> df.select(df.r.a).show()
        +---+
        |r.a|
        +---+
        |  1|
        +---+
        """"""
        return self[name]

    def __getattr__(self, item):
        if item.startswith(""__""):
            raise AttributeError(item)
        return self.getField(item)

    def __getitem__(self, k):
        if isinstance(k, slice):
            if k.step is not None:
                raise ValueError(""slice with step is not supported."")
            return self.substr(k.start, k.stop)
        else:
            return _bin_op(""apply"")(self, k)

    def __iter__(self):
        raise TypeError(""Column is not iterable"")

    # string methods
    _contains_doc = """"""
    Contains the other element. Returns a boolean :class:`Column` based on a string match.

    :param other: string in line

    >>> df.filter(df.name.contains('o')).collect()
    [Row(age=5, name=u'Bob')]
    """"""
    _rlike_doc = """"""
    SQL RLIKE expression (LIKE with Regex). Returns a boolean :class:`Column` based on a regex
    match.

    :param other: an extended regex expression

    >>> df.filter(df.name.rlike('ice$')).collect()
    [Row(age=2, name=u'Alice')]
    """"""
    _like_doc = """"""
    SQL like expression. Returns a boolean :class:`Column` based on a SQL LIKE match.

    :param other: a SQL LIKE pattern

    See :func:`rlike` for a regex version

    >>> df.filter(df.name.like('Al%')).collect()
    [Row(age=2, name=u'Alice')]
    """"""
    _startswith_doc = """"""
    String starts with. Returns a boolean :class:`Column` based on a string match.

    :param other: string at start of line (do not use a regex `^`)

    >>> df.filter(df.name.startswith('Al')).collect()
    [Row(age=2, name=u'Alice')]
    >>> df.filter(df.name.startswith('^Al')).collect()
    []
    """"""
    _endswith_doc = """"""
    String ends with. Returns a boolean :class:`Column` based on a string match.

    :param other: string at end of line (do not use a regex `$`)

    >>> df.filter(df.name.endswith('ice')).collect()
    [Row(age=2, name=u'Alice')]
    >>> df.filter(df.name.endswith('ice$')).collect()
    []
    """"""

    contains = ignore_unicode_prefix(_bin_op(""contains"", _contains_doc))
    rlike = ignore_unicode_prefix(_bin_op(""rlike"", _rlike_doc))
    like = ignore_unicode_prefix(_bin_op(""like"", _like_doc))
    startswith = ignore_unicode_prefix(_bin_op(""startsWith"", _startswith_doc))
    endswith = ignore_unicode_prefix(_bin_op(""endsWith"", _endswith_doc))

    @ignore_unicode_prefix
    @since(1.3)
    def substr(self, startPos, length):
        """"""
        Return a :class:`Column` which is a substring of the column.

        :param startPos: start position (int or Column)
        :param length:  length of the substring (int or Column)

        >>> df.select(df.name.substr(1, 3).alias(""col"")).collect()
        [Row(col=u'Ali'), Row(col=u'Bob')]
        """"""
        if type(startPos) != type(length):
            raise TypeError(""Can not mix the type"")
        if isinstance(startPos, (int, long)):
            jc = self._jc.substr(startPos, length)
        elif isinstance(startPos, Column):
            jc = self._jc.substr(startPos._jc, length._jc)
        else:
            raise TypeError(""Unexpected type: %s"" % type(startPos))
        return Column(jc)

    @ignore_unicode_prefix
    @since(1.5)
    def isin(self, *cols):
        """"""
        A boolean expression that is evaluated to true if the value of this
        expression is contained by the evaluated values of the arguments.

        >>> df[df.name.isin(""Bob"", ""Mike"")].collect()
        [Row(age=5, name=u'Bob')]
        >>> df[df.age.isin([1, 2, 3])].collect()
        [Row(age=2, name=u'Alice')]
        """"""
        if len(cols) == 1 and isinstance(cols[0], (list, set)):
            cols = cols[0]
        cols = [c._jc if isinstance(c, Column) else _create_column_from_literal(c) for c in cols]
        sc = SparkContext._active_spark_context
        jc = getattr(self._jc, ""isin"")(_to_seq(sc, cols))
        return Column(jc)

    # order
    _asc_doc = """"""
    Returns a sort expression based on the ascending order of the given column name

    >>> from pyspark.sql import Row
    >>> df = spark.createDataFrame([Row(name=u'Tom', height=80), Row(name=u'Alice', height=None)])
    >>> df.select(df.name).orderBy(df.name.asc()).collect()
    [Row(name=u'Alice'), Row(name=u'Tom')]
    """"""
    _desc_doc = """"""
    Returns a sort expression based on the descending order of the given column name.

    >>> from pyspark.sql import Row
    >>> df = spark.createDataFrame([Row(name=u'Tom', height=80), Row(name=u'Alice', height=None)])
    >>> df.select(df.name).orderBy(df.name.desc()).collect()
    [Row(name=u'Tom'), Row(name=u'Alice')]
    """"""

    asc = ignore_unicode_prefix(_unary_op(""asc"", _asc_doc))
    desc = ignore_unicode_prefix(_unary_op(""desc"", _desc_doc))

    _isNull_doc = """"""
    True if the current expression is null.

    >>> from pyspark.sql import Row
    >>> df = spark.createDataFrame([Row(name=u'Tom', height=80), Row(name=u'Alice', height=None)])
    >>> df.filter(df.height.isNull()).collect()
    [Row(height=None, name=u'Alice')]
    """"""
    _isNotNull_doc = """"""
    True if the current expression is NOT null.

    >>> from pyspark.sql import Row
    >>> df = spark.createDataFrame([Row(name=u'Tom', height=80), Row(name=u'Alice', height=None)])
    >>> df.filter(df.height.isNotNull()).collect()
    [Row(height=80, name=u'Tom')]
    """"""

    isNull = ignore_unicode_prefix(_unary_op(""isNull"", _isNull_doc))
    isNotNull = ignore_unicode_prefix(_unary_op(""isNotNull"", _isNotNull_doc))

    @since(1.3)
    def alias(self, *alias, **kwargs):
        """"""
        Returns this column aliased with a new name or names (in the case of expressions that
        return more than one column, such as explode).

        :param alias: strings of desired column names (collects all positional arguments passed)
        :param metadata: a dict of information to be stored in ``metadata`` attribute of the
            corresponding :class: `StructField` (optional, keyword only argument)

        .. versionchanged:: 2.2
           Added optional ``metadata`` argument.

        >>> df.select(df.age.alias(""age2"")).collect()
        [Row(age2=2), Row(age2=5)]
        >>> df.select(df.age.alias(""age3"", metadata={'max': 99})).schema['age3'].metadata['max']
        99
        """"""

        metadata = kwargs.pop('metadata', None)
        assert not kwargs, 'Unexpected kwargs where passed: %s' % kwargs

        sc = SparkContext._active_spark_context
        if len(alias) == 1:
            if metadata:
                jmeta = sc._jvm.org.apache.spark.sql.types.Metadata.fromJson(
                    json.dumps(metadata))
                return Column(getattr(self._jc, ""as"")(alias[0], jmeta))
            else:
                return Column(getattr(self._jc, ""as"")(alias[0]))
        else:
            if metadata:
                raise ValueError('metadata can only be provided for a single column')
            return Column(getattr(self._jc, ""as"")(_to_seq(sc, list(alias))))

    name = copy_func(alias, sinceversion=2.0, doc="":func:`name` is an alias for :func:`alias`."")

    @ignore_unicode_prefix
    @since(1.3)
    def cast(self, dataType):
        """""" Convert the column into type ``dataType``.

        >>> df.select(df.age.cast(""string"").alias('ages')).collect()
        [Row(ages=u'2'), Row(ages=u'5')]
        >>> df.select(df.age.cast(StringType()).alias('ages')).collect()
        [Row(ages=u'2'), Row(ages=u'5')]
        """"""
        if isinstance(dataType, basestring):
            jc = self._jc.cast(dataType)
        elif isinstance(dataType, DataType):
            from pyspark.sql import SparkSession
            spark = SparkSession.builder.getOrCreate()
            jdt = spark._jsparkSession.parseDataType(dataType.json())
            jc = self._jc.cast(jdt)
        else:
            raise TypeError(""unexpected type: %s"" % type(dataType))
        return Column(jc)

    astype = copy_func(cast, sinceversion=1.4, doc="":func:`astype` is an alias for :func:`cast`."")

    @since(1.3)
    def between(self, lowerBound, upperBound):
        """"""
        A boolean expression that is evaluated to true if the value of this
        expression is between the given columns.

        >>> df.select(df.name, df.age.between(2, 4)).show()
        +-----+---------------------------+
        | name|((age >= 2) AND (age <= 4))|
        +-----+---------------------------+
        |Alice|                       true|
        |  Bob|                      false|
        +-----+---------------------------+
        """"""
        return (self >= lowerBound) & (self <= upperBound)

    @since(1.4)
    def when(self, condition, value):
        """"""
        Evaluates a list of conditions and returns one of multiple possible result expressions.
        If :func:`Column.otherwise` is not invoked, None is returned for unmatched conditions.

        See :func:`pyspark.sql.functions.when` for example usage.

        :param condition: a boolean :class:`Column` expression.
        :param value: a literal value, or a :class:`Column` expression.

        >>> from pyspark.sql import functions as F
        >>> df.select(df.name, F.when(df.age > 4, 1).when(df.age < 3, -1).otherwise(0)).show()
        +-----+------------------------------------------------------------+
        | name|CASE WHEN (age > 4) THEN 1 WHEN (age < 3) THEN -1 ELSE 0 END|
        +-----+------------------------------------------------------------+
        |Alice|                                                          -1|
        |  Bob|                                                           1|
        +-----+------------------------------------------------------------+
        """"""
        if not isinstance(condition, Column):
            raise TypeError(""condition should be a Column"")
        v = value._jc if isinstance(value, Column) else value
        jc = self._jc.when(condition._jc, v)
        return Column(jc)

    @since(1.4)
    def otherwise(self, value):
        """"""
        Evaluates a list of conditions and returns one of multiple possible result expressions.
        If :func:`Column.otherwise` is not invoked, None is returned for unmatched conditions.

        See :func:`pyspark.sql.functions.when` for example usage.

        :param value: a literal value, or a :class:`Column` expression.

        >>> from pyspark.sql import functions as F
        >>> df.select(df.name, F.when(df.age > 3, 1).otherwise(0)).show()
        +-----+-------------------------------------+
        | name|CASE WHEN (age > 3) THEN 1 ELSE 0 END|
        +-----+-------------------------------------+
        |Alice|                                    0|
        |  Bob|                                    1|
        +-----+-------------------------------------+
        """"""
        v = value._jc if isinstance(value, Column) else value
        jc = self._jc.otherwise(v)
        return Column(jc)

    @since(1.4)
    def over(self, window):
        """"""
        Define a windowing column.

        :param window: a :class:`WindowSpec`
        :return: a Column

        >>> from pyspark.sql import Window
        >>> window = Window.partitionBy(""name"").orderBy(""age"").rowsBetween(-1, 1)
        >>> from pyspark.sql.functions import rank, min
        >>> # df.select(rank().over(window), min('age').over(window))
        """"""
        from pyspark.sql.window import WindowSpec
        if not isinstance(window, WindowSpec):
            raise TypeError(""window should be WindowSpec"")
        jc = self._jc.over(window._jspec)
        return Column(jc)

    def __nonzero__(self):
        raise ValueError(""Cannot convert column into bool: please use '&' for 'and', '|' for 'or', ""
                         ""'~' for 'not' when building DataFrame boolean expressions."")
    __bool__ = __nonzero__

    def __repr__(self):
        return 'Column<%s>' % self._jc.toString().encode('utf8')


def _test():
    import doctest
    from pyspark.sql import SparkSession
    import pyspark.sql.column
    globs = pyspark.sql.column.__dict__.copy()
    spark = SparkSession.builder\
        .master(""local[4]"")\
        .appName(""sql.column tests"")\
        .getOrCreate()
    sc = spark.sparkContext
    globs['spark'] = spark
    globs['df'] = sc.parallelize([(2, 'Alice'), (5, 'Bob')]) \
        .toDF(StructType([StructField('age', IntegerType()),
                          StructField('name', StringType())]))

    (failure_count, test_count) = doctest.testmod(
        pyspark.sql.column, globs=globs,
        optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE | doctest.REPORT_NDIFF)
    spark.stop()
    if failure_count:
        exit(-1)


if __name__ == ""__main__"":
    _test()
","[['kwargs', '==', 'False']]","['basestring', 'long', '__all__', 'literal', 'sc', 'name', 'col', 'jcol', 'cols', 'converter', 'doc', 'jc', '_.__doc__', 'reverse', 'other', 'fn', 'njc', 'jother', 'self._jc', '__neg__', '__add__', '__sub__', '__mul__', '__div__', '__truediv__', '__mod__', '__radd__', '__rsub__', '__rmul__', '__rdiv__', '__rtruediv__', '__rmod__', '__pow__', '__rpow__', '__eq__', '__ne__', '__lt__', '__le__', '__ge__', '__gt__', '_eqNullSafe_doc', '>>> df1', '|(value', '>>> df2', '...     Row(value', 'eqNullSafe', '__and__', '__or__', '__invert__', '__rand__', '__ror__', 'item', '_bitwiseOR_doc', '>>> df', '_bitwiseAND_doc', '_bitwiseXOR_doc', 'bitwiseOR', 'bitwiseAND', 'bitwiseXOR', 'key', 'k', '_contains_doc', '_rlike_doc', '_like_doc', '_startswith_doc', '_endswith_doc', 'contains', 'rlike', 'like', 'startswith', 'endswith', 'startPos', 'length', '*cols', '_asc_doc', '_desc_doc', 'asc', 'desc', '_isNull_doc', '_isNotNull_doc', 'isNull', 'isNotNull', '*alias', '**kwargs', 'metadata', 'jmeta', 'dataType', 'spark', 'jdt', 'astype', 'lowerBound', 'upperBound', 'condition', 'value', 'v', 'window', '>>> window', '__bool__', 'globs', ""globs['spark']"", ""globs['df']"", '(failure_count', 'test_count)']","#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the ""License""); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import sys
import warnings
import json

if sys.version >= '3':
    basestring = str
    long = int

from pyspark import copy_func, since
from pyspark.context import SparkContext
from pyspark.rdd import ignore_unicode_prefix
from pyspark.sql.types import *

__all__ = [""Column""]


def _create_column_from_literal(literal):
    sc = SparkContext._active_spark_context
    return sc._jvm.functions.lit(literal)


def _create_column_from_name(name):
    sc = SparkContext._active_spark_context
    return sc._jvm.functions.col(name)


def _to_java_column(col):
    if isinstance(col, Column):
        jcol = col._jc
    else:
        jcol = _create_column_from_name(col)
    return jcol


def _to_seq(sc, cols, converter=None):
    """"""
    Convert a list of Column (or names) into a JVM Seq of Column.

    An optional `converter` could be used to convert items in `cols`
    into JVM Column objects.
    """"""
    if converter:
        cols = [converter(c) for c in cols]
    return sc._jvm.PythonUtils.toSeq(cols)


def _to_list(sc, cols, converter=None):
    """"""
    Convert a list of Column (or names) into a JVM (Scala) List of Column.

    An optional `converter` could be used to convert items in `cols`
    into JVM Column objects.
    """"""
    if converter:
        cols = [converter(c) for c in cols]
    return sc._jvm.PythonUtils.toList(cols)


def _unary_op(name, doc=""unary operator""):
    """""" Create a method for given unary operator """"""
    def _(self):
        jc = getattr(self._jc, name)()
        return Column(jc)
    _.__doc__ = doc
    return _


def _func_op(name, doc=''):
    def _(self):
        sc = SparkContext._active_spark_context
        jc = getattr(sc._jvm.functions, name)(self._jc)
        return Column(jc)
    _.__doc__ = doc
    return _


def _bin_func_op(name, reverse=False, doc=""binary function""):
    def _(self, other):
        sc = SparkContext._active_spark_context
        fn = getattr(sc._jvm.functions, name)
        jc = other._jc if isinstance(other, Column) else _create_column_from_literal(other)
        njc = fn(self._jc, jc) if not reverse else fn(jc, self._jc)
        return Column(njc)
    _.__doc__ = doc
    return _


def _bin_op(name, doc=""binary operator""):
    """""" Create a method for given binary operator
    """"""
    def _(self, other):
        jc = other._jc if isinstance(other, Column) else other
        njc = getattr(self._jc, name)(jc)
        return Column(njc)
    _.__doc__ = doc
    return _


def _reverse_op(name, doc=""binary operator""):
    """""" Create a method for binary operator (this object is on right side)
    """"""
    def _(self, other):
        jother = _create_column_from_literal(other)
        jc = getattr(jother, name)(self._jc)
        return Column(jc)
    _.__doc__ = doc
    return _


class Column(object):

    """"""
    A column in a DataFrame.

    :class:`Column` instances can be created by::

        # 1. Select a column out of a DataFrame

        df.colName
        df[""colName""]

        # 2. Create from an expression
        df.colName + 1
        1 / df.colName

    .. versionadded:: 1.3
    """"""

    def __init__(self, jc):
        self._jc = jc

    # arithmetic operators
    __neg__ = _func_op(""negate"")
    __add__ = _bin_op(""plus"")
    __sub__ = _bin_op(""minus"")
    __mul__ = _bin_op(""multiply"")
    __div__ = _bin_op(""divide"")
    __truediv__ = _bin_op(""divide"")
    __mod__ = _bin_op(""mod"")
    __radd__ = _bin_op(""plus"")
    __rsub__ = _reverse_op(""minus"")
    __rmul__ = _bin_op(""multiply"")
    __rdiv__ = _reverse_op(""divide"")
    __rtruediv__ = _reverse_op(""divide"")
    __rmod__ = _reverse_op(""mod"")
    __pow__ = _bin_func_op(""pow"")
    __rpow__ = _bin_func_op(""pow"", reverse=True)

    # logistic operators
    __eq__ = _bin_op(""equalTo"")
    __ne__ = _bin_op(""notEqual"")
    __lt__ = _bin_op(""lt"")
    __le__ = _bin_op(""leq"")
    __ge__ = _bin_op(""geq"")
    __gt__ = _bin_op(""gt"")

    _eqNullSafe_doc = """"""
    Equality test that is safe for null values.

    :param other: a value or :class:`Column`

    >>> from pyspark.sql import Row
    >>> df1 = spark.createDataFrame([
    ...     Row(id=1, value='foo'),
    ...     Row(id=2, value=None)
    ... ])
    >>> df1.select(
    ...     df1['value'] == 'foo',
    ...     df1['value'].eqNullSafe('foo'),
    ...     df1['value'].eqNullSafe(None)
    ... ).show()
    +-------------+---------------+----------------+
    |(value = foo)|(value <=> foo)|(value <=> NULL)|
    +-------------+---------------+----------------+
    |         true|           true|           false|
    |         null|          false|            true|
    +-------------+---------------+----------------+
    >>> df2 = spark.createDataFrame([
    ...     Row(value = 'bar'),
    ...     Row(value = None)
    ... ])
    >>> df1.join(df2, df1[""value""] == df2[""value""]).count()
    0
    >>> df1.join(df2, df1[""value""].eqNullSafe(df2[""value""])).count()
    1
    >>> df2 = spark.createDataFrame([
    ...     Row(id=1, value=float('NaN')),
    ...     Row(id=2, value=42.0),
    ...     Row(id=3, value=None)
    ... ])
    >>> df2.select(
    ...     df2['value'].eqNullSafe(None),
    ...     df2['value'].eqNullSafe(float('NaN')),
    ...     df2['value'].eqNullSafe(42.0)
    ... ).show()
    +----------------+---------------+----------------+
    |(value <=> NULL)|(value <=> NaN)|(value <=> 42.0)|
    +----------------+---------------+----------------+
    |           false|           true|           false|
    |           false|          false|            true|
    |            true|          false|           false|
    +----------------+---------------+----------------+

    .. note:: Unlike Pandas, PySpark doesn't consider NaN values to be NULL.
       See the `NaN Semantics`_ for details.
    .. _NaN Semantics:
       https://spark.apache.org/docs/latest/sql-programming-guide.html#nan-semantics
    .. versionadded:: 2.3.0
    """"""
    eqNullSafe = _bin_op(""eqNullSafe"", _eqNullSafe_doc)

    # `and`, `or`, `not` cannot be overloaded in Python,
    # so use bitwise operators as boolean operators
    __and__ = _bin_op('and')
    __or__ = _bin_op('or')
    __invert__ = _func_op('not')
    __rand__ = _bin_op(""and"")
    __ror__ = _bin_op(""or"")

    # container operators
    def __contains__(self, item):
        raise ValueError(""Cannot apply 'in' operator against a column: please use 'contains' ""
                         ""in a string column or 'array_contains' function for an array column."")

    # bitwise operators
    _bitwiseOR_doc = """"""
    Compute bitwise OR of this expression with another expression.

    :param other: a value or :class:`Column` to calculate bitwise or(|) against
                  this :class:`Column`.

    >>> from pyspark.sql import Row
    >>> df = spark.createDataFrame([Row(a=170, b=75)])
    >>> df.select(df.a.bitwiseOR(df.b)).collect()
    [Row((a | b)=235)]
    """"""
    _bitwiseAND_doc = """"""
    Compute bitwise AND of this expression with another expression.

    :param other: a value or :class:`Column` to calculate bitwise and(&) against
                  this :class:`Column`.

    >>> from pyspark.sql import Row
    >>> df = spark.createDataFrame([Row(a=170, b=75)])
    >>> df.select(df.a.bitwiseAND(df.b)).collect()
    [Row((a & b)=10)]
    """"""
    _bitwiseXOR_doc = """"""
    Compute bitwise XOR of this expression with another expression.

    :param other: a value or :class:`Column` to calculate bitwise xor(^) against
                  this :class:`Column`.

    >>> from pyspark.sql import Row
    >>> df = spark.createDataFrame([Row(a=170, b=75)])
    >>> df.select(df.a.bitwiseXOR(df.b)).collect()
    [Row((a ^ b)=225)]
    """"""

    bitwiseOR = _bin_op(""bitwiseOR"", _bitwiseOR_doc)
    bitwiseAND = _bin_op(""bitwiseAND"", _bitwiseAND_doc)
    bitwiseXOR = _bin_op(""bitwiseXOR"", _bitwiseXOR_doc)

    @since(1.3)
    def getItem(self, key):
        """"""
        An expression that gets an item at position ``ordinal`` out of a list,
        or gets an item by key out of a dict.

        >>> df = spark.createDataFrame([([1, 2], {""key"": ""value""})], [""l"", ""d""])
        >>> df.select(df.l.getItem(0), df.d.getItem(""key"")).show()
        +----+------+
        |l[0]|d[key]|
        +----+------+
        |   1| value|
        +----+------+
        >>> df.select(df.l[0], df.d[""key""]).show()
        +----+------+
        |l[0]|d[key]|
        +----+------+
        |   1| value|
        +----+------+
        """"""
        return self[key]

    @since(1.3)
    def getField(self, name):
        """"""
        An expression that gets a field by name in a StructField.

        >>> from pyspark.sql import Row
        >>> df = spark.createDataFrame([Row(r=Row(a=1, b=""b""))])
        >>> df.select(df.r.getField(""b"")).show()
        +---+
        |r.b|
        +---+
        |  b|
        +---+
        >>> df.select(df.r.a).show()
        +---+
        |r.a|
        +---+
        |  1|
        +---+
        """"""
        return self[name]

    def __getattr__(self, item):
        if item.startswith(""__""):
            raise AttributeError(item)
        return self.getField(item)

    def __getitem__(self, k):
        if isinstance(k, slice):
            if k.step is not None:
                raise ValueError(""slice with step is not supported."")
            return self.substr(k.start, k.stop)
        else:
            return _bin_op(""apply"")(self, k)

    def __iter__(self):
        raise TypeError(""Column is not iterable"")

    # string methods
    _contains_doc = """"""
    Contains the other element. Returns a boolean :class:`Column` based on a string match.

    :param other: string in line

    >>> df.filter(df.name.contains('o')).collect()
    [Row(age=5, name=u'Bob')]
    """"""
    _rlike_doc = """"""
    SQL RLIKE expression (LIKE with Regex). Returns a boolean :class:`Column` based on a regex
    match.

    :param other: an extended regex expression

    >>> df.filter(df.name.rlike('ice$')).collect()
    [Row(age=2, name=u'Alice')]
    """"""
    _like_doc = """"""
    SQL like expression. Returns a boolean :class:`Column` based on a SQL LIKE match.

    :param other: a SQL LIKE pattern

    See :func:`rlike` for a regex version

    >>> df.filter(df.name.like('Al%')).collect()
    [Row(age=2, name=u'Alice')]
    """"""
    _startswith_doc = """"""
    String starts with. Returns a boolean :class:`Column` based on a string match.

    :param other: string at start of line (do not use a regex `^`)

    >>> df.filter(df.name.startswith('Al')).collect()
    [Row(age=2, name=u'Alice')]
    >>> df.filter(df.name.startswith('^Al')).collect()
    []
    """"""
    _endswith_doc = """"""
    String ends with. Returns a boolean :class:`Column` based on a string match.

    :param other: string at end of line (do not use a regex `$`)

    >>> df.filter(df.name.endswith('ice')).collect()
    [Row(age=2, name=u'Alice')]
    >>> df.filter(df.name.endswith('ice$')).collect()
    []
    """"""

    contains = ignore_unicode_prefix(_bin_op(""contains"", _contains_doc))
    rlike = ignore_unicode_prefix(_bin_op(""rlike"", _rlike_doc))
    like = ignore_unicode_prefix(_bin_op(""like"", _like_doc))
    startswith = ignore_unicode_prefix(_bin_op(""startsWith"", _startswith_doc))
    endswith = ignore_unicode_prefix(_bin_op(""endsWith"", _endswith_doc))

    @ignore_unicode_prefix
    @since(1.3)
    def substr(self, startPos, length):
        """"""
        Return a :class:`Column` which is a substring of the column.

        :param startPos: start position (int or Column)
        :param length:  length of the substring (int or Column)

        >>> df.select(df.name.substr(1, 3).alias(""col"")).collect()
        [Row(col=u'Ali'), Row(col=u'Bob')]
        """"""
        if type(startPos) != type(length):
            raise TypeError(""Can not mix the type"")
        if isinstance(startPos, (int, long)):
            jc = self._jc.substr(startPos, length)
        elif isinstance(startPos, Column):
            jc = self._jc.substr(startPos._jc, length._jc)
        else:
            raise TypeError(""Unexpected type: %s"" % type(startPos))
        return Column(jc)

    @ignore_unicode_prefix
    @since(1.5)
    def isin(self, *cols):
        """"""
        A boolean expression that is evaluated to true if the value of this
        expression is contained by the evaluated values of the arguments.

        >>> df[df.name.isin(""Bob"", ""Mike"")].collect()
        [Row(age=5, name=u'Bob')]
        >>> df[df.age.isin([1, 2, 3])].collect()
        [Row(age=2, name=u'Alice')]
        """"""
        if len(cols) == 1 and isinstance(cols[0], (list, set)):
            cols = cols[0]
        cols = [c._jc if isinstance(c, Column) else _create_column_from_literal(c) for c in cols]
        sc = SparkContext._active_spark_context
        jc = getattr(self._jc, ""isin"")(_to_seq(sc, cols))
        return Column(jc)

    # order
    _asc_doc = """"""
    Returns a sort expression based on the ascending order of the given column name

    >>> from pyspark.sql import Row
    >>> df = spark.createDataFrame([Row(name=u'Tom', height=80), Row(name=u'Alice', height=None)])
    >>> df.select(df.name).orderBy(df.name.asc()).collect()
    [Row(name=u'Alice'), Row(name=u'Tom')]
    """"""
    _desc_doc = """"""
    Returns a sort expression based on the descending order of the given column name.

    >>> from pyspark.sql import Row
    >>> df = spark.createDataFrame([Row(name=u'Tom', height=80), Row(name=u'Alice', height=None)])
    >>> df.select(df.name).orderBy(df.name.desc()).collect()
    [Row(name=u'Tom'), Row(name=u'Alice')]
    """"""

    asc = ignore_unicode_prefix(_unary_op(""asc"", _asc_doc))
    desc = ignore_unicode_prefix(_unary_op(""desc"", _desc_doc))

    _isNull_doc = """"""
    True if the current expression is null.

    >>> from pyspark.sql import Row
    >>> df = spark.createDataFrame([Row(name=u'Tom', height=80), Row(name=u'Alice', height=None)])
    >>> df.filter(df.height.isNull()).collect()
    [Row(height=None, name=u'Alice')]
    """"""
    _isNotNull_doc = """"""
    True if the current expression is NOT null.

    >>> from pyspark.sql import Row
    >>> df = spark.createDataFrame([Row(name=u'Tom', height=80), Row(name=u'Alice', height=None)])
    >>> df.filter(df.height.isNotNull()).collect()
    [Row(height=80, name=u'Tom')]
    """"""

    isNull = ignore_unicode_prefix(_unary_op(""isNull"", _isNull_doc))
    isNotNull = ignore_unicode_prefix(_unary_op(""isNotNull"", _isNotNull_doc))

    @since(1.3)
    def alias(self, *alias, **kwargs):
        """"""
        Returns this column aliased with a new name or names (in the case of expressions that
        return more than one column, such as explode).

        :param alias: strings of desired column names (collects all positional arguments passed)
        :param metadata: a dict of information to be stored in ``metadata`` attribute of the
            corresponding :class: `StructField` (optional, keyword only argument)

        .. versionchanged:: 2.2
           Added optional ``metadata`` argument.

        >>> df.select(df.age.alias(""age2"")).collect()
        [Row(age2=2), Row(age2=5)]
        >>> df.select(df.age.alias(""age3"", metadata={'max': 99})).schema['age3'].metadata['max']
        99
        """"""

        metadata = kwargs.pop('metadata', None)

        sc = SparkContext._active_spark_context
        if len(alias) == 1:
            if metadata:
                jmeta = sc._jvm.org.apache.spark.sql.types.Metadata.fromJson(
                    json.dumps(metadata))
                return Column(getattr(self._jc, ""as"")(alias[0], jmeta))
            else:
                return Column(getattr(self._jc, ""as"")(alias[0]))
        else:
            if metadata:
                raise ValueError('metadata can only be provided for a single column')
            return Column(getattr(self._jc, ""as"")(_to_seq(sc, list(alias))))

    name = copy_func(alias, sinceversion=2.0, doc="":func:`name` is an alias for :func:`alias`."")

    @ignore_unicode_prefix
    @since(1.3)
    def cast(self, dataType):
        """""" Convert the column into type ``dataType``.

        >>> df.select(df.age.cast(""string"").alias('ages')).collect()
        [Row(ages=u'2'), Row(ages=u'5')]
        >>> df.select(df.age.cast(StringType()).alias('ages')).collect()
        [Row(ages=u'2'), Row(ages=u'5')]
        """"""
        if isinstance(dataType, basestring):
            jc = self._jc.cast(dataType)
        elif isinstance(dataType, DataType):
            from pyspark.sql import SparkSession
            spark = SparkSession.builder.getOrCreate()
            jdt = spark._jsparkSession.parseDataType(dataType.json())
            jc = self._jc.cast(jdt)
        else:
            raise TypeError(""unexpected type: %s"" % type(dataType))
        return Column(jc)

    astype = copy_func(cast, sinceversion=1.4, doc="":func:`astype` is an alias for :func:`cast`."")

    @since(1.3)
    def between(self, lowerBound, upperBound):
        """"""
        A boolean expression that is evaluated to true if the value of this
        expression is between the given columns.

        >>> df.select(df.name, df.age.between(2, 4)).show()
        +-----+---------------------------+
        | name|((age >= 2) AND (age <= 4))|
        +-----+---------------------------+
        |Alice|                       true|
        |  Bob|                      false|
        +-----+---------------------------+
        """"""
        return (self >= lowerBound) & (self <= upperBound)

    @since(1.4)
    def when(self, condition, value):
        """"""
        Evaluates a list of conditions and returns one of multiple possible result expressions.
        If :func:`Column.otherwise` is not invoked, None is returned for unmatched conditions.

        See :func:`pyspark.sql.functions.when` for example usage.

        :param condition: a boolean :class:`Column` expression.
        :param value: a literal value, or a :class:`Column` expression.

        >>> from pyspark.sql import functions as F
        >>> df.select(df.name, F.when(df.age > 4, 1).when(df.age < 3, -1).otherwise(0)).show()
        +-----+------------------------------------------------------------+
        | name|CASE WHEN (age > 4) THEN 1 WHEN (age < 3) THEN -1 ELSE 0 END|
        +-----+------------------------------------------------------------+
        |Alice|                                                          -1|
        |  Bob|                                                           1|
        +-----+------------------------------------------------------------+
        """"""
        if not isinstance(condition, Column):
            raise TypeError(""condition should be a Column"")
        v = value._jc if isinstance(value, Column) else value
        jc = self._jc.when(condition._jc, v)
        return Column(jc)

    @since(1.4)
    def otherwise(self, value):
        """"""
        Evaluates a list of conditions and returns one of multiple possible result expressions.
        If :func:`Column.otherwise` is not invoked, None is returned for unmatched conditions.

        See :func:`pyspark.sql.functions.when` for example usage.

        :param value: a literal value, or a :class:`Column` expression.

        >>> from pyspark.sql import functions as F
        >>> df.select(df.name, F.when(df.age > 3, 1).otherwise(0)).show()
        +-----+-------------------------------------+
        | name|CASE WHEN (age > 3) THEN 1 ELSE 0 END|
        +-----+-------------------------------------+
        |Alice|                                    0|
        |  Bob|                                    1|
        +-----+-------------------------------------+
        """"""
        v = value._jc if isinstance(value, Column) else value
        jc = self._jc.otherwise(v)
        return Column(jc)

    @since(1.4)
    def over(self, window):
        """"""
        Define a windowing column.

        :param window: a :class:`WindowSpec`
        :return: a Column

        >>> from pyspark.sql import Window
        >>> window = Window.partitionBy(""name"").orderBy(""age"").rowsBetween(-1, 1)
        >>> from pyspark.sql.functions import rank, min
        >>> # df.select(rank().over(window), min('age').over(window))
        """"""
        from pyspark.sql.window import WindowSpec
        if not isinstance(window, WindowSpec):
            raise TypeError(""window should be WindowSpec"")
        jc = self._jc.over(window._jspec)
        return Column(jc)

    def __nonzero__(self):
        raise ValueError(""Cannot convert column into bool: please use '&' for 'and', '|' for 'or', ""
                         ""'~' for 'not' when building DataFrame boolean expressions."")
    __bool__ = __nonzero__

    def __repr__(self):
        return 'Column<%s>' % self._jc.toString().encode('utf8')


def _test():
    import doctest
    from pyspark.sql import SparkSession
    import pyspark.sql.column
    globs = pyspark.sql.column.__dict__.copy()
    spark = SparkSession.builder\
        .master(""local[4]"")\
        .appName(""sql.column tests"")\
        .getOrCreate()
    sc = spark.sparkContext
    globs['spark'] = spark
    globs['df'] = sc.parallelize([(2, 'Alice'), (5, 'Bob')]) \
        .toDF(StructType([StructField('age', IntegerType()),
                          StructField('name', StringType())]))

    (failure_count, test_count) = doctest.testmod(
        pyspark.sql.column, globs=globs,
        optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE | doctest.REPORT_NDIFF)
    spark.stop()
    if failure_count:
        exit(-1)


if __name__ == ""__main__"":
    _test()
"
