image_directory,isComplete,raw_code,code,caption,hasAssert
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p460.jpg,True,"The image contains Verilog code, which I'll write out for you:

```verilog
import ""DPI-C"" function chandle counter7_new();
import ""DPI-C"" function void counter7
   (input chandle inst,
    output bit [6:0] out,
    input bit [6:0] in,
    input bit reset, load);

// Test two instances of the counter
program automatic test;

    bit [6:0] o1, o2, i1, i2;
    bit reset, load, clk;
    chandle inst1, inst2; // Points to storage in C

    initial begin
        inst1 = counter7_new();
        inst2 = counter7_new();
        fork
            forever #10 clk = ~clk;
            forever @(posedge clk) begin
                counter7(inst1, o1, i1, reset, load);
                counter7(inst2, o2, i2, reset, load);
            end
        join_none

        reset = 0; // Initialize signals
        load = 0;
        i1 = 120;
        i2 = 10;

        @(negedge clk) load = 1; // Load inputs
        @(negedge clk) load = 0; // Count
        @(negedge clk) $finish;
    end
endprogram
```

This snippet of code shows a testbench for a 7-bit counter with per-instance storage. It imports two ""DPI-C"" functions (`chandle counter7_new();` and `void counter7()`) and then sets up a test program to test two instances of the counter. Events are triggered on the positive edge of a clock signal, and it manipulates `load` and `reset` signals as part of the test sequence.","
import ""DPI-C"" function chandle counter7_new();
import ""DPI-C"" function void counter7
   (input chandle inst,
    output bit [6:0] out,
    input bit [6:0] in,
    input bit reset, load);

// Test two instances of the counter
program automatic test;

    bit [6:0] o1, o2, i1, i2;
    bit reset, load, clk;
    chandle inst1, inst2; // Points to storage in C

    initial begin
        inst1 = counter7_new();
        inst2 = counter7_new();
        fork
            forever #10 clk = ~clk;
            forever @(posedge clk) begin
                counter7(inst1, o1, i1, reset, load);
                counter7(inst2, o2, i2, reset, load);
            end
        join_none

        reset = 0; // Initialize signals
        load = 0;
        i1 = 120;
        i2 = 10;

        @(negedge clk) load = 1; // Load inputs
        @(negedge clk) load = 0; // Count
        @(negedge clk) $finish;
    end
endprogram
",Verilog code example for testing a 7-bit counter with DPI-C interface for connecting C routines.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p156.jpg,True,"The image contains a snippet of Verilog code, specifically defining a property. Here is the code:

```verilog
property abc;
  @(posedge clk) a |=> b[=2:5] ##1 c;
endproperty
```

The code shows a property declaration using the SystemVerilog Assertion (SVA) syntax, which is used within the Verilog hardware description language to assert logical properties in simulation and formal verification.","
property abc;
  @(posedge clk) a |=> b[=2:5] ##1 c;
endproperty
","""Explaining Verilog Non-consecutive Repetition Operators with Examples and Simulation Results""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p306.jpg,True,"The image contains code written in the Verilog/SystemVerilog language, used in hardware design and verification. Here is the code extracted from the image:

```verilog
function void Environment::build();
    // Initialize mailboxes
    gen2agt = new();
    agt2drv = new();
    mon2chk = new();

    // Initialize transactors
    gen = new(gen2agt);
    agt = new(gen2agt, agt2drv);
    drv = new(agt2drv);
    mon = new(mon2chk);
    chk = new(mon2chk);
    scb = new(cfg);
endfunction

task Environment::run();
    fork
        gen.run(cfg.run_for_n_trans);
        agt.run();
        drv.run();
        mon.run();
        chk.run();
        scb.run(cfg.run_for_n_trans);
    join
endtask

task Environment::wrap_up();
    fork
        gen.wrap_up();
        agt.wrap_up();
        drv.wrap_up();
        mon.wrap_up();
        chk.wrap_up();
        scb.wrap_up();
    join
endtask
```

The code shows the definition of functions and tasks within a class named `Environment`, which is likely part of a testbench infrastructure. The functions and tasks are used to initialize components, run operations, and clean up after execution.","
function void Environment::build();
    // Initialize mailboxes
    gen2agt = new();
    agt2drv = new();
    mon2chk = new();

    // Initialize transactors
    gen = new(gen2agt);
    agt = new(gen2agt, agt2drv);
    drv = new(agt2drv);
    mon = new(mon2chk);
    chk = new(mon2chk);
    scb = new(cfg);
endfunction

task Environment::run();
    fork
        gen.run(cfg.run_for_n_trans);
        agt.run();
        drv.run();
        mon.run();
        chk.run();
        scb.run(cfg.run_for_n_trans);
    join
endtask

task Environment::wrap_up();
    fork
        gen.wrap_up();
        agt.wrap_up();
        drv.wrap_up();
        mon.wrap_up();
        chk.wrap_up();
        scb.wrap_up();
    join
endtask
","Caption: ""Example of Verilog code for building a testbench using functions and tasks to initialize mailboxes, transactors, run simulations, and wrap up in an object-oriented approach.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p478.jpg,True,"There are snippets of code in the image. Here they are:

```verilog
m1: assume property (@(global_clock) i != $future_gclk(o));
```

And:

```verilog
type (a, ,, (posedge clk)) pa;
always @(posedge clk) pa <= a;
```

These are Verilog code examples related to future and past value functions in formal verification.","
m1: assume property (@(global_clock) i != $future_gclk(o));


type (a, ,, (posedge clk)) pa;
always @(posedge clk) pa <= a;
","""Exploring the use of future and past value functions in SystemVerilog for formal verification and the impact on efficiency and simulation load.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p474.jpg,True,"```verilog
import ""DPI-C"" function void view_pack(input bit [63:0] b64 []);

program automatic test;
  bit [1:0][0:3][6:-1] bpack[9:1];

  initial begin
    foreach(bpack[i]) bpack[i] = i;
    bpack[2] = 64'h12345678_90abcdef;
    
    $display(""SV: bpack[2]=%h"", bpack[2]); // 64 bits
    $display(""SV: bpack[2][0]=%h"", bpack[2][0]); // 32 bits
    $display(""SV: bpack[2][0][0]=%h"", bpack[2][0][0]); // 8 bits

    view_pack(bpack);
  end
endprogram : test
```

```c
void view_pack(const svOpenArrayHandle h) {
  int i;

  for (i=svLow(h,1); i<=svHigh(h,1); i++)
    io_printf(""C: b64[%d]=%llx\n"", i, *(long long int *)svGetArrElemPtr1(h, i));
}
```","
import ""DPI-C"" function void view_pack(input bit [63:0] b64 []);

program automatic test;
  bit [1:0][0:3][6:-1] bpack[9:1];

  initial begin
    foreach(bpack[i]) bpack[i] = i;
    bpack[2] = 64'h12345678_90abcdef;
    
    $display(""SV: bpack[2]=%h"", bpack[2]); // 64 bits
    $display(""SV: bpack[2][0]=%h"", bpack[2][0]); // 32 bits
    $display(""SV: bpack[2][0][0]=%h"", bpack[2][0][0]); // 8 bits

    view_pack(bpack);
  end
endprogram : test

view_pack(const svOpenArrayHandle h) {
  int i;

  for (i=svLow(h,1); i<=svHigh(h,1); i++)
    io_printf(""C: b64[%d]=%llx\n"", i, *(long long int *)svGetArrElemPtr1(h, i));
}
",Sample code demonstrating the use of packed open arrays in SystemVerilog and interfacing with C code using DPI-C.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p142.jpg,True,"The image contains Verilog code related to a property specification using SystemVerilog assertions. Here is the code from the image:

```verilog
property checkConsecutive (clk,Sig,numClk);
    @(posedge clk) disable iff (rst) Sig |-> not (Sig[*numClk]);
endproperty

checkADS: assert property(checkConsecutive(busClk, ADS,2))
          else $display($stime,,,"" Error: ADS asserted consecutively for 2 Clocks"");
```","
property checkConsecutive (clk,Sig,numClk);
    @(posedge clk) disable iff (rst) Sig |-> not (Sig[*numClk]);
endproperty

checkADS: assert property(checkConsecutive(busClk, ADS,2))
          else $display($stime,,,"" Error: ADS asserted consecutively for 2 Clocks"");
","Caption: ""Example of a SystemVerilog assertion to check that a signal is not asserted for more than 2 consecutive clock cycles.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p336.jpg,True,"The image contains two excerpts of Verilog code. Here they are:

First snippet:
```verilog
always @(*) begin
    if (c1_long) begin
        for (int i=0; i<4; i++) begin
            dreg[i] <= tr[i+1];
            a19: assert property (@(posedge clk) dreg[i] |=> r12);
        end
    end
end
```

Second snippet:
```verilog
always @(*) begin: B1
    r11 <= v11 | v12;
    a20_1: assert property (@(posedge clk) v11 |=> v12);
    #5;
    r12 <= v12 & v13;
    a20_2: assert property (@(posedge clk) r11 |=> r12);
end
```","
always @(*) begin
    if (c1_long) begin
        for (int i=0; i<4; i++) begin
            dreg[i] <= tr[i+1];
            a19: assert property (@(posedge clk) dreg[i] |=> r12);
        end
    end
end


always @(*) begin: B1
    r11 <= v11 | v12;
    a20_1: assert property (@(posedge clk) v11 |=> v12);
    #5;
    r12 <= v12 & v13;
    a20_2: assert property (@(posedge clk) r11 |=> r12);
end
","Caption: ""Understanding the behavior of Verilog assertions within for loops and procedural blocks, highlighting how they interact with the procedural assertion queue.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p321.jpg,True,"The image contains snippets of code, which I will transcribe for you:

Read a string and use it immediately:

```c
char *string_p; /* string pointer only, no storage */
string_p = tf_strgetp(1, 'b');
io_printf(""string_p points to %s\n"", string_p);
```

Read a string and copy it to application-allocated storage for later use:

```c
char *string_p; /* string pointer only, no storage */
char *string_keep; /* another string pointer only */
string_p = tf_strgetp(1, 'b'); /* get string from 1st arg */
string_keep = malloc(strlen(string_p)+1);
strcpy(string, string_p); /* save string for later use */
```

Please note that in the second code snippet there seems to be a minor error. The `strcpy` function should use `string_keep` as the destination for the copy operation rather than `string` (which has not been declared). The correct line should probably be:

```c
strcpy(string_keep, string_p); /* save string for later use */
```","*string_p; /* string pointer only, no storage */
string_p = tf_strgetp(1, 'b');
io_printf(""string_p points to %s\n"", string_p);

*string_p; /* string pointer only, no storage */
char *string_keep; /* another string pointer only */
string_p = tf_strgetp(1, 'b'); /* get string from 1st arg */
string_keep = malloc(strlen(string_p)+1);
strcpy(string, string_p); /* save string for later use */

y(string_keep, string_p); /* save string for later use */
","Caption: ""Verilog PLI usage for handling string buffers via temporary pointers in C.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p335.jpg,True,"The image contains a piece of Verilog code, specifically a function prototype. Here is the code from the image:

```c
char *tf_longtime_tostr(lowtime, hightime)
int lowtime; /* lower (right-most) 32-bits of a 64-bit unsigned integer. */
int hightime; /* upper (left-most) 32-bits of a 64-bit unsigned integer. */
```

This function, `tf_longtime_tostr`, converts a 64-bit simulation time represented as a pair of 32-bit integers into a character string, and it returns a pointer to this string. The string is stored in temporary simulation-allocated storage.","*tf_longtime_tostr(lowtime, hightime)
int lowtime; /* lower (right-most) 32-bits of a 64-bit unsigned integer. */
int hightime; /* upper (left-most) 32-bits of a 64-bit unsigned integer. */
","""Table of time unit values in Verilog and documentation for a utility routine to convert 64-bit time values to strings.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p448.jpg,True,"```verilog
while (mif.Rdy_Dtack==0) #10;
endtask : HostRead

task CPU_driver::run();
  CellCfgType CellFwd;
  Initialize_Host();

  // Configure through Host interface
  repeat (10) @(negedge clk);
  $write(""Memory: Loading ... "");
  for (int i=0; i<=255; i++) begin
    CellFwd.FWD = $urandom();
`ifdef FWDALL
    CellFwd.FWD = '1
`endif
    CellFwd.VPI = i;
    HostWrite(i, CellFwd);
    lookup[i] = CellFwd;
  end

  // Verify memory
  $write(""Verifying ..."");
  for (int i=0; i<=255; i++) begin
    HostRead(i, CellFwd);
    if (lookup[i] != CellFwd) begin
      $display(""FATAL, Mem Loc 0x%xx contains 0x%xx, expected 0x%xx"",
               i, CellFwd, lookup[i]);

      $finish;
    end
  end
  $display(""Verified"");

endtask : run
```","
while (mif.Rdy_Dtack==0) #10;
endtask : HostRead

task CPU_driver::run();
  CellCfgType CellFwd;
  Initialize_Host();

  // Configure through Host interface
  repeat (10) @(negedge clk);
  $write(""Memory: Loading ... "");
  for (int i=0; i<=255; i++) begin
    CellFwd.FWD = $urandom();
`ifdef FWDALL
    CellFwd.FWD = '1
`endif
    CellFwd.VPI = i;
    HostWrite(i, CellFwd);
    lookup[i] = CellFwd;
  end

  // Verify memory
  $write(""Verifying ..."");
  for (int i=0; i<=255; i++) begin
    HostRead(i, CellFwd);
    if (lookup[i] != CellFwd) begin
      $display(""FATAL, Mem Loc 0x%xx contains 0x%xx, expected 0x%xx"",
               i, CellFwd, lookup[i]);

      $finish;
    end
  end
  $display(""Verified"");

endtask : run
","Caption: ""Verilog task for memory initialization and verification, highlighting configuration through a host interface and random memory checking.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p453.jpg,True,"```verilog
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
/***********************************************************
 * calltf routine: turns on asynchronous callbacks to the misctf
 * routine whenever an argument to the system task changes value
 ***********************************************************/
int PLIbook_ScientificALU_calltf()
{
    tf_asynchon();
    return(0);
}

/***********************************************************
 * misctf routine: Serves as an interface between Verilog simulation
 * and the C model. Called whenever the C model inputs change value,
 * reads the input values, and passes the values to the C model, and
 * puts the C model outputs into simulation. Passes the instance
 * pointer of the Verilog system task which represents the C model
 * to serve as a unique flag within the C model.
 ***********************************************************/
int PLIbook_ScientificALU_misctf(int user_data, int reason, int paramvc)
{
    #define ALU_ENABLE  1 /* system task arg 1 is ALU enable input */
    #define ALU_A       2 /* system task arg 2 is ALU A input */
    #define ALU_B       3 /* system task arg 3 is ALU B input */
    #define ALU_OP      4 /* system task arg 4 is ALU opcode input */
    #define ALU_RESULT  5 /* system task arg 5 is ALU result output */
    #define ALU_EXCEPT  6 /* system task arg 6 is ALU exception output */
    #define ALU_ERROR   7 /* system task arg 7 is ALU error output */
    
    double  a, b, result;
    int     opcode, excep, err, enable;
    char    *instance_p;

    /* abort if misctf was not called for a task argument value change */
    if (reason != REASON_PARAMVC)
        return(0);

    /* abort if task argument that changed was a model output */
    if (paramvc == ALU_OP) /* model outputs are after model inputs */
        return(0);

    a       = tf_getrealp(ALU_A);
    b       = tf_getrealp(ALU_B);
    opcode  = tf_getp(ALU_OP);

    /* Obtain the instance pointer for this system task instance */
    instance_p = tf_getinstance();

    /****** Call C model *******/
}
```
The image contains Verilog code related to a combinational logic interface for a latched scientific ALU C model, including `calltf` and `misctf` routines.","
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
/***********************************************************
 * calltf routine: turns on asynchronous callbacks to the misctf
 * routine whenever an argument to the system task changes value
 ***********************************************************/
int PLIbook_ScientificALU_calltf()
{
    tf_asynchon();
    return(0);
}

/***********************************************************
 * misctf routine: Serves as an interface between Verilog simulation
 * and the C model. Called whenever the C model inputs change value,
 * reads the input values, and passes the values to the C model, and
 * puts the C model outputs into simulation. Passes the instance
 * pointer of the Verilog system task which represents the C model
 * to serve as a unique flag within the C model.
 ***********************************************************/
int PLIbook_ScientificALU_misctf(int user_data, int reason, int paramvc)
{
    #define ALU_ENABLE  1 /* system task arg 1 is ALU enable input */
    #define ALU_A       2 /* system task arg 2 is ALU A input */
    #define ALU_B       3 /* system task arg 3 is ALU B input */
    #define ALU_OP      4 /* system task arg 4 is ALU opcode input */
    #define ALU_RESULT  5 /* system task arg 5 is ALU result output */
    #define ALU_EXCEPT  6 /* system task arg 6 is ALU exception output */
    #define ALU_ERROR   7 /* system task arg 7 is ALU error output */
    
    double  a, b, result;
    int     opcode, excep, err, enable;
    char    *instance_p;

    /* abort if misctf was not called for a task argument value change */
    if (reason != REASON_PARAMVC)
        return(0);

    /* abort if task argument that changed was a model output */
    if (paramvc == ALU_OP) /* model outputs are after model inputs */
        return(0);

    a       = tf_getrealp(ALU_A);
    b       = tf_getrealp(ALU_B);
    opcode  = tf_getp(ALU_OP);

    /* Obtain the instance pointer for this system task instance */
    instance_p = tf_getinstance();

    /****** Call C model *******/
}
","""Example of Verilog PLI code for interfacing between Verilog simulations and a C model ALU.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p444.jpg,True,"The image contains Verilog code. Here is the code as seen in the image:

```verilog
property p;
logic [3:0] tag;
@(posedge clk) (req, tag = req_tag)
|=> s_eventually [1:18] ack && (ack_tag == tag);
endproperty
a: assert property (p);

default clocking ck @(posedge clk);
endclocking
initial begin // add to the test
$assertoff();
#104;
// start assertion just before
// the start time of failure
$asserton();
#2;
// stop assertion right after
// the failing attempt at time 105
$assertoff();
end

property p;
logic [3:0] tag;
(
  req, tag = req_tag, // make sure it triggered
  $display(""[%t] req asserted, tag %0d"", $time, tag)
)
|=> s_eventually [1:18] ack && (ack_tag == tag);
endproperty
a: assert property (p);
```

This code includes properties and assertions which are often used in formal verification to check that certain conditions hold in a design during simulation.","
property p;
logic [3:0] tag;
@(posedge clk) (req, tag = req_tag)
|=> s_eventually [1:18] ack && (ack_tag == tag);
endproperty
a: assert property (p);

default clocking ck @(posedge clk);
endclocking
initial begin // add to the test
$assertoff();
#104;
// start assertion just before
// the start time of failure
$asserton();
#2;
// stop assertion right after
// the failing attempt at time 105
$assertoff();
end

property p;
logic [3:0] tag;
(
  req, tag = req_tag, // make sure it triggered
  $display(""[%t] req asserted, tag %0d"", $time, tag)
)
|=> s_eventually [1:18] ack && (ack_tag == tag);
endproperty
a: assert property (p);
","Caption: ""Debugging an Assertion in Verilog: This excerpt covers the process of debugging an assertion under development, including a sample assertion code and the method to instrument the test.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p195.jpg,True,"```verilog
property bgcheck;
    @(posedge clk) bgack |= -> $countones(busgnt);
endproperty
```

The code shown defines a property named `bgcheck` in Verilog that checks for the presence of at least one '1' in the expression `busgnt` when the clock edge is at the positive edge (`posedge`) and `bgack` is high. If there's at least one '1', the implication operator `|->` indicates that the property is satisfied. The `$countones` system function is used for counting the number of '1's present in the expression `busgnt`.","
property bgcheck;
    @(posedge clk) bgack |= -> $countones(busgnt);
endproperty
","Caption: ""Example of using the SystemVerilog $countones function as a pass/fail check in a property.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p134.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
always @(posedge clock) begin
  temp1 = f(i1,o1);  // o1 will be updated every time
  temp2 = f(i2,o2);  // o2 will be updated every time
  if ( temp1 && temp2 )  // OK! no side effects
    mem[addr] <= data_in;
end
```","
always @(posedge clock) begin
  temp1 = f(i1,o1);  // o1 will be updated every time
  temp2 = f(i2,o2);  // o2 will be updated every time
  if ( temp1 && temp2 )  // OK! no side effects
    mem[addr] <= data_in;
end
","""Exploring Operator Gotchas in Verilog and How to Avoid Short-Circuiting Issues in Code""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p401.jpg,True,"The image contains a snippet of code, which appears to be part of a document discussing automatic termination proofs for programs. The code is related to a Windows device driver and it describes a loop that has a termination bug. Here is the code from the image:

```c
for (entry = DeviceExtension->ReadQueue.Flink;
     entry != &DeviceExtension->ReadQueue;
     entry = entry->Flink) {
    irp = (IRP *)((CHAR *)(entry)-(ULONG)(&((IRP *)0)->Tail.Overlay.ListEntry));
    stack = IoGetCurrentIrpStackLocation (irp);
    if (stack->FileObject == FileObject) {
        RemoveEntryList(entry);
        if (IoSetCancelRoutine (irp, NULL)) {
            return irp;
        } else {
            InitializeListHead (&irp->Tail.Overlay.ListEntry);
        }
    }
}
```

The code is accompanied by a caption explaining that it contains a termination bug which the paper addresses, and it notes that the bug can have catastrophic effects on the responsiveness of the computer when it occurs.","entry = DeviceExtension->ReadQueue.Flink;
     entry != &DeviceExtension->ReadQueue;
     entry = entry->Flink) {
    irp = (IRP *)((CHAR *)(entry)-(ULONG)(&((IRP *)0)->Tail.Overlay.ListEntry));
    stack = IoGetCurrentIrpStackLocation (irp);
    if (stack->FileObject == FileObject) {
        RemoveEntryList(entry);
        if (IoSetCancelRoutine (irp, NULL)) {
            return irp;
        } else {
            InitializeListHead (&irp->Tail.Overlay.ListEntry);
        }
    }
}
","""Example of a Windows device driver code snippet with a termination bug as described in a technical document discussing automatic termination proofs for programs with complex memory structures.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p110.jpg,True,"The image contains a syntax example and a specific example of SystemVerilog code related to sequence declaration. Here is the code:

Syntax for SystemVerilog sequence:
```verilog
sequence_declaration ::=
sequence sequence_identifier [sequence_formal_list ] ';'
        { assertion_variable_declaration }
        sequence_expr ';'
endsequence [ ':' sequence_identifier ]
```

Specific example provided in the image:
```verilog
sequence req_ack (req, del, ack);
    req ##[1:3] ack;  // ack occurs within 1 to 3 cycles after req
endsequence;
```

The syntax shows the general structure of a SystemVerilog sequence declaration, while the specific example demonstrates how to declare a sequence that uses the non-consecutive repetition operator `##[min:max]` to specify that the signal `ack` should occur within 1 to 3 cycles after the signal `req`.","
sequence_declaration ::=
sequence sequence_identifier [sequence_formal_list ] ';'
        { assertion_variable_declaration }
        sequence_expr ';'
endsequence [ ':' sequence_identifier ]


sequence req_ack (req, del, ack);
    req ##[1:3] ack;  // ack occurs within 1 to 3 cycles after req
endsequence;
","""Example of SystemVerilog sequence declaration and operations from a textbook on Assertion-Based Design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p493.jpg,True,"The image contains Verilog code, excerpts of which are as follows:

Embedded assertion code:
```verilog
// ...
a1: assert property (p);
// ...
```

Stand-alone assertion equivalent:
```verilog
assert property (@(posedge clk) en && !cond |->
```

Looping statement with assertions:
```verilog
property p(int i, j);
    a[i] |->
    ##[1:2] b[j];
endproperty : p

always @(posedge clk) begin : b1
// ...
for (int i = 0; i < 5; i++) begin : b2
    // ...
    for (int j = 0; j < i; j++) begin : b3
        // ...
        a1: assert property (p(i, j));
    end : b3
end : b2
end : b1
```

Equivalent stand-alone assertions:
```verilog
assert property (@(posedge clk) p(1, 0));
assert property (@(posedge clk) p(2, 0));
// ...
assert property (@(posedge clk) p(4, 3));
```","
// ...
a1: assert property (p);
// ...


assert property (@(posedge clk) en && !cond |->


property p(int i, j);
    a[i] |->
    ##[1:2] b[j];
endproperty : p

always @(posedge clk) begin : b1
// ...
for (int i = 0; i < 5; i++) begin : b2
    // ...
    for (int j = 0; j < i; j++) begin : b3
        // ...
        a1: assert property (p(i, j));
    end : b3
end : b2
end : b1


assert property (@(posedge clk) p(1, 0));
assert property (@(posedge clk) p(2, 0));
// ...
assert property (@(posedge clk) p(4, 3));
","Caption: ""Verilog code examples showing how to embed assertions within conditional and loop structures, and their equivalent stand-alone assertions for formal verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p484.jpg,True,"Here is the code from the image:

```c
else
    module_h = acc_handle_targ(i);
PLIbook_GetAllSignals(module_h);
acc_close();
return(0);
}

void PLIbook_GetAllSignals(handle module_h)
{
    handle signal_h;
    static int signal_types[6] = {accNet, accReg, accIntegerVar,
                                  accTimeVar, accRealVar, 0 };
    
    acc_initialize();
    io_printf(""\nAt time %s, signals in module %s (%s):\n"",
              tf_strgettime(),
              acc_fetch_fullname(module_h),
              acc_fetch_defname(module_h));
    signal_h = null;  /* start with known value for target handle */
    while (signal_h = acc_next(signal_types, module_h, signal_h)) {
        io_printf("" %-13s %-13s value is %s (hex)\n"",
                  acc_fetch_type_str(acc_fetch_fulltype(signal_h)),
                  acc_fetch_name(signal_h),
                  acc_fetch_value(signal_h, ""%h"", null));
    }
    acc_close();
    return;
}
```

This code is from ""The Verilog PLI Handbook, Part Two"" and discusses the usage of ACC routines within the PLI standard for Verilog simulations.","    module_h = acc_handle_targ(i);
PLIbook_GetAllSignals(module_h);
acc_close();
return(0);
}

void PLIbook_GetAllSignals(handle module_h)
{
    handle signal_h;
    static int signal_types[6] = {accNet, accReg, accIntegerVar,
                                  accTimeVar, accRealVar, 0 };
    
    acc_initialize();
    io_printf(""\nAt time %s, signals in module %s (%s):\n"",
              tf_strgettime(),
              acc_fetch_fullname(module_h),
              acc_fetch_defname(module_h));
    signal_h = null;  /* start with known value for target handle */
    while (signal_h = acc_next(signal_types, module_h, signal_h)) {
        io_printf("" %-13s %-13s value is %s (hex)\n"",
                  acc_fetch_type_str(acc_fetch_fulltype(signal_h)),
                  acc_fetch_name(signal_h),
                  acc_fetch_value(signal_h, ""%h"", null));
    }
    acc_close();
    return;
}
","""Excerpt from the Verilog PLI Handbook demonstrating the use of ACC routines within Verilog PLI applications.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p138.jpg,True,"The image contains two code examples written in Verilog. Below are the transcriptions of both:

Example 4-11 PLI assert always check
```verilog
$assert_always_ck (ck, reset_n, expression,
                   ""My optional assertion error message"")
```

Example 4-12 $assert_never within a CASE default branch
```verilog
case({a,b}) begin
  2’b01: s = c+4’b0001;
  2’b10: s = c-4’b0001;
  default: $assert_error(“Case default error”);
endcase
```","
$assert_always_ck (ck, reset_n, expression,
                   ""My optional assertion error message"")


case({a,b}) begin
  2’b01: s = c+4’b0001;
  2’b10: s = c-4’b0001;
  default: $assert_error(“Case default error”);
endcase
","Caption: ""Examples of Verilog PLI-based assertion checks used for design verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p108.jpg,True,"```verilog
module RAM #(parameter SIZE = 1024, A_WIDTH = 16, D_WIDTH = 31)
    (output logic [D_WIDTH-1:0] data_out,
     input logic [D_WIDTH-1:0] data_in,
     input logic [A_WIDTH-1:0] addr,  // 16 bit bus
     input logic                  read, write);

bit [D_WIDTH-1:0] mem_array [0:SIZE-1];  // 2-state array
                                          // GOTCHA! only need 10 bit index

assign data_out = read? mem_array[addr] : 'z;  // read from array
...
endmodule
```","
module RAM #(parameter SIZE = 1024, A_WIDTH = 16, D_WIDTH = 31)
    (output logic [D_WIDTH-1:0] data_out,
     input logic [D_WIDTH-1:0] data_in,
     input logic [A_WIDTH-1:0] addr,  // 16 bit bus
     input logic                  read, write);

bit [D_WIDTH-1:0] mem_array [0:SIZE-1];  // 2-state array
                                          // GOTCHA! only need 10 bit index

assign data_out = read? mem_array[addr] : 'z;  // read from array
...
endmodule
","""Verilog Gotcha: Risks of hidden errors with out-of-bounds array access in RTL simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p487.jpg,True,"The image contains a snippet of code related to property specification in formal verification, likely using SystemVerilog Assertions (SVA) based on the syntax. Here is the code from the image:

```verilog
always req |-> ##[1:700] gnt
```

The code specifies that always when the request signal `req` is asserted (true), the grant signal `gnt` must be asserted within a range from 1 to 700 clock cycles later. This is used to formalize a liveness property in the context of hardware verification.","
always req |-> ##[1:700] gnt
","""Exploring the concept of safety and liveness properties in the context of formal verification with an example of Verilog temporal logic for property specification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p490.jpg,True,"The image contains a section of a textbook discussing the Verilog Programming Language Interface (PLI), specifically about ACC (Access) routine error handling in the context of Verilog simulation tools. There is a snippet of C code provided in the image which I will transcribe for you:

```c
handle net_handle, module_handle;
char *net_name;

/* add code to read the name of a net from a file */
net_handle = acc_handle_by_name(net_name, module_handle);
if (acc_error_flag) {
    io_printf(""Net %s was could not be found\n"", net_name);
}
... /* use the net handle obtained */
```

Please note that there might be a small typo in the printed `io_printf` statement: ""was could not be found"" should read ""could not be found"". This C code example is using the ACC library to handle errors when working with Verilog simulations.","e net_handle, module_handle;
char *net_name;

/* add code to read the name of a net from a file */
net_handle = acc_handle_by_name(net_name, module_handle);
if (acc_error_flag) {
    io_printf(""Net %s was could not be found\n"", net_name);
}
... /* use the net handle obtained */
","This image shows a page from ""The Verilog PLI Handbook,"" outlining the error handling for ACC routines in Verilog PLI with an example C code fragment illustrating the usage of the global error flag `acc_error_flag`.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p28.jpg,True,"The image contains Verilog code. Here is the code as shown in the image:

```verilog
module fsm (...);

enum logic [1:0] {HOLD, LOAD, READY} state_e, nstate_e;
...
always_comb begin
  case (state_e)                             // OK, names match declarations
    HOLD: nstate_e = LOAD;                   // OK, names match declarations
    LOAD: nstate_e = READY;                  // OK, names match declarations
    READY: nstate_e = HOLD;                  // OK, names match declarations
  endcase
end
endmodule: fsm
```","
module fsm (...);

enum logic [1:0] {HOLD, LOAD, READY} state_e, nstate_e;
...
always_comb begin
  case (state_e)                             // OK, names match declarations
    HOLD: nstate_e = LOAD;                   // OK, names match declarations
    LOAD: nstate_e = READY;                  // OK, names match declarations
    READY: nstate_e = HOLD;                  // OK, names match declarations
  endcase
end
endmodule: fsm
",Corrected Verilog case-sensitivity example with naming conventions.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p104.jpg,True,"The image contains two Verilog code samples displaying the usage of enumerated types and conversions between enumerated and integer types in Verilog. Here are the code samples:

Sample 2.59:
```verilog
typedef enum {RED, BLUE, GREEN} color_e;
color_e color;
color = color.first;
do
    begin
        $display(""Color = %0d/%s"", color, color.name());
        color = color.next;
    end
while (color != color.first); // Done at wrap-around
```

Sample 2.60:
```verilog
typedef enum {RED, BLUE, GREEN} color_e;
color_e color, c2;
int c;

initial begin
    color = BLUE;             // Set to known good value
    c = color;                // Convert from enum to int (1)
    c++;                      // Increment int (2)
    if (!$cast(color, c))     // Cast int back to enum
        $display(""Cast failed for c=%0d"", c);
    $display(""Color is %0d / %s"", color, color.name());
    c++;                      // 3 is out-of-bounds for enum
    c2 = COLOR_E'(c);         // No type checking
    $display(""c2 is %0d / %s"", c2, c2.name());
end
```

These examples illustrate how to traverse through the members of an enumeration and how to convert between enumerated and integer types, including cases of out-of-bounds values.","
typedef enum {RED, BLUE, GREEN} color_e;
color_e color;
color = color.first;
do
    begin
        $display(""Color = %0d/%s"", color, color.name());
        color = color.next;
    end
while (color != color.first); // Done at wrap-around


typedef enum {RED, BLUE, GREEN} color_e;
color_e color, c2;
int c;

initial begin
    color = BLUE;             // Set to known good value
    c = color;                // Convert from enum to int (1)
    c++;                      // Increment int (2)
    if (!$cast(color, c))     // Cast int back to enum
        $display(""Cast failed for c=%0d"", c);
    $display(""Color is %0d / %s"", color, color.name());
    c++;                      // 3 is out-of-bounds for enum
    c2 = COLOR_E'(c);         // No type checking
    $display(""c2 is %0d / %s"", c2, c2.name());
end
","""Verilog Enumeration and Type Casting Examples""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p96.jpg,True,"The image contains an example of code related to PSL (Property Specification Language) used in conjunction with Verilog. Here's the code from the image:

Example 3-17 PSL SERE - sequence of Boolean expressions
```
{A&B; C|D; E->F}
```

Example 3-18 PSL SERE for req, ack, !halt sequence
```
assert always {req -> next {ack; !halt}};
```

This example shows how sequences of Boolean expressions are used in PSL to create assertions in hardware verification.","C|D; E->F}

 always {req -> next {ack; !halt}};
","Caption: ""Educational material explaining Property Specification Language (PSL) using Sugar Extended Regular Expressions (SEREs) for sequence matching in Verilog code, with examples of assertion-based design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p108.jpg,True,"The image contains Verilog code. Here is the code from the image:

```verilog
c1: cover (ctr_max) $display(""Counter reached its maximal value"");

wire [15:0] bus_drivers;
c2: cover #0 (bus_drivers !== 16'bz) $display(""Bus is active"");
```","
c1: cover (ctr_max) $display(""Counter reached its maximal value"");

wire [15:0] bus_drivers;
c2: cover #0 (bus_drivers !== 16'bz) $display(""Bus is active"");
",An excerpt explaining immediate and deferred coverage with Verilog code examples for performance analysis.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p227.jpg,True,"The image contains Verilog code in the form of SystemVerilog Assertions (SVA). Here is the code extracted from the image:

```verilog
property p_tRCD_not;
  @(posedge clk)
    `s_active |-> not ##[0:(tRCD - 1)]
        (`s_read || `s_write || `s_burst_read
        || `s_burst_write);
endproperty

property p_tRCD;
  @(posedge clk)
    `s_active |-> ##[tRCD:10] (`s_read || `s_write ||
       `s_burst_read || `s_burst_write);
endproperty

a_tRCD_not: assert property (p_tRCD_not);
a_tRCD: assert property (p_tRCD);

c_tRCD_not: cover property (p_tRCD_not);
c_tRCD: cover property (p_tRCD);
```

The code defines two properties `p_tRCD_not` and `p_tRCD`, along with corresponding `assert` and `cover` statements for each property. These assertions are used to check memory read/write timing constraints in hardware description.","
property p_tRCD_not;
  @(posedge clk)
    `s_active |-> not ##[0:(tRCD - 1)]
        (`s_read || `s_write || `s_burst_read
        || `s_burst_write);
endproperty

property p_tRCD;
  @(posedge clk)
    `s_active |-> ##[tRCD:10] (`s_read || `s_write ||
       `s_burst_read || `s_burst_write);
endproperty

a_tRCD_not: assert property (p_tRCD_not);
a_tRCD: assert property (p_tRCD);

c_tRCD_not: cover property (p_tRCD_not);
c_tRCD: cover property (p_tRCD);
","The image is a page from a technical document discussing SystemVerilog Assertions (SVA) for memory operations. It includes timing diagrams and properties written in SystemVerilog to verify the correct timing behavior for read/write commands in relation to an active command. The specific properties `p_tRCD_not` and `p_tRCD` ensure that read/write commands are not issued too soon after an active command, and within a valid time window, respectively.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p354.jpg,True,"The image contains Verilog code. Here it is transcribed:

```verilog
module CPU;
logic snoop, cache;
sequence s;
    (CPU.snoop || CPU.cache) ##1 cache;
endsequence : s
...
endmodule : top

module m(input clock);
logic [15:0] a, b;
logic c, d;
typedef bit [15:0] bits;
...
let ones_match(bits x, y) = x == y;
let same(logic x, y) = x === y;

always_comb
a1: assert (ones_match(a, b));
//Note: the actuals 'a' and 'b' are of type 'logic', while the
//formals 'x', 'y' are of type 'bits'

property toggles(bit x, y);
    same(x, y) |=> !same(x, y);
    //Note: the actuals 'x', 'y' are of type 'bit', while the
    //formals 'x', 'y' are of type 'logic'
endproperty

a2: assert property (@(posedge clock) toggles(c, d));
endmodule : m
```","
module CPU;
logic snoop, cache;
sequence s;
    (CPU.snoop || CPU.cache) ##1 cache;
endsequence : s
...
endmodule : top

module m(input clock);
logic [15:0] a, b;
logic c, d;
typedef bit [15:0] bits;
...
let ones_match(bits x, y) = x == y;
let same(logic x, y) = x === y;

always_comb
a1: assert (ones_match(a, b));
//Note: the actuals 'a' and 'b' are of type 'logic', while the
//formals 'x', 'y' are of type 'bits'

property toggles(bit x, y);
    same(x, y) |=> !same(x, y);
    //Note: the actuals 'x', 'y' are of type 'bit', while the
    //formals 'x', 'y' are of type 'logic'
endproperty

a2: assert property (@(posedge clock) toggles(c, d));
endmodule : m
",Verilog code examples demonstrating the use of 'let' declarations and type conversion in module instances.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p340.jpg,True,"The image contains two examples of Verilog code related to SystemVerilog assertions with abort properties. Here are the code excerpts:

1. First code excerpt:
```verilog
property p; (accept_on(a) p1) or (reject_on(b) p2);
endproperty
```

2. Second code excerpt:
```verilog
property p; accept_on(a) reject_on(b) p1; endproperty
```

3. Third code excerpt:
```verilog
Frame_accept_reject: assert property (
    @(posedge clk)
    accept_on (Frame_)
    Cycle_start |=> reject_on(Tabort)
)
else $display (""Frame_FAIL"");
```

These snippets are part of a text discussing the use of ""accept_on"" and ""reject_on"" constructs in SystemVerilog properties to control the behavior of properties when certain conditions occur.","
property p; (accept_on(a) p1) or (reject_on(b) p2);
endproperty


property p; accept_on(a) reject_on(b) p1; endproperty


Frame_accept_reject: assert property (
    @(posedge clk)
    accept_on (Frame_)
    Cycle_start |=> reject_on(Tabort)
)
else $display (""Frame_FAIL"");
",Caption: Explaining Verilog's reject_on and accept_on properties for asynchronous aborts in concurrent assertions.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p233.jpg,True,"Here is the code presented in the image:

```verilog
property p_tRRD;
    @(posedge clk)
        (`s_active && bank_addr[1:0] == 0) |->
        not ##[0: tRRD] (`s_active && bank_addr[1:0] != 0));
endproperty

a_tRRD: assert property(p_tRRD);
c_tRRD: cover property (p_tRRD);
```

Additionally, there is a code snippet that starts with ""genvar"" but is not fully visible in the image:

```verilog
genvar j;
generate
```

This snippet suggests the beginning of a generate block used to instantiate multiple modules or generate Verilog code dynamically in a loop, but the rest of the code is not shown.","
property p_tRRD;
    @(posedge clk)
        (`s_active && bank_addr[1:0] == 0) |->
        not ##[0: tRRD] (`s_active && bank_addr[1:0] != 0));
endproperty

a_tRRD: assert property(p_tRRD);
c_tRRD: cover property (p_tRRD);


genvar j;
generate
","Caption: ""Disabling Auto-precharge in SDRAM and Verilog code for checking the minimum time interval between active commands to different banks using SystemVerilog Assertions (SVA).""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p134.jpg,True,"The image contains the following Verilog code snippets:

```verilog
a1: assert property (@(posedge clk) ##2 a);
```

```verilog
a2: assert property (@(posedge clk) nexttime[2] a);
```

```verilog
s ##1 |-> p;
```

```verilog
(s ##1 @($global_clock 1)) |-> p;
```

These snippets are related to suffix implication in Verilog properties.","
a1: assert property (@(posedge clk) ##2 a);


a2: assert property (@(posedge clk) nexttime[2] a);


s ##1 |-> p;


(s ##1 @($global_clock 1)) |-> p;
",The image provides an explanation on 'Suffix Implication' using Verilog properties with examples of overlapping and nonoverlapping implications in the context of system verification.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p138.jpg,True,"```verilog
module monitor (arb_if.MONITOR arbif);

always @ (posedge arbif.request[0]) begin
    $display(""%0t: request[0] asserted"", $time);
    @ (posedge arbif.grant[0]);
    $display(""%0t: grant[0] asserted"", $time);
end

always @ (posedge arbif.request[1]) begin
    $display(""%0t: request[1] asserted"", $time);
    @ (posedge arbif.grant[1]);
    $display(""%0t: grant[1] asserted"", $time);
end

endmodule
```","
module monitor (arb_if.MONITOR arbif);

always @ (posedge arbif.request[0]) begin
    $display(""%0t: request[0] asserted"", $time);
    @ (posedge arbif.grant[0]);
    $display(""%0t: grant[0] asserted"", $time);
end

always @ (posedge arbif.request[1]) begin
    $display(""%0t: request[1] asserted"", $time);
    @ (posedge arbif.grant[1]);
    $display(""%0t: grant[1] asserted"", $time);
end

endmodule
","""Verilog code example demonstrating the use of modports with an arbiter interface, alongside a discussion on interface trade-offs.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p645.jpg,True,"The image contains code related to Verilog PLI (Programming Language Interface) and the definition of a structure used to link PLI applications with Verilog simulators. Below is the code from the image:

```c
s_tfcell veriusertfs[] =
{
  { type, user_data, checktf_app, sizetf_app, calltf_app, misctf_app, ""tf_name"", 1, 0, 0 },
  { type, user_data, checktf_app, sizetf_app, calltf_app, misctf_app, ""tf_name"", 1, 0, 0 },
  ...
  {0}, /* first field in final array cell is 0 */
};

typedef struct t_tfcell {
  short type;                 /* one of the constants: usertask,
                                 userfunction, userrealfunction */
  short data;                 /* data passed to user routine */
  int (*checktf)();           /* pointer to the checktf routine */
  int (*sizetf)();            /* pointer to the sizetf routine */
  int (*calltf)();            /* pointer to the calltf routine */
  int (*misctf)();            /* pointer to the misctf routine */
  char *tfname;               /* name of the system task/function */
  int forwref;                /* usually set to 1 */
  char *tfveritool;           /* usually ignored */
  char *tferrmessage;         /* usually ignored */
} s_tfcell, *p_tfcell;
```

This code shows the definition of an array `veriusertfs` of `s_tfcell` structures, which are used by PLI applications in Verilog simulators. Each element of the array represents a task or function that can be accessed from within the Verilog simulator environment. The `typedef` defines the structure `t_tfcell`, which is aliased as `s_tfcell` and `*p_tfcell`. Note that placeholder names like ""tf_name"", ""type"", ""user_data"", ""checktf_app"", ""sizetf_app"", ""calltf_app"", and ""misctf_app"" should be replaced with actual identifiers when used in a real context.","ell veriusertfs[] =
{
  { type, user_data, checktf_app, sizetf_app, calltf_app, misctf_app, ""tf_name"", 1, 0, 0 },
  { type, user_data, checktf_app, sizetf_app, calltf_app, misctf_app, ""tf_name"", 1, 0, 0 },
  ...
  {0}, /* first field in final array cell is 0 */
};

typedef struct t_tfcell {
  short type;                 /* one of the constants: usertask,
                                 userfunction, userrealfunction */
  short data;                 /* data passed to user routine */
  int (*checktf)();           /* pointer to the checktf routine */
  int (*sizetf)();            /* pointer to the sizetf routine */
  int (*calltf)();            /* pointer to the calltf routine */
  int (*misctf)();            /* pointer to the misctf routine */
  char *tfname;               /* name of the system task/function */
  int forwref;                /* usually set to 1 */
  char *tfveritool;           /* usually ignored */
  char *tferrmessage;         /* usually ignored */
} s_tfcell, *p_tfcell;
","Caption: ""Appendix from a technical document showing the definition and structure of a Verilog PLI application array called 'veriusertfs' used for linking to Verilog simulators.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p651.jpg,True,"The image contains a partial listing of a sample Verilog-XL `veriuser.c` file. The code is as follows:

```c
#include ""veriuser.h""
#include ""vxl_veriuser.h""

/* prototypes for the PLI application routines */
extern int PLIbook_ShowVal_checktf(), PLIbook_ShowVal_calltf(),
           PLIbook_pow_sizetf(), PLIbook_pow_checktf(),
           PLIbook_pow_calltf(), PLIbook_pow_misctf();

/* the veriusertfs table */
s_tfcell veriusertfs[] =
{
    {usertask,
     0,                       /* user_data value */
     PLIbook_ShowVal_checktf, /* checktf routine */
```

It's worth noting that the array `veriusertfs[]` and its contents are shown here only partially, and the listing does not include the entire content of the file. The last part of the code is not fully visible and is likely to contain more entries defining PLI application routines for Verilog simulation.","ude ""veriuser.h""
#include ""vxl_veriuser.h""

/* prototypes for the PLI application routines */
extern int PLIbook_ShowVal_checktf(), PLIbook_ShowVal_calltf(),
           PLIbook_pow_sizetf(), PLIbook_pow_checktf(),
           PLIbook_pow_calltf(), PLIbook_pow_misctf();

/* the veriusertfs table */
s_tfcell veriusertfs[] =
{
    {usertask,
     0,                       /* user_data value */
     PLIbook_ShowVal_checktf, /* checktf routine */
","""Interfacing PLI applications with Verilog-XL and the Verilog-XL veriuser.c file example""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p282.jpg,True,"```verilog
module assert_always (ck, reset_n, test_expr);
input ck, reset_n, test_expr;
parameter severity_level = 0;
parameter msg=""ASSERT ALWAYS VIOLATION"";
`ifdef ASSERT_ON
```","
module assert_always (ck, reset_n, test_expr);
input ck, reset_n, test_expr;
parameter severity_level = 0;
parameter msg=""ASSERT ALWAYS VIOLATION"";
`ifdef ASSERT_ON
","""Documentation on the 'assert_always' assertion in Verilog outlining its syntax, usage, and module definition.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p120.jpg,True,"The image contains Verilog code. Here's the code that’s displayed:

```verilog
initial
a2: assert property (@(posedge clk) s_eventually always !rst);

always s_eventually p
```

```verilog
a1: assert property (@(posedge clk) s_eventually req -> gnt);
```","
initial
a2: assert property (@(posedge clk) s_eventually always !rst);

always s_eventually p


a1: assert property (@(posedge clk) s_eventually req -> gnt);
","Caption: ""Explaining the Verilog S_eventually Property with Code Examples and Assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p171.jpg,True,"```c
int i, s = 0;
int a[1000];
for (i = 0; i < 1000; i = i + 1) {
    assert(i < 1000);
    s = s + a[i];
}
```
This is the code from the image which describes a simple C program that accumulates the sum of an array `a` while asserting that the index `i` stays within the bounds of the array.",", s = 0;
int a[1000];
for (i = 0; i < 1000; i = i + 1) {
    assert(i < 1000);
    s = s + a[i];
}
","Caption: ""Excerpt from a document discussing counterexamples with loops in predicate abstraction, featuring a simple code example with potential buffer overflow.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p397.jpg,True,"There is code in the image. Here it is:

```verilog
module counter_property (
    input clk, rst_, ld_cnt_, updn_cnt, count_enb,
    input [7:0] data_in,
    input logic [7:0] data_out
);

//-----------------------------------------
// CHECK # 1. Check that when 'rst_' is asserted (==0) that
// data_out == 8'b0
//-----------------------------------------
```","
module counter_property (
    input clk, rst_, ld_cnt_, updn_cnt, count_enb,
    input [7:0] data_in,
    input logic [7:0] data_out
);

//-----------------------------------------
// CHECK # 1. Check that when 'rst_' is asserted (==0) that
// data_out == 8'b0
//-----------------------------------------
","""Exploration of UP/DOWN Counter Design with SystemVerilog Assertions and Sampled Value Functions in LAB4""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p306.jpg,True,"The image contains a fragment of SystemVerilog code. Here is the code as it appears in the image:

```systemverilog
// extra modeling code (not part of design) used with property
// specification

always @(posedge clk) begin
  if (~rstN)
    prevState <= 'IDLE;
  else
    prevState <= currentState;
end // always

always @(prevState or ...) begin
  case (prevState)
    'IDLE: if (...) currentState = 'ADDRESS
    ...
    ...
    ...
    default: currentState = 'ERROR;
  endcase
end // always

// SystemVerilog temporal property specification
property ValidTransaction;
  @(posedge clk) (currentState != 'ERROR);
endproperty
assert property (ValidTransaction);
```

Please note that some parts of the code contain placeholder ellipses (...) to indicate omitted code or conditions.","erilog
// extra modeling code (not part of design) used with property
// specification

always @(posedge clk) begin
  if (~rstN)
    prevState <= 'IDLE;
  else
    prevState <= currentState;
end // always

always @(prevState or ...) begin
  case (prevState)
    'IDLE: if (...) currentState = 'ADDRESS
    ...
    ...
    ...
    default: currentState = 'ERROR;
  endcase
end // always

// SystemVerilog temporal property specification
property ValidTransaction;
  @(posedge clk) (currentState != 'ERROR);
endproperty
assert property (ValidTransaction);
",Example of SystemVerilog code modeling transaction sequence and specifying temporal properties in a high-level requirements context.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p383.jpg,True,"The image contains snippets of Verilog code as follows:

```
@(negedge clk); {cstart,req,gnt}=3'b000;
@(negedge clk); {cstart,req,gnt}=3'b001;

@(negedge clk); $finish(2);
end

endmodule
```

This code appears to be part of a test bench or simulation environment for a Verilog design. The `@(negedge clk);` lines are sensitivity lists that trigger on the negative edge of a `clk` signal. The statements following those lines set values to a group of signals `cstart`, `req`, and `gnt`. The `$finish(2);` is a system task that ends the simulation and can return an exit code.","dge clk); {cstart,req,gnt}=3'b000;
@(negedge clk); {cstart,req,gnt}=3'b001;

@(negedge clk); $finish(2);
end

endmodule
",This image depicts a page from a textbook or document related to SystemVerilog Assertions (SVAs) in which a snippet of Verilog code and related simulation log questions are presented. The content is likely part of a tutorial or a lab exercise discussing the behavior of assertions in a hardware verification context.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p241.jpg,True,"The image contains several pieces of Verilog code. Here they are:

Example 9-11:
```verilog
module b (p, w, x, y, z);
    input [7:0] w, x, y, z;
    output [7:0] p;
    wire [7:0] w, x, y, z;
    reg [7:0] p, r, s;
    always @(w or x or y or z)
    begin
        r = w | x;
        s = y | z;
        p = r & s;
    end
endmodule // b
```

Example 9-12:
```verilog
always @(w or x or y or z)
    p = (w | x) & (y | z);
```

Example 9-13:
```verilog
assign p = (w | x) & (y | z);
```

These codes illustrate different ways to express combinational logic in Verilog. Example 9-11 shows a more explicit use of intermediary variables within an `always` block, whereas Example 9-12 simplifies the logic within a similar `always` block. Example 9-13 shows the equivalent combinational logic using an `assign` statement, which is inherently combinational in Verilog.","
module b (p, w, x, y, z);
    input [7:0] w, x, y, z;
    output [7:0] p;
    wire [7:0] w, x, y, z;
    reg [7:0] p, r, s;
    always @(w or x or y or z)
    begin
        r = w | x;
        s = y | z;
        p = r & s;
    end
endmodule // b


always @(w or x or y or z)
    p = (w | x) & (y | z);


assign p = (w | x) & (y | z);
",Verilog code example illustrating procedural assignments in combinational logic with sensitivity list and RTL design rules.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p220.jpg,True,"The image contains three Verilog code examples. Here is the code as shown in the image:

First code example (ONE):

```verilog
sequence burst (logic FRAME_, BurstSize = 4)
  logic abc = 1'b0, BSize = BurstSize;
  @(posedge clk)
    FRAME_ |=> ...
endsequence
```

Second code example (TWO):

```verilog
sequence burst (logic FRAME_, local input logic BSize)
  logic abc = 1'b0;
  @(posedge clk)
    FRAME_ |=> ...
endsequence
```

Third code example:

```verilog
sequence local_IO (
  local
    byte a;
  local inout
    byte b;
  local input
    logic c;
  local output
    byte d;
);
endsequence
```","
sequence burst (logic FRAME_, BurstSize = 4)
  logic abc = 1'b0, BSize = BurstSize;
  @(posedge clk)
    FRAME_ |=> ...
endsequence


sequence burst (logic FRAME_, local input logic BSize)
  logic abc = 1'b0;
  @(posedge clk)
    FRAME_ |=> ...
endsequence


sequence local_IO (
  local
    byte a;
  local inout
    byte b;
  local input
    logic c;
  local output
    byte d;
);
endsequence
","The image shows an excerpt from a document focused on local variables in Verilog, discussing the use of ""argument local variables"" within sequence constructs.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p234.jpg,True,"The image contains Verilog code, specifically showing the definition of sequences and properties for use in formal verification or simulation. Here's the code present in the image:

```verilog
sequence aRb (aFell , bRose);
@(posedge clk) $fell(aFell ) ##1 $rose( bRose );
endsequence

property endCycle;
@(posedge clk) $rose(c) |=> aRb(a , b).triggered;
endproperty
base: assert property (endCycle) else gotoFail;

sequence readStart; @(posedge clk) read_enb ##1 readStartState; endsequence
sequence readID; @(posedge clk) readStartState ##1 readIDState; endsequence
sequence readData; @(posedge clk) readIDState ##1 readDataState; endsequence
sequence readEnd; @(posedge clk) readDataState ##1 readEndState; endsequence

property checkReadStates;
@(posedge clk)
    readStart.triggered ##[1:$]
    readID.triggered ##[1:$]
    readData.triggered ##[1:$]
    readEnd
;
endproperty

sCheck: assert property (checkReadStates) else $display ($stime,,""FAIL"");
cCheck: cover property (checkReadStates) $display ($stime,,""PASS"");
```

The code includes a combination of SystemVerilog assertions (SVA) that can be used to validate the behavior of a design by checking that certain conditions hold true at specified points during simulation.","
sequence aRb (aFell , bRose);
@(posedge clk) $fell(aFell ) ##1 $rose( bRose );
endsequence

property endCycle;
@(posedge clk) $rose(c) |=> aRb(a , b).triggered;
endproperty
base: assert property (endCycle) else gotoFail;

sequence readStart; @(posedge clk) read_enb ##1 readStartState; endsequence
sequence readID; @(posedge clk) readStartState ##1 readIDState; endsequence
sequence readData; @(posedge clk) readIDState ##1 readDataState; endsequence
sequence readEnd; @(posedge clk) readDataState ##1 readEndState; endsequence

property checkReadStates;
@(posedge clk)
    readStart.triggered ##[1:$]
    readID.triggered ##[1:$]
    readData.triggered ##[1:$]
    readEnd
;
endproperty

sCheck: assert property (checkReadStates) else $display ($stime,,""FAIL"");
cCheck: cover property (checkReadStates) $display ($stime,,""PASS"");
","""Example of Verilog Assertions and Sequences for State Machine Transition Checking""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p719.jpg,True,"The image includes a section of text with definitions and a code snippet that relates to the Verilog Procedural Interface (VPI). The code snippet in the image is a C structure definition used with the VPI. Here is the code:

```c
typedef struct t_vpi_vlog_info {
    int argc;
    char **argv;
    char *product;
    char *version;
} s_vpi_vlog_info, *p_vpi_vlog_info;
```

This structure definition `s_vpi_vlog_info` is meant to be used with a VPI routine that retrieves the simulator's invocation option information. The image also includes function prototypes for other VPI functions, such as `vpi_get_vlog_info`, `vpi_handle`, `vpi_handle_by_index`, `vpi_handle_by_name`, and `vpi_handle_multi`, but not their implementations.","ef struct t_vpi_vlog_info {
    int argc;
    char **argv;
    char *product;
    char *version;
} s_vpi_vlog_info, *p_vpi_vlog_info;
",Excerpt from the IEEE 1364-1995 VPI Routine Library documentation showing Verilog Procedural Interface (VPI) functions in Verilog.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p731.jpg,True,"The image contains text describing various functions from the IEEE 1364-1995 TF routine library related to Verilog, but it does not contain any actual code examples that can be written out as Verilog source code. The text describes function prototypes and their descriptions for simulation time retrieval and manipulation within a Verilog environment. Here are the function prototypes listed in the image:

```
double tf_getrealtime()
double tf_igetrealtime(tfintst)
char    *tfintst

int tf_gettime()
int tf_igettime(tfintst)
char    *tfintst

int tf_gettimeprecision()
int tf_igettimeprecision(tfintst)
char    *tfintst

int tf_gettimeunit()
int tf_igettimeunit(tfintst)
char    *tfintst

char *tf_getworkarea()
char *tf_igetworkarea(tfintst)
char    *tfintst
```

These are not executable Verilog code but rather a list of function signatures from a Verilog PLI (Programming Language Interface) library, which are used to interact with the simulator."," tf_getrealtime()
double tf_igetrealtime(tfintst)
char    *tfintst

int tf_gettime()
int tf_igettime(tfintst)
char    *tfintst

int tf_gettimeprecision()
int tf_igettimeprecision(tfintst)
char    *tfintst

int tf_gettimeunit()
int tf_igettimeunit(tfintst)
char    *tfintst

char *tf_getworkarea()
char *tf_igetworkarea(tfintst)
char    *tfintst
","Caption: ""Document excerpt showing the IEEE 1364-1995 Verilog Time Function (TF) Routine Library for retrieving simulation time and time scale information.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p299.jpg,True,"```verilog
property complex_req_start_retry;
  @(posedge clk)
    first_match(req_start ##[1:5] restart ##1 retry)
    |-> abort ##1 !abort throughout req_start[->1]
endproperty
```","
property complex_req_start_retry;
  @(posedge clk)
    first_match(req_start ##[1:5] restart ##1 retry)
    |-> abort ##1 !abort throughout req_start[->1]
endproperty
","Caption: ""Understanding Sequence Ambiguity in SystemVerilog with an example of the 'first_match' operator to address sequence ambiguity issues.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p56.jpg,True,"```verilog
assertion_instantiation ::= assert_identifier
    [parameter_value_assignment] module_instance ;

parameter_value_assignment ::= # (severity_number {,other
    parameter expressions}, message)

module_instance ::= name_of_instance
    ([list_of_module_connections])

name_of_instance ::= module_instance_identifier

list_of_module_connections ::=
    ordered_port_connection {,ordered_port_connection} |
    named_port_connection {,named_port_connection}

ordered_port_connection ::= [expression]

named_port_connection ::= .port_identifier ([expression])

assert_identifier ::= assert_[type_identifier]

type_identifier ::= identifier
```","
assertion_instantiation ::= assert_identifier
    [parameter_value_assignment] module_instance ;

parameter_value_assignment ::= # (severity_number {,other
    parameter expressions}, message)

module_instance ::= name_of_instance
    ([list_of_module_connections])

name_of_instance ::= module_instance_identifier

list_of_module_connections ::=
    ordered_port_connection {,ordered_port_connection} |
    named_port_connection {,named_port_connection}

ordered_port_connection ::= [expression]

named_port_connection ::= .port_identifier ([expression])

assert_identifier ::= assert_[type_identifier]

type_identifier ::= identifier
","""Excerpt from a technical document detailing Assertion Monitor Library syntax and parameters for use in Verilog Hardware Description Language.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p208.jpg,True,"The image contains Verilog code which I will transcribe below:

First code block:
```verilog
property mclocks;
  @(posedge clk0) A |-> @(posedge clk1) B;
endproperty
```

Second code block:
```verilog
property mclocks;
  @(posedge clk0) A |=> @(posedge clk1) B;
endproperty
```

Third code block:
```verilog
property mclocks;
  @(posedge clk0) A |-> @(posedge clk0) B;
endproperty
```

Fourth code block:
```verilog
property mclocks;
  @(posedge clk0) A |-> ##1 @(posedge clk1) B;
endproperty
```

These snippets are demonstrating the use of properties in SystemVerilog to specify the behavior of multiple clock domains.","
property mclocks;
  @(posedge clk0) A |-> @(posedge clk1) B;
endproperty


property mclocks;
  @(posedge clk0) A |=> @(posedge clk1) B;
endproperty


property mclocks;
  @(posedge clk0) A |-> @(posedge clk0) B;
endproperty


property mclocks;
  @(posedge clk0) A |-> ##1 @(posedge clk1) B;
endproperty
","""Exploring Legal and Illegal Conditions in Multiply Clocked Properties of Verilog Code""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p140.jpg,True,"```verilog
1. Define pT = ^Word[7:0];

2. Define low-nibble pN = ^Word[3:0];

3. Define even pE = ^(Word[6], Word[4], Word[2], Word[0]);

4. Define low half-nibble pL = ^(Word[5:4], Word[1:0]);
```

There are comments made with '8' characters like '8'xxxxxxxx' for illustrative purposes in the document, but these are not part of the actual Verilog code.","
1. Define pT = ^Word[7:0];

2. Define low-nibble pN = ^Word[3:0];

3. Define even pE = ^(Word[6], Word[4], Word[2], Word[0]);

4. Define low half-nibble pL = ^(Word[5:4], Word[1:0]);
","Caption: ""Excerpt from a document detailing an Error-Correcting Code (ECC) process using parity bits in Verilog to detect and correct single-bit errors in a data word.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p64.jpg,True,"```verilog
property ldpccheck;
    @(posedge clk) $rose (FRAME_) |-> ##[1:2] $fell (LDP_);
endproperty
aP: assert property (ldpccheck) else $display(""ldpccheck FAIL"");
cP: cover property (ldpccheck) $display(""ldpccheck PASS"");
```

The image contains this snippet of Verilog code related to a property definition and usage in SystemVerilog Assertions (SVA).","
property ldpccheck;
    @(posedge clk) $rose (FRAME_) |-> ##[1:2] $fell (LDP_);
endproperty
aP: assert property (ldpccheck) else $display(""ldpccheck FAIL"");
cP: cover property (ldpccheck) $display(""ldpccheck PASS"");
","A textbook or article excerpt discussing the ""cover"" property in SystemVerilog Assertions (SVA) and presenting an example of Verilog code that utilizes the ""cover"" statement for verification purposes.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p272.jpg,True,"The image contains Verilog and SystemVerilog code.

Here is the Verilog code:

```verilog
// See Example 6-44 on page 201 for details of pipelined_regack
// module
sendReadReq .req(req), // The handshakes, request
            .ack(done), // and done (completion)
            .req_datain(1'b1), .dataout(1'b1), // not used
            .clk(elk),
            .latency(100), // Maximum latency for return of done.
            .pipdepth(1); // Only 1 request at a time.
```

Here is the SystemVerilog code:

```systemverilog
property legal_cmds;
    @(posedge clk) disable iff (reset_n)
    req |-> cmd inside {`READ, `WRITE, `INTA, `EIEIO};
endproperty

assert property (legal_cmds);
```","
// See Example 6-44 on page 201 for details of pipelined_regack
// module
sendReadReq .req(req), // The handshakes, request
            .ack(done), // and done (completion)
            .req_datain(1'b1), .dataout(1'b1), // not used
            .clk(elk),
            .latency(100), // Maximum latency for return of done.
            .pipdepth(1); // Only 1 request at a time.

erilog
property legal_cmds;
    @(posedge clk) disable iff (reset_n)
    req |-> cmd inside {`READ, `WRITE, `INTA, `EIEIO};
endproperty

assert property (legal_cmds);
","Caption: ""Excerpts from a guide on Verilog and SystemVerilog, showcasing examples for validating request-to-done transactions and checking for legal instructions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p266.jpg,True,"There is Verilog and SystemVerilog code in this image. Here is the text for the code parts:

Verilog fragment for priority multiplexer:
```verilog
always @(select or data0 or data1 or data2 or data3)
  casez (select) // synopsys full_case parallel_case
    4'bzz11: outdata = data0;
    4'bzz10: outdata = data1;
    4'bzz0: outdata = data2;
    4'bz00: outdata = data3;
    default: assert property (@(posedge `TOP.clk) (1'b0));
      // Not legal select value.
  endcase
```

SystemVerilog ensure at least one select is active:
```systemverilog
property atleastone;
  @(posedge clk) not (select == 4'b0);
endproperty

assert property (atleastone);
```","
always @(select or data0 or data1 or data2 or data3)
  casez (select) // synopsys full_case parallel_case
    4'bzz11: outdata = data0;
    4'bzz10: outdata = data1;
    4'bzz0: outdata = data2;
    4'bz00: outdata = data3;
    default: assert property (@(posedge `TOP.clk) (1'b0));
      // Not legal select value.
  endcase

erilog
property atleastone;
  @(posedge clk) not (select == 4'b0);
endproperty

assert property (atleastone);
","""Example Verilog and SystemVerilog code demonstrating priority multiplexer design and assertions for verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p154.jpg,True,"Here is the Verilog code from the image:

```verilog
// Basic toggle flip-flop:
//
wire Qn_D, Qout;
...
DFF Toggle01 ( .Q(Qout), .Qn(Qn_D), .D(Qn_D), .Clk(Clk1N) );
...

module TFF (output Q, input Clock, Reset);
    // DFFC is the DFF above, unconnected, with clear (reset) added.
    wire Qn_D, TQ;
    assign Q = TQ;
    DFFC Toggler ( .Q(TQ), .Qn(Qn_D), .D(Qn_D), .Clk(Clock), .Rst(Reset) );
endmodule
```

Please note that there are some ellipsis (...) which indicate that some parts of the code are not shown in the image.","
// Basic toggle flip-flop:
//
wire Qn_D, Qout;
...
DFF Toggle01 ( .Q(Qout), .Qn(Qn_D), .D(Qn_D), .Clk(Clk1N) );
...

module TFF (output Q, input Clock, Reset);
    // DFFC is the DFF above, unconnected, with clear (reset) added.
    wire Qn_D, TQ;
    assign Q = TQ;
    DFFC Toggler ( .Q(TQ), .Qn(Qn_D), .D(Qn_D), .Clk(Clock), .Rst(Reset) );
endmodule
","Caption: ""Understanding Toggle Flip-Flops and Ripple Counters through Verilog Code Implementation and Schematics""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p81.jpg,True,"The image contains Verilog code. Below are the code excerpts from the image:

Example 4-7:
```verilog
module mux2_20(_x, d0, d1, s);
output[19:0]_x;
input s;
input [19:0]d0;
input [19:0]d1;
assign _x = (~s ? d1 : d0);
endmodule // mux2_20
```

Example 4-8:
```verilog
module mux2_20(_x, d0, d1, s);
output[19:0]_x;
input s;
input [19:0]d0;
input [19:0]d1;
mux2_4 m0(
    .s(s), .d1(d1[19:16]), .d0(d0[19:16]),
    ._x(_x[19:16]));
mux2_4 m1(
    .s(s), .d1(d1[15:12]), .d0(d0[15:12]),
    ._x(_x[15:12]));
endmodule
```

Please note that the code snippets may continue beyond the visible content or have additional comments and explanations that are not included in the text provided above.","
module mux2_20(_x, d0, d1, s);
output[19:0]_x;
input s;
input [19:0]d0;
input [19:0]d1;
assign _x = (~s ? d1 : d0);
endmodule // mux2_20


module mux2_20(_x, d0, d1, s);
output[19:0]_x;
input s;
input [19:0]d0;
input [19:0]d1;
mux2_4 m0(
    .s(s), .d1(d1[19:16]), .d0(d0[19:16]),
    ._x(_x[19:16]));
mux2_4 m1(
    .s(s), .d1(d1[15:12]), .d0(d0[15:12]),
    ._x(_x[15:12]));
endmodule
","Caption: ""Examples of Verilog code for a 20-bit wide 2-to-1 multiplexer with an inverted output, illustrating both simulation-targeted and synthesis-targeted library code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p168.jpg,True,"The image contains Verilog code. Here it is:

```verilog
always@(posedge clockIn)
begin
    #1 a = b;
    // other statements
end

...

always@(a, b, c) #2 ena = (a & b) | c;

...

always@(a, b) #2 ena = a ^ b;
```","
always@(posedge clockIn)
begin
    #1 a = b;
    // other statements
end

...

always@(a, b, c) #2 ena = (a & b) | c;

...

always@(a, b) #2 ena = a ^ b;
","""Understanding Race Conditions in Verilog with Examples of Concurrent Signal Assignments""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p65.jpg,True,"```verilog
reg       A = 1'b1, B = 1'b0;
reg[3:0]  C = 4'b0101, D = 4'b1100;
reg[15:0] E = 16'hfffe;
...
C = A | B; // C gets A=4'b0001 | B=4'b0000 --> 4'b0001.
C = E & D; // C gets E=4'b1110 & D=4'b1100 --> 4'b1100.
E = A + C; // E gets A=16'h1 + C=16'h9 --> 16'ha.

// Example module inside a module:
module ModuleName ( ...I/O's... ); // <--semicolon ends header.
...
parameter Awid = 32, Bwid = 16;
...
reg[Awid-1:0] Abus, Zbus;
wire[Bwid-1:0] Bwire;
...
endmodule

// Example module in a module header:
module ModuleName
  #(parameter Awid = 32, Bwid = 16) // <-- no comma!
  ( ...I/O's... ); // <--semicolon ends header.
...
reg[Awid-1:0] Abus, Zbus;
wire[Bwid-1:0] Bwire;
...
endmodule
``` 

This code contains examples of Verilog hardware description language, including how to initialize variables, perform bitwise operations, and define modules with parameters.","
reg       A = 1'b1, B = 1'b0;
reg[3:0]  C = 4'b0101, D = 4'b1100;
reg[15:0] E = 16'hfffe;
...
C = A | B; // C gets A=4'b0001 | B=4'b0000 --> 4'b0001.
C = E & D; // C gets E=4'b1110 & D=4'b1100 --> 4'b1100.
E = A + C; // E gets A=16'h1 + C=16'h9 --> 16'ha.

// Example module inside a module:
module ModuleName ( ...I/O's... ); // <--semicolon ends header.
...
parameter Awid = 32, Bwid = 16;
...
reg[Awid-1:0] Abus, Zbus;
wire[Bwid-1:0] Bwire;
...
endmodule

// Example module in a module header:
module ModuleName
  #(parameter Awid = 32, Bwid = 16) // <-- no comma!
  ( ...I/O's... ); // <--semicolon ends header.
...
reg[Awid-1:0] Abus, Zbus;
wire[Bwid-1:0] Bwire;
...
endmodule
","""Verilog Code and Concepts: Initialization, Parameters, and Commenting Techniques""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p518.jpg,True,"The image contains snippets of code in the context of Verilog property specification. Here is the code from the image:

```verilog
property my_always[0] (property p);
    1'b1;
endproperty

property my_always[k] (property p);
    (nexttime[0] p) and nexttime my_always[k-1] (p);
endproperty
```

And it is used in the following expressions:

1. `my_always[1](q) = (nexttime[0] q) and nexttime 1'b1`
2. `my_always[k+1](q) = (nexttime[0] q) and nexttime my_always[k] (q)`

The text is describing a formal semantics within the context of verification or property checking in hardware design using SystemVerilog.","
property my_always[0] (property p);
    1'b1;
endproperty

property my_always[k] (property p);
    (nexttime[0] p) and nexttime my_always[k-1] (p);
endproperty
",Formal semantics of k-fold properties in Verilog with an example of temporal property approximation.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p151.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
// open a file to document transactions

integer h_mt;
initial
begin
``` 

This code appears to be an introduction to a process that will open a file with the intent to document transactions. However, the rest of the code that would complete the functionality is not shown.","
// open a file to document transactions

integer h_mt;
initial
begin
","""Excerpt from a technical document discussing the use of SVA (SystemVerilog Assertions) for creating transaction logs in testbenches, with an example of initiating a transaction log in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p269.jpg,True,"Here is the code present in the image:

```c
/***********************************************************************
 * Structure definition to store output values when the ALU is latched.
 ***********************************************************************/
typedef struct PLIbook_ScientificALU_outputs {
    double result;   /* stored result of previous operation */
    int except;
} PLIbook_ALU_outputs_s, *PLIbook_ALU_outputs_p;

/***********************************************************************
 * C model with latched outputs. When enable is 1, the ALU returns
 * the currently calculated outputs, and when 0, the ALU returns the
 * latched previous results.
 ***********************************************************************/
#include <math.h>
#include <errno.h>
void PLIbook_ScientificALU_C_model(
    double *result,  /* output from ALU */
    int *execp,      /* output; set if result is out of range */
```

Please note that the code in the image is incomplete, and the full implementation is not shown.","*******************************************************************
 * Structure definition to store output values when the ALU is latched.
 ***********************************************************************/
typedef struct PLIbook_ScientificALU_outputs {
    double result;   /* stored result of previous operation */
    int except;
} PLIbook_ALU_outputs_s, *PLIbook_ALU_outputs_p;

/***********************************************************************
 * C model with latched outputs. When enable is 1, the ALU returns
 * the currently calculated outputs, and when 0, the ALU returns the
 * latched previous results.
 ***********************************************************************/
#include <math.h>
#include <errno.h>
void PLIbook_ScientificALU_C_model(
    double *result,  /* output from ALU */
    int *execp,      /* output; set if result is out of range */
","""Chapter excerpt on Interfacing to C Models Using VPI Routines in Verilog, with an example code of a latched scientific ALU model.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p50.jpg,True,"There is code in this image. Here it is:

```verilog
`define k 2 + 3
let m = 2 + 3;
int n = 2 + 3;

logic [`k:0] a;
logic [m:0] a;
logic [n:0] a;
```

Additionally, there are references to other code-like constructs such as `include`, `define`, `ifdef`, and `ifndef`, but these are mentioned in discussion rather than provided as complete code examples.","
`define k 2 + 3
let m = 2 + 3;
int n = 2 + 3;

logic [`k:0] a;
logic [m:0] a;
logic [n:0] a;
","Caption: ""Distinguishing between compile time, elaboration time, and simulation time in SystemVerilog language constructs.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p272.jpg,True,"Here is the Verilog code from the image:

```verilog
initial begin
    $display(""@%0t: start fork...join_any example"", $time);
    #10 $display(""@%0t: sequential after #10"", $time);
    fork
        $display(""@%0t: parallel start"", $time);
        #50 $display(""@%0t: parallel after #50"", $time);
        #10 $display(""@%0t: parallel after #10"", $time);
        begin
            #30 $display(""@%0t: sequential after #30"", $time);
            #10 $display(""@%0t: sequential after #10"", $time);
        end
    join_any
    $display(""@%0t: after join_any"", $time);
    #80 $display(""@%0t: finish after #80"", $time);
end
```

This code contains a demonstration of the `fork...join_any` construct, where several threads of execution are launched in parallel, and the parent thread continues after any one of the child threads completes.","
initial begin
    $display(""@%0t: start fork...join_any example"", $time);
    #10 $display(""@%0t: sequential after #10"", $time);
    fork
        $display(""@%0t: parallel start"", $time);
        #50 $display(""@%0t: parallel after #50"", $time);
        #10 $display(""@%0t: parallel after #10"", $time);
        begin
            #30 $display(""@%0t: sequential after #30"", $time);
            #10 $display(""@%0t: sequential after #10"", $time);
        end
    join_any
    $display(""@%0t: after join_any"", $time);
    #80 $display(""@%0t: finish after #80"", $time);
end
","The image shows a textbook page explaining the use of threads in Verilog, specifically focusing on synchronizing threads with the `fork...join_any` construct.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p381.jpg,True,"The image contains a snippet of Verilog code within a text. Here is the code from the image:

```verilog
reg SetupNotify;
...
always @(SetupNotify) $stop;
...
specify
    ...
    $setup( D, posedge Clk, MinD_Clk, SetupNotify );
endspecify
```

This code appears to be an example related to setup timing checks in a Verilog simulation environment, using the $setup timing control and the $stop system task.","
reg SetupNotify;
...
always @(SetupNotify) $stop;
...
specify
    ...
    $setup( D, posedge Clk, MinD_Clk, SetupNotify );
endspecify
","""Verilog timing check example and explanation on pulse filtering in simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p44.jpg,True,"The image contains snippets of Verilog code. Here are the two excerpts shown:

**First Excerpt:**

```verilog
logic a, b, c, d, cond, clk;
let onecold(sig) = $onehot(~sig);
// ...
always_comb begin
  // ...
  a1: assert (onecold({a, b, c}) || d);
end
a2: assert final (onecold({a, b, c}) -> d);
a3: assert property (@(posedge clk) cond |-> onecold({a, b, c}));
```

**Second Excerpt:**

```verilog
logic ready, request, grant, clk;
// ...
sequence falling(x);
  (x ##1 !x);
endsequence
a1: assert property (@(posedge clk) falling(ready) |=> ready);
a2: assert property (@(posedge clk) request |=> falling(grant));
```","
logic a, b, c, d, cond, clk;
let onecold(sig) = $onehot(~sig);
// ...
always_comb begin
  // ...
  a1: assert (onecold({a, b, c}) || d);
end
a2: assert final (onecold({a, b, c}) -> d);
a3: assert property (@(posedge clk) cond |-> onecold({a, b, c}));


logic ready, request, grant, clk;
// ...
sequence falling(x);
  (x ##1 !x);
endsequence
a1: assert property (@(posedge clk) falling(ready) |=> ready);
a2: assert property (@(posedge clk) request |=> falling(grant));
","""Verilog code examples showcasing assertion reuse and sequence reuse in digital design verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p266.jpg,True,"The image contains Verilog code. Here is the code as it appears in the image:

```verilog
package my_package;

  typedef enum {READ, WRITE} rw_e;

  class Transaction;
    rw_e old_rw;
    rand rw_e rw;
    rand bit [31:0] addr, data;
    constraint rw_c{if (old_rw == WRITE) rw != WRITE;};

    function void post_randomize;
      old_rw = rw;
    endfunction

    function void print_all;
      $display(""addr = %d, data = %d, rw = %s"", addr, data, rw);
    endfunction

  endclass

endpackage
```","
package my_package;

  typedef enum {READ, WRITE} rw_e;

  class Transaction;
    rw_e old_rw;
    rand rw_e rw;
    rand bit [31:0] addr, data;
    constraint rw_c{if (old_rw == WRITE) rw != WRITE;};

    function void post_randomize;
      old_rw = rw;
    endfunction

    function void print_all;
      $display(""addr = %d, data = %d, rw = %s"", addr, data, rw);
    endfunction

  endclass

endpackage
",Verilog code snippet showing a Transaction class with randomization constraints to prevent back-to-back transactions of the same type from having the same address.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p395.jpg,True,"The image contains Verilog code, I will write it down for you:

```verilog
// Assume a AdjustFreq vector declared which
//                    sets the VFO frequency:
reg [HiBit:0] Count;
reg PLLClockOut;
always@(posedge FastClock, posedge Reset)
    if (Reset==1'b1)
    begin
        PLLClockOut <= 1'b0;
        Count       <= 'b0;
    end
else begin
    if (Count>=AdjustFreq)  // Programmable limit.
    begin
        PLLClockOut <= ~PLLClockOut;
        Count       <= 'b0;
    end
    else Count <= Count + 1;
end
```

This code snippet represents a simple phase-locked loop (PLL) Verilog module that could be used in digital circuit design.","
// Assume a AdjustFreq vector declared which
//                    sets the VFO frequency:
reg [HiBit:0] Count;
reg PLLClockOut;
always@(posedge FastClock, posedge Reset)
    if (Reset==1'b1)
    begin
        PLLClockOut <= 1'b0;
        Count       <= 'b0;
    end
else begin
    if (Count>=AdjustFreq)  // Programmable limit.
    begin
        PLLClockOut <= ~PLLClockOut;
        Count       <= 'b0;
    end
    else Count <= Count + 1;
end
","""Example of Verilog code for a Variable Frequency Oscillator (VFO) with frequency adjustment logic.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p145.jpg,True,"The image contains two snippets of code. The first snippet appears to be SystemVerilog (which is based on the Verilog hardware description language) code used in a simulation environment, and the second snippet is an example of a SystemVerilog property. Here is the code:

First snippet:
```systemverilog
$display(""FC: All possible request scenarios covered 3 times each\n"");
$finish();
```

Second snippet:
```systemverilog
property p_m1t1r;
// master1 reading from target 1
@(posedge clk)
$fell(frame1 && irdy1) |-> ...
```

Please note that the second snippet is not complete; the `...` indicates that there is more to the property that is not shown in the image provided.","erilog
$display(""FC: All possible request scenarios covered 3 times each\n"");
$finish();

erilog
property p_m1t1r;
// master1 reading from target 1
@(posedge clk)
$fell(frame1 && irdy1) |-> ...
","Caption: ""Excerpt from a technical document detailing simulation termination methods in Verilog and a table showing Master to Target transaction scenarios for verifying system transactions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p71.jpg,True,"The image contains several snippets of Verilog code. Below is the code as shown in the image:

First snippet:
```verilog
wire [31:0] X;
integer A, B;
...
// Put the greater of A or B into X; A if they are equal:
assign X = (A>=B) ? A : B;
```

Second snippet (inside an always block):
```verilog
always@(posedge clk)
begin
  xbus[1] <= '1'b1;
  @(posedge Enable) // Execution stops here until Enable goes to '1'.
  begin
    Dbus[7] <= 8'haa;
    xbus[7:4] <= 'b0;
  end
  ebus[2] <= '1'b0;
  ...
```

Third snippet (showing combinatorial logic with always block):
```verilog
always@(Ain, Bin, Cin, Din, temp1, temp2)
begin
  temp1 = Ain*Bin;
  temp2 = Cin*Din;
  CombOut = (temp1 & temp2) | Ain^Din;
end
assign #5 OutBit = CombOut | OtherCombOut; // Collect the delays here.
```
The code shown is an educational example for learning Verilog syntax and constructs used in digital design for combinational and sequential logic.","
wire [31:0] X;
integer A, B;
...
// Put the greater of A or B into X; A if they are equal:
assign X = (A>=B) ? A : B;


always@(posedge clk)
begin
  xbus[1] <= '1'b1;
  @(posedge Enable) // Execution stops here until Enable goes to '1'.
  begin
    Dbus[7] <= 8'haa;
    xbus[7:4] <= 'b0;
  end
  ebus[2] <= '1'b0;
  ...


always@(Ain, Bin, Cin, Din, temp1, temp2)
begin
  temp1 = Ain*Bin;
  temp2 = Cin*Din;
  CombOut = (temp1 & temp2) | Ain^Din;
end
assign #5 OutBit = CombOut | OtherCombOut; // Collect the delays here.
","The image displays a page from a document discussing various aspects of Verilog coding, focusing on combinational and sequential logic, and illustrating the use of continuous assignments, conditional assignments, and always blocks.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p524.jpg,True,"The image contains a section of text discussing the concept of ""Free Variables"" in the context of Verilog formal verification, specifically within the scope of checkers and assertions. Below is the code snippet from the image:

```verilog
checker failure;
default clocking @($global_clock); endclocking
rand bit v;
a1: assert property(v);
endchecker : failure
```

This code declares a checker called 'failure', defines a random bit `v` as a free variable, and specifies an assertion `a1` that checks a property of `v`.","
checker failure;
default clocking @($global_clock); endclocking
rand bit v;
a1: assert property(v);
endchecker : failure
","""Understanding Free Variables in Verilog Assertions with an Example Checker""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p59.jpg,True,"The image contains several snippets of Verilog code. Here they are:

1995 header format:
```verilog
module MyCounter
  (CountOut, CountReady, StartCount, Load, Clock, Reset);
  output[15:0] CountOut;
  output CountReady;
  output StartCount;
  input Load, Clock, Reset;
  reg[15:0] CountOut; // Could be anywhere in the module.
  ...
endmodule
```

2001 header format:
```verilog
module MyCounter
  (output[15:0] CountOut, output CountReady
   input[15:0] StartCount, input Load, Clock, Reset);
  // Header has ended; module itself now begins:
  reg[15:0] CountOutR;
  assign CountOut = CountOutR;
  ...
endmodule
```

In 2001 format, it is still possible to declare an output port to be a reg:
```verilog
module My2001Module (output reg[15:0] CountOut, ...);
```","
module MyCounter
  (CountOut, CountReady, StartCount, Load, Clock, Reset);
  output[15:0] CountOut;
  output CountReady;
  output StartCount;
  input Load, Clock, Reset;
  reg[15:0] CountOut; // Could be anywhere in the module.
  ...
endmodule


module MyCounter
  (output[15:0] CountOut, output CountReady
   input[15:0] StartCount, input Load, Clock, Reset);
  // Header has ended; module itself now begins:
  reg[15:0] CountOutR;
  assign CountOut = CountOutR;
  ...
endmodule


module My2001Module (output reg[15:0] CountOut, ...);
","""Comparison of Verilog module declarations in 1995 and 2001 header formats.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p255.jpg,True,"Here is the code that is visible in the image:

```c
#include <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard input/output library */
#include ""vpi_user.h""  /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library
                        (using TF routines for simulation control) */

/* prototypes of routines in this PLI application */
int PLIbook_ScientificALU_calltf(), PLIbook_ScientificALU_compiletf();
int PLIbook_ScientificALU_interface();
```

This code snippet is related to Verilog PLI (Programming Language Interface) using VPI (Verilog Procedural Interface) routines, which is a methodology used to create custom C models that can interface with Verilog simulations.","ude <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard input/output library */
#include ""vpi_user.h""  /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library
                        (using TF routines for simulation control) */

/* prototypes of routines in this PLI application */
int PLIbook_ScientificALU_calltf(), PLIbook_ScientificALU_compiletf();
int PLIbook_ScientificALU_interface();
","""Chapter excerpt on interfacing to C models using VPI routines in Verilog, including an example of combinational logic C model interface.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p242.jpg,True,"The image displays some Verilog code snippets used for asserting properties. The following are the code excerpts from the image:

```verilog
wire e;
initial a: assert property (
    (always nexttime e) iff (nexttime always e) );
```

```verilog
property p1;
    not (a[*1 ##1 b) ;
endproperty
property p2;
    strong (!b[+ ##0 !a) ;
endproperty
a1: assert property(p1 iff p2) ;
```

```verilog
a1: assert property(if (b) not strong(a ##1 b)
                    else a ##1 b) ;

a2: assert property(
    (b |-> not strong (a ##1 b)) and
    (!b |-> a ##1 b) ) ;

a3: assert property(if (b) a ##1 b) ;

a4: assert property(b |-> a ##1 b) ;
```","
wire e;
initial a: assert property (
    (always nexttime e) iff (nexttime always e) );


property p1;
    not (a[*1 ##1 b) ;
endproperty
property p2;
    strong (!b[+ ##0 !a) ;
endproperty
a1: assert property(p1 iff p2) ;


a1: assert property(if (b) not strong(a ##1 b)
                    else a ##1 b) ;

a2: assert property(
    (b |-> not strong (a ##1 b)) and
    (!b |-> a ##1 b) ) ;

a3: assert property(if (b) a ##1 b) ;

a4: assert property(b |-> a ##1 b) ;
","""Exploring Advanced Properties in Verilog with Assertions and Implications""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p241.jpg,True,"The image contains an example of how to use simulation event callbacks for logic value changes in Verilog simulations using VPI callbacks. Here is the code from the image:

```c
#include <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard input/output library */
#include <malloc.h> /* ANSI C standard memory allocation library */
```

This particular block of code is including standard C libraries that would be used in a C program to interact with Verilog simulations using the VPI interface. These libraries provide functions for memory allocation, I/O operations, and other general utilities.","ude <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard input/output library */
#include <malloc.h> /* ANSI C standard memory allocation library */
","Textbook excerpt on synchronizing to Verilog simulations using VPI callbacks, including an example of using simulation event callbacks for logic value changes.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p256.jpg,True,"The image contains examples of Verilog code. Here it is:

```
(read && en) [*3] ##1 (write && en) [*4]
```

And a rewritten version using the `throughout` operator:

```
en throughout read[*3] ##1 write[*4]
```","&& en) [*3] ##1 (write && en) [*4]

oughout read[*3] ##1 write[*4]
","Caption: ""Verilog sequence operators and the use of the 'throughout' operator in sequence expressions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p89.jpg,True,"The image includes examples of Verilog code. Below is the text of the code present in the image:

For Sample 2.35:
```verilog
struct packed { bit [7:0] r, g, b; } c[];
c = '{{r:7, g:4, b:9}, '{r:3, g:2, b:9}, '{r:5, g:2, b:1}};

c.sort with (item.r); // sort using r only
// '{{r:3, g:2, b:9}, '{r:5, g:2, b:1}, '{r:7, g:4, b:9}}

c.sort(x) with ({x.g, x.b}); // Sort g first, then b
// '{{r:5, g:2, b:1}, '{r:3, g:2, b:9}, '{r:7, g:4, b:9}}
```

For Sample 2.36:
```verilog
typedef struct packed
    {bit [7:0] addr;
    bit [7:0] pr;
    bit [15:0] data; } Packet;

Packet scb[$];

function void check_addr(bit [7:0] addr);
    int intq[$];

    intq = scb.find_index() with (item.addr == addr);
    case (intq.size())
        0: $display(""Addr %h not found in scoreboard"", addr);
        1: scb.delete(intq[0]);
        default:
            $display(""ERROR: Multiple hits for addr %h"", addr);
    endcase
endfunction : check_addr
```

This snippet of code shows structures and how they are packed and sorted in Sample 2.35, and defines a scoreboard using array locator methods in Sample 2.36.","
struct packed { bit [7:0] r, g, b; } c[];
c = '{{r:7, g:4, b:9}, '{r:3, g:2, b:9}, '{r:5, g:2, b:1}};

c.sort with (item.r); // sort using r only
// '{{r:3, g:2, b:9}, '{r:5, g:2, b:1}, '{r:7, g:4, b:9}}

c.sort(x) with ({x.g, x.b}); // Sort g first, then b
// '{{r:5, g:2, b:1}, '{r:3, g:2, b:9}, '{r:7, g:4, b:9}}


typedef struct packed
    {bit [7:0] addr;
    bit [7:0] pr;
    bit [15:0] data; } Packet;

Packet scb[$];

function void check_addr(bit [7:0] addr);
    int intq[$];

    intq = scb.find_index() with (item.addr == addr);
    case (intq.size())
        0: $display(""Addr %h not found in scoreboard"", addr);
        1: scb.delete(intq[0]);
        default:
            $display(""ERROR: Multiple hits for addr %h"", addr);
    endcase
endfunction : check_addr
","""Verilog code examples demonstrating array sorting and scoreboard implementation using array methods.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p50.jpg,True,"The image contains Verilog code for SystemVerilog Assertions (SVA). Here is the code extracted from the image:

```verilog
sequence s11a;
    @(posedge clk) (a && b) ##1 c;
endsequence

sequence s11b;
    @(posedge clk) ##2 1d;
endsequence

property p11;
    s11a |-> s11b;
endproperty

a11 : assert property(p11);
```

This snippet defines two sequences (`s11a` and `s11b`) and a property (`p11`) that asserts an implication between the two sequences. The `assert` statement with the label `a11` is utilized to check the property `p11`.

Sequence `s11a` is looking for the signals `a` and `b` to be high at the positive edge of the clock and then, one clock cycle later, signal `c` should be high.

Sequence `s11b` expects signal `d` to be low after 2 clock cycles from the positive edge of the clock.

The property `p11` asserts that if `s11a` succeeds then `s11b` must also succeed.","
sequence s11a;
    @(posedge clk) (a && b) ##1 c;
endsequence

sequence s11b;
    @(posedge clk) ##2 1d;
endsequence

property p11;
    s11a |-> s11b;
endproperty

a11 : assert property(p11);
","Caption: ""Example of Verilog SystemVerilog Assertions (SVA) with sequences and properties for simulation.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p530.jpg,True,"The image contains snippets of Verilog code. The code represented is as follows:

```verilog
bit v; // or rand bit v
initial v = 1'b0;
initial v = 1'b1;
```

And there is another representation of code in a more descriptive context:

```verilog
rand some_type v = e;
```

This is equivalent to the following assumption in Verilog:

```verilog
initial
  assume property (@$global_clock v === e);
```

The text also discusses the assignment of free variables and mentions that:

```verilog
It is illegal to assign to a free variable in a blocking or continuous assignment.
```","
bit v; // or rand bit v
initial v = 1'b0;
initial v = 1'b1;


rand some_type v = e;


initial
  assume property (@$global_clock v === e);


It is illegal to assign to a free variable in a blocking or continuous assignment.
","Caption: ""Understanding free variable initialization and assignment rules in Verilog code, as outlined in a formal verification context.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p179.jpg,True,"The image contains two segments of Verilog SystemVerilog Assertions (SVA) code. Here they are transcribed:

The first code segment is:

```verilog
property p_forbid_trans3a;
    @(posedge clk)
    (!((state == IDLE2) || (state == IDLE3))
    && reset) |->
        $past(state== IDLE1) == 0;
endproperty

a_forbid_trans3a:
    assert property(p_forbid_trans3a);

c_forbid_trans3a:
    cover property(p_forbid_trans3a);
```

The second code segment is:

```verilog
property p_forbid_trans3b;
    @(posedge clk)
    (!((state == IDLE1) || (state == IDLE3))
    && reset) |->
        $past(state== IDLE2) == 0;
endproperty

a_forbid_trans3b:
    assert property(p_forbid_trans3b);

c_forbid_trans3b:
    cover property(p_forbid_trans3b);
```

These segments define properties for asserting forbidden transitions in a finite state machine (FSM) and then use `assert` and `cover` to enforce and track these properties during simulation.","
property p_forbid_trans3a;
    @(posedge clk)
    (!((state == IDLE2) || (state == IDLE3))
    && reset) |->
        $past(state== IDLE1) == 0;
endproperty

a_forbid_trans3a:
    assert property(p_forbid_trans3a);

c_forbid_trans3a:
    cover property(p_forbid_trans3a);


property p_forbid_trans3b;
    @(posedge clk)
    (!((state == IDLE1) || (state == IDLE3))
    && reset) |->
        $past(state== IDLE2) == 0;
endproperty

a_forbid_trans3b:
    assert property(p_forbid_trans3b);

c_forbid_trans3b:
    cover property(p_forbid_trans3b);
","Caption: ""Verilog code examples demonstrating how to use SystemVerilog Assertions (SVA) for verifying forbidden state transitions in finite state machines (FSMs).""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p527.jpg,True,"The image contains a segment of code, which seems to be written in the C programming language, related to Verilog's ACC (Application Component Interface) Routine Library. Here's the code transcribed from the image:

```c
/********************************************
 * checktf application
 ********************************************/
int PLIbook_DisplayNets_checktf()
{
    acc_initialize();
    if (tf_nump() != 1)
        tf_error(""$display_all_nets must have 1 argument."");
    else if (tf_typep(1) == TF_NULLPARAM)
        tf_error(""$display_all_nets arg cannot be null."");
    else if (acc_fetch_type(acc_handle_tfarg(1)) != accModule)
        tf_error(""$display_all_nets arg must be a module instance."");
    acc_close();
    return(0);
}

/********************************************
 * misctf application
 ********************************************/
int PLIbook_DisplayNets_misctf(int user_data, int reason)
{
    PLIbook_NetData_p net_data;
    handle mod_h;

    acc_initialize();
    acc_configure(accDisplayWarnings, ""true"");

    switch (reason) {
        case REASON_ENDOFCOMPILE:
            acc_initialize();
            net_data = (PLIbook_NetData_p)malloc(sizeof(PLIbook_NetData_s));
            net_data->module_h = acc_handle_tfarg(1);
            net_data->net_array = acc_collect(acc_next_net,
                                              net_data->module_h,
                                              &net_data->net_count);
            io_printf(""Total nets collected in misctf routine = %d\n"",
                      net_data->net_count);
            tf_setworkarea((char *)net_data);
            acc_close();
            break;
        case REASON_FINISH:
            net_data = (PLIbook_NetData_p)tf_getworkarea();
            acc_free(net_data->net_array);
            break;
    }
    acc_close();
    return(0);
}

/********************************************
 * calltf application
 ********************************************/
int PLIbook_DisplayNets_calltf()
{
    // The body of this function is not visible in the image provided.
}
```

Please note that the `PLIbook_DisplayNets_calltf` function's body is not visible in the image. This code involves interfacing with Verilog simulations through PLI (Programming Language Interface), which ACC is a part of. The code also handles initialization and cleanup of ACC resources, error checking for the applied task arguments, and managing the collection of net data during simulation events.","****************************************
 * checktf application
 ********************************************/
int PLIbook_DisplayNets_checktf()
{
    acc_initialize();
    if (tf_nump() != 1)
        tf_error(""$display_all_nets must have 1 argument."");
    else if (tf_typep(1) == TF_NULLPARAM)
        tf_error(""$display_all_nets arg cannot be null."");
    else if (acc_fetch_type(acc_handle_tfarg(1)) != accModule)
        tf_error(""$display_all_nets arg must be a module instance."");
    acc_close();
    return(0);
}

/********************************************
 * misctf application
 ********************************************/
int PLIbook_DisplayNets_misctf(int user_data, int reason)
{
    PLIbook_NetData_p net_data;
    handle mod_h;

    acc_initialize();
    acc_configure(accDisplayWarnings, ""true"");

    switch (reason) {
        case REASON_ENDOFCOMPILE:
            acc_initialize();
            net_data = (PLIbook_NetData_p)malloc(sizeof(PLIbook_NetData_s));
            net_data->module_h = acc_handle_tfarg(1);
            net_data->net_array = acc_collect(acc_next_net,
                                              net_data->module_h,
                                              &net_data->net_count);
            io_printf(""Total nets collected in misctf routine = %d\n"",
                      net_data->net_count);
            tf_setworkarea((char *)net_data);
            acc_close();
            break;
        case REASON_FINISH:
            net_data = (PLIbook_NetData_p)tf_getworkarea();
            acc_free(net_data->net_array);
            break;
    }
    acc_close();
    return(0);
}

/********************************************
 * calltf application
 ********************************************/
int PLIbook_DisplayNets_calltf()
{
    // The body of this function is not visible in the image provided.
}
",Excerpt from chapter detailing the use of the ACC Routine Library in Verilog with code examples for checktf and misctf applications.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p192.jpg,True,"The image contains Verilog code, as follows:

```verilog
module au_comp_chk (
    input logic clk, reset, enable1, enable2,
    input logic signed [15:0]
    d1, d2, d3, d4, d5, d6, d7, d8,
    input logic signed [15:0]
    o1, o2, o3, o4, o5, o6, o7, o8
);

logic signed [15:0] in_local[0:7];
logic signed [15:0] out_orig[0:7];
logic signed [15:0] out_local[0:7];

integer i, k;

integer wh_local[0:7][0:7] = 
{
    {1, 1, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, -1, -1, -1, -1, -1},
    {1, 1, -1, -1, -1, -1, 1, 1},
    {1, -1, -1, 1, 1, -1, -1, 1},
    {1, 1, 1, 1, -1, -1, -1, -1},
    {1, -1, 1, -1, 1, -1, 1, -1},
    {1, -1, -1, 1, -1, 1, 1, -1},
    {1, -1, 1, -1, 1, -1, 1, -1},
};
```

This Verilog code defines a module named `au_comp_chk` with various inputs, arrays of logic elements, and an integer 2D array representing a matrix named `wh_local`.","
module au_comp_chk (
    input logic clk, reset, enable1, enable2,
    input logic signed [15:0]
    d1, d2, d3, d4, d5, d6, d7, d8,
    input logic signed [15:0]
    o1, o2, o3, o4, o5, o6, o7, o8
);

logic signed [15:0] in_local[0:7];
logic signed [15:0] out_orig[0:7];
logic signed [15:0] out_local[0:7];

integer i, k;

integer wh_local[0:7][0:7] = 
{
    {1, 1, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, -1, -1, -1, -1, -1},
    {1, 1, -1, -1, -1, -1, 1, 1},
    {1, -1, -1, 1, 1, -1, -1, 1},
    {1, 1, 1, 1, -1, -1, -1, -1},
    {1, -1, 1, -1, 1, -1, 1, -1},
    {1, -1, -1, 1, -1, 1, 1, -1},
    {1, -1, 1, -1, 1, -1, 1, -1},
};
","""Example of a Verilog code module for SVA Checker in a WHT (Walsh-Hadamard Transform) hardware implementation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p93.jpg,True,"```
a2: assert property (@(clk) a);

a3: assert property (@(posedge clk iff en) a);
```","sert property (@(clk) a);

a3: assert property (@(posedge clk iff en) a);
","""Exploring Concurrent Assertions and Gated Clocks in SystemVerilog""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p76.jpg,True,"The image contains Verilog code. Here is the code excerpt from the image:

```verilog
initial begin
    bit [31:0] src[5] = '{0,1,2,3,4},
                dst[5] = '{5,4,3,2,1};

    // Aggregate compare the two arrays
    if (src==dst)
        $display(""src == dst"");
    else
        $display(""src != dst"");

    // Aggregate copy all src values to dst
    dst = src;

    // Change just one element
    src[0] = 5;

    // Are all values equal (no!)
    $display(""src %s dst"", (src == dst) ? ""=="" : ""!="");

    // Use array slice to compare elements 1-4 (they are equal)
    $display(""src[1:4] %s dst[1:4]"",
             (src[1:4] == dst[1:4]) ? ""=="" : ""!="");
end
```

The code demonstrates basic array operations in Verilog, including copying arrays and comparing arrays or array slices.","
initial begin
    bit [31:0] src[5] = '{0,1,2,3,4},
                dst[5] = '{5,4,3,2,1};

    // Aggregate compare the two arrays
    if (src==dst)
        $display(""src == dst"");
    else
        $display(""src != dst"");

    // Aggregate copy all src values to dst
    dst = src;

    // Change just one element
    src[0] = 5;

    // Are all values equal (no!)
    $display(""src %s dst"", (src == dst) ? ""=="" : ""!="");

    // Use array slice to compare elements 1-4 (they are equal)
    $display(""src[1:4] %s dst[1:4]"",
             (src[1:4] == dst[1:4]) ? ""=="" : ""!="");
end
",Basic Array Operations in Verilog: Copy and Compare Operations,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p87.jpg,True,"There is code in the image. Here it is:

```verilog
da5: assert #0 (a == b) else begin
     err_cnt++; $error(""p1 failure: a = %b, b = %b"", a, b); end
da6: assert #0 (a == b) else ctr++;
da7: assert #0 (a == b) else
     begin
     $error(""da7 failure: a = %b, b = %b"", a, b);
     end
```","
da5: assert #0 (a == b) else begin
     err_cnt++; $error(""p1 failure: a = %b, b = %b"", a, b); end
da6: assert #0 (a == b) else ctr++;
da7: assert #0 (a == b) else
     begin
     $error(""da7 failure: a = %b, b = %b"", a, b);
     end
","Caption: ""Text from a document discussing the legality and implications of using deferred assertions in Verilog, including examples of illegal assertions and notes on the execution of assertions with respect to subroutine argument values.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p356.jpg,True,"```
design IntroLib.Intro_Top;

default class;

instance IntroLib.Intro_Top.XorNor.xor_01 special;
```"," IntroLib.Intro_Top;

default class;

instance IntroLib.Intro_Top.XorNor.xor_01 special;
","An excerpt from a Verilog VLSI design text discussing Verilog configurations, instance statements, libraries, and timing arcs.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p430.jpg,True,"Here is the Verilog code from the image:

```verilog
always@(posedge ClockR, posedge Reset)
begin : Reader
  if (Reset=='1'b1)
    (init Parityr, Dreadyr, DataOr)
  else if (Read=='1'b1)
    (do parity check and read)
end // Reader.
//
always@(posedge ClockW, posedge Reset)
begin : Writer
  if (Reset=='1'b1) // Zero the memory:
    for (i=0; i<MemHi; i=i+1) Storage[i] <= 'b0;
  else if (Write=='1'b1)
    (do write)
end // Writer.
...
```

Please note that certain parts of the code were intentionally described in a pseudo-code format, such as `(init Parityr, Dreadyr, DataOr)`, `(do parity check and read)`, and `(do write)`. These would need to be replaced with the actual Verilog code to perform the specified operations.","
always@(posedge ClockR, posedge Reset)
begin : Reader
  if (Reset=='1'b1)
    (init Parityr, Dreadyr, DataOr)
  else if (Read=='1'b1)
    (do parity check and read)
end // Reader.
//
always@(posedge ClockW, posedge Reset)
begin : Writer
  if (Reset=='1'b1) // Zero the memory:
    for (i=0; i<MemHi; i=i+1) Storage[i] <= 'b0;
  else if (Write=='1'b1)
    (do write)
end // Writer.
...
","""Guidelines for avoiding race conditions and adopting new naming conventions in Verilog, with example code for separate read and write always blocks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p87.jpg,True,"The following Verilog code is present in the image:

```verilog
sequence s32a;
    @(posedge clk)
        (([!a&:b] ##1 (c[->3])) ##1 (a&&b));
endsequence

sequence s32b;
    @(posedge clk)
        $fell(start) ##[5:10] $rose(start);
endsequence

sequence s32;
    @(posedge clk) s32a within s32b;
endsequence

property p32;
    @(posedge clk) $fell(start) |-> s32;
endproperty

a32: assert property(p32);
```","
sequence s32a;
    @(posedge clk)
        (([!a&:b] ##1 (c[->3])) ##1 (a&&b));
endsequence

sequence s32b;
    @(posedge clk)
        $fell(start) ##[5:10] $rose(start);
endsequence

sequence s32;
    @(posedge clk) s32a within s32b;
endsequence

property p32;
    @(posedge clk) $fell(start) |-> s32;
endproperty

a32: assert property(p32);
","""Exploring the 'within' construct in Verilog for defining sequences contained within other sequences, along with sample code and property assertion.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p281.jpg,True,"The image contains the following pieces of code written in Verilog:

```verilog
a6: assert property(
    write |-> ##[1:*] read ##1 [1:*] intersect write[-1]);

a7: assert property(
    write |-> ##[1:*] read ##1 [1:*] intersect write[-1]);
```

The code snippet continues with the same line repeated as `a7`, which suggests a possible error in the text, as these are assert property statements that typically should be different for different assertions. The properties expressed in these statements are used for formal verification in hardware description languages like Verilog.

Other parts of the image include discussions on sequences as events and instructions on implementing various assertions.","
a6: assert property(
    write |-> ##[1:*] read ##1 [1:*] intersect write[-1]);

a7: assert property(
    write |-> ##[1:*] read ##1 [1:*] intersect write[-1]);
","Caption: ""Excerpt from a technical document discussing SystemVerilog assertions, with examples of temporal properties for sequence event control.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p296.jpg,True,"This image contains several snippets of Verilog code. Here they are:

First snippet:
```verilog
module top;
  reg [7:0] in1;
  wire [7:0] out1;
  bottom b1 (in1[7:4], out1[7:4]);
  bottom b2 (in2[3:0], out2[3:0]);
endmodule

module bottom (in, out);
  ...
endmodule
```

Second snippet (some parts are indicated with ellipses to show that not the entire code is provided):
```verilog
module top;
  ...
  middle m1 (...);
  middle m2 (...);

  initial
    $my_app_1(in1, out1);

  always @(posedge clock)
    $my_app_1(in2, out2);
endmodule

module middle (...);
  ...
  bottom b1 (...);
  bottom b2 (...);
endmodule
```

Please note that the snippets are examples to illustrate specific concepts in the Verilog PLI (Programming Language Interface) and thus may include placeholders or incomplete sections marked with ellipses (...).","
module top;
  reg [7:0] in1;
  wire [7:0] out1;
  bottom b1 (in1[7:4], out1[7:4]);
  bottom b2 (in2[3:0], out2[3:0]);
endmodule

module bottom (in, out);
  ...
endmodule


module top;
  ...
  middle m1 (...);
  middle m2 (...);

  initial
    $my_app_1(in1, out1);

  always @(posedge clock)
    $my_app_1(in2, out2);
endmodule

module middle (...);
  ...
  bottom b1 (...);
  bottom b2 (...);
endmodule
","Caption: ""Verilog code example illustrating module instantiation and hierarchy, with an emphasis on the use of the Verilog Programming Language Interface (PLI).""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p137.jpg,True,"Here's the Verilog code from the image:

Example 6-5:
```verilog
mult_16x16 mult1 (coord_x, coord_y, mult1_prod);
assign c_indx = ((mult1_prod & indx_mask) + indx_offset);
```

Example 6-6:
```verilog
case ((a & b | c ^ d) || mem[Idx])
  4'b0100: c_nxt_st = r_nxt_st << 1;
  4'b1000: c_nxt_st = r_nxt_st >> 1;
  default: c_nxt_st = r_nxt_st;
endcase;
```

Example 6-7:
```verilog
c_nxt_st_test = (a & b | c ^ d) || mem[Idx];
case (c_nxt_st_test)
  4'b0100: c_nxt_st = r_nxt_st << 1;
  4'b1000: c_nxt_st = r_nxt_st >> 1;
  default: c_nxt_st = r_nxt_st;
endcase;
```","
mult_16x16 mult1 (coord_x, coord_y, mult1_prod);
assign c_indx = ((mult1_prod & indx_mask) + indx_offset);


case ((a & b | c ^ d) || mem[Idx])
  4'b0100: c_nxt_st = r_nxt_st << 1;
  4'b1000: c_nxt_st = r_nxt_st >> 1;
  default: c_nxt_st = r_nxt_st;
endcase;


c_nxt_st_test = (a & b | c ^ d) || mem[Idx];
case (c_nxt_st_test)
  4'b0100: c_nxt_st = r_nxt_st << 1;
  4'b1000: c_nxt_st = r_nxt_st >> 1;
  default: c_nxt_st = r_nxt_st;
endcase;
","""Verilog case statements with complex test expressions and their impact on verification and equivalence checking""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p299.jpg,True,"```verilog
program automatic synch_peek;
// Uses Producer from Sample 7-38

mailbox #(int) mbx;

class Consumer;
    task run();
        int i;
        repeat (3) begin
            mbx.peek(i);            // Peek integer from mbx
            $display(""Consumer: after peek(%0d)"", i);
            mbx.get(i);             // Remove from mbx
        end
    endtask
endclass : Consumer

Producer p;
Consumer c;

initial begin
    // Construct mailbox, producer, consumer
    mbx = new(1);                  // Bounded mailbox - limit 1!
    p = new();
    c = new();

    // Run the producer and consumer in parallel
    fork
        p.run();
        c.run();
    join
end
endprogram
```","
program automatic synch_peek;
// Uses Producer from Sample 7-38

mailbox #(int) mbx;

class Consumer;
    task run();
        int i;
        repeat (3) begin
            mbx.peek(i);            // Peek integer from mbx
            $display(""Consumer: after peek(%0d)"", i);
            mbx.get(i);             // Remove from mbx
        end
    endtask
endclass : Consumer

Producer p;
Consumer c;

initial begin
    // Construct mailbox, producer, consumer
    mbx = new(1);                  // Bounded mailbox - limit 1!
    p = new();
    c = new();

    // Run the producer and consumer in parallel
    fork
        p.run();
        c.run();
    join
end
endprogram
",An example of a Verilog program illustrating a producer-consumer model synchronized with a bounded mailbox.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p295.jpg,True,"The image contains a snippet of text describing restrictions in multiply clocked sequences in Verilog, specifically SystemVerilog Assertions (SVA). There is a small piece of code in the image, which I will transcribe below:

```
(@ev1) a [*] ##1 a (@ev2) b
```

The text also mentions a corrected version of the above code to make it legal, which is:

```
(@ev1) a [*] ##1 (@ev2) b
```"," a [*] ##1 a (@ev2) b

 a [*] ##1 (@ev2) b
","""Documentation explaining restrictions in multiply clocked sequences in SystemVerilog Assertions (SVA).""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p282.jpg,True,"```verilog
module test;

initial
  $hello();

endmodule
```

```c
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */

int PLIbook_hello_calltf()
{
  io_printf(""\nHello World!\n\n"");
  return(0);
}
```","
module test;

initial
  $hello();

endmodule

ude ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */

int PLIbook_hello_calltf()
{
  io_printf(""\nHello World!\n\n"");
  return(0);
}
","""Example of Verilog PLI calltf routine to execute C code during simulation""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p549.jpg,True,"```c
typedef struct node {
    int h; struct node *n;
} *List;

void foo(int flag) {
    List a = (List) malloc(...);
    if (a == NULL) exit(1);
    List p = a;
    while (random())
        if (flag)
            p->h = 1;
        else
            p->h = 2;
    p->n = (List) malloc(...);
    if (p->n == NULL) exit(1);
    p = p->n;
    p->h = 3;
    p = a; /* Now check it. */
    if (flag)
        while (p->h == 1) p = p->n;
    else
        while (p->h == 2) p = p->n;
    assert(p->h == 3);
}
```","ef struct node {
    int h; struct node *n;
} *List;

void foo(int flag) {
    List a = (List) malloc(...);
    if (a == NULL) exit(1);
    List p = a;
    while (random())
        if (flag)
            p->h = 1;
        else
            p->h = 2;
    p->n = (List) malloc(...);
    if (p->n == NULL) exit(1);
    p = p->n;
    p->h = 3;
    p = a; /* Now check it. */
    if (flag)
        while (p->h == 1) p = p->n;
    else
        while (p->h == 2) p = p->n;
    assert(p->h == 3);
}
","Caption: ""Figure 2 from an academic paper, depicting an example C program alongside its concrete list representation and abstract shape graph for lazy shape analysis.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p294.jpg,True,"```verilog
module various_clocks(input logic clk1, clk2, a, b, c);
    default clocking NCLK1 @(negedge clk1); endclocking
    clocking PCLK2 @(posedge clk2); endclocking
    a2: assert property(a |-> b);
    a3: assert property(a[*2] |=> c);
    module nested_1;
        default clocking PCLK2;
        a4: assert property(a |=> b);
    endmodule
    module nested_2;
        a9: assert property(a |=> @PCLK2 c);
    endmodule
endmodule
```","
module various_clocks(input logic clk1, clk2, a, b, c);
    default clocking NCLK1 @(negedge clk1); endclocking
    clocking PCLK2 @(posedge clk2); endclocking
    a2: assert property(a |-> b);
    a3: assert property(a[*2] |=> c);
    module nested_1;
        default clocking PCLK2;
        a4: assert property(a |=> b);
    endmodule
    module nested_2;
        a9: assert property(a |=> @PCLK2 c);
    endmodule
endmodule
","""Exploring default clocking in Verilog modules and assertions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p136.jpg,True,"The image includes a snippet of Verilog code in Example 6-4. Here is the code:

```verilog
assign c_indx = (((coord_x * coord_y) & dx_mask) + indx_offset);
```

This Verilog line of code seems to be assigning a value to the signal `c_indx`, which is calculated by multiplying `coord_x` and `coord_y`, bitwise ANDing the result with `dx_mask`, and then adding `indx_offset` to it.","
assign c_indx = (((coord_x * coord_y) & dx_mask) + indx_offset);
","Caption: ""An excerpt from a text discussing RTL formal verification with an example of Verilog code implementing a cutpoint identification principle for equivalence checking.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p92.jpg,True,"```verilog
Property p35;
    (@(posedge clk) 1[*3:5] intersect (a ##[1:$] b ##[1:$] c));
endproperty

a35: assert property(p35);
```","
Property p35;
    (@(posedge clk) 1[*3:5] intersect (a ##[1:$] b ##[1:$] c));
endproperty

a35: assert property(p35);
","Caption: ""Verilog code snippet demonstrating a SystemVerilog Assertion (SVA) with a waveform example for signal sequence property verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p86.jpg,True,"```verilog
property p31;
@(posedge clk) $fell(start) |->
(!start) throughout
(##1 (!a&&!b) ##1 (c[->3]) ##1 (a&&b));
endproperty

a31: assert property(p31);
```","
property p31;
@(posedge clk) $fell(start) |->
(!start) throughout
(##1 (!a&&!b) ##1 (c[->3]) ##1 (a&&b));
endproperty

a31: assert property(p31);
",Verilog SVA example with a waveform illustration showing property success and failure based on signal patterns.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p297.jpg,True,"```verilog
module bottom (...);
    ...
    initial
        $my_app_2(in3, out3);
    always @(posedge clock)
        $my_app_2(in4, out4);
endmodule
```","
module bottom (...);
    ...
    initial
        $my_app_2(in3, out3);
    always @(posedge clock)
        $my_app_2(in4, out4);
endmodule
","Caption: ""Excerpt from a textbook detailing interfacing TF/ACC based PLI applications with Verilog simulators, explaining the instantiation of system tasks and the corresponding Verilog code snippet for module 'bottom'.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p280.jpg,True,"The image contains assertions written in a hardware verification language, which is used for expressing properties in hardware designs, and it might be based on SystemVerilog. Here are the code snippets present in the image:

```plaintext
a1: assert property (a[->1] );
a2: assert property (strong(a[->1]) );
a3: assert property (a[=1] |-> b);
```

These are used for formulating assertions about hardware behavior in a formal verification context.","xt
a1: assert property (a[->1] );
a2: assert property (strong(a[->1]) );
a3: assert property (a[=1] |-> b);
","Image Caption: ""Excerpt from a textbook on advanced sequences in Verilog, illustrating various assert property examples and questions related to assertion-based verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p86.jpg,True,"The image contains Verilog code, and here it is:

```verilog
int err_cnt = 0;
task err(bit a, b, string s);
    err_cnt++;
    $error(""%s failure: a = %b, b = %b"", a, b);
endtask

da1: assert #0 (a == b)
    else err(""da1"", a, b);
da2: assert #0 (a == b) $info(""a and b have value %b"", a);
    else $error(""da3 failure: a = %b, b = %b"", a, b);
da3: assert #0 (a == b) $info(""a and b have value %b"", a);
    else $error(""da3 failure: a = %b, b = %b"", a, b);
da4: assert #0 (a == b);
```","
int err_cnt = 0;
task err(bit a, b, string s);
    err_cnt++;
    $error(""%s failure: a = %b, b = %b"", a, b);
endtask

da1: assert #0 (a == b)
    else err(""da1"", a, b);
da2: assert #0 (a == b) $info(""a and b have value %b"", a);
    else $error(""da3 failure: a = %b, b = %b"", a, b);
da3: assert #0 (a == b) $info(""a and b have value %b"", a);
    else $error(""da3 failure: a = %b, b = %b"", a, b);
da4: assert #0 (a == b);
","The image is a page from a document explaining the use of deferred assertions in Verilog, particularly when using them with single subroutine calls in SystemVerilog, and includes a code snippet showing examples of observed deferred assertions.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p77.jpg,True,"```verilog
initial begin
  bit [31:0] src[5] = '{5{5}};
  $displayb(src[0],, // 'b101 or 'd5
            src[0][0],, // 'b1
            src[0][2:1]); // 'b10
end
```

```verilog
bit [3:0] [7:0] bytes; // 4 bytes packed into 32-bits
bytes = 32'hCAFE_DADA;
$displayh(bytes,, // Show all 32-bits
          bytes[3],, // Most significant byte ""CA""
          bytes[3][7]); // Most significant bit ""1"" of ""CA""
```","
initial begin
  bit [31:0] src[5] = '{5{5}};
  $displayb(src[0],, // 'b101 or 'd5
            src[0][0],, // 'b1
            src[0][2:1]); // 'b10
end


bit [3:0] [7:0] bytes; // 4 bytes packed into 32-bits
bytes = 32'hCAFE_DADA;
$displayh(bytes,, // Show all 32-bits
          bytes[3],, // Most significant byte ""CA""
          bytes[3][7]); // Most significant bit ""1"" of ""CA""
","This image is a textbook excerpt discussing the concept of fixed-size arrays, packed arrays, and their usage in SystemVerilog, featuring code samples and diagram.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p187.jpg,True,"Here's the Verilog code snippet visible in the image:

```verilog
module au (
    input logic [7:0] a, b, c,
```

The snippet appears to be a portion of a Verilog module declaration for an arithmetic unit (au) that takes three 8-bit logic inputs: a, b, and c. However, the image cuts off the code, so the full module definition is not visible.","
module au (
    input logic [7:0] a, b, c,
","""Chapter excerpt discussing SystemVerilog Assertions (SVA) for data intensive designs, including a simple multiplier check example in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p431.jpg,True,"The image contains a snippet of Verilog code. Here is the code extracted from the image:

```verilog
reg latchR, latchW; // Reset these to 1'b0 in SM comb. block.
...
task incrRead; // Unsynthesizable!
begin
    if (latchR=='1'b0)
        latchR = '1'b1;
        @(posedge ClkR)
        ReadCount = ReadCount + 1;
        latchR = '1'b0;
    end
end
endtask
```

Please note that the code above may be a part of a larger Verilog code block and should be considered in the context provided by the accompanying text.","
reg latchR, latchW; // Reset these to 1'b0 in SM comb. block.
...
task incrRead; // Unsynthesizable!
begin
    if (latchR=='1'b0)
        latchR = '1'b1;
        @(posedge ClkR)
        ReadCount = ReadCount + 1;
        latchR = '1'b0;
    end
end
endtask
","""Excerpt from a digital VLSI design textbook discussing modifications to a FIFO state machine in Verilog code, including an example task to prevent race conditions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p193.jpg,True,"```verilog
always@(o1, o2, o3, o4, o5, o6, o8)
begin
  out_orig[0] <= o1;
  out_orig[1] <= o2;
  out_orig[2] <= o3;
  out_orig[3] <= o4;
  out_orig[4] <= o5;
  out_orig[5] <= o6;
  out_orig[6] <= o7;
  out_orig[7] <= o8;
end

always@(d1, d2, d3, d4, d5, d6, d7, d8)
begin
  for(i=0; i<8; i++)
  begin
    out_local[i] <=
      (d1*wh_local[i][0]) + (d2*wh_local[i][1]) +
      (d3*wh_local[i][2]) + (d4*wh_local[i][3]) +
      (d5*wh_local[i][4]) + (d6*wh_local[i][5]) +
      (d7*wh_local[i][6]) + (d8*wh_local[i][7]) ;
  end
end

end

genvar j;
generate
for(j=0; j<8; j++)
begin : loop
  a_au_comp_chk_0 :
  assert property
  (@(posedge clk) (reset &&enable2) |-> 
   (out_local[j] == out_orig[j]));
end
```
This Verilog code is taken from a book or a paper, and seems to be part of a section titled ""SVA for data intensive designs"". The code contains a couple of always blocks and a generate block involving for loops and an assertion for property checking.","
always@(o1, o2, o3, o4, o5, o6, o8)
begin
  out_orig[0] <= o1;
  out_orig[1] <= o2;
  out_orig[2] <= o3;
  out_orig[3] <= o4;
  out_orig[4] <= o5;
  out_orig[5] <= o6;
  out_orig[6] <= o7;
  out_orig[7] <= o8;
end

always@(d1, d2, d3, d4, d5, d6, d7, d8)
begin
  for(i=0; i<8; i++)
  begin
    out_local[i] <=
      (d1*wh_local[i][0]) + (d2*wh_local[i][1]) +
      (d3*wh_local[i][2]) + (d4*wh_local[i][3]) +
      (d5*wh_local[i][4]) + (d6*wh_local[i][5]) +
      (d7*wh_local[i][6]) + (d8*wh_local[i][7]) ;
  end
end

end

genvar j;
generate
for(j=0; j<8; j++)
begin : loop
  a_au_comp_chk_0 :
  assert property
  (@(posedge clk) (reset &&enable2) |-> 
   (out_local[j] == out_orig[j]));
end
","""Example of Verilog code for signal assignments and SystemVerilog Assertions (SVA) for design validation.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p92.jpg,True,"The image contains a snippet of Verilog code. Here is the code written out:

```verilog
a1: assert property (@(posedge clk) a);
```

This line of code is an example of a SystemVerilog assertion, which asserts that a certain property (in this case, signal `a` being true at the positive edge of the clock `clk`) holds true.","
a1: assert property (@(posedge clk) a);
","Caption: ""A textbook page explaining the role of clocking events in concurrent assertions with a specific focus on SystemVerilog Assertion (SVA) and how the assertion clock interacts with property expressions in verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p257.jpg,True,"The image contains Verilog code snippets in the context of SystemVerilog assertions. Here are the code snippets from the image:

```verilog
a1: assert property (req ##1 !done[*] ##1 done |=> ready);
```

```verilog
a2: assert property (req ##1 done[-:1] |=> ready);
```

```verilog
a1: assert property (start ##1 req[*0:$-2:5] |-> en);
```

```verilog
a1: assert property (start ##1 req[*0:$-2:$] |-> en);
```","
a1: assert property (req ##1 !done[*] ##1 done |=> ready);


a2: assert property (req ##1 done[-:1] |=> ready);


a1: assert property (start ##1 req[*0:$-2:5] |-> en);


a1: assert property (start ##1 req[*0:$-2:$] |-> en);
",Verilog Sequence Operators and Goto Repetition Syntax Examples,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p88.jpg,True,"The image contains text and code written in the Verilog/SystemVerilog hardware description language. Here is the code from the image:

```verilog
Sample 2.33 Creating the sum of an array of single bits

bit one[6]; // Array of single bits
int total;

initial begin
    foreach (one[i])
        one[i] = i; // one[i] gets 0 or 1

    // Compute the single-bit sum
    total = one.sum(); // total = 1 = (0+1+0+1+0+1) & 1
    
    // Compute with 32-bit signed arithmetic
    total = one.sum() with (int'(item)); // total = 3
end
```

The code comments describe an example of summing an array of single bits using two different methods to illustrate the importance of operation width in SystemVerilog.","
Sample 2.33 Creating the sum of an array of single bits

bit one[6]; // Array of single bits
int total;

initial begin
    foreach (one[i])
        one[i] = i; // one[i] gets 0 or 1

    // Compute the single-bit sum
    total = one.sum(); // total = 1 = (0+1+0+1+0+1) & 1
    
    // Compute with 32-bit signed arithmetic
    total = one.sum() with (int'(item)); // total = 3
end
","""Verilog code snippet illustrating the calculation of the sum of an array of single bits using different precision in SystemVerilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p526.jpg,True,"The image shows a portion of a page from ""The Verilog PLI Handbook, Part Two"" and includes a fragment of C code related to Verilog Programming Language Interface (PLI). Here's the code that is visible in the image:

```c
void acc_free(array_ptr)
handle *array_ptr; /* pointer to an array of handles. */
```

This function declaration in C shows a prototype for the `acc_free` function, which is designed to free memory that has been previously allocated with the `acc_collect()` function within the context of Verilog PLI.

Below this function declaration, there's a comment regarding the source code location for the accompanying examples, followed by the beginning of another example which is titled ""Example 15-5: \$display_all_nets — using the acc_collect() routine"". This section includes the beginning of a C code snippet that includes `#include` preprocessor directives and a `typedef` structure definition:

```c
#include ""veriusert.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */
/******************************************************************** 
 * structure definition for data to be passed from misctf to calltf *
 ********************************************************************/
typedef struct PLIbook_NetData {
    handle module_h;
    handle *net_array;
    int net_count;
} PLIbook_NetData_s, *PLIbook_NetData_p;
```

The code above is meant to include standard PLI libraries and define a data structure for use within a PLI application, which typically aids in passing data between different callback routines.","acc_free(array_ptr)
handle *array_ptr; /* pointer to an array of handles. */

ude ""veriusert.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */
/******************************************************************** 
 * structure definition for data to be passed from misctf to calltf *
 ********************************************************************/
typedef struct PLIbook_NetData {
    handle module_h;
    handle *net_array;
    int net_count;
} PLIbook_NetData_s, *PLIbook_NetData_p;
","""Exploring Verilog PLI Memory Management and Example Code for Displaying All Nets""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p178.jpg,True,"The image contains Verilog code specifying system-level properties using SystemVerilog assertions (SVA). Here's the code text:

```verilog
property p_forbid_trans2a;
    @(posedge clk)
    (!((state == IDLE2) || (state == IDLE3) || (state == MASTER2) || (state == MASTER3))
    && reset) |->
    $past ((state == MASTER1) == 0);
endproperty

a_forbid_trans2a:
    assert property(p_forbid_trans2a);
c_forbid_trans2a:
    cover property(p_forbid_trans2a);

property p_forbid_trans2b;
    @(posedge clk)
    (((state == IDLE1) || (state == IDLE3) || (state == MASTER1) || (state == MASTER3))
    && reset) |->
    $past ((state == MASTER2) == 0);
endproperty

a_forbid_trans2b:
    assert property(p_forbid_trans2b);
c_forbid_trans2b:
    cover property(p_forbid_trans2b);

property p_forbid_trans2c;
    @(posedge clk)
    (((state == IDLE2) || (state == IDLE1) || (state == MASTER2) || (state == MASTER1))
    && reset) |->
    $past ((state == MASTER3) == 0);
endproperty

a_forbid_trans2c:
    assert property(p_forbid_trans2c);
c_forbid_trans2c:
    cover property(p_forbid_trans2c);
```

The properties defined here use temporal logic to constrain the behavior of a state machine related to the `state` signal and a `reset` signal on the positive edge clock events.","
property p_forbid_trans2a;
    @(posedge clk)
    (!((state == IDLE2) || (state == IDLE3) || (state == MASTER2) || (state == MASTER3))
    && reset) |->
    $past ((state == MASTER1) == 0);
endproperty

a_forbid_trans2a:
    assert property(p_forbid_trans2a);
c_forbid_trans2a:
    cover property(p_forbid_trans2a);

property p_forbid_trans2b;
    @(posedge clk)
    (((state == IDLE1) || (state == IDLE3) || (state == MASTER1) || (state == MASTER3))
    && reset) |->
    $past ((state == MASTER2) == 0);
endproperty

a_forbid_trans2b:
    assert property(p_forbid_trans2b);
c_forbid_trans2b:
    cover property(p_forbid_trans2b);

property p_forbid_trans2c;
    @(posedge clk)
    (((state == IDLE2) || (state == IDLE1) || (state == MASTER2) || (state == MASTER1))
    && reset) |->
    $past ((state == MASTER3) == 0);
endproperty

a_forbid_trans2c:
    assert property(p_forbid_trans2c);
c_forbid_trans2c:
    cover property(p_forbid_trans2c);
","""Verilog code example showcasing properties and assertions for state transition forbiddance in a finite state machine""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p531.jpg,True,"```verilog
rand bit myclk;
always_ff @(global_clock)
    myclk <= !myclk;
```

```verilog
rand some_type v;
always_ff @(global_clock v <= e;
```

```verilog
assume property (@(global_clock) $future_gclk(v) === e);
```

```verilog
assume property (@(global_clock) $changing_gclk(myclk));
```

```verilog
v' <- @(edge clk) e, which is controlled by clocking event (edge clk), is defined as v' <- (clk /# clk') ? e : v.
```

The image contains excerpts of code and text from a book or similar document discussing the semantics of unconditional assignment to free variables in Verilog.","
rand bit myclk;
always_ff @(global_clock)
    myclk <= !myclk;


rand some_type v;
always_ff @(global_clock v <= e;


assume property (@(global_clock) $future_gclk(v) === e);


assume property (@(global_clock) $changing_gclk(myclk));


v' <- @(edge clk) e, which is controlled by clocking event (edge clk), is defined as v' <- (clk /# clk') ? e : v.
","Caption: ""Excerpt from a technical document discussing Verilog checker modeling with free variables, including examples of non-deterministic behavior and formal semantics related to global and arbitrary clocks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p58.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
module module_name
( name of outputN width_if_not_1 port_name, ...,
  name of inputN width_if_not_1 port_name, ...,
  name of inoutN width_if_not_1 port_name, ... );
... nothing more to declare about ports; but, for each output port with width > 1:
reg width new_reg_nameN;
assign outputN = new_reg_nameN; // All work below will be with new_reg_nameN.
...
endmodule
```","
module module_name
( name of outputN width_if_not_1 port_name, ...,
  name of inputN width_if_not_1 port_name, ...,
  name of inoutN width_if_not_1 port_name, ... );
... nothing more to declare about ports; but, for each output port with width > 1:
reg width new_reg_nameN;
assign outputN = new_reg_nameN; // All work below will be with new_reg_nameN.
...
endmodule
","Caption: ""Comparison of Verilog header formats from traditional to the 2001 standard including an example of module declaration with IO ports and a brief overview of related pitfalls with traditional header declarations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p45.jpg,True,"The image does contain code. Here is the Verilog code extracted from the image:

```verilog
property p7;
    @(posedge clk) a ##2 b;
endproperty

a7 : assert property(p7)
    $display(""Property p7 succeeded\n"");
else
    $display(""Property p7 failed\n"");
```

This Verilog code defines a property named `p7` and an assertion `a7` that checks the property. If the assertion passes, it will display ""Property p7 succeeded"", otherwise, it will display ""Property p7 failed"".","
property p7;
    @(posedge clk) a ##2 b;
endproperty

a7 : assert property(p7)
    $display(""Property p7 succeeded\n"");
else
    $display(""Property p7 failed\n"");
",A textbook page explaining the use of action blocks in SystemVerilog assertions with example code for a property and corresponding assert statement.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p525.jpg,True,"The image contains Verilog code in two blocks. Here's the code as it appears in the image:

First code block:
```verilog
checker success;
  default clocking @($global_clock); endclocking
  rand bit v;
  a1: assert property (v || !v);
endchecker : success
```

Second code block:
```verilog
checker check;
  default clocking @($global_clock); endclocking
  rand bit v;
  a1: assert property (s_eventually v);
  a2: assert property (s_eventually !v);
endchecker : check
```","
checker success;
  default clocking @($global_clock); endclocking
  rand bit v;
  a1: assert property (v || !v);
endchecker : success


checker check;
  default clocking @($global_clock); endclocking
  rand bit v;
  a1: assert property (s_eventually v);
  a2: assert property (s_eventually !v);
endchecker : check
",The image depicts an excerpt from a technical document explaining the concept of free variables in the context of Verilog assertions and checkers. It includes sample Verilog code illustrating assertions with free variables.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p243.jpg,True,"The image contains Verilog code. Here is the code excerpt from the image:

1. The general `case` property structure:
```verilog
case (b)
  b1: p1;
  ...
  bn: pn;
  default: p;
endcase
```
2. The `property p` example:
```verilog
property p(bit [2:0] delay);
  case (delay)
    0: a;
    1: nexttime[1] a;
    2: nexttime[2] a;
    3: nexttime[3] a;
    4: nexttime[4] a;
    default: 1'b0; // delay too large
  endcase
endproperty : p
```","
case (b)
  b1: p1;
  ...
  bn: pn;
  default: p;
endcase


property p(bit [2:0] delay);
  case (delay)
    0: a;
    1: nexttime[1] a;
    2: nexttime[2] a;
    3: nexttime[3] a;
    4: nexttime[4] a;
    default: 1'b0; // delay too large
  endcase
endproperty : p
","Caption: ""Verilog code snippet illustrating the use of a `case` property for defining sequence delays based on register values, along with a discussion on implications and followed-by operators in SVA (SystemVerilog Assertions).""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p254.jpg,True,"```verilog
initial
  $scientific_alu(a, b, opcode, result, exception, error);
```

The image contains a snippet of Verilog code within the text.","
initial
  $scientific_alu(a, b, opcode, result, exception, error);
",Page from the Verilog PLI Handbook discussing simulation callback routines in Verilog simulations.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p394.jpg,True,"The image contains a Verilog code snippet. Here is the code transcribed from the image:

```verilog
reg FastClock;
wire WireToDelay, WireFromDelay;
assign WireToDelay = ~FastClock; // oscillation here.
// ----------------------------------------------
// A nor always block will allow initialization:
always@(WireFromDelay, Reset)
  if (Reset==1'b1)
    FastClock <= 1'b0;
  else FastClock <= WireFromDelay;
// ----------------------------------------------
// The delays control the (fixed) fast oscillator speed:
LibraryDelayCell Delay0 ( .Out(Wire1), .In(WireToDelay) );
LibraryDelayCell Delay1 ( .Out(Wire2), .In(Wire1) );
...
LibraryDelayCell DelayN ( .Out(WireFromDelay), .In(WireN) );
// (synthesizer dont_touch on all Delay* instances)
```

This code describes a fast counter oscillator controlled by a delay line, which can be configured using Verilog's generate statement and calibrated delay cells from a library. It includes a reset functionality and is designed to create an oscillating signal (`FastClock`).","
reg FastClock;
wire WireToDelay, WireFromDelay;
assign WireToDelay = ~FastClock; // oscillation here.
// ----------------------------------------------
// A nor always block will allow initialization:
always@(WireFromDelay, Reset)
  if (Reset==1'b1)
    FastClock <= 1'b0;
  else FastClock <= WireFromDelay;
// ----------------------------------------------
// The delays control the (fixed) fast oscillator speed:
LibraryDelayCell Delay0 ( .Out(Wire1), .In(WireToDelay) );
LibraryDelayCell Delay1 ( .Out(Wire2), .In(Wire1) );
...
LibraryDelayCell DelayN ( .Out(WireFromDelay), .In(WireN) );
// (synthesizer dont_touch on all Delay* instances)
","""Excerpt from a book on Digital VLSI Design with Verilog showing a schematic for a synthesizable VFO internal FastClock and accompanying Verilog code snippet for an oscillator circuit.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p267.jpg,True,"The image contains the following Verilog code:

```verilog
class Transaction;
  rand rw_e rw;
  rand bit [31:0] addr, data;
endclass

class RandTransaction;
  rand Transaction trans_array[];

  constraint rw_c {foreach (trans_array[i])
    if ((i>0) && (trans_array[i-1].rw == WRITE))
      trans_array[i].rw != WRITE;}

  function new();
    trans_array = new[TESTS];
    foreach (trans_array[i])
      trans_array[i] = new();
  endfunction

endclass
```

This code snippet defines two classes for a Verilog transaction-level model: `Transaction` and `RandTransaction`. `Transaction` class has randomizable properties `rw`, `addr`, and `data`. `RandTransaction` class contains an array of `Transaction` objects and a constraint `rw_c` to ensure that consecutive write transactions do not happen at the same address. It also includes a `new` function to create an array of `Transaction` objects.","
class Transaction;
  rand rw_e rw;
  rand bit [31:0] addr, data;
endclass

class RandTransaction;
  rand Transaction trans_array[];

  constraint rw_c {foreach (trans_array[i])
    if ((i>0) && (trans_array[i-1].rw == WRITE))
      trans_array[i].rw != WRITE;}

  function new();
    trans_array = new[TESTS];
    foreach (trans_array[i])
      trans_array[i] = new();
  endfunction

endclass
","Caption: ""Verilog code snippet showing the definition of a Transaction class and a RandTransaction class, with constraints and function definitions for generating random transactions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p45.jpg,True,"```verilog
logic end_reset, operational, enter_deadlock_area, stuck, clk;
// ...
property forever_n(x, n);
  nexttime[n] always x;
endproperty
a1: assert property (@(posedge clk)
  end_reset |-> forever_n(operational, 100));
a2: assert property (@(posedge clk)
  enter_deadlock_area |-> forever_n(stuck, 5));
```","
logic end_reset, operational, enter_deadlock_area, stuck, clk;
// ...
property forever_n(x, n);
  nexttime[n] always x;
endproperty
a1: assert property (@(posedge clk)
  end_reset |-> forever_n(operational, 100));
a2: assert property (@(posedge clk)
  enter_deadlock_area |-> forever_n(stuck, 5));
","""Example of Verilog Property Reuse for Assertions in Hardware Verification""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p70.jpg,True,"The image contains snippets of Verilog code, which are examples of procedural control constructs. Here's the code extracted from the image:

```verilog
if (expr) statement1;
else if (expr) statement2;
else statement3;

case (expr)
  alt1: statement1;
  alt2: statement2;
  ...
  default: default_stmt;
endcase

for (loop_var_init; loop_reentry_expression; loop_var_update)
  statement(s);
```

These examples illustrate the use of `if`, `case`, and `for` constructs in Verilog.","
if (expr) statement1;
else if (expr) statement2;
else statement3;

case (expr)
  alt1: statement1;
  alt2: statement2;
  ...
  default: default_stmt;
endcase

for (loop_var_init; loop_reentry_expression; loop_var_update)
  statement(s);
","An educational text explaining Verilog procedural control constructs, including ""if,"" ""case,"" and ""for"" statements, and the conditional expression operator.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p144.jpg,True,"The image contains Verilog code, which is used for hardware description and verification. Here is the code extracted from the image:

```verilog
creq3++;
if(creq3 == 3) creq3_flag = 1'b1;
end

c_req12: cover property(p_req12)
begin
creq12++;
if(creq12 == 3) creq12_flag = 1'b1;
end

c_req23: cover property(p_req23)
begin
creq23++;
if(creq23 == 3) creq23_flag = 1'b1;
end

c_req31: cover property(p_req31)
begin
creq31++;
if(creq31 == 3) creq31_flag = 1'b1;
end

c_req123: cover property(p_req123)
begin
creq123++;
if(creq123 == 3) creq123_flag = 1'b1;
end
```

And there is also a snippet of a conditional block that seems to be within an 'always' block:

```verilog
always@(posedge clk)
begin

if(creq1_flag && creq2_flag && creq3_flag && creq12_flag && creq23_flag && creq31_flag && creq123_flag)
begin
```

Please note that the actual condition check and what happens inside the last 'if' and 'begin' block is not fully visible in the image; hence, I'm unable to provide that part of the code.","
creq3++;
if(creq3 == 3) creq3_flag = 1'b1;
end

c_req12: cover property(p_req12)
begin
creq12++;
if(creq12 == 3) creq12_flag = 1'b1;
end

c_req23: cover property(p_req23)
begin
creq23++;
if(creq23 == 3) creq23_flag = 1'b1;
end

c_req31: cover property(p_req31)
begin
creq31++;
if(creq31 == 3) creq31_flag = 1'b1;
end

c_req123: cover property(p_req123)
begin
creq123++;
if(creq123 == 3) creq123_flag = 1'b1;
end


always@(posedge clk)
begin

if(creq1_flag && creq2_flag && creq3_flag && creq12_flag && creq23_flag && creq31_flag && creq123_flag)
begin
","Caption: ""Excerpt from a document showing Verilog code snippets for SystemVerilog Assertions (SVA) covering properties in a simulation methodology.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p150.jpg,True,"The image contains a snippet of a document that refers to Verilog/SystemVerilog concepts for simulation and verification, however, the actual content is not Verilog code but rather psuedocode or a conceptual representation of certain flags or conditions.

Here is the text that relates to simulation methodology:

```
creq123_flag && m1_t1_r_flag && m1_t1_w_flag && m1_t0_r_flag && m1_t0_w_flag && m2_t1_r_flag &&
m2_t1_w_flag && m2_t0_r_flag && m2_t0_w_flag && m3_t1_r_flag && m3_t1_w_flag && m3_t0_r_flag &&
m3_t0_w_flag)

begin

$display(""FC: All possible request scenarios covered 3 times\n"");

$display(""FC: All possible transactions covered 3 times\n"");

$finish();

end
end
```

Please note that this snippet is a conditional expression followed by what appears to be procedural code within a 'begin ... end' block. The `$display` and `$finish` are system tasks in Verilog/SystemVerilog used for debugging and controlling simulation, respectively. The purpose of this code seems to be for displaying messages within a simulation and then finishing the simulation run.","3_flag && m1_t1_r_flag && m1_t1_w_flag && m1_t0_r_flag && m1_t0_w_flag && m2_t1_r_flag &&
m2_t1_w_flag && m2_t0_r_flag && m2_t0_w_flag && m3_t1_r_flag && m3_t1_w_flag && m3_t0_r_flag &&
m3_t0_w_flag)

begin

$display(""FC: All possible request scenarios covered 3 times\n"");

$display(""FC: All possible transactions covered 3 times\n"");

$finish();

end
end
","Caption: ""An excerpt from a document discussing SVA simulation methodology, showcasing a piece of Verilog code related to functional coverage and simulation termination when all possible request scenarios and transactions are covered.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p64.jpg,True,"The image contains several snippets of Verilog code. Here they are transcribed for you:

```verilog
reg[3:0] A, B;
reg Z; ...
Z = A && B;
```

And:

```verilog
reg[3:0] Z;
reg A, B; ...
Z = A && B;
```

Additionally, the image contains other examples of type conversions for vector operations:

```verilog
reg[3:0] A, B, Z;
...
x = A && B; // x gets 1'b0 only if either A or B is 4'b0.
z = A && B; // z gets 4'b0 only if either A or B is 4'b0.
            // Otherwise, z gets 4'b0001

z = A & B;  // Each bit of Z get the and of the
            // corresponding bits of A and B.
x = !Z;     // x gets 1'b1 only if all bits of Z are 0.
x = ~Z;     // Z narrows to its LSB and is inverted; so x gets !Z[0].
```

Please note that `reg` is a keyword in Verilog for declaring registers, `&&` is the logical AND operator, `&` is the bitwise AND operator, `!` is the logical negation operator, and `~` is the bitwise negation operator.","
reg[3:0] A, B;
reg Z; ...
Z = A && B;


reg[3:0] Z;
reg A, B; ...
Z = A && B;


reg[3:0] A, B, Z;
...
x = A && B; // x gets 1'b0 only if either A or B is 4'b0.
z = A && B; // z gets 4'b0 only if either A or B is 4'b0.
            // Otherwise, z gets 4'b0001

z = A & B;  // Each bit of Z get the and of the
            // corresponding bits of A and B.
x = !Z;     // x gets 1'b1 only if all bits of Z are 0.
x = ~Z;     // Z narrows to its LSB and is inverted; so x gets !Z[0].
","""Description and examples of vector operations and type conversions in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p79.jpg,True,"The image contains some Verilog code related to the ""intersect"" construct. Here is the code from the image:

```verilog
sequence s28a;
    @(posedge clk) a##[1:2] b;
endsequence

sequence s28b;
    @(posedge clk) c##[2:3] d;
endsequence

property p28;
    @(posedge clk) s28a intersect s28b;
endproperty
```","
sequence s28a;
    @(posedge clk) a##[1:2] b;
endsequence

sequence s28b;
    @(posedge clk) c##[2:3] d;
endsequence

property p28;
    @(posedge clk) s28a intersect s28b;
endproperty
","An excerpt from a document describing the use of the ""intersect"" construct in Verilog for sequence and property definition, with an example of its implementation.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p380.jpg,True,"The image contains Verilog code. Here it is:

```verilog
wire ClockToHold;
assign #tCancel ClockToHold = Clock; // tCancel from IP vendor or experiment.
specify
  $hold (posedge ClockToHold, DataIn, tHold); // tHold from data book.
  ...
```

and further down:

```verilog
$setup ( D&&&[Ena=='b1], posedge Clk, MinD_Clk );
```

The text surrounding these snippets describes avoiding negative time limits by adding an input delay and explains timing check conditioned events in Verilog.","
wire ClockToHold;
assign #tCancel ClockToHold = Clock; // tCancel from IP vendor or experiment.
specify
  $hold (posedge ClockToHold, DataIn, tHold); // tHold from data book.
  ...


$setup ( D&&&[Ena=='b1], posedge Clk, MinD_Clk );
","Caption: ""Discussion on Verilog strategies to avoid negative time limits in timing checks and introducing the concept of timing check notifiers.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p273.jpg,True,"The image contains an excerpt of Verilog code. Here is the transcribed code from the image:

```verilog
Sample 7.7 Generator / Driver class with a run task

class Gen_drive;

// Transactor that creates N packets
task run(input int n);
    Packet p;

    fork
        repeat (n) begin
            p = new();
            `SV_RAND_CHECK(p.randomize());
            transmit(p);
        end
        join_none  // Use fork-join_none so run() does not block
    endtask
    
    task transmit(input Packet p);
        ...
    endtask
endclass

Gen_drive gen;

initial begin
    gen = new();
    gen.run(10);
    // Start the checker, monitor, and other threads
    ...
end
```

This code defines a class `Gen_drive` that contains a `run` task for generating `N` packets and sending them using the `transmit` method. It employs a non-blocking construct `fork...join_none` to ensure `run()` does not block the flow of execution. A `transmit` task is also provided but the specific implementation detail is omitted with `...`. An object `gen` of `Gen_drive` class is then created and `run(10)` is initiated in an initial block to generate and transmit 10 packets. Further actions like starting a checker, monitor, or other threads are hinted at by ellipses.","
Sample 7.7 Generator / Driver class with a run task

class Gen_drive;

// Transactor that creates N packets
task run(input int n);
    Packet p;

    fork
        repeat (n) begin
            p = new();
            `SV_RAND_CHECK(p.randomize());
            transmit(p);
        end
        join_none  // Use fork-join_none so run() does not block
    endtask
    
    task transmit(input Packet p);
        ...
    endtask
endclass

Gen_drive gen;

initial begin
    gen = new();
    gen.run(10);
    // Start the checker, monitor, and other threads
    ...
end
","""Example of a Verilog class with fork-join_none for non-blocking thread creation and a task for transmitting packets.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p51.jpg,True,"```verilog
module m #(bit FLAG = 1) (input logic in1, in2, select, output logic out1, out2);
    if (FLAG) assign out1 = in1;
    else assign out1 = in2;
    always_comb
        if (select) out2 = in1;
        else out2 = in2;
endmodule : m
```","
module m #(bit FLAG = 1) (input logic in1, in2, select, output logic out1, out2);
    if (FLAG) assign out1 = in1;
    else assign out1 = in2;
    always_comb
        if (select) out2 = in1;
        else out2 = in2;
endmodule : m
",Example of generate if and procedural if statements in Verilog code.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p268.jpg,True,"```c
cb_data_s.obj = ALUdata->b_h;
vpi_register_cb(&cb_data_s);

value_s.format = vpIntVal;
cb_data_s.obj = ALUdata->opcode_h;
vpi_register_cb(&cb_data_s);

/* clear the callback sync_flag to indicate that no read-write */
/* synchronize callbacks have been processed */
ALUdata->sync_flag = 0;

return(0);
}
```","ta_s.obj = ALUdata->b_h;
vpi_register_cb(&cb_data_s);

value_s.format = vpIntVal;
cb_data_s.obj = ALUdata->opcode_h;
vpi_register_cb(&cb_data_s);

/* clear the callback sync_flag to indicate that no read-write */
/* synchronize callbacks have been processed */
ALUdata->sync_flag = 0;

return(0);
}
","Caption: ""Excerpt from 'The Verilog PLI Handbook' showing code related to registering callbacks and synchronizing activities in C models with Verilog simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p169.jpg,True,"```verilog
always@(posedge clockIn)
begin
    #1 a = b;
    // (other statements)
end
...
always@(a, b, c)
begin
    #2 ena = (c==1) ? 1 : a & b; // An if could be used here.
    #2 ena = a ^ b;
end
```

```verilog
always@(posedge clockIn)
begin
    #1 a = b;
    // (other statements)
end
...
always@(a, b, c)
    #2 ena = (c==1) ? 1 : a & b;
```","
always@(posedge clockIn)
begin
    #1 a = b;
    // (other statements)
end
...
always@(a, b, c)
begin
    #2 ena = (c==1) ? 1 : a & b; // An if could be used here.
    #2 ena = a ^ b;
end


always@(posedge clockIn)
begin
    #1 a = b;
    // (other statements)
end
...
always@(a, b, c)
    #2 ena = (c==1) ? 1 : a & b;
","Caption: ""Resolving Race Conditions in Verilog by Using Consistent Clocking Schemes""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p267.jpg,True,"The image contains two Verilog code snippets:

The first code snippet is an example of SystemVerilog functional coverage for all combinations of selects:

```verilog
genvar i;
generate for (i=1; i<=15; i = i + 1)
    cover property @(posedge clk) select == i;
endgenerate
```

The second code snippet is a Verilog-2001 fragment for a complex multiplexer:

```verilog
always @(*) begin
    legal_state_size: assert property
    (@(posedge clk) disable iff (reset_n)
        (somehto[stite_size1[2:0]]) )
    else $error (""illegal state_size1 value %0b."", state_size1 [2:0]);

    casez ({size_sel, state_size1[2:0]}) // synopsys parallel_case full_case
    4'b1_??1: next_size = case_a_route;
    4'b0_??1: next_size = case_b_route;
    4'b?_1??: next_size = case_c_route;
    4'b?_0??: next_size = case_d_route;
    4'b0_000: next_size = case_e_route;
    endcase
end
```

Please note that there is a typing error in the assertion part of the second code snippet. It appears to be ""somehto"" when it likely should be a placeholder for actual condition logic, and ""stite_size1"" should presumably be ""state_size1"". These would need to be corrected to form a valid Verilog code.","
genvar i;
generate for (i=1; i<=15; i = i + 1)
    cover property @(posedge clk) select == i;
endgenerate


always @(*) begin
    legal_state_size: assert property
    (@(posedge clk) disable iff (reset_n)
        (somehto[stite_size1[2:0]]) )
    else $error (""illegal state_size1 value %0b."", state_size1 [2:0]);

    casez ({size_sel, state_size1[2:0]}) // synopsys parallel_case full_case
    4'b1_??1: next_size = case_a_route;
    4'b0_??1: next_size = case_b_route;
    4'b?_1??: next_size = case_c_route;
    4'b?_0??: next_size = case_d_route;
    4'b0_000: next_size = case_e_route;
    endcase
end
","Caption: ""Examples of SystemVerilog code for functional coverage and complex multiplexer design with assertions and casez statement.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p71.jpg,True,"The image contains Verilog code. Here's the code snippet:

```verilog
always @(posedge clk)
begin
    if (dbusAck)
        begin
            checkbusReq: assert (busReq && !reset) `uDispaly(""\n%t ****************************************
            *********************************************** busReq asserted and reset inactive - %m passed\n"");
        else
        begin
            $fatal(""\n%stime,.., %m failed \n"");
            #machinecheck = 1'b1; //DON'T PUT EXECUTABLE RTL HERE...
        end
    end
end
```

There is also an example of an immediate assertion declared incorrectly in a continuous assignment statement, which is highlighted as illegal and will cause a compile-time error:

```verilog
assign arb = assert (a || b); // ILLEGAL
```

A note accompanying the illegal statement mentions that immediate assertions cannot be used in continuous assignments because continuous assignment is a non-procedural statement. This would result in a compile-time error.","
always @(posedge clk)
begin
    if (dbusAck)
        begin
            checkbusReq: assert (busReq && !reset) `uDispaly(""\n%t ****************************************
            *********************************************** busReq asserted and reset inactive - %m passed\n"");
        else
        begin
            $fatal(""\n%stime,.., %m failed \n"");
            #machinecheck = 1'b1; //DON'T PUT EXECUTABLE RTL HERE...
        end
    end
end


assign arb = assert (a || b); // ILLEGAL
","Caption: ""Exploring Immediate Assertions in Verilog and their limitations within non-procedural statements.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p65.jpg,True,"The image contains the following Verilog code:

```verilog
cover sequence (
  clocking_event ] [ disable iff ( expression_or_dist ) ]
  sequence_expr )
  statement_or_null
```

This appears to be an excerpt from a document explaining the ""cover sequence"" construct in SystemVerilog, including its formal syntax, as defined in the SystemVerilog 3.1a Language Reference Manual (LRM).","
cover sequence (
  clocking_event ] [ disable iff ( expression_or_dist ) ]
  sequence_expr )
  statement_or_null
","""Explanation of 'cover sequence' syntax and usage in SystemVerilog for verification coverage.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p273.jpg,True,"```verilog
genvar N;
generate for (N=0; N<=20; N= N+ 1)
    cover property @(posedge clk) (done ##N req);
endgenerate
```","
genvar N;
generate for (N=0; N<=20; N= N+ 1)
    cover property @(posedge clk) (done ##N req);
endgenerate
","""Example of SystemVerilog code for functional coverage measurement, addressing timing corner cases in transactions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p209.jpg,True,"The image contains Verilog code. Here is the text transcription of the code:

```verilog
A1: assert property (
    @(posedge clk1) Frame__ |-> nexttime @(posedge clk2) IRDY);
    
A2: assert property (
    @(posedge clk1) Frame__ |-> ##1 @(posedge clk2) IRDY;
    
A3: assert property (
    @(posedge clk1) Frame__ |-> @(posedge clk2) nexttime IRDY;

a1: assert property (
    (@(posedge clk) en && $rose(req) |=> gnt);
    
a2: assert property (
    (@(posedge clk) en && $rose(req, @(posedge sysclk)) |=> gnt);
    
always_ff @(posedge clk1)
    Dreg <= $rose (Xreg, @(posedge sysclk));
```

The code contains several assertions and one always_ff block that are commonly used in formal verification with SystemVerilog assertion (SVA).","
A1: assert property (
    @(posedge clk1) Frame__ |-> nexttime @(posedge clk2) IRDY);
    
A2: assert property (
    @(posedge clk1) Frame__ |-> ##1 @(posedge clk2) IRDY;
    
A3: assert property (
    @(posedge clk1) Frame__ |-> @(posedge clk2) nexttime IRDY;

a1: assert property (
    (@(posedge clk) en && $rose(req) |=> gnt);
    
a2: assert property (
    (@(posedge clk) en && $rose(req, @(posedge sysclk)) |=> gnt);
    
always_ff @(posedge clk1)
    Dreg <= $rose (Xreg, @(posedge sysclk));
",Verilog Assertions and Clocking Example: Understanding Clock Flow in SVA (SystemVerilog Assertions) and Sampled Value Functions.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p298.jpg,True,"The image contains two code snippets which are examples demonstrating the correct and incorrect use of assertions in Property Specification Language (PSL) for Verilog:

Example 8-26 PSL: Incorrect use of a negated Implication
```
// Will produce a false error at every clock when req does not occur
assert never (req -> next halt);
```

Example 8-27 PSL: Correct use of a forbidden sequence
```
// Will produce correct error whenever a halt occurs after a req
assert never ({req; halt});
```","l produce a false error at every clock when req does not occur
assert never (req -> next halt);

l produce correct error whenever a halt occurs after a req
assert never ({req; halt});
","""Verilog Property Specification Language (PSL) examples illustrating incorrect and correct use of negated implications and forbidden sequences in assertions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p724.jpg,True,"```c
typedef struct t_vpi_systf_data {
    int type;                 /* vpiSysTask, vpiSysFunc */
    int subtype;              /* vpiSysFuncInt, vpiSysFuncReal,
                                 vpiSysFuncTime, vpiSysFuncSized */
    char *tfname;             /* quoted task/function name,
                                 first character must be $ */
    int (*calltf)();          /* unquoted name of C routine */
    int (*compiletf)();       /* unquoted name of C routine */
    int (*sizetf)();          /* unquoted name of C routine,
                                 only used with vpiSysFuncSized
                                 callbacks */
    char *user_data;          /* returned with callback */
} s_vpi_systf_data, *p_vpi_systf_data;
```

There is no additional executable Verilog code beyond this struct definition in the image, but there's some explanation of a Verilog PLI (Programming Language Interface) function and some typedefs associated with it.","ef struct t_vpi_systf_data {
    int type;                 /* vpiSysTask, vpiSysFunc */
    int subtype;              /* vpiSysFuncInt, vpiSysFuncReal,
                                 vpiSysFuncTime, vpiSysFuncSized */
    char *tfname;             /* quoted task/function name,
                                 first character must be $ */
    int (*calltf)();          /* unquoted name of C routine */
    int (*compiletf)();       /* unquoted name of C routine */
    int (*sizetf)();          /* unquoted name of C routine,
                                 only used with vpiSysFuncSized
                                 callbacks */
    char *user_data;          /* returned with callback */
} s_vpi_systf_data, *p_vpi_systf_data;
","""Verilog PLI Handbook - Information and code snippet on PLI system tasks and functions registration in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p718.jpg,True,"The image contains a snippet of documentation related to Verilog PLI (Programming Language Interface), specifically the C data structures and type definitions that interface with Verilog. Here is the text of the code in the image:

```c
void vpi_get_value(vpiHandle expr, p_vpi_value value)
vpiHandle expr                        handle for an object.
p_vpi_value value                     pointer to an application-allocated s_vpi_value structure to receive value information.

Retrieves the simulation value of an expression into an s_vpi_value structure.

typedef struct t_vpi_value {
  int format;               /* vpiBinStrVal, vpiOctStrVal, vpiDecStrVal,
                               vpiHexStrVal, vpiScalarVal, vpiIntVal,
                               vpiRealVal, vpiStringVal, vpiVectorVal,
                               vpiStrengthVal, vpiSuppressVal, vpiTimeVal,
                               vpiObjTypeVal */
  union {
    char *str;              /* string value */
    int scalar;             /* vpi0, vpi1, vpiX, vpiZ, vpiH, vpiL,
                               vpiDontCare */
                             /* integer value */
    int integer;             /* integer value */
    double real;             /* real value */
    struct t_vpi_time *time; /* time value */
    struct t_vpi_vecval *vector; /* vector value*/
    struct t_vpi_strengthval *strength; /* strength value */
    char *misc;              /* reserved */
  } value;
} s_vpi_value, *p_vpi_value;

typedef struct t_vpi_time {
  int type;                 /* vpiScaledRealTime, vpiSimTime,
                               vpiSuppressTime */
  unsigned int high;        /* when using vpiSimTime */
  unsigned int low;         /* when using vpiSimTime */
  double real;              /* when using vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;

typedef struct t_vpi_vecval {
  /* one aval/bval pair for each bit in vector */
  int aval, bval;           /* bit encoding: a/b: 0/0==0,
                               1/1==1, 1/1==X, 0/1==Z */
} s_vpi_vecval, *p_vpi_vecval;

typedef struct t_vpi_strengthval {
  int logic;                /* vpi0, vpi1, vpiX, vpiZ */
  int s0, s1;               /* Logical-OR of the constants:
                               vpiSupplyDrive, vpiStrongDrive,
                               vpiPullDrive, vpiWeakDrive,
                               vpiLargeCharge, vpiMediumCharge,
                               vpiSmallCharge, vpiHiZ */
} s_vpi_strengthval, *p_vpi_strengthval;
```

This code defines structures used for passing values between C applications and Verilog simulators through the PLI. These structures are an integral part of interfacing C code with a Verilog simulation, allowing for manipulation and observation of the simulation from C programs.","vpi_get_value(vpiHandle expr, p_vpi_value value)
vpiHandle expr                        handle for an object.
p_vpi_value value                     pointer to an application-allocated s_vpi_value structure to receive value information.

Retrieves the simulation value of an expression into an s_vpi_value structure.

typedef struct t_vpi_value {
  int format;               /* vpiBinStrVal, vpiOctStrVal, vpiDecStrVal,
                               vpiHexStrVal, vpiScalarVal, vpiIntVal,
                               vpiRealVal, vpiStringVal, vpiVectorVal,
                               vpiStrengthVal, vpiSuppressVal, vpiTimeVal,
                               vpiObjTypeVal */
  union {
    char *str;              /* string value */
    int scalar;             /* vpi0, vpi1, vpiX, vpiZ, vpiH, vpiL,
                               vpiDontCare */
                             /* integer value */
    int integer;             /* integer value */
    double real;             /* real value */
    struct t_vpi_time *time; /* time value */
    struct t_vpi_vecval *vector; /* vector value*/
    struct t_vpi_strengthval *strength; /* strength value */
    char *misc;              /* reserved */
  } value;
} s_vpi_value, *p_vpi_value;

typedef struct t_vpi_time {
  int type;                 /* vpiScaledRealTime, vpiSimTime,
                               vpiSuppressTime */
  unsigned int high;        /* when using vpiSimTime */
  unsigned int low;         /* when using vpiSimTime */
  double real;              /* when using vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;

typedef struct t_vpi_vecval {
  /* one aval/bval pair for each bit in vector */
  int aval, bval;           /* bit encoding: a/b: 0/0==0,
                               1/1==1, 1/1==X, 0/1==Z */
} s_vpi_vecval, *p_vpi_vecval;

typedef struct t_vpi_strengthval {
  int logic;                /* vpi0, vpi1, vpiX, vpiZ */
  int s0, s1;               /* Logical-OR of the constants:
                               vpiSupplyDrive, vpiStrongDrive,
                               vpiPullDrive, vpiWeakDrive,
                               vpiLargeCharge, vpiMediumCharge,
                               vpiSmallCharge, vpiHiZ */
} s_vpi_strengthval, *p_vpi_strengthval;
","""Verilog Programming Language Interface (PLI) Reference: Data Structures and Functions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p235.jpg,True,"The image shows a snippet of Verilog code which is part of a test-bench utilizing the `.triggered` construct to create an assertion property for state transition sequences. Here is the code:

```verilog
module state_transition;
    logic readStartState, readIDState, readDataState, readEndState;
    logic clk, read_enb;

    sequence readStart; @(posedge clk) read_enb ##1 readStartState;
    endsequence

    sequence readID; @(posedge clk) readStartState ##1 readIDState;
    endsequence

    sequence readData; @(posedge clk) readIDState ##1 readDataState;
    endsequence

    sequence readEnd; @(posedge clk) readDataState ##1 readEndState;
    endsequence

    property checkReadStates;
        @(posedge clk)
            readStart.triggered      ##[1:$]
            readID.triggered         ##[1:$]
            readData.triggered       ##[1:$]
            readEnd
        ;
    endproperty

    $Check: assert property (checkReadStates) else $display ($stime,,, ""FAIL"");
    cCheck: cover property (checkReadStates) $display ($stime,,, ""PASS"");
endmodule
```

This Verilog code specifies a module `state_transition` with multiple internal states and describes how the transitions between these states can be asserted and covered using SystemVerilog assertion (SVA) sequences and properties. It involves checking the triggering (activation) of sequences representing state transitions and is used to monitor the correct state progression in the module.","
module state_transition;
    logic readStartState, readIDState, readDataState, readEndState;
    logic clk, read_enb;

    sequence readStart; @(posedge clk) read_enb ##1 readStartState;
    endsequence

    sequence readID; @(posedge clk) readStartState ##1 readIDState;
    endsequence

    sequence readData; @(posedge clk) readIDState ##1 readDataState;
    endsequence

    sequence readEnd; @(posedge clk) readDataState ##1 readEndState;
    endsequence

    property checkReadStates;
        @(posedge clk)
            readStart.triggered      ##[1:$]
            readID.triggered         ##[1:$]
            readData.triggered       ##[1:$]
            readEnd
        ;
    endproperty

    $Check: assert property (checkReadStates) else $display ($stime,,, ""FAIL"");
    cCheck: cover property (checkReadStates) $display ($stime,,, ""PASS"");
endmodule
",Verilog code example demonstrating state transition sequences and properties using the `.triggered` method.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p182.jpg,True,"```verilog
always@(negedge clk)
  begin : MyNegedgeAlways
    ...
  end

begin : Loop_1_to_9
  for (j=1; j<=9; j = j + 1)
    begin
      ...
    end // for j.
end // Named loop block.
```","
always@(negedge clk)
  begin : MyNegedgeAlways
    ...
  end

begin : Loop_1_to_9
  for (j=1; j<=9; j = j + 1)
    begin
      ...
    end // for j.
end // Named loop block.
","Caption: ""Educational material explaining the function and naming of blocks in Verilog code, with an example of naming procedural blocks for improved readability and debugging, followed by a discussion on Phase-Locked Loop (PLL) in serial data transmission systems.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p221.jpg,True,"The image contains Verilog code. Here it is:

```verilog
sequence check_trdy (cycle_begin);
    cycle_begin ##2 ir_dy ##2 trdy;
endsequence

property illegal_use_of_local_with_triggered;
    bit local_var;
    (1'b1, local_var = CB) |-> check_trdy(local_var).
    triggered; // ILLEGAL
endproperty
```

This snippet shows an example of a sequence declaration and a property declaration in SystemVerilog. The comment indicates that using a local variable with the `.triggered` method in this way is illegal.","
sequence check_trdy (cycle_begin);
    cycle_begin ##2 ir_dy ##2 trdy;
endsequence

property illegal_use_of_local_with_triggered;
    bit local_var;
    (1'b1, local_var = CB) |-> check_trdy(local_var).
    triggered; // ILLEGAL
endproperty
","Caption: ""Rules and examples pertaining to the use of local variables in Verilog sequences and properties.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p693.jpg,True,"The image contains text and diagrams but no complete code segments. However, here are some function prototypes and enumerations related to Verilog Programming Interface (VPI) from the image:

```c
int vpiType
int vpiOpType
int vpiConstType
int vpiSize
str vpiFile
int vpiLineNo
```

The text underneath these prototypes explains what each function returns:

1. `vpiType` returns `vpiPartSelect`, `vpiOperation`, `vpiConstant`, `vpiFuncCall`, `vpiSysFuncCall`, `vpiNet`, `vpiReg`, `vpiIntegerVar`, `vpiTimeVar`, `vpiRealVar`, `vpiVarSelect`, `vpiParameter`, `vpiMemory`, `vpiMemoryWord`
2. `vpiOpType` if `vpiType` is `vpiOperation`, returns one of the operator constants shown in note 4, below.
3. `vpiConstType` if `vpiType` is `vpiConstant`, returns `vpiDecConst`, `vpiRealConst`, `vpiBinaryConst`, `vpiOctConst`, `vpiHexConst`, `vpiStringConst`.
4. `vpiSize` returns the bit size of the expression result.
5. `vpiFile` returns the file name containing the expression.
6. `vpiLineNo` returns the file line number containing the expression.

It also includes two footnotes:

1. The value of an expression is accessed using `vpi_get_value()`. The value of a memory cannot be accessed; instead, iterate on memory words and access the value of each word.
2. If an operator is `vpiMultiConcat`, the first operand is the multiplier expression.","piType
int vpiOpType
int vpiConstType
int vpiSize
str vpiFile
int vpiLineNo
","""Overview of VPI expression objects and associated routines in the IEEE 1364-1995 Verilog Standard.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p254.jpg,True,"The image contains two snippets of Verilog code. Here they are:

Example 9-27:
```verilog
module b_gc (ck ,rst , r_gc);
`include “Example9-25”
input ck ,rst;
output [1:0] r_gc;
wire [1:0] r_gc;
reg [1:0] n;
always @(r_gc)
    case (r_gc)
        ‘R_NORMAL : n = ‘R_WAIT;
        ‘R_WAIT : n = ‘R_IDLE;
        ‘R_IDLE : n = ‘R_DONE;
        ‘R_DONE : n = ‘R_NORMAL;
    endcase
dff #(2) reg_r ( .q(r_gc) , .ck(ck) , .d(n), .rst (rst) );
endmodule // b_gc
```

Example 9-28:
```verilog
reg [(8 * SWDTH) - 1 : 0] r_chip_id;
reg [IO_T_FLD] qt_array [0: QT_DEPTH-1];
```

These are pieces of code written in the Verilog hardware description language, with the first example being a complete module and the second example illustrating the declaration of register arrays.","
module b_gc (ck ,rst , r_gc);
`include “Example9-25”
input ck ,rst;
output [1:0] r_gc;
wire [1:0] r_gc;
reg [1:0] n;
always @(r_gc)
    case (r_gc)
        ‘R_NORMAL : n = ‘R_WAIT;
        ‘R_WAIT : n = ‘R_IDLE;
        ‘R_IDLE : n = ‘R_DONE;
        ‘R_DONE : n = ‘R_NORMAL;
    endcase
dff #(2) reg_r ( .q(r_gc) , .ck(ck) , .d(n), .rst (rst) );
endmodule // b_gc


reg [(8 * SWDTH) - 1 : 0] r_chip_id;
reg [IO_T_FLD] qt_array [0: QT_DEPTH-1];
","""Example of Verilog Code Module with Conditional Statements and Code Inclusion Directions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p382.jpg,True,"The image contains Verilog code. Here it is:

```verilog
//the following property is not needed. You can simply use ""property pr1""
//for 'cover' as well.

property pr1_for_cover;
    @(posedge clk) cstart ##0 sr1;
endproperty

`elsif nonoverlap
property pr1;
    @(posedge clk) cstart |=> sr1;
endproperty

//Note that if a simulator supports filter on vacuous pass for a 'cover'
//the property pr1_for_cover is not needed. You can simply use ""property pr1""
//for 'cover' as well.

property pr1_for_cover;
    @(posedge clk) cstart ##1 sr1;
endproperty
`endif

reqGnt: assert property (pr1) else $display($stime,,"""",""\t\t%m FAIL"");
creqGnt: cover property (pr1_for_cover) $display($stime,,"""",""\t\t%m PASS"");

initial
begin
    {cstart, req, gnt}=3'b000;
end

initial
begin
    @(negedge clk); {cstart, req, gnt}=3'b100;
    @(negedge clk); {cstart, req, gnt}=3'b110;
    @(negedge clk); {cstart, req, gnt}=3'b000;
    @(negedge clk); {cstart, req, gnt}=3'b001;

    @(negedge clk); {cstart,req,gnt}=3'b110;
    @(negedge clk); {cstart,req,gnt}=3'b110;
    @(negedge clk); {cstart,req,gnt}=3'b111;
    @(negedge clk); {cstart,req,gnt}=3'b010;
end
```

This code snippet is related to properties and assertions in Verilog, which are typically used in formal verification or simulation to validate the behavior of hardware designs.","
//the following property is not needed. You can simply use ""property pr1""
//for 'cover' as well.

property pr1_for_cover;
    @(posedge clk) cstart ##0 sr1;
endproperty

`elsif nonoverlap
property pr1;
    @(posedge clk) cstart |=> sr1;
endproperty

//Note that if a simulator supports filter on vacuous pass for a 'cover'
//the property pr1_for_cover is not needed. You can simply use ""property pr1""
//for 'cover' as well.

property pr1_for_cover;
    @(posedge clk) cstart ##1 sr1;
endproperty
`endif

reqGnt: assert property (pr1) else $display($stime,,"""",""\t\t%m FAIL"");
creqGnt: cover property (pr1_for_cover) $display($stime,,"""",""\t\t%m PASS"");

initial
begin
    {cstart, req, gnt}=3'b000;
end

initial
begin
    @(negedge clk); {cstart, req, gnt}=3'b100;
    @(negedge clk); {cstart, req, gnt}=3'b110;
    @(negedge clk); {cstart, req, gnt}=3'b000;
    @(negedge clk); {cstart, req, gnt}=3'b001;

    @(negedge clk); {cstart,req,gnt}=3'b110;
    @(negedge clk); {cstart,req,gnt}=3'b110;
    @(negedge clk); {cstart,req,gnt}=3'b111;
    @(negedge clk); {cstart,req,gnt}=3'b010;
end
","""Verilog Assertions for Simulating Synchrony and Cover Properties""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p313.jpg,True,"```verilog
task ovl_error;
input [8*63:0] err_msg;
begin
`ifdef ASSERT_MAX_REPORT_ERROR
    if (error_count <= `ASSERT_MAX_REPORT_ERROR)
`endif
    if (severity_level == 0) begin
        error_count = error_count + 1;
        $display (""OVL_FATAL : %s : %s : %s : \ severity %0d : time %0t : %m"",
            assert_name, msg, err_msg,
            severity_level, $time);
        ovl_finish;
    end

    else if (severity_level == 1) begin
        $display(""OVL_ERROR : %s : %s : %s : \ severity %0d : time %0t : %m"",
            assert_name, msg, err_msg,
            severity_level, $time);
        error_count = error_count + 1;
    end

    else if (severity_level == 2) begin
        $display(""OVL_WARNING : %s : %s : %s : \ severity %0d : time %0t : %m"",
            assert_name, msg, err_msg,
            severity_level, $time);
        ovl_warning;
    end

    else begin
        if ((severity_level > 4) ||
            (error_count == 1))
            $display(""OVL_NOTE : %s : %s : %s : \ severity %0d : time %0t : %m"",
                assert_name, msg, err_msg,
                severity_level, $time);
    end
end
endtask

task ovl_finish;
begin
    #100 $finish;
end
endtask
```","
task ovl_error;
input [8*63:0] err_msg;
begin
`ifdef ASSERT_MAX_REPORT_ERROR
    if (error_count <= `ASSERT_MAX_REPORT_ERROR)
`endif
    if (severity_level == 0) begin
        error_count = error_count + 1;
        $display (""OVL_FATAL : %s : %s : %s : \ severity %0d : time %0t : %m"",
            assert_name, msg, err_msg,
            severity_level, $time);
        ovl_finish;
    end

    else if (severity_level == 1) begin
        $display(""OVL_ERROR : %s : %s : %s : \ severity %0d : time %0t : %m"",
            assert_name, msg, err_msg,
            severity_level, $time);
        error_count = error_count + 1;
    end

    else if (severity_level == 2) begin
        $display(""OVL_WARNING : %s : %s : %s : \ severity %0d : time %0t : %m"",
            assert_name, msg, err_msg,
            severity_level, $time);
        ovl_warning;
    end

    else begin
        if ((severity_level > 4) ||
            (error_count == 1))
            $display(""OVL_NOTE : %s : %s : %s : \ severity %0d : time %0t : %m"",
                assert_name, msg, err_msg,
                severity_level, $time);
    end
end
endtask

task ovl_finish;
begin
    #100 $finish;
end
endtask
","Caption: ""Verilog task definitions for error handling in Open Verification Library""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p396.jpg,True,"Here is the Verilog code from the image:

```verilog
//COUNT DATA
`ifdef check3
else
    case (updn_cnt)
        1'b1: data_out <= data_out - 1;
        1'b0: data_out <= data_out + 1;
    endcase
`else
else
    case (updn_cnt)
        1'b1: data_out <= data_out + 1;
        1'b0: data_out <= data_out - 1;
    endcase
`endif

end
end
endmodule
```

The image also contains instructions related to coding assertions for a 'counter' design in Verilog but does not include the actual assertion code.","
//COUNT DATA
`ifdef check3
else
    case (updn_cnt)
        1'b1: data_out <= data_out - 1;
        1'b0: data_out <= data_out + 1;
    endcase
`else
else
    case (updn_cnt)
        1'b1: data_out <= data_out + 1;
        1'b0: data_out <= data_out - 1;
    endcase
`endif

end
end
endmodule
",Verilog Counter Module and Assertions to Code Exercise.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p650.jpg,True,"The image contains a partial listing of a Verilog-XL `vpi_user.c` file, which is a source file for interfacing VPI applications with Verilog-XL. The code provided in the image is:

```c
#include ""vpi_user.h""
#include ""vpi_user_cds.h""

/* prototypes of the PLI application routines */
extern void PLIbook_ShowValue_register();
extern void PLIbook_pow_register();

void (*vlog_startup_routines[])() =
{
    /*** add user entries here ***/
    PLIbook_ShowValue_register,
    PLIbook_pow_register,
    0 /*** final entry must be 0 ***/
};
```

This code is registering two PLI application routines, `PLIbook_ShowValue_register` and `PLIbook_pow_register`, in the `vlog_startup_routines` array for use with the Verilog-XL simulator. The comment `/*** add user entries here ***/` indicates where additional routines can be added, and a `0` is used as the final entry to signify the end of the array.","ude ""vpi_user.h""
#include ""vpi_user_cds.h""

/* prototypes of the PLI application routines */
extern void PLIbook_ShowValue_register();
extern void PLIbook_pow_register();

void (*vlog_startup_routines[])() =
{
    /*** add user entries here ***/
    PLIbook_ShowValue_register,
    PLIbook_pow_register,
    0 /*** final entry must be 0 ***/
};
","Caption: ""Interfacing VPI applications with Verilog-XL - An excerpt from the Verilog PLI Handbook showcasing how to edit the vpi_user.c file for registering PLI application routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p121.jpg,True,"The image contains a snippet of text which discusses Verilog assertions, specifically in the context of SystemVerilog Assertions (SVA). There are two snippets of code in the SystemVerilog Assertion language. Here they are transcribed for you:

1.
```verilog
s_eventually reg -> gnt
```

2.
```verilog
a1: assert property (@(posedge clk) s_eventually ready);
```

The code appears in the context of discussing properties like liveness, fairness, and basic boolean property connectives in formal verification.","
s_eventually reg -> gnt


a1: assert property (@(posedge clk) s_eventually ready);
","Caption: ""Text segment discussing fairness and liveness properties in formal verification, featuring an example Verilog assertion for signal readiness.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p136.jpg,True,"The image includes a snippet of Verilog code, which is as follows:

```verilog
module dff (clk, d, q, qb);
input clk, d;
output q, qb;
ff_prim q1 (q, d, clk,);
not q2 (qb, q);

specify
(d => q) = 2.5;
endspecify
endmodule
```

This Verilog code describes a module named `dff` which appears to be a D flip-flop. It contains inputs `clk` (clock) and `d` (data), outputs `q` and `qb` (where `qb` is typically the complement of `q`), the instantiation of a `ff_prim` primitive with a not-specified instance name (connects `q`, `d`, `clk`), and an inverter defined as `not q2 (qb, q)`. 

The `specify` block describes timing constraints, indicating that the delay from `d` to `q` is specified to be 2.5 units (the time unit is not specified here). The `endspecify` block marks the end of the timing constraints specification.

The rest of the text in the image provides context and some instructions on how to use the VPI (Verilog Procedural Interface) to traverse and manipulate a Verilog design, specifically mentioning the traversal from a module to module paths via `vpi_iterate(vpiModPath, module_handle)` function.","
module dff (clk, d, q, qb);
input clk, d;
output q, qb;
ff_prim q1 (q, d, clk,);
not q2 (qb, q);

specify
(d => q) = 2.5;
endspecify
endmodule
","""Excerpt from The Verilog PLI Handbook featuring a D flip-flop Verilog module with path delay specification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p283.jpg,True,"```verilog
integer error_count;
initial error_count = 0;
always @(posedge clk) begin
`ifdef ASSERT_GLOBAL_RESET
  if (ASSERT_GLOBAL_RESET != 1'b0) begin
  else
    if (reset_n != 1'b0) begin
    `endif
      if (test_expr != 1'b1) begin
        error_count = error_count + 1;
        `ifdef ASSERT_MAX_REPORT_ERROR
          if (error_count <= ASSERT_MAX_REPORT_ERROR)
        `endif
            $display(""%s : severity %0d : time %0t : %m"", 
                     msg, severity_level, $time);
        if (severity_level == 0) $finish;
      end
    end
end
//endalways
`endif
endmodule // assert_always
```","
integer error_count;
initial error_count = 0;
always @(posedge clk) begin
`ifdef ASSERT_GLOBAL_RESET
  if (ASSERT_GLOBAL_RESET != 1'b0) begin
  else
    if (reset_n != 1'b0) begin
    `endif
      if (test_expr != 1'b1) begin
        error_count = error_count + 1;
        `ifdef ASSERT_MAX_REPORT_ERROR
          if (error_count <= ASSERT_MAX_REPORT_ERROR)
        `endif
            $display(""%s : severity %0d : time %0t : %m"", 
                     msg, severity_level, $time);
        if (severity_level == 0) $finish;
      end
    end
end
//endalways
`endif
endmodule // assert_always
","Caption: ""Example of Verilog code for an assertion monitor with assertions and error reporting mechanism.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p139.jpg,True,"The image contains an excerpt from a book discussing the interface construct in SystemVerilog. There is a snippet of code which I will transcribe for you:

```verilog
interface asynch_if();
    logic l;
    wire w;
endinterface

module test(asynch_if ifc);
    logic local_wire;
    assign ifc.w = local_wire;

    initial begin
        ifc.l <= 0;  // Drive asynch logic directly ...
        local_wire <= 1; // but drive wire through assign
        ...
    end
endmodule
```
This code demonstrates the difference between driving interface signals that are declared as `logic` and as `wire` in SystemVerilog.","
interface asynch_if();
    logic l;
    wire w;
endinterface

module test(asynch_if ifc);
    logic local_wire;
    assign ifc.w = local_wire;

    initial begin
        ifc.l <= 0;  // Drive asynch logic directly ...
        local_wire <= 1; // but drive wire through assign
        ...
    end
endmodule
","""Discussion and example of using logic and wire data types in SystemVerilog interfaces.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p135.jpg,True,"The image contains several Verilog SystemVerilog assertion properties. Here is the code extracted from the image:

```verilog
a1: assert property (@(posedge clk) rdy |-> !rst);

a2: assert property (@(posedge clk) rdy -> !rst);

a1: assert property (@(posedge clk) sent |-> nexttime done);

a2: assert property (@(posedge clk) sent |-> ##1 done);

a3: assert property (@(posedge clk) sent ##1 |-> done);

a4_illegal: assert property (
    @(posedge clk) sent nexttime 1 |-> done);

a5: assert property (@(posedge clk) sent |=> done);
```

These properties are used for formal verification in hardware design to assert that certain conditions hold true under specified circumstances in relation to clock events.","
a1: assert property (@(posedge clk) rdy |-> !rst);

a2: assert property (@(posedge clk) rdy -> !rst);

a1: assert property (@(posedge clk) sent |-> nexttime done);

a2: assert property (@(posedge clk) sent |-> ##1 done);

a3: assert property (@(posedge clk) sent ##1 |-> done);

a4_illegal: assert property (
    @(posedge clk) sent nexttime 1 |-> done);

a5: assert property (@(posedge clk) sent |=> done);
","The image shows a textbook page discussing the use of assert statements in Verilog for property verification, including several examples of assertions with explanations and a discussion of legal and illegal usage within the context of sequential properties.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p369.jpg,True,"```verilog
checker checker_args
  (sequence start,
   property end,
   string message = "" "",
   event clk = $inferred_clock,
   rst = $inferred_disable
  );
endchecker

checker myCheck(a, b, c);
  ...
  sequence busSeq ; ...; endsequence
  always @(posedge clk) begin a <= busSeq.triggered; end
endchecker
```","
checker checker_args
  (sequence start,
   property end,
   string message = "" "",
   event clk = $inferred_clock,
   rst = $inferred_disable
  );
endchecker

checker myCheck(a, b, c);
  ...
  sequence busSeq ; ...; endsequence
  always @(posedge clk) begin a <= busSeq.triggered; end
endchecker
","Caption: ""Extract from a textbook discussing Verilog checker block rules and showcasing examples of checker declarations and instantiation in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p232.jpg,True,"The image contains Verilog code related to assertions in a SystemVerilog environment, specifically dealing with SDRAM control logic. Here's the code transcribed:

```verilog
c_tRAS_not : cover property (p_tRAS_not);

SDRAM_chk10: Back to back writes are not allowed.
property p_wr_wr;
    @(posedge clk)
        `s_write |-> not ##1 `s_write;
endproperty

a_wr_wr: assert property (p_wr_wr);
c_wr_wr: cover property (p_wr_wr);

SDRAM_chk11: Check if auto-precharge is disabled during read/write operations.

Most of the SDRAM today can be precharged automatically by setting the addr[10] bit to a high during read/write operations. This assertion is written using implications and logical operation on the command definitions.

property p_disable_autoprecharge;
    @(posedge clk)
        (`s_write || `s_burst_write ||
         `s_read || `s_burst_read) |-> 
            addr[10] == 0;
endproperty

a_disable_autoprecharge:
    assert property(p_disable_autoprecharge);

Figure 5-20 shows the waveform for disabling auto-precharge during read/write commands.
```

This Verilog code snippet is defining properties and assertions for checking certain constraints or behaviors expected of SDRAM, such as prohibiting back-to-back write operations and the condition under which auto-precharge is disabled.","
c_tRAS_not : cover property (p_tRAS_not);

SDRAM_chk10: Back to back writes are not allowed.
property p_wr_wr;
    @(posedge clk)
        `s_write |-> not ##1 `s_write;
endproperty

a_wr_wr: assert property (p_wr_wr);
c_wr_wr: cover property (p_wr_wr);

SDRAM_chk11: Check if auto-precharge is disabled during read/write operations.

Most of the SDRAM today can be precharged automatically by setting the addr[10] bit to a high during read/write operations. This assertion is written using implications and logical operation on the command definitions.

property p_disable_autoprecharge;
    @(posedge clk)
        (`s_write || `s_burst_write ||
         `s_read || `s_burst_read) |-> 
            addr[10] == 0;
endproperty

a_disable_autoprecharge:
    assert property(p_disable_autoprecharge);

Figure 5-20 shows the waveform for disabling auto-precharge during read/write commands.
",This image shows a textbook page or document detailing SystemVerilog properties for SDRAM (Synchronous Dynamic Random-Access Memory) checks. The shown code includes assertions and cover properties that relate to memory write operations and the disabling of auto-precharge during read/write operations.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p83.jpg,True,"```verilog
!(en1 & en2) // enables are mutually exclusive
```","
!(en1 & en2) // enables are mutually exclusive
","""Exploration of Boolean and Temporal Layers in Verilog Property Specification""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p427.jpg,True,"The image contains Verilog code, specifically relating to assertions for a synchronous FIFO (first-in, first-out) memory buffer. The code is using `property`, `assert`, and conditional compilation (`ifdef`, `endif`) constructs to define and check various conditions. Here is the code excerpt from the image:

```verilog
`ifdef check1
property check_reset;
    @(posedge clk)
    (lrst_ |->
     (‘rd_ptr==0 && ‘wr_ptr==0 && fifo_empty==1 && fifo_full==0));
endproperty
check_resetP: assert property (check_reset) else $display($stime, ""\t\t FAIL::check_reset\n"");
`endif

`ifdef check2
property fifoempty;
    @(posedge clk) disable iff (lrst_)
    ( ‘cnt==0 |->
       fifo_empty);
endproperty
fifoemptyP: assert property (fifoempty) else $display($stime, ""\t\t FAIL::fifo_empty condition\n"");
`endif

`ifdef check3
property fifofull;
    @(posedge clk) disable iff (lrst_)
    ( ‘cnt>(fifo_depth-1) |->
       fifo_full);
endproperty
fifofullP: assert property (fifofull) else $display($stime, ""\t\t FAIL::fifo_full condition\n"");
`endif
```

This code defines three properties (`check_reset`, `fifoempty`, and `fifofull`) and corresponding assertions that are intended to check the status of pointers and the empty/full status of the FIFO under certain conditions. Conditional compilation directives like `ifdef` and `endif` are used to potentially include or exclude these checks based on compilation flags.","
`ifdef check1
property check_reset;
    @(posedge clk)
    (lrst_ |->
     (‘rd_ptr==0 && ‘wr_ptr==0 && fifo_empty==1 && fifo_full==0));
endproperty
check_resetP: assert property (check_reset) else $display($stime, ""\t\t FAIL::check_reset\n"");
`endif

`ifdef check2
property fifoempty;
    @(posedge clk) disable iff (lrst_)
    ( ‘cnt==0 |->
       fifo_empty);
endproperty
fifoemptyP: assert property (fifoempty) else $display($stime, ""\t\t FAIL::fifo_empty condition\n"");
`endif

`ifdef check3
property fifofull;
    @(posedge clk) disable iff (lrst_)
    ( ‘cnt>(fifo_depth-1) |->
       fifo_full);
endproperty
fifofullP: assert property (fifofull) else $display($stime, ""\t\t FAIL::fifo_full condition\n"");
`endif
","Verilog code snippet showcasing assertions for synchronous FIFO properties, including reset behavior, FIFO empty and full condition checks.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p109.jpg,True,"The image contains two snippets of code in the context of Verilog, which is used for hardware description and verification. Here are the code snippets as presented in the image:

Snippet 1:
```verilog
c3: cover property (@(posedge clk) write ##1 busy[*] ##1 read);
```

Snippet 2:
```verilog
c4: cover sequence (@(posedge clk) write ##1 busy[*] ##1 read);
```

Additionally, there is a mention of the `cover property` construct in the text with an example:
```verilog
cover property(@(posedge clk) write ##1 read);
```

This code is related to checking coverage in hardware verification using SystemVerilog. It defines properties and sequences that are to be covered during simulation to ensure that certain behaviors of the design have been tested.","
c3: cover property (@(posedge clk) write ##1 busy[*] ##1 read);


c4: cover sequence (@(posedge clk) write ##1 busy[*] ##1 read);


cover property(@(posedge clk) write ##1 read);
","""Example of Verilog code illustrating concurrent coverage, using 'cover property' and 'cover sequence' statements to track functional coverage.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p97.jpg,True,"```verilog
assert always ({req; ack; !halt} |-> {1; grant, grant});
```","
assert always ({req; ack; !halt} |-> {1; grant, grant});
","Caption: ""A segment describing SERE (Sequential Extended Regular Expression) repetition operators and PSL (Property Specification Language) suffix implication in Verilog for specifying RTL (Register-Transfer Level) properties, with an example of PSL assertion.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p433.jpg,True,"The image contains Verilog code related to properties used in the context of a bus protocol within a SystemVerilog Assertion (SVA) framework. Below is the code that is visible in the image:

```verilog
// CHECK # 1. Check that once dValid goes high that it is consecutively 
// asserted (high) for minimum 2 and maximum 4 clocks.
// Check also that once dValid is asserted (high) for 2 to 4 clocks that
// it does de-assert (low) the very next clock.
//--------------------------------------------------
`ifdef check1
property checkValid;
  @(posedge clk) disable iff (reset) $rose(dValid) |-> (dValid [*2:4] ##1 $fell(dValid));
endproperty
assert property (checkValid) else $display($stime,,,""checkValid FAIL"");
`endif

// CHECK # 2. Check that data is not unknown and remains stable after dValid goes
// high and until dAck goes high.
//---------------------------------------------------
`ifdef check2
property checkdataValid;
  @(posedge clk) disable iff (reset)
  $rose(dValid) |-> (!$isunknown(data) && $stable(data) [*1:$] ##0 $rose(dAck));
endproperty
assert property (checkdataValid) else $display($stime,,,""checkdataValid FAIL"");
`endif

// CHECK # 3. Check that 'dack' and 'dValid' relationship is maintained to complete the
// data transfer. In other words,
//
// 'dack' going high signifies that target have accepted data and that master must de-
// assert 'dValid' the clock after 'dack' goes high.
//
// Note that since data must be valid for minimum 2 cycles, that 'dack' cannot go High
// for at least 1 clock after the transfer starts (i.e. after the rising edge of 'dValid') and
// that it must not remain low for more than 3 clocks (because data must transfer in max 4
// clocks).
//---------------------------------------------------
`ifdef check3
property checkdAck;
  @(posedge clk) disable iff (reset)
  $rose(dValid) |-> (dValid && !dAck [*1:3] ##1 $rose(dAck) ##1 $fell(dValid));
endproperty
assert property (checkdAck) else $display($stime,,,""checkdAck FAIL"");
`endif
```

This snippet uses `ifdef` constructs to conditionally include checks based on macro definitions, allowing a user to control which checks are performed based on their compile-time options. Each check is encapsulated inside a property, such as `checkValid`, `checkdataValid`, and `checkdAck`, which are then asserted. If the assertion fails, an error message is displayed. The code demostrates the use of SVA immediate assertions to perform checks on signal behavior within a digital system in the context of a bus protocol.","
// CHECK # 1. Check that once dValid goes high that it is consecutively 
// asserted (high) for minimum 2 and maximum 4 clocks.
// Check also that once dValid is asserted (high) for 2 to 4 clocks that
// it does de-assert (low) the very next clock.
//--------------------------------------------------
`ifdef check1
property checkValid;
  @(posedge clk) disable iff (reset) $rose(dValid) |-> (dValid [*2:4] ##1 $fell(dValid));
endproperty
assert property (checkValid) else $display($stime,,,""checkValid FAIL"");
`endif

// CHECK # 2. Check that data is not unknown and remains stable after dValid goes
// high and until dAck goes high.
//---------------------------------------------------
`ifdef check2
property checkdataValid;
  @(posedge clk) disable iff (reset)
  $rose(dValid) |-> (!$isunknown(data) && $stable(data) [*1:$] ##0 $rose(dAck));
endproperty
assert property (checkdataValid) else $display($stime,,,""checkdataValid FAIL"");
`endif

// CHECK # 3. Check that 'dack' and 'dValid' relationship is maintained to complete the
// data transfer. In other words,
//
// 'dack' going high signifies that target have accepted data and that master must de-
// assert 'dValid' the clock after 'dack' goes high.
//
// Note that since data must be valid for minimum 2 cycles, that 'dack' cannot go High
// for at least 1 clock after the transfer starts (i.e. after the rising edge of 'dValid') and
// that it must not remain low for more than 3 clocks (because data must transfer in max 4
// clocks).
//---------------------------------------------------
`ifdef check3
property checkdAck;
  @(posedge clk) disable iff (reset)
  $rose(dValid) |-> (dValid && !dAck [*1:3] ##1 $rose(dAck) ##1 $fell(dValid));
endproperty
assert property (checkdAck) else $display($stime,,,""checkdAck FAIL"");
`endif
",Verilog Assertions for Data Transfer Protocol Validation.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p105.jpg,True,"The image contains an excerpt from a text discussing constants and strings in SystemVerilog, including a code sample. Here is the code extracted from the image:

```verilog
initial begin
    const byte colon = "":"";
    ...
end
```","
initial begin
    const byte colon = "":"";
    ...
end
",Excerpt from a textbook discussing constants in SystemVerilog and declaring a const variable using Verilog syntax.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p355.jpg,True,"The image contains Verilog code. Here is the code transcribed from the image:

```verilog
module m(input clock);
  logic [15:0] a, b;
  logic c, d;
  typedef bit [15:0] bits;
  ...
  // let ones_match(bits x, y) = x == y;
  // let same(logic x, y) = x === y;

  always_comb
    a1:assert ((bits'(a) == bits'(b)));

  property toggles(bit x, y);
    (logic'(x) !== logic'(y)) |-> !(logic'(x) === logic'(y));
  endproperty

  a2: assert property (@(posedge clock) toggles(c, d));
endmodule : m
```

Below this code block, there's a list that reads:

Finally, here’s where a “let” can be declared:
- A module
- An interface
- A program
- A checker
- A clocking block
- A package
- A compilation-unit scope
- A generate block
- A sequential or parallel block
- A subroutine","
module m(input clock);
  logic [15:0] a, b;
  logic c, d;
  typedef bit [15:0] bits;
  ...
  // let ones_match(bits x, y) = x == y;
  // let same(logic x, y) = x === y;

  always_comb
    a1:assert ((bits'(a) == bits'(b)));

  property toggles(bit x, y);
    (logic'(x) !== logic'(y)) |-> !(logic'(x) === logic'(y));
  endproperty

  a2: assert property (@(posedge clock) toggles(c, d));
endmodule : m
","""Example of Verilog code using 'let' macro definitions and properties for assertions in hardware verification""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p226.jpg,True,"The image contains a snippet of Verilog code related to SDRAM timing verification. Here is the code as it appears in the image:

```verilog
property p_read;
  @(posedge clk)
    (`s_read || `s_burst_read) |-> 
    ##tCAS ($isunknown(data) == 0);
endproperty

a_read: assert property(p_read);
c_read: cover property(p_read);
```","
property p_read;
  @(posedge clk)
    (`s_read || `s_burst_read) |-> 
    ##tCAS ($isunknown(data) == 0);
endproperty

a_read: assert property(p_read);
c_read: cover property(p_read);
","""Verilog code illustrating a property for SDRAM read command verification with CAS latency, including waveforms and an assertion statement.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p109.jpg,True,"The provided image contains Verilog code. Here is the code transcribed from the image:

```verilog
module RAM #(parameter A_WIDTH = 16,
             SIZE      = 1<<A_WIDTH,
             D_WIDTH   = $clog2(SIZE)
            )
           (output logic [D_WIDTH-1:0] data_out,
            input  logic [D_WIDTH-1:0] data_in,
            input  logic [A_WIDTH-1:0] addr,
            input  logic               read, write);
```

Below is a second version of module declaration with a slight modification:

```verilog
module RAM (data_out, data_in, addr, read, write);
parameter A_WIDTH = 16;
localparam SIZE   = 1<<A_WIDTH,
           D_WIDTH = $clog2(SIZE)

output logic [D_WIDTH-1:0] data_out;
input  logic [D_WIDTH-1:0] data_in;
input  logic [A_WIDTH-1:0] addr;
input  logic               read, write;
```

(Note: the `$clog2` function used in the example above was added in the Verilog-2005 standard. Prior to 2005, this function had to be written by the designer, using either a recursive Verilog function or using the Verilog PLI.)","
module RAM #(parameter A_WIDTH = 16,
             SIZE      = 1<<A_WIDTH,
             D_WIDTH   = $clog2(SIZE)
            )
           (output logic [D_WIDTH-1:0] data_out,
            input  logic [D_WIDTH-1:0] data_in,
            input  logic [A_WIDTH-1:0] addr,
            input  logic               read, write);


module RAM (data_out, data_in, addr, read, write);
parameter A_WIDTH = 16;
localparam SIZE   = 1<<A_WIDTH,
           D_WIDTH = $clog2(SIZE)

output logic [D_WIDTH-1:0] data_out;
input  logic [D_WIDTH-1:0] data_in;
input  logic [A_WIDTH-1:0] addr;
input  logic               read, write;
",Verilog code example showing the use of parameters and the preferred modeling style to avoid incorrect parameter sizes.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p29.jpg,True,"```verilog
logic [7:0] foo;
initial foo = bar;  // ERROR: bar not declared

logic [7:0] foo;
assign foo = bar;  // ERROR: bar not declared

logic [7:0] foo;
assign bar = foo;  // GOTCHA: bar not declared, but no error

module adder (input logic a, b, ci,
              output logic sum, co);

...

endmodule

module top;
wire a, b, ci, s1, s2, c1;
adder i1 (.a(a), .b(b), .ci(c1), .sum(s1), .co(c1) ); // GOTCHA!
adder i2 (.a(a), .b(b), .ci(c1), .sum(s2), .co(c0) ); // GOTCHA!
endmodule
```","
logic [7:0] foo;
initial foo = bar;  // ERROR: bar not declared

logic [7:0] foo;
assign foo = bar;  // ERROR: bar not declared

logic [7:0] foo;
assign bar = foo;  // GOTCHA: bar not declared, but no error

module adder (input logic a, b, ci,
              output logic sum, co);

...

endmodule

module top;
wire a, b, ci, s1, s2, c1;
adder i1 (.a(a), .b(b), .ci(c1), .sum(s1), .co(c1) ); // GOTCHA!
adder i2 (.a(a), .b(b), .ci(c1), .sum(s2), .co(c0) ); // GOTCHA!
endmodule
","""Exploring the pitfalls of implicit net declarations in Verilog and SystemVerilog with code examples.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p491.jpg,True,"The image contains the following code snippet:

```c
acc_configure(accDisplayErrors, ""false"");
```","onfigure(accDisplayErrors, ""false"");
","""Exception handling in ACC routines and configuration of error messages in a Verilog simulation environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p486.jpg,True,"The image contains passages of text related to Liveness Properties in the context of formal verification and models. There are two segments of code written in what appears to be SystemVerilog Assertions (SVA), a hardware verification language used alongside Verilog.

Here's the code from the image:

First code snippet:
```verilog
always ev1 |-> c s_until_with ev2.
```

Second code snippet:
```verilog
always req |=> s_eventually gnt.
```

Third code snippet:
```verilog
always req |-> s_eventually gnt
``` 

These snippets demonstrate the use of temporal logic operators in specifying hardware verification properties.","
always ev1 |-> c s_until_with ev2.


always req |=> s_eventually gnt.


always req |-> s_eventually gnt
","Caption: ""An excerpt from a text discussing Liveness Properties in formal verification and models, illustrating examples of Verilog code used for specifying properties in hardware verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p139.jpg,True,"The image contains code snippets written in Verilog. Here are the code extracts from the image:

```verilog
always @ (posedge ck) begin
    $assert_always (a^b);
end

always @(a or b) begin
    $assert_delete ();
    $assert_always_ck (ck, a^b);
end
```

These are examples showing clocked versus non-clocked procedural PLI assertions in Verilog.","
always @ (posedge ck) begin
    $assert_always (a^b);
end

always @(a or b) begin
    $assert_delete ();
    $assert_always_ck (ck, a^b);
end
",Caption: Example of Verilog code illustrating clocked vs non-clocked procedural PLI assertions in a digital design context.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p492.jpg,True,"```verilog
always @(posedge clk) begin : b1
    if (en) begin : b2
        // ...
        if (cond) begin : b3
            // ...
```
","
always @(posedge clk) begin : b1
    if (en) begin : b2
        // ...
        if (cond) begin : b3
            // ...
","Caption: ""Guidance on the use of weak and strong operators in temporal properties and an example of embedded assertions in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p366.jpg,True,"```verilog
1 procedure evaluate(r)
2 begin
3   if r.last_seen == update_count then return
4   case r = w, r = to_return
5     case r = op(r1, r2)
6       evaluate(r1), evaluate(r2)
7       m = max{r1.last_change, r2.last_change}
8       if m > r.last_seen then
9         w = op(r1.weight, r2.weight)
10        if r.weight ≠ w then
11          r.last_change = m
12          r.weight = w
13        r.last_seen = update_count
14 end
```","
1 procedure evaluate(r)
2 begin
3   if r.last_seen == update_count then return
4   case r = w, r = to_return
5     case r = op(r1, r2)
6       evaluate(r1), evaluate(r2)
7       m = max{r1.last_change, r2.last_change}
8       if m > r.last_seen then
9         w = op(r1.weight, r2.weight)
10        if r.weight ≠ w then
11          r.last_change = m
12          r.weight = w
13        r.last_seen = update_count
14 end
","Caption: ""Pseudo-code for an incremental evaluation algorithm for regular expressions, possibly related to a paper by A. Lal and T. Reps.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p135.jpg,True,"The image contains Verilog code snippets used to illustrate a point related to the logical NOT operator (`!`) versus the bitwise invert operator (`~`). Here is the code from the image:

```verilog
logic a;           // 1-bit 4-state variable
logic [1:0] b;     // 2-bit 4-state variable

initial begin
  a = 1;
  b = 1;

  if (!a) ... // evaluates as FALSE
  if (~a) ... // evaluates as FALSE
  if (!b) ... // evaluates as FALSE
  if (~b) ... // evaluates as TRUE -- GOTCHA!
end

// How to avoid this Gotcha
if (!b) ... // OK, logical operator used for true/false test

always #5 clk = ~clk; // OK, invert operator used to invert clock
```

The text explains the difference in using the NOT operator and the bitwise invert operator and gives examples of their correct usage.","
logic a;           // 1-bit 4-state variable
logic [1:0] b;     // 2-bit 4-state variable

initial begin
  a = 1;
  b = 1;

  if (!a) ... // evaluates as FALSE
  if (~a) ... // evaluates as FALSE
  if (!b) ... // evaluates as FALSE
  if (~b) ... // evaluates as TRUE -- GOTCHA!
end

// How to avoid this Gotcha
if (!b) ... // OK, logical operator used for true/false test

always #5 clk = ~clk; // OK, invert operator used to invert clock
","""Understanding the difference between the logical NOT (!) operator and the bitwise invert (~) operator in Verilog coding.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p111.jpg,True,"The image contains an excerpt from a book discussing SystemVerilog repetition operators. While there are no complete Verilog code examples, there is a representation of how to use the repetition operators in SystemVerilog. The relevant expressions are:

```verilog
expr [*2]
```

which specifies that `expr` is to be repeated exactly 2 times, and is the same as saying:
```verilog
expr ##1 expr
```

The document also mentions another repetition operator:
```verilog
[*1:$]
```
which describes a repetition of one to infinity, similar to the PSL 1.0 `inf` keyword.","
expr [*2]


expr ##1 expr


[*1:$]
","""Overview of Repetition Operators in SystemVerilog for defining sequences of Boolean expressions with examples and rules for repeat counts.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p545.jpg,True,"```verilog
module DFA (output Q, input D, Clk);
  voltage Q; D;
  localparam integer Direction = +1; // +1 for posedge.
  integer State;
  analog
  begin
    @(cross(V(Clk) - 0.5, Direction)) State = (V(D) > 0.5);
    V(Q) <+ transition(State? 1: 0);
  end
endmodule
```","
module DFA (output Q, input D, Clk);
  voltage Q; D;
  localparam integer Direction = +1; // +1 for posedge.
  integer State;
  analog
  begin
    @(cross(V(Clk) - 0.5, Direction)) State = (V(D) > 0.5);
    V(Q) <+ transition(State? 1: 0);
  end
endmodule
",Example of Verilog-AMS code for modeling a D flip-flop (DFF).,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p180.jpg,True,"The image contains a snippet of Verilog code. Here it is transcribed:

```verilog
property checkNumRW;
    @(posedge clk)
        $rose(CPU_start) |-> (READ_complete[==3] intersect WRITE_complete[==2]) ##0 $rose(CPU_End);
endproperty
```","
property checkNumRW;
    @(posedge clk)
        $rose(CPU_start) |-> (READ_complete[==3] intersect WRITE_complete[==2]) ##0 $rose(CPU_End);
endproperty
","""Verilog code illustrating a property specification using SVA (SystemVerilog Assertions) and a comparison between 'intersect' and 'and' operators in sequence expressions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p194.jpg,True,"The image contains Verilog code. Here it is:

For Figure 9.4:
```verilog
SPECIFICATION: If Bus Grant Ack (bgack) is asserted there can only be 1 Bus Gnt (busgnt).

always @(posedge clk)
begin
    if (bgack)
    begin
        cones = $countones(busgnt);
        if (cones > 1 || cones == 0);
            $display($stime, ""\t\t FAIL:Number of 1's = %0d"",cones);
        else
            $display($stime, ""\t\t PASS:Number of 1's = %0d"",cones);
    end
end
```

And for Figure 9.5:
```verilog
SPECIFICATION: Check that a bus conforms to Gray Code Transition

property CheckGrayCode (mySig);
    @(posedge clk) ($countones ($past (mySig) ^ mySig) <= 1);
endproperty

CGrayProp: assert CheckGrayCode (PipePointer);
```","
SPECIFICATION: If Bus Grant Ack (bgack) is asserted there can only be 1 Bus Gnt (busgnt).

always @(posedge clk)
begin
    if (bgack)
    begin
        cones = $countones(busgnt);
        if (cones > 1 || cones == 0);
            $display($stime, ""\t\t FAIL:Number of 1's = %0d"",cones);
        else
            $display($stime, ""\t\t PASS:Number of 1's = %0d"",cones);
    end
end


SPECIFICATION: Check that a bus conforms to Gray Code Transition

property CheckGrayCode (mySig);
    @(posedge clk) ($countones ($past (mySig) ^ mySig) <= 1);
endproperty

CGrayProp: assert CheckGrayCode (PipePointer);
","""Verilog code examples implementing `$countones` to count the number of '1's in bus signals and demonstrating assertions for bus grant acknowledgement and Gray Code compliance checking.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p105.jpg,True,"The image contains information about SystemVerilog, specifically about immediate assertions in SystemVerilog. Here is the code extract from the image:

```verilog
immediate_assert_statement ::=assert ( expression ) action_block
action_block ::= statement [ else statement_or_null ]
               | [ statement_or_null ] else statement_or_null
statement_or_null ::=statement | `;`
```

This snippet provides the syntax for writing immediate assertions in SystemVerilog. The ""immediate_assert_statement"" starts with the assert keyword followed by an expression within parentheses and an action block. The action block can include a statement, an optional else clause, and a ""statement_or_null"" which can be either an actual statement or an empty statement represented by a semicolon (;).","
immediate_assert_statement ::=assert ( expression ) action_block
action_block ::= statement [ else statement_or_null ]
               | [ statement_or_null ] else statement_or_null
statement_or_null ::=statement | `;`
","""Excerpt from a technical document discussing SystemVerilog immediate assertions and error severity levels in RTL properties specification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p237.jpg,True,"The image contains Verilog code for two modules, `SchedDelayA` and `SchedDelayB`. Here is the code for both modules:

`SchedDelayA` module:
```verilog
module SchedDelayA;
reg a, b;
initial
begin
    #1 a <= 1'b1;
    #2 a = 1'b0;
    #2 a = 1'b1;
    #1 a = 1'b0;
    #0 b = 1'b0;
    #0 b = 1'b1;
    #0 b <= 1'b1;
    #5 $finish;
end
// always(b) a = b;
// always(a) b <= a;
// 
endmodule // SchedDelayA.
```

`SchedDelayB` module:
```verilog
module SchedDelayB;
reg a, b;
initial
begin
    #0 b = 1'b1;
    #0 b = 1'b0;
    #0 b <= 1'b1;
    #1 a <= 1'b1;
    #2 a = 1'b0;
    #2 a = 1'b1;
    #1 a = 1'b0;
    #5 $finish;
end
// always(a) b <= a;
// always(b) a = b;
// 
endmodule // SchedDelayB.
```

The code consists of initial blocks within each module that define a sequence of events, including delays and assignments to the registers `a` and `b`. Comments within the code indicate additional ""always"" procedural blocks that are currently commented out and not part of the active code.","
module SchedDelayA;
reg a, b;
initial
begin
    #1 a <= 1'b1;
    #2 a = 1'b0;
    #2 a = 1'b1;
    #1 a = 1'b0;
    #0 b = 1'b0;
    #0 b = 1'b1;
    #0 b <= 1'b1;
    #5 $finish;
end
// always(b) a = b;
// always(a) b <= a;
// 
endmodule // SchedDelayA.


module SchedDelayB;
reg a, b;
initial
begin
    #0 b = 1'b1;
    #0 b = 1'b0;
    #0 b <= 1'b1;
    #1 a <= 1'b1;
    #2 a = 1'b0;
    #2 a = 1'b1;
    #1 a = 1'b0;
    #5 $finish;
end
// always(a) b <= a;
// always(b) a = b;
// 
endmodule // SchedDelayB.
","""Verilog scheduling and delay examples with exercise questions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p323.jpg,True,"The provided image contains an excerpt from a document discussing procedural concurrent assertions in Verilog, and it includes a code example. Here is the code from the image:

```verilog
module e1Unit(input logic clk, ...);
  logic i1, i2, d1, dout;
  always @(posedge clk) begin
    d1 <= i1|i2;
    dout <= d1;

    a1: assert property (nexttime[2] dout == $past(i1|i2, 2));
  end
  ...
endmodule
```

A new evaluation attempt of assertion `a1` is started each time a clock tick `posedge clk` occurs, and this clocking event is used to reckon time within `a1`. The assertion `a1` evaluates to make sure that the current value of `i1|i2` becomes the value of `dout`.","
module e1Unit(input logic clk, ...);
  logic i1, i2, d1, dout;
  always @(posedge clk) begin
    d1 <= i1|i2;
    dout <= d1;

    a1: assert property (nexttime[2] dout == $past(i1|i2, 2));
  end
  ...
endmodule
",Concurrent Assertions in Verilog: Using an always Procedure,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p445.jpg,True,"Here is the Verilog code from the image:

```verilog
property p_cover;
    logic [3:0] tag;
    (
        req, tag = req_tag,
        $display(""[t=%t] req asserted, tag %0d"", $time, tag)
    )
    ##[1:$]
    (
        ack && tag == ack_tag,
        display(""[t=%t] ack asserted, ack_tag %0d"", $time, ack_tag)
    );
endproperty
c: cover property (p_cover);

property p;
    logic [3:0] tag;
    (req, tag = req_tag)
    |=>
    s_eventually [0:18] ack && (ack_tag == tag);
endproperty
a: assert property (p);
```

Please note that there is a typo in the second `$display` function; the first dollar sign is missing, hence it should be `$display` instead of `display`.

Furthermore, there might be more code on the page, but that's all that's shown in the snippet.","
property p_cover;
    logic [3:0] tag;
    (
        req, tag = req_tag,
        $display(""[t=%t] req asserted, tag %0d"", $time, tag)
    )
    ##[1:$]
    (
        ack && tag == ack_tag,
        display(""[t=%t] ack asserted, ack_tag %0d"", $time, ack_tag)
    );
endproperty
c: cover property (p_cover);

property p;
    logic [3:0] tag;
    (req, tag = req_tag)
    |=>
    s_eventually [0:18] ack && (ack_tag == tag);
endproperty
a: assert property (p);
","""Verilog Assertions and Cover Properties for Debugging and Validation""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p452.jpg,True,"Here is the code from the image:

```c
PLIbook_SciALUOutput_s_p ALU_outputs;

/* Locate the output storage in the stack for this model instance */
/* If no storage is found, then allocate a storage block and add */
/* the storage to the stack. */
ALU_outputs = ALU_outputs_stack; /* top-of-stack is in global var. */
while (ALU_outputs && (ALU_outputs->instance_p != instance_p))
    ALU_outputs = ALU_outputs->next_ALU_outputs;

/* If no storage area found for this model instance, create one */
if (ALU_outputs == NULL) {
    ALU_outputs = 
        (PLIbook_SciALUOutputps_p)malloc(sizeof(PLIbook_SciALUOutputs_s));
    ALU_outputs->instance_p = instance_p; /* set owner of this space */
    ALU_outputs->next_ALU_outputs = NULL;
    ALU_outputs_stack = ALU_outputs; /* save new top-of-stack */
}

if (enable) { /* ALU is not latched, calculate outputs and store */
    switch (opcode) {
        case 0x0: ALU_outputs->result = sqrt (a, b); break;
        case 0x1: ALU_outputs->result = pow (a); break;
        case 0x2: ALU_outputs->result = exp (a); break;
        case 0x3: ALU_outputs->result = ldexp (a, (intb)); break;
        case 0x4: ALU_outputs->result = fabs (a); break;
        case 0x5: ALU_outputs->result = fmod (a, b); break;
        case 0x6: ALU_outputs->result = ceil (a); break;
        case 0x7: ALU_outputs->result = floor (a); break;
        case 0x8: ALU_outputs->result = log (a); break;
        case 0x9: ALU_outputs->result = log10 (a); break;
        case 0xA: ALU_outputs->result = sin (a); break;
        case 0xB: ALU_outputs->result = cos (a); break;
        case 0xC: ALU_outputs->result = tan (a); break;
        case 0xD: ALU_outputs->result = asin (a); break;
        case 0xE: ALU_outputs->result = acos (a); break;
        case 0xF: ALU_outputs->result = atan (a); break;
    }
    ALU_outputs->err = (errno == EDOM);   /* arg out of range */
    ALU_outputs->excep = (errno == ERANGE); /* result out of range */
    errno = 0;                             /* clear the error flag */
    if (ALU_outputs->err) ALU_outputs->result = 0.0;
}

/* return the values stored in the C model */
*result = ALU_outputs->result;
*err = ALU_outputs->err;
*excep = ALU_outputs->excep;

return;
}
```

Please note that this code seems to be part of a larger file or an example in a textbook discussing interfacing to C models using TF (Task Function) routines, given the chapter title. Additionally, there might be errors in the code logic or syntax, such as the use of `sqrt` with two arguments (`sqrt (a, b)`) which is not standard in C (the `sqrt` function typically takes only one argument). Also, the `instance_p` variable is referenced but not defined within the provided snippet.","ok_SciALUOutput_s_p ALU_outputs;

/* Locate the output storage in the stack for this model instance */
/* If no storage is found, then allocate a storage block and add */
/* the storage to the stack. */
ALU_outputs = ALU_outputs_stack; /* top-of-stack is in global var. */
while (ALU_outputs && (ALU_outputs->instance_p != instance_p))
    ALU_outputs = ALU_outputs->next_ALU_outputs;

/* If no storage area found for this model instance, create one */
if (ALU_outputs == NULL) {
    ALU_outputs = 
        (PLIbook_SciALUOutputps_p)malloc(sizeof(PLIbook_SciALUOutputs_s));
    ALU_outputs->instance_p = instance_p; /* set owner of this space */
    ALU_outputs->next_ALU_outputs = NULL;
    ALU_outputs_stack = ALU_outputs; /* save new top-of-stack */
}

if (enable) { /* ALU is not latched, calculate outputs and store */
    switch (opcode) {
        case 0x0: ALU_outputs->result = sqrt (a, b); break;
        case 0x1: ALU_outputs->result = pow (a); break;
        case 0x2: ALU_outputs->result = exp (a); break;
        case 0x3: ALU_outputs->result = ldexp (a, (intb)); break;
        case 0x4: ALU_outputs->result = fabs (a); break;
        case 0x5: ALU_outputs->result = fmod (a, b); break;
        case 0x6: ALU_outputs->result = ceil (a); break;
        case 0x7: ALU_outputs->result = floor (a); break;
        case 0x8: ALU_outputs->result = log (a); break;
        case 0x9: ALU_outputs->result = log10 (a); break;
        case 0xA: ALU_outputs->result = sin (a); break;
        case 0xB: ALU_outputs->result = cos (a); break;
        case 0xC: ALU_outputs->result = tan (a); break;
        case 0xD: ALU_outputs->result = asin (a); break;
        case 0xE: ALU_outputs->result = acos (a); break;
        case 0xF: ALU_outputs->result = atan (a); break;
    }
    ALU_outputs->err = (errno == EDOM);   /* arg out of range */
    ALU_outputs->excep = (errno == ERANGE); /* result out of range */
    errno = 0;                             /* clear the error flag */
    if (ALU_outputs->err) ALU_outputs->result = 0.0;
}

/* return the values stored in the C model */
*result = ALU_outputs->result;
*err = ALU_outputs->err;
*excep = ALU_outputs->excep;

return;
}
","Caption: ""A snippet of C code demonstrating the interface between a Verilog model and C using TF routines, focusing on arithmetic operations in an ALU.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p449.jpg,True,"The image contains Verilog code within a sample testbench. Here is the code as shown in the image:

```verilog
program automatic test
  #(parameter int NumRx = 4, parameter int NumTx = 4)
  (Utopia.TB_Rx Rx[0:NumRx-1],
   Utopia.TB_Tx Tx[0:NumTx-1],
   cpu_ifc.Test mif,
   input logic rst, clk);

`include ""environment.sv""
Environment env;

class Config_1_cell extends Config;
  constraint one_cells {nCells == 1; }

  function new(input int NumRx,NumTx);
    super.new(NumRx,NumTx);
  endfunction : new
endclass : Config_1_cells

initial begin
  env = new(Rx, Tx, NumRx, NumTx, mif);

  begin // Just simulate for 1 cell
    Config_1_cells c1 = new(NumRx,NumTx);
    env.cfg = c1;
  end

  env.gen_cfg(); // Config will have just 1 cell
  env.build();
  env.run();
  env.wrap_up();
end

endprogram // test
```

This code sample demonstrates how to set up a SystemVerilog testbench program with a configurable number of receiver and transmitter cells, but here it's specifically configured to test with only one cell. The `Config_1_cell` class extends a base `Config` class and includes a constraint to ensure that only one cell is created. The testbench environmental setup and execution calls are also included.","
program automatic test
  #(parameter int NumRx = 4, parameter int NumTx = 4)
  (Utopia.TB_Rx Rx[0:NumRx-1],
   Utopia.TB_Tx Tx[0:NumTx-1],
   cpu_ifc.Test mif,
   input logic rst, clk);

`include ""environment.sv""
Environment env;

class Config_1_cell extends Config;
  constraint one_cells {nCells == 1; }

  function new(input int NumRx,NumTx);
    super.new(NumRx,NumTx);
  endfunction : new
endclass : Config_1_cells

initial begin
  env = new(Rx, Tx, NumRx, NumTx, mif);

  begin // Just simulate for 1 cell
    Config_1_cells c1 = new(NumRx,NumTx);
    env.cfg = c1;
  end

  env.gen_cfg(); // Config will have just 1 cell
  env.build();
  env.run();
  env.wrap_up();
end

endprogram // test
","""Excerpt from a book or document showing a Verilog test program with configuration for testing one cell in a SystemVerilog testbench.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p446.jpg,True,"The image contains Verilog code. Here is the extracted code written out for you:

```c
int PLIbook_ScientificALU_misctf(int user_data, int reason, int paramvc)
{
    #define ALU_CLOCK   1 /* system task arg 1 is ALU clock input */
    #define ALU_A       2 /* system task arg 2 is ALU A input */
    #define ALU_B       3 /* system task arg 3 is ALU B input */
    #define ALU_OP      4 /* system task arg 4 is ALU opcode input */
    #define ALU_RESULT  5 /* system task arg 5 is ALU result output */
    #define ALU_EXCEPT  6 /* system task arg 6 is ALU exception output */
    #define ALU_ERROR   7 /* system task arg 7 is ALU error output */

    double a, b, result;
    int opcode, excep, err, clock;

    /* abort if misctf was not called for a task argument value change */
    if (reason != REASON_PARAMVC)
        return(0);

    /* abort if task argument that changed was not the clock input */
    if (paramvc != ALU_CLOCK)
        return(0);

    /* Read current values of C model inputs from Verilog simulation */
    clock = tf_getp(ALU_CLOCK);
    if (clock != 1) /* abort if not a positive edge of the clock input */
        return(0);
    a = tf_getrealp(ALU_A);
    b = tf_getrealp(ALU_B);
    opcode = tf_getp(ALU_OP);

    /****** Call C model *******/
    PLIbook_ScientificALU_C_model(clock, a, b, opcode, &result, &excep, &err);

    /* Write the C model outputs onto the Verilog signals */
    tf_putrealp(ALU_RESULT, result);
    tf_putp(ALU_EXCEPT, excep);
    tf_putp(ALU_ERROR, err);

    return(0);
}
``` 

Please note that the code snippet uses functions like `tf_getp()`, `tf_getrealp()`, `tf_putrealp()`, and `tf_putp()`, which are task/function calls related to the PLI (Programming Language Interface) that allows interaction between Verilog and C models. The `PLIbook_ScientificALU_C_model` seems to be an external C function that is called from within this Verilog PLI task function.","LIbook_ScientificALU_misctf(int user_data, int reason, int paramvc)
{
    #define ALU_CLOCK   1 /* system task arg 1 is ALU clock input */
    #define ALU_A       2 /* system task arg 2 is ALU A input */
    #define ALU_B       3 /* system task arg 3 is ALU B input */
    #define ALU_OP      4 /* system task arg 4 is ALU opcode input */
    #define ALU_RESULT  5 /* system task arg 5 is ALU result output */
    #define ALU_EXCEPT  6 /* system task arg 6 is ALU exception output */
    #define ALU_ERROR   7 /* system task arg 7 is ALU error output */

    double a, b, result;
    int opcode, excep, err, clock;

    /* abort if misctf was not called for a task argument value change */
    if (reason != REASON_PARAMVC)
        return(0);

    /* abort if task argument that changed was not the clock input */
    if (paramvc != ALU_CLOCK)
        return(0);

    /* Read current values of C model inputs from Verilog simulation */
    clock = tf_getp(ALU_CLOCK);
    if (clock != 1) /* abort if not a positive edge of the clock input */
        return(0);
    a = tf_getrealp(ALU_A);
    b = tf_getrealp(ALU_B);
    opcode = tf_getp(ALU_OP);

    /****** Call C model *******/
    PLIbook_ScientificALU_C_model(clock, a, b, opcode, &result, &excep, &err);

    /* Write the C model outputs onto the Verilog signals */
    tf_putrealp(ALU_RESULT, result);
    tf_putp(ALU_EXCEPT, excep);
    tf_putp(ALU_ERROR, err);

    return(0);
}
","""Example of interfacing Verilog code with C models using TF (task function) routines from a textbook chapter on Interfacing to C Models.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p320.jpg,True,"There is a snippet of code in the image. Here it is:

```c
char *tf_getinstance()
```

The code is the declaration of a function in C language that returns a pointer to a character. The function, `tf_getinstance`, seems to be related to obtaining an instance pointer for a system task or function in the context of Verilog PLI (Programming Language Interface).","*tf_getinstance()
",Extract from a technical document discussing the use of TF routines in Verilog PLI (Programming Language Interface) with a function prototype for tf_getinstance().,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p337.jpg,True,"Here is the Verilog code present in the image:

```verilog
always @(*) begin: B1
    r11 <= v11 | v12;
    a21_1: assert property (@(posedge clk) v11 |=> v12);
    #0;
    r12 <= v12 & v13;
    a21_2: assert property (@(posedge clk) r11 |=> r12);
end

always @ (posedge clk) begin
    i3 <= lb1 && lb8;
    i4 <= lb2 && lb11;
end

always @ (posedge e1) begin
    d1 <= i1 + i2 ;
    a22: assert property (@(posedge clk) d1 |=> (i3 || i4));
    dout <= f_ecap(d1);
end
```

This code snippet includes Verilog blocks, signal assignments, and assertions, demonstrating how assertions can be interleaved with other Verilog statements like assignments and delays.","
always @(*) begin: B1
    r11 <= v11 | v12;
    a21_1: assert property (@(posedge clk) v11 |=> v12);
    #0;
    r12 <= v12 & v13;
    a21_2: assert property (@(posedge clk) r11 |=> r12);
end

always @ (posedge clk) begin
    i3 <= lb1 && lb8;
    i4 <= lb2 && lb11;
end

always @ (posedge e1) begin
    d1 <= i1 + i2 ;
    a22: assert property (@(posedge clk) d1 |=> (i3 || i4));
    dout <= f_ecap(d1);
end
",Verilog code examples demonstrating procedural concurrent assertions with different delay controls.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p308.jpg,True,"The image contains excerpts of C language code snippets that appear to be used in interfacing with the Verilog Programming Language Interface (PLI). Here is the code from the image:

```c
arg_handle = acc_handle_tfarg(2);
if (!(acc_object_in_typelist(arg_handle, valid_types)))
    tf_error(""$pow arg2 must be number, variable or net.\n"");
return(0);
}

/********************************************************************************
* Calltf application
********************************************************************************/
#include <math.h>
int PLIbook_pow_calltf()
{
    int base, exp, result;

    base = tf_getp(1);       /* read base value from tfarg 1 */
    exp  = tf_getp(2);       /* read exponent value from tfarg 2 */
    result = (int)pow((double)base, (double)exp);
    tf_putp(0,result);       /* return result */
    return(0);
}

/********************************************************************************
* Misctf application
********************************************************************************/
int PLIbook_pow_misctf(int user_data, int reason)
{
    if (reason == reason_endofcompile)
        io_printf(""\n$pow PLI application is being used.\n\n"");
    return(0);
}
```

These code snippets are for specific PLI applications, which interact with a Verilog simulator. The first block checks if the second argument to a Verilog task or function is one of the valid types. The second block is the implementation of a `calltf` routine which raises a base to an exponent. The third block is a `misctf` routine that prints a message signaling that the `$pow` PLI application is in use, provided this check is being done at the end of the compilation phase. The code also includes the `<math.h>` library to use the `pow` function.","andle = acc_handle_tfarg(2);
if (!(acc_object_in_typelist(arg_handle, valid_types)))
    tf_error(""$pow arg2 must be number, variable or net.\n"");
return(0);
}

/********************************************************************************
* Calltf application
********************************************************************************/
#include <math.h>
int PLIbook_pow_calltf()
{
    int base, exp, result;

    base = tf_getp(1);       /* read base value from tfarg 1 */
    exp  = tf_getp(2);       /* read exponent value from tfarg 2 */
    result = (int)pow((double)base, (double)exp);
    tf_putp(0,result);       /* return result */
    return(0);
}

/********************************************************************************
* Misctf application
********************************************************************************/
int PLIbook_pow_misctf(int user_data, int reason)
{
    if (reason == reason_endofcompile)
        io_printf(""\n$pow PLI application is being used.\n\n"");
    return(0);
}
",Caption: Excerpt from a handbook demonstrating the use of the Verilog Programming Language Interface (PLI) with examples of calltf and misctf routines.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p475.jpg,True,"The image contains C code. Here it is:

```c
typedef struct {
    unsigned char b, g, r; // x86 little-endian
    //unsigned char r, g, b; // SPARC format
} *p_rgb;

void invert(p_rgb rgb) {
    rgb->r = ~rgb->r;     // Invert the color values
    rgb->g = ~rgb->g;
    rgb->b = ~rgb->b;
    io_printf(""C: Invert rgb=%02x,%02x,%02x\n"",
              rgb->r, rgb->g, rgb->b);
}
```

This code is for sharing a structure that represents a color pixel with red, green, and blue components. The `invert` function inverts the colors of the pixel (for x86 little-endian format). There is also a commented-out line for SPARC format, which is big-endian.","ef struct {
    unsigned char b, g, r; // x86 little-endian
    //unsigned char r, g, b; // SPARC format
} *p_rgb;

void invert(p_rgb rgb) {
    rgb->r = ~rgb->r;     // Invert the color values
    rgb->g = ~rgb->g;
    rgb->b = ~rgb->b;
    io_printf(""C: Invert rgb=%02x,%02x,%02x\n"",
              rgb->r, rgb->g, rgb->b);
}
","Caption: ""C code example demonstrating a structure to share a pixel data format between SystemVerilog and C, including a function to invert the color values.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p479.jpg,True,"The image contains a snippet of SystemVerilog code. Here it is:

```verilog
initial assume property (I and always R);
```","
initial assume property (I and always R);
","The image presents a segment from a textbook discussing properties, assertions, and assumptions in the context of SystemVerilog verification. The Verilog code snippet at the bottom is an example of an `assume` statement: `initial assume property (I and always R);`.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p157.jpg,True,"The image contains two snippets of Verilog code associated with properties in SystemVerilog assertions. Here is the code:

First snippet:
```verilog
property RdAckCheck(int length);
    @(posedge clk) nBurstRead |-> RdAck [=length] ##1 ReadDone;
endproperty

aP: assert property (RdAckCheck(8));
```

Second snippet:
```verilog
property abc;
    @(posedge clk) a |-> b[=0:$] ##1 c;
endproperty
```

The text also explains how the non-consecutive repetition operator works in the context of these properties.","
property RdAckCheck(int length);
    @(posedge clk) nBurstRead |-> RdAck [=length] ##1 ReadDone;
endproperty

aP: assert property (RdAckCheck(8));


property abc;
    @(posedge clk) a |-> b[=0:$] ##1 c;
endproperty
","""Verilog property example demonstrating non-consecutive repetition operator usage in assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p307.jpg,True,"The image contains an example of a basic test program written in a hardware description language. Here is the code from the image:

```verilog
program automatic test;

Environment env;

initial begin
  env = new();
  env.gen_cfg();
  env.build();
  env.run();
  env.wrap_up();
end

endprogram
```","
program automatic test;

Environment env;

initial begin
  env = new();
  env.gen_cfg();
  env.build();
  env.run();
  env.wrap_up();
end

endprogram
","""Example of a basic SystemVerilog test program structure and discussion on threaded testbench design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p477.jpg,True,"The image contains C code within a text about interfacing with C/C++ in the context of SystemVerilog. Here is the code from the image:

```c
char *print(p_rgb rgb) {
    static char s[12];
    sprintf(s, ""%02x,%02x,%02x"", rgb->r, rgb->g, rgb->b);
    return s;
}
```

And here is the second snippet of code presented in the image:

```c
#define PRINT_SIZE 12
#define MAX_CALLS 16
#define HEAP_SIZE PRINT_SIZE * MAX_CALLS

char *print(p_rgb rgb) {
    static char print_heap[HEAP_SIZE + PRINT_SIZE];
    char *s;
    static int heap_idx = 0;
    int nchars;

    s = &print_heap[heap_idx];
    nchars = sprintf(s, ""%02x,%02x,%02x"", 
                         rgb->r, rgb->g, rgb->b);
    heap_idx += nchars + 1;  // Don't forget null!
    if (heap_idx > HEAP_SIZE)
        heap_idx = 0;
    return s;
}
```

The code is demonstrating how to return string data from a C function that might be used in a SystemVerilog context, first using a static local string, and then using a static heap to manage multiple concurrent calls to the function.","*print(p_rgb rgb) {
    static char s[12];
    sprintf(s, ""%02x,%02x,%02x"", rgb->r, rgb->g, rgb->b);
    return s;
}

ne PRINT_SIZE 12
#define MAX_CALLS 16
#define HEAP_SIZE PRINT_SIZE * MAX_CALLS

char *print(p_rgb rgb) {
    static char print_heap[HEAP_SIZE + PRINT_SIZE];
    char *s;
    static int heap_idx = 0;
    int nchars;

    s = &print_heap[heap_idx];
    nchars = sprintf(s, ""%02x,%02x,%02x"", 
                         rgb->r, rgb->g, rgb->b);
    heap_idx += nchars + 1;  // Don't forget null!
    if (heap_idx > HEAP_SIZE)
        heap_idx = 0;
    return s;
}
","""Example of managing string return values in C functions for interoperation with SystemVerilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p141.jpg,True,"Here is the Verilog code extracted from the image:

```verilog
sequence Sc1;
  a ##1 b[*2];
endsequence

property ab;
  @(posedge clk) |=> Sc1;
endproperty

property cons_on_antecedent;
  @(posedge clk) a[*2] |->
  (((##[1:3] c) or (d |=> e)) );
endproperty
```

The code includes definitions of sequences and properties using SystemVerilog assertions (SVA), which are a part of the Verilog hardware description language used for formal verification.","
sequence Sc1;
  a ##1 b[*2];
endsequence

property ab;
  @(posedge clk) |=> Sc1;
endproperty

property cons_on_antecedent;
  @(posedge clk) a[*2] |->
  (((##[1:3] c) or (d |=> e)) );
endproperty
","""Understanding Verilog's consecutive repetition operator with examples and waveform illustrations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p311.jpg,True,"The image contains two snippets of code written in the context of Verilog/SystemVerilog. Below are the transcriptions of both code snippets:

**Snippet 1:**
```verilog
initial begin
    fork
        begin
            sem = new(1);
            sem.get(1);
            #45ns;
            sem.put(2);
        end
        wait10();
    join
end
```

**Snippet 2:**
```verilog
program automatic test;
    mailbox #(int) mbx;
    int value;
    initial begin
        mbx = new(1);
        $display(""mbx.num()=%0d"", mbx.num());
        $display(""mbx.try_get= %0d"", mbx.try_get(value));
        mbx.put(2);
        $display(""mbx.try_put= %0d"", mbx.try_put(value));
        $display(""mbx.num()=%0d"", mbx.num());
        mbx.peek(value);
        $display(""value=%0d"", value);
    end
endprogram
```

These code passages demonstrate how to use semaphores, mailboxes, and some basic concurrency features in SystemVerilog.","
initial begin
    fork
        begin
            sem = new(1);
            sem.get(1);
            #45ns;
            sem.put(2);
        end
        wait10();
    join
end


program automatic test;
    mailbox #(int) mbx;
    int value;
    initial begin
        mbx = new(1);
        $display(""mbx.num()=%0d"", mbx.num());
        $display(""mbx.try_get= %0d"", mbx.try_get(value));
        mbx.put(2);
        $display(""mbx.try_put= %0d"", mbx.try_put(value));
        $display(""mbx.num()=%0d"", mbx.num());
        mbx.peek(value);
        $display(""value=%0d"", value);
    end
endprogram
","The image shows a textbook page with a section on ""Threads and Interprocess Communication,"" specifically dealing with semaphore usage and mailbox handling in Verilog/SystemVerilog code excerpts.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p305.jpg,True,"Here is the Verilog code from the image:

```verilog
class Config;
    rand bit [31:0] run_for_n_trans;
    constraint reasonable
    {
        run_for_n_trans inside {[1:1000]};
    }
endclass

class Environment;

    Generator gen;
    Agent agt;
    Driver drv;
    Monitor mon;
    Checker chk;
    Scoreboard scb;
    Config cfg;
    mailbox # (Transaction) gen2agt, agt2drv, mon2chk;

    extern function new();
    extern function void gen_cfg();
    extern function void build();
    extern task run();
    extern task wrap_up();

endclass

function Environment::new();
    cfg = new();
endfunction

function void Environment::gen_cfg();
    `SV_RAND_CHECK(cfg.randomize);
endfunction
``` 

This code describes two classes in SystemVerilog, a hardware description and verification language. The `Config` class seems to be for configuration of parameters, with constraints on the values. The `Environment` class contains various components like Generator, Agent, etc., and functions to initialize and configure an environment, likely for simulation purposes.","
class Config;
    rand bit [31:0] run_for_n_trans;
    constraint reasonable
    {
        run_for_n_trans inside {[1:1000]};
    }
endclass

class Environment;

    Generator gen;
    Agent agt;
    Driver drv;
    Monitor mon;
    Checker chk;
    Scoreboard scb;
    Config cfg;
    mailbox # (Transaction) gen2agt, agt2drv, mon2chk;

    extern function new();
    extern function void gen_cfg();
    extern function void build();
    extern task run();
    extern task wrap_up();

endclass

function Environment::new();
    cfg = new();
endfunction

function void Environment::gen_cfg();
    `SV_RAND_CHECK(cfg.randomize);
endfunction
","""Example of a Verilog Configuration Class and an Environment Class for System Simulation""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p463.jpg,True,"The image contains a code snippet written in a language that integrates C-like syntax (possibly SystemVerilog DPI-C). Here is the code transcribed from the image:

```c
// 4-state replacement for counter7 from Sample 12-9
void counter7(c7 *inst,
              svLogicVecVal* count,
              const svLogicVecVal* i,
              const svLogic reset,
              const svLogic load) {

    if (reset & 0x2) {  // Check just the bval bit of scalar
        io_printf(""Error: Z or X detected on reset\n\n"");
        return;
    }
    if (load & 0x2) {  // Check just the bval bit of scalar
        io_printf(""Error: Z or X detected on load\n\n"");
        return;
    }
    if (i->bval) {  // Check just the bval bits of 7-bit vector
        io_printf(""Error: Z or X detected on i\n\n"");
        return;
    }

    if (reset)
        inst->cnt = 0;                // Reset
    else if (load)
        inst->cnt = i->aval;          // Load value
    else
        inst->cnt++;                  // Count
    inst->cnt &= 0x7f;                // Mask upper bit

    count->aval = inst->cnt;          // Write to output
    count->bval = 0;
}
```

The code appears to be a routine designed to interface with a 4-state logic hardware counter, where 'Z' and 'X' states are possible besides '0' and '1'. It includes error checking for undefined or high-impedance states on the reset and load signals, as well as on the input vector 'i'.

Please note that this code is probably meant to be used within a simulation environment where VPI routines are available, given the use of `io_printf` and data types such as `svLogicVecVal`.","state replacement for counter7 from Sample 12-9
void counter7(c7 *inst,
              svLogicVecVal* count,
              const svLogicVecVal* i,
              const svLogic reset,
              const svLogic load) {

    if (reset & 0x2) {  // Check just the bval bit of scalar
        io_printf(""Error: Z or X detected on reset\n\n"");
        return;
    }
    if (load & 0x2) {  // Check just the bval bit of scalar
        io_printf(""Error: Z or X detected on load\n\n"");
        return;
    }
    if (i->bval) {  // Check just the bval bits of 7-bit vector
        io_printf(""Error: Z or X detected on i\n\n"");
        return;
    }

    if (reset)
        inst->cnt = 0;                // Reset
    else if (load)
        inst->cnt = i->aval;          // Load value
    else
        inst->cnt++;                  // Count
    inst->cnt &= 0x7f;                // Mask upper bit

    count->aval = inst->cnt;          // Write to output
    count->bval = 0;
}
",A snippet from a book showing a Verilog code example for a counter that checks for 4-state logic values (Z and X) and corresponding text describing how to interface with C/C++ and how to convert from 2-state to 4-state logic types in SystemVerilog and C for simulations.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p478.jpg,True,"There is some Verilog code in the image. Here it is:

```verilog
#10 test = 3'b001;
#10 $show_all_signals(top);
#10 $show_all_signals(l1);
#10 $stop;
#10 $finish;
endmodule
```

This code appears to be part of a simulation script or testbench in Verilog, where certain system tasks such are being used, likely for debugging or signal monitoring purposes.","
#10 test = 3'b001;
#10 $show_all_signals(top);
#10 $show_all_signals(l1);
#10 $stop;
#10 $finish;
endmodule
","A screenshot of a Verilog simulation page showing example Verilog code and output for the `$show_all_signals` system task from ""The Verilog PLI Handbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p447.jpg,True,"The image contains two snippets of Verilog code. Here's the first snippet:

```verilog
endproperty
a: assert property (p);
```

This code snippet shows the assertion of a property `p` using the `assert property` construct in Verilog. The `endproperty` indicates the end of a property definition.

The second snippet is a more detailed property definition using a strong sequence in Verilog:

```verilog
property p;
logic [3:0] tag;
(req, tag = req_tag)
|->
strong (
    (!(ack && (ack_tag == tag)) [*2]
    ##[1:6]
    (ack && (ack_tag == tag))
);
endproperty
a: assert property (p);
```

In this snippet, a property `p` is defined, where a signal `req` and a 4-bit tag `tag` are assigned a value based on `req_tag`. The property then specifies a strong sequence that requires a condition where `ack` is not asserted and the `ack_tag` is not equal to the `tag`, repeated twice (`[*2]`), followed by a timing window of 1 to 6 cycles before the condition where `ack` is asserted and `ack_tag` equals `tag` becomes true. The `endproperty` keyword again signifies the end of the property definition, and the `assert property` statement is used to assert the defined property `p`.","
endproperty
a: assert property (p);


property p;
logic [3:0] tag;
(req, tag = req_tag)
|->
strong (
    (!(ack && (ack_tag == tag)) [*2]
    ##[1:6]
    (ack && (ack_tag == tag))
);
endproperty
a: assert property (p);
","Example of using a strong sequence in a Verilog property for assertions, and a brief mention of debugging assertion failures.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p321.jpg,True,"The image contains Verilog code. Here is the text of the code:

```verilog
begin: GEN_BAD
  default disable iff bad;
  a0: assert property(a |=> b);
  a1: assert property(disable iff (retry) a |=> b);
  a2: assert property(p);
  a3: assert property(a |=> p);
end

endgenerate
module m_nested;
  default disable iff reset && bad;
  a0: assert property(a |=> b);
  a1: assert property(disable iff (retry) a |=> b);
  default disable iff retry;
  a2: assert property(p);
  a3: assert property(a |=> p);
endmodule
```

This code includes assertions within a generate block and a nested module, using SystemVerilog's Immediate Assertions syntax. The `|=>` operator is a non-overlapping implication, while `disable iff` is used to specify conditions under which the assertion should be disabled.","
begin: GEN_BAD
  default disable iff bad;
  a0: assert property(a |=> b);
  a1: assert property(disable iff (retry) a |=> b);
  a2: assert property(p);
  a3: assert property(a |=> p);
end

endgenerate
module m_nested;
  default disable iff reset && bad;
  a0: assert property(a |=> b);
  a1: assert property(disable iff (retry) a |=> b);
  default disable iff retry;
  a2: assert property(p);
  a3: assert property(a |=> p);
endmodule
","""Excerpt from a technical document showing Verilog code with assertions for properties handling resets and bad conditions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p339.jpg,True,"The image contains snippets of code likely from a SystemVerilog (not Verilog) example in a document or book. Here's the code that is visible:

```systemverilog
class Scoreboard;
    Transaction scb[$]; // Store expected tr's in queue

    function void save_expected(input Transaction tr);
        scb.push_back(tr);
    endfunction

    function void compare_actual(input Transaction tr);
        int q[$];

        q = scb.find_index(x) with (x.src == tr.src);
        case (q.size())
            0: $display(""No match found"");
            1: scb.delete(q[0]);
            default:
               $display(""Error, multiple matches found!"");
        endcase
    endfunction : compare_actual
endclass : Scoreboard
```

The code is for a simple scoreboard used in hardware verification, which involves comparing expected and actual transactions to validate the correctness of a design under test.","erilog
class Scoreboard;
    Transaction scb[$]; // Store expected tr's in queue

    function void save_expected(input Transaction tr);
        scb.push_back(tr);
    endfunction

    function void compare_actual(input Transaction tr);
        int q[$];

        q = scb.find_index(x) with (x.src == tr.src);
        case (q.size())
            0: $display(""No match found"");
            1: scb.delete(q[0]);
            default:
               $display(""Error, multiple matches found!"");
        endcase
    endfunction : compare_actual
endclass : Scoreboard
","""Example of a simple Verilog scoreboard for comparing expected and actual transactions in a testbench.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p322.jpg,True,"The image contains text that describes some TF (Task Function) routines in the context of Verilog, but there isn't a full snippet of Verilog code to provide. However, the names of the TF routines mentioned are similar to function prototypes in C or C-like languages. Here are the prototypes mentioned:

```c
void tf_dostop()

void tf_dofinish()

void io_printf(format, arg1,...,arg12)
```

Please note that these routines are specific to a PLI (Programming Language Interface) application interfacing with a Verilog simulation and represent function signatures rather than executable code.","tf_dostop()

void tf_dofinish()

void io_printf(format, arg1,...,arg12)
","Caption: ""Excerpt from a technical document explaining the use of TF routines in controlling simulation and printing messages in Verilog simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p444.jpg,True,"The image contains snippets of Verilog code. Here they are:

First snippet:

```verilog
always @(posedge clock)
  $scientific_alu(clock, a, b, op, result, excep, err);
```

Second snippet:

```verilog
always @(posedge clock or negedge rst)
  $scientific_alu(clock, rst, a, b, op, result, excep, err);
```","
always @(posedge clock)
  $scientific_alu(clock, a, b, op, result, excep, err);


always @(posedge clock or negedge rst)
  $scientific_alu(clock, rst, a, b, op, result, excep, err);
","""Excerpt from educational material explaining how to create a sequential logic interface to a C model using Verilog HDL, with examples of Verilog always blocks for synchronous and asynchronous logic.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p182.jpg,True,"The image you've provided contains Verilog code snippets. Here is the code written on the page:

```verilog
sequence bcORef;
  ((##[2:5] {b && c}) or
   ##[2:5] {e && f})
endsequence

property fms;
  first_match (bcORef) |=> $rose(a);
endproperty

baseP: assert property (@(posedge clk) d |-> fms) else gotoFail;
coverP: cover property (@(posedge clk) d |=> fms) gotoPass;
```

This appears to be an excerpt from a document discussing Verilog properties and how they are applied in a simulation or synthesis context. The sequence and property definitions are related to formal verification or functional coverage in hardware design.","
sequence bcORef;
  ((##[2:5] {b && c}) or
   ##[2:5] {e && f})
endsequence

property fms;
  first_match (bcORef) |=> $rose(a);
endproperty

baseP: assert property (@(posedge clk) d |-> fms) else gotoFail;
coverP: cover property (@(posedge clk) d |=> fms) gotoPass;
",Caption: Example demonstrating the application of the `first_match` operator in Verilog Assertions for sequence and temporal property verification.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p113.jpg,True,"The image contains text related to SystemVerilog syntax and examples of code. Here is the code presented in the image:

Syntax 3-3 SystemVerilog first match operator
```
// See Appendix C for additional details

sequence_expr ::=
    first_match ( sequence_expr )
```

Example 3-45 SystemVerilog first match for req ack sequence
```
sequence seq_1;
    req ##[2:4] ack;
endsequence

sequence seq_2;
    first_match(req ##[2:4] ack) ;
endsequence
```

Syntax 3-4 SystemVerilog throughout operator
```
// See Appendix C for additional details

sequence_expr ::=
    expression_or_dist throughout sequence_expr
```

The code snippets illustrate the use of the first match operator and throughout operator in SystemVerilog. The surrounding text explains the functionality and gives context to the use of these operators in sequence expressions."," Appendix C for additional details

sequence_expr ::=
    first_match ( sequence_expr )

ce seq_1;
    req ##[2:4] ack;
endsequence

sequence seq_2;
    first_match(req ##[2:4] ack) ;
endsequence

 Appendix C for additional details

sequence_expr ::=
    expression_or_dist throughout sequence_expr
","Caption: ""Excerpt from a technical document describing the SystemVerilog first match and throughout operators with syntax and usage examples.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p137.jpg,True,"```verilog
int total;  // 32-bit integer variable

total = fifties.sum
$display(""total is %0d"", total);  // OK
```","
int total;  // 32-bit integer variable

total = fifties.sum
$display(""total is %0d"", total);  // OK
","A section from a book discussing Verilog best practices, highlighting how to properly assign a method return to a larger vector to ensure correct handling of operation context. The Verilog code snippet demonstrates an integer variable receiving a sum and displaying the result.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p221.jpg,True,"The image contains Verilog code. Here is the transcribed code:

```verilog
task ErrHandle(input[3:0] Sts, input[255:0] Msg);
reg[1:0] Action;
begin
  if (Sts==4'h0 || Msg==""b0)
    Action = 2'b00; // == 0.
  else if (Sts==4'hf) Action = 2'b01; // Sts == -1, 2's complement.
  else if (Sts>=4'h8) Action = 2'b10; // Sts < -1, 2's complement.
  else                Action = 2'b11; // Sts >  0.
  //
  case (Action)
    2'b00: Sts = 0; // Do nothing.
    2'b01: begin
      $display(""time=%4d: FATAL ERROR. %s""
      , $time,
        Msg);
      $finish;
    end
    2'b10: begin
      $display(""time=%4d: ERROR Sts=%02d. %s""
      , $time,
        Sts, Msg);
      $display(""\nYou may continue the simulation now."");
      $stop;
    end
    default: $display(""time=%4d: Sts=%02d. NOTE: %s""
      , $time, Sts, Msg);
  endcase
end
endtask
```

Please note that there are some typos in the code as it was transcribed from the image. Specifically, `Msg==""b0` should be corrected to `Msg==""b0""`.","
task ErrHandle(input[3:0] Sts, input[255:0] Msg);
reg[1:0] Action;
begin
  if (Sts==4'h0 || Msg==""b0)
    Action = 2'b00; // == 0.
  else if (Sts==4'hf) Action = 2'b01; // Sts == -1, 2's complement.
  else if (Sts>=4'h8) Action = 2'b10; // Sts < -1, 2's complement.
  else                Action = 2'b11; // Sts >  0.
  //
  case (Action)
    2'b00: Sts = 0; // Do nothing.
    2'b01: begin
      $display(""time=%4d: FATAL ERROR. %s""
      , $time,
        Msg);
      $finish;
    end
    2'b10: begin
      $display(""time=%4d: ERROR Sts=%02d. %s""
      , $time,
        Sts, Msg);
      $display(""\nYou may continue the simulation now."");
      $stop;
    end
    default: $display(""time=%4d: Sts=%02d. NOTE: %s""
      , $time, Sts, Msg);
  endcase
end
endtask
","The image shows a textbook excerpt discussing a Verilog task called `ErrHandle`, which is used for error handling based on the status code passed to it, with different actions for various error conditions.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p235.jpg,True,"There is code present in the image. Here it is:

```verilog
@(MyEventName) do_something;

""if (some expr) -> MyEventName;""

wait (expr) statement;
```

Please note that these snippets may be part of example explanations or conceptual demonstrations rather than fully functional code.","
@(MyEventName) do_something;

""if (some expr) -> MyEventName;""

wait (expr) statement;
","A textbook page explaining Verilog event control with examples of ""@"" event and ""wait"" statement usage.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p123.jpg,True,"The image does contain Verilog code. Here is the code extracted from the image:

```verilog
logic [3:0] u1, u2; // unsigned 4-bit vectors
logic signed [3:0] s1, s2; // signed 4-bit vectors

logic [7:0] u3; // unsigned 8-bit vector
logic signed [7:0] s3; // signed 8-bit vector
logic o; // unsigned 1-bit vector

u3 = u1 + u2; // zero extension (unsigned = unsigned + unsigned)

s3 = s1 + s2; // sign extension (signed = signed + signed)

s3 = s1 + 1; // sign extension (signed = signed + signed)

s3++; // sign extension (expands to s3 = s3 + 1, which is signed = signed + signed)

u3 += 2'b11; // zero extension (expands to u3 = u3 + 2'b11, which is unsigned = unsigned + unsigned)

s3 += 2'sb11; // sign extension (expands to s3 = s3 + 2'sb11, which is signed = signed + signed)

A gotcha can occur when an engineer doesn't understand the operand expansion rules. The next examples show some operation results that might be different from expected. These examples use the same declarations as the examples above.

s3 = u1 + u2; // GOTCHA? zero extension, even though s3 is signed
// Rule: left-hand side does not affect sign
// extension context of operands on right-hand side

s3 = s1 + s2; // GOTCHA? sign extension, even though U3 is unsigned
// Rule: left-hand side does not affect sign
// extension context of operands on right-hand side

s3 = s1 + u2; // GOTCHA? zero extension, even though s1 and s3 are signed
// Rule: unsigned type on right-hand side means the
// entire right-hand side context is unsigned

s3 = s1 + 1'b1; // GOTCHA? zero extension, even though s1 and s3 are signed
// Rule: unsigned type on right-hand side means the
// entire right-hand side context is unsigned

s3 += 2'b11; // GOTCHA? zero extension, even though s3 is signed
// (operation is same as: s3 = s3 + 2'b11)
// Rule: unsigned type on right-hand side means the
// entire right-hand side context is unsigned

u3 += 2'sb11; // GOTCHA? zero extension, even though the 2'sb11 is signed (operation is same as: u3 = u3 + 2'sb11)
// Rule: unsigned type on right-hand side means the
// entire right-hand side context is unsigned
```

The code demonstrates several examples of how Verilog handles sign extension and zero extension in different contexts, which could lead to potential mistakes if not properly understood (referred to as ""gotchas"" in the text).","
logic [3:0] u1, u2; // unsigned 4-bit vectors
logic signed [3:0] s1, s2; // signed 4-bit vectors

logic [7:0] u3; // unsigned 8-bit vector
logic signed [7:0] s3; // signed 8-bit vector
logic o; // unsigned 1-bit vector

u3 = u1 + u2; // zero extension (unsigned = unsigned + unsigned)

s3 = s1 + s2; // sign extension (signed = signed + signed)

s3 = s1 + 1; // sign extension (signed = signed + signed)

s3++; // sign extension (expands to s3 = s3 + 1, which is signed = signed + signed)

u3 += 2'b11; // zero extension (expands to u3 = u3 + 2'b11, which is unsigned = unsigned + unsigned)

s3 += 2'sb11; // sign extension (expands to s3 = s3 + 2'sb11, which is signed = signed + signed)

A gotcha can occur when an engineer doesn't understand the operand expansion rules. The next examples show some operation results that might be different from expected. These examples use the same declarations as the examples above.

s3 = u1 + u2; // GOTCHA? zero extension, even though s3 is signed
// Rule: left-hand side does not affect sign
// extension context of operands on right-hand side

s3 = s1 + s2; // GOTCHA? sign extension, even though U3 is unsigned
// Rule: left-hand side does not affect sign
// extension context of operands on right-hand side

s3 = s1 + u2; // GOTCHA? zero extension, even though s1 and s3 are signed
// Rule: unsigned type on right-hand side means the
// entire right-hand side context is unsigned

s3 = s1 + 1'b1; // GOTCHA? zero extension, even though s1 and s3 are signed
// Rule: unsigned type on right-hand side means the
// entire right-hand side context is unsigned

s3 += 2'b11; // GOTCHA? zero extension, even though s3 is signed
// (operation is same as: s3 = s3 + 2'b11)
// Rule: unsigned type on right-hand side means the
// entire right-hand side context is unsigned

u3 += 2'sb11; // GOTCHA? zero extension, even though the 2'sb11 is signed (operation is same as: u3 = u3 + 2'sb11)
// Rule: unsigned type on right-hand side means the
// entire right-hand side context is unsigned
","""Verilog Gotchas: Understanding Operand Expansion and Sign Extension in Verilog Code""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p107.jpg,True,"The image contains two examples of SystemVerilog property declaration code. Here are the transcriptions of the code:

Example 3-36 SystemVerilog property declaration example

```verilog
property mutex (clk, reset_n, a, b);
    @(posedge clk) disable iff (reset_n) (! (a & b) );
endproperty
```

Example 3-37 SystemVerilog property declaration example with not

```verilog
property mutex_with_not (clk, reset_n, a, b);
    @(posedge clk) disable iff (reset_n) not (a & b);
endproperty
```","
property mutex (clk, reset_n, a, b);
    @(posedge clk) disable iff (reset_n) (! (a & b) );
endproperty


property mutex_with_not (clk, reset_n, a, b);
    @(posedge clk) disable iff (reset_n) not (a & b);
endproperty
","""Examples of SystemVerilog property declarations for mutual exclusion with asynchronous reset conditions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p196.jpg,True,"The image contains Verilog code related to properties for assertions. Here are the code snippets found in the image:

```verilog
property checkFloat;
    @(posedge clk) BusUndriven |-> ($countbits (bus, '1bz) == 0);
endproperty
```

```verilog
property checkUnknown;
    @(posedge clk) memread |-> ($countbits (data, '1bx, '1bz) == 0);
endproperty
```

These properties appear to be used for checking if a bus is undriven (i.e., in a high impedance '1bz state) or if the bits in a given vector contain unknown ('1bx) or high impedance states. The `$countbits` system function is used to count how many bits are in a certain state.","
property checkFloat;
    @(posedge clk) BusUndriven |-> ($countbits (bus, '1bz) == 0);
endproperty


property checkUnknown;
    @(posedge clk) memread |-> ($countbits (data, '1bx, '1bz) == 0);
endproperty
",Verilog Assertions: Using $countbits to Check for Floating States and Unknown Values in Buses,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p484.jpg,True,"The image contains Verilog code, which I will transcribe below:

First snippet:
```verilog
logic s1 = 1’b1, s2 = 1’b0, s3 = 1’b0;
always @(global_clock begin
  s1 <= s1;
  s2 <= s1 && a;
  s3 <= s2 && !b;
end
```

Second snippet:
```verilog
logic s2 = 1’b0, s3 = 1’b0;
always @(global_clock begin
  s2 <= a;
  s3 <= s2 && !b;
end
```

Please note that there is a syntax error in the Verilog code provided in the image. The `always` block in both snippets should have a closing parenthesis for the `@` sensitivity list:
```verilog
always @(global_clock) begin
  // rest of the code
```
Also, `end` at the end of each `always` block should be `end` to indicate the end of the block.","
logic s1 = 1’b1, s2 = 1’b0, s3 = 1’b0;
always @(global_clock begin
  s1 <= s1;
  s2 <= s1 && a;
  s3 <= s2 && !b;
end


logic s2 = 1’b0, s3 = 1’b0;
always @(global_clock begin
  s2 <= a;
  s3 <= s2 && !b;
end


always @(global_clock) begin
  // rest of the code
","""Verilog code for a state machine that complements a property, along with optimization suggestions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p488.jpg,True,"The image contains Verilog code. Here's the transcription:

```verilog
module block;
  import ""DPI-C"" context function void c_display();
  import ""DPI-C"" context function void save_my_scope();
  export ""DPI-C"" function sv_display;

  function void sv_display();
    $display(""SV: In %m"");
  endfunction : sv_display

  initial begin
    save_my_scope();
    c_display();
  end
endmodule : block

module top;
  import ""DPI-C"" context function void c_display();
  export ""DPI-C"" function sv_display;

  function void sv_display();
    $display(""SV: In %m"");
  endfunction : sv_display

  block b1();

  initial #1 c_display();
endmodule : top
```

Below the code, there's some text explaining output and context scope in SystemVerilog:

```
This produces the output shown in Sample 12.50.

Sample 12.50 Output from svSetScope code

C: c_display called from top.b1
C: Calling top.b1.sv_display
SV: In top.b1.sv_display

C: c_display called from top
C: Calling top.b1.sv_display
SV: In top.b1.sv_display

You could use this concept of scope to allow a C model to know where it was instantiated from, and differentiate each instance. For example, a memory model may be instantiated several times, and needs to allocate unique storage for every instance.
```","
module block;
  import ""DPI-C"" context function void c_display();
  import ""DPI-C"" context function void save_my_scope();
  export ""DPI-C"" function sv_display;

  function void sv_display();
    $display(""SV: In %m"");
  endfunction : sv_display

  initial begin
    save_my_scope();
    c_display();
  end
endmodule : block

module top;
  import ""DPI-C"" context function void c_display();
  export ""DPI-C"" function sv_display;

  function void sv_display();
    $display(""SV: In %m"");
  endfunction : sv_display

  block b1();

  initial #1 c_display();
endmodule : top

roduces the output shown in Sample 12.50.

Sample 12.50 Output from svSetScope code

C: c_display called from top.b1
C: Calling top.b1.sv_display
SV: In top.b1.sv_display

C: c_display called from top
C: Calling top.b1.sv_display
SV: In top.b1.sv_display

You could use this concept of scope to allow a C model to know where it was instantiated from, and differentiate each instance. For example, a memory model may be instantiated several times, and needs to allocate unique storage for every instance.
","Verilog code example demonstrating the use of DPI-C for communication between C and SystemVerilog, including context function usage and the resultant output.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p487.jpg,True,"The image contains the following code:

```c
my_calltf_app()
{
    /* declarations */
    acc_initialize();
    
    /* use routines from ACC library */
    acc_close();
}
```","lltf_app()
{
    /* declarations */
    acc_initialize();
    
    /* use routines from ACC library */
    acc_close();
}
","""Text excerpt describing the initialization and closing of the ACC environment in Verilog, with example usage of acc_initialize() and acc_close() functions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p108.jpg,True,"```c
PLIbook_PrintSignalValues(signal_iterator);
}

/* obtain handles to regs in scope and read current value */
signal_iterator = vpi_iterate(vpiReg, scope_handle);
if (signal_iterator != NULL)
    PLIbook_PrintSignalValues(signal_iterator);

/* obtain handles to variables in scope and read current value */
signal_iterator = vpi_iterate(vpiVariables, scope_handle);
if (signal_iterator != NULL)
    PLIbook_PrintSignalValues(signal_iterator);

vpi_printf(""\n""); /* add some white space to output */
return(0);
}

void PLIbook_PrintSignalValues(vpiHandle signal_iterator)
{
    vpiHandle signal_handle;
    int       signal_type;
    s_vpi_value current_value;

    while ( (signal_handle = vpi_scan(signal_iterator)) != NULL ) {
        signal_type = vpi_get(vpiType, signal_handle);
        switch (signal_type) {
            case vpiNet:
                current_value.format = vpiBinStrVal;
                vpi_get_value(signal_handle, &current_value);
                vpi_printf("" net %-*s value is %s (binary)\n"",
                           vpi_get_str(vpiName, signal_handle),
                           current_value.value.str);
                break;
                
            case vpiReg:
                current_value.format = vpiBinStrVal;
                vpi_get_value(signal_handle, &current_value);
                vpi_printf("" reg %-*s value is %s (binary)\n"",
                           vpi_get_str(vpiName, signal_handle),
                           current_value.value.str);
                break;

            case vpiIntegerVar:
                current_value.format = vpiIntVal;
                vpi_get_value(signal_handle, &current_value);
                vpi_printf("" integer %-*s value is %d (decimal)\n"",
                           vpi_get_str(vpiName, signal_handle),
                           current_value.value.integer);
                break;

            case vpiRealVar:
                current_value.format = vpiRealVal;
```
This image contains a snippet of code related to the Verilog Programming Language Interface (PLI). The code seems to be part of a function that prints out signal values for different types of Verilog variables (nets, registers, integer variables, and real variables).","ok_PrintSignalValues(signal_iterator);
}

/* obtain handles to regs in scope and read current value */
signal_iterator = vpi_iterate(vpiReg, scope_handle);
if (signal_iterator != NULL)
    PLIbook_PrintSignalValues(signal_iterator);

/* obtain handles to variables in scope and read current value */
signal_iterator = vpi_iterate(vpiVariables, scope_handle);
if (signal_iterator != NULL)
    PLIbook_PrintSignalValues(signal_iterator);

vpi_printf(""\n""); /* add some white space to output */
return(0);
}

void PLIbook_PrintSignalValues(vpiHandle signal_iterator)
{
    vpiHandle signal_handle;
    int       signal_type;
    s_vpi_value current_value;

    while ( (signal_handle = vpi_scan(signal_iterator)) != NULL ) {
        signal_type = vpi_get(vpiType, signal_handle);
        switch (signal_type) {
            case vpiNet:
                current_value.format = vpiBinStrVal;
                vpi_get_value(signal_handle, &current_value);
                vpi_printf("" net %-*s value is %s (binary)\n"",
                           vpi_get_str(vpiName, signal_handle),
                           current_value.value.str);
                break;
                
            case vpiReg:
                current_value.format = vpiBinStrVal;
                vpi_get_value(signal_handle, &current_value);
                vpi_printf("" reg %-*s value is %s (binary)\n"",
                           vpi_get_str(vpiName, signal_handle),
                           current_value.value.str);
                break;

            case vpiIntegerVar:
                current_value.format = vpiIntVal;
                vpi_get_value(signal_handle, &current_value);
                vpi_printf("" integer %-*s value is %d (decimal)\n"",
                           vpi_get_str(vpiName, signal_handle),
                           current_value.value.integer);
                break;

            case vpiRealVar:
                current_value.format = vpiRealVal;
","Caption: ""Sample Verilog PLI (Programming Language Interface) code demonstrating signal value extraction and printing.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p113.jpg,True,"The image contains two samples of Verilog code. Here they are:

Sample 3.1:
```verilog
initial
begin : example
  integer array[10], sum, j;
  
  // Declare i in for statement
  for (int i=0; i<10; i++)     // Increment i
    array[i] = i;
  
  // Add up values in the array
  sum = array[9];
  j=8;
  do
    sum += array[j];           // do...while loop
  while (j--);                 // Test if j=0
  $display(""Sum=%4d"", sum);    // %4d - specify width
end : example
```

Sample 3.2:
```verilog
initial begin
  bit [127:0] cmd;
  int file, c;
  
  file = $fopen(""commands.txt"", ""r"");
  while (!$feof(file)) begin
    c = $fscanf(file, ""%s"", cmd);
    case (cmd)
      """": continue;            // Blank line - skip to loop end
      ""done"": break;           // Done - leave loop
      ...                      // Process other commands here
    endcase // case(cmd)
  end
  
  $fclose(file);
end
```

The code examples demonstrate usage of procedural statements and control structures in Verilog, including loops and file I/O.","
initial
begin : example
  integer array[10], sum, j;
  
  // Declare i in for statement
  for (int i=0; i<10; i++)     // Increment i
    array[i] = i;
  
  // Add up values in the array
  sum = array[9];
  j=8;
  do
    sum += array[j];           // do...while loop
  while (j--);                 // Test if j=0
  $display(""Sum=%4d"", sum);    // %4d - specify width
end : example


initial begin
  bit [127:0] cmd;
  int file, c;
  
  file = $fopen(""commands.txt"", ""r"");
  while (!$feof(file)) begin
    c = $fscanf(file, ""%s"", cmd);
    case (cmd)
      """": continue;            // Blank line - skip to loop end
      ""done"": break;           // Done - leave loop
      ...                      // Process other commands here
    endcase // case(cmd)
  end
  
  $fclose(file);
end
","""Verilog code examples demonstrating procedural statements, loop control with break and continue, and file I/O operations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p425.jpg,True,"```verilog
sequence sr1;
  req ##2 gnt;
endsequence

property pr1;
  @(posedge clk) cstart |=> sr1;
endproperty

property pr1_for_cover;
  @(posedge clk) cstart ##1 sr1;
endproperty
```","
sequence sr1;
  req ##2 gnt;
endsequence

property pr1;
  @(posedge clk) cstart |=> sr1;
endproperty

property pr1_for_cover;
  @(posedge clk) cstart ##1 sr1;
endproperty
","""Explanation and example of Verilog non-overlap operator in properties, along with Q&A on behavior.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p230.jpg,True,"The image contains Verilog code snippets, which are assertions and properties for SDRAM operation checks. Here is the code present in the image:

```verilog
property p_rd_wr;
    @(posedge clk)
        s_read |-> not ##[0:tCAS] s_write;
endproperty

a_rd_wr: assert property (p_rd_wr);
c_rd_wr: cover property (p_rd_wr);

property p_tRP_not;
    @(posedge clk)
        s_precharge |-> not ##[0:(tRP - 1)] s_active;
endproperty

property p_tRP;
    @(posedge clk)
        s_precharge |-> ##[tRP:12000] s_active;
endproperty

a_tRP_not: assert property (p_tRP_not);
a_tRP: assert property (p_tRP);

c_tRP_not: assert property (p_tRP_not);
```

These code snippets use SystemVerilog assertions to enforce timing relationships between different signals in an SDRAM module. For example, `p_rd_wr` is a property that ensures a write command (`s_write`) cannot be issued within the CAS latency (`tCAS`) after a read command (`s_read`).

Please note that the `##[start:end]` syntax refers to a range of cycles in which the subsequent events must occur (or not occur) for the assertion to pass. The expressions `a_*` are used to assert the properties, while `c_*` are used for coverage purposes.","
property p_rd_wr;
    @(posedge clk)
        s_read |-> not ##[0:tCAS] s_write;
endproperty

a_rd_wr: assert property (p_rd_wr);
c_rd_wr: cover property (p_rd_wr);

property p_tRP_not;
    @(posedge clk)
        s_precharge |-> not ##[0:(tRP - 1)] s_active;
endproperty

property p_tRP;
    @(posedge clk)
        s_precharge |-> ##[tRP:12000] s_active;
endproperty

a_tRP_not: assert property (p_tRP_not);
a_tRP: assert property (p_tRP);

c_tRP_not: assert property (p_tRP_not);
","""Verilog Assertions for SDRAM Timing Constraints""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p224.jpg,True,"```verilog
property p_tMRD;
  @(posedge clk)
    `s_loadmoderegister |-> ##[tMRD] `s_active;
endproperty
```","
property p_tMRD;
  @(posedge clk)
    `s_loadmoderegister |-> ##[tMRD] `s_active;
endproperty
",A textbook page discussing SDRAM timing parameters and Verilog code for a property checking the timing between load mode register to active command.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p357.jpg,True,"The image contains the following Verilog code:

```verilog
checker checker_identifier [(checker_port_list)];
  checker_or_generate_item
endchecker [: checker_identifier]
```

And also a module declaration:

```verilog
module checkerModule #(burstSize = 4) ( dack_, oe_, bMode, bMode_in, clk, rst);
input dack_, oe_, bMode , bMode_in, clk, rst;
```","
checker checker_identifier [(checker_port_list)];
  checker_or_generate_item
endchecker [: checker_identifier]


module checkerModule #(burstSize = 4) ( dack_, oe_, bMode, bMode_in, clk, rst);
input dack_, oe_, bMode , bMode_in, clk, rst;
","Caption: ""Understanding Verilog Checkers - An Introduction and Syntax Example with 'checkerModule' Code Snippet""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p107.jpg,True,"The image contains verbatim code in Verilog along with some explanations. Here's the code from the image:

```verilog
bit [7:0] b8;
bit one = 1'b1;              // Single bit
$displayb(one + one);        // A: 1+1 = 0

b8 = one + one;              // B: 1+1 = 2
$displayb(b8);

$displayb(one + one + 2'b0); // C: 1+1 = 2 with constant

$displayb(2'(one) + one);    // D: 1+1 = 2 with cast
```

These code snippets illustrate different ways to handle expression width and the resulting values in SystemVerilog, emphasizing context-dependent behavior.","
bit [7:0] b8;
bit one = 1'b1;              // Single bit
$displayb(one + one);        // A: 1+1 = 0

b8 = one + one;              // B: 1+1 = 2
$displayb(b8);

$displayb(one + one + 2'b0); // C: 1+1 = 2 with constant

$displayb(2'(one) + one);    // D: 1+1 = 2 with cast
","""Exploring Verilog Code Examples and Context-Dependent Expression Width in Digital Design""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p95.jpg,True,"The image contains two snippets of code related to PSL (Property Specification Language) and Verilog. Here they are:

Example 3-15
```verilog
default clock = (posedge clk);
assert always (req -> next ack) abort !reset_n;
```

Example 3-16
```verilog
assert always (req -> next (ack -> next (!halt -> (grant & next grant))));
```","
default clock = (posedge clk);
assert always (req -> next ack) abort !reset_n;


assert always (req -> next (ack -> next (!halt -> (grant & next grant))));
","""Example of PSL default clock and sequence specification using the 'next' operator in Verilog.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p431.jpg,True,"The image contains Verilog code. Here is the code as displayed in the image:

```verilog
//-------------------------------
// CHECK # 3. Check that if ld_cnt is deasserted (==1) and count_enb is
// enabled (==1) that if updn_cnt==1 the count goes UP and if updn_cnt==0 the
// count goes DOWN.
//-------------------------------

`ifdef check3
property counter_count;
@(posedge clk) disable iff (|rst) (|d_cnt_t & count_enb) |-> 
  (if (updn_cnt) ##1 (data_out+8'h01) == $past(data_out)
   else           ##1 (data_out-8'h01) == $past(data_out));
endproperty

counter_count_check: assert property(counter_count)
else $display($stime,, ""\t\tCOUNTER COUNT CHECK FAIL:: UPDOWN COUNT using
$past\n"");
`endif

//-------------------------------
// Alternate way of writing assertion for CHECK # 3
// Check for count using local variable
//-------------------------------

/*
`ifdef check3
property counter_count_local;
logic[7:0] local_data;
@(posedge clk) disable iff (|rst) (|d_cnt_t & count_enb, local_data = data_out) |-> 
  (if (updn_cnt) ##1 (local_data == (local_data+8'h01))
   else          ##1 (local_data == (local_data-8'h01)));
endproperty

counter_count_check: assert property(counter_count)
else $display($stime,, ""\t\tCOUNTER COUNT CHECK FAIL:: UPDOWN COUNT using
$past\n"");
`endif
*/
```

The code is split into two main parts within the image, each with a different way of writing a check for the same condition. The first part is uncommented and would be active in a simulation or synthesis, while the second part is commented out and would not be active.","
//-------------------------------
// CHECK # 3. Check that if ld_cnt is deasserted (==1) and count_enb is
// enabled (==1) that if updn_cnt==1 the count goes UP and if updn_cnt==0 the
// count goes DOWN.
//-------------------------------

`ifdef check3
property counter_count;
@(posedge clk) disable iff (|rst) (|d_cnt_t & count_enb) |-> 
  (if (updn_cnt) ##1 (data_out+8'h01) == $past(data_out)
   else           ##1 (data_out-8'h01) == $past(data_out));
endproperty

counter_count_check: assert property(counter_count)
else $display($stime,, ""\t\tCOUNTER COUNT CHECK FAIL:: UPDOWN COUNT using
$past\n"");
`endif

//-------------------------------
// Alternate way of writing assertion for CHECK # 3
// Check for count using local variable
//-------------------------------

/*
`ifdef check3
property counter_count_local;
logic[7:0] local_data;
@(posedge clk) disable iff (|rst) (|d_cnt_t & count_enb, local_data = data_out) |-> 
  (if (updn_cnt) ##1 (local_data == (local_data+8'h01))
   else          ##1 (local_data == (local_data-8'h01)));
endproperty

counter_count_check: assert property(counter_count)
else $display($stime,, ""\t\tCOUNTER COUNT CHECK FAIL:: UPDOWN COUNT using
$past\n"");
`endif
*/
",Verilog code example of property assertions for checking counter behavior based on enable and up/down control signals.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p419.jpg,True,"The image contains code related to Verilog and assertions in a form of a property and its use within verification. Here is the Verilog code from the image:

First code snippet:

```verilog
property pr1;
  @(posedge clk) req ##2 gnt;
endproperty
reaGnt: assert property (pr1) $display($stime,,,""\t %m PASS"");
  else $display($stime,,,""\t %m FAIL"");
```

Second code snippet:

```verilog
`define no_implication

/* Rest of the code is not visible and is therefore not transcribed */
```

The text also includes a Q&A session with output logs discussing the behavior of the code snippet related to the implications in assertions.","
property pr1;
  @(posedge clk) req ##2 gnt;
endproperty
reaGnt: assert property (pr1) $display($stime,,,""\t %m PASS"");
  else $display($stime,,,""\t %m FAIL"");


`define no_implication

/* Rest of the code is not visible and is therefore not transcribed */
","""Example and explanation of a Verilog property without an implication operator and its test simulation output.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p134.jpg,True,"The image contains code written in C that appears to be using Verilog PLI (Programming Language Interface). Here is the code from the image:

```c
#else /* if error, generate brief error message */
if (systf_h == NULL) {
    vpi_printf(""ERROR: PLIbook_getarg_handle_vpi() could not obtain handle to systf call\n"");
    return(NULL);
}
#endif

arg_itr = vpi_iterate(vpiArgument, systf_h);
#ifdef PLIbookDebug /* if error, generate verbose debug message */
if (vpi_chk_error(&err)) {
    vpi_printf(""ERROR: PLIbook_getarg_handle_vpi() could not obtain iterator to systf args\n"");
    vpi_printf(""File %s, Line %d: %s\n"",
               err.file, err.line, err.message);
}
#else /* if error, generate brief error message */
if (systf_h == NULL) {
    vpi_printf(""ERROR: PLIbook_getarg_handle_vpi() could not obtain iterator to systf args\n"");
    return(NULL);
}
#endif

for (i=1; i<=argNum; i++) {
    arg_h = vpi_scan(arg_itr);
#ifdef PLIbookDebug /* if error, generate verbose debug message */
    if (vpi_chk_error(&err)) {
        vpi_printf(""ERROR: PLIbook_getarg_handle_vpi() could not obtain handle to systf arg %d\n"", i);
        vpi_printf(""File %s, Line %d: %s\n"",
                   err.file, err.line, err.message);
    }
#endif
    if (arg_h == NULL) {
        vpi_printf(""ERROR: PLIbook_getarg_handle_vpi() systf arg %d out-of-range\n"",
                   argNum);
        return(NULL);
    }
}
vpi_free_object(arg_itr); /* free iterator -- didn't scan all args */

return(arg_h);
```

This code is making use of the VPI library functions to interact with Verilog data structures from C code. The `#ifdef` and `#endif` statements in the code suggest that portions of the code will be compiled conditionally, depending on whether `PLIbookDebug` is defined. If `PLIbookDebug` is defined, the code will print more detailed error messages using the error information provided by the VPI function `vpi_chk_error()`."," /* if error, generate brief error message */
if (systf_h == NULL) {
    vpi_printf(""ERROR: PLIbook_getarg_handle_vpi() could not obtain handle to systf call\n"");
    return(NULL);
}
#endif

arg_itr = vpi_iterate(vpiArgument, systf_h);
#ifdef PLIbookDebug /* if error, generate verbose debug message */
if (vpi_chk_error(&err)) {
    vpi_printf(""ERROR: PLIbook_getarg_handle_vpi() could not obtain iterator to systf args\n"");
    vpi_printf(""File %s, Line %d: %s\n"",
               err.file, err.line, err.message);
}
#else /* if error, generate brief error message */
if (systf_h == NULL) {
    vpi_printf(""ERROR: PLIbook_getarg_handle_vpi() could not obtain iterator to systf args\n"");
    return(NULL);
}
#endif

for (i=1; i<=argNum; i++) {
    arg_h = vpi_scan(arg_itr);
#ifdef PLIbookDebug /* if error, generate verbose debug message */
    if (vpi_chk_error(&err)) {
        vpi_printf(""ERROR: PLIbook_getarg_handle_vpi() could not obtain handle to systf arg %d\n"", i);
        vpi_printf(""File %s, Line %d: %s\n"",
                   err.file, err.line, err.message);
    }
#endif
    if (arg_h == NULL) {
        vpi_printf(""ERROR: PLIbook_getarg_handle_vpi() systf arg %d out-of-range\n"",
                   argNum);
        return(NULL);
    }
}
vpi_free_object(arg_itr); /* free iterator -- didn't scan all args */

return(arg_h);
","This image contains an excerpt from ""The Verilog PLI Handbook"" showing a section of Verilog code related to the Programming Language Interface (PLI). The code handles error messaging for a system call argument handle retrieval process.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p652.jpg,True,"The image shows a page from ""The Verilog PLI Handbook, Appendices,"" with a piece of code written in C, which is related to Verilog Programming Language Interface (PLI). Here is the code present on the image:

```c
{
    0,                          /* type of PLI routine */
    0,                          /* user_data value */
    PLIbook_ShowVal_checktf,    /* checktf routine */
    PLIbook_ShowVal_sizetf,     /* sizetf routine */
    PLIbook_ShowVal_calltf,     /* calltf routine */
    0,                          /* misctf routine */
    ""$show_value"",              /* system task/function name */
    1                           /* forward reference = true */
},

{
    (userfunction,
    0,                          /* type of PLI routine */
    0,                          /* user_data value */
    PLIbook_pow_checktf,        /* checktf routine */
    PLIbook_pow_sizetf,         /* sizetf routine */
    PLIbook_pow_calltf,         /* calltf routine */
    PLIbook_pow_misctf,         /* misctf routine */
    ""$pow"",                     /* system task/function name */
    1                           /* forward reference = true */
},

{0} /*** final entry must be 0 ***/
};
```

The code seems to be a part of an array definition, possibly used to define PLI applications in the Verilog simulation environment. Each entry specifies the handlers for the different callback functions associated with a system task or function in Verilog (e.g., checktf, sizetf, calltf, misctf), the name of the system task/function, and whether a forward reference is allowed.

Please note that without further context from preceding or following pages, some of the details and the purpose of this specific code snippet might not be fully clear."," 0,                          /* type of PLI routine */
    0,                          /* user_data value */
    PLIbook_ShowVal_checktf,    /* checktf routine */
    PLIbook_ShowVal_sizetf,     /* sizetf routine */
    PLIbook_ShowVal_calltf,     /* calltf routine */
    0,                          /* misctf routine */
    ""$show_value"",              /* system task/function name */
    1                           /* forward reference = true */
},

{
    (userfunction,
    0,                          /* type of PLI routine */
    0,                          /* user_data value */
    PLIbook_pow_checktf,        /* checktf routine */
    PLIbook_pow_sizetf,         /* sizetf routine */
    PLIbook_pow_calltf,         /* calltf routine */
    PLIbook_pow_misctf,         /* misctf routine */
    ""$pow"",                     /* system task/function name */
    1                           /* forward reference = true */
},

{0} /*** final entry must be 0 ***/
};
","""Excerpt from The Verilog PLI Handbook detailing the structure and initialization of PLI applications in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p120.jpg,True,"The image contains a snippet of code from a Verilog PLI (Programming Language Interface) Handbook. Here is the text of the code present in the image:

```c
#define PLIbookDebug 1  /* set to 0 to omit debug messages */
#ifdef PLIbookDebug
  s_vpi_error_info err; /* allocate a VPI error structure */
#endif

primitive_handle = vpi_handle(vpiPrimitive, NULL);
#ifdef PLIbookDebug  /* if error, generate verbose debug message */
  if (vpi_chk_error(&err)) {
    vpi_printf(""\nERROR:\n"");
    vpi_printf("" Product: %s Code: %s\n"", err.product, err.code);
    vpi_printf("" Message: %s\n"", err.message);
    if (err.file != NULL) {
      vpi_printf("" File: %s Line: %d\n\n"", err.file, err.line);
    }
  }
#else  /* if error, generate basic error message */
  if (primitive_handle == NULL)
    vpi_printf(""\nERROR: could not obtain primitive handle\n"");
#endif
```

This example demonstrates how to use `vpi_chk_error` to check for errors after calling `vpi_handle` and how to print detailed error information depending on whether `PLIbookDebug` is defined and set to 1. If debugging is enabled, it will print out the product, code, message, file, and line number associated with the error. If debugging is not enabled, a basic error message is printed if the handle could not be obtained.","ne PLIbookDebug 1  /* set to 0 to omit debug messages */
#ifdef PLIbookDebug
  s_vpi_error_info err; /* allocate a VPI error structure */
#endif

primitive_handle = vpi_handle(vpiPrimitive, NULL);
#ifdef PLIbookDebug  /* if error, generate verbose debug message */
  if (vpi_chk_error(&err)) {
    vpi_printf(""\nERROR:\n"");
    vpi_printf("" Product: %s Code: %s\n"", err.product, err.code);
    vpi_printf("" Message: %s\n"", err.message);
    if (err.file != NULL) {
      vpi_printf("" File: %s Line: %d\n\n"", err.file, err.line);
    }
  }
#else  /* if error, generate basic error message */
  if (primitive_handle == NULL)
    vpi_printf(""\nERROR: could not obtain primitive handle\n"");
#endif
","""Verilog Programming Interface (VPI) error handling example using conditional compilation for debugging.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p137.jpg,True,"The image contains several snippets of Verilog code used within assert property statements. Here are the Verilog code excerpts:

1.
```verilog
a1: assert property (@(posedge clk) start |-> ##2 send |-> ##3 ack);
```

2.
```verilog
a2: assert property (@(posedge clk) start ##2 send |-> ##3 ack);
```

3.
```verilog
a1: assert property (@(posedge clk) req |-> req until grant);
```

4.
```verilog
a2: assert property (@(posedge clk) reg |-> reg until_with grant);
```","
a1: assert property (@(posedge clk) start |-> ##2 send |-> ##3 ack);


a2: assert property (@(posedge clk) start ##2 send |-> ##3 ack);


a1: assert property (@(posedge clk) req |-> req until grant);


a2: assert property (@(posedge clk) reg |-> reg until_with grant);
",Discussion and code examples related to synchronous assertion properties in Verilog using SystemVerilog syntax for sequence and property definitions.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p311.jpg,True,"The image contains snippets of text that describe aspects of Verilog coding conventions and control variables for runtime macros from the Assertion Monitor Library (OVL) but does not contain actual code implementations or examples. Here are the text snippets visible in the image:

```
{ ,ordered_port_connection}
| named_port_connection { ,named_port_connection}

ordered_port_connection ::= [expression]

named_port_connection ::= .port_identifier
([expression])

assert_identifier ::= assert_[type_identifier]

type_identifier ::= identifier
```

```
A.2.1 OVL runtime macro controls

The Assertion Monitor Library currently includes four Verilog
Macro Global Variables:

`ASSERT_GLOBAL_RESET`
`ASSERT_MAX_REPORT_ERROR`
`ASSERT_ON`
`ASSERT_INIT_MSG`

These four variables are described briefly in the table below and in
greater detail in the following paragraphs.
```

```
Variable                   Definition
----------------------------------------------------------
ASSERT_GLOBAL_RESET        Overrides individual reset_n signals
ASSERT_MAX_REPORT_ERROR    Defines the number of errors required to trigger a report
ASSERT_ON                  Enables assertion monitors during verification
ASSERT_INIT_MSG            Prints a report that lists the assertions present in a
                           given simulation environment.
```

```
The list_of_module_connections has one required
parameter, reset_n. The signal reset_n is an active low signal
that indicates to the assertion monitor when the initialization of
the circuit being monitored is complete. During the time when
reset_n is low, the assertion monitor will be disabled and not
initialized. Alternatively, to specify a reset_n signal or condition
for each assertion monitor, you may specify the global macro
variable `ASSERT_GLOBAL_RESET`. If this variable is
defined, all instantiated monitors will disregard their respective
reset_n signals. Instead, they will be initialized whenever
`ASSERT_GLOBAL_RESET` is low.
```

Please note that the content shown above includes definitions and descriptions, not executable Verilog code.","ered_port_connection}
| named_port_connection { ,named_port_connection}

ordered_port_connection ::= [expression]

named_port_connection ::= .port_identifier
([expression])

assert_identifier ::= assert_[type_identifier]

type_identifier ::= identifier

OVL runtime macro controls

The Assertion Monitor Library currently includes four Verilog
Macro Global Variables:

`ASSERT_GLOBAL_RESET`
`ASSERT_MAX_REPORT_ERROR`
`ASSERT_ON`
`ASSERT_INIT_MSG`

These four variables are described briefly in the table below and in
greater detail in the following paragraphs.

le                   Definition
----------------------------------------------------------
ASSERT_GLOBAL_RESET        Overrides individual reset_n signals
ASSERT_MAX_REPORT_ERROR    Defines the number of errors required to trigger a report
ASSERT_ON                  Enables assertion monitors during verification
ASSERT_INIT_MSG            Prints a report that lists the assertions present in a
                           given simulation environment.

st_of_module_connections has one required
parameter, reset_n. The signal reset_n is an active low signal
that indicates to the assertion monitor when the initialization of
the circuit being monitored is complete. During the time when
reset_n is low, the assertion monitor will be disabled and not
initialized. Alternatively, to specify a reset_n signal or condition
for each assertion monitor, you may specify the global macro
variable `ASSERT_GLOBAL_RESET`. If this variable is
defined, all instantiated monitors will disregard their respective
reset_n signals. Instead, they will be initialized whenever
`ASSERT_GLOBAL_RESET` is low.
",Verilog syntax and Open Verification Library (OVL) runtime macro controls for assertion monitoring.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p380.jpg,True,"The image contains text and what appear to be testbench logs or simulation results rather than actual Verilog code. It seems to be a part of a document or book discussing certain scenarios that occur during the verification of Verilog code. Here is the text that can be considered similar to code or command-line actions, though it is not syntactical Verilog code:

```
run -all
KERNEL: 10 clk=1 req=0 gnt=0
KERNEL: 30 clk=1 req=1 gnt=0
KERNEL: 50 clk=1 req=0 gnt=0
KERNEL: 70 clk=1 req=0 gnt=1
KERNEL: 90 clk=1 req=1 gnt=0
KERNEL: 110 clk=1 req=0 gnt=0
KERNEL: 130 clk=1 req=0 gnt=0
```
The text also includes results such as ""PASS"" and ""FAIL"" referencing what seems to be a `test_implication` function or procedure, and it poses questions related to the test results at specific simulation times.","ll
KERNEL: 10 clk=1 req=0 gnt=0
KERNEL: 30 clk=1 req=1 gnt=0
KERNEL: 50 clk=1 req=0 gnt=0
KERNEL: 70 clk=1 req=0 gnt=1
KERNEL: 90 clk=1 req=1 gnt=0
KERNEL: 110 clk=1 req=0 gnt=0
KERNEL: 130 clk=1 req=0 gnt=0
","A text-based exploration of test implications in a Verilog simulation environment, questioning the occurrence of multiple pass and fail outcomes at specific simulation times.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p394.jpg,True,"The image contains Verilog code. Here is the code transcribed from the image:

```verilog
fifowrite(10);
fiforead(9);
@(posedge clk);
@(posedge clk);
@(posedge clk); $finish(2);
end

always #5 clk=!clk;

task fiforeset;
fifo_write=0; fifo_read=0; rst_=1;
@(negedge clk); rst_=0;
@(negedge clk);
@(negedge clk); rst_=1;
endtask

task fifowrite;
input int nwrite;
fifo_read=0;
for (int i=0; i<nwrite-1; i++)
    begin
    @(negedge clk); fifo_write=1; fifo_data_in=i;
    // $display($stime,,, ""fifo Write Data = %0d"", fifo_data_in);
    end
endtask

task fiforead;
input int nread;
fifo_write=0;
repeat(nread)
    begin
    @(negedge clk); fifo_read=1;
    // $display($stime,,, ""fifo Read Data = %0d"", fifo_data_out);
    end
endtask

always @(posedge clk)
$display($stime,,, ""rst_=%b clk=%b fifo_write=%b fifo_read=%b
fifo_full=%b fifo_empty=%b wr_ptr=%0d rd_ptr=%0d cnt=%0d"",
rst_,clk,fifo_write,fifo_read,fifo_full,fifo_empty,fil_wr_-
ptr,fil_rd_ptr,fil.cnt);

endmodule
```

Please note that the code appears to be part of a larger module that is not completely shown in the image, and some comments may indicate that additional display functionality (`$display`) has been commented out.","
fifowrite(10);
fiforead(9);
@(posedge clk);
@(posedge clk);
@(posedge clk); $finish(2);
end

always #5 clk=!clk;

task fiforeset;
fifo_write=0; fifo_read=0; rst_=1;
@(negedge clk); rst_=0;
@(negedge clk);
@(negedge clk); rst_=1;
endtask

task fifowrite;
input int nwrite;
fifo_read=0;
for (int i=0; i<nwrite-1; i++)
    begin
    @(negedge clk); fifo_write=1; fifo_data_in=i;
    // $display($stime,,, ""fifo Write Data = %0d"", fifo_data_in);
    end
endtask

task fiforead;
input int nread;
fifo_write=0;
repeat(nread)
    begin
    @(negedge clk); fifo_read=1;
    // $display($stime,,, ""fifo Read Data = %0d"", fifo_data_out);
    end
endtask

always @(posedge clk)
$display($stime,,, ""rst_=%b clk=%b fifo_write=%b fifo_read=%b
fifo_full=%b fifo_empty=%b wr_ptr=%0d rd_ptr=%0d cnt=%0d"",
rst_,clk,fifo_write,fifo_read,fifo_full,fifo_empty,fil_wr_-
ptr,fil_rd_ptr,fil.cnt);

endmodule
","Caption: ""Verilog code example for FIFO read and write tasks, along with a clock toggling statement and a testbench sequence.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p56.jpg,True,"Here is the Verilog code snippet from the image:

```verilog
`ifdef ASSERT_ON
FIFO_check: assert @(posedge clk) (reset_n => FIFO_depth < 7);
`endif
```

This code is demonstrating the use of conditional compilation in Verilog to include assertions in the design only when the `ASSERT_ON` macro is defined.","
`ifdef ASSERT_ON
FIFO_check: assert @(posedge clk) (reset_n => FIFO_depth < 7);
`endif
","""Best practices for naming Verilog assertions and methods for conditional assertion compilation.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p172.jpg,True,"The image contains pseudo-code for a Boolean program and two counterexample illustrations, some of which appear to represent program traces or states. Here is the pseudo-code from the image:

```verilog
(a) Boolean program

bool b1; /* i < 1000 */
bool b2; /* j < 1000 */

L1: b1, b2 := 1, 1;
L2: if (!b2) goto L7;
L3: assert (b1);
L4: skip;
L5: b1, b2 := *, *;
L6: goto L2;
L7: skip;

(b) Counterexample (c) Counterexample with loop

L1: b1 b2           L1: b1 b2
L2: b1 b2           L2: b1 b2
L3: b1 b2           L3: b1 b2
L4: b1 b2           L4: b1 b2
L5: b1 b2           L5: b1 b2
L6: b1 b2           L6: b1 b2
L2: b1 b2           L2: b1 b2
L3: b1 b2           L3: b1 b2
```

The `*` symbol in the statement `b1, b2 := *, *;` usually indicates non-deterministic assignment in programming language semantics.

The other parts of the text are academic in nature and describe a method of enriching counterexamples with loop information, detection of loops, feasibility of counterexamples with loops, and information about a loop detection algorithm.","
(a) Boolean program

bool b1; /* i < 1000 */
bool b2; /* j < 1000 */

L1: b1, b2 := 1, 1;
L2: if (!b2) goto L7;
L3: assert (b1);
L4: skip;
L5: b1, b2 := *, *;
L6: goto L2;
L7: skip;

(b) Counterexample (c) Counterexample with loop

L1: b1 b2           L1: b1 b2
L2: b1 b2           L2: b1 b2
L3: b1 b2           L3: b1 b2
L4: b1 b2           L4: b1 b2
L5: b1 b2           L5: b1 b2
L6: b1 b2           L6: b1 b2
L2: b1 b2           L2: b1 b2
L3: b1 b2           L3: b1 b2
","""Exploration of counterexamples in model checking with emphasis on loop detection and counterexample feasibility in Verilog programs.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p242.jpg,True,"The image contains a portion of a textbook or educational material discussing Verilog code. The code on this page is as follows:

```verilog
module b_dp(ap_in0,ap_in1, ap_out0,ap_out1);
  input [39:0] ap_in0, ap_in1;
  output [47:0] ap_out0, ap_out1;
  reg [47:0]ap_out0, ap_out1;

  function [47:0] c_ecc_out;
    input [39:0] c_data_in;
    begin
      c_ecc_out = { (^ (c_data_in & 40'h00000007l)),
                    (^ (c_data_in & 40'h0000ff89)),
                    (^ (c_data_in & 40'h00f35c60)),
                    (^ (c_data_in & 40'h71c3ca84)),
                    (^ (c_data_in & 40'hd6455353)),
                    (^ (c_data_in & 40'h892e2fa38)),
                    (^ (c_data_in & 40'hr0294bd7)),
                    (^ (c_data_in & 40'hea360c677)),
                    c_data_in};
    end
  endfunction

  always @ (ap_in0 or ap_in1)
  begin
    ap_out0 = c_ecc_out (ap_in0);
    ap_out1 = c_ecc_out (ap_in1);
  end
endmodule //b_dp

assign ap_out0 = c_ecc_out (ap_in0);
assign ap_out1 = c_ecc_out (ap_in1);
```

This code defines a Verilog module with inputs and outputs, a function to calculate error-correcting codes, and procedural assignments within an always block, as well as continuous assignments outside the module scope with the `assign` keyword. It is worth noting that there appears to be a syntax convention error within this code as the ""assign"" lines should be inside the module definition to be syntactically correct—unless they are intended as an alternative example to the ""always"" block inside the module, which is a common educational method to show different ways to achieve similar functionality in Verilog.","
module b_dp(ap_in0,ap_in1, ap_out0,ap_out1);
  input [39:0] ap_in0, ap_in1;
  output [47:0] ap_out0, ap_out1;
  reg [47:0]ap_out0, ap_out1;

  function [47:0] c_ecc_out;
    input [39:0] c_data_in;
    begin
      c_ecc_out = { (^ (c_data_in & 40'h00000007l)),
                    (^ (c_data_in & 40'h0000ff89)),
                    (^ (c_data_in & 40'h00f35c60)),
                    (^ (c_data_in & 40'h71c3ca84)),
                    (^ (c_data_in & 40'hd6455353)),
                    (^ (c_data_in & 40'h892e2fa38)),
                    (^ (c_data_in & 40'hr0294bd7)),
                    (^ (c_data_in & 40'hea360c677)),
                    c_data_in};
    end
  endfunction

  always @ (ap_in0 or ap_in1)
  begin
    ap_out0 = c_ecc_out (ap_in0);
    ap_out1 = c_ecc_out (ap_in1);
  end
endmodule //b_dp

assign ap_out0 = c_ecc_out (ap_in0);
assign ap_out1 = c_ecc_out (ap_in1);
",Verilog code example showing the use of functions for combinational logic and procedural assignments for module outputs.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p256.jpg,True,"The image contains a snippet of C code related to Verilog simulation. Here's the code extract:

```c
char *plusarg;
...
plusarg = mc_scan_plusargs(""rseed="");
After executing the function call, plusarg contains a pointer to a string containing ""89674523.""
```

This snippet demonstrates how to use a C function `mc_scan_plusargs` to retrieve values passed to a Verilog simulation via command-line arguments. The function searches for the argument ""rseed="" and when found, it assigns the subsequent value to the variable `plusarg`.","*plusarg;
...
plusarg = mc_scan_plusargs(""rseed="");
After executing the function call, plusarg contains a pointer to a string containing ""89674523.""
","Caption: ""Excerpt from a technical text discussing Verilog simulation run options and a code snippet for parsing command line arguments in a Verilog test environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p194.jpg,True,"The image does contain code. Here it is:

```verilog
reg[63:0] SerVect = // The current 64-bit window to scan.
    63              50              40              30              20              10              0
/* 32109876 54321098 76543210 98765432 10987654 32109876 54321098 76543210 */
'64'b01100001_00011000_01100010_00010000_01111001_00010000_01111101_00000000;

localparam [PadHi:0] p0 = 8'b0000_00_00; // The pad patterns.
localparam [PadHi:0] p1 = 8'b0000_01_00; // localparams can't be overridden.
localparam [PadHi:0] p2 = 8'b0000_10_00;
localparam [PadHi:0] p3 = 8'b0000_11_00;

...
if (
    (SerVect[55]==mp[7] && SerVect[54]==mp[6] && SerVect[53]==mp[5]
     && SerVect[52]==mp[4] && SerVect[51]==mp[3]
     && SerVect[50]==mp[3] && SerVect[49]==mp[3] && SerVect[48]==mp[0]
     && SerVect[39]==mp[7] && ... (total of 32 compares)
    ) Found = 1'b0;
else Found = 1'b0;
... (etc.)
```

This snippet seems to be a part of a Verilog digital design used for finding patterns within a parallel stream of data. The `reg[63:0] SerVect` declaration is a 64-bit register intended to hold the current window of data to be scanned for patterns. Local parameters are defined with potentially corresponding pad patterns, and a condition is written that compares parts of `SerVect` to match an unspecified pattern `mp`. If the pattern is found, the Found signal is set to a certain value. Please note that the code snippet provided is not complete and is presented in a truncated form for illustrative purposes.","
reg[63:0] SerVect = // The current 64-bit window to scan.
    63              50              40              30              20              10              0
/* 32109876 54321098 76543210 98765432 10987654 32109876 54321098 76543210 */
'64'b01100001_00011000_01100010_00010000_01111001_00010000_01111101_00000000;

localparam [PadHi:0] p0 = 8'b0000_00_00; // The pad patterns.
localparam [PadHi:0] p1 = 8'b0000_01_00; // localparams can't be overridden.
localparam [PadHi:0] p2 = 8'b0000_10_00;
localparam [PadHi:0] p3 = 8'b0000_11_00;

...
if (
    (SerVect[55]==mp[7] && SerVect[54]==mp[6] && SerVect[53]==mp[5]
     && SerVect[52]==mp[4] && SerVect[51]==mp[3]
     && SerVect[50]==mp[3] && SerVect[49]==mp[3] && SerVect[48]==mp[0]
     && SerVect[39]==mp[7] && ... (total of 32 compares)
    ) Found = 1'b0;
else Found = 1'b0;
... (etc.)
","""Excerpt from a digital design text discussing serial window scanning in Verilog and previewing a phase-locked loop (PLL) lab exercise.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p237.jpg,True,"The image contains examples of Verilog code. Here is the code extracted from the image:

```verilog
sequence busGnt;
    @(posedge clk) req ##[1:5] gnt;
endsequence

initial begin
    wait (busGnt.triggered) $display($stime,, ""Bus Grant given"");
end

sequence abc;
    @(posedge clk) a ##[1:5] #1 b [*5] #1 c;
endsequence

sequence myseq;
    @(posedge clk) d #1 abc.triggered #1 d;
endsequence
```

These code snippets show examples of how the `.triggered` method is used in SystemVerilog sequence expressions within a procedural context.","
sequence busGnt;
    @(posedge clk) req ##[1:5] gnt;
endsequence

initial begin
    wait (busGnt.triggered) $display($stime,, ""Bus Grant given"");
end

sequence abc;
    @(posedge clk) a ##[1:5] #1 b [*5] #1 c;
endsequence

sequence myseq;
    @(posedge clk) d #1 abc.triggered #1 d;
endsequence
","""Understanding the .triggered construct in Verilog for sequence endpoint detection.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p344.jpg,True,"The image includes a section of Verilog code. Here it is:

```verilog
module ctc_complex;

logic irdyn, trdyn, devseln, stopn, framen;
integer i, j;
logic clk;
logic [3:0] test_expr;

assign irdyn = test_expr[3];
assign trdyn = test_expr[2];
assign devseln = test_expr[1];
assign stopn = test_expr[0];
```","
module ctc_complex;

logic irdyn, trdyn, devseln, stopn, framen;
integer i, j;
logic clk;
logic [3:0] test_expr;

assign irdyn = test_expr[3];
assign trdyn = test_expr[2];
assign devseln = test_expr[1];
assign stopn = test_expr[0];
","""Understanding Verilog Code for Stimulus Generation with a Table of Logical Conditions for PCI Check""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p223.jpg,True,"```
property Frame_to_IRDY (integer minTime);
integer localBaseTime;
  @(posedge clk) ($fall(Frame_), localBaseTime = $time)
    |=> 
    $rose(IRDY) && $time >= localBaseTime + minTime;
endproperty

measureTime: assert property (Frame_to_IRDY (MINIMUM_TIME));
```","ty Frame_to_IRDY (integer minTime);
integer localBaseTime;
  @(posedge clk) ($fall(Frame_), localBaseTime = $time)
    |=> 
    $rose(IRDY) && $time >= localBaseTime + minTime;
endproperty

measureTime: assert property (Frame_to_IRDY (MINIMUM_TIME));
","Caption: ""Verilog property example for ensuring a minimum time interval between events using the SystemVerilog Assertions (SVA) framework.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p55.jpg,True,"Here's the Verilog code from the image:

```verilog
assert_never_q_safe ( clk, reset_n,
  (q_valid==1’b1) ? (q_underflow==1’b1): 1’b1);
```

Please note that there appears to be a syntax error in the code. Verilog uses `'b` to specify binary values, but in the image, there seems to be a typographical error with `1’b1` which should instead be `1'b1`.","
assert_never_q_safe ( clk, reset_n,
  (q_valid==1’b1) ? (q_underflow==1’b1): 1’b1);
","""Sequential Assertion Monitor Example in Verilog""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p732.jpg,True,"The image displays text descriptions of several Verilog Programming Language Interface (PLI) functions, but there is no actual source code or programming language syntax present. It's a list of function prototypes and descriptions, not code that can be executed or compiled. However, if you wish to have the function prototypes written out as they might appear in source code, I can provide that. Here are the function prototypes and the corresponding explanations as text:

```c
void tf_long_to_real(int low, int high, double *real);
```
Converts a 64-bit long integer to a real number.

```c
char *tf_longtime_tostr(int lowtime, int hightime);
```
Converts simulation time (64-bit unsigned integer) to a character string. Returns a pointer to the string.

```c
void tf_message(int level, char *facility, char *code, char *format, ...);
```
Prints a formatted message to the simulator’s output channel and output log file. Uses formatting controls similar to C printf, with a maximum of 5 arguments.

```c
char *tf_mipname();
char *tf_imipname(char *tfinst);
```
Returns a pointer to a string containing the full hierarchical path name of the module containing the calling or specific instance of a system task/function.","tf_long_to_real(int low, int high, double *real);

*tf_longtime_tostr(int lowtime, int hightime);

tf_message(int level, char *facility, char *code, char *format, ...);

*tf_mipname();
char *tf_imipname(char *tfinst);
","This image shows a page from ""The Verilog PLI Handbook,"" detailing the prototypes and descriptions for several functions in Verilog's Programming Language Interface (PLI).",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p98.jpg,True,"```verilog
sequence sr1;
  req ##2 gnt;
endsequence

property pr1;
  @(posedge clk) cStart |-> sr1;
endproperty

reqGnt: assert property (pr1) $display($stime,,""\t %m PASS"");
else $display($stime,,""\t\t %m FAIL"");
```","
sequence sr1;
  req ##2 gnt;
endsequence

property pr1;
  @(posedge clk) cStart |-> sr1;
endproperty

reqGnt: assert property (pr1) $display($stime,,""\t %m PASS"");
else $display($stime,,""\t\t %m FAIL"");
","""Exploring multi-threaded concurrent assertions in Verilog SystemVerilog Assertions (SVA).""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p73.jpg,True,"The image contains excerpts from a document regarding Verilog code, specifically discussing immediate assertions, including examples of legal and illegal usage. Below are the code snippets from the image:

Illegal examples:
```verilog
frameirdy: assert final (!frame == irdy) else begin interrupt=1;
$error (""FAILURE""); end //ILLEGAL
frameirdy: assertfinal (!frame == irdy) else begin $error (""FAILURE""); 
end //ILLEGAL
```

Legal examples:
```verilog
frameirdy: assert final (!frame == irdy) else $error(""FAILURE""); //LEGAL (no begin-end)
frameirdy: assert final (!frame == irdy) $info(""PASS""); else $error(""FAILURE""); //LEGAL
frameirdy: assert final (!frame == irdy); //LEGAL - no action block
```

Code involving modules with deferred immediate assertions:
```verilog
module (x, y, z);
....
    z1: assert final (x == y || z);
endmodule

This is equivalent to

module (x, y, z);
    always_comb begin
        z1: assert final (x == y || z);
    end
endmodule
```

The document also mentions that along with ""assert,"" there are corresponding deferred ""cover"" and ""assume"" statements in SystemVerilog and their usage is analogous to the ""assert"" example provided.","
frameirdy: assert final (!frame == irdy) else begin interrupt=1;
$error (""FAILURE""); end //ILLEGAL
frameirdy: assertfinal (!frame == irdy) else begin $error (""FAILURE""); 
end //ILLEGAL


frameirdy: assert final (!frame == irdy) else $error(""FAILURE""); //LEGAL (no begin-end)
frameirdy: assert final (!frame == irdy) $info(""PASS""); else $error(""FAILURE""); //LEGAL
frameirdy: assert final (!frame == irdy); //LEGAL - no action block


module (x, y, z);
....
    z1: assert final (x == y || z);
endmodule

This is equivalent to

module (x, y, z);
    always_comb begin
        z1: assert final (x == y || z);
    end
endmodule
","An excerpt from a technical document explaining immediate assertions in Verilog, showing examples of both illegal and legal usage of 'assert final' statements.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p265.jpg,True,"The image contains two snippets of code. They are written in a hardware description language.

Here is the first snippet:
```verilog
assert property ($onehot(select));
```
This code represents a SystemVerilog assertion used to validate a one-hot selector.

Here is the second snippet:
```verilog
cover {select[2'b00]};
cover {select[2'b01]};
cover {select[2'b10]};
cover {select[2'b11]};
```
These lines are for PSL (Property Specification Language) functional coverage for each input selected, to track which cases of 'select' have been covered during simulation.","
assert property ($onehot(select));


cover {select[2'b00]};
cover {select[2'b01]};
cover {select[2'b10]};
cover {select[2'b11]};
","Caption: ""Examples of SystemVerilog assertions and functional coverage for validating one-hot selectors and priority multiplexers in digital design verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p271.jpg,True,"The image contains SystemVerilog code within a documentation context. Here's the code snippet provided:

```verilog
genvar N;
generate for (N=1; N<=15; N= N+ 1)
  cover property @(posedge clk) ({int1,int2,int3,int4 } == N);
endgenerate
```

This SystemVerilog code appears to be used for defining functional coverage in a verification environment. It's setting up coverage points for the values of the `int1` through `int4` signals, checking that at the positive edge of the `clk` signal, the concatenation of these signals equals the value of `N` as it iterates from 1 to 15.","
genvar N;
generate for (N=1; N<=15; N= N+ 1)
  cover property @(posedge clk) ({int1,int2,int3,int4 } == N);
endgenerate
",Excerpt from a technical document on Assertion-Based Design showcasing a SystemVerilog code example for functional coverage and discussing assertions in a simple single request protocol.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p259.jpg,True,"The image contains code written in Property Specification Language (PSL) which is used to describe temporal sequences in hardware description languages such as Verilog or VHDL:

``` 
cover { (state == \ READ\ ); [*2] ; state == \ REFRESH\ };
```

``` 
cover {state == \ IDLE\ ; state == \ READ\ };
cover {state == \ READ1\ ; state == \ STALL\ }; // and so on.
```"," { (state == \ READ\ ); [*2] ; state == \ REFRESH\ };

 {state == \ IDLE\ ; state == \ READ\ };
cover {state == \ READ1\ ; state == \ STALL\ }; // and so on.
","Caption: ""The image showcases a section from a textbook on Assertion-Based Design discussing State Sequence Coverage and Functional Coverage in Verilog, with examples of PSL (Property Specification Language) code for verifying state transitions in a system.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p82.jpg,True,"This image contains Verilog code. Here it is:

```verilog
_x_X [15:12]));
mux2_4 m2(
    .s(s), .d1(d1[(11:8)]), .d0(d0[(11:8)]),
    .x_X (x[11:8]));
mux2_4 m3(
    .s(s), .d1(d1[(7:4)]), .d0(d0[(7:4)]),
    .x_X (x[7:4]));
mux2_4 m4(
    .s(s), .d1(d1[(3:0)]), .d0(d0[(3:0)]),
    .x_X (x[3:0]));
endmodule // mux2_20

module mux2_4(s, d0, d1, x_);
input s;
input [3:0] d0, d1;
output [3:0] x_;
// Vendor Macro Cell
SLI42M sli42_0
.A1(d1[0]),.A2(d1[1]),.A3(d1[2]),.A4(d1[3]),
.B1(d0[0]),.B2(d0[1]),.B3(d0[2]),.B4(d0[3]),.S(s),
.X1(x_[0]),.X2(x_[1]),.X3(x_[2]),.X4(x_[3]));
endmodule // mux2_4

module SLI42M (A1,A2,A3,A4,B1,B2,B3,B4,S,X1,X2,X3,X4);
input S;
input A1,A2,A3,A4,B1,B2,B3,B4;
output X1,X2,X3,X4;
assign X1 = (S ? A1 : B1 );
assign X2 = (S ? A2 : B2 );
assign X3 = (S ? A3 : B3 );
assign X4 = (S ? A4 : B4 );
endmodule // SLI42M
```

Please note, however, that there may be a continuation of the code before or after what is visible in the image. The code defines several modules, likely part of a more extensive Verilog source describing a digital system.","
_x_X [15:12]));
mux2_4 m2(
    .s(s), .d1(d1[(11:8)]), .d0(d0[(11:8)]),
    .x_X (x[11:8]));
mux2_4 m3(
    .s(s), .d1(d1[(7:4)]), .d0(d0[(7:4)]),
    .x_X (x[7:4]));
mux2_4 m4(
    .s(s), .d1(d1[(3:0)]), .d0(d0[(3:0)]),
    .x_X (x[3:0]));
endmodule // mux2_20

module mux2_4(s, d0, d1, x_);
input s;
input [3:0] d0, d1;
output [3:0] x_;
// Vendor Macro Cell
SLI42M sli42_0
.A1(d1[0]),.A2(d1[1]),.A3(d1[2]),.A4(d1[3]),
.B1(d0[0]),.B2(d0[1]),.B3(d0[2]),.B4(d0[3]),.S(s),
.X1(x_[0]),.X2(x_[1]),.X3(x_[2]),.X4(x_[3]));
endmodule // mux2_4

module SLI42M (A1,A2,A3,A4,B1,B2,B3,B4,S,X1,X2,X3,X4);
input S;
input A1,A2,A3,A4,B1,B2,B3,B4;
output X1,X2,X3,X4;
assign X1 = (S ? A1 : B1 );
assign X2 = (S ? A2 : B2 );
assign X3 = (S ? A3 : B3 );
assign X4 = (S ? A4 : B4 );
endmodule // SLI42M
","""Excerpt from a technical document showing Verilog code for multiplexer modules and text discussing OBHD Scan Chain Hookup.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p146.jpg,True,"The image contains code snippets written in the context of SVA (SystemVerilog Assertions). Here is the code from the page:

```verilog
property p_mtltw;
// master 1 writing to target 1
@(posedge clk)
  $fell(frame1 && irdy1) |->
  ##3 ($fell(trdy[1])) ##3 !data[8];

endproperty

property p_mltOr;
// master 1 reading from target 0
@(posedge clk)
  $fell(frame1 && irdy1) |->
  ##3 ($fell(trdy[0])) ##3 !data[8];

endproperty

property p_mltOw;
// master 1 writing to target 0
@(posedge clk)
  $fell(frame1 && irdy1) |->
  ##3 ($fell(trdy[0])) ##3 data[8];

endproperty

property p_m2t1r;
// master 2 reading from target 1
@(posedge clk)
  $fell(frame2 && irdy2) |->
  ##3 ($fell(trdy[1])) ##3 !data[8];

endproperty

property p_m2t1w;
// master 2 writing to target 1
@(posedge clk)
  $fell(frame2 && irdy2) |->
  ##3 ($fell(trdy[1])) ##3 data[8];

endproperty

property p_m2tOr;
// master 2 reading from target 0
@(posedge clk)
  $fell(frame2 && irdy2) |->
  ##3 ($fell(trdy[0])) ##3 !data[8];
```

This code defines various properties used for assertion checking in SystemVerilog. Properties are commonly used in formal verification to assert the correctness of a design with regard to certain conditions or protocols. Each property represents a specific condition that is translated into an assertion to be checked during simulation.","
property p_mtltw;
// master 1 writing to target 1
@(posedge clk)
  $fell(frame1 && irdy1) |->
  ##3 ($fell(trdy[1])) ##3 !data[8];

endproperty

property p_mltOr;
// master 1 reading from target 0
@(posedge clk)
  $fell(frame1 && irdy1) |->
  ##3 ($fell(trdy[0])) ##3 !data[8];

endproperty

property p_mltOw;
// master 1 writing to target 0
@(posedge clk)
  $fell(frame1 && irdy1) |->
  ##3 ($fell(trdy[0])) ##3 data[8];

endproperty

property p_m2t1r;
// master 2 reading from target 1
@(posedge clk)
  $fell(frame2 && irdy2) |->
  ##3 ($fell(trdy[1])) ##3 !data[8];

endproperty

property p_m2t1w;
// master 2 writing to target 1
@(posedge clk)
  $fell(frame2 && irdy2) |->
  ##3 ($fell(trdy[1])) ##3 data[8];

endproperty

property p_m2tOr;
// master 2 reading from target 0
@(posedge clk)
  $fell(frame2 && irdy2) |->
  ##3 ($fell(trdy[0])) ##3 !data[8];
","""Excerpt from a book displaying SystemVerilog Assertion (SVA) properties for simulation methodology.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p518.jpg,True,"The image contains a snippet of text describing Verilog Programming Language Interface (PLI), specifically focusing on conditional module path delay. While there is a representation of code or syntax in the diagram, there is no complete Verilog code excerpt to transcribe.

However, I can transcribe the diagrammed representation of path delay syntax for you:

```verilog
(if (opcode == add) (a, b *> out) = (5, 3);
```

This representation indicates a conditional module path delay with a path condition expression, path inputs, a module path, and a path output. This is not a complete code snippet but shows how one could specify a condition for path delays in Verilog.","
(if (opcode == add) (a, b *> out) = (5, 3);
","""Page from 'The Verilog PLI Handbook' detailing the conditional module path delay syntax in Verilog and listing ACC routines for module path handling.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p72.jpg,True,"The image contains three pieces of Verilog code, as follows:

1.
```verilog
always@(posedge Clk)
    Q <= D
```

2.
```verilog
always@(negedge Clk)
    Q <= D
```

3.
```verilog
initial Clock = 1'b0;
...
always@(Clock)
    #10 Clock <= !Clock;
```

These snippets demonstrate Verilog syntax for describing the behavior of digital circuits, specifically related to clocking and edge-triggered events.","
always@(posedge Clk)
    Q <= D


always@(negedge Clk)
    Q <= D


initial Clock = 1'b0;
...
always@(Clock)
    #10 Clock <= !Clock;
","Caption: ""Best practices for using blocking and nonblocking assignments in Verilog, with example code snippets and corresponding digital logic schematics for clocked flip-flops and a clock signal generation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p265.jpg,True,"The image contains a snippet of Verilog code as part of an exercise question. Here is the code extracted from the image:

```verilog
class MemTrans;
  rand bit rw; // read if rw=0, write if rw=1
  rand bit [7:0] data_in;
  rand bit [3:0] address;
endclass // MemTrans
```","
class MemTrans;
  rand bit rw; // read if rw=0, write if rw=1
  rand bit [7:0] data_in;
  rand bit [3:0] address;
endclass // MemTrans
",Exercise instructions and a class definition in Verilog for creating memory transaction constraints and testing them.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p47.jpg,True,"The image contains a snippet of Verilog code in the context of an exercise. The code is an assertion statement.

Here is the code:

```verilog
assert property(@(posedge clk) req[*2] |=> grant[*2]);
```

The exercise associated with this code is:

1.3. Implement the following assertion in RTL: two consecutive requests should be followed by two consecutive grants.","
assert property(@(posedge clk) req[*2] |=> grant[*2]);
","""Introduction to Verification Units and SystemVerilog Assertions with an Exercise on Implementing an Assertion""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p396.jpg,True,"There is Verilog code in the image. Here it is:

```verilog
// OLD, unsynthesizable VFO:
always@(ClockIn, Reset)                     // The input system clock.
  if (Reset=='b1)
    ... (stuff) ...
  else if (CounterClock=='b1)               // The PLL MultiCounter output clock.
    VarClockCount = VarClockCount + 2'b01;
  else
    begin
      case (VarClockCount)                   // The comparator object.
        2'b00: AdjustFreq = 2'b11;
        2'b01: AdjustFreq = 2'b01;
        default: AdjustFreq = 2'b00;
      endcase
    VarClockCount = 2'b00;
    end
```","
// OLD, unsynthesizable VFO:
always@(ClockIn, Reset)                     // The input system clock.
  if (Reset=='b1)
    ... (stuff) ...
  else if (CounterClock=='b1)               // The PLL MultiCounter output clock.
    VarClockCount = VarClockCount + 2'b01;
  else
    begin
      case (VarClockCount)                   // The comparator object.
        2'b00: AdjustFreq = 2'b11;
        2'b01: AdjustFreq = 2'b01;
        default: AdjustFreq = 2'b00;
      endcase
    VarClockCount = 2'b00;
    end
","Caption: ""Excerpt from a digital VLSI design textbook discussing a synthesizable frequency comparator in Verilog, highlighting issues with latch inference and the transition from unsynthesizable code to an improved edge-sensitive implementation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p269.jpg,True,"The image contains Verilog code. Here is the code snippet from the image:

```verilog
sequence r;
  @(posedge clk) a ##1 b[k:1:2];
endsequence : r

sequence req;
  start_req ##1 end_req;
endsequence : req

sequence ack;
  enable ##[1:10] end_ack;
endsequence

a1: assert property (req |-> busy until_with ack);

a2: assert property (req |-> busy until_with ack.triggered);

a3: assert property (disable iff (rst)
  req |-> busy until_with ack.triggered);
```

This code is from a section discussing sequence methods and presenting examples of assertions in Verilog/SystemVerilog for hardware verification.","
sequence r;
  @(posedge clk) a ##1 b[k:1:2];
endsequence : r

sequence req;
  start_req ##1 end_req;
endsequence : req

sequence ack;
  enable ##[1:10] end_ack;
endsequence

a1: assert property (req |-> busy until_with ack);

a2: assert property (req |-> busy until_with ack.triggered);

a3: assert property (disable iff (rst)
  req |-> busy until_with ack.triggered);
","""Understanding Sequence Methods in SystemVerilog Assertions and Their Application in Verification""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p271.jpg,True,"The image contains Verilog code associated with a `fork...join_none` example. The code snippet is as follows:

```verilog
initial begin
  $display(""%0t: start fork...join_none example"", $time);
  #10 $display(""%0t: sequential after #10"", $time);
  fork
    $display(""%0t: parallel start"", $time);
    #50 $display(""%0t: parallel after #50"", $time);
    #10 $display(""%0t: parallel after #10"", $time);
    begin
      #30 $display(""%0t: sequential after #30"", $time);
      #10 $display(""%0t: sequential after #10"", $time);
    end
  join_none
  $display(""%0t: after join_none"", $time);
  #80 $display(""%0t: finish after #80"", $time);
end
```

This code uses the `fork...join_none` construct to schedule statements in parallel without waiting for all forked processes to complete before continuing with the sequential code that follows.","
initial begin
  $display(""%0t: start fork...join_none example"", $time);
  #10 $display(""%0t: sequential after #10"", $time);
  fork
    $display(""%0t: parallel start"", $time);
    #50 $display(""%0t: parallel after #50"", $time);
    #10 $display(""%0t: parallel after #10"", $time);
    begin
      #30 $display(""%0t: sequential after #30"", $time);
      #10 $display(""%0t: sequential after #10"", $time);
    end
  join_none
  $display(""%0t: after join_none"", $time);
  #80 $display(""%0t: finish after #80"", $time);
end
",Verilog code examples demonstrating the use of fork...join and fork...join_none constructs for parallel thread execution.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p53.jpg,True,"The image contains two snippets of Verilog code. Here are the transcriptions for both:

First snippet (flip-flop implementation):
```verilog
logic data, q, clk, rst;
always_ff @(posedge clk or negedge rst)
    if (!rst) q <= '1'b0;
    else q <= data;
```

Second snippet (final procedure to display assertion failures):
```verilog
logic clk, rdy, rst;
int fCount = 0;
...
always @(posedge clk) 
    rdy_fail: assert (rdy -> !rst) else fCount++;
final 
    $display(""Number of assertions rdy_fail failed: %d"",fCount);
```

Please note that in the second snippet, the '...' indicates that there may be additional code, which is not shown in this excerpt.","
logic data, q, clk, rst;
always_ff @(posedge clk or negedge rst)
    if (!rst) q <= '1'b0;
    else q <= data;


logic clk, rdy, rst;
int fCount = 0;
...
always @(posedge clk) 
    rdy_fail: assert (rdy -> !rst) else fCount++;
final 
    $display(""Number of assertions rdy_fail failed: %d"",fCount);
","The image shows a textbook page describing SystemVerilog procedures, specifically the always_ff and final procedures, with code examples for each.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p382.jpg,True,"The image contains text describing the syntax for `PATHPULSE` in Verilog. There are a couple of lines that can be considered as code:

```verilog
specparam PATHPULSE$Ain$Bout = (R_limit, E_limit);
```
```verilog
""PATHPULSE$ = (R_limit, E_limit);""
```
```verilog
""PATHPULSE$ = R_limit;""
```

These lines are examples of how to use `PATHPULSE` in Verilog code to specify timing paths and their limits.","
specparam PATHPULSE$Ain$Bout = (R_limit, E_limit);


""PATHPULSE$ = (R_limit, E_limit);""


""PATHPULSE$ = R_limit;""
",A textbook excerpt explaining the PATHPULSE syntax in Verilog with a waveform diagram illustrating pulse filtering effects.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p66.jpg,True,"The image contains two blocks of Verilog code. Here they are transcribed below:

First block of code:
```verilog
always@(posedge clk)
begin
    xreg = NewValue;
    `ifdef DC // ""if DC not defined""
        $display(""time=%0d: Xreg=[%h]"", $time, xreg);
    `endif
    yreg = ...
    `endif
    ...
end
```

Second block of code:
```verilog
always@(posedge clk)
begin
    xreg = NewValue;
    `ifdef DC
    `else
        $display(""time=%0d: Xreg=[%h]"", $time, xreg);
    `endif
    ...
end
```

Please note that the code given may be incomplete, and there may be errors (such as potentially mismatched `endif` directives) due to the original context within the image.","
always@(posedge clk)
begin
    xreg = NewValue;
    `ifdef DC // ""if DC not defined""
        $display(""time=%0d: Xreg=[%h]"", $time, xreg);
    `endif
    yreg = ...
    `endif
    ...
end


always@(posedge clk)
begin
    xreg = NewValue;
    `ifdef DC
    `else
        $display(""time=%0d: Xreg=[%h]"", $time, xreg);
    `endif
    ...
end
","The image shows a textbook page discussing Digital VLSI Design with Verilog, focusing on conditional compilation using `ifdef` and `endif` directives to make Verilog system tasks visible or invisible to synthesizers, and the similar usage of `else`. It includes examples of Verilog code using these preprocessor directives.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p152.jpg,True,"The image contains Verilog code. Here is the transcribed code:

```verilog
2. SVA SIMULATION METHODOLOGY

h_mt = $fopen(""mt.dat"");
end

// calling task for documentation

`ifdef slv_doc
c_m1t1w_doc:
  cover property(p_m1t1w) master_xaction(1,1);
c_m1t1r_doc:
  cover property(p_m1t1r) master_xaction(1,1);
c_m1t2w_doc:
  cover property(p_m1t0w) master_xaction(1,0);
c_m1t2r_doc:
  cover property(p_m1t0r) master_xaction(1,0);
c_m2t1w_doc:
  cover property(p_m2t1w) master_xaction(2,1);
c_m2t1r_doc:
  cover property(p_m2t1r) master_xaction(2,1);
c_m2t2w_doc:
  cover property(p_m2t0w) master_xaction(2,0);
c_m2t2r_doc:
  cover property(p_m2t0r) master_xaction(2,0);
c_m3t1w_doc:
  cover property(p_m3t1w) master_xaction(3,1);
c_m3t1r_doc:
  cover property(p_m3t1r) master_xaction(3,1);
c_m3t2w_doc:
  cover property(p_m3t0w) master_xaction(3,0);
c_m3t2r_doc:
  cover property(p_m3t0r) master_xaction(3,0);

`endif

task master_xaction(
  input int m_identity, input int t_identity);

integer i;

begin

if(data[8])
begin
```

Please note that this Verilog code snippet is part of a simulation methodology and includes conditional compilation directives (`ifdef`/`endif`), cover property specifications, and the initial lines of a task definition (`master_xaction`). However, since the text is cut off, some parts of the code may be missing.","
2. SVA SIMULATION METHODOLOGY

h_mt = $fopen(""mt.dat"");
end

// calling task for documentation

`ifdef slv_doc
c_m1t1w_doc:
  cover property(p_m1t1w) master_xaction(1,1);
c_m1t1r_doc:
  cover property(p_m1t1r) master_xaction(1,1);
c_m1t2w_doc:
  cover property(p_m1t0w) master_xaction(1,0);
c_m1t2r_doc:
  cover property(p_m1t0r) master_xaction(1,0);
c_m2t1w_doc:
  cover property(p_m2t1w) master_xaction(2,1);
c_m2t1r_doc:
  cover property(p_m2t1r) master_xaction(2,1);
c_m2t2w_doc:
  cover property(p_m2t0w) master_xaction(2,0);
c_m2t2r_doc:
  cover property(p_m2t0r) master_xaction(2,0);
c_m3t1w_doc:
  cover property(p_m3t1w) master_xaction(3,1);
c_m3t1r_doc:
  cover property(p_m3t1r) master_xaction(3,1);
c_m3t2w_doc:
  cover property(p_m3t0w) master_xaction(3,0);
c_m3t2r_doc:
  cover property(p_m3t0r) master_xaction(3,0);

`endif

task master_xaction(
  input int m_identity, input int t_identity);

integer i;

begin

if(data[8])
begin
","""Verilog code snippet showing SystemVerilog Assertions (SVA) coverage properties and a task definition for simulation documentation in a verification environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p533.jpg,True,"This image contains examples of Verilog code. Here is the code from the image:

```verilog
v <= ...;
...
v <= ...;
```

And another example is:

```verilog
if (cond) begin
    ... // sequence of statements 1
    v <= expr1;
    ... // sequence of statements 2
    v <= expr2;
end
```

It is rewritten as:

```verilog
if (cond) begin
    ... // sequence of statements 1
    v <= expr1;
end
```","
v <= ...;
...
v <= ...;


if (cond) begin
    ... // sequence of statements 1
    v <= expr1;
    ... // sequence of statements 2
    v <= expr2;
end


if (cond) begin
    ... // sequence of statements 1
    v <= expr1;
end
","Caption: ""Understanding the semantics of conditional assignments to free variables in SystemVerilog based on nonblocking assignment rules and loop unrolling.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p524.jpg,True,"The image contains Verilog code related to PLI (Programming Language Interface) in Verilog. Here are the contents of the code in the image:

```verilog
/***********************************************************************
 * Checktf application
 ***********************************************************************/
int PLIbook_CountLoads_checktf()
{
    static int valid_args[4] = {accNet, accReg, accRegBit, 0};
    int direction;
    handle tfarg_h, port_h;
    
    acc_initialize();
    if (tf_nump() != 1)
        tf_error(""$count_loads must have 1 argument."");
    else if (tf_typep(1) == TF_NULLPARAM)
        tf_error(""$count_loads arg cannot be null."");
    /* acc_handle_tfarg() returns a loconn handle, not a port handle */
    else if (tf_sizep(1) != 1)
        tf_error(""$count_loads arg must be scalar or a bit-select."");
    else {
        tfarg_h = acc_handle_tfarg(1);
        if (!acc_object_in_typelist(tfarg_h, valid_args)) {
            tf_error(""$count_loads arg must be a net or reg signal"");
            return(0);
        }
        port_h = acc_next_port(tfarg_h, null);
        if (port_h == null) {
            tf_error(""$count_loads arg is not connected to a module port."");
            return(0);
        }
        direction = acc_fetch_direction(port_h);
        if ( direction != accOutput
            && direction != accInout)
            tf_error(""$count_loads arg must be an output or inout port."");
    }
    acc_close();
    return(0);
}

/***********************************************************************
 * Calltf application
 ***********************************************************************/
int PLIbook_CountLoads_calltf()
{
    handle loconn_h, port_h, hiconn_h;
    int load_count;
    
    acc_initialize();
    acc_configure(accDisplayWarnings, ""true"");
    
    /* acc_handle_tfarg() returns a loconn handle, not a port handle */
    loconn_h = acc_handle_tfarg(1);
    port_h = acc_next_port(loconn_h, null);
    hiconn_h = acc_handle_hiconn(port_h);
    load_count = acc_count(acc_next_cell_load, hiconn_h);
    
    /* The rest of the code is not shown in the image */
}
```

Please note that there may be additional code that is not visible in the image provided. The code shown in the image is used for checking and counting loads using Verilog PLI. The comments in the code also indicate that certain functions return different types of handles, and the developer is expected to handle these correctly.","
/***********************************************************************
 * Checktf application
 ***********************************************************************/
int PLIbook_CountLoads_checktf()
{
    static int valid_args[4] = {accNet, accReg, accRegBit, 0};
    int direction;
    handle tfarg_h, port_h;
    
    acc_initialize();
    if (tf_nump() != 1)
        tf_error(""$count_loads must have 1 argument."");
    else if (tf_typep(1) == TF_NULLPARAM)
        tf_error(""$count_loads arg cannot be null."");
    /* acc_handle_tfarg() returns a loconn handle, not a port handle */
    else if (tf_sizep(1) != 1)
        tf_error(""$count_loads arg must be scalar or a bit-select."");
    else {
        tfarg_h = acc_handle_tfarg(1);
        if (!acc_object_in_typelist(tfarg_h, valid_args)) {
            tf_error(""$count_loads arg must be a net or reg signal"");
            return(0);
        }
        port_h = acc_next_port(tfarg_h, null);
        if (port_h == null) {
            tf_error(""$count_loads arg is not connected to a module port."");
            return(0);
        }
        direction = acc_fetch_direction(port_h);
        if ( direction != accOutput
            && direction != accInout)
            tf_error(""$count_loads arg must be an output or inout port."");
    }
    acc_close();
    return(0);
}

/***********************************************************************
 * Calltf application
 ***********************************************************************/
int PLIbook_CountLoads_calltf()
{
    handle loconn_h, port_h, hiconn_h;
    int load_count;
    
    acc_initialize();
    acc_configure(accDisplayWarnings, ""true"");
    
    /* acc_handle_tfarg() returns a loconn handle, not a port handle */
    loconn_h = acc_handle_tfarg(1);
    port_h = acc_next_port(loconn_h, null);
    hiconn_h = acc_handle_hiconn(port_h);
    load_count = acc_count(acc_next_cell_load, hiconn_h);
    
    /* The rest of the code is not shown in the image */
}
",Caption: Excerpts from the Verilog PLI handbook showing the use of PLI in Verilog code to manipulate and query properties of Verilog modules.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p242.jpg,True,"```c
#include ""vpi_user.h"" /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library
                          (using TF routines for simulation control) */

/* prototypes of routines in this PLI application */
int PLIbook_MyMonitor_calltf(), PLIbook_MyMonitor_compiletf(),
    PLIbook_MyMonitor_callback();

/**********************************************************************
 * VPI Registration Data
 **********************************************************************/
void PLIbook_MyMonitor_register()
{
  s_vpi_systf_data tf_data;

  tf_data.type         = vpiSysTask;
  tf_data.tfname       = ""$my_monitor"";
  tf_data.calltf       = PLIbook_MyMonitor_calltf;
  tf_data.compiletf    = PLIbook_MyMonitor_compiletf;
  tf_data.sizetf       = NULL;
  tf_data.user_data    = NULL;
  vpi_register_systf(&tf_data);
}

/**********************************************************************
 * compiletf application
 **********************************************************************/
int PLIbook_MyMonitor_compiletf(char *user_data)
{
  vpiHandle systf_handle, arg_iterator, arg_handle;
  int       tfarg_type;

  /* obtain a handle to the system task instance */
  systf_handle = vpi_handle(vpiSysTfCall, NULL);

  /* obtain handles to system task arguments */
  arg_iterator = vpi_iterate(vpiArgument, systf_handle);
  if (arg_iterator == NULL) {
    vpi_printf(""ERROR: $my_monitor requires 1 argument\n"");
    tf_dofinish(); /* abort simulation */
    return(0);
  }

  /* check the type of object in system task arguments */
  arg_handle = vpi_scan(arg_iterator);
  tfarg_type = vpi_get(vpiType, arg_handle);
  if (tfarg_type != vpiModule) {
    vpi_printf(""ERROR: $my_monitor arg1 must be module instance\n"");
    vpi_free_object(arg_iterator); /* free iterator memory */
    tf_dofinish(); /* abort simulation */
    return(0);
  }
}
```","ude ""vpi_user.h"" /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library
                          (using TF routines for simulation control) */

/* prototypes of routines in this PLI application */
int PLIbook_MyMonitor_calltf(), PLIbook_MyMonitor_compiletf(),
    PLIbook_MyMonitor_callback();

/**********************************************************************
 * VPI Registration Data
 **********************************************************************/
void PLIbook_MyMonitor_register()
{
  s_vpi_systf_data tf_data;

  tf_data.type         = vpiSysTask;
  tf_data.tfname       = ""$my_monitor"";
  tf_data.calltf       = PLIbook_MyMonitor_calltf;
  tf_data.compiletf    = PLIbook_MyMonitor_compiletf;
  tf_data.sizetf       = NULL;
  tf_data.user_data    = NULL;
  vpi_register_systf(&tf_data);
}

/**********************************************************************
 * compiletf application
 **********************************************************************/
int PLIbook_MyMonitor_compiletf(char *user_data)
{
  vpiHandle systf_handle, arg_iterator, arg_handle;
  int       tfarg_type;

  /* obtain a handle to the system task instance */
  systf_handle = vpi_handle(vpiSysTfCall, NULL);

  /* obtain handles to system task arguments */
  arg_iterator = vpi_iterate(vpiArgument, systf_handle);
  if (arg_iterator == NULL) {
    vpi_printf(""ERROR: $my_monitor requires 1 argument\n"");
    tf_dofinish(); /* abort simulation */
    return(0);
  }

  /* check the type of object in system task arguments */
  arg_handle = vpi_scan(arg_iterator);
  tfarg_type = vpi_get(vpiType, arg_handle);
  if (tfarg_type != vpiModule) {
    vpi_printf(""ERROR: $my_monitor arg1 must be module instance\n"");
    vpi_free_object(arg_iterator); /* free iterator memory */
    tf_dofinish(); /* abort simulation */
    return(0);
  }
}
","Excerpt from ""The Verilog PLI Handbook"" showing Verilog code for registering and handling a system task using the Programming Language Interface (PLI).",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p259.jpg,True,"The image contains several snippets of code. Here are the code segments presented:

The first segment:

```verilog
class Gen1;
Transaction tra, trb;

forever @(int1.cb)
  tra.randomize();
  trb.randomize();
endclass
```

The second segment:

```verilog
class Gen2;
Transaction tr1, tr2;

forever @(int2.cb)
  tr1.randomize();
  tr2.randomize();
endclass
```

The third segment:

```verilog
function void build();
pci_gen gen0, gen1;
gen0 = new();
gen1 = new();
fork
  gen0.run();
  gen1.run();
join
endfunction : build
```

These pieces of code seem to be examples in the context of ""Random Stability and Hierarchical Seeding"" in SystemVerilog, a hardware description and verification language.","
class Gen1;
Transaction tra, trb;

forever @(int1.cb)
  tra.randomize();
  trb.randomize();
endclass


class Gen2;
Transaction tr1, tr2;

forever @(int2.cb)
  tr1.randomize();
  tr2.randomize();
endclass


function void build();
pci_gen gen0, gen1;
gen0 = new();
gen1 = new();
fork
  gen0.run();
  gen1.run();
join
endfunction : build
","""Verilog Code Example Illustrating Separate Random Generators Per Object and Hierarchical Seeding for Testbench Stability""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p256.jpg,True,"```c
/* VPI Registration Data *********************************************************/

void PLIbook_ScientificALU_register()
{
    s_vpi_systf_data tf_data;
    tf_data.type        = vpiSysTask;
    tf_data.tfname      = ""$scientific_alu"";
    tf_data.calltf      = PLIbook_ScientificALU_calltf;
    tf_data.compiletf   = PLIbook_ScientificALU_compiletf;
    tf_data.sizetf      = NULL;
    tf_data.user_data   = NULL;
    vpi_register_systf(&tf_data);
}

/* Definition for a structure to hold the data to be passed from
 * calltf application to the ALU interface.
 *******************************************************************************/

typedef struct PLIbook_ScientificALU_data {
    vpiHandle a_h, b_h, opcode_h, result_h, excep_h, err_h;
} PLIbook_ALU_data_s, *PLIbook_ALU_data_p;

/* Handle change callback routine: Serves as an interface
 * between Verilog simulation and the C model. Called whenever the
 * C model inputs change value, passes the values to the C model, and
 * puts the C model outputs into simulation.
 *
 * NOTE: The handles for the arguments to scientific_alu were obtained
 * in the calltf routine and saved in application-allocated memory. A
 * pointer to this memory is passed to this callback via the user_data
 * field.
 *******************************************************************************/

int PLIbook_ScientificALU_interface(p_cb_data cb_data)
{
    double
        a, b, result;
    int
        opcode, excep, err;
    s_vpi_value value_s;

    PLIbook_ALU_data_p ALUdata;

    /* Retrieve pointer to ALU data structure from callback user_data. */
    /* The structure contains the handles for the scientific_alu args */
    ALUdata = (PLIbook_ALU_data_p)cb_data->user_data;

    /* Read current values of C model inputs from Verilog simulation */
    value_s.format = vpiRealVal;
    vpi_get_value(ALUdata->a_h, &value_s);
    a = value_s.value.real;

    vpi_get_value(ALUdata->b_h, &value_s);
    b = value_s.value.real;

    // ... The remainder of the code is not visible in the image provided.
```","I Registration Data *********************************************************/

void PLIbook_ScientificALU_register()
{
    s_vpi_systf_data tf_data;
    tf_data.type        = vpiSysTask;
    tf_data.tfname      = ""$scientific_alu"";
    tf_data.calltf      = PLIbook_ScientificALU_calltf;
    tf_data.compiletf   = PLIbook_ScientificALU_compiletf;
    tf_data.sizetf      = NULL;
    tf_data.user_data   = NULL;
    vpi_register_systf(&tf_data);
}

/* Definition for a structure to hold the data to be passed from
 * calltf application to the ALU interface.
 *******************************************************************************/

typedef struct PLIbook_ScientificALU_data {
    vpiHandle a_h, b_h, opcode_h, result_h, excep_h, err_h;
} PLIbook_ALU_data_s, *PLIbook_ALU_data_p;

/* Handle change callback routine: Serves as an interface
 * between Verilog simulation and the C model. Called whenever the
 * C model inputs change value, passes the values to the C model, and
 * puts the C model outputs into simulation.
 *
 * NOTE: The handles for the arguments to scientific_alu were obtained
 * in the calltf routine and saved in application-allocated memory. A
 * pointer to this memory is passed to this callback via the user_data
 * field.
 *******************************************************************************/

int PLIbook_ScientificALU_interface(p_cb_data cb_data)
{
    double
        a, b, result;
    int
        opcode, excep, err;
    s_vpi_value value_s;

    PLIbook_ALU_data_p ALUdata;

    /* Retrieve pointer to ALU data structure from callback user_data. */
    /* The structure contains the handles for the scientific_alu args */
    ALUdata = (PLIbook_ALU_data_p)cb_data->user_data;

    /* Read current values of C model inputs from Verilog simulation */
    value_s.format = vpiRealVal;
    vpi_get_value(ALUdata->a_h, &value_s);
    a = value_s.value.real;

    vpi_get_value(ALUdata->b_h, &value_s);
    b = value_s.value.real;

    // ... The remainder of the code is not visible in the image provided.
","Caption: ""Example of Verilog PLI (Programming Language Interface) code for registering and interfacing a scientific arithmetic logic unit (ALU) with a C model.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p241.jpg,True,"The image contains code snippets written in Verilog, specifically in the context of SystemVerilog assertions for the verification of digital circuits. Here are the code snippets:

```verilog
a1: assert property (
    strong(##m ev) implies sig[*(m + n + 1)]);
```

```verilog
a2: assert property (
    (!sig |-> !ev[*(m+1)]) and (ev |-> sig[*(n+1)]));
```

These snippets define two properties `a1` and `a2` within `assert property` statements which are part of SystemVerilog's Assertion Based Verification (ABV) feature set.","
a1: assert property (
    strong(##m ev) implies sig[*(m + n + 1)]);


a2: assert property (
    (!sig |-> !ev[*(m+1)]) and (ev |-> sig[*(n+1)]));
","""Explanation and examples of Boolean property operators in Verilog for sequence matching and temporal implication.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p527.jpg,True,"The image contains a snippet of Verilog code. Here is the code present in the image:

```verilog
checker check;
default clocking @($global_clock; endclocking
rand bit[5:0] v;
m1: assume property (v > 2);
m2: assume property (v < 7);
a1: assert property (v > 1);
a2: assert property (s_eventually v <= 5);
a3: assert property (s_eventually v > 5);
endchecker : check
```

This code examples are part of a text discussing free variables within Verilog checkers and assumptions/properties related to them.","
checker check;
default clocking @($global_clock; endclocking
rand bit[5:0] v;
m1: assume property (v > 2);
m2: assume property (v < 7);
a1: assert property (v > 1);
a2: assert property (s_eventually v <= 5);
a3: assert property (s_eventually v > 5);
endchecker : check
","""Verilog SVA Example with Free Variables and Checker""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p530.jpg,True,"The image contains a snippet of C code, which is provided below:

```c
char prim_name[64];
handle prim_handle;
double new_delay;

fscanf(file_p, ""%s %f"", prim_name, &new_delay);
prim_handle = acc_handle_by_name(prim_name, null);
if (prim_handle)
    /* add new delay value to the primitive object */
else
    /* error: primitive not found */
```

Additionally, there is a snippet of Verilog code as well:

```verilog
module my_chip (in1, in2, out);
    input in1, in2;
    output out;
    wire in1, in2, out;
    ...
endmodule
```","prim_name[64];
handle prim_handle;
double new_delay;

fscanf(file_p, ""%s %f"", prim_name, &new_delay);
prim_handle = acc_handle_by_name(prim_name, null);
if (prim_handle)
    /* add new delay value to the primitive object */
else
    /* error: primitive not found */


module my_chip (in1, in2, out);
    input in1, in2;
    output out;
    wire in1, in2, out;
    ...
endmodule
","""Explaining acc_handle_object in Verilog for accessing simulation objects with code examples""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p47.jpg,True,"The image contains Verilog SystemVerilog Assertion (SVA) code for defining a property and asserting that property within a hardware verification context. Here's the code:

```verilog
property p9;
    @(posedge clk) a |=> b;
endproperty

a9 : assert property(p9);
```","
property p9;
    @(posedge clk) a |=> b;
endproperty

a9 : assert property(p9);
",Verilog non-overlapped implication property example and evaluation with waveform illustration.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p433.jpg,True,"This image contains excerpts from a Digital VLSI Design book discussing steps involving FIFO (First-In-First-Out) register files in Verilog. There is a snippet of code present:

```verilog
always @(*)
  ...
  case (CurState)
    ...
    stateX: begin
      // 1. Check for read & write requests.
         Update read & write addresses.
         Issue memory read & write commands.
      // 2. Check for updated addresses.
         Assign NextState.
    end
    stateY: begin
      ...
    end
    ...
  endcase
```

This code represents part of a combinational block in a Verilog state machine for a FIFO. However, the code itself is incomplete as indicated by the ellipses (""...""), and it serves as an outline to describe the functionality that should occur in states `stateX` and `stateY` of the state machine.","
always @(*)
  ...
  case (CurState)
    ...
    stateX: begin
      // 1. Check for read & write requests.
         Update read & write addresses.
         Issue memory read & write commands.
      // 2. Check for updated addresses.
         Assign NextState.
    end
    stateY: begin
      ...
    end
    ...
  endcase
","Caption: ""Excerpt from a digital VLSI design textbook detailing the steps involved in the modification and routing of clock signals in a FIFO implementation using Verilog code, including a state machine transition logic.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p185.jpg,True,"Here is the Verilog code that is visible in the image:

```verilog
assign req_local[3:1] = { {req3, req2, req1} };
assign gnt_local[3:1] = { {gnt3, gnt2, gnt1} };

genvar j, k;
generate
    for (j=2; j<6; j++)
    begin: latency
        for (k=1; k<4; k++)
        begin: Master
            c_gnt_o :
            cover property(@(posedge clk) $fell(gnt_local[k])
                |-> ($past(req_local[k],j) == 1'b0));
        end
    end
endgenerate
```

This snippet of code is used within a SystemVerilog Assertion (SVA) context for specifying properties of finite state machines, particularly for coverage and latency.","
assign req_local[3:1] = { {req3, req2, req1} };
assign gnt_local[3:1] = { {gnt3, gnt2, gnt1} };

genvar j, k;
generate
    for (j=2; j<6; j++)
    begin: latency
        for (k=1; k<4; k++)
        begin: Master
            c_gnt_o :
            cover property(@(posedge clk) $fell(gnt_local[k])
                |-> ($past(req_local[k],j) == 1'b0));
        end
    end
endgenerate
","""Segment of a textbook discussing SystemVerilog Assertions (SVA) for Finite State Machines with an example of Verilog code for latency property coverage.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p75.jpg,True,"Here is the code from the image:

```verilog
initial begin
    byte twoD[4][6];
    foreach(twoD[i,j])
        twoD[i][j] = i*10+j;

    foreach (twoD[i]) begin  // Step through first dim.
        $write(""%2d:"", i);
        foreach(twoD[i,j])    // Step through second
            $write("" %3d"", twoD[i][j]);
        $display;
    end
end
```

This Verilog code showcases the use of two-dimensional arrays and `foreach` loops to iterate over the array elements and assign them values based on their indices. Then it prints out the contents of the two-dimensional array in a formatted manner.","
initial begin
    byte twoD[4][6];
    foreach(twoD[i,j])
        twoD[i][j] = i*10+j;

    foreach (twoD[i]) begin  // Step through first dim.
        $write(""%2d:"", i);
        foreach(twoD[i,j])    // Step through second
            $write("" %3d"", twoD[i][j]);
        $display;
    end
end
","""Example of iterating over multi-dimensional arrays in Verilog using the foreach loop.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p84.jpg,True,"The image contains Verilog code. Here is the Verilog code extract from the image:

```verilog
module mod1(output b, ...);
    assign b = ...;
    ...
endmodule

module mod2(...);
    wire a, b;
    mod1(.x);
    assign a = ...;
    a2: assert #0 (a == b);
endmodule
```

This code snippet shows two Verilog module definitions with some incomplete code portions indicated by `...`. The second module, `mod2`, includes an assertion statement labelled `a2`.","
module mod1(output b, ...);
    assign b = ...;
    ...
endmodule

module mod2(...);
    wire a, b;
    mod1(.x);
    assign a = ...;
    a2: assert #0 (a == b);
endmodule
",Caption: Example of Verilog code demonstrating observed deferred assertion and its behavior during simulation.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p355.jpg,True,"The image contains an example of a Verilog configuration code. Here is the code reproduced from the image:

```verilog
config config_name;
  design design_top_name;
  default list_of_libraries;
  cell cell_name use library_name;
  instance inst_name [use] instance_liblist [.cell];
endconfig
```

The text explains that the configuration is bounded by the keywords `config` and `endconfig`. It also describes the purpose of the Verilog configuration and how keywords and other reserved words are used.","
config config_name;
  design design_top_name;
  default list_of_libraries;
  cell cell_name use library_name;
  instance inst_name [use] instance_liblist [.cell];
endconfig
","Caption: ""Explanation of Verilog configuration syntax and usage for module versioning and library management.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p90.jpg,True,"The image contains a segment of a document discussing assertion statements in the context of simulation evaluation attempts in Verilog or SystemVerilog. There is a piece of Verilog code in the image, which is an assertion statement. Here is the code:

```verilog
a1: assert property(@(posedge clk) a ##1 b);
```

This code defines an assertion with the label 'a1'. It specifies that at every positive edge of the clock (`posedge clk`), the property that signal 'a' is followed by signal 'b' one clock cycle later (`a ##1 b`) must hold true. The use of '##' indicates a sequential timing relationship between the occurrences of the signals in the assertion.","
a1: assert property(@(posedge clk) a ##1 b);
","Caption: ""Excerpt from a document explaining simulation evaluation attempts in Verilog, including a sample assertion property.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p61.jpg,True,"The image contains Verilog code. Below is the code:

Sample 1.2
```verilog
task write(reg [15:0] addr, reg [31:0] data);
    // Drive Control bus
    @(posedge clk)
    PAddr <= addr;
    PWData <= data;
    PWrite <= 1’b1;
    PSel <= 1’b1;

    // Toggle PEnable
    @(posedge clk)
    PEnable <= 1’b1;
    @(posedge clk)
    PEnable <= 1’b0;
endtask
```

Sample 1.3
```verilog
module test(PAddr, PWrite, PSel, PWData, PEnable, Rst, clk);
    // Port declarations omitted...

    // Tasks as shown in Sample 1-2

    initial begin
        reset();                    // Reset the device
        write(16’h50, 32’h50);      // Write data into memory

        // Check the result
        if (top.mem.memory[16’h50] == 32’h50)
            $display(""Success"");
        else
            $display(""Error, wrong value in memory"");
        $finish;
    end
endmodule
```

Please note that the apostrophes in the binary literals (`1’b1` and `1’b0`) might actually be intended to be straight single quotes (`1'b1` and `1'b0`) typically used to denote binary values in Verilog. This is likely an error introduced during the text OCR (optical character recognition) or typesetting process.","
task write(reg [15:0] addr, reg [31:0] data);
    // Drive Control bus
    @(posedge clk)
    PAddr <= addr;
    PWData <= data;
    PWrite <= 1’b1;
    PSel <= 1’b1;

    // Toggle PEnable
    @(posedge clk)
    PEnable <= 1’b1;
    @(posedge clk)
    PEnable <= 1’b0;
endtask


module test(PAddr, PWrite, PSel, PWData, PEnable, Rst, clk);
    // Port declarations omitted...

    // Tasks as shown in Sample 1-2

    initial begin
        reset();                    // Reset the device
        write(16’h50, 32’h50);      // Write data into memory

        // Check the result
        if (top.mem.memory[16’h50] == 32’h50)
            $display(""Success"");
        else
            $display(""Error, wrong value in memory"");
        $finish;
    end
endmodule
",Verilog task example for writing data to APB bus and a simple memory write testbench.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p90.jpg,True,"```verilog
property p34;
    @(posedge clk)
    disable iff (reset)
    $rose(start) |-> a[=2] ##1 b[=2] ##1 !start;
endproperty

a34: assert property(p34);
```","
property p34;
    @(posedge clk)
    disable iff (reset)
    $rose(start) |-> a[=2] ##1 b[=2] ##1 !start;
endproperty

a34: assert property(p34);
","This is a textbook page with an explanation of the ""disable iff"" construct in SystemVerilog Assertions (SVA) alongside an example of an SVA property and an evaluation table for various SVA checker built-in functions.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p369.jpg,True,"The image contains a snippet of text that includes an example of Verilog code within a larger context. Here is the code from the image:

```verilog
specparam tClkQR=5, tClkQF=8, dBuf=1, tClr=2;
...
posedge iClk => BufO) = (tClkQR+dBuf, tClkQF+dBuf);
...
``` 

This excerpt displays a use of `specparam` for specifying timing parameters and the definition of delay values for a posedge-triggered output `BufO`.","
specparam tClkQR=5, tClkQF=8, dBuf=1, tClr=2;
...
posedge iClk => BufO) = (tClkQR+dBuf, tClkQF+dBuf);
...
","""Verilog Timing Delays: Specifying and simulating edge-sensitive delays in synchronous logic using Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p295.jpg,True,"The image contains excerpts of Verilog code, which I'll transcribe below:

```verilog
always @(posedge clock)
    if (chip_out !== $pow(base, exponent))
        ...

initial
    $monitor(""output = %f"", $pow(base, exponent));

assign temp = i + $pow(base, exponent);
```

Further down in the image, there is another Verilog code block inside a `module` definition:

```verilog
module top (...);
    ...
    reg [15:0] in1;
    ...
    my_chip u1 (in1, out1);
    ...
    initial
        $cell_count(u1);
    ...
    always @(posedge clock)
        $read_vector_file(""vectors.pat"", in1);
    ...
endmodule
```

This code includes examples of how to use system functions and tasks with arguments and how to instantiate modules with arguments in a Verilog design.","
always @(posedge clock)
    if (chip_out !== $pow(base, exponent))
        ...

initial
    $monitor(""output = %f"", $pow(base, exponent));

assign temp = i + $pow(base, exponent);


module top (...);
    ...
    reg [15:0] in1;
    ...
    my_chip u1 (in1, out1);
    ...
    initial
        $cell_count(u1);
    ...
    always @(posedge clock)
        $read_vector_file(""vectors.pat"", in1);
    ...
endmodule
","""Excerpt from a textbook on interfacing PLI applications with Verilog simulators, illustrating the use of system task/function arguments and instances in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p84.jpg,True,"The image contains Verilog code within a document that's discussing the ""first_match"" construct in SystemVerilog Assertions (SVA). Here is the code presented in the image:

```verilog
sequence s30a;
    @(posedge clk) a ##[1:3] b;
endsequence

sequence s30b;
    @(posedge clk) c ##[2:3] d;
endsequence

property p30;
    @(posedge clk) first_match(s30a or s30b);
endproperty
```","
sequence s30a;
    @(posedge clk) a ##[1:3] b;
endsequence

sequence s30b;
    @(posedge clk) c ##[2:3] d;
endsequence

property p30;
    @(posedge clk) first_match(s30a or s30b);
endproperty
","The image shows a page from a document related to SystemVerilog Assertions (SVA) with a focus on the ""first_match"" construct used in temporal logic to ensure that only the first matching sequence in a specified timing window is considered.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p99.jpg,True,"```verilog
...
always @(ClockStim) #25 ClockStim <= !ClockStim;
//
initial
begin
    #0 ClockStim = 1'b0;
    ...
end
```","
...
always @(ClockStim) #25 ClockStim <= !ClockStim;
//
initial
begin
    #0 ClockStim = 1'b0;
    ...
end
","""Example of a Verilog code snippet for clock generation in a simulation testbench along with instructions for refining timing.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p239.jpg,True,"There is no code in this image, but there are mathematical expressions and set notations that pertain to the formal verification process in Verilog or another hardware description language. Here are the notations provided:

```
- APc = AP ∪ {resetc, (c = 0), ..., (c = N)}, Sc = S
  x Sc, Sc0 = S0 x {s0c}, Rc = {((s, sc), (s', sc')), ((s, scN), (s', scN)) | (s, s') ∈ R}
  ∪ {((s, sc), (s', sc' + 1)) | (s, sc), (s', sc') ∈ R, 0 ≤ i < N}
- Lc((s, sc)) = L(s) ∪ {resetc | i = 0} ∪ {(c = i)}.
```

These notations define the components of a Kripke structure that represents the possible states and transitions within a timer system, which is an element of temporal hardware verification. This structure is used to verify the behavior of a system with respect to time constraints and liveness properties. 

They use:

- `APc` (atomic propositions for the timer c)
- `Sc` (states for the timer c)
- `Sc0` (initial states for the timer c)
- `Rc` (transition relation for the timer c)
- `Lc` (a labeling function assigning a set of atomic propositions to each state in Sc)

The purpose of these components is to formally represent and analyze the behavior of the timer as it counts and resets within specified bounds.","= AP ∪ {resetc, (c = 0), ..., (c = N)}, Sc = S
  x Sc, Sc0 = S0 x {s0c}, Rc = {((s, sc), (s', sc')), ((s, scN), (s', scN)) | (s, s') ∈ R}
  ∪ {((s, sc), (s', sc' + 1)) | (s, sc), (s', sc') ∈ R, 0 ≤ i < N}
- Lc((s, sc)) = L(s) ∪ {resetc | i = 0} ∪ {(c = i)}.
","""Fig. 2. Kripke structure of a timer with an upper bound depicted in an academic paper on formal verification methods in computer science.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p294.jpg,True,"```verilog
always @(posedge clock)
  $read_test_vector(""vectors.pat"", input_vector);
```","
always @(posedge clock)
  $read_test_vector(""vectors.pat"", input_vector);
","""Excerpt from a book detailing the usage of user-defined system tasks and functions in Verilog HDL, including code examples.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p98.jpg,True,"The image contains text and a figure related to Digital VLSI Design with Verilog, including a brief snippet of Verilog code. Here's the code snippet from the image:

```verilog
wire toInputCombo_A;
...
DFFC A_in_FF(.Q(toInputCombo_A), .D(A), ...);

DFFC myFFInstanceName(... , .Clk(ScanClk), .Clr(ScanClr));
```

These lines of code are showing how to wire a D flip-flop with a clear signal (`DFFC`) in Verilog, specifying the connections to the `Q` output and `D` input, as well as connections for a clock (`Clk`) and clear (`Clr`) control signals. The rest of the text provides context and instructions on how to work with these lines of code within a digital design, but does not include further code.","
wire toInputCombo_A;
...
DFFC A_in_FF(.Q(toInputCombo_A), .D(A), ...);

DFFC myFFInstanceName(... , .Clk(ScanClk), .Clr(ScanClr));
","Caption: ""Guidance on structuring Verilog code for D flip-flop component instantiation and connecting scan clock and clear signals, including a schematic representation of the updated design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p85.jpg,True,"The image contains both text discussing Verilog concepts and snippets of Verilog code. Here is the code from the image:

```verilog
a30: assert property(p30);
```

And the textual representation of another Verilog expression related to property testing:

```verilog
(expression) throughout (sequence definition)
```

Additionally, there's an example test expression provided in the image:

```verilog
((a&&b) ##1 ((-c) [*3]) ##1 (a&&b)).
```","
a30: assert property(p30);


(expression) throughout (sequence definition)


((a&&b) ##1 ((-c) [*3]) ##1 (a&&b)).
","An educational excerpt explaining and illustrating the use of the ""first_match"" construct in SystemVerilog Assertions (SVA) with a waveform example.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p280.jpg,True,"```verilog
always @(posedge clock)
    $display(""chip_out = %h"", chip_out);

always @(posedge clock)
    vector <= $random();
```","
always @(posedge clock)
    $display(""chip_out = %h"", chip_out);

always @(posedge clock)
    vector <= $random();
","""Explanation of Verilog PLI application creation steps and examples of system tasks and functions in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p297.jpg,True,"The image contains examples of properties written in a formal syntax that resembles code, but it is not actually Verilog code. These are theoretical examples used to illustrate clock flow rules in a text-based context, likely from a textbook or academic paper on hardware description languages. Below are the examples from the image:

Example 12.3:
```
@(ev1) a |=> b ##1 @(ev2) c
```

Example 12.4:
```
@(ev1) a ##1 (b ##1 @(ev2) c) |=> d
```

The examples demonstrate the use of temporal operators in property specification. The symbols |=> and ##1 are used to indicate temporal relations between events or conditions in a hardware verification or design context."," a |=> b ##1 @(ev2) c

 a ##1 (b ##1 @(ev2) c) |=> d
",This image features excerpts from a text discussing clock flow rules in Verilog code along with examples on how clocks govern various constructs within properties.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p135.jpg,True,"The image contains Verilog code, which is as follows:

```verilog
assign c_a = f1;
assign c_b = f2;
assign c_c = f3;
assign c_y = (c_a & c_b) | ~c_c;
```

This code snippet appears to be part of an educational text or document explaining concepts of digital design, possibly with a focus on synthesis and mapping of RTL (Register-Transfer Level) code to gate-level implementations.","
assign c_a = f1;
assign c_b = f2;
assign c_c = f3;
assign c_y = (c_a & c_b) | ~c_c;
","""Example of a simple register-transfer level (RTL) specification in Verilog with corresponding gate implementation diagram and mapping points.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p60.jpg,True,"The image contains Verilog code. Here is the code:

```verilog
module test(PAddr, PWrite, PSel, PWData, PEnable, Rst, clk);
// Port declarations omitted...

initial begin
    // Drive reset
    Rst <= 0;
    #100 Rst <= 1'b1;

    // Drive the control bus
    @(posedge clk)
    PAddr  <= 16'h50;
    PWData <= 32'h50;
    PWrite <= 1'b1;
    PSel   <= 1'b1;

    // Toggle PEnable
    @(posedge clk)
    PEnable <= 1'b1;
    @(posedge clk)
    PEnable <= 1'b0;

    // Check the result
    if (top.mem.memory[16'h50] == 32'h50)
        $display(""Success"");
    else
        $display(""Error, wrong value in memory"");
    $finish;
end
endmodule
```

This Verilog code appears to be an example of how to drive the APB (Advanced Peripheral Bus) pins within a test module. It sets up initial values and controls the data flow to the bus, finally checking if the desired result is obtained and printing an appropriate message.","
module test(PAddr, PWrite, PSel, PWData, PEnable, Rst, clk);
// Port declarations omitted...

initial begin
    // Drive reset
    Rst <= 0;
    #100 Rst <= 1'b1;

    // Drive the control bus
    @(posedge clk)
    PAddr  <= 16'h50;
    PWData <= 32'h50;
    PWrite <= 1'b1;
    PSel   <= 1'b1;

    // Toggle PEnable
    @(posedge clk)
    PEnable <= 1'b1;
    @(posedge clk)
    PEnable <= 1'b0;

    // Check the result
    if (top.mem.memory[16'h50] == 32'h50)
        $display(""Success"");
    else
        $display(""Error, wrong value in memory"");
    $finish;
end
endmodule
","""Verilog Testbench Example for Driving APB (Advanced Peripheral Bus) Pins""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p91.jpg,True,"The image contains Verilog code. Here it is:

```verilog
Example 4.5. Operator always as a top-level property in an assertion.

module m;
  bit clk, a, b;
  default clocking ccc @(posedge clk); endclocking
  a_always: assert property(always (a ##1 b));
//...
endmodule

Example 4.6. The following two assertions provide an interesting illustration of the meaning of an evaluation attempt.

module m;
  bit clk, a, b;
  a1: assert property(@(posedge clk) a |=> b);
  initial
    a2: assert property(@(posedge clk) always (a |=> b));
endmodule
```","
Example 4.5. Operator always as a top-level property in an assertion.

module m;
  bit clk, a, b;
  default clocking ccc @(posedge clk); endclocking
  a_always: assert property(always (a ##1 b));
//...
endmodule

Example 4.6. The following two assertions provide an interesting illustration of the meaning of an evaluation attempt.

module m;
  bit clk, a, b;
  a1: assert property(@(posedge clk) a |=> b);
  initial
    a2: assert property(@(posedge clk) always (a |=> b));
endmodule
","Caption: ""Discussion and example of concurrent assertions in Verilog, highlighting the usage and implications of the always operator for assertions within a module.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p184.jpg,True,"The image contains a snippet of Verilog code. The code is for generating cover statements in SystemVerilog using a generate loop. Here is the transcript of the code:

```verilog
genvar s;
generate
  for (s=2; s<=6; s++)
  begin: generic
    c_gnt_generic : cover property(@(posedge clk) $rose(gnt) |->
      ($past(req,s) == 'b1));
  end
endgenerate
```

This code is being used to analyze the latency of an arbiter in responding to requests (`req`) by observing the grant signal (`gnt`). The `for` loop generates cover properties for different latencies (from 2 to 6 cycles in this case).","
genvar s;
generate
  for (s=2; s<=6; s++)
  begin: generic
    c_gnt_generic : cover property(@(posedge clk) $rose(gnt) |->
      ($past(req,s) == 'b1));
  end
endgenerate
","""Example of Verilog generate statement used for creating multiple coverage properties to measure arbiter response time in a digital system.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p432.jpg,True,"```verilog
always@(ClkR, ClkW, Reset)
  if (Reset=='1'b1)
    StateClock = '1'b0;
  else StateClock = !StateClock;
```

```verilog
// read & write command logic
// Set the default:
NextState = normal;
//
// Check for a_full (R == W+1):
tmpCount = WriteCount+1;
if (ReadCount==tmpCount)
    NextState = a_full;
//
// Check for a_empty (W == R+1):
tmpCount = ReadCount+1;
if (WriteCount==tmpCount)
    NextState = a_empty;
```","
always@(ClkR, ClkW, Reset)
  if (Reset=='1'b1)
    StateClock = '1'b0;
  else StateClock = !StateClock;


// read & write command logic
// Set the default:
NextState = normal;
//
// Check for a_full (R == W+1):
tmpCount = WriteCount+1;
if (ReadCount==tmpCount)
    NextState = a_full;
//
// Check for a_empty (W == R+1):
tmpCount = ReadCount+1;
if (WriteCount==tmpCount)
    NextState = a_empty;
","Caption: ""Verilog HDL code snippet demonstrating change-sensitive always block and state machine transition logic for handling read and write operations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p85.jpg,True,"The image contains the following Verilog code:

```verilog
program prog(output b, ...);
    assign b = ...;
    ...
endprogram

module mod2(...);
    wire a, b;
    prog(.*);
    assign a = ...;
    a3: assert final (a == b);
endmodule
```

This snippet is part of a discussion on deferred assertions in Verilog.","
program prog(output b, ...);
    assign b = ...;
    ...
endprogram

module mod2(...);
    wire a, b;
    prog(.*);
    assign a = ...;
    a3: assert final (a == b);
endmodule
",Caption: Example Verilog code demonstrating the use of a final deferred assertion for simulation robustness against glitches.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p74.jpg,True,"The image contains several segments of Verilog code. Here it is:

Sample 2.9:
```verilog
initial begin
  ascend = '{0,1,2,3};
  $display(""%p"", ascend);      // '{0, 1, 2, 3}
  ascend = '{4{8}};
  $display(""%p"", ascend);      // '{8, 8, 8, 8}
end
```

Sample 2.10:
```verilog
initial begin
  bit [31:0] src[5], dst[5];
  for (int i=0; i<$size(src); i++)
    src[i] = i;                // Initialize src array
  foreach (dst[j])
    dst[j] = src[j] * 2;       // Set dst array to 2 * src
end
```

Sample 2.11:
```verilog
int md[2][3] = '{'{0,1,2}, '{3,4,5}};
initial begin
  $display(""Initial value:"");
  foreach (md[i,j])            // Yes, this is the right syntax
    $display(""md[%0d][%0d] = %0d"", i, j, md[i][j]);

  $display(""New value:"");
  // Replicate last 3 values of 5
  md = '{'{9, 8, 7}, '{3{5}}};
  foreach (md[i,j])            // Yes, this is the right syntax
    $display(""md[%0d][%0d] = %0d"", i, j, md[i][j]);
end
```
These code samples show how to use `""%p""` print specifier, basic array operations using `for` and `foreach` loops in Verilog, and handling multi-dimensional arrays with `foreach`.","
initial begin
  ascend = '{0,1,2,3};
  $display(""%p"", ascend);      // '{0, 1, 2, 3}
  ascend = '{4{8}};
  $display(""%p"", ascend);      // '{8, 8, 8, 8}
end


initial begin
  bit [31:0] src[5], dst[5];
  for (int i=0; i<$size(src); i++)
    src[i] = i;                // Initialize src array
  foreach (dst[j])
    dst[j] = src[j] * 2;       // Set dst array to 2 * src
end


int md[2][3] = '{'{0,1,2}, '{3,4,5}};
initial begin
  $display(""Initial value:"");
  foreach (md[i,j])            // Yes, this is the right syntax
    $display(""md[%0d][%0d] = %0d"", i, j, md[i][j]);

  $display(""New value:"");
  // Replicate last 3 values of 5
  md = '{'{9, 8, 7}, '{3{5}}};
  foreach (md[i,j])            // Yes, this is the right syntax
    $display(""md[%0d][%0d] = %0d"", i, j, md[i][j]);
end
",Excerpt from a textbook on Verilog that explains how to use `%p` print specifier for displaying arrays and the basic array operations with `for` and `foreach` loops in Verilog.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p257.jpg,True,"The image contains code in the context of interfacing to C models using VPI routines in a Verilog environment. Here is the code excerpt:

```verilog
value_s.format = vpiIntVal;
vpi_get_value(ALUdata->opcode_h, &value_s);
opcode = value_s.value.integer;

/****** Call the C model ******/
PLIbook_ScientificALU_C_model(&result, &execp, &err, a, b, opcode);

/* Write the C model outputs onto the Verilog signals */
value_s.format = vpiRealVal;
value_s.value.real = result;
vpi_put_value(ALUdata->result_h, &value_s, NULL, vpiNoDelay);

value_s.format = vpiIntVal;
value_s.value.integer = execp;
vpi_put_value(ALUdata->execp_h, &value_s, NULL, vpiNoDelay);

value_s.value.integer = err;
vpi_put_value(ALUdata->err_h, &value_s, NULL, vpiNoDelay);

return(0);
}

/******************************************************************************
 * callback routine: Registers a callback to the C model interface
 * whenever any input to the C model changes value
 ******************************************************************************/
PLIbook_ScientificALU_calltf(char *user_data)
{
vpiHandle instance_h, arg_itr;
s_vpi_value value_s;
s_vpi_time time_s;
s_cb_data cb_data_s;
PLIbook_ALU_data_p ALUdata;

/* allocate storage to hold $scientific_alu argument handles */
ALUdata = (PLIbook_ALU_data_p)malloc(sizeof(PLIbook_ALU_data_s));

/* obtain a handle to the system task instance */
instance_h = vpi_handle(vpiSysTfCall, NULL);

/* obtain handles to system task arguments */
/* compiletf has already verified arguments are correct */
arg_itr = vpi_iterate(vpiArgument, instance_h);
ALUdata->a_h    = vpi_scan(arg_itr); /* 1st arg is a input */
ALUdata->b_h    = vpi_scan(arg_itr); /* 2nd arg is b input */
ALUdata->opcode_h = vpi_scan(arg_itr); /* 3rd arg is opcode input */
ALUdata->result_h = vpi_scan(arg_itr); /* 4th arg is result output */
ALUdata->execp_h  = vpi_scan(arg_itr); /* 5th arg is execp output */
ALUdata->err_h    = vpi_scan(arg_itr); /* 6th arg is error output */
vpi_free_object(arg_itr); /* free iterator--did not scan to null */
```

This code shows the interaction between a Verilog model and a C model, facilitating data exchange and model execution callbacks using Verilog Procedural Interface (VPI).","
value_s.format = vpiIntVal;
vpi_get_value(ALUdata->opcode_h, &value_s);
opcode = value_s.value.integer;

/****** Call the C model ******/
PLIbook_ScientificALU_C_model(&result, &execp, &err, a, b, opcode);

/* Write the C model outputs onto the Verilog signals */
value_s.format = vpiRealVal;
value_s.value.real = result;
vpi_put_value(ALUdata->result_h, &value_s, NULL, vpiNoDelay);

value_s.format = vpiIntVal;
value_s.value.integer = execp;
vpi_put_value(ALUdata->execp_h, &value_s, NULL, vpiNoDelay);

value_s.value.integer = err;
vpi_put_value(ALUdata->err_h, &value_s, NULL, vpiNoDelay);

return(0);
}

/******************************************************************************
 * callback routine: Registers a callback to the C model interface
 * whenever any input to the C model changes value
 ******************************************************************************/
PLIbook_ScientificALU_calltf(char *user_data)
{
vpiHandle instance_h, arg_itr;
s_vpi_value value_s;
s_vpi_time time_s;
s_cb_data cb_data_s;
PLIbook_ALU_data_p ALUdata;

/* allocate storage to hold $scientific_alu argument handles */
ALUdata = (PLIbook_ALU_data_p)malloc(sizeof(PLIbook_ALU_data_s));

/* obtain a handle to the system task instance */
instance_h = vpi_handle(vpiSysTfCall, NULL);

/* obtain handles to system task arguments */
/* compiletf has already verified arguments are correct */
arg_itr = vpi_iterate(vpiArgument, instance_h);
ALUdata->a_h    = vpi_scan(arg_itr); /* 1st arg is a input */
ALUdata->b_h    = vpi_scan(arg_itr); /* 2nd arg is b input */
ALUdata->opcode_h = vpi_scan(arg_itr); /* 3rd arg is opcode input */
ALUdata->result_h = vpi_scan(arg_itr); /* 4th arg is result output */
ALUdata->execp_h  = vpi_scan(arg_itr); /* 5th arg is execp output */
ALUdata->err_h    = vpi_scan(arg_itr); /* 6th arg is error output */
vpi_free_object(arg_itr); /* free iterator--did not scan to null */
","""Excerpt from a book on Verilog showing code for interfacing Verilog with C models using VPI routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p46.jpg,True,"```verilog
property p8;
  @(posedge clk) a |-> b;
endproperty

a8 : assert property(p8);
```","
property p8;
  @(posedge clk) a |-> b;
endproperty

a8 : assert property(p8);
","Caption: ""Explanation and example of an overlapped implication in SystemVerilog Assertions (SVA).""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p525.jpg,True,"```c
tf_putp(0, load_count);
acc_close();
return(0);
}

handle *acc_collect(next_routine, object, count)
handle *next_routine name of any ACC next routine except acc_next_topmod().
handle object reference object for the ACC next routine.
int *count pointer to variable to receive number of objects collected.
```

The provided image includes a snippet of C code related to Verilog PLI (Programming Language Interface) and ACC (Access) routines from a technical document or book.","tp(0, load_count);
acc_close();
return(0);
}

handle *acc_collect(next_routine, object, count)
handle *next_routine name of any ACC next routine except acc_next_topmod().
handle object reference object for the ACC next routine.
int *count pointer to variable to receive number of objects collected.
","""Excerpt from technical documentation detailing the use of the ACC Routine Library for Verilog PLI applications.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p532.jpg,True,"```verilog
rand bit myclk;
always_ff @clk myclk <= !myclk;
```

```verilog
m1: assume_property (@$global_clock $future_gclk(myclk) == ($changing_gclk(clk) ? !myclk : myclk));
```

```verilog
m2: assume_property (@clk ##1 $changed(myclk));
```","
rand bit myclk;
always_ff @clk myclk <= !myclk;


m1: assume_property (@$global_clock $future_gclk(myclk) == ($changing_gclk(clk) ? !myclk : myclk));


m2: assume_property (@clk ##1 $changed(myclk));
","""Understanding Clock-Synchronized Variables in SystemVerilog and their Formal Verification""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p52.jpg,True,"```verilog
property p12;
    @(posedge clk) (a && b) |-> ##[1:3] c;
endproperty

a12 : assert property(p12);
```

There is Verilog code describing a property `p12` using SystemVerilog Assertions (SVA) and the corresponding assertion `a12` that checks this property in the given image.","
property p12;
    @(posedge clk) (a && b) |-> ##[1:3] c;
endproperty

a12 : assert property(p12);
","""Example of a SystemVerilog Assertion (SVA) with a waveform illustration showing property validation over multiple clock cycles.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p258.jpg,True,"The image contains Verilog (SystemVerilog) code. Here's the code provided in the image:

For Figure 6.3 ""Sharing a single random generator"":

```verilog
class Gen1;
    Transaction tr;

    forever @ (int1.cb)
        tr.randomize();
    endclass
```

```verilog
class Gen2;
    Transaction tr1, tr2;

    forever @ (int2.cb)
        tr1.randomize();
        tr2.randomize();
    endclass
```

For Figure 6.4 ""First generator uses additional values"":

```verilog
class Gen1;
    Transaction tra, trb;

    forever @ (int1.cb)
        tra.randomize();
        trb.randomize();
    endclass
```

```verilog
class Gen2;
    Transaction tr1, tr2;

    forever @ (int2.cb)
        tr1.randomize();
        tr2.randomize();
    endclass
```

Please note that the code examples deal with randomization in SystemVerilog, and they are showing how different generators are using random values from a pseudo-random number generator (PRNG).","
class Gen1;
    Transaction tr;

    forever @ (int1.cb)
        tr.randomize();
    endclass


class Gen2;
    Transaction tr1, tr2;

    forever @ (int2.cb)
        tr1.randomize();
        tr2.randomize();
    endclass


class Gen1;
    Transaction tra, trb;

    forever @ (int1.cb)
        tra.randomize();
        trb.randomize();
    endclass


class Gen2;
    Transaction tr1, tr2;

    forever @ (int2.cb)
        tr1.randomize();
        tr2.randomize();
    endclass
","Caption: ""Illustrations showing the consequences of sharing a single pseudorandom number generator (PRNG) between multiple stimulus generators in Verilog, highlighting potential random value consumption issues.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p243.jpg,True,"The image contains an excerpt from a book discussing ""Synchronizing to Verilog Simulations Using VPI Callbacks."" It shows a section of code written in the C programming language, interfacing with a Verilog simulator via the Verilog Procedural Interface (VPI). Here is the code from the image:

```c
/* check that there is only 1 system task argument */
arg_handle = vpi_scan(arg_iterator);
if (arg_handle != NULL) {
    vpi_printf(""ERROR: $my_monitor can only have 1 argument\n"");
    vpi_free_object(arg_iterator); /* free iterator memory */
    tf_dofinish(); /* abort simulation */
    return(0);
}
return(0);
}

/***********************************************************************
 * calltf application
 ***********************************************************************/
PLIbook_MyMonitor_calltf(char *user_data)
{
    vpiHandle    sysTf_h, arg_itr, mod_h, net_itr, net_h;
    s_vpi_time   time_s;
    s_vpi_value  value_s;
    s_cb_data    cb_data_s;
    char         *net_name_temp, *net_name_keep;

    /* setup value change callback options */
    time_s.type      = vpiScaledRealTime;
    value_s.format   = vpiBinStrVal;

    cb_data_s.reason = cbValueChange;
    cb_data_s.cb_rtn = PLIbook_MyMonitor_callback;
    cb_data_s.time   = &time_s;
    cb_data_s.value  = &value_s;

    /* obtain a handle to the system task instance */
    sysTf_h = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handle to system task argument */
    /* compiletf has already verified only 1 arg with correct type */
    arg_itr = vpi_iterate(vpiArgument, sysTf_h);
    mod_h = vpi_scan(arg_itr);
    vpi_free_object(arg_itr); /* free iterator--did not scan to null */
    
    /* add value change callback for each net in module named in tfarg */
    vpi_printf(""\nAdding monitors to all nets in module %s:\n\n"", 
               vpi_get_str(vpiDefName, mod_h));

    net_itr = vpi_iterate(vpiNet, mod_h);
    while ((net_h = vpi_scan(net_itr)) != NULL) {
        net_name_temp = vpi_get_str(vpiFullName, net_h);
        net_name_keep = malloc(strlen(net_name_temp)+1);
        strcpy(net_name_keep, net_name_temp);
        cb_data_s.obj = net_h;
        cb_data_s.user_data = net_name_keep;
        vpi_register_cb(&cb_data_s);
    }
}
```

This code is designed to set up a callback in a Verilog simulation that will trigger whenever a value changes on a specified net. It reads the argument passed to the system task, sets up the callback structure, and iterates over all nets in a given module to add the value change callback to each net. The callback function itself is not provided in this excerpt.","eck that there is only 1 system task argument */
arg_handle = vpi_scan(arg_iterator);
if (arg_handle != NULL) {
    vpi_printf(""ERROR: $my_monitor can only have 1 argument\n"");
    vpi_free_object(arg_iterator); /* free iterator memory */
    tf_dofinish(); /* abort simulation */
    return(0);
}
return(0);
}

/***********************************************************************
 * calltf application
 ***********************************************************************/
PLIbook_MyMonitor_calltf(char *user_data)
{
    vpiHandle    sysTf_h, arg_itr, mod_h, net_itr, net_h;
    s_vpi_time   time_s;
    s_vpi_value  value_s;
    s_cb_data    cb_data_s;
    char         *net_name_temp, *net_name_keep;

    /* setup value change callback options */
    time_s.type      = vpiScaledRealTime;
    value_s.format   = vpiBinStrVal;

    cb_data_s.reason = cbValueChange;
    cb_data_s.cb_rtn = PLIbook_MyMonitor_callback;
    cb_data_s.time   = &time_s;
    cb_data_s.value  = &value_s;

    /* obtain a handle to the system task instance */
    sysTf_h = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handle to system task argument */
    /* compiletf has already verified only 1 arg with correct type */
    arg_itr = vpi_iterate(vpiArgument, sysTf_h);
    mod_h = vpi_scan(arg_itr);
    vpi_free_object(arg_itr); /* free iterator--did not scan to null */
    
    /* add value change callback for each net in module named in tfarg */
    vpi_printf(""\nAdding monitors to all nets in module %s:\n\n"", 
               vpi_get_str(vpiDefName, mod_h));

    net_itr = vpi_iterate(vpiNet, mod_h);
    while ((net_h = vpi_scan(net_itr)) != NULL) {
        net_name_temp = vpi_get_str(vpiFullName, net_h);
        net_name_keep = malloc(strlen(net_name_temp)+1);
        strcpy(net_name_keep, net_name_temp);
        cb_data_s.obj = net_h;
        cb_data_s.user_data = net_name_keep;
        vpi_register_cb(&cb_data_s);
    }
}
",A segment of a textbook discussing and demonstrating how to synchronize to Verilog simulations using VPI callbacks with example code.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p383.jpg,True,"The image shows a page from a document with information on Verilog code. Here is the Verilog code present in the image:

```verilog
module NewInertia #(parameter r_limit = 3, e_limit = 4:5:6)
(output Z, input A, B, C);
...
specify
    // (delays; timing checks) ...
    specparam PATHPULSE$ = r_limit ; // Module default.
    specparam PATHPULSE$B$Z = {~r_limit, ~e_limit };
endspecify
endmodule
```

The text accompanying the code discusses the use of the `specify` block, including full path delay statements, and the special behavior and limitations of the `PATHPULSE` parameter in simulations. It also introduces the `specparam Improved Pessimism` feature along with other relevant reserved `specparam` types like `pulsestyle_onevent`, `pulsestyle_onedetect`, and `showcancelled`.","
module NewInertia #(parameter r_limit = 3, e_limit = 4:5:6)
(output Z, input A, B, C);
...
specify
    // (delays; timing checks) ...
    specparam PATHPULSE$ = r_limit ; // Module default.
    specparam PATHPULSE$B$Z = {~r_limit, ~e_limit };
endspecify
endmodule
",A textbook excerpt discussing Verilog full path delay statements with a sample module declaration and descriptions of 'specparam' configurations for timing checks.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p52.jpg,True,"The image contains Verilog code examples. Here are the code snippets from the image:

Example 2.3:
```verilog
always_comb
logic in1, in2, sel, out;
always_comb
if (sel) out = in2;
else out = in1;
```

Example 2.4:
```verilog
always_latch
logic data, clk, q;
always_latch
if (clk) q = data;
```","
always_comb
logic in1, in2, sel, out;
always_comb
if (sel) out = in2;
else out = in1;


always_latch
logic data, clk, q;
always_latch
if (clk) q = data;
","Caption: Explanation and examples of Verilog procedural blocks: always_comb for combinational logic, always_latch for latched logic, and always_ff for sequential logic.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p270.jpg,True,"The image contains Verilog code in a text format. Here is the code written in the image:

```verilog
initial begin
  $display(""@%0t: start fork...join example"", $time);
  #10 $display(""@%0t: sequential after #10"", $time);
  fork
    $display(""@%0t: parallel start"", $time);
    #50 $display(""@%0t: parallel after #50"", $time);
    #10 $display(""@%0t: parallel after #10"", $time);
    begin
      #30 $display(""@%0t: sequential after #30"", $time);
      #10 $display(""@%0t: sequential after #10"", $time);
    end
  join
  $display(""@%0t: after join"", $time);
  #80 $display(""@%0t: finish after #80"", $time);
end
```

The code is an example demonstrating the use of `fork...join` parallel blocks with an enclosed `begin...end` sequential block, and it is meant to showcase the difference in behavior between parallel and sequential execution in Verilog.","
initial begin
  $display(""@%0t: start fork...join example"", $time);
  #10 $display(""@%0t: sequential after #10"", $time);
  fork
    $display(""@%0t: parallel start"", $time);
    #50 $display(""@%0t: parallel after #50"", $time);
    #10 $display(""@%0t: parallel after #10"", $time);
    begin
      #30 $display(""@%0t: sequential after #30"", $time);
      #10 $display(""@%0t: sequential after #10"", $time);
    end
  join
  $display(""@%0t: after join"", $time);
  #80 $display(""@%0t: finish after #80"", $time);
end
",Example of Verilog fork...join parallel execution and comparison with sequential begin...end blocks.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p153.jpg,True,"The image contains Verilog code. Here is the code transcribed from the image:

```verilog
for(i=0; i<8; i++)
begin
  $fwrite(h_mt, ""WRITE: Master %0d writing to Target %0d = %0d at %0t\n"", m_identity, t_identity, data[7:0], $time);

  @(posedge clk);
end
end

if(!data[8])
begin
  @(posedge clk);
  for(i=0; i<8; i++)
  begin
    $fwrite(h_mt, ""READ: Master %0d reading from Target %0d = %0d at %0t\n"", m_identity, t_identity, data[0], $time);

    @(posedge clk);
  end
end

end

endtask
```

The code seems to be a part of a task which writes transaction logs for read and write operations, checking a conditional statement and acting on a positive edge-triggered clock signal `clk`. Additionally, it formats the log information using the `$fwrite` system task, including the master identity `m_identity`, the target identity `t_identity`, the data being read or written `data`, and a time stamp `$time`.","
for(i=0; i<8; i++)
begin
  $fwrite(h_mt, ""WRITE: Master %0d writing to Target %0d = %0d at %0t\n"", m_identity, t_identity, data[7:0], $time);

  @(posedge clk);
end
end

if(!data[8])
begin
  @(posedge clk);
  for(i=0; i<8; i++)
  begin
    $fwrite(h_mt, ""READ: Master %0d reading from Target %0d = %0d at %0t\n"", m_identity, t_identity, data[0], $time);

    @(posedge clk);
  end
end

end

endtask
",Verilog code snippet demonstrating the implementation of transactions logging for a master-slave communication system.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p67.jpg,True,"The image contains the following Verilog code:

```verilog
`define BLOCKING
`define Awid 32
module ModuleName ( ... I/O's ... );
...
reg[`Awid-1:0] Abus, Zbus; // The ` selects the `Awid value.
...
always@( ... )
begin
  `ifdef BLOCKING
    @reg = Areg | Breg;
  `else
    @reg <= Areg | Breg;
  `endif
end
endmodule
`undef BLOCKING // Use `undefs unless you want these to be seen in subsequently compiled files.
`undef Awid
```

Please note that there are some inaccuracies or placeholders in the code example provided in the image. For instance, the ""@"" sign before ""reg"" is not syntactically correct in Verilog, and would typically be an error. The ""..."" placeholders are meant to indicate other code/context that would be filled in with the specific details relevant to a user's design. Furthermore, the comments after the code clarify that the ""`define"" and ""`undef"" directives are compiler directives in Verilog.","
`define BLOCKING
`define Awid 32
module ModuleName ( ... I/O's ... );
...
reg[`Awid-1:0] Abus, Zbus; // The ` selects the `Awid value.
...
always@( ... )
begin
  `ifdef BLOCKING
    @reg = Areg | Breg;
  `else
    @reg <= Areg | Breg;
  `endif
end
endmodule
`undef BLOCKING // Use `undefs unless you want these to be seen in subsequently compiled files.
`undef Awid
","""Verilog Code Example for Conditional Compilation Using `ifdef` and Macros""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p38.jpg,True,"The image shows a page from a document with text discussing an algorithm and its implementation, but it does not contain any Verilog code. Here is the pseudocode provided for the ""Backward antichain algorithm for testing universality"":

```
Algorithm 1. Backward antichain algorithm for testing universality
Data: a nondeterministic finite automaton A = (Loc, Init, Fin, Σ, δ).

begin
    Start ← {Init};
    F ← {Fin};
    Frontier ← F;
    while (Frontier ≠ Ø) ∧ (Start ∉ Frontier) do
        Frontier ← {q ∈ CP𝜀Pre^A(Frontier) | q ∉ F};
        F ← F ∪ Frontier;
    return (Start ∉ Frontier);
end
```

The rest of the text on the page goes into various details about implementations and evaluations of antichain algorithms, a fully symbolic encoding, a semi-symbolic encoding, and the randomized model, but no actual Verilog code is present.","thm 1. Backward antichain algorithm for testing universality
Data: a nondeterministic finite automaton A = (Loc, Init, Fin, Σ, δ).

begin
    Start ← {Init};
    F ← {Fin};
    Frontier ← F;
    while (Frontier ≠ Ø) ∧ (Start ∉ Frontier) do
        Frontier ← {q ∈ CP𝜀Pre^A(Frontier) | q ∉ F};
        F ← F ∪ Frontier;
    return (Start ∉ Frontier);
end
","The image shows a document page discussing a backward antichain algorithm for testing universality, including a pseudocode representation and an explanation of symbolic implementations used for encoding non-deterministic finite automata (NFAs).",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p73.jpg,True,"```verilog
reg Clock;
...
always@(Clock)
    #10 Clock <= !Clock; // ~Clock also OK.
```

```verilog
reg Clock;
...
initial // This one only for clock generation.
begin
    Clock <= 1'b0;
    forever
        #10 Clock <= !Clock;
end
```","
reg Clock;
...
always@(Clock)
    #10 Clock <= !Clock; // ~Clock also OK.


reg Clock;
...
initial // This one only for clock generation.
begin
    Clock <= 1'b0;
    forever
        #10 Clock <= !Clock;
end
","""Defining Clock Signals in Verilog Using Nonblocking and Blocking Assignments""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p147.jpg,True,"The image contains Verilog code. Here is the code from the image:

```verilog
property p_m2t0w;
// master 2 writing to target 0
@(posedge clk)
$fell (frame2 && irdy2) |-> ##3 ($fell (trdy[0])) ##3 data[8];
endproperty

property p_m3t1r;
// master 3 reading from target 1
@(posedge clk)
$fell (frame3 && irdy3) |-> ##3 ($fell (trdy[1])) ##3 !data[8];
endproperty

property p_m3t1w;
// master 3 writing to target 1
@(posedge clk)
$fell (frame3 && irdy3) |-> ##3 ($fell (trdy[1])) ##3 data[8];
endproperty

property p_m3t0r;
// master 3 reading from target 0
@(posedge clk)
$fell (frame3 && irdy3) |-> ##3 ($fell (trdy[0])) ##3 !data[8];
endproperty

property p_m3t0w;
// master 3 writing to target 0
@(posedge clk)
$fell (frame3 && irdy3) |-> ##3 ($fell (trdy[0])) ##3 data[8];
endproperty
```

Below this code, there is explanatory text and another snippet:

```verilog
c_m1t1r: cover property(p_m1t1r)
begin
```

This Verilog code defines properties representing certain scenarios in a hardware design, using SystemVerilog assertions (SVA) for formal verification. The `cover` statement is used for collecting coverage information on the properties.","
property p_m2t0w;
// master 2 writing to target 0
@(posedge clk)
$fell (frame2 && irdy2) |-> ##3 ($fell (trdy[0])) ##3 data[8];
endproperty

property p_m3t1r;
// master 3 reading from target 1
@(posedge clk)
$fell (frame3 && irdy3) |-> ##3 ($fell (trdy[1])) ##3 !data[8];
endproperty

property p_m3t1w;
// master 3 writing to target 1
@(posedge clk)
$fell (frame3 && irdy3) |-> ##3 ($fell (trdy[1])) ##3 data[8];
endproperty

property p_m3t0r;
// master 3 reading from target 0
@(posedge clk)
$fell (frame3 && irdy3) |-> ##3 ($fell (trdy[0])) ##3 !data[8];
endproperty

property p_m3t0w;
// master 3 writing to target 0
@(posedge clk)
$fell (frame3 && irdy3) |-> ##3 ($fell (trdy[0])) ##3 data[8];
endproperty


c_m1t1r: cover property(p_m1t1r)
begin
","Caption: ""Excerpt from a technical document showing Verilog properties for synchronous bus operations, with instructions on using cover statements for scenario occurrence counting.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p268.jpg,True,"The image contains snippets of Verilog code. Here is the code provided in the image:

```verilog
logic a, b, c, d;
//...
sequence s;
    @(posedge clk) a ##[1:3] b;
endsequence : s
sequence t(x);
    @(posedge clk) x[*5];
endsequence : t
property p(sequence r, untyped y);
    a |-> r(y).triggered;
endproperty
a1: assert property (@(posedge clk) c |-> s.triggered);
a2: assert property (@(posedge clk) c |-> t(d).triggered);
a3: assert property (@(posedge clk) p(t, d));

// ...

logic a, b, c;
//...
a1_illegal: assert property (@(posedge clk)
    c |-> (a ##[1:3] b).triggered);

// ...

logic a, b, c, d;
sequence s1;
    @(posedge clk) a ##1 b;
endsequence : s1
sequence s2;
    @(posedge clk1) a ##1 b;
endsequence : s2
sequence s3;
    @(posedge clk1) a ##1 @(posedge clk1) b ##1 @(posedge clk) c;
endsequence : s3
a1: assert property (@(posedge clk) d |-> s1.triggered);
a2: assert property (@(posedge clk) d |-> s2.triggered);
a3: assert property (@(posedge clk) d |-> s3.triggered);

// ...

sequence s;
    @(posedge clk) a[*1:2] ##1 b[*1:2];
endsequence : s
```

This code includes examples of Verilog constructs, such as `logic` declarations, sequences, properties, and assert statements. These are used to illustrate legal and illegal uses of these constructs according to the context given in the image.","
logic a, b, c, d;
//...
sequence s;
    @(posedge clk) a ##[1:3] b;
endsequence : s
sequence t(x);
    @(posedge clk) x[*5];
endsequence : t
property p(sequence r, untyped y);
    a |-> r(y).triggered;
endproperty
a1: assert property (@(posedge clk) c |-> s.triggered);
a2: assert property (@(posedge clk) c |-> t(d).triggered);
a3: assert property (@(posedge clk) p(t, d));

// ...

logic a, b, c;
//...
a1_illegal: assert property (@(posedge clk)
    c |-> (a ##[1:3] b).triggered);

// ...

logic a, b, c, d;
sequence s1;
    @(posedge clk) a ##1 b;
endsequence : s1
sequence s2;
    @(posedge clk1) a ##1 b;
endsequence : s2
sequence s3;
    @(posedge clk1) a ##1 @(posedge clk1) b ##1 @(posedge clk) c;
endsequence : s3
a1: assert property (@(posedge clk) d |-> s1.triggered);
a2: assert property (@(posedge clk) d |-> s2.triggered);
a3: assert property (@(posedge clk) d |-> s3.triggered);

// ...

sequence s;
    @(posedge clk) a[*1:2] ##1 b[*1:2];
endsequence : s
","Caption: ""Examples of legal and illegal Verilog code for advanced sequence properties in SystemVerilog Assertions (SVA).""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p46.jpg,True,"The image contains Verilog code associated with a concept called a ""checker."" Here is the code:

```verilog
checker mytrig (sequence trig, property prop, event clk);
    a1: assert property (@clk trig |-> prop);
    c1: cover property (@clk trig);
endchecker : mytrig

module m (input logic done, ready, clock, output logic idle);
    ...
    assign idle = done || !ready;
    mytrig check_consistency(done, idle, posedge clock);
endmodule : m
```

Please let me know if you need any further information or help understanding the code.","
checker mytrig (sequence trig, property prop, event clk);
    a1: assert property (@clk trig |-> prop);
    c1: cover property (@clk trig);
endchecker : mytrig

module m (input logic done, ready, clock, output logic idle);
    ...
    assign idle = done || !ready;
    mytrig check_consistency(done, idle, posedge clock);
endmodule : m
","""Example of a Verilog code showing a simple checker module and its use in SystemVerilog Assertion (SVA) and Property Specification Language (PSL) concepts.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p264.jpg,True,"```verilog
class MemTrans;
  rand bit x;
  rand bit [1:0] y;
  constraint c_xy {
    y inside{[x::3]};
    solve x before y;
  }
endclass
```","
class MemTrans;
  rand bit x;
  rand bit [1:0] y;
  constraint c_xy {
    y inside{[x::3]};
    solve x before y;
  }
endclass
","""SystemVerilog Randomization Exercise and a Snippet of Constraint Code""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p83.jpg,True,"```verilog
module dff (q,d,clk,rst,scan_sel,scan_in);
// parameterized module
always @(posedge clk)
    q <= (rst == 1'b1) ? 0 : (scan_sel ? scan_in : d);
endmodule // dff
```

```verilog
// scan stitch include file -- to be included in the top module of the design
assign core.in_p3.in_reg.rb0_s.scan_in[3:0] = {
    core.out_m3.out_reg.rb0_q[29],
    core.in_m2.err_r1.r2.q [4],
    core.in_p3.pkt_info.r1.q [7],
    core.out_p3.out_reg.rb0_q [32]};
assign core.in_p3.in_reg.rb1.scan_in [3] = 
    core.in_p3.in_reg.rb0_s.q [3];
```","
module dff (q,d,clk,rst,scan_sel,scan_in);
// parameterized module
always @(posedge clk)
    q <= (rst == 1'b1) ? 0 : (scan_sel ? scan_in : d);
endmodule // dff


// scan stitch include file -- to be included in the top module of the design
assign core.in_p3.in_reg.rb0_s.scan_in[3:0] = {
    core.out_m3.out_reg.rb0_q[29],
    core.in_m2.err_r1.r2.q [4],
    core.in_p3.pkt_info.r1.q [7],
    core.out_p3.out_reg.rb0_q [32]};
assign core.in_p3.in_reg.rb1.scan_in [3] = 
    core.in_p3.in_reg.rb0_s.q [3];
","Caption: ""The image depicts excerpts from a book on RTL methodology basics, showing a Verilog parameterized module example and a scan stitch include file for back-annotating scan into RTL.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p258.jpg,True,"The image contains two code snippets:

The first one is a SystemVerilog property declaration:

```verilog
property trans_toidle;
    @ (posedge clk) ($rose(state=='REFRESH) |-> ##[5:15] state=='IDLE);
endproperty
assert property (trans_toidle);
```

The second one is a PSL (Property Specification Language) example for functional coverage:

```verilog
cover {state == 'IDLE};
cover {state == 'READ};
cover {state == 'READ1};
cover {state == 'REFRESH};
cover {state == 'STALL};
```","
property trans_toidle;
    @ (posedge clk) ($rose(state=='REFRESH) |-> ##[5:15] state=='IDLE);
endproperty
assert property (trans_toidle);


cover {state == 'IDLE};
cover {state == 'READ};
cover {state == 'READ1};
cover {state == 'REFRESH};
cover {state == 'STALL};
","A textbook page discussing SystemVerilog for checking state transitions and functional coverage for finite state machines (FSMs) in verification, with snippets of example code.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p270.jpg,True,"The image contains a Verilog code fragment. Here is the code written in the image:

```verilog
always @(int1 or int2 or int3 or int4)
  casez ({int1, int2, int3, int4}) // synopsys full_case
    4'b??1: int_req2 = 2'd0;
    4'b?10: int_req2 = 2'd1;
    4'b100: int_req2 = 2'd2;
    default: int_req2 = 2'd3;
  endcase
```","
always @(int1 or int2 or int3 or int4)
  casez ({int1, int2, int3, int4}) // synopsys full_case
    4'b??1: int_req2 = 2'd0;
    4'b?10: int_req2 = 2'd1;
    4'b100: int_req2 = 2'd2;
    default: int_req2 = 2'd3;
  endcase
","""Verilog code example for a 2-bit priority encoder with casez construct for sparse bit sets.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p72.jpg,True,"```verilog
assign not_a = !a;

always_comb begin:bl
  a1: assert (not_a != a)   // immediate
  a2: assert #0 (not_a != a);  //Observed Deferred immediate
  a3: assert final (not_a !=a)  //Final Deferred immediate
end
```
The image contains excerpts from a document discussing ""Deferred Immediate Assertions"" in Verilog, a hardware description language. The code snippet provided is an example of using immediate and deferred assertions within a Verilog always_comb block.","
assign not_a = !a;

always_comb begin:bl
  a1: assert (not_a != a)   // immediate
  a2: assert #0 (not_a != a);  //Observed Deferred immediate
  a3: assert final (not_a !=a)  //Final Deferred immediate
end
","Caption: ""Discussion and example of deferred immediate assertions in Verilog, highlighting the differences between immediate assertions, observed deferred immediate assertions, and final deferred immediate assertions with accompanying code.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p264.jpg,True,"The image contains two snippets of Verilog code. Here they are:

**Example 7-47:**
```verilog
genvar i;
generate for (i=0;i<=3;i = i + 1)
    cover property(@(posedge clk) (select == i));
endgenerate
```

**Example 7-48:**
```verilog
always @(select or data0 or data1 or data2 or data3)
    case(1’b1)
        select[0]: outdata = data0;
        select[1]: outdata = data1;
        select[2]: outdata = data2;
        select[3]: outdata = data3;
    endcase
```

The first example (Example 7-47) demonstrates SystemVerilog functional coverage for a four-to-one encoded multiplexer. The second example (Example 7-48) is a Verilog fragment for a decoded multiplexer example.","
genvar i;
generate for (i=0;i<=3;i = i + 1)
    cover property(@(posedge clk) (select == i));
endgenerate


always @(select or data0 or data1 or data2 or data3)
    case(1’b1)
        select[0]: outdata = data0;
        select[1]: outdata = data1;
        select[2]: outdata = data2;
        select[3]: outdata = data3;
    endcase
","Caption: ""SystemVerilog functional coverage and Verilog code for a decoded multiplexer circuit from an assertion cookbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p54.jpg,True,"The image contains Verilog code. Below is the code as written in the image:

```verilog
module assert_always (ck, reset_n, test_expr);
    input ck, reset_n, test_expr;
    parameter severity_level = 0;
    parameter msg=""ASSERT ALWAYS VIOLATION"";
    `ifdef ASSERT_ON
    integer error_count;
    initial error_count = 0;
    always @(posedge ck) begin
        `ifdef ASSERT_GLOBAL_RESET
        if(`ASSERT_GLOBAL_RESET != `1'b0) begin
        `else
        if(reset_n != `1'b0) begin
        `endif
            if (test_expr != `1'b1) begin
                error_count = error_count + 1;
                `ifdef ASSERT_MAX_REPORT_ERROR
                if (error_count <= `ASSERT_MAX_REPORT_ERROR)
                `endif
                $display(""%s : severity %0d : time %0t: %m"", msg, severity_level, $time);
                if (severity_level == 0) $finish;
            end
        end
    end
    `endif
endmodule // assert_always
```

This code defines a Verilog module named `assert_always`, which is intended to provide an assertion mechanism during simulation to check that `test_expr` remains true at every positive clock edge of the signal `ck`. The severity level and violation message can be configured with parameters, and the code includes preprocessor directives (`ifdef`) to conditionally compile blocks of code based on the defined symbols. The code also includes a counter to track the number of errors (`error_count`). Note that some identifiers are enclosed within backticks and single quotes (`), which means they refer to `define macros, presumably defined elsewhere in the code base.","
module assert_always (ck, reset_n, test_expr);
    input ck, reset_n, test_expr;
    parameter severity_level = 0;
    parameter msg=""ASSERT ALWAYS VIOLATION"";
    `ifdef ASSERT_ON
    integer error_count;
    initial error_count = 0;
    always @(posedge ck) begin
        `ifdef ASSERT_GLOBAL_RESET
        if(`ASSERT_GLOBAL_RESET != `1'b0) begin
        `else
        if(reset_n != `1'b0) begin
        `endif
            if (test_expr != `1'b1) begin
                error_count = error_count + 1;
                `ifdef ASSERT_MAX_REPORT_ERROR
                if (error_count <= `ASSERT_MAX_REPORT_ERROR)
                `endif
                $display(""%s : severity %0d : time %0t: %m"", msg, severity_level, $time);
                if (severity_level == 0) $finish;
            end
        end
    end
    `endif
endmodule // assert_always
",Example Verilog code for an assertion checker using `always` block for simulation.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p727.jpg,True,"The image contains text and code snippets related to the IEEE 1364-1995 TF (Task and Function) Routine Library, which appears to be for the Verilog hardware description language. Here are the visible code snippets:

```c
void tf_asynchron()
void tf_iasynchron(tfintst)
char *tfintst   // pointer to an instance of a system task/function.
```

```c
void tf_clearalldelays()
void tf_iclearalldelays(tfintst)
char *tfintst   // pointer to an instance of a system task/function.
```

```c
int tf_compare_long(low1, high1, low2, high2)
int low1        // lower 32 bits of the first operand.
int high1       // upper 32 bits of the first operand.
int low2        // lower 32 bits of the second operand.
int high2       // upper 32 bits of second operand.
```

```c
int tf_copypvc_flag(n)
int tf_icopypvc_flag(n, tfintst)
int n             // index number of a system task/function argument, or -1.
char *tfintst     // pointer to an instance of a system task/function.
```

```c
void tf_divide_long(low1, high1, low2, high2)
int *low1         // pointer to lower 32 bits of first operand.
int *high1        // pointer to upper 32 bits of first operand.
int low2          // lower 32 bits of second operand.
int high2         // upper 32 bits of second operand.
```

```c
void tf_dofinish()
```

These snippets outline the function prototypes for various task and function routines in Verilog as per the 1995 IEEE standard.","tf_asynchron()
void tf_iasynchron(tfintst)
char *tfintst   // pointer to an instance of a system task/function.

tf_clearalldelays()
void tf_iclearalldelays(tfintst)
char *tfintst   // pointer to an instance of a system task/function.

f_compare_long(low1, high1, low2, high2)
int low1        // lower 32 bits of the first operand.
int high1       // upper 32 bits of the first operand.
int low2        // lower 32 bits of the second operand.
int high2       // upper 32 bits of second operand.

f_copypvc_flag(n)
int tf_icopypvc_flag(n, tfintst)
int n             // index number of a system task/function argument, or -1.
char *tfintst     // pointer to an instance of a system task/function.

tf_divide_long(low1, high1, low2, high2)
int *low1         // pointer to lower 32 bits of first operand.
int *high1        // pointer to upper 32 bits of first operand.
int low2          // lower 32 bits of second operand.
int high2         // upper 32 bits of second operand.

tf_dofinish()
","""Documentation excerpt showing interface for Verilog PLI tasks related to asynchronous operations, delay manipulation, long integer comparison, PVC flag copying, long division, and task finalization.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p222.jpg,True,"The image contains some Verilog code as part of a SystemVerilog property definition. Here's the code excerpt:

```verilog
property checkRead;
  int localID;
  ($rose(read), localID = readID) |=> 
    not (($rose(read) && readID!==localID) [*1:$]) ##0
    ($rose(readAck) && readACKID == localID);
endproperty

baseP: assert property (checkRead) else
  $display($stime,,,""tproperty FAIL"");
```

This SystemVerilog code defines a property `checkRead` that seems to be checking for a protocol where once a 'read' has been issued, another 'read' for the same `readID` cannot be re-issued until a `readAck` with the same ID has returned. The code includes temporal logic to enforce this rule.","
property checkRead;
  int localID;
  ($rose(read), localID = readID) |=> 
    not (($rose(read) && readID!==localID) [*1:$]) ##0
    ($rose(readAck) && readACKID == localID);
endproperty

baseP: assert property (checkRead) else
  $display($stime,,,""tproperty FAIL"");
","Caption: ""Example of Verilog code demonstrating the use of local variables within a property for check conditions in assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p345.jpg,True,"```verilog
initial begin
  clk = 1'b0; test_expr = 4'd15;
  repeat(2) @(posedge clk);
  
  for(i=1; i<17; i++) // timing loop
  begin
    for(j=0; j<16; j++) // logical loop
    begin
      framenn = 1'b0;
      repeat(1) @(posedge clk);
      test_expr = 4'b1101;
      repeat(i) @(posedge clk);
      test_expr = j;
      repeat(1) @(posedge clk);
      framenn = 1'b1;
      repeat(1) @(posedge clk);
      test_expr = 4'b1111;
      repeat(1) @(posedge clk);
    end
  end
  
  repeat(2) @(posedge clk);
  $finish;
end

initial forever clk = #25 ~clk;

endmodule
```","
initial begin
  clk = 1'b0; test_expr = 4'd15;
  repeat(2) @(posedge clk);
  
  for(i=1; i<17; i++) // timing loop
  begin
    for(j=0; j<16; j++) // logical loop
    begin
      framenn = 1'b0;
      repeat(1) @(posedge clk);
      test_expr = 4'b1101;
      repeat(i) @(posedge clk);
      test_expr = j;
      repeat(1) @(posedge clk);
      framenn = 1'b1;
      repeat(1) @(posedge clk);
      test_expr = 4'b1111;
      repeat(1) @(posedge clk);
    end
  end
  
  repeat(2) @(posedge clk);
  $finish;
end

initial forever clk = #25 ~clk;

endmodule
",Verilog testbench code for simulating a PCI Checker with nested timing and logical loops and the corresponding waveform diagram.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p236.jpg,True,"The image contains Verilog code. Here is the written version:

```verilog
initial
begin
  read_enb=1; clk=0;
  @(posedge clk) readStartState=1;
  @(posedge clk) readIDState=1;
  @(posedge clk) @(posedge clk) readDataState=1;
  @(posedge clk) @(posedge clk) readEndState=1;
end

initial $monitor($stime,,""clk=%b"",clk,,
                ""read_enb=%b"",read_enb,, 
                ""readStartState=%b"",readStartState,,
                ""readIDState=%b"",readIDState,,
                ""readDataState=%b"",readDataState,,
                ""readEndState=%b"",readEndState);

always #10 clk=!clk;
endmodule

/*
#   10  clk=1    read_enb=1  readStartState=1    readIDState=0
     readDataState=0 readEndState=0
#   20  clk=0    read_enb=1  readStartState=1    readIDState=0 
     readDataState=0 readEndState=0
#   30  clk=1    read_enb=1  readStartState=1    readIDState=1 
     readDataState=0 readEndState=0
#   40  clk=0    read_enb=1  readStartState=1    readIDState=1 
     readDataState=0 readEndState=0
#   50  clk=1    read_enb=1  readStartState=1    readIDState=1
     readDataState=0 readEndState=0
#   60  clk=0    read_enb=1  readStartState=1    readIDState=1
     readDataState=0 readEndState=0 
#   70  clk=1    read_enb=1  readStartState=1    readIDState=1
     readDataState=1 readEndState=0
#   80  clk=0    read_enb=1  readStartState=1    readIDState=1
     readDataState=1 readEndState=0
#   90  clk=1    read_enb=1  readStartState=1    readIDState=1
     readDataState=1 readEndState=0
# 100  clk=0    read_enb=1  readStartState=1    readIDState=1
     readDataState=1 readEndState=0
# 110  clk=1    read_enb=1  readStartState=1    readIDState=1
     readDataState=1 readEndState=1
# 120  clk=0    read_enb=1  readStartState=1    readIDState=1
     readDataState=1 readEndState=1
# 130  PASS
*/
```

This code segment appears to be a Verilog testbench or excerpt of one, intended for use in simulating digital logic. It shows the use of an `initial` block, a `$monitor` system task to display signals during simulation, an `always` block to generate a clock signal, and timing comments for expected signal transitions to be used alongside simulation.","
initial
begin
  read_enb=1; clk=0;
  @(posedge clk) readStartState=1;
  @(posedge clk) readIDState=1;
  @(posedge clk) @(posedge clk) readDataState=1;
  @(posedge clk) @(posedge clk) readEndState=1;
end

initial $monitor($stime,,""clk=%b"",clk,,
                ""read_enb=%b"",read_enb,, 
                ""readStartState=%b"",readStartState,,
                ""readIDState=%b"",readIDState,,
                ""readDataState=%b"",readDataState,,
                ""readEndState=%b"",readEndState);

always #10 clk=!clk;
endmodule

/*
#   10  clk=1    read_enb=1  readStartState=1    readIDState=0
     readDataState=0 readEndState=0
#   20  clk=0    read_enb=1  readStartState=1    readIDState=0 
     readDataState=0 readEndState=0
#   30  clk=1    read_enb=1  readStartState=1    readIDState=1 
     readDataState=0 readEndState=0
#   40  clk=0    read_enb=1  readStartState=1    readIDState=1 
     readDataState=0 readEndState=0
#   50  clk=1    read_enb=1  readStartState=1    readIDState=1
     readDataState=0 readEndState=0
#   60  clk=0    read_enb=1  readStartState=1    readIDState=1
     readDataState=0 readEndState=0 
#   70  clk=1    read_enb=1  readStartState=1    readIDState=1
     readDataState=1 readEndState=0
#   80  clk=0    read_enb=1  readStartState=1    readIDState=1
     readDataState=1 readEndState=0
#   90  clk=1    read_enb=1  readStartState=1    readIDState=1
     readDataState=1 readEndState=0
# 100  clk=0    read_enb=1  readStartState=1    readIDState=1
     readDataState=1 readEndState=0
# 110  clk=1    read_enb=1  readStartState=1    readIDState=1
     readDataState=1 readEndState=1
# 120  clk=0    read_enb=1  readStartState=1    readIDState=1
     readDataState=1 readEndState=1
# 130  PASS
*/
","""Verilog code snippet showing initial block, clock signal generation, and waveforms for testing a module with a monitor statement.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p338.jpg,True,"The image includes Verilog code contained within an example of `assert_transition`. Here is the code from the image:

```verilog
module counter_09_or_OF (reset_n, clk, sel_09);
input reset_n, clk, sel_09;
output [3:0] count;
reg [3:0] count;

always @(posedge clk)
  if (reset_n==0 || count==4'd9 && sel_09==1'b1)
    count <= 4'd0;
  else
    count <= count + 1;

assert_no_transition #(0,4) valid_count
  (clk, reset_n, count, 4'd9,
   (sel_09 == 1'b0)? 4'd10 : 4'd0);
endmodule
``` 

The code is an example of using assertions for verification in a Verilog module. It defines a counter and utilizes the `assert_no_transition` construct to ensure that certain transitions do not occur under specified conditions.","
module counter_09_or_OF (reset_n, clk, sel_09);
input reset_n, clk, sel_09;
output [3:0] count;
reg [3:0] count;

always @(posedge clk)
  if (reset_n==0 || count==4'd9 && sel_09==1'b1)
    count <= 4'd0;
  else
    count <= count + 1;

assert_no_transition #(0,4) valid_count
  (clk, reset_n, count, 4'd9,
   (sel_09 == 1'b0)? 4'd10 : 4'd0);
endmodule
","Caption: ""Verilog code for assert_transition - Assertion-Based Design example for verifying FSM transitions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p684.jpg,True,"```c
/*
 * all entry must be entered before this line *
 */
{0, 0, 0, 0, 0, 0, 0, 0} /* this must be the last entry */
```
"," all entry must be entered before this line *
 */
{0, 0, 0, 0, 0, 0, 0, 0} /* this must be the last entry */
","An excerpt from ""The Verilog PLI Handbook"" showing an example of a Verilog PLI (Programming Language Interface) application code and discussing the inclusion of PLI applications in the Verilog environment.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p243.jpg,True,"The image contains Verilog code for a module that appears to represent a multiplexer using an if-else statement. Here is the code extracted from the image:

```verilog
module b (p, q, s, w, x, y, z);
    input s;
    input [7:0] w, x, y, z;
    output [7:0] p, q;
    wire s;
    wire [7:0] w, x, y, z;
    reg [7:0] p, q;
    always @ (s or w or x or y or z) begin
        if(s == 1'b1) begin
            p = w;
            q = y;
        end
        else begin
            p = x;
            q = z;
        end
    end
endmodule // b
```

This code defines a Verilog module that takes a single bit select input `s` and four 8-bit inputs `w`, `x`, `y`, and `z`. Depending on the value of `s`, the module assigns different inputs to the 8-bit outputs `p` and `q`.","
module b (p, q, s, w, x, y, z);
    input s;
    input [7:0] w, x, y, z;
    output [7:0] p, q;
    wire s;
    wire [7:0] w, x, y, z;
    reg [7:0] p, q;
    always @ (s or w or x or y or z) begin
        if(s == 1'b1) begin
            p = w;
            q = y;
        end
        else begin
            p = x;
            q = z;
        end
    end
endmodule // b
","Caption: ""Verilog tutorial page showing if-else statement usage for multiplexer logic representation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p395.jpg,True,"The image contains a portion of Verilog code. Here is the text as it appears:

```verilog
module counter (
    input clk, rst_, ld_cnt_, upd_cnt, count_enb,
    input [7:0] data_in,
    output logic [7:0] data_out
);

always @ (posedge clk or negedge rst_)
begin
    if (!rst_)
    begin
        `ifdef check1
        data_out <= 0;
        `endif
    end
    else
    begin 
        //LOAD DATA
        if (!ld_cnt_)
            data_out <= data_in;
        
        //HOLD DATA
        `ifdef check2
        else if (!count_enb)
            data_out <= data_out;
        `endif
    end
```

Please note that the code snippet is incomplete as it ends abruptly and the closing endmodule statement is missing. It is necessary to complete the module with the appropriate logic and final endmodule statement for the code to be functional in Verilog.","
module counter (
    input clk, rst_, ld_cnt_, upd_cnt, count_enb,
    input [7:0] data_in,
    output logic [7:0] data_out
);

always @ (posedge clk or negedge rst_)
begin
    if (!rst_)
    begin
        `ifdef check1
        data_out <= 0;
        `endif
    end
    else
    begin 
        //LOAD DATA
        if (!ld_cnt_)
            data_out <= data_in;
        
        //HOLD DATA
        `ifdef check2
        else if (!count_enb)
            data_out <= data_out;
        `endif
    end
","Caption: ""Verilog RTL code snippet for a simple counter module with input and output definitions and sequential logic to reset, load, or hold data based on input signals.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p173.jpg,True,"```verilog
FindLoops(s1,...,sn)
1 foreach i ∈ {1,...,n}, j < i:
2   if ∃j′≥j,...,sj′′: ∀k ∈ {j,...,j′}, ∃!(sk) = ∃!(sk∧)
3     ∀k ∈ {j,...,i − 1}.sj′′+k−j+1 ∃⇒ sj = sj ∧ s′j = s′j
4     then insert ![sj,...,sj′′;l]
5 return counterexample s1,...,sn with loops
```","
FindLoops(s1,...,sn)
1 foreach i ∈ {1,...,n}, j < i:
2   if ∃j′≥j,...,sj′′: ∀k ∈ {j,...,j′}, ∃!(sk) = ∃!(sk∧)
3     ∀k ∈ {j,...,i − 1}.sj′′+k−j+1 ∃⇒ sj = sj ∧ s′j = s′j
4     then insert ![sj,...,sj′′;l]
5 return counterexample s1,...,sn with loops
","Caption: ""Academic text excerpt discussing the syntax and semantics of abstract counterexamples with loops, and pseudocode for loop detection algorithm.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p381.jpg,True,"The image contains a portion of Verilog code. Here is the code:

```verilog
module test_overlap_nonoverlap;
bit clk, cstart, req, gnt;

always @ (posedge clk)
$display($stime,,, ""clk=%b cstart=%b req=%b gnt=%b"", clk, cstart, req, gnt);

always #10 clk = !clk;

sequence sr1;
    req ##2 gnt;
endsequence

`ifdef overlap
property pr1;
    @(posedge clk) cstart |-> sr1;
endproperty
```

The code snippet appears to be from a document related to learning SystemVerilog Assertions (SVA), specifically dealing with overlap and non-overlap operators.","
module test_overlap_nonoverlap;
bit clk, cstart, req, gnt;

always @ (posedge clk)
$display($stime,,, ""clk=%b cstart=%b req=%b gnt=%b"", clk, cstart, req, gnt);

always #10 clk = !clk;

sequence sr1;
    req ##2 gnt;
endsequence

`ifdef overlap
property pr1;
    @(posedge clk) cstart |-> sr1;
endproperty
","Caption: ""Lab exercise on SystemVerilog Assertions covering overlap and non-overlap operators, with a snippet of testbench code illustrating the usage of sequences and properties in SVA.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p310.jpg,True,"The image includes a Backus-Naur Form (BNF) definition of Verilog code for assertion instantiation as part of the Open Verification Library (OVL) standard definition. Here is the code excerpt:

```verilog
assertion_instantiation ::= assert_identifier
  [parameter_value_assignment] module_instance ;

parameter_value_assignment ::= #(severity_level
  {,other parameter expressions}, options, msg)

module_instance ::= name_of_instance
  [(list_of_module_connections)]

name_of_instance ::= module_instance_identifier

list_of_module_connections ::=
  ordered_port_connection
```

This is not executable code but rather a syntax guideline showing how assertions are instantiated in Verilog using the OVL.","
assertion_instantiation ::= assert_identifier
  [parameter_value_assignment] module_instance ;

parameter_value_assignment ::= #(severity_level
  {,other parameter expressions}, options, msg)

module_instance ::= name_of_instance
  [(list_of_module_connections)]

name_of_instance ::= module_instance_identifier

list_of_module_connections ::=
  ordered_port_connection
","Caption: ""A textbook excerpt on assertion-based design with an illustration of Verilog assertion instantiation syntax outlined by the Open Verification Library (OVL) standard.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p647.jpg,True,"The image contains code related to Verilog simulators, specifically for linking PLI (Programming Language Interface) applications to Verilog simulators. Here is the code:

```c
/* prototypes of the PLI application routines */
extern int PLIbook_hello_calltf(), PLIbook_hello_checktf();

/* the veriusertfs table */
s_tfcell veriusertfs[] =
{
    {usertask,
     0,                       /* user_data value */
     PLIbook_hello_checktf,   /* checktf routine */
     0,                       /* sizetf routine */
     PLIbook_hello_calltf,    /* calltf routine */
     0,                       /* misctf routine */
     ""shello"",                /* system task/function name */
     1                        /* forward reference = true */
    },

    {0} /*** final entry must be 0 ***/
};
```

The second portion of code demonstrates how a function pointer to a PLI routine might be cast to a different type in a C program:

```c
(int (*)())PLIbook_pow_calltf
```

Please note that this example with `PLIbook_pow_calltf` shows how casting can be done in C code, and it doesn’t seem to directly relate to the earlier `PLIbook_hello_calltf` routine.","ototypes of the PLI application routines */
extern int PLIbook_hello_calltf(), PLIbook_hello_checktf();

/* the veriusertfs table */
s_tfcell veriusertfs[] =
{
    {usertask,
     0,                       /* user_data value */
     PLIbook_hello_checktf,   /* checktf routine */
     0,                       /* sizetf routine */
     PLIbook_hello_calltf,    /* calltf routine */
     0,                       /* misctf routine */
     ""shello"",                /* system task/function name */
     1                        /* forward reference = true */
    },

    {0} /*** final entry must be 0 ***/
};

(*)())PLIbook_pow_calltf
","""Example of a Verilog PLI user-defined task using a veriusertfs table and discussion on proper function return types for PLI routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p136.jpg,True,"The image contains Verilog code in snippet form relating to temporal assertions. Here are the code snippets visible in the image:

```verilog
a1: assert property (@(posedge clk)
    req ##1 !ack[*3] |-> req || err);

a2: assert property (@(posedge clk)
    req ##1 !ack[*3] |=> req || err);
```

These are two different temporal assertions in Verilog using SystemVerilog Assertion (SVA) syntax, with the difference being the type of implication: overlapping (|->) and nonoverlapping (|=>), which corresponds to the timing diagrams in the images labeled as Fig. 6.6 and Fig. 6.7 respectively.","
a1: assert property (@(posedge clk)
    req ##1 !ack[*3] |-> req || err);

a2: assert property (@(posedge clk)
    req ##1 !ack[*3] |=> req || err);
","This image shows a textbook page discussing Suffix Implication in Verilog, with examples of overlapping and nonoverlapping implication timing diagrams, and corresponding assert property code snippets.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p122.jpg,True,"The image contains a snippet of textual content from a book or article discussing basic Boolean property connectives related to Verilog or SystemVerilog, specifically discussing logical operators and expressions. However, there is one piece of code present in the example 5.18. Here is the code:

```verilog
initial a1:
  assert property (@(posedge clk) rst && nexttime rst);
```

This assertion checks that the reset signal `rst` must be asserted during the first two cycles of the clock `clk`.","
initial a1:
  assert property (@(posedge clk) rst && nexttime rst);
","""Understanding Basic Boolean Property Connectives and Assertions in Verilog""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p280.jpg,True,"The image contains snippets of text related to Verilog programming concepts, such as library-only operators, operator precedence, system tasks and functions, and compiler directives. It provides examples of how to use certain operators and directives within Verilog code. The following is the Verilog code found in the image:

```verilog
c = a | ( b );  // is generally OK
c = a | b;      // is an error to some tools.
```

Additionally, it includes SystemVerilog tasks and function calls and compiler directives, but not in the form of complete executable code:

- `$display(""text and format specs"",signal,signal, ...);`
- `$finish;`
- `$time // function`
- `$write (""text, format specs"",signal,signal, ...);`

Supported format specs:
- `%b, %d, %h, %o, %s, %t, \n, \t, \\, \"", \%, %m.`

Compiler Directives:
- `include ""<file>""`
- `define <name> <text to comment or end-of-line>`
- `ifdef <name>`
- `else`
- `endif`
- `timescale 1 ns / 10 ps`","
c = a | ( b );  // is generally OK
c = a | b;      // is an error to some tools.
","""Verilog Reference Guide: Operators, System Tasks, and Compiler Directives""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p418.jpg,True,"```verilog
bind dut dut_property dut_bind_inst (
  .pclk(clk),
  .preq(req),
  .pgnt(gnt)
);
```","
bind dut dut_property dut_bind_inst (
  .pclk(clk),
  .preq(req),
  .pgnt(gnt)
);
",Verilog 'bind' construct example with a schematic representation of module binding and signal connections.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p225.jpg,True,"The image contains Verilog code related to SystemVerilog Assertions (SVA) for checking and covering properties of a memory's load mode register. Here's the code in the image:

```verilog
a_tMRD: assert property(p_tMRD);
c_tMRD: cover property(p_tMRD);
```

Further below, there's another block of code:

```verilog
property p_loadmoderegister;
    @(posedge clk)
        (s_loadmoderegister) |->
            (addr == 16'h0022);
endproperty

a_loadmoderegister: 
    assert property(p_loadmoderegister);

c_loadmoderegister:
    cover property(p_loadmoderegister);
```

This code defines a property for checking the load mode register, asserts that property, and creates coverage for that property.","
a_tMRD: assert property(p_tMRD);
c_tMRD: cover property(p_tMRD);


property p_loadmoderegister;
    @(posedge clk)
        (s_loadmoderegister) |->
            (addr == 16'h0022);
endproperty

a_loadmoderegister: 
    assert property(p_loadmoderegister);

c_loadmoderegister:
    cover property(p_loadmoderegister);
","Caption: ""SystemVerilog Assertions (SVA) for Verifying Load Mode Register Values in SDRAM""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p430.jpg,True,"```verilog
//------------------------------
// CHECK # 1. Check that when 'rst_' is asserted (==0) that data_out == 8'b0
//------------------------------
`ifdef check1
property counter_reset;
 @(clk) disable iff (!rst_) (data_out == 8'b0);
endproperty

counter_reset_check: assert property(counter_reset)
 else $display($stime,,, ""t/tCOUNTER RESET CHECK FAIL: rst_= %b data_out=%0d \n"", rst_,data_out);
`endif

//------------------------------
// CHECK # 2. Check that if ld_cnt_ is deasserted (==1) and count_enb is not enabled 
// (==0) that data_out HOLDS it's previous value.
// Disable this property 'iff (!rst')
//------------------------------
`ifdef check2
property counter_hold;
 @(posedge clk) disable iff (!rst_) (!ld_cnt_ & !count_enb) |=> data_out ===
 $past(data_out);
endproperty

counter_hold_check: assert property(counter_hold)
 else $display($stime,,, ""t/tCOUNTER HOLD CHECK FAIL: counter HOLD \n"");
`endif
```

This code snippet is written in Verilog, and it is designed to check properties of a counter circuit. The checks are written using SystemVerilog assertions (SVA). These assertions are common in hardware verification to ensure that certain conditions hold true during simulation.","
//------------------------------
// CHECK # 1. Check that when 'rst_' is asserted (==0) that data_out == 8'b0
//------------------------------
`ifdef check1
property counter_reset;
 @(clk) disable iff (!rst_) (data_out == 8'b0);
endproperty

counter_reset_check: assert property(counter_reset)
 else $display($stime,,, ""t/tCOUNTER RESET CHECK FAIL: rst_= %b data_out=%0d \n"", rst_,data_out);
`endif

//------------------------------
// CHECK # 2. Check that if ld_cnt_ is deasserted (==1) and count_enb is not enabled 
// (==0) that data_out HOLDS it's previous value.
// Disable this property 'iff (!rst')
//------------------------------
`ifdef check2
property counter_hold;
 @(posedge clk) disable iff (!rst_) (!ld_cnt_ & !count_enb) |=> data_out ===
 $past(data_out);
endproperty

counter_hold_check: assert property(counter_hold)
 else $display($stime,,, ""t/tCOUNTER HOLD CHECK FAIL: counter HOLD \n"");
`endif
",Verilog Assertions for Checking Counter Behavior,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p94.jpg,True,"The image contains Verilog code snippets related to assertion-based design. Here are the code excerpts shown in the image:

Example 3-13 OVL assert_next:
```verilog
assert_next my_req_ack (clk, reset_n, req, ack);
```

Example 3-14 OVL assert_next with 3 number of clocks parameter:
```verilog
assert_next #(0,3) my_req_ack (clk, reset_n, req, ack);
```","
assert_next my_req_ack (clk, reset_n, req, ack);


assert_next #(0,3) my_req_ack (clk, reset_n, req, ack);
","""Examples of using the Accellera OVL assert_next monitor in Verilog for assertion-based design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p106.jpg,True,"The image contains a segment of a book or document that describes string manipulations in Verilog. There is code on the page, which I will transcribe below:

```verilog
string s;

initial begin
    s = ""IEEE "";
    $display(s.getc(0));          // Display: 73, ASCII value of 'I'
    $display(s.tolower());        // Display: 'ieee '
    
    s.putc(s.len()-1, ""_"");       // change ' ' -> '_'
    s = {s, ""1800""};              // ""IEEE_1800""

    $display(s.substr(2, 5));     // Display: EE-1

    // Create temporary string, note format
    my_log($sformatf(""%s %5d"", s, 42));
end

function void my_log(string message);
    // Print a message to a log
    $display(""%0t: %s"", $time, message);
endfunction
```

This code example demonstrates various string operations in Verilog such as character retrieval, case conversion, character replacement, string concatenation, substring extraction, and custom logging with string formatting.","
string s;

initial begin
    s = ""IEEE "";
    $display(s.getc(0));          // Display: 73, ASCII value of 'I'
    $display(s.tolower());        // Display: 'ieee '
    
    s.putc(s.len()-1, ""_"");       // change ' ' -> '_'
    s = {s, ""1800""};              // ""IEEE_1800""

    $display(s.substr(2, 5));     // Display: EE-1

    // Create temporary string, note format
    my_log($sformatf(""%s %5d"", s, 42));
end

function void my_log(string message);
    // Print a message to a log
    $display(""%0t: %s"", $time, message);
endfunction
",Sample Verilog code demonstrating string manipulation and custom logging function using SystemVerilog syntax.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p231.jpg,True,"The image contains Verilog code pertaining to assertions and properties for memories in SystemVerilog Assertion (SVA). Here's the code written in the image:

```
c_trp: assert property (p_tRP);

SDRAM_chk9: tRAS, active to precharge must occur between tRASmin
(5 clock cycles) to tRASmax (12000 clock cycles).

The active command (enables the rows) to the precharge command (de-
activates the rows) cannot happen within the “tRASmin” cycles and should
happen within “tRASmax” cycles.

property p_tRAS_not;
  @(posedge clk)
    `s_active |-> not ##[0: (tRAS_min - 1)] `s_precharge;
endproperty

property p_tRas;
  @(posedge clk)
    `s_active |-> ##[tRAS_min:tRAS_max] `s_precharge;
endproperty

a_tRAS_not: assert property (p_tRAS_not);
a_tRAS: assert property (p_tRAS);
c_tRAS: cover property (p_tRAS);
```

This code snippet is for defining timing constraints and ensuring the correctness of memory access operations using SystemVerilog assertions."," assert property (p_tRP);

SDRAM_chk9: tRAS, active to precharge must occur between tRASmin
(5 clock cycles) to tRASmax (12000 clock cycles).

The active command (enables the rows) to the precharge command (de-
activates the rows) cannot happen within the “tRASmin” cycles and should
happen within “tRASmax” cycles.

property p_tRAS_not;
  @(posedge clk)
    `s_active |-> not ##[0: (tRAS_min - 1)] `s_precharge;
endproperty

property p_tRas;
  @(posedge clk)
    `s_active |-> ##[tRAS_min:tRAS_max] `s_precharge;
endproperty

a_tRAS_not: assert property (p_tRAS_not);
a_tRAS: assert property (p_tRAS);
c_tRAS: cover property (p_tRAS);
","""SystemVerilog Assertions for Timing Constraints in Memory Operations""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p342.jpg,True,"```verilog
$sassertcontrol ( control_type [ , [ assertion_type ] [ , [ directive_type ] [ , [ levels ] [ , list_of_scopes_or_assertions ] ] ] ] ) ;
```

This is the Verilog code presented in the image. It shows the syntax for the `$sassertcontrol` system task in Verilog.","
$sassertcontrol ( control_type [ , [ assertion_type ] [ , [ directive_type ] [ , [ levels ] [ , list_of_scopes_or_assertions ] ] ] ] ) ;
","""Overview of the `$assertcontrol` system task in Verilog for managing the behavior of assertions and related constructs.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p491.jpg,True,"```verilog
a1: assert property (@clk !a);
a2: assert property (@clk not a);
initial a3: assert property (@clk !a);
initial a4: assert property (@clk not a);
```
These are the lines of Verilog code found in the image.","
a1: assert property (@clk !a);
a2: assert property (@clk not a);
initial a3: assert property (@clk !a);
initial a4: assert property (@clk not a);
","Caption: ""Understanding Weak and Strong Operators in Verilog Assertions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p489.jpg,True,"The image includes multiple snippets of code. Here they are:

SystemVerilog code snippet:
```verilog
import ""DPI-C"" function int call_perl(string s);

program automatic perl_test;
  int ret_val;
  string script;

  initial begin
    $value$plusargs(""script=%s"", script);
    $display(""SV: Running '%0s'"", script);
    ret_val = call_perl(script);
    $display(""SV: Perl script returned %0d"", ret_val );
  end
endprogram : perl_test
```

C wrapper code snippet for Perl script:
```c
#include <svdpi.h>
#include <stdlib.h>
#include <wait.h>

int call_perl(const char* command) {
  int result = system(command);
  return WEXITSTATUS(result);
}
```

Perl script snippet:
```perl
#!/usr/local/bin/perl
print ""Perl: Hello world!\n"";
exit (3)
```

The image also refers to running a Unix command in Sample 12.54, but that command is not shown in the image provided.","
import ""DPI-C"" function int call_perl(string s);

program automatic perl_test;
  int ret_val;
  string script;

  initial begin
    $value$plusargs(""script=%s"", script);
    $display(""SV: Running '%0s'"", script);
    ret_val = call_perl(script);
    $display(""SV: Perl script returned %0d"", ret_val );
  end
endprogram : perl_test

ude <svdpi.h>
#include <stdlib.h>
#include <wait.h>

int call_perl(const char* command) {
  int result = system(command);
  return WEXITSTATUS(result);
}

/usr/local/bin/perl
print ""Perl: Hello world!\n"";
exit (3)
",Sample code demonstrating the interfacing of SystemVerilog with C for running a Perl script.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p492.jpg,True,"The image contains a snippet of text from ""The Verilog PLI Handbook, Part Two"" that discusses Verilog Programming Language Interface (PLI) and Application Control Interface (ACC). There is a line of code in the document:

```verilog
acc_configure(accDisplayWarnings, ""true"");
``` 

This line of code is an example of how to enable ACC warning messages in a Verilog PLI application using the `acc_configure` routine.","
acc_configure(accDisplayWarnings, ""true"");
","Caption: This image displays an excerpt from ""The Verilog PLI Handbook,"" discussing the usage of ACC (access) routines in Verilog, with a focus on configuring warning messages and the introduction to using ACC object diagrams.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p197.jpg,True,"The image contains Verilog code related to system functions and tasks. Here is the code transcribed from the image:

```verilog
module assertion_control(input reset_, machinecheck_exception,
                         machinecheck_ISR_return );

  always @(reset_) begin
    if (reset_ == 1'b0) Sassertkill(0, top.pcim.top.axim);
    else Sasserton(0, top.pcim.top.axim);
    // reset_ == 1'b0 Sassertkill(0, top);
  end

  always @(machinecheck_exception)
    Sassertoff(0, top.datamodule.array);

  always @(machinecheck_ISR_return)
    Sasserton(0, top.datamodule.array);

endmodule
```

This code snippet seems to be demonstrating how to control assertions in a Verilog module based on certain conditions, such as reset signals or exception handling signals. It appears in a section of the document titled ""Fig. 9.8 Application Assertion Control.""","
module assertion_control(input reset_, machinecheck_exception,
                         machinecheck_ISR_return );

  always @(reset_) begin
    if (reset_ == 1'b0) Sassertkill(0, top.pcim.top.axim);
    else Sasserton(0, top.pcim.top.axim);
    // reset_ == 1'b0 Sassertkill(0, top);
  end

  always @(machinecheck_exception)
    Sassertoff(0, top.datamodule.array);

  always @(machinecheck_ISR_return)
    Sasserton(0, top.datamodule.array);

endmodule
","Caption: ""Explanation and example usage of Verilog system tasks for controlling assertion execution – $assertoff, $asserton, and $assertkill.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p106.jpg,True,"The text in the image includes a block of Verilog code. Here is the code provided:

```verilog
always @ (push or pop or cnt or reset_n)
    if (reset_n)
        if ({push, pop} == 2'b01)
            underflow_check: assert (cnt!=0) else
                $error(""underflow error at %m"");
```

This snippet demonstrates a SystemVerilog immediate assertion for checking a queue underflow condition.","
always @ (push or pop or cnt or reset_n)
    if (reset_n)
        if ({push, pop} == 2'b01)
            underflow_check: assert (cnt!=0) else
                $error(""underflow error at %m"");
","""Explaining SystemVerilog Immediate Assertions with Queue Underflow Check Example""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p112.jpg,True,"The image includes code-like pseudocode examples within the text which are used to illustrate certain concepts in assertion-based design, specifically related to Verilog or SystemVerilog. Here are the relevant extracts:

1.
```
a ##1 b [=1] ##1 c
```
The text states this is equivalent to the sequence:
```
a ##1 !b [*0:$] ##1 b ##1 !b [*0:$] ##1 c
```

2.
```
{a; b [=1]; c}
```
This is presented as how the same sequence in PSL 1.0 would be coded.

3.
```
a ##1 b[->1] ##1 c
```
The text states this is equivalent to the sequence:
```
a ##1 !b [*0:$] ##1 b ##1 c
```

4.
```
{a; b[->1]; c}
```
This is presented as how the same sequence in PSL 1.0 would be coded.

These examples are used to explain nonconsecutive exact repetitions and related constructs in assertion languages used for hardware validation. Please note that these are not complete Verilog or SystemVerilog programs, but rather snippets used to demonstrate specific concepts in the context of the provided text.","b [=1] ##1 c

!b [*0:$] ##1 b ##1 !b [*0:$] ##1 c

[=1]; c}

b[->1] ##1 c

!b [*0:$] ##1 b ##1 c

->1]; c}
","Caption: ""Explanation and example of nonconsecutive exact repetitions in Verilog code, as described in a section from a document on Assertion-Based Design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p183.jpg,True,"The image contains Verilog code, specifically SystemVerilog properties and sequences used for formal verification or simulation assertion checks. Here are the code excerpts from the image:

```verilog
sequence bc;
    (##[0:$] {b && c}, $display($stime,,""FIRST MATCH b&&c""));
endsequence

property fms;
    first_match(bc) |-> $rose(a);
endproperty

baseP: assert property(@(posedge clk) |-> fms) else gotoFail;
coverP: cover property(@(posedge clk) |-> fms) gotoPass;

sequence busIdleCheck;
    (##[2:$] {frame_ && irdy_});
endsequence

property fms;
    @(posedge clk) first_match(busIdleCheck) |-> (state == busIdle);
endproperty

baseP: assert property (fms);
```

The sequences and properties are used to define conditions on signals (`b`, `c`, and `a` in the first example; `frame_`, `irdy_`, and `state` in the second example) and to capture specific occurrences or patterns (like `first_match`) which should be checked every clock cycle (`posedge clk`) in a digital design under test.","
sequence bc;
    (##[0:$] {b && c}, $display($stime,,""FIRST MATCH b&&c""));
endsequence

property fms;
    first_match(bc) |-> $rose(a);
endproperty

baseP: assert property(@(posedge clk) |-> fms) else gotoFail;
coverP: cover property(@(posedge clk) |-> fms) gotoPass;

sequence busIdleCheck;
    (##[2:$] {frame_ && irdy_});
endsequence

property fms;
    @(posedge clk) first_match(busIdleCheck) |-> (state == busIdle);
endproperty

baseP: assert property (fms);
","Caption: ""Examples and explanations of using first_match in sequence and property constructs in Verilog for hardware assertion checking.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p136.jpg,True,"```verilog
logic [7:0] fifties [0:3] = '{50,100,150,200}; // 8-bit array
$display(""fifties.sum is %0d"", fifties.sum); // GOTCHA!
```

This part of the image contains the Verilog code. However, to understand the context and what the image explains, reading the full text is necessary. There's an additional code snippet that shows how to avoid the issue described:

```verilog
$display(""fifties.sum is %0d"", (fifties.sum + 16'd0)); // OK
```","
logic [7:0] fifties [0:3] = '{50,100,150,200}; // 8-bit array
$display(""fifties.sum is %0d"", fifties.sum); // GOTCHA!


$display(""fifties.sum is %0d"", (fifties.sum + 16'd0)); // OK
","Exploration of the array `.sum` method gotcha in Verilog, with an example showing how improper context can lead to incorrect summation, and a solution to ensure the correct sum is calculated.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p323.jpg,True,"```verilog
io_printf(""Module %s has %d nets\n"", module_name, num_nets);

void io_mcdprintf(mcd, format, arg1...arg12)
int mcd                multi-channel descriptor of open files.
char *format           quoted character string of formatted message.
arg1...arg12           arguments to formatted message string.

void tf_warning(format, arg1...arg5)
char *format           quoted character string of formatted message.
arg1...arg5            arguments to formatted message string.

tf_warning(""Reached end-of-file in test vector file %s\n"", file_name);

void tf_error(format, arg1...arg5)
char *format           quoted character string of formatted message.
arg1...arg5            arguments to formatted message string.
```","
io_printf(""Module %s has %d nets\n"", module_name, num_nets);

void io_mcdprintf(mcd, format, arg1...arg12)
int mcd                multi-channel descriptor of open files.
char *format           quoted character string of formatted message.
arg1...arg12           arguments to formatted message string.

void tf_warning(format, arg1...arg5)
char *format           quoted character string of formatted message.
arg1...arg5            arguments to formatted message string.

tf_warning(""Reached end-of-file in test vector file %s\n"", file_name);

void tf_error(format, arg1...arg5)
char *format           quoted character string of formatted message.
arg1...arg5            arguments to formatted message string.
","""Excerpt from The Verilog PLI Handbook detailing the use of I/O and error handling functions in Verilog with C language integration.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p334.jpg,True,"Here is the Verilog code from the image:

```verilog
always @(*) begin: B1
    r11 <= v11;
    if (c1_long) begin
        r12 <= v12 & v13;
        a18: assert property (@(posedge clk) r11 |-> r12);
    end
end
```","
always @(*) begin: B1
    r11 <= v11;
    if (c1_long) begin
        r12 <= v12 & v13;
        a18: assert property (@(posedge clk) r11 |-> r12);
    end
end
","""Understanding Event Semantics in Procedural Concurrent Assertions with a Verilog Code Example""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p338.jpg,True,"The image contains Verilog code. Here it is:

```verilog
Sample 8.28 Test using a callback for error injection

class Driver_cbs_drop extends Driver_cbs;
    virtual task pre_tx(ref Transaction tr, ref bit drop);
        // Randomly drop 1 out of every 100 transactions
        drop = ($urandom_range(0,99) == 0);
    endtask
endclass

program automatic test;
    Environment env;

    initial begin
        env = new();
        env.gen_cfg();
        env.build();
        
        begin  // Create error injection callback
            Driver_cbs_drop dcd = new();
            env.drv.cbs.push_back(dcd); // Put into driver's Q
        end

        env.run();
        env.wrap_up();
    end

endprogram
```","
Sample 8.28 Test using a callback for error injection

class Driver_cbs_drop extends Driver_cbs;
    virtual task pre_tx(ref Transaction tr, ref bit drop);
        // Randomly drop 1 out of every 100 transactions
        drop = ($urandom_range(0,99) == 0);
    endtask
endclass

program automatic test;
    Environment env;

    initial begin
        env = new();
        env.gen_cfg();
        env.build();
        
        begin  // Create error injection callback
            Driver_cbs_drop dcd = new();
            env.drv.cbs.push_back(dcd); // Put into driver's Q
        end

        env.run();
        env.wrap_up();
    end

endprogram
","Caption: ""Example of using a callback in Verilog to randomly drop packets for error injection in a testbench environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p452.jpg,True,"There is a segment of code within the image, specifically a Verilog assertion statement. Here is the code from the image:

```verilog
assert property(en ##1 [y+1] |-> x)
```

This Verilog code asserts a property based on a sequence of events defined by the sequence operator (##) and implication operator (|->). The `[y+1]` part specifies a repetition, which means the event that follows `en` should be true exactly `y+1` times before the implication `x` is checked.","
assert property(en ##1 [y+1] |-> x)
","""Considerations and exercises related to Verilog properties, assertions, and efficiency in simulation and formal verification""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p445.jpg,True,"The image contains partial code related to Verilog Programming Interface (PLI), specifically a C model interface using Task Function (TF) routines. Here is the code present in the image:

```c
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
/**********************************************************************
* callback routine: Turns on asynchronous callbacks to the misctf
* routine whenever an argument to the system task changes value
***********************************************************************/
int PLIbook_ScientificALU_calltf()
{
    tf_asynchon();
    return(0);
}

/**********************************************************************
* misctf routine: Serves as an interface between Verilog simulation
* and the C model. Called whenever the C model inputs change value,
* ignores all changes except a positive edge of clock, on the positive
* edge of clock, reads the input values, and passes the values to the
* C model, and writes the C model outputs into simulation.
***********************************************************************/
```

The rest of the `misctf` routine is not visible in the image. This excerpt of code represents how callbacks can be set up in a Verilog C interface to react to changes in simulation, such as updates to inputs, and it emphasizes the handling of positive clock edges.","ude ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
/**********************************************************************
* callback routine: Turns on asynchronous callbacks to the misctf
* routine whenever an argument to the system task changes value
***********************************************************************/
int PLIbook_ScientificALU_calltf()
{
    tf_asynchon();
    return(0);
}

/**********************************************************************
* misctf routine: Serves as an interface between Verilog simulation
* and the C model. Called whenever the C model inputs change value,
* ignores all changes except a positive edge of clock, on the positive
* edge of clock, reads the input values, and passes the values to the
* C model, and writes the C model outputs into simulation.
***********************************************************************/
","Caption: ""Verilog PLI Handbook excerpt showing an example of sequential logic C model interface using TF routines for Verilog simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p446.jpg,True,"Here's the Verilog code from the image:

```verilog
|-> 
(
  s_eventually [1:18] ack && (ack_tag == tag)
  and
  !(ack && (ack_tag == tag))
);
endproperty
a: assert property (p);
```

```verilog
property p;
logic [3:0] tag;
(req, tag = req_tag)
|-> 
strong
  (!(ack && (ack_tag == tag)) ##1
  ##[1:18] ack && (ack_tag == tag)
  );
endproperty
a: assert property (p);
```

```verilog
property p1;
logic [3:0] tag;
(req, tag = req_tag)
|-> 
s_eventually [1:18] ack && (ack_tag == tag);
endproperty

property p2;
logic [3:0] tag;
@(posedge clk) (req, tag = req_tag)
|-> 
!(ack && (ack_tag == tag));
endproperty
a1: assert property (p1);
a2: assert property (p2);
```

```verilog
property p;
logic [3:0] tag;
(req, tag = req_tag)
|->
(s_eventually [3:18] ack && (ack_tag == tag))
and
(s_always [1:2] !(ack && (ack_tag == tag)));
```

These are properties defining temporal assertions in Verilog, which could be used in formal verification or simulation to check the correct behavior of a design.","
|-> 
(
  s_eventually [1:18] ack && (ack_tag == tag)
  and
  !(ack && (ack_tag == tag))
);
endproperty
a: assert property (p);


property p;
logic [3:0] tag;
(req, tag = req_tag)
|-> 
strong
  (!(ack && (ack_tag == tag)) ##1
  ##[1:18] ack && (ack_tag == tag)
  );
endproperty
a: assert property (p);


property p1;
logic [3:0] tag;
(req, tag = req_tag)
|-> 
s_eventually [1:18] ack && (ack_tag == tag);
endproperty

property p2;
logic [3:0] tag;
@(posedge clk) (req, tag = req_tag)
|-> 
!(ack && (ack_tag == tag));
endproperty
a1: assert property (p1);
a2: assert property (p2);


property p;
logic [3:0] tag;
(req, tag = req_tag)
|->
(s_eventually [3:18] ack && (ack_tag == tag))
and
(s_always [1:2] !(ack && (ack_tag == tag)));
","Caption: ""Examples of Verilog assertion properties for debugging and optimizing formal verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p451.jpg,True,"The image contains C code from ""The Verilog PLI Handbook,"" which is related to a scientific Arithmetic Logic Unit (ALU) C model with latched outputs. Here is the code visible in the image:

```c
/******************************************************************************
* Definition for a structure to store output values when the ALU is
* latched. When enable is 1, the ALU returns the currently calculated
* outputs, and when 0, the ALU returns the latched previous results.
******************************************************************************/
#include <stdio.h>
typedef struct PLIbook_SciALUOutputs *PLIbook_SciALUOutputs_p;
typedef struct PLIbook_SciALUOutputs {
    char *instance_p; /* shows which task instance owns this space */
    double result;    /* stored result of previous operation */
    int excep;        /* exception code */
    int err;          /* error code */
    PLIbook_SciALUOutputs_p next_ALU_outputs; /* next stack location */
} PLIbook_SciALUOutputs_s;

/* declare global stack pointer */
static PLIbook_SciALUOutputs_p ALU_outputs_stack = NULL;

/******************************************************************************
* Model of a Scientific Arithmetic Logic Unit.
* Latched outputs version.
******************************************************************************/
#include <math.h>
#include <errno.h>
void PLIbook_ScientificALU_C_model (
    int enable,                 /* input; 0 = latched */
    double a,                   /* input */
    double b,                   /* input */
    int opcode,                 /* input */
    double *result,             /* output from ALU */
    int *excep,                 /* output; set if result is out of range */
    int *err,                   /* output; set if input is out of range */
    char *instance_p            /* input; pointer to system task instance */
)
```

The image cuts off at this point, so the remainder of the function definition is not visible.","**************************************************************************
* Definition for a structure to store output values when the ALU is
* latched. When enable is 1, the ALU returns the currently calculated
* outputs, and when 0, the ALU returns the latched previous results.
******************************************************************************/
#include <stdio.h>
typedef struct PLIbook_SciALUOutputs *PLIbook_SciALUOutputs_p;
typedef struct PLIbook_SciALUOutputs {
    char *instance_p; /* shows which task instance owns this space */
    double result;    /* stored result of previous operation */
    int excep;        /* exception code */
    int err;          /* error code */
    PLIbook_SciALUOutputs_p next_ALU_outputs; /* next stack location */
} PLIbook_SciALUOutputs_s;

/* declare global stack pointer */
static PLIbook_SciALUOutputs_p ALU_outputs_stack = NULL;

/******************************************************************************
* Model of a Scientific Arithmetic Logic Unit.
* Latched outputs version.
******************************************************************************/
#include <math.h>
#include <errno.h>
void PLIbook_ScientificALU_C_model (
    int enable,                 /* input; 0 = latched */
    double a,                   /* input */
    double b,                   /* input */
    int opcode,                 /* input */
    double *result,             /* output from ALU */
    int *excep,                 /* output; set if result is out of range */
    int *err,                   /* output; set if input is out of range */
    char *instance_p            /* input; pointer to system task instance */
)
","""Verilog PLI Handbook excerpt featuring code for a scientific ALU C model with latched outputs.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p337.jpg,True,"The image contains snippets of code related to Verilog PLI (Programming Language Interface), specifically for reading simulation invocation options. Here are the code snippets as shown:

```c
char *mc_scan_plusargs (plusarg)
char    *plusarg;  /* name of the invocation option. */
```

And the examples provided:

```c
if (mc_scan_plusargs(""PLIbook_verbose""))
    io_printf(""debug: value read from file is %s\n"", vector);
```

```c
if (file_name = mc_scan_plusargs(""file+""))
    io_printf(""Simulation invoked with +file+ name of %s\n"", file_name);
else
    io_printf(""Simulation was not invoked with +file+ \n"");
```

Please note, I've captured the code as text, so it can be copied accurately if needed.","*mc_scan_plusargs (plusarg)
char    *plusarg;  /* name of the invocation option. */

c_scan_plusargs(""PLIbook_verbose""))
    io_printf(""debug: value read from file is %s\n"", vector);

ile_name = mc_scan_plusargs(""file+""))
    io_printf(""Simulation invoked with +file+ name of %s\n"", file_name);
else
    io_printf(""Simulation was not invoked with +file+ \n"");
","Excerpt from ""The Verilog PLI Handbook"" detailing how to read simulation invocation options using Verilog PLI, with example code snippets.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p320.jpg,True,"The image includes Verilog code. Here's the code from the image:

```verilog
module # (parameter BAD) m (
  logic a, b, c, clk, reset, retry, bad
);
  default clocking PCLK @(posedge clk); endclocking
  default disable iff reset;
  property p; disable iff (retry) b |=> c; endproperty
  a0: assert property(a |=> b);
  a1: assert property(disable iff (retry) a |=> b);
  a2: assert property(p);
  a3: assert property(a |=> p);
  generate if (BAD)
```

This code snippet is part of a SystemVerilog Assertion (SVA) exercise involving assertions and properties and how to handle reset and retry conditions.","
module # (parameter BAD) m (
  logic a, b, c, clk, reset, retry, bad
);
  default clocking PCLK @(posedge clk); endclocking
  default disable iff reset;
  property p; disable iff (retry) b |=> c; endproperty
  a0: assert property(a |=> b);
  a1: assert property(disable iff (retry) a |=> b);
  a2: assert property(p);
  a3: assert property(a |=> p);
  generate if (BAD)
","""Verilog Assertions and Waveform for Examining Property Relationships""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p304.jpg,True,"The image contains SystemVerilog code for a basic transactor. Here is the code as written in the image:

```verilog
class Agent;

mailbox #(Transaction) gen2agt, agt2dvr;
Transaction tr;

function new(input mailbox #(Transaction) gen2agt, agt2dvr);
  this.gen2agt = gen2agt;
  this.agt2dvr = agt2dvr;
endfunction

task run();
  forever begin
    gen2agt.get(tr);       // Get transaction from upstream block
    ...                    // Do some processing
    agt2dvr.put(tr);       // Send it to downstream block
  end
endtask

task wrap_up();  // Empty for now
endtask

endclass
```

This code defines an `Agent` class with methods for initializing with two mailboxes, running a loop to get transactions from one mailbox and putting them into another, and a placeholder task called `wrap_up`. This would be used in a hardware verification context.","
class Agent;

mailbox #(Transaction) gen2agt, agt2dvr;
Transaction tr;

function new(input mailbox #(Transaction) gen2agt, agt2dvr);
  this.gen2agt = gen2agt;
  this.agt2dvr = agt2dvr;
endfunction

task run();
  forever begin
    gen2agt.get(tr);       // Get transaction from upstream block
    ...                    // Do some processing
    agt2dvr.put(tr);       // Send it to downstream block
  end
endtask

task wrap_up();  // Empty for now
endtask

endclass
","""Verilog Testbench Structure and Basic Transactor Agent Code Example""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p308.jpg,True,"The image contains text along with several SystemVerilog code snippets. Below are the code snippets from the image:

From section 12.6:
```verilog
1. @(ev1) a |=> @(ev2) b until c.
2. @(ev1) a |=> @(ev2) b until c.
3. not(@(ev1) a) #1 @(ev2) b |=> not(@(ev3) c).
4. @(ev1) (a ##1 @(ev2) b) |=> if (c) @(ev3) d else e.
5. @(ev1) sync_accept_on(a) b until @(ev2) c and nexttime @(ev3) d.
```

From section 12.7:
```verilog
1. (@(ev1) a ##1 b[*]) |=> c.
2. if (a) @(ev1) p else q.
3. @(ev1) (a) p else q.
4. @(ev1) a implies @(ev2) b or c.
5. (@(ev1) a) implies (@(ev2) b) or c.
6. accept_on(a) (@(ev1) b) and strong(c throughout @(ev2) d).
```

From section 12.8:
```verilog
1. @(ev1) a ##1 b[*] |=> c.
2. @(ev1) a ##1 b[*] |=> c.
3. @(ev1) a within @(ev2) b[-1].
4. @(ev1) a within b[-1].
5. assert property(if (a) @(ev1) b else c);.
6. assert property(@(ev1) if (a) b else c);.
7. assert property(@(ev1) a implies (@(ev2) b) or c);.
```

From section 12.9:
```verilog
sequence s_req_ack;
  req ##1 ack;
endsequence
a_triggered: assert property(
  @(posedge dclk)
  dvalid |-> s_req_ack.triggered
);
```

The code snippets are from a textbook or educational source discussing advanced Verilog and SystemVerilog concepts related to clocking and assertions.","
1. @(ev1) a |=> @(ev2) b until c.
2. @(ev1) a |=> @(ev2) b until c.
3. not(@(ev1) a) #1 @(ev2) b |=> not(@(ev3) c).
4. @(ev1) (a ##1 @(ev2) b) |=> if (c) @(ev3) d else e.
5. @(ev1) sync_accept_on(a) b until @(ev2) c and nexttime @(ev3) d.


1. (@(ev1) a ##1 b[*]) |=> c.
2. if (a) @(ev1) p else q.
3. @(ev1) (a) p else q.
4. @(ev1) a implies @(ev2) b or c.
5. (@(ev1) a) implies (@(ev2) b) or c.
6. accept_on(a) (@(ev1) b) and strong(c throughout @(ev2) d).


1. @(ev1) a ##1 b[*] |=> c.
2. @(ev1) a ##1 b[*] |=> c.
3. @(ev1) a within @(ev2) b[-1].
4. @(ev1) a within b[-1].
5. assert property(if (a) @(ev1) b else c);.
6. assert property(@(ev1) if (a) b else c);.
7. assert property(@(ev1) a implies (@(ev2) b) or c);.


sequence s_req_ack;
  req ##1 ack;
endsequence
a_triggered: assert property(
  @(posedge dclk)
  dvalid |-> s_req_ack.triggered
);
","A textbook page displaying Verilog code snippets and exercises related to clocking, synchronization, and assertions in digital design.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p479.jpg,True,"The image contains Verilog code snippets. Below is the code extracted from the image:

First code snippet:
```verilog
module top;
    ...
    always @(posedge clock)
    begin: local
        integer i;
        reg local_bus;
        ...
        $show_all_signals;
    end
endmodule
```

Second code snippet (no system task/function arguments):
```verilog
$show_all_signals;
```

Third code snippet (a null system task/function argument):
```verilog
$show_all_signals();
```

Fourth code snippet:
```verilog
module top;
    ...
    addbit i1 (a, b, ci, sum, co); // instance of an adder
    ...
    always @(posedge clock)
        $show_all_signals; // list signals in this module
        $show_all_signals(i1); // list signals in instance i1
    endmodule

module addbit (a, b, ci, sum, co);
    ...
    always @(sum or co)
        $show_all_signals(); // list signals in this module
endmodule
```

Please note that the snippets may not be complete, as indicated by ellipses (""...""), and are intended to demonstrate certain aspects of Verilog syntax and usage.","
module top;
    ...
    always @(posedge clock)
    begin: local
        integer i;
        reg local_bus;
        ...
        $show_all_signals;
    end
endmodule


$show_all_signals;


$show_all_signals();


module top;
    ...
    addbit i1 (a, b, ci, sum, co); // instance of an adder
    ...
    always @(posedge clock)
        $show_all_signals; // list signals in this module
        $show_all_signals(i1); // list signals in instance i1
    endmodule

module addbit (a, b, ci, sum, co);
    ...
    always @(sum or co)
        $show_all_signals(); // list signals in this module
endmodule
",Verilog code examples showing the use of the $show_all_signals system task to list signals in a module.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p154.jpg,True,"The image contains Verilog code within two separate text blocks. Here is the code from both blocks:

First block (Fig. 8.18 Repetition non-consecutive operator—basics):
```verilog
property ab;
  @(posedge clk) a |=> b[=2];
endproperty
```

Second block (Fig. 8.19 Non-consecutive repetition operator—example):
```verilog
property abc;
  @(posedge clk) a |=> b[=2] ##1 c;
endproperty
```","
property ab;
  @(posedge clk) a |=> b[=2];
endproperty


property abc;
  @(posedge clk) a |=> b[=2] ##1 c;
endproperty
","""Examples of Verilog non-consecutive repetition operators in property specifications""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p462.jpg,True,"```verilog
import ""DPI-C"" function chandle counter7_new();
import ""DPI-C"" function void counter7
    (input chandle inst,
     output logic [6:0] out,
     input logic [6:0] in,
     input logic reset, load);
```","
import ""DPI-C"" function chandle counter7_new();
import ""DPI-C"" function void counter7
    (input chandle inst,
     output logic [6:0] out,
     input logic [6:0] in,
     input logic reset, load);
","""Verilog code snippet for a 4-state counter with DPI-C import functionality and how it extends beyond 2-state values.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p140.jpg,True,"The image contains the following piece of code related to Verilog:

```verilog
@(posedge clk) $rose(tagError) |-> ##[1:$] $rose(tErrorBit) ##0 $rose(mCheck);
```

This is a SystemVerilog assertion statement, which is used to check for certain conditions in the verification of digital designs.","
@(posedge clk) $rose(tagError) |-> ##[1:$] $rose(tErrorBit) ##0 $rose(mCheck);
","Caption: ""Figure explaining the use of delay range application in Verilog, depicting how to model uncertainty in the timing of signal assertions using SystemVerilog property specifications.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p476.jpg,True,"The image contains Verilog code. Here it is:

```verilog
typedef struct packed { bit [ 7:0] r, g, b; } RGB_T;
import ""DPI-C"" function void invert(inout RGB_T pstruct);

program automatic test;

class RGB;
  rand bit [ 7:0] r, g, b;
  function void display(input string prefix="""");
    $display(""%sRGB=%2x,%2x,%2x"", prefix, r, g, b);
  endfunction : display

  // Pack the class properties into a struct
  function RGB_T pack();
    pack.r = r; pack.g = g; pack.b = b;
  endfunction : pack

  // Unpack a struct into the class properties
  function void unpack(input RGB_T pstruct);
    r = pstruct.r; g = pstruct.g; b = pstruct.b;
  endfunction : unpack
endclass : RGB

initial begin
  RGB pixel;
  RGB_T pstruct;

  pixel = new;
  repeat (5) begin
    `SV_RAND_CHECK(pixel.randomize()); // Create random pixel
    pixel.display(""\nSV: before "");    // Print it
    pstruct = pixel.pack();            // Convert to a struct
    invert(pstruct);                   // Call C to invert bits
    pixel.unpack(pstruct);             // Unpack struct to class
    pixel.display(""SV: after "");       // Print it
  end
end
endprogram
```

This code is a sample from a textbook that demonstrates how to share composite types (such as structs) between SystemVerilog and C. It includes a `typedef` for a packed struct, a `class` with methods to pack and unpack the struct, and an example `program` that uses these to randomly generate RGB values, display them, invert them using a C function through DPI, and then display them again.","
typedef struct packed { bit [ 7:0] r, g, b; } RGB_T;
import ""DPI-C"" function void invert(inout RGB_T pstruct);

program automatic test;

class RGB;
  rand bit [ 7:0] r, g, b;
  function void display(input string prefix="""");
    $display(""%sRGB=%2x,%2x,%2x"", prefix, r, g, b);
  endfunction : display

  // Pack the class properties into a struct
  function RGB_T pack();
    pack.r = r; pack.g = g; pack.b = b;
  endfunction : pack

  // Unpack a struct into the class properties
  function void unpack(input RGB_T pstruct);
    r = pstruct.r; g = pstruct.g; b = pstruct.b;
  endfunction : unpack
endclass : RGB

initial begin
  RGB pixel;
  RGB_T pstruct;

  pixel = new;
  repeat (5) begin
    `SV_RAND_CHECK(pixel.randomize()); // Create random pixel
    pixel.display(""\nSV: before "");    // Print it
    pstruct = pixel.pack();            // Convert to a struct
    invert(pstruct);                   // Call C to invert bits
    pixel.unpack(pstruct);             // Unpack struct to class
    pixel.display(""SV: after "");       // Print it
  end
end
endprogram
",Verilog Testbench Example Demonstrating the Interaction Between SystemVerilog and C Using DPI-C for RGB Structure Packing and Unpacking.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p310.jpg,True,"The image contains Verilog code. Here is the text extracted from the image:

```verilog
event e1, e2;
task trigger(event local_event, input time wait_time);
    #wait_time;
    ->local_event;
endtask

initial begin
    fork
        trigger(e1, 10ns);
        begin
            wait(e1.triggered());
            $display(""%0t: e1 triggered"", $time);
        end
    join
end

initial begin
    fork
        trigger(e2, 20ns);
        begin
            wait(e2.triggered());
            $display(""%0t: e2 triggered"", $time);
        end
    join
end
```

This code snippet describes a Verilog task named `trigger` and two initial blocks which execute in parallel because of the `fork ... join` construct. The task `trigger` takes an event (`local_event`) and a time (`wait_time`) as arguments, waits for the specified `wait_time`, and then triggers the event. The initial blocks are used to trigger two events (`e1` and `e2`) with delays of 10ns and 20ns respectively. Once an event is triggered, a message is displayed with the current simulation time and which event was triggered.","
event e1, e2;
task trigger(event local_event, input time wait_time);
    #wait_time;
    ->local_event;
endtask

initial begin
    fork
        trigger(e1, 10ns);
        begin
            wait(e1.triggered());
            $display(""%0t: e1 triggered"", $time);
        end
    join
end

initial begin
    fork
        trigger(e2, 20ns);
        begin
            wait(e2.triggered());
            $display(""%0t: e2 triggered"", $time);
        end
    join
end
","Caption: ""Verilog code demonstrating the use of concurrent fork-join blocks and event triggers with delays.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p324.jpg,True,"The image contains Verilog code. Here is the code as it appears in the image:

```verilog
module e1Unit(input logic clk, ...);
  logic i1, i2, d1, dout, out_en;
  always @(posedge clk) begin
    d1 <= i1|i2;
    if (out_en) begin
      dout <= d1;
      a2_1: assert property (nexttime dout == $past(i1|i2, 2));
    end
    else
      a2_2: assert property (nexttime $stable(dout));
  end
  ...
endmodule
```

The code represents a Verilog module with assertions. The `assert property` statements are used to verify certain conditions during simulation.","
module e1Unit(input logic clk, ...);
  logic i1, i2, d1, dout, out_en;
  always @(posedge clk) begin
    d1 <= i1|i2;
    if (out_en) begin
      dout <= d1;
      a2_1: assert property (nexttime dout == $past(i1|i2, 2));
    end
    else
      a2_2: assert property (nexttime $stable(dout));
  end
  ...
endmodule
","""Using assertions in Verilog procedural code to improve code understanding and debugging with an example of concurrent assertion under an enabling condition.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p178.jpg,True,"The image contains multiple snippets of Verilog code. Here is a transcription of the code:

1.
```verilog
sequence ab;
  a ##2 b;
endsequence

sequence cde;
  c ##2 d ##2 e;
endsequence

sequence abcde;
  ab intersect cde;
endsequence

property isect1;
  @(posedge clk) |-> abcde;
endproperty
```

2.
```verilog
`define true 1'b1

property retryCheck;
  @(posedge clk) $rose(Retry) |-> `true[*1:4] intersect
                               (Retry ##[1:5] $rose(dataRead));
endproperty
```

The provided text explains certain aspects of how sequences operate in Verilog and discusses the 'intersect' operator with an application example.","
sequence ab;
  a ##2 b;
endsequence

sequence cde;
  c ##2 d ##2 e;
endsequence

sequence abcde;
  ab intersect cde;
endsequence

property isect1;
  @(posedge clk) |-> abcde;
endproperty


`define true 1'b1

property retryCheck;
  @(posedge clk) $rose(Retry) |-> `true[*1:4] intersect
                               (Retry ##[1:5] $rose(dataRead));
endproperty
",Explaining the Verilog `intersect` operator and its application in temporal property checking.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p455.jpg,True,"Here is the Verilog code from the image:

```verilog
`timescale 1ns / 100ps
module scientific_alu(a_in, b_in, opcode_in, result_out, exception, error);
    output [63:0] result_out;
    output        exception, error;
    input  [63:0] a_in, b_in;
    input  [3:0]  opcode_in;

    wire [63:0] result_out, result_vector;
    wire [63:0] a_in, a_vector;
    wire [63:0] b_in, b_vector;
    wire [3:0]  opcode_in, opcode_vector;
    wire        exception, error;

    reg         exception_reg, error_reg;
    real        a, b, result; // real variables used in this module

    // convert real numbers to/from 64-bit vector port connections
    assign result_vector = $realtobits(result);
    always @(a_vector)    a = $bitstoreal(a_vector);
    always @(b_vector)    b = $bitstoreal(b_vector);

    //call the PLI application which interfaces to the C model
    initial
    $scientific_alu(a, b, opcode_vector, result, exception_reg, error_reg);

    specify
        (a_in, b_in *> result_out, exception, error) = (5.6, 4.7);
        (opcode_in *> result_out, exception, error) = (3.4, 3.8);
    endspecify
endmodule
```

The code snippet is from a book under the heading ""Example 13-9: scientific ALU Verilog shell module with pin-to-pin path delays"" which is an example of a scientific arithmetic logic unit (ALU) expressed in Verilog. It includes details on input/output ports, the wire and reg declarations, real number handling, PLI call, and path delay specifications.","
`timescale 1ns / 100ps
module scientific_alu(a_in, b_in, opcode_in, result_out, exception, error);
    output [63:0] result_out;
    output        exception, error;
    input  [63:0] a_in, b_in;
    input  [3:0]  opcode_in;

    wire [63:0] result_out, result_vector;
    wire [63:0] a_in, a_vector;
    wire [63:0] b_in, b_vector;
    wire [3:0]  opcode_in, opcode_vector;
    wire        exception, error;

    reg         exception_reg, error_reg;
    real        a, b, result; // real variables used in this module

    // convert real numbers to/from 64-bit vector port connections
    assign result_vector = $realtobits(result);
    always @(a_vector)    a = $bitstoreal(a_vector);
    always @(b_vector)    b = $bitstoreal(b_vector);

    //call the PLI application which interfaces to the C model
    initial
    $scientific_alu(a, b, opcode_vector, result, exception_reg, error_reg);

    specify
        (a_in, b_in *> result_out, exception, error) = (5.6, 4.7);
        (opcode_in *> result_out, exception, error) = (3.4, 3.8);
    endspecify
endmodule
","Verilog code snippet for a scientific ALU module with pin-to-pin path delays from ""The Verilog PLI Handbook, Part Two"".",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p441.jpg,True,"Here is the Verilog code from the image:

```verilog
if (tf_typep(ALU_A) != TF_READWRITEREAL)
    tf_error(""$scientific_alu arg 1 must be a real variable\n"");

if (tf_typep(ALU_B) != TF_READWRITEREAL)
    tf_error(""$scientific_alu arg 2 must be a real variable\n"");

if (tf_typep(ALU_OP) != TF_READONLY)
    tf_error(""$scientific_alu arg 3 must be a net\n"");
else if (tf_sizep(ALU_OP) != 4)
    tf_error(""$scientific_alu arg 3 must be a 4-bit vector\n"");

if (tf_typep(ALU_RESULT) != TF_READWRITEREAL)
    tf_error(""$scientific_alu arg 4 must be a real variable\n"");

if (tf_typep(ALU_EXCEPT) != TF_READWRITE)
    tf_error(""$scientific_alu arg 5 must be a reg\n"");
else if (tf_sizep(ALU_EXCEPT) != 1)
    tf_error(""$scientific_alu arg 5 must be scalar\n"");

if (tf_typep(ALU_ERROR) != TF_READWRITE)
    tf_error(""$scientific_alu arg 6 must be a reg\n"");
else if (tf_sizep(ALU_ERROR) != 1)
    tf_error(""$scientific_alu arg 6 must be scalar\n"");

return(0);
}
```

The code snippet includes checks for argument types and sizes, and it uses `tf_error` to report errors when the checks fail. It seems like this code is part of a function or a task in a Verilog PLI (Programming Language Interface) application. The actual function or task implementation that these code checks belong to isn't included in the visible text.","
if (tf_typep(ALU_A) != TF_READWRITEREAL)
    tf_error(""$scientific_alu arg 1 must be a real variable\n"");

if (tf_typep(ALU_B) != TF_READWRITEREAL)
    tf_error(""$scientific_alu arg 2 must be a real variable\n"");

if (tf_typep(ALU_OP) != TF_READONLY)
    tf_error(""$scientific_alu arg 3 must be a net\n"");
else if (tf_sizep(ALU_OP) != 4)
    tf_error(""$scientific_alu arg 3 must be a 4-bit vector\n"");

if (tf_typep(ALU_RESULT) != TF_READWRITEREAL)
    tf_error(""$scientific_alu arg 4 must be a real variable\n"");

if (tf_typep(ALU_EXCEPT) != TF_READWRITE)
    tf_error(""$scientific_alu arg 5 must be a reg\n"");
else if (tf_sizep(ALU_EXCEPT) != 1)
    tf_error(""$scientific_alu arg 5 must be scalar\n"");

if (tf_typep(ALU_ERROR) != TF_READWRITE)
    tf_error(""$scientific_alu arg 6 must be a reg\n"");
else if (tf_sizep(ALU_ERROR) != 1)
    tf_error(""$scientific_alu arg 6 must be scalar\n"");

return(0);
}
","Caption: ""Excerpt from 'The Verilog PLI Handbook' depicting error checking code for a Verilog PLI interface and a section discussing the use of misctf routine in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p330.jpg,True,"Here are the code segments in the image:

Example 14.13:
```verilog
always @(ev) begin
    automatic dataT d = pipeline.pop_front();
    store[ptr] = d;
    a13: assert property (@(posedge clk) store[ptr] == d);
    ptr = next_ptr(ptr);
end
```

Example 14.14:
```verilog
always @(ev) begin
    automatic dataT d = pipeline.pop_front();
    automatic ptrT ptr_copy = ptr;
    store[ptr] = d;
    a14: assert property (@(posedge clk) store[ptr_copy] == d);
    ptr = next_ptr(ptr);
end
```","
always @(ev) begin
    automatic dataT d = pipeline.pop_front();
    store[ptr] = d;
    a13: assert property (@(posedge clk) store[ptr] == d);
    ptr = next_ptr(ptr);
end


always @(ev) begin
    automatic dataT d = pipeline.pop_front();
    automatic ptrT ptr_copy = ptr;
    store[ptr] = d;
    a14: assert property (@(posedge clk) store[ptr_copy] == d);
    ptr = next_ptr(ptr);
end
",Verilog code for demonstrating the use of automatic variables in procedural assertions and addressing a timing problem with static variables.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p327.jpg,True,"```c
if (tf_typep(1) != TF_STRING)
    tf_error(""$read_test_vector arg 1 must be a string\n"");

if (tf_typep(2) != TF_READWRITE)
    tf_error(""$read_test_vector arg 2 must be a reg type\n"");

char *vector;
if (tf_sizep(1) != 1)
    tf_error(""$my_app arg 1 must be scalar\n"");
/* allocate memory for a string the size of TF arg 2 */
vector = malloc(tf_sizep(2) + 1);
```","f_typep(1) != TF_STRING)
    tf_error(""$read_test_vector arg 1 must be a string\n"");

if (tf_typep(2) != TF_READWRITE)
    tf_error(""$read_test_vector arg 2 must be a reg type\n"");

char *vector;
if (tf_sizep(1) != 1)
    tf_error(""$my_app arg 1 must be scalar\n"");
/* allocate memory for a string the size of TF arg 2 */
vector = malloc(tf_sizep(2) + 1);
","Caption: ""Excerpt from the Verilog PLI Handbook detailing the usage of tf_typep and tf_sizep functions in Verilog programming.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p314.jpg,True,"The image contains Verilog code from a document. Here is the code provided in the image:

```verilog
class Transaction;
  rand bit [31:0] src, dst, data[8]; // Random variables
  bit [31:0] csm;                    // Calculated variable

  virtual function void calc_csm();
    csm = src ^ dst ^ data.xor;
  endfunction

  virtual function void display(input string prefix="""");
    $display(""%sTr: src=%h, dst=%h, csm=%h, data=%p"", 
             prefix, src, dst, csm, data);
  endfunction
endclass
```

This code defines a Verilog class named `Transaction` with member variables for source address (`src`), destination address (`dst`), an array of data words (`data`), and a checksum (`csm`). It also includes two virtual functions, `calc_csm()` for calculating the checksum and `display()` for displaying the transaction details.","
class Transaction;
  rand bit [31:0] src, dst, data[8]; // Random variables
  bit [31:0] csm;                    // Calculated variable

  virtual function void calc_csm();
    csm = src ^ dst ^ data.xor;
  endfunction

  virtual function void display(input string prefix="""");
    $display(""%sTr: src=%h, dst=%h, csm=%h, data=%p"", 
             prefix, src, dst, csm, data);
  endfunction
endclass
",Sample Verilog code for a basic transaction class demonstrating inheritance and virtual methods.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p469.jpg,True,"The image contains text and snippets of code related to Verilog and ACC (Application Control Constructs) routines. Here is the code from the image:

```c
char *acc_fetch_name(object)
handle object; /* handle for an object. */

char *acc_fetch_fullname(object)
handle object; /* handle for an object. */

char *acc_fetch_defname(object)
handle object; /* handle for a module or primitive instance. */

/* Read a string and use it immediately: */
char *string_p; /* string pointer only, no storage */
string_p = acc_fetch_name(net_handle);
io_printf(""string_p points to %s\n"", string_p);

/* Read a string and copy it to application-allocated storage for later use: */
char *string_p; /* string pointer only, no storage */
char *string_keep; /* another string pointer */
string_p = acc_fetch_name(net_handle);
string_keep = malloc(strlen(string_p)+1);
strcpy(string, string_p); /* save string for later use */
```

These are function prototypes and examples of how to use them to retrieve names of Verilog objects and to handle strings in a simulation environment where Verilog and the C programming language interface using PLI (Programming Language Interface).","*acc_fetch_name(object)
handle object; /* handle for an object. */

char *acc_fetch_fullname(object)
handle object; /* handle for an object. */

char *acc_fetch_defname(object)
handle object; /* handle for a module or primitive instance. */

/* Read a string and use it immediately: */
char *string_p; /* string pointer only, no storage */
string_p = acc_fetch_name(net_handle);
io_printf(""string_p points to %s\n"", string_p);

/* Read a string and copy it to application-allocated storage for later use: */
char *string_p; /* string pointer only, no storage */
char *string_keep; /* another string pointer */
string_p = acc_fetch_name(net_handle);
string_keep = malloc(strlen(string_p)+1);
strcpy(string, string_p); /* save string for later use */
","Caption: ""Excerpt from a technical document explaining ACC (access) routines for handling Verilog objects, including `acc_fetch_name`, `acc_fetch_fullname`, and `acc_fetch_defname`, with examples provided for reading strings representing logic values in Verilog using Programming Language Interface (PLI).""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p144.jpg,True,"Here is the Verilog code that appears in the image:

```verilog
sequence Sc1;
    a ##1 b[*2:5];
endsequence

property abc;
    @(posedge clk) a |-> Sc1;
endproperty
```

The image also contains some descriptive text related to Verilog sequences and properties, as well as an illustrated example showing how the ""`##1 b[*2:5]`"" part of a sequence works in a timing diagram. There is some commentary text explaining how the repetition range ""`[*m:n]`"" operates and how a sequence fails or passes in certain simulation conditions.","
sequence Sc1;
    a ##1 b[*2:5];
endsequence

property abc;
    @(posedge clk) a |-> Sc1;
endproperty
","""Understanding Consecutive Repetition Range in Verilog Assertions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p466.jpg,True,"The image contains C++ code for a counter class with various methods. Here is the code:

```cpp
class Counter7 {
public:
    Counter7();
    void count();
    void load(const svBitVecVal* i);
    void reset();
    int get();
private:
    unsigned char cnt;
};

Counter7::Counter7() { // Initialize counter
    cnt = 0;
}

void Counter7::count() { // Increment counter
    cnt = cnt + 1;
    cnt &= 0x7F; // Mask upper bit
}

void Counter7::load(const svBitVecVal* i) {
    cnt = *i;
    cnt &= 0x7F; // Mask upper bit
}

void Counter7::reset() {
    cnt = 0;
}

// Get the counter value in a pointer to a svBitVecVal
int Counter7::get() {
    return cnt;
}
```

The comments alongside the code provide a brief explanation of the functionality of each method within the `Counter7` class.","ss Counter7 {
public:
    Counter7();
    void count();
    void load(const svBitVecVal* i);
    void reset();
    int get();
private:
    unsigned char cnt;
};

Counter7::Counter7() { // Initialize counter
    cnt = 0;
}

void Counter7::count() { // Increment counter
    cnt = cnt + 1;
    cnt &= 0x7F; // Mask upper bit
}

void Counter7::load(const svBitVecVal* i) {
    cnt = *i;
    cnt &= 0x7F; // Mask upper bit
}

void Counter7::reset() {
    cnt = 0;
}

// Get the counter value in a pointer to a svBitVecVal
int Counter7::get() {
    return cnt;
}
","""Example of a C++ counter model with methods for communication, intended for interfacing with SystemVerilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p150.jpg,True,"The image contains Verilog code snippets. Here is the code from the image:

```verilog
initial
begin
    read_enb=1; clk=0;
    @(posedge clk) readStartState=1;
    @(posedge clk) @(posedge clk); readIDState=1;
    @(posedge clk) @(posedge clk); readDataState=1;
    @(posedge clk) @(posedge clk); readEndState=1;
end

initial $monitor($stime,,""clk="",clk,
    ""read_enb=%0b"",read_enb,/,
    ""readStartState=%0b"",readStartState,/,
    ""readIDState=%0b"",readIDState,/,
    ""readDataState=%0b"",readDataState,/,
    ""readEndState=%0b"",readEndState);

always #10 clk=~clk;

endmodule

/*
# 0 clk=0 read_enb=1 readStartState=0 readIDState=0 readDataState=0 readEndState=0
# 10 clk=1 read_enb=1 readStartState=1 readIDState=0 readDataState=0 readEndState=0
# 20 clk=0 read_enb=1 readStartState=1 readIDState=0 readDataState=0 readEndState=0
# 30 clk=1 read_enb=1 readStartState=0 readIDState=0 readDataState=0 readEndState=0
# 40 clk=0 read_enb=1 readStartState=1 readIDState=0 readDataState=0 readEndState=0
# 50 clk=1 read_enb=1 readStartState=1 readIDState=1 readDataState=0 readEndState=0
# 60 clk=0 read_enb=1 readStartState=1 readIDState=1 readDataState=0 readEndState=0
# 70 clk=1 read_enb=1 readStartState=1 readIDState=1 readDataState=0 readEndState=0
# 80 clk=0 read_enb=1 readStartState=1 readIDState=1 readDataState=0 readEndState=0
# 90 clk=1 read_enb=1 readStartState=1 readIDState=1 readDataState=1 readEndState=0
# 100 clk=0 read_enb=1 readStartState=1 readIDState=1 readDataState=1 readEndState=0
*/
```
The code above appears to be part of a Verilog simulation testbench. It includes an initial block to set up conditions and trigger events on the rising edge of the clock (`posedge clk`). There is also a monitor to display changes in the signals and a statement that toggles the clock every 10 units of simulation time. The commented section provides a timeline of signal values expected during simulation.","
initial
begin
    read_enb=1; clk=0;
    @(posedge clk) readStartState=1;
    @(posedge clk) @(posedge clk); readIDState=1;
    @(posedge clk) @(posedge clk); readDataState=1;
    @(posedge clk) @(posedge clk); readEndState=1;
end

initial $monitor($stime,,""clk="",clk,
    ""read_enb=%0b"",read_enb,/,
    ""readStartState=%0b"",readStartState,/,
    ""readIDState=%0b"",readIDState,/,
    ""readDataState=%0b"",readDataState,/,
    ""readEndState=%0b"",readEndState);

always #10 clk=~clk;

endmodule

/*
# 0 clk=0 read_enb=1 readStartState=0 readIDState=0 readDataState=0 readEndState=0
# 10 clk=1 read_enb=1 readStartState=1 readIDState=0 readDataState=0 readEndState=0
# 20 clk=0 read_enb=1 readStartState=1 readIDState=0 readDataState=0 readEndState=0
# 30 clk=1 read_enb=1 readStartState=0 readIDState=0 readDataState=0 readEndState=0
# 40 clk=0 read_enb=1 readStartState=1 readIDState=0 readDataState=0 readEndState=0
# 50 clk=1 read_enb=1 readStartState=1 readIDState=1 readDataState=0 readEndState=0
# 60 clk=0 read_enb=1 readStartState=1 readIDState=1 readDataState=0 readEndState=0
# 70 clk=1 read_enb=1 readStartState=1 readIDState=1 readDataState=0 readEndState=0
# 80 clk=0 read_enb=1 readStartState=1 readIDState=1 readDataState=0 readEndState=0
# 90 clk=1 read_enb=1 readStartState=1 readIDState=1 readDataState=1 readEndState=0
# 100 clk=0 read_enb=1 readStartState=1 readIDState=1 readDataState=1 readEndState=0
*/
",Verilog Testbench Code and Signal Timing Diagram,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p300.jpg,True,"The image contains Verilog code in a section titled ""Sample 7.42 Producer–consumer synchronized with an event"". Here is the code from the image:

```verilog
program automatic mbx_evt;
  mailbox #(int) mbx;
  event handshake;

  class Producer;
    task run();
      for (int i=1; i<4; i++) begin
        $display(""Producer: before put(%0d)"", i);
        mbx.put(i);
        @handshake;
        $display(""Producer: after put(%0d)"", i);
      end
    endtask
  endclass : Producer

  class Consumer;
    task run();
      int i;
      repeat (3) begin
        mbx.get(i);
        $display(""Consumer: after get(%0d)"", i);
        ->handshake;
      end
    endtask
  endclass : Consumer
```

This snippet is an example of a producer-consumer model using a mailbox and an event for synchronization in a SystemVerilog program.","
program automatic mbx_evt;
  mailbox #(int) mbx;
  event handshake;

  class Producer;
    task run();
      for (int i=1; i<4; i++) begin
        $display(""Producer: before put(%0d)"", i);
        mbx.put(i);
        @handshake;
        $display(""Producer: after put(%0d)"", i);
      end
    endtask
  endclass : Producer

  class Consumer;
    task run();
      int i;
      repeat (3) begin
        mbx.get(i);
        $display(""Consumer: after get(%0d)"", i);
        ->handshake;
      end
    endtask
  endclass : Consumer
","Caption: ""Verilog example illustrating synchronized threads using a mailbox and event for inter-process communication.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p218.jpg,True,"```verilog
normal: begin
  // On a write:
  if ( {WriteReq,ReadReq}==2'b10 ) // Concatenation.
    begin
      ReadCmdReg = 1'b0; // Disable RAM read.
      WriteCmdReg = 1'b1; // Issue a RAM write command.
      incrWrite; // Call task, which blocks on posedge Clk.
      //
      // Transition rule: Check for a_full:
      if ( ReadCount == WriteCount+1 )
        NextState = a_full;
      else NextState = normal;
    end
  // On a read:
  if ( {WriteReq,ReadReq}==2'b01 ) // Another concatenation.
    begin
      WriteCmdReg = 1'b0; // Disable RAM write.
      ReadCmdReg = 1'b1; // Issue a RAM read.
      incrRead; // Call task, which blocks on posedge Clk.
      //
      // Transition rule: Check for a_empty:
      if ( ReadCount+1 == WriteCount )
        NextState = a_empty;
      else NextState = normal;
    end
end // normal state.
``` 

This is the Verilog code extracted from the provided image.","
normal: begin
  // On a write:
  if ( {WriteReq,ReadReq}==2'b10 ) // Concatenation.
    begin
      ReadCmdReg = 1'b0; // Disable RAM read.
      WriteCmdReg = 1'b1; // Issue a RAM write command.
      incrWrite; // Call task, which blocks on posedge Clk.
      //
      // Transition rule: Check for a_full:
      if ( ReadCount == WriteCount+1 )
        NextState = a_full;
      else NextState = normal;
    end
  // On a read:
  if ( {WriteReq,ReadReq}==2'b01 ) // Another concatenation.
    begin
      WriteCmdReg = 1'b0; // Disable RAM write.
      ReadCmdReg = 1'b1; // Issue a RAM read.
      incrRead; // Call task, which blocks on posedge Clk.
      //
      // Transition rule: Check for a_empty:
      if ( ReadCount+1 == WriteCount )
        NextState = a_empty;
      else NextState = normal;
    end
end // normal state.
","Caption: ""Example of a Verilog code snippet implementing a finite state machine with normal state handling for both read and write operations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p481.jpg,True,"The image contains text discussing Safety and Liveness in the context of assertions and properties relevant to hardware design using Verilog. There are two lines of code provided, representing assertions in a formal verification context:

```verilog
a1: assert property (always a);
a2: assert property (s_eventually a);
```","
a1: assert property (always a);
a2: assert property (s_eventually a);
","Caption: ""A comparison of safety and liveness properties in formal verification with Verilog assertions, discussing the implications of adding assumptions to a model.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p495.jpg,True,"The image contains snippets of Verilog code related to immediate and deferred assertions. Here is the code from the image:

```verilog
always @(posedge clk) begin
    // ...
    if (en) begin
        // ...
        a1: assert #0 ($onehot0({a, b})); 
    end
end

always @(posedge clk) begin
    // ...
    if (en) begin
        // ...
        a1: assert property ($onehot0({a, b}));
    end
end
```

The above code illustrates the syntax for immediate assertions and concurrent assertions in the context of a Verilog hardware description.","
always @(posedge clk) begin
    // ...
    if (en) begin
        // ...
        a1: assert #0 ($onehot0({a, b})); 
    end
end

always @(posedge clk) begin
    // ...
    if (en) begin
        // ...
        a1: assert property ($onehot0({a, b}));
    end
end
","Caption: ""Demonstration of immediate and deferred assertions in Verilog HDL, along with exercises on formal verification concepts and temporal properties in system design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p482.jpg,True,"The image contains a snippet of code written in C, which is used in conjunction with the Verilog Procedural Interface (PLI). Here is the code text:

```c
acc_initialize();
if (tf_nump() == 0)
    module_h = acc_handle_scope(acc_handle_tfinst());
else if (tf_typep(1) == tf_nullparam)
    module_h = acc_handle_scope(acc_handle_tfinst());
else
    module_h = acc_handle_tfarg(1);
io_printf(""\nAt time %s, signals in module %s (%s):\n"",
    tf_strgettime(),
    acc_fetch_fullname(module_h),
    acc_fetch_defname(module_h));
signal_h = null;  /* start with known value for target handle */
while (signal_h = acc_next(signal_types, module_h, signal_h)) {
    io_printf(""  %-13s %-13s value is %s (hex)\n"",
        acc_fetch_type_str(acc_fetch_fulltype(signal_h)),
        acc_fetch_name(signal_h),
        acc_fetch_value(signal_h, ""%h"", null));
}
acc_close();
return(0);
```

This code appears to be part of a larger program that uses the Verilog PLI to interface with Verilog simulations from C. It initializes the PLI, fetches handles to modules and signals, and then prints out signal names, types, and values.","nitialize();
if (tf_nump() == 0)
    module_h = acc_handle_scope(acc_handle_tfinst());
else if (tf_typep(1) == tf_nullparam)
    module_h = acc_handle_scope(acc_handle_tfinst());
else
    module_h = acc_handle_tfarg(1);
io_printf(""\nAt time %s, signals in module %s (%s):\n"",
    tf_strgettime(),
    acc_fetch_fullname(module_h),
    acc_fetch_defname(module_h));
signal_h = null;  /* start with known value for target handle */
while (signal_h = acc_next(signal_types, module_h, signal_h)) {
    io_printf(""  %-13s %-13s value is %s (hex)\n"",
        acc_fetch_type_str(acc_fetch_fulltype(signal_h)),
        acc_fetch_name(signal_h),
        acc_fetch_value(signal_h, ""%h"", null));
}
acc_close();
return(0);
","This image shows an excerpt from ""The Verilog PLI Handbook,"" including a snippet of Verilog PLI C code used to access signal values in a Verilog model and a tip suggesting the use of structured programming for better maintainability.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p132.jpg,True,"The image contains the following Verilog code:

```verilog
j = ++i;                // OK, increment i, then assign result to j
j = (i += 1);           // OK, increment i, then assign result to j

i = 10;
j = --i + ++i; // GOTCHA! multiple operations on same variable
```

And further down:

```verilog
always_comb begin
    temp = --i;        // pre-decrement i, save result in temp
    j = temp1 + i++;   // add temp1 and i, then increment i
end
```

Please note that in the second code snippet, there is a typographical error in the text: ""temp1"" should be ""temp"" based on the context given.","
j = ++i;                // OK, increment i, then assign result to j
j = (i += 1);           // OK, increment i, then assign result to j

i = 10;
j = --i + ++i; // GOTCHA! multiple operations on same variable


always_comb begin
    temp = --i;        // pre-decrement i, save result in temp
    j = temp1 + i++;   // add temp1 and i, then increment i
end
","Caption: ""Understanding Operator Gotchas in SystemVerilog: Avoiding Multiple Variable Modifications in a Single Statement.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p187.jpg,True,"```verilog
property ife;
@(posedge clk) a ##1 (b || c) [-1] |->
  if (b)
    (##1 d)
  else
    (##1 e);
endproperty

base: assert property (ife) else gotoFail;
cover: cover property (ife) gotoPass;
```","
property ife;
@(posedge clk) a ##1 (b || c) [-1] |->
  if (b)
    (##1 d)
  else
    (##1 e);
endproperty

base: assert property (ife) else gotoFail;
cover: cover property (ife) gotoPass;
","Caption: ""Illustration of Verilog conditional properties and their usage in simulations, alongside examples of property assertions and simulation results.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p542.jpg,True,"```verilog
module MyModule (output . . ., input Clk1, Ena);
    . . .
    property CheckEna (Pre, Post); // Declare the property to be asserted.
        (posedge Pre) (Pre=='1'b1) |=> ##[1:7] (Post == '1'b1);
    endproperty
    Clk1_Ena: assert property ( CheckEna(Clk1, Ena) ) // State the assertion.
        else $display(""%m {time=%0d}: %s\n"", 
            $time, ""Ena failed to occur within 7 posedges of Clk1"");
    . . .
    always@(posedge Clk1) // Violation message if no Ena within 7 clocks.
    . . .
endmodule
```","
module MyModule (output . . ., input Clk1, Ena);
    . . .
    property CheckEna (Pre, Post); // Declare the property to be asserted.
        (posedge Pre) (Pre=='1'b1) |=> ##[1:7] (Post == '1'b1);
    endproperty
    Clk1_Ena: assert property ( CheckEna(Clk1, Ena) ) // State the assertion.
        else $display(""%m {time=%0d}: %s\n"", 
            $time, ""Ena failed to occur within 7 posedges of Clk1"");
    . . .
    always@(posedge Clk1) // Violation message if no Ena within 7 clocks.
    . . .
endmodule
",Example of a concurrent assertion in SystemVerilog with an assertion violation message.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p102.jpg,True,"```verilog
assert_window req_ack (clk, reset_n, req, !req, ack) ;
```","
assert_window req_ack (clk, reset_n, req, !req, ack) ;
","Caption: ""Excerpt from a technical document on assertion-based design detailing Verilog OVL event bounded window example and PSL built-in functions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p193.jpg,True,"The image contains two snippets of Verilog code. Here is the text for both of the code segments:

First snippet:
```verilog
property ucheck;
@(posedge clk) bgack |-> not ($isunknown(busgnt));
endproperty
```

Second snippet:
```verilog
property validControl;
@(posedge clk) disable iff (busIdle || rst) adrStrobe |->
not ($isunknown({cbE, cwrtAdr, cwrtData}));
endproperty
```","
property ucheck;
@(posedge clk) bgack |-> not ($isunknown(busgnt));
endproperty


property validControl;
@(posedge clk) disable iff (busIdle || rst) adrStrobe |->
not ($isunknown({cbE, cwrtAdr, cwrtData}));
endproperty
","Caption: ""Verilog Code Examples for SystemVerilog Assertions using $isunknown Function""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p126.jpg,True,"The image contains Verilog code, which I will transcribe below:

First segment:
```verilog
module signed_adder_with_carry_in
(input  logic signed [3:0] a, b,  // signed 4-bit inputs
 input  logic                  ci,  // unsigned 1-bit input
 output logic signed [3:0] sum,     // signed 4-bit output
 output logic                  co); // unsigned 1-bit output
 assign {co,sum} = a + b + ci; // GOTCHA! unsigned 5-bit adder
endmodule
```

Second segment:
```verilog
module signed_adder_with_carry_in
(input  logic signed [3:0] a, b,     // signed 4-bit inputs
 input  logic signed           ci,     // signed 1-bit input
 output logic signed [3:0] sum,     // signed 4-bit output
 output logic                co);    // unsigned 1-bit output

 assign {co, sum} = a + b + ci; // GOTCHA! ci is subtracted
endmodule
```","
module signed_adder_with_carry_in
(input  logic signed [3:0] a, b,  // signed 4-bit inputs
 input  logic                  ci,  // unsigned 1-bit input
 output logic signed [3:0] sum,     // signed 4-bit output
 output logic                  co); // unsigned 1-bit output
 assign {co,sum} = a + b + ci; // GOTCHA! unsigned 5-bit adder
endmodule


module signed_adder_with_carry_in
(input  logic signed [3:0] a, b,     // signed 4-bit inputs
 input  logic signed           ci,     // signed 1-bit input
 output logic signed [3:0] sum,     // signed 4-bit output
 output logic                co);    // unsigned 1-bit output

 assign {co, sum} = a + b + ci; // GOTCHA! ci is subtracted
endmodule
",Verilog Arithmetic Gotchas: Misunderstandings in Signed Adder Operations with Carry Inputs,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p209.jpg,True,"The image contains Verilog code snippets that are examples of how to bind a datapath checker to various stages of a pipeline design using SystemVerilog Assertions (SVA). Here are the code examples provided:

1.
```verilog
bind datapath dp_chk
#(.data_file(""wh2.dat""), .identity(""WH2""))
dpchk4
(reset, clk, dp_enable3, dwltwl1, dwltwl2, ..., dwltwl63, dwltwl64);
```
2.
```verilog
// check that the output of quantization is
// correct

bind datapath dp_chk
#(.data_file(""quantized.dat""),
.identity(""QUANTIZATION"")) dpchk5
(reset, clk, dp_enable4,
do1,do2,...do62,do63,do64);
```
These examples illustrate the usage of the `bind` keyword in Verilog to instantiate a monitoring or checking mechanism at certain points in a hardware design, along with specifying parameters for different instances of the checker.","
bind datapath dp_chk
#(.data_file(""wh2.dat""), .identity(""WH2""))
dpchk4
(reset, clk, dp_enable3, dwltwl1, dwltwl2, ..., dwltwl63, dwltwl64);


// check that the output of quantization is
// correct

bind datapath dp_chk
#(.data_file(""quantized.dat""),
.identity(""QUANTIZATION"")) dpchk5
(reset, clk, dp_enable4,
do1,do2,...do62,do63,do64);
","Caption: ""Example of SVA (SystemVerilog Assertions) for datapath checking in Verilog code with descriptions of the checker's functionality and how it's applied in data-intensive designs.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p34.jpg,True,"The image contains Verilog code within the text. Here is the code excerpt:

```verilog
always @(posedge clock)
    $display(""chip_out = %h"", chip_out);
```

And another code excerpt:

```verilog
always @(posedge clock)
    vector <= $random();
```","
always @(posedge clock)
    $display(""chip_out = %h"", chip_out);


always @(posedge clock)
    vector <= $random();
","""Overview of Verilog Programming Interface (PLI) applications and examples of system tasks and system functions in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p284.jpg,True,"```verilog
module assert_change (clk, reset_n, start_event, test_expr);
parameter severity_level=0;
parameter width=1;
parameter num_cks=1;
parameter flag=0;
parameter msg=""ASSERT CHANGE VIOLATION"";

input clk;
input reset_n;
input start_event;
input [width-1:0] test_expr;

//synopsys translate_off
`ifdef ASSERT_ON
parameter CHANGE_START = 1'b0;
parameter CHANGE_CHECK = 1'b1;
parameter FLAG_IGNORE_NEW_START = 2'b00;
parameter FLAG_RESET_ON_START = 2'b01;
```","
module assert_change (clk, reset_n, start_event, test_expr);
parameter severity_level=0;
parameter width=1;
parameter num_cks=1;
parameter flag=0;
parameter msg=""ASSERT CHANGE VIOLATION"";

input clk;
input reset_n;
input start_event;
input [width-1:0] test_expr;

//synopsys translate_off
`ifdef ASSERT_ON
parameter CHANGE_START = 1'b0;
parameter CHANGE_CHECK = 1'b1;
parameter FLAG_IGNORE_NEW_START = 2'b00;
parameter FLAG_RESET_ON_START = 2'b01;
","""Documentation on a Verilog assert_change monitor module which checks for specified changes in signals during simulation""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p131.jpg,True,"The image contains a snippet of text that includes example code. Here's the code from the image:

```c
vpiHandle systf_handle;

systf_handle = vpi_handle(vpiSysTfCall, NULL);
``` 

This code snippet is demonstrating how to obtain a handle for a system task or function instance using the Verilog Procedural Interface (VPI).","ndle systf_handle;

systf_handle = vpi_handle(vpiSysTfCall, NULL);
","""Object diagram and code snippet for obtaining a handle on system tasks and functions in Verilog using the VPI Routine Library.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p125.jpg,True,"The image contains a snippet of code related to the Verilog Procedural Interface (VPI). Here's the code portion:

```verilog
vpiHandle module_handle, port_handle, port_iterator;

/* add code to obtain a handle for a module */
port_iterator = vpi_iterate(vpiPort, module_handle);
if (port_iterator != NULL) {
    while ((port_handle = vpi_scan(port_iterator)) != NULL) {
        /* process the port handle */
    }
}
``` 

This code is used to iterate over ports of a module in a Verilog simulation using the VPI. The `vpi_iterate` function is called to obtain an iterator for the module's ports, and `vpi_scan` is used within a loop to process each port.","
vpiHandle module_handle, port_handle, port_iterator;

/* add code to obtain a handle for a module */
port_iterator = vpi_iterate(vpiPort, module_handle);
if (port_iterator != NULL) {
    while ((port_handle = vpi_scan(port_iterator)) != NULL) {
        /* process the port handle */
    }
}
","Caption: ""A page from a technical document explaining the usage of the VPI routine library for Verilog, including an example of how to use `vpi_scan` to process Verilog module ports with a provided code snippet.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p132.jpg,True,"The image contains Verilog SystemVerilog Assertion (SVA) code. Here it is:

```verilog
a1: assert property (@(posedge clk) sig ##1 !sig);
```

This code is an example of a property assertion in Verilog that is supposed to check a condition for signal toggling but is incorrectly written as explained in the text.","
a1: assert property (@(posedge clk) sig ##1 !sig);
","Caption: ""Explanation of sequence concatenation and sequence fusion in Verilog, with examples of SystemVerilog assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p408.jpg,True,"The image contains a snippet of Verilog code, which is as follows:

```verilog
initial
begin
    @(negedge clk); reset=1;
    @(negedge clk); reset=0;
end

always @(posedge clk)
    $display(""%stime,,,""clk=%b dValid=%b data=%h dAck=%b"",
        clk, dValid, data, dAck);

endmodule
```

This code appears to be part of a module that includes an initial block for setting a reset sequence and an always block for displaying signals' values at the positive edge of a clock signal defined as `clk`.","
initial
begin
    @(negedge clk); reset=1;
    @(negedge clk); reset=0;
end

always @(posedge clk)
    $display(""%stime,,,""clk=%b dValid=%b data=%h dAck=%b"",
        clk, dValid, data, dAck);

endmodule
","""Example of Verilog code for PCI Read Protocol with an outline of the laboratory exercise including different modules for a PCI system.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p290.jpg,True,"The image contains Verilog code. Here is the code as shown in the image:

```verilog
input test_expr;

//synopsys translate_off
`ifdef ASSERT_ON

parameter FRAME_START = 1'b0;
parameter FRAME_CHECK = 1'b1;
parameter FLAG_IGNORE_NEW_START = 2'b00;
parameter FLAG_RESET_ON_START = 2'b01;
parameter FLAG_ERR_ON_START = 2'b10;

reg r_test_expr;
reg r_state;
reg r_start_event;

initial begin
  r_state=FRAME_START;
  r_start_event = 1'b1;
end

integer num_cks;
integer i;
integer error_count;
initial error_count = 0;

wire start_condition;
wire test_condition;

always @(posedge ck) begin
  r_start_event <= start_event;
  r_test_expr <= test_expr;
end

assign start_condition = (r_start_event == 1'b0)
                         && (start_event == 1'b1);
assign test_condition = (r_test_expr == 1'b0)
                        && (test_expr == 1'b1);

always @(posedge ck) begin
  `ifdef ASSERT_GLOBAL_RESET
  if (ASSERT_GLOBAL_RESET != 1'b0) begin
  `else
  if (reset_h != 0) begin // active low reset
  `endif
    case (r_state)
      FRAME_START:
        if (start_condition == 1'b1) begin
          r_state <= FRAME_CHECK;
```
Please note that the code may extend beyond the visible area in the image and therefore might not be complete.","
input test_expr;

//synopsys translate_off
`ifdef ASSERT_ON

parameter FRAME_START = 1'b0;
parameter FRAME_CHECK = 1'b1;
parameter FLAG_IGNORE_NEW_START = 2'b00;
parameter FLAG_RESET_ON_START = 2'b01;
parameter FLAG_ERR_ON_START = 2'b10;

reg r_test_expr;
reg r_state;
reg r_start_event;

initial begin
  r_state=FRAME_START;
  r_start_event = 1'b1;
end

integer num_cks;
integer i;
integer error_count;
initial error_count = 0;

wire start_condition;
wire test_condition;

always @(posedge ck) begin
  r_start_event <= start_event;
  r_test_expr <= test_expr;
end

assign start_condition = (r_start_event == 1'b0)
                         && (start_event == 1'b1);
assign test_condition = (r_test_expr == 1'b0)
                        && (test_expr == 1'b1);

always @(posedge ck) begin
  `ifdef ASSERT_GLOBAL_RESET
  if (ASSERT_GLOBAL_RESET != 1'b0) begin
  `else
  if (reset_h != 0) begin // active low reset
  `endif
    case (r_state)
      FRAME_START:
        if (start_condition == 1'b1) begin
          r_state <= FRAME_CHECK;
","""Example of Verilog code with parameter definitions and always blocks for synchronous logic design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p643.jpg,True,"```verilog
/* prototypes of PLI application routine names */
int PLIbook_hello_calltf(), PLIbook_hello_compiletf();

void PLIbook_hello_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type        = vpiSysTask;
    tf_data.tfname      = ""$hello"";
    tf_data.calltf      = PLIbook_hello_calltf;
    tf_data.compiletf   = PLIbook_hello_compiletf;
    tf_data.sizetf      = NULL;
    vpi_register_systf(&tf_data);
}

/* prototypes of the PLI application register routines */
extern void PLIbook_hello_register();

void (*vlog_startup_routines[])() =
{
    /*** add user entries here ***/
    PLIbook_hello_register,
    0 /*** final entry must be 0 ***/
};
```","
/* prototypes of PLI application routine names */
int PLIbook_hello_calltf(), PLIbook_hello_compiletf();

void PLIbook_hello_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type        = vpiSysTask;
    tf_data.tfname      = ""$hello"";
    tf_data.calltf      = PLIbook_hello_calltf;
    tf_data.compiletf   = PLIbook_hello_compiletf;
    tf_data.sizetf      = NULL;
    vpi_register_systf(&tf_data);
}

/* prototypes of the PLI application register routines */
extern void PLIbook_hello_register();

void (*vlog_startup_routines[])() =
{
    /*** add user entries here ***/
    PLIbook_hello_register,
    0 /*** final entry must be 0 ***/
};
","""Verilog Procedural Interface (VPI) registration examples for PLI applications in Verilog simulators""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p346.jpg,True,"```verilog
$assertcontrol (VACUOUSOFF, CONCURRENT | EXPECT) ;

$assertcontrol (OFF) ;

$assertcontrol (ON, CONCURRENT_IS_IMMEDIATE | IMMEDIATE, ASSERT | COVER | ASSUME, 0) ;

$assertcontrol (KILL, CONCURRENT, ASSERT, 0) ;

$assertcontrol (LOCK, ALL_ASSERTS, ALL_DIRECTIVES, 0, a1) ;
$assertcontrol (ON); // enable all the assertions except a1
$assertcontrol (UNLOCK, ALL_ASSERTS, ALL_DIRECTIVES, 0, a1) ;
```","
$assertcontrol (VACUOUSOFF, CONCURRENT | EXPECT) ;

$assertcontrol (OFF) ;

$assertcontrol (ON, CONCURRENT_IS_IMMEDIATE | IMMEDIATE, ASSERT | COVER | ASSUME, 0) ;

$assertcontrol (KILL, CONCURRENT, ASSERT, 0) ;

$assertcontrol (LOCK, ALL_ASSERTS, ALL_DIRECTIVES, 0, a1) ;
$assertcontrol (ON); // enable all the assertions except a1
$assertcontrol (UNLOCK, ALL_ASSERTS, ALL_DIRECTIVES, 0, a1) ;
","""Excerpts from a technical document detailing the use of `$assertcontrol` system task in Verilog for controlling assertion levels and behavior in hardware verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p116.jpg,True,"The image contains excerpts from a document with sample Verilog code. Here is the code from the document:

Sample 3.8:
```verilog
task mytask2 (output logic [31:0] x,
              input logic y);
...
endtask
```

Sample 3.9:
```verilog
task t3;
  input a, b;
  logic a, b;
  output [15:0] u, v;
  bit [15:0] u, v;
...
endtask
```

Sample 3.10:
```verilog
task t3(a, b, output bit [15:0] u, v); // Lazy declarations
...
endtask
```","
task mytask2 (output logic [31:0] x,
              input logic y);
...
endtask


task t3;
  input a, b;
  logic a, b;
  output [15:0] u, v;
  bit [15:0] u, v;
...
endtask


task t3(a, b, output bit [15:0] u, v); // Lazy declarations
...
endtask
","The image shows a textbook page discussing routine arguments in SystemVerilog, a hardware description and verification language. It explains C-style argument declarations and argument direction for tasks in Verilog, providing examples of different ways to declare routine arguments with varying levels of brevity and detail.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p84.jpg,True,"```verilog
always (! (en1 & en2)) // enables are always mutually exclusive
```","
always (! (en1 & en2)) // enables are always mutually exclusive
","""Example of a PSL temporal layer property expression in Verilog, discussing mutual exclusivity of enables and their use in assertions for verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p420.jpg,True,"The image contains a snippet of Verilog code. Here is the code:

```verilog
property pr1;
  @(posedge clk) req ##2 gnt;
endproperty
reqGnt: assert property (pr1) $display($stime,,""t:%t %m PASS""); else $display($stime,,""t:%t %m FAIL"");
```

The code defines a property for a SystemVerilog assertion and the corresponding assertion to check that property.","
property pr1;
  @(posedge clk) req ##2 gnt;
endproperty
reqGnt: assert property (pr1) $display($stime,,""t:%t %m PASS""); else $display($stime,,""t:%t %m FAIL"");
",Verilog Assertion Example and Kernel Output Analysis,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p102.jpg,True,"The image contains two snippets of Verilog code. Here is the first snippet:

```verilog
// Create data type for values 0, 1, 2
typedef enum {INIT, DECODE, IDLE} fsmstate_e;
fsmstate_e pstate, nstate; // declare typed variables

initial begin
    case (pstate)
        IDLE: nstate = INIT; // data assignment
        INIT: nstate = DECODE;
        default: nstate = IDLE;
    endcase
    $display(""Next state is %s"",
             nstate.name()); // Display symbolic state name
end
```

Here is the second snippet:

```verilog
typedef enum {INIT, DECODE=2, IDLE} fsmtype_e;
```","
// Create data type for values 0, 1, 2
typedef enum {INIT, DECODE, IDLE} fsmstate_e;
fsmstate_e pstate, nstate; // declare typed variables

initial begin
    case (pstate)
        IDLE: nstate = INIT; // data assignment
        INIT: nstate = DECODE;
        default: nstate = IDLE;
    endcase
    $display(""Next state is %s"",
             nstate.name()); // Display symbolic state name
end


typedef enum {INIT, DECODE=2, IDLE} fsmtype_e;
","""Verilog code snippet demonstrating the use of enumerated types for finite state machine representation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p90.jpg,True,"The image contains Verilog code. Here is the text version of the code presented:

```verilog
assert never (reset_n && {push,pop}==2'b10 && cnt==FIFO_depth)
  @(posedge clk);

assert never (reset_n && pop && cnt==0)
  @(posedge clk);

module FIFO (data_out, data_in,
  clk, FIFO_clr_n, FIFO_reset_n,
  push, // push strobe, active high
  pop   // pop strobe, active high
);
// FIFO parameters
parameter FIFO_width = `FIFO_WIDTH;
parameter FIFO_depth = `FIFO_DEPTH;
parameter FIFO_pntr_w = `FIFO_PNTR_W;
parameter FIFO_cntr_w = `FIFO_CNTR_W;
output [FIFO_width-1:0] data_out;
input  [FIFO_width-1:0] data_in;
input                   clk, FIFO_clr_n,
                         FIFO_reset_n, push, pop;

// FIFO buffer declaration
reg [FIFO_width-1:0] FIFO[FIFO_depth-1:0];
// FIFO pointers
reg [FIFO_pntr_w-1:0] top; // top
reg [FIFO_pntr_w-1:0] btm; // bottom
reg [FIFO_cntr_w-1:0] cnt; // count

`ifdef ASSERT_ON
wire reset_n = FIFO_reset_n & FIFO_clr_n;

// OVL assert that the FIFO cannot overflow
assert_never no_overflow (clk, reset_n,
  ({push,pop}==2’b10 && cnt==FIFO_depth-1));

// OVL assert that the FIFO cannot underflow
assert_never no_underflow (clk, reset_n,
  (pop && cnt == 0));

`endif
```

This code is an example of Verilog (a hardware description language used in electronic design automation) that defines a FIFO (first-in-first-out) buffer with parameters, assertions for overflow and underflow conditions, and conditional compilation blocks. The two assertions at the top are written in Property Specification Language (PSL), and the module definition includes standard Verilog with OVL (Open Verification Library) assertions.","
assert never (reset_n && {push,pop}==2'b10 && cnt==FIFO_depth)
  @(posedge clk);

assert never (reset_n && pop && cnt==0)
  @(posedge clk);

module FIFO (data_out, data_in,
  clk, FIFO_clr_n, FIFO_reset_n,
  push, // push strobe, active high
  pop   // pop strobe, active high
);
// FIFO parameters
parameter FIFO_width = `FIFO_WIDTH;
parameter FIFO_depth = `FIFO_DEPTH;
parameter FIFO_pntr_w = `FIFO_PNTR_W;
parameter FIFO_cntr_w = `FIFO_CNTR_W;
output [FIFO_width-1:0] data_out;
input  [FIFO_width-1:0] data_in;
input                   clk, FIFO_clr_n,
                         FIFO_reset_n, push, pop;

// FIFO buffer declaration
reg [FIFO_width-1:0] FIFO[FIFO_depth-1:0];
// FIFO pointers
reg [FIFO_pntr_w-1:0] top; // top
reg [FIFO_pntr_w-1:0] btm; // bottom
reg [FIFO_cntr_w-1:0] cnt; // count

`ifdef ASSERT_ON
wire reset_n = FIFO_reset_n & FIFO_clr_n;

// OVL assert that the FIFO cannot overflow
assert_never no_overflow (clk, reset_n,
  ({push,pop}==2’b10 && cnt==FIFO_depth-1));

// OVL assert that the FIFO cannot underflow
assert_never no_underflow (clk, reset_n,
  (pop && cnt == 0));

`endif
","""Overview of Verilog code implementing FIFO overflow and underflow assertions using PSL and OVL.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p434.jpg,True,"The image contains Verilog code. Here is the code written in the image:

```verilog
// CHECK # 1. On falling edge of FRAME_, AD or C_BE_ cannot be unknown.
//-------------------------------------------------------
`ifdef check1
property checkPCI_AD_CBE;
    @(posedge clk) disable iff (!reset_) $fell(FRAME_) |->
                    (!$isunknown(AD) || !$isunknown(C_BE_));
endproperty

assert property (checkPCI_AD_CBE) else
$display($stime,, ""CHECK1:checkPCI_AD_CBE FAIL\n"");
`endif

// CHECK # 2. When IRDY_ and TRDY_ are asserted (low) AD or C_BE_ cannot be unknown.
//-------------------------------------------------------
`ifdef check2
property checkPCI_DataPhase;
    @(posedge clk) disable iff (!reset_) ((IRDY_ && !TRDY_) |->
                    (!$isunknown(AD) || !$isunknown(C_BE_)));
endproperty

assert property (checkPCI_DataPhase) else
$display($stime,, ""CHECK2:checkPCI_DataPhase FAIL\n"");
`endif

// CHECK # 3. FRAME_ can go High only if IRDY_ is asserted. In other words, master can signify end of cycle only if IRDY_ is asserted.
//-------------------------------------------------------
`ifdef check3
property checkPCI_Frame_Irdy;
    @(posedge clk) disable iff (!reset_) $rose(FRAME_) |->
                    !IRDY_;
endproperty

assert property (checkPCI_Frame_Irdy) else
$display($stime,, ""CHECK3:checkPCI_frmIrdy FAIL\n"");
`endif
```

This code seems to be a series of assertions checking the state of a PCI bus in a system. The checks verify that certain signal conditions are met relative to the clock signal, reset signal, and various control signals such as FRAME_, IRDY_, and TRDY_ according to the PCI protocol. If these conditions are not met, an error message is displayed with the current simulation time.","
// CHECK # 1. On falling edge of FRAME_, AD or C_BE_ cannot be unknown.
//-------------------------------------------------------
`ifdef check1
property checkPCI_AD_CBE;
    @(posedge clk) disable iff (!reset_) $fell(FRAME_) |->
                    (!$isunknown(AD) || !$isunknown(C_BE_));
endproperty

assert property (checkPCI_AD_CBE) else
$display($stime,, ""CHECK1:checkPCI_AD_CBE FAIL\n"");
`endif

// CHECK # 2. When IRDY_ and TRDY_ are asserted (low) AD or C_BE_ cannot be unknown.
//-------------------------------------------------------
`ifdef check2
property checkPCI_DataPhase;
    @(posedge clk) disable iff (!reset_) ((IRDY_ && !TRDY_) |->
                    (!$isunknown(AD) || !$isunknown(C_BE_)));
endproperty

assert property (checkPCI_DataPhase) else
$display($stime,, ""CHECK2:checkPCI_DataPhase FAIL\n"");
`endif

// CHECK # 3. FRAME_ can go High only if IRDY_ is asserted. In other words, master can signify end of cycle only if IRDY_ is asserted.
//-------------------------------------------------------
`ifdef check3
property checkPCI_Frame_Irdy;
    @(posedge clk) disable iff (!reset_) $rose(FRAME_) |->
                    !IRDY_;
endproperty

assert property (checkPCI_Frame_Irdy) else
$display($stime,, ""CHECK3:checkPCI_frmIrdy FAIL\n"");
`endif
","""Example checks for PCI Read Protocol using SystemVerilog assertions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p119.jpg,True,"```verilog
typedef struct t_vpi_error_info {
  int state;          /* vpiCompile, vpiPLI, vpiRun */
  int level;          /* vpiNotice, vpiWarning, vpiError, 
                         vpiSystem, vpiInternal */
  char *message;
  char *product;
  char *code;
  char *file;
  int line;
} s_vpi_error_info, *p_vpi_error_info;
```","
typedef struct t_vpi_error_info {
  int state;          /* vpiCompile, vpiPLI, vpiRun */
  int level;          /* vpiNotice, vpiWarning, vpiError, 
                         vpiSystem, vpiInternal */
  char *message;
  char *product;
  char *code;
  char *file;
  int line;
} s_vpi_error_info, *p_vpi_error_info;
","""Excerpt from a document detailing the s_vpi_error_info structure from the VPI Routine Library in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p352.jpg,True,"The image contains Verilog code, as follows:

```verilog
P1: assert property (@ (posedge clk) (rxorg)); //concurrent assertion
always_comb begin
    a1: assert (xxory (r1,r2)); //immediate assertion
    a2: assert (rxorg);
end
endmodule

module abc;
logic clk, r1,r2,req,gnt;
P1: assert property (@ (posedge clk) (req || gnt)); //concurrent assertion
always_comb begin
    a1: assert (r1 ^ r2); //immediate assertion
    a2: assert (req || gnt);
end
endmodule
```

And another example:

```verilog
module abc;
logic clk,r1,r2,req,gnt,ack,start;
let arose(x) = $rose ( x );
let afell(y) = $fell ( y );
always_comb begin
    if (ack) s1: assert(arose(gnt));
    if (start) s2: assert(afell(req));
end
```

Lastly:

```verilog
task write_value;
input logic [31:0] addr;
input logic [31:0] value;
...
endtask
...
let addr = top.block1.unit1.base + top.block1.unit2.displ;
...
write_value(addr, 0);
```","
P1: assert property (@ (posedge clk) (rxorg)); //concurrent assertion
always_comb begin
    a1: assert (xxory (r1,r2)); //immediate assertion
    a2: assert (rxorg);
end
endmodule

module abc;
logic clk, r1,r2,req,gnt;
P1: assert property (@ (posedge clk) (req || gnt)); //concurrent assertion
always_comb begin
    a1: assert (r1 ^ r2); //immediate assertion
    a2: assert (req || gnt);
end
endmodule


module abc;
logic clk,r1,r2,req,gnt,ack,start;
let arose(x) = $rose ( x );
let afell(y) = $fell ( y );
always_comb begin
    if (ack) s1: assert(arose(gnt));
    if (start) s2: assert(afell(req));
end


task write_value;
input logic [31:0] addr;
input logic [31:0] value;
...
endtask
...
let addr = top.block1.unit1.base + top.block1.unit2.displ;
...
write_value(addr, 0);
","""Verilog code demonstrating 'let' declarations, concurrent assertions, and immediate assertions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p328.jpg,True,"The image contains an example of Verilog code. Here is the code:

```verilog
assert_cycle_sequence # (0,3) init_test (clk, reset_n,
    {r_opcode == 'WRITE, r_opcode == 'WAIT,
    r_opcode == 'DONE} );
```","
assert_cycle_sequence # (0,3) init_test (clk, reset_n,
    {r_opcode == 'WRITE, r_opcode == 'WAIT,
    r_opcode == 'DONE} );
","""Overview of the assert_cycle_sequence syntax and usage in Verilog for assertion-based design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p694.jpg,True,"The image is a textual excerpt from ""The Verilog PLI Handbook, Appendices"" and it lists various constants associated with Verilog Programming Language Interface (PLI) operators. The actual code is not present, but the names of constants that represent Verilog operators are shown. Here is the list of constants:

```
vpiMinusOp       unary minus operator
vpiPlusOp        unary plus operator
vpiNotOp         unary not operator
vpiBitNegOp      bitwise negation operator
vpiUnaryAndOp    bitwise reduction and operator
vpiUnaryNandOp   bitwise reduction nand operator
vpiUnaryOrOp     bitwise reduction or operator
vpiUnaryNorOp    bitwise reduction nor operator
vpiUnaryXorOp    bitwise reduction xor operator
vpiUnaryXNorOp   bitwise reduction xnor operator
vpiSubOp         binary subtraction operator
vpiDivOp         binary division operator
vpiModOp         binary modulus operator
vpiEqOp          binary equality operator
vpiNeqOp         binary inequality operator
vpiCaseEqOp      case equality operator (===)
vpiCaseNeqOp     case inequality operator (!==)
vpiGtOp          binary greater-than operator
vpiGeOp          binary greater-than-or-equal operator
vpiLtOp          binary less-than operator
vpiLeOp          binary less-than-or-equal operator
vpiLShiftOp      binary left shift operator
vpiRShiftOp      binary right shift operator
vpiAddOp         binary addition operator
vpiMultOp        binary multiplication operator
vpiLogAndOp      binary logical and operator
vpiLogOrOp       binary logical or operator
vpiBitAndOp      binary bitwise and operator
vpiBitOrOp       binary bitwise or operator
vpiBitXorOp      binary bitwise xor operator
vpiBitXnorOp     binary bitwise xnor operator
vpiConditionOp   ternary conditional operator
vpiConcatOp      concatenation operator
vpiMultiConcatOp replication operator (repeated concatenation)
vpiEventOrOp     event or operator
vpiNullOp        null operation
vpiListOp        list of expressions
vpiMinTypMaxOp   min:typ:max: delay expression
vpiPosedgeOp     posedge operator
vpiNegedgeOp     negedge operator
```

These constants are used in Verilog PLI to identify the type of operation being performed by a specific node or handle in a Verilog abstract syntax tree.","usOp       unary minus operator
vpiPlusOp        unary plus operator
vpiNotOp         unary not operator
vpiBitNegOp      bitwise negation operator
vpiUnaryAndOp    bitwise reduction and operator
vpiUnaryNandOp   bitwise reduction nand operator
vpiUnaryOrOp     bitwise reduction or operator
vpiUnaryNorOp    bitwise reduction nor operator
vpiUnaryXorOp    bitwise reduction xor operator
vpiUnaryXNorOp   bitwise reduction xnor operator
vpiSubOp         binary subtraction operator
vpiDivOp         binary division operator
vpiModOp         binary modulus operator
vpiEqOp          binary equality operator
vpiNeqOp         binary inequality operator
vpiCaseEqOp      case equality operator (===)
vpiCaseNeqOp     case inequality operator (!==)
vpiGtOp          binary greater-than operator
vpiGeOp          binary greater-than-or-equal operator
vpiLtOp          binary less-than operator
vpiLeOp          binary less-than-or-equal operator
vpiLShiftOp      binary left shift operator
vpiRShiftOp      binary right shift operator
vpiAddOp         binary addition operator
vpiMultOp        binary multiplication operator
vpiLogAndOp      binary logical and operator
vpiLogOrOp       binary logical or operator
vpiBitAndOp      binary bitwise and operator
vpiBitOrOp       binary bitwise or operator
vpiBitXorOp      binary bitwise xor operator
vpiBitXnorOp     binary bitwise xnor operator
vpiConditionOp   ternary conditional operator
vpiConcatOp      concatenation operator
vpiMultiConcatOp replication operator (repeated concatenation)
vpiEventOrOp     event or operator
vpiNullOp        null operation
vpiListOp        list of expressions
vpiMinTypMaxOp   min:typ:max: delay expression
vpiPosedgeOp     posedge operator
vpiNegedgeOp     negedge operator
","""List of Verilog Programming Language Interface (PLI) operators and their descriptions from the Verilog PLI Handbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p247.jpg,True,"```verilog
module mwxd(clk,we,wr_ad,rd_ad,di,r_do);
parameter w = 16; // word width
parameter d = 512; // memory depth
parameter a = 9; //address width
input clk, we;
input [a-1:0] wr_ad;
input [a-1:0] rd_ad;
input [w-1:0] di;
output [w-1:0] r_do;
reg [a-1:0] r_wr_ad;
reg [a-1:0] r_rd_ad;
reg r_we;
reg [w-1:0] r_di;
reg [w-1:0] r_do;
reg [w-1:0] core [0:d-1];
wire [w-1:0] c_do;

always @ (posedge clk) begin
    r_wr_ad <= wr_ad;
    r_rd_ad <= rd_ad;
    r_we <= we;
    r_di <= di;
    r_do <= c_do;
end // always

assign c_do = core[r_rd_ad];

always @ (negedge clk)
    if (r_we)
        core[r_wr_ad] = r_di;
endmodule // mwxd.
```
The Verilog code in the image outlines the module declaration for a write-enabled multiplexer-demo with parameter definitions, input/output declarations, register declarations, always blocks, assignments, and a conditional block within an always block to handle the write operation on the negedge of the clock.","
module mwxd(clk,we,wr_ad,rd_ad,di,r_do);
parameter w = 16; // word width
parameter d = 512; // memory depth
parameter a = 9; //address width
input clk, we;
input [a-1:0] wr_ad;
input [a-1:0] rd_ad;
input [w-1:0] di;
output [w-1:0] r_do;
reg [a-1:0] r_wr_ad;
reg [a-1:0] r_rd_ad;
reg r_we;
reg [w-1:0] r_di;
reg [w-1:0] r_do;
reg [w-1:0] core [0:d-1];
wire [w-1:0] c_do;

always @ (posedge clk) begin
    r_wr_ad <= wr_ad;
    r_rd_ad <= rd_ad;
    r_we <= we;
    r_di <= di;
    r_do <= c_do;
end // always

assign c_do = core[r_rd_ad];

always @ (negedge clk)
    if (r_we)
        core[r_wr_ad] = r_di;
endmodule // mwxd.
",Verilog code example for a memory read-write module with parameterizable word and address width.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p253.jpg,True,"```verilog
`define R_NORMAL2'h0
`define R_WAIT 2'h1
`define R_DONE 2'h2
`define R_IDLE 2'h3

`define IO_T_FLD 15:10
`define IO_Q_FLD 9:4
`define IO_S_FLD 3:0

`define QT_DEPTH 64
```","
`define R_NORMAL2'h0
`define R_WAIT 2'h1
`define R_DONE 2'h2
`define R_IDLE 2'h3

`define IO_T_FLD 15:10
`define IO_Q_FLD 9:4
`define IO_S_FLD 3:0

`define QT_DEPTH 64
","""Verilog Compiler Directives and Constant Definitions for State Machines and Bit Fields""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p680.jpg,True,"The image does contain code related to Verilog PLI (Programming Language Interface). Here is the code excerpt from the document:

Example A-15: PLI table file to specify PLI applications for the VCS simulator
```
// Example Synopsys VCS PLI table to register PLI applications
// For the book, ""Using The Verilog PLI"", Chapter 4

$show_value check=PLIbook_ShowVal_checktf call=PLIbook_ShowVal_calltf data=0 acc+=read+;
$pow check=PLIbook_pow_checktf call=PLIbook_pow_calltf misc=PLIbook_pow_misctf size=32 data=0
```

Additionally, an example command to invoke the simulation with the PLI applications `$show_value` and `$pow` is given:

```
vcsi -Mupdate test.v -P my_pli_apps.tab pow.c showval.c
```","mple Synopsys VCS PLI table to register PLI applications
// For the book, ""Using The Verilog PLI"", Chapter 4

$show_value check=PLIbook_ShowVal_checktf call=PLIbook_ShowVal_calltf data=0 acc+=read+;
$pow check=PLIbook_pow_checktf call=PLIbook_pow_calltf misc=PLIbook_pow_misctf size=32 data=0

Mupdate test.v -P my_pli_apps.tab pow.c showval.c
","""Guide on compiling and running PLI applications in Verilog with VCS simulator and an example PLI table for VCS.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p314.jpg,True,"```verilog
task ovl_warning;
begin
  // Some user defined Stuff Here, e.g., PLI
end
endtask

task ovl_init_msg;
begin
  $display(""OVL_NOTE: %s initialized @ %m \ Severity: %0d, Message: %s"",
           assert_name, severity_level, msg);
end
endtask
```","
task ovl_warning;
begin
  // Some user defined Stuff Here, e.g., PLI
end
endtask

task ovl_init_msg;
begin
  $display(""OVL_NOTE: %s initialized @ %m \ Severity: %0d, Message: %s"",
           assert_name, severity_level, msg);
end
endtask
","""Verilog code snippet demonstrating the implementation of OVL (Open Verification Library) tasks for error reporting and initialization messages in a simulation environment.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p391.jpg,True,"```verilog
`ifdef check2
property fifoempty;
    @(posedge clk) !rst |-> `rd_ptr==0; // DUMMY... remove this line and
                                       // replace it with correct check
endproperty
fifoemptyP: assert property (fifoempty) else $display($stime, ""\t\t FAIL::fifo_empty condition\n"");
`endif

`ifdef check3
property fifofull;
    @(posedge clk) !rst |-> `rd_ptr==0; // DUMMY... remove this line and
                                       // replace it with correct check
endproperty
fifofullP: assert property (fifofull) else $display($stime, ""\t\t FAIL::fifo_full condition\n"");
`endif

`ifdef check4
property fifo_full_write_stable_wrptr;
    @(posedge clk) !rst |-> `rd_ptr==0; // DUMMY... remove this line and
                                       // replace it with correct check
endproperty
```","
`ifdef check2
property fifoempty;
    @(posedge clk) !rst |-> `rd_ptr==0; // DUMMY... remove this line and
                                       // replace it with correct check
endproperty
fifoemptyP: assert property (fifoempty) else $display($stime, ""\t\t FAIL::fifo_empty condition\n"");
`endif

`ifdef check3
property fifofull;
    @(posedge clk) !rst |-> `rd_ptr==0; // DUMMY... remove this line and
                                       // replace it with correct check
endproperty
fifofullP: assert property (fifofull) else $display($stime, ""\t\t FAIL::fifo_full condition\n"");
`endif

`ifdef check4
property fifo_full_write_stable_wrptr;
    @(posedge clk) !rst |-> `rd_ptr==0; // DUMMY... remove this line and
                                       // replace it with correct check
endproperty
","Verilog Assertions for FIFO Operations: Checking empty, full and write conditions.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p300.jpg,True,"The image displays text discussing aspects of Property Specification Language (PSL) and SystemVerilog, including examples of how to specify overlapping expressions correctly and incorrectly. It includes snippets of code as well. Below is the Verilog code from the image:

```verilog
// PSL: Incorrectly specifying overlapping expressions
// The following error was an attempt to specify that done will occur
// whenever transfer occurs
default clock = (posedge clk);

property EvenOddAddr =
    always {rose (write)} |-> {({transfer [-1]} & {done})};
assert EvenOddAddr;
```

The code above shows an incorrect example using PSL.

```verilog
// PSL: Correctly specifying overlapping expression
// The following correct example uses the fusion operator (:) to
// specify that done will overlap on the last occurrence of transfer
default clock = (posedge clk);

property EvenOddAddr =
    always {rose (write)} |-> ({transfer [-1]} : {done});
assert EvenOddAddr;
```

The second snippet shows the correct way to use the fusion operator in PSL to specify overlapping expressions.","
// PSL: Incorrectly specifying overlapping expressions
// The following error was an attempt to specify that done will occur
// whenever transfer occurs
default clock = (posedge clk);

property EvenOddAddr =
    always {rose (write)} |-> {({transfer [-1]} & {done})};
assert EvenOddAddr;


// PSL: Correctly specifying overlapping expression
// The following correct example uses the fusion operator (:) to
// specify that done will overlap on the last occurrence of transfer
default clock = (posedge clk);

property EvenOddAddr =
    always {rose (write)} |-> ({transfer [-1]} : {done});
assert EvenOddAddr;
","""Examples of correctly and incorrectly specifying overlapping expressions in PSL (Property Specification Language) for Verilog/SystemVerilog assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p723.jpg,True,"```c
typedef struct t_cb_data {
    int reason;          /* callback reason */
    int (*cb_rtn)();     /* call routine */
    vpiHandle obj;       /* trigger object */
    p_vpi_time time;     /* callback time */
    p_vpi_value value;   /* trigger object value */
    int index;           /* index of the memory word
                            or var select which
                            changed value */
    char *user_data;     /* passed to callback */
    s_cb_data, *p_cb_data;
} s_cb_data, *p_cb_data;

typedef struct t_vpi_time {
    int type;            /* vpiScaledRealTime, vpiSimTime,
                            vpiSuppressTime */
    unsigned int high;   /* when using vpiSimTime */
    unsigned int low;    /* when using vpiSimTime */
    double real;         /* when using vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;

typedef struct t_vpi_vecval {
    int aval, bval;      /* bit encoding: a/b: 0/0=e0,
                            1/0=e1, 1/1=eX, 0/1=eZ */
} s_vpi_vecval, *p_vpi_vecval;
```","ef struct t_cb_data {
    int reason;          /* callback reason */
    int (*cb_rtn)();     /* call routine */
    vpiHandle obj;       /* trigger object */
    p_vpi_time time;     /* callback time */
    p_vpi_value value;   /* trigger object value */
    int index;           /* index of the memory word
                            or var select which
                            changed value */
    char *user_data;     /* passed to callback */
    s_cb_data, *p_cb_data;
} s_cb_data, *p_cb_data;

typedef struct t_vpi_time {
    int type;            /* vpiScaledRealTime, vpiSimTime,
                            vpiSuppressTime */
    unsigned int high;   /* when using vpiSimTime */
    unsigned int low;    /* when using vpiSimTime */
    double real;         /* when using vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;

typedef struct t_vpi_vecval {
    int aval, bval;      /* bit encoding: a/b: 0/0=e0,
                            1/0=e1, 1/1=eX, 0/1=eZ */
} s_vpi_vecval, *p_vpi_vecval;
","""Verilog VPI Routine Documentation and Struct Definitions for Simulation Callbacks""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p50.jpg,True,"```verilog
`ifdef EVENTS_ON
// Detects when queue is full
// and queue write request occur simultaneously
always @(posedge clk) begin
    if(reset_n == 1'b0 && q_full && q_c_write) begin
        $display(""EVENT:%0d:%0t:%m"", `EV_Q_FULL_WR, $time);
    end
end
`endif
```","
`ifdef EVENTS_ON
// Detects when queue is full
// and queue write request occur simultaneously
always @(posedge clk) begin
    if(reset_n == 1'b0 && q_full && q_c_write) begin
        $display(""EVENT:%0d:%0t:%m"", `EV_Q_FULL_WR, $time);
    end
end
`endif
","Caption: ""Excerpt from a document describing Verilog event monitoring and showcasing conditional compilation with Verilog code snippet.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p232.jpg,True,"The image includes some Verilog code snippets within a text document. Here is the text transcription of the code present in the image:

First code snippet:

```verilog
sequence branch(a ,b ,c ,d);
    @(posedge clk) $fell(a) ##1 $fell(5) $rose(b) ##1 c [=2] ##1 d;
endsequence

property endCycle;
    @(posedge clk) $rose( endBranch |-> branch(a, b , c , d).triggered;
endproperty
```

Second code snippet:

```verilog
sequence aRb( aFell, bRose );
    @(posedge clk) $fell( aFell ) ##1 $rose( bRose );
endsequence

property endCycle;
    @(posedge clk) $rose(c) |-> aRb (a, b).triggered;
endproperty
base: assert property (endCycle) else gotoFail;
```

These are used to demonstrate the usage of `.triggered` in the context of sequence and property definitions in SystemVerilog, a hardware description and verification language.","
sequence branch(a ,b ,c ,d);
    @(posedge clk) $fell(a) ##1 $fell(5) $rose(b) ##1 c [=2] ##1 d;
endsequence

property endCycle;
    @(posedge clk) $rose( endBranch |-> branch(a, b , c , d).triggered;
endproperty


sequence aRb( aFell, bRose );
    @(posedge clk) $fell( aFell ) ##1 $rose( bRose );
endsequence

property endCycle;
    @(posedge clk) $rose(c) |-> aRb (a, b).triggered;
endproperty
base: assert property (endCycle) else gotoFail;
","Caption: ""Explanation and Example Usage of the .triggered Method in SystemVerilog Assertions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p341.jpg,True,"The image contains Verilog code. Here is the code written in the image:

```verilog
if(i == 0)
begin
    b <= ~b;
    repeat(1) @(posedge clk);
    a <= ~a; b <= ~b;
end
else
begin
    repeat(1) @(posedge clk);
    a<= ~a;
    repeat((i-1)) @(posedge clk);
    b<= ~b;
    repeat(1) @(posedge clk);
    b<= ~b;
end
end
end

/**************************************
// case 4
// repetitions
**************************************/

if(rpt_me == 1)
begin
    if(rpt_edge == 2'b11) begin
        a = 1'b0; b=1'b0;
    end

    if(rpt_edge == 2'b00) begin
        a = 1'b1; b=1'b1;
    end

    if(rpt_edge == 2'b01) begin
        a = 1'b1; b=1'b0;
    end

    if(rpt_edge == 2'b10) begin
        a = 1'b0; b=1'b1;
    end

    if(c_rpt == 1)
```

Please note that the last ""if"" statement seems to be incomplete, and the code itself may be part of a larger Verilog program not fully visible on the page.","
if(i == 0)
begin
    b <= ~b;
    repeat(1) @(posedge clk);
    a <= ~a; b <= ~b;
end
else
begin
    repeat(1) @(posedge clk);
    a<= ~a;
    repeat((i-1)) @(posedge clk);
    b<= ~b;
    repeat(1) @(posedge clk);
    b<= ~b;
end
end
end

/**************************************
// case 4
// repetitions
**************************************/

if(rpt_me == 1)
begin
    if(rpt_edge == 2'b11) begin
        a = 1'b0; b=1'b0;
    end

    if(rpt_edge == 2'b00) begin
        a = 1'b1; b=1'b1;
    end

    if(rpt_edge == 2'b01) begin
        a = 1'b1; b=1'b0;
    end

    if(rpt_edge == 2'b10) begin
        a = 1'b0; b=1'b1;
    end

    if(c_rpt == 1)
","""Excerpt from a book displaying Verilog code for conditional operations and edge case handling.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p191.jpg,True,"```verilog
always @(negedge StartSearch)
begin
    #1 Nkeeper    = 'b0;  // Init count keeper every search start.
    #1 FoundPads  = 'b0;  // Move this init here.
    #1 i          = StartI;
end
```","
always @(negedge StartSearch)
begin
    #1 Nkeeper    = 'b0;  // Init count keeper every search start.
    #1 FoundPads  = 'b0;  // Move this init here.
    #1 i          = StartI;
end
",Verilog code snippet showing the initialization of a packet search algorithm on the negative edge of a signal.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p185.jpg,True,"The image indeed contains some Verilog code. Here it is:

```verilog
integer i, j;
reg CurrentSerialBit; // A design data object.
reg[63:0] Stream; // For now, this is a fixed data object.
...

// Concatenation used for documentation purposes, only:
// 'a'                     'b'                     'c'                     'l'
Stream = {32'b1100001_00011000_01100010_00010000,
          32'b01110001_0011110_00000000_01111010_00000000};

begin : While_i
while(1) // Exit control of this loop will be inside of it.
    begin
    for (i = 63; i >= 0; i = i - 1) // Repeats every 64 bits, if no disable.
        begin
        #1 CurrentSerialBit = Stream[i]; // The delay value will be explained.
        (do stuff with CurrentSerialBit then disable While_i)
        end // for i.
    end // End named block While_i.
... // Pick up execution here after disable While_i.
```

The code is part of a discussion on procedural synchronization in Verilog and includes comments that explain certain elements like data objects and the use of the `disable` statement within procedural blocks.","
integer i, j;
reg CurrentSerialBit; // A design data object.
reg[63:0] Stream; // For now, this is a fixed data object.
...

// Concatenation used for documentation purposes, only:
// 'a'                     'b'                     'c'                     'l'
Stream = {32'b1100001_00011000_01100010_00010000,
          32'b01110001_0011110_00000000_01111010_00000000};

begin : While_i
while(1) // Exit control of this loop will be inside of it.
    begin
    for (i = 63; i >= 0; i = i - 1) // Repeats every 64 bits, if no disable.
        begin
        #1 CurrentSerialBit = Stream[i]; // The delay value will be explained.
        (do stuff with CurrentSerialBit then disable While_i)
        end // for i.
    end // End named block While_i.
... // Pick up execution here after disable While_i.
","""Excerpt from a textbook on Digital VLSI Design with Verilog highlighting procedural synchronization in Verilog code, with an example of a 'while' loop and usage instructions for the 'disable' statement.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p78.jpg,True,"The image contains a snippet of Verilog code. Here is the code transcribed from the image:

```verilog
if (rst_ == 1'b0) begin
    r_a <= 16'b0;
    r_b <= 16'b0;
    r_c <= 16'b0;
end
else if (scan_sel) begin
    r_a <= vff_a.scan_in ;
    r_b <= vff_b.scan_in ;
    r_c <= vff_c.scan_in ;
end
else begin
    r_a <= c_a;
    r_b <= c_b;
    r_c <= c_c;
end
```","
if (rst_ == 1'b0) begin
    r_a <= 16'b0;
    r_b <= 16'b0;
    r_c <= 16'b0;
end
else if (scan_sel) begin
    r_a <= vff_a.scan_in ;
    r_b <= vff_b.scan_in ;
    r_c <= vff_c.scan_in ;
end
else begin
    r_a <= c_a;
    r_b <= c_b;
    r_c <= c_c;
end
","""Verilog conditional assignment example from a textbook chapter on HDL coding practices.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p226.jpg,True,"The image contains a block of Verilog code, which specifies a property. Here's the code that is visible in the image:

```verilog
property rc1(intr, iack);
    iack or (intr and ( 'true |=> rc1(intr,iack) ));
Endproperty
```

The code is used to define a recursive property in Verilog for formal verification purposes. The property `rc1` takes two signals, `intr` (representing an interrupt) and `iack` (representing an interrupt acknowledgment) as inputs. The property checks if `iack` is true or if `intr` is true followed by the same property `rc1` recursively with the same signals.","
property rc1(intr, iack);
    iack or (intr and ( 'true |=> rc1(intr,iack) ));
Endproperty
","""Exploration of recursive properties in Verilog with an example of a specification ensuring 'intr' holds true until 'iack' is asserted.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p87.jpg,True,"The image contains Verilog code. Here is the transcribed text:

```verilog
output [3:0] q;
input ck; input [3:0] d;
always @(posedge ck) begin
    q <= d;
end
initial $InitiaIState(q);
endmodule // dff_4
```

```verilog
module dff_2(q, ck, d);
output [1:0] q;
input ck;
input [1:0] d;
cff0 r0 ( .d(d[1]), .ck(ck), .q(q[1]) );
cff1 r1 ( .d(d[0]), .ck(ck), .q(q[0]) );
endmodule // dff_2
```

```verilog
module dff_4(q, ck, d);
output [3:0] q;
input ck;
input [3:0] d;
cff0 r0 ( .d(d[3]), .ck(ck), .q(q[3]) );
cff1 r1 ( .d(d[2]), .ck(ck), .q(q[2]) );
cff2 r2 ( .d(d[1]), .ck(ck), .q(q[1]) );
cff3 r3 ( .d(d[0]), .ck(ck), .q(q[0]) );
endmodule // dff_2
```

Please note there's a typographical error in the initial block of the first code snippet: `$InitiaIState(q);` is likely meant to be `$InitialState(q);` where the letter 'l' is wrongly used instead of the letter 'I'.","
output [3:0] q;
input ck; input [3:0] d;
always @(posedge ck) begin
    q <= d;
end
initial $InitiaIState(q);
endmodule // dff_4


module dff_2(q, ck, d);
output [1:0] q;
input ck;
input [1:0] d;
cff0 r0 ( .d(d[1]), .ck(ck), .q(q[1]) );
cff1 r1 ( .d(d[0]), .ck(ck), .q(q[0]) );
endmodule // dff_2


module dff_4(q, ck, d);
output [3:0] q;
input ck;
input [3:0] d;
cff0 r0 ( .d(d[3]), .ck(ck), .q(q[3]) );
cff1 r1 ( .d(d[2]), .ck(ck), .q(q[2]) );
cff2 r2 ( .d(d[1]), .ck(ck), .q(q[1]) );
cff3 r3 ( .d(d[0]), .ck(ck), .q(q[0]) );
endmodule // dff_2
","Caption: ""Excerpt from a technical document discussing RTL methodology basics with examples of Verilog flip-flop modules.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p248.jpg,True,"The image contains Verilog code. Here are the excerpts of code from the image:

In the first block of code:
```verilog
// For all eight cache line.
assert forall L in {0:7}:
  always {rose(write_hit[L])} |=> {prev(cache_line[L]) != cache_line[L] || !valid[L]};
```

In the second block of code:
```verilog
genvar i;
generate for (i=0; i<=7; i = i + 1)
  cover property @(posedge clk) (cache_fill & cache_we[i]);
endgenerate
```","
// For all eight cache line.
assert forall L in {0:7}:
  always {rose(write_hit[L])} |=> {prev(cache_line[L]) != cache_line[L] || !valid[L]};


genvar i;
generate for (i=0; i<=7; i = i + 1)
  cover property @(posedge clk) (cache_fill & cache_we[i]);
endgenerate
","Caption: ""Excerpts from a Verilog and PSL (Property Specification Language) code documentation showing assertions for cache line write verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p260.jpg,True,"The image contains Verilog code. Here is the transcription of the code:

```verilog
parameter max=5'd26;
reg [4:0] count;
always @ (posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 5'b0;
    else
        case2 ({inc, dec, load})
            3'b?1?: count <= count_in; // load takes priority.
            3'b10: count <= count + 1'b1;
            3'b01: count <= count - 1'b1;
            //0, 6 - The default case keeps the same counter value.
        endcase
end
```

The code is an example of a Verilog fragment for an up-down counter with parallel load capability.","
parameter max=5'd26;
reg [4:0] count;
always @ (posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 5'b0;
    else
        case2 ({inc, dec, load})
            3'b?1?: count <= count_in; // load takes priority.
            3'b10: count <= count + 1'b1;
            3'b01: count <= count - 1'b1;
            //0, 6 - The default case keeps the same counter value.
        endcase
end
",Example Verilog code for an up-down counter with parallel load and discussion about implementing assertions for maximum counter value.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p76.jpg,True,"The image includes Verilog code. Here is the code represented in the image:

```verilog
module ReqAck;

bit ReqPending, currentReq, AckPending, currentAck;
logic ReqCheck, AckCheck;

function bit checkReqAck (bit a, bit b);
    A1: assert final (a == b);
endfunction
......
always_comb begin : ReqC
    ReqCheck = checkReqAck (ReqPending, currentReq);
end

always_comb begin : AckC
    AckCheck = checkReqAck (AckPending, currentAck);
end
endmodule
```

The provided Verilog code example is related to a discussion on deferred assertion within a function in a Verilog module.","
module ReqAck;

bit ReqPending, currentReq, AckPending, currentAck;
logic ReqCheck, AckCheck;

function bit checkReqAck (bit a, bit b);
    A1: assert final (a == b);
endfunction
......
always_comb begin : ReqC
    ReqCheck = checkReqAck (ReqPending, currentReq);
end

always_comb begin : AckC
    AckCheck = checkReqAck (AckPending, currentAck);
end
endmodule
","""Example of Verilog code using deferred assertions in a function to check signal consistency.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p152.jpg,True,"The image contains Verilog code. Here is the code snippet presented:

```verilog
initial // Cycle the reset by time 10:
begin
    #0 Reset = 1'b0;
    #1 Reset = 1'b1;
    #9 Reset = 1'b0;
end
```

This code demonstrates an initial block in Verilog which is used to cycle a `Reset` signal during simulation.","
initial // Cycle the reset by time 10:
begin
    #0 Reset = 1'b0;
    #1 Reset = 1'b1;
    #9 Reset = 1'b0;
end
","Caption: ""Educational material explaining behavioral and structural Verilog with code examples and theoretical context for digital design coursework.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p146.jpg,True,"The image contains snippets of Verilog code within the text. Here is the code extracted from the image:

```verilog
for (...)
begin
    ...
    #1 DbusIn = (some data depending on loop);
    #1 Write  = 1'b1;
    #10 Write = 1'b0;
    SomeReg  = Mem1kx32_inst.MemStorage[j];
    $display(""..."", $time, addr, SomeReg[31:0], SomeReg[32]);
end
```

The ""`...`"" within the code and the text indicates there are more lines of code or parameters that are not completely shown. The exact contents would depend on the specific context and implementation details that the author is discussing. The specific loop conditions and additional contents are not shown in the image.","
for (...)
begin
    ...
    #1 DbusIn = (some data depending on loop);
    #1 Write  = 1'b1;
    #10 Write = 1'b0;
    SomeReg  = Mem1kx32_inst.MemStorage[j];
    $display(""..."", $time, addr, SomeReg[31:0], SomeReg[32]);
end
","Caption: ""Verilog simulation waveform for a single-port memory with separate read and write operations, accompanied by instructions for testing and modifying RAM design in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p274.jpg,True,"The image contains Verilog code. Here is the code transcribed from the image:

```verilog
// extra modeling to simplify expressing coverage property
reg [3:0] req_cnt, ack_cnt;
initial {req_cnt, ack_cnt} = 8'b0;
always @(posedge clk) begin
  // Increment counter each time a req or ack occurs.
  if (req) req_cnt <= req_cnt + 1;
  if (ack) ack_cnt <= ack_cnt + 1;
end

genvar C, T;
generate for (C=0; C<15; C= C+ 1)
  generate for (T=0; T<=9; T= T+ 1)
    cover property (@(posedge clk)
                    (req && req_cnt == C; ##T ack && ack_cnt == C));
  endgenerate
endgenerate
```

This code snippet is an example demonstrating SystemVerilog functional coverage for requirement-to-done timing as described in the image's text.","
// extra modeling to simplify expressing coverage property
reg [3:0] req_cnt, ack_cnt;
initial {req_cnt, ack_cnt} = 8'b0;
always @(posedge clk) begin
  // Increment counter each time a req or ack occurs.
  if (req) req_cnt <= req_cnt + 1;
  if (ack) ack_cnt <= ack_cnt + 1;
end

genvar C, T;
generate for (C=0; C<15; C= C+ 1)
  generate for (T=0; T<=9; T= T+ 1)
    cover property (@(posedge clk)
                    (req && req_cnt == C; ##T ack && ack_cnt == C));
  endgenerate
endgenerate
","Caption: ""Extract from a textbook discussing SystemVerilog functional coverage for request-to-done timing verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p247.jpg,True,"The image contains snippets of C code and Verilog code as part of an explanation on interfacing C models using VPI routines. Here is the code from the image:

C code snippet:
```c
void c_model(...)
{
    // Content of the function is not shown in the image
}
```

Verilog code snippet:
```verilog
module c_model(...);
    // Content of the module is not shown in the image
endmodule
```

And there is another C code snippet that appears to be a function prototype or declaration:
```c
int c_mod_calltf()
{
    // Content of the function is not shown in the image
}
```

Please note that the actual content inside the functions or modules is not visible in the image provided.","c_model(...)
{
    // Content of the function is not shown in the image
}


module c_model(...);
    // Content of the module is not shown in the image
endmodule

_mod_calltf()
{
    // Content of the function is not shown in the image
}
","A document detailing the interfacing of Verilog simulations to C models using VPI routines, with steps for creating a C language model, a Verilog HDL shell module, and a PLI application for interfacing.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p250.jpg,True,"The image contains snippets of Verilog code. Here they are:

```
a3: assert property (req |=> !req);
```

```
a4: assert property (not strong(req[*2]));
```

```
a1: assert property (
    req implies (nexttime ack) or nexttime [2] rtry);
```

```
a2: assert property (
    req implies (ack or nexttime rtry));
```

```
a: assert property (req |=> (ack or ##1 rtry));
```","sert property (req |=> !req);

sert property (not strong(req[*2]));

sert property (
    req implies (nexttime ack) or nexttime [2] rtry);

sert property (
    req implies (ack or nexttime rtry));

ert property (req |=> (ack or ##1 rtry));
","The image shows a textbook page discussing advanced properties of assertions in Verilog, including examples of assert statements and explanations of bounded eventually and always operators.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p536.jpg,True,"Here is the Verilog code contained in the image:

```verilog
always_ff @clk a <= e;

always_ff @(sglobal_clock a <= $changing_gclk(clk) ? e : a;

checker check1;
    rand bit v;
    check2 c2(v, $global_clock);
endchecker : check1

checker check2(a, clk = $inferred_clock);
    a1: assert property (@clk not always a iff s_eventually !a);
endchecker : check2

rand bit [2:0] v;
m1: assume property(@$global_clock v == 3’d2 || v == 3’d5);

bit [2:0] v;
rand bit x;
assign v = x ? 3’d2 : 3’d5;
```

This code includes examples of an `always_ff` block, definitions of checkers, declaration of random bit variables, property assumption, and a continuous assignment with a ternary operator.","
always_ff @clk a <= e;

always_ff @(sglobal_clock a <= $changing_gclk(clk) ? e : a;

checker check1;
    rand bit v;
    check2 c2(v, $global_clock);
endchecker : check1

checker check2(a, clk = $inferred_clock);
    a1: assert property (@clk not always a iff s_eventually !a);
endchecker : check2

rand bit [2:0] v;
m1: assume property(@$global_clock v == 3’d2 || v == 3’d5);

bit [2:0] v;
rand bit x;
assign v = x ? 3’d2 : 3’d5;
","""Understanding Non-Determinism in Clock Events and Usage of Free Variables in SystemVerilog Checkers""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p521.jpg,True,"The image contains a Verilog code example for a timing check. Here is the code extracted from the image:

```verilog
$setup(data, posedge clock &&& (reset), 10, err_flag);
```

This code snippet is defining a setup timing check in Verilog hardware description language (HDL).","
$setup(data, posedge clock &&& (reset), 10, err_flag);
","""Documentation on Verilog ACC Routine Library detailing timing constraints and handle functions for timing checks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p42.jpg,True,"```verilog
sequence s5;
    @(posedge clk) a ##2 b;
endsequence

property p5;
    s5;
endproperty

a5 : assert property(p5);

sequence s5a;
    a ##2 b;
endsequence

property p5a;
    @(posedge clk) s5a;
endproperty

a5a : assert property(p5a);

sequence s5b;
    a ##2 b;
endsequence
```","
sequence s5;
    @(posedge clk) a ##2 b;
endsequence

property p5;
    s5;
endproperty

a5 : assert property(p5);

sequence s5a;
    a ##2 b;
endsequence

property p5a;
    @(posedge clk) s5a;
endproperty

a5a : assert property(p5a);

sequence s5b;
    a ##2 b;
endsequence
","""Introduction to clock definitions in SystemVerilog Assertions (SVA) with code examples.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p248.jpg,True,"The image contains Verilog code. Below is the transcribed code from the two code samples present in the image:

Sample 6.61:
```verilog
class Ascend;
  rand uint d[10];
  constraint c {
    foreach (d[i])  // For every element
      if (i>0)      // except the first
        d[i] > d[i-1]; // compare with previous element
  }
endclass
```

Sample 6.62:
```verilog
class UniqueSlow; // Bad code, do not use
  rand bit [7:0] ua[64];
  constraint c {
    foreach (ua[i])             // For every element,
      foreach (ua[j])
        if (i != j)             // except the diagonals,
          ua[i] != ua[j]; // compare to other elements
  }
endclass
```","
class Ascend;
  rand uint d[10];
  constraint c {
    foreach (d[i])  // For every element
      if (i>0)      // except the first
        d[i] > d[i-1]; // compare with previous element
  }
endclass


class UniqueSlow; // Bad code, do not use
  rand bit [7:0] ua[64];
  constraint c {
    foreach (ua[i])             // For every element,
      foreach (ua[j])
        if (i != j)             // except the diagonals,
          ua[i] != ua[j]; // compare to other elements
  }
endclass
","Caption: ""Excerpts from a document discussing the use of constraints in Verilog for creating ascending array values and generating arrays of unique values.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p253.jpg,True,"```verilog
module chip (...)
    ...
    scientific_alu u1 (a, b, opcode, result, exceP, err);
    ...
endmodule
```","
module chip (...)
    ...
    scientific_alu u1 (a, b, opcode, result, exceP, err);
    ...
endmodule
","""Verilog Shell Module for Interfacing with C Models Using VPI Routines""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p393.jpg,True,"The image contains Verilog code. Here it is transcribed:

```verilog
module PLLTop (output ClockOut, input ClockIn, Reset);
    ...
    // delayed output input
    Library_DelayCell DelayU1 (.Z(SampleWire), .I(ClockIn));
    //
    // (dont_touch DelayU1 synthesis directives)
    //
    VFO VFOU1 (.ClockOut(Mlz32), .AdjustFreq(AdjFreq)
               .Sample(SampleWire), .Reset(Reset) );
```

Please note that the ellipsis ""..."" and comments ""//"" indicate there may be additional code or comments not displayed in the image.","
module PLLTop (output ClockOut, input ClockIn, Reset);
    ...
    // delayed output input
    Library_DelayCell DelayU1 (.Z(SampleWire), .I(ClockIn));
    //
    // (dont_touch DelayU1 synthesis directives)
    //
    VFO VFOU1 (.ClockOut(Mlz32), .AdjustFreq(AdjFreq)
               .Sample(SampleWire), .Reset(Reset) );
","Caption: ""Excerpt from a textbook discussing the implementation of a library delay cell in Verilog code, and challenges in synthesizing a variable-frequency oscillator (VFO) for a phase-locked loop (PLL) using macro and nonblocking assignments.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p260.jpg,True,"The image contains code and here it is transcribed below:

```verilog
function void build();
  pci_gen gen0, gen1;
  atm_gen new_gen;          // New ATM generator
  gen0 = new();
  gen1 = new();
  new_gen = new();          // Construct new object after old ones

  fork
    gen0.run();
    gen1.run();
    new_gen.run();          // Spawn new thread after old ones
  join
endfunction : build
```

The code appears to be an example related to test code modification and is written in the context of hardware verification using SystemVerilog. It shows a `build` function that creates and starts transaction generators in parallel threads using fork-join constructs.","
function void build();
  pci_gen gen0, gen1;
  atm_gen new_gen;          // New ATM generator
  gen0 = new();
  gen1 = new();
  new_gen = new();          // Construct new object after old ones

  fork
    gen0.run();
    gen1.run();
    new_gen.run();          // Spawn new thread after old ones
  join
endfunction : build
","Caption: ""Verilog code example demonstrating the creation and initialization of generator objects and launching concurrent processes with fork-join construct in a testbench.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p143.jpg,True,"The image contains Verilog code defining properties for a simulation and associated `cover` statements. Here is the code in the image:

```verilog
property p_req1; // master 1&2 requesting
    @(posedge clk)
        $fell(req1) && $fell(req2) && req3;
endproperty

property p_req2; // master 2&3 r[e]questing
    @(posedge clk)
        $fell(req2) && $fell(req3) && req1;
endproperty

property p_req3; // master 1&3 requesting
    @(posedge clk)
        $fell(req3) && $fell(req1) && req2;
endproperty

property p_req123; // master 1&2&3 requesting
    @(posedge clk)
        $fell(req1) && $fell(req2) && $fell(req3);
endproperty

Each property should have a cover statement associated with it as shown below. The action block of the cover statement can be used to update register flags. In this case, every time the property is covered, a local register count is incremented. In the same clock, we check if the counter has reached a value of 3. If so, then the flag associated to that property is asserted. In other words, it is expected that each request combination occurs three times during simulation and if and when it happens, a flag associated with that specific request combination will be asserted.

c_req1: cover property(p_req1)
    begin
        creq1++;
        if (creq1 == 3) creq1_flag = 1'b1;
    end

c_req2: cover property(p_req2)
    begin
        creq2++;
        if (creq2 == 3) creq2_flag = 1'b1;
    end

c_req3: cover property(p_req3)
    begin
        creq3++;
        if (creq3 == 3) creq3_flag = 1'b1;
    end
```","
property p_req1; // master 1&2 requesting
    @(posedge clk)
        $fell(req1) && $fell(req2) && req3;
endproperty

property p_req2; // master 2&3 r[e]questing
    @(posedge clk)
        $fell(req2) && $fell(req3) && req1;
endproperty

property p_req3; // master 1&3 requesting
    @(posedge clk)
        $fell(req3) && $fell(req1) && req2;
endproperty

property p_req123; // master 1&2&3 requesting
    @(posedge clk)
        $fell(req1) && $fell(req2) && $fell(req3);
endproperty

Each property should have a cover statement associated with it as shown below. The action block of the cover statement can be used to update register flags. In this case, every time the property is covered, a local register count is incremented. In the same clock, we check if the counter has reached a value of 3. If so, then the flag associated to that property is asserted. In other words, it is expected that each request combination occurs three times during simulation and if and when it happens, a flag associated with that specific request combination will be asserted.

c_req1: cover property(p_req1)
    begin
        creq1++;
        if (creq1 == 3) creq1_flag = 1'b1;
    end

c_req2: cover property(p_req2)
    begin
        creq2++;
        if (creq2 == 3) creq2_flag = 1'b1;
    end

c_req3: cover property(p_req3)
    begin
        creq3++;
        if (creq3 == 3) creq3_flag = 1'b1;
    end
","The image displays excerpts from a technical book chapter including Verilog properties defined for various master request scenarios, alongside corresponding cover statements in a hardware verification context.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p63.jpg,True,"```verilog
reg [31:0] A;
integer I;
...
A = -1; // The default is to treat ""-1"" as a decimal integer.
I = -1; // Now, both A and I hold 32'hffff_ffff.
//
if ( I > 32'h0 )
    $display(""I is positive."");
else
    $display(""I is not positive.""); //Prints ""I is not positive.""
...
if ( A > 32'h0 )
    $display(""A is positive."");
else
    $display(""A is not positive.""); //Prints ""A is positive.""
...
```","
reg [31:0] A;
integer I;
...
A = -1; // The default is to treat ""-1"" as a decimal integer.
I = -1; // Now, both A and I hold 32'hffff_ffff.
//
if ( I > 32'h0 )
    $display(""I is positive."");
else
    $display(""I is not positive.""); //Prints ""I is not positive.""
...
if ( A > 32'h0 )
    $display(""A is positive."");
else
    $display(""A is not positive.""); //Prints ""A is positive.""
...
","""Understanding the Sign Bit and Relational Operators in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p509.jpg,True,"The image contains code related to Verilog, specifically for using the ACC (Access) routines from within a PLI (Programming Language Interface) application. Here is the code from the image:

```c
#include ""veriuser.h""             /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""             /* IEEE 1364 PLI ACC routine library */
/***********************************************************************
 * calltf application
 ***********************************************************************/
void PLIbook_PortInfo_calltf()
{
    handle mod_h, port_h, loconn_h, hiconn_h;
    acc_initialize();
    acc_configure(accDisplayWarnings, ""true"");

    mod_h = acc_handle_tfarg(1);

    io_printf(""\nModule %s:\n"", acc_fetch_defname(mod_h));
    io_printf("" Instance name: %s\n"", acc_fetch_fullname(mod_h));

    switch ( acc_fetch_fulltype(mod_h) ) {
        case accTopModule:
            io_printf("" Module type: top-level\n"");
            break;
        case accModuleInstance:
            io_printf("" Module type: module instance\n"");
            break;
        case accCellInstance:
            io_printf("" Module type: cell module\n"");
            break;
        default:
            io_printf("" Module type: unknown\n"");
    }

    io_printf(""\n Ports:\n"");
    port_h = null;
    while (port_h = acc_next_port(mod_h, port_h)) {
        io_printf("" %-8s"", acc_fetch_name(port_h) );
        io_printf(""%2d-bit "", acc_fetch_size(port_h) );
    }
}
```

This code snippet is part of an example demonstrating how to traverse hierarchical module ports in a Verilog design using the ACC Library of the PLI.","ude ""veriuser.h""             /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""             /* IEEE 1364 PLI ACC routine library */
/***********************************************************************
 * calltf application
 ***********************************************************************/
void PLIbook_PortInfo_calltf()
{
    handle mod_h, port_h, loconn_h, hiconn_h;
    acc_initialize();
    acc_configure(accDisplayWarnings, ""true"");

    mod_h = acc_handle_tfarg(1);

    io_printf(""\nModule %s:\n"", acc_fetch_defname(mod_h));
    io_printf("" Instance name: %s\n"", acc_fetch_fullname(mod_h));

    switch ( acc_fetch_fulltype(mod_h) ) {
        case accTopModule:
            io_printf("" Module type: top-level\n"");
            break;
        case accModuleInstance:
            io_printf("" Module type: module instance\n"");
            break;
        case accCellInstance:
            io_printf("" Module type: cell module\n"");
            break;
        default:
            io_printf("" Module type: unknown\n"");
    }

    io_printf(""\n Ports:\n"");
    port_h = null;
    while (port_h = acc_next_port(mod_h, port_h)) {
        io_printf("" %-8s"", acc_fetch_name(port_h) );
        io_printf(""%2d-bit "", acc_fetch_size(port_h) );
    }
}
","""Example of Verilog ACC Routine Library usage for hierarchy traversal and module port information extraction.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p157.jpg,True,"Here is the Verilog code from the image:

```verilog
// functional description of master

// Block level checks for prototype debugging

`ifdef master_debug

d_a_master_start1:
    assert property(p_master_start1)
    else
        a_master_start1_flag = 1'b1;

d_a_master_start2:
    assert property(p_master_start2)
    else
        a_master_start2_flag = 1'b1;

d_a_master_stop1:
    assert property(p_master_stop1)
    else
        a_master_stop1_flag = 1'b1;

d_a_master_stop2:
    assert property(p_master_stop2)
    else
        a_master_stop2_flag = 1'b1;

d_a_master_data1:
    assert property(p_master_data1)
    else
        a_master_data1_flag = 1'b1;

d_a_master_data2:
    assert property(p_master_data2)
    else
        a_master_data2_flag = 1'b1;

d_a_master_data01:
    assert property(p_master_data01)
    else
        a_master_data01_flag = 1'b1;

d_a_master_data02:
    assert property(p_master_data02)
    else
        a_master_data02_flag = 1'b1;

`endif

endmodule
```

This code snippet seems to be from a portion of a textbook or a manual discussing block-level checks for debugging a Verilog module. The use of `assert property()` is part of SystemVerilog Assertions (SVA), used for formally verifying properties in simulation.","
// functional description of master

// Block level checks for prototype debugging

`ifdef master_debug

d_a_master_start1:
    assert property(p_master_start1)
    else
        a_master_start1_flag = 1'b1;

d_a_master_start2:
    assert property(p_master_start2)
    else
        a_master_start2_flag = 1'b1;

d_a_master_stop1:
    assert property(p_master_stop1)
    else
        a_master_stop1_flag = 1'b1;

d_a_master_stop2:
    assert property(p_master_stop2)
    else
        a_master_stop2_flag = 1'b1;

d_a_master_data1:
    assert property(p_master_data1)
    else
        a_master_data1_flag = 1'b1;

d_a_master_data2:
    assert property(p_master_data2)
    else
        a_master_data2_flag = 1'b1;

d_a_master_data01:
    assert property(p_master_data01)
    else
        a_master_data01_flag = 1'b1;

d_a_master_data02:
    assert property(p_master_data02)
    else
        a_master_data02_flag = 1'b1;

`endif

endmodule
","""Snippet of Verilog code implementing block-level checks for debugging a master module with assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p278.jpg,True,"Here is the Verilog code extracted from the image:

```verilog
default clocking @(posedge clk);
endclocking
sequence req;
  start_req ##1 end_req;
endsequence
sequence end_ack;
  empty_slot[->1] ##1 no_conflict;
endsequence
sequence ack;
  enable ##[1:10] end_ack.triggered;
endsequence
a2: assert property (req |-> busy_until_with ack.triggered);
```

The image contains partial code for Example 11.34 and the beginning of Example 11.35, but the latter is incomplete.","
default clocking @(posedge clk);
endclocking
sequence req;
  start_req ##1 end_req;
endsequence
sequence end_ack;
  empty_slot[->1] ##1 no_conflict;
endsequence
sequence ack;
  enable ##[1:10] end_ack.triggered;
endsequence
a2: assert property (req |-> busy_until_with ack.triggered);
","""Exploring Advanced Sequence Usage in Verilog for Sequence Matching and Assertions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p274.jpg,True,"The image includes a snippet of Verilog code as part of an example labeled ""Sample 7.8 Dynamic thread creation"". Here is the code from the image:

```verilog
program automatic test(bus_ifc.TB bus);
    // Code for interface not shown
    task check_trans(input Transaction tr);
        fork
            begin
                wait (bus.cb.data == tr.data);
                $display(""%0t: data match %d"", $time, tr.data);
            end
        join_none  // Spawn thread, don't block
    endtask

    Transaction tr;

    initial begin
        repeat (10) begin
            tr = new();                        // Create a random transaction
            `SV_RAND_CHECK(tr.randomize());
            transmit(tr);                      // Send transaction into the DUT
            check_trans(tr);                   // Wait for reply from DUT
        end
        #100; // Wait for final transaction to complete
    end
endprogram
```

This code demonstrates the creation of dynamic threads in a test program for verifying a design under test (DUT) in SystemVerilog.","
program automatic test(bus_ifc.TB bus);
    // Code for interface not shown
    task check_trans(input Transaction tr);
        fork
            begin
                wait (bus.cb.data == tr.data);
                $display(""%0t: data match %d"", $time, tr.data);
            end
        join_none  // Spawn thread, don't block
    endtask

    Transaction tr;

    initial begin
        repeat (10) begin
            tr = new();                        // Create a random transaction
            `SV_RAND_CHECK(tr.randomize());
            transmit(tr);                      // Send transaction into the DUT
            check_trans(tr);                   // Wait for reply from DUT
        end
        #100; // Wait for final transaction to complete
    end
endprogram
","""Example of SystemVerilog code featuring dynamic thread creation and transaction checking in a testbench scenario.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p284.jpg,True,"The image contains Verilog code, which is a hardware description language used for electronic system design. Here is the code from the image:

```verilog
module test;

initial
begin
    $hello();
    #10 $stop;
    $finish;
end

endmodule
```

This code defines a simple Verilog module named `test` that calls a system task `$hello()`, waits for 10 time units (`#10`), and then calls `$stop` to stop the simulation, followed by `$finish` to end the simulation. The ""$hello()"" task is likely a user-defined PLI (Programming Language Interface) task for demonstration purposes.","
module test;

initial
begin
    $hello();
    #10 $stop;
    $finish;
end

endmodule
","Caption: ""Example of Verilog code demonstrating the use of a PLI application in a simulation environment, with results shown in a Cadence Verilog-XL simulator.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p88.jpg,True,"The image contains Verilog code snippets. Here is the code from the image:

```verilog
always@(a, b, sel)
    if (sel=='1'b1)
        z = a;
    else z = b;
always@(*)
    if (sel=='1'b1)
        z = a;
    else z = b;
always@(sel)
    if (sel=='1'b1)
        z = a;
    else z = b;
always@(a, b)
    if (sel=='1'b1)
        z = a;
    else z = b;
```

These snippets represent different `always` blocks in Verilog, demonstrating how the sensitivity list affects the behavior of the block.","
always@(a, b, sel)
    if (sel=='1'b1)
        z = a;
    else z = b;
always@(*)
    if (sel=='1'b1)
        z = a;
    else z = b;
always@(sel)
    if (sel=='1'b1)
        z = a;
    else z = b;
always@(a, b)
    if (sel=='1'b1)
        z = a;
    else z = b;
","Caption: Excerpt from a Verilog tutorial explaining expressions and statements, including details on always blocks, latches, and muxes in digital VLSI design.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p95.jpg,True,"The image contains Verilog code which describes properties using the SystemVerilog Assertions (SVA) syntax. Here is the code visible in the image:

```verilog
`define free (a && b && c && d)

property p_nest;
  @(posedge clk) $fell(a) |->
    ##1 (!b && !c && !d) |->
    ##[6:10] `free;
endproperty

a_nest: assert property(p_nest);

property p_nest1;
  @(posedge clk) $fell(a) ##1 (!b && !c && !d);
```

This code defines properties for design verification, using the `assert` statement to ensure certain conditions hold true in a Verilog simulation over a sequence of clock cycles. The macros and properties encapsulate temporal assertions regarding signal behavior relative to clock edges and specific conditions, vital for checking correct timing and logic in digital circuits.
","
`define free (a && b && c && d)

property p_nest;
  @(posedge clk) $fell(a) |->
    ##1 (!b && !c && !d) |->
    ##[6:10] `free;
endproperty

a_nest: assert property(p_nest);

property p_nest1;
  @(posedge clk) $fell(a) ##1 (!b && !c && !d);
","The image shows an excerpt from a technical document discussing Verification using SystemVerilog Assertions (SVA), describing examples of Success and Failure checks, and a section on Nested Implication in Verilog code.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p287.jpg,True,"The image contains Verilog code, and here it is:

```verilog
module multiply_clocked(input logic clk1, clk2, a, b, c);
    a5: assert property (
        @(posedge clk1) a |=> (@posedge clk2) b
    );
endmodule
``` 

The code snippet shows a Verilog module with a concurrent assertion that involves multiple clock domains, named `multiply_clocked`. The assertion `a5` uses the implication (`|=>`) operator to state a property that must hold between the positive edges (`posedge`) of `clk1` and `clk2`.","
module multiply_clocked(input logic clk1, clk2, a, b, c);
    a5: assert property (
        @(posedge clk1) a |=> (@posedge clk2) b
    );
endmodule
","""Example of a Verilog module with a multiply clocked assertion and its waveform representation.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p378.jpg,True,"```verilog
// Requires DBus constant during the entire positive phase:
// ref. edge  data event  lead shift  lag shift
$nochange(posedge Clk,  DBus,  0,  0);

// Violation starts 1 before negedge; ends 2 after posedge:
specparam MinSetup = 1, MinHold = 2;
$nochange(negedge Clk, EBus, MinSetup, MinHold);

// Shift the check 1 unit later:
specparam MinSetup = -1, MinHold = 1;
$nochange(negedge Clk, FBus, MinSetup, MinHold);
```

Note: $nochange apparently has been implemented recently only in the new VCS simulator.","
// Requires DBus constant during the entire positive phase:
// ref. edge  data event  lead shift  lag shift
$nochange(posedge Clk,  DBus,  0,  0);

// Violation starts 1 before negedge; ends 2 after posedge:
specparam MinSetup = 1, MinHold = 2;
$nochange(negedge Clk, EBus, MinSetup, MinHold);

// Shift the check 1 unit later:
specparam MinSetup = -1, MinHold = 1;
$nochange(negedge Clk, FBus, MinSetup, MinHold);
","""Examples of Verilog specparam usage for nochange timing checks in digital VLSI design and a cautionary note on negative time limits for setup and hold time checks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p70.jpg,True,"```verilog
module logic_data_type(input logic rst_h);
    parameter CYCLE = 20;
    logic q, q_l, d, clk, rst_l;
    initial begin
        clk = 0; // Procedural assignment
        forever #(CYCLE/2) clk = ~clk;
    end

    assign rst_l = ~rst_h; // Continuous assignment
    not n1(q_l, q);        // q_l is driven by gate
    my_dff d1(q, d, clk, rst_l); // q is driven by module

endmodule
```","
module logic_data_type(input logic rst_h);
    parameter CYCLE = 20;
    logic q, q_l, d, clk, rst_l;
    initial begin
        clk = 0; // Procedural assignment
        forever #(CYCLE/2) clk = ~clk;
    end

    assign rst_l = ~rst_h; // Continuous assignment
    not n1(q_l, q);        // q_l is driven by gate
    my_dff d1(q, d, clk, rst_l); // q is driven by module

endmodule
","""Exploring the SystemVerilog logic type and its usage in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p350.jpg,True,"The image contains some code snippets written in Verilog. Here is the code provided in the image:

```verilog
assign Out = 1'b1;

assign OutNarrow = 2'b10;
```

These are Verilog statements used to assign constant values to signals `Out` and `OutNarrow`. The first line is assigning a 1-bit value `1` to `Out`, while the second line is assigning a 2-bit value `10` to `OutNarrow`. These are likely examples within a broader context of a digital design tutorial or exercise.","
assign Out = 1'b1;

assign OutNarrow = 2'b10;
","""Exploring Hierarchies and Clock Synchronization in Verilog Simulations""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p81.jpg,True,"```verilog
assign a = ...;
assign b = ...;
always_comb a1: assert (a == b);
```","
assign a = ...;
assign b = ...;
always_comb a1: assert (a == b);
","""Exploring Simulation Glitches with Immediate Assertions in Verilog Code""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p436.jpg,True,"```verilog
localparam[2:0]
    emptys = 3'b000, // all 0 = emptys.
    _emptys = 3'b010, // LSB 0 = close to emptys.
    normals = 3'b011, // _emptys < normals < a_fulls.
    a_fulls = 3'b101, // MSB 1 = close to fulls.
    fulls = 3'b111; // all 1 = fulls
```","
localparam[2:0]
    emptys = 3'b000, // all 0 = emptys.
    _emptys = 3'b010, // LSB 0 = close to emptys.
    normals = 3'b011, // _emptys < normals < a_fulls.
    a_fulls = 3'b101, // MSB 1 = close to fulls.
    fulls = 3'b111; // all 1 = fulls
","Caption: ""Refinement of a FIFO state machine in Verilog for correct synthesis, including renaming states and local parameter sizing, alongside instructions for simulating the FIFO serializer.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p180.jpg,True,"The image contains two segments of Verilog code as part of a textbook or educational material. Here are the code excerpts:

First code block:
```verilog
property p_forbid_trans3c;
    @(posedge clk)
        (((state == IDLE1) || (state == IDLE2))
        && reset) |->
            $past (state== IDLE3) == 0;
endproperty

a_forbid_trans3c:
    assert property(p_forbid_trans3c);

c_forbid_trans3c:
    cover property(p_forbid_trans3c);
```

Second code block:
```verilog
property p_req_gnt;
    @(posedge clk)
        (({req1 || req2 || req3} && reset) |->
            ##1 {gnt1 || gnt2 || gnt3});
endproperty

a_req_gnt: assert property(p_req_gnt);

c_req_gnt: cover property(p_req_gnt);
```

Below each property definition, there are instances where the property is utilized within the context of assertions and coverage points (`a_forbid_trans3c`, `c_forbid_trans3c`, `a_req_gnt`, `c_req_gnt`). The comments and the text describe the function and purpose of each property, but they do not represent actual code.","
property p_forbid_trans3c;
    @(posedge clk)
        (((state == IDLE1) || (state == IDLE2))
        && reset) |->
            $past (state== IDLE3) == 0;
endproperty

a_forbid_trans3c:
    assert property(p_forbid_trans3c);

c_forbid_trans3c:
    cover property(p_forbid_trans3c);


property p_req_gnt;
    @(posedge clk)
        (({req1 || req2 || req3} && reset) |->
            ##1 {gnt1 || gnt2 || gnt3});
endproperty

a_req_gnt: assert property(p_req_gnt);

c_req_gnt: cover property(p_req_gnt);
","""SystemVerilog Assertions and Waveform for Granting Bus Requests""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p194.jpg,True,"```
bind au_comp au_comp_chk a1 (clk, reset, enable1, enable2, d1, d2, d3, d4, d5, d6, d7, d8, o1, o2, o3, o4, o5, o6, o7, o8);
```","u_comp au_comp_chk a1 (clk, reset, enable1, enable2, d1, d2, d3, d4, d5, d6, d7, d8, o1, o2, o3, o4, o5, o6, o7, o8);
","""Verilog code excerpt and waveform for a WHT (Walsh-Hadamard Transform) checker in a digital design verification context.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p119.jpg,True,"```
$TrapXZ(ipin, ipin, qpin);
```","Z(ipin, ipin, qpin);
","""Excerpt from a technical document discussing RTL simulation, focusing on assertion monitors and providing an example of a Verilog code snippet related to simulation of tristate bus signals.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p65.jpg,True,"The image contains code that appears to be written in SystemVerilog, which is used for hardware description and verification. Here is the code extract from the image:

```verilog
task run();
  done = 0;
  while (!done) begin
    // Get the next transaction
    // Make transformations
    // Send out transactions
  end
endtask
```

This is a basic example of a task in SystemVerilog, which represents a portion of what appears to be a driver or transactor, used in a testbench environment for simulating and verifying hardware designs.","
task run();
  done = 0;
  while (!done) begin
    // Get the next transaction
    // Make transformations
    // Send out transactions
  end
endtask
","Caption: ""Educational material explaining the creation of a simple driver in Verilog with an example code snippet for a basic transactor task.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p94.jpg,True,"The image contains a code snippet written in Verilog. Here is the code as it appears in the image:

```verilog
module top;
  bit sys_clk;
  global clocking GCLK @ (edge sys_clk);
  endclocking
  // code to animate sys_clk in simulation
  ...
  mod1 mod1_inst();
  mod2 mod2_inst();
endmodule

module mod1();
  logic a, b;
  ...
  m_check m_check_inst(a, b);
endmodule

module mod2();
  logic x, y, clk;
  global clocking @ (posedge clk);
  endclocking
  ...
  m_check m_check_inst(x, y);
endmodule

module m_check(input logic a, b);
  a_simple: assert property (@$global_clock a |=> b);
endmodule
```

This code snippet is demonstrating the use of global clocking in a SystemVerilog design. The global clocking declaration is used to define a clocking event for multiple components in a design hierarchy. The `assert property` statement inside of `m_check` module shows how an assertion is made using the global clocking event.","
module top;
  bit sys_clk;
  global clocking GCLK @ (edge sys_clk);
  endclocking
  // code to animate sys_clk in simulation
  ...
  mod1 mod1_inst();
  mod2 mod2_inst();
endmodule

module mod1();
  logic a, b;
  ...
  m_check m_check_inst(a, b);
endmodule

module mod2();
  logic x, y, clk;
  global clocking @ (posedge clk);
  endclocking
  ...
  m_check m_check_inst(x, y);
endmodule

module m_check(input logic a, b);
  a_simple: assert property (@$global_clock a |=> b);
endmodule
","""Verilog code example demonstrating global clocking declaration and usage in different modules.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p80.jpg,True,"The image contains Verilog code. Here is the text:

```verilog
always_comb begin
  // ...
  a1: assert (a == b) begin
    a1_success++;
    $info(""a1: a and b have value %b"", a);
  end
  else begin
    a1_failure++;
    $error(""a1 failure: a = %b, b = %b"", a, b);
  end
end
```

This snippet demonstrates the usage of an immediate assertion within an `always_comb` block in Verilog.","
always_comb begin
  // ...
  a1: assert (a == b) begin
    a1_success++;
    $info(""a1: a and b have value %b"", a);
  end
  else begin
    a1_failure++;
    $error(""a1 failure: a = %b, b = %b"", a, b);
  end
end
","Caption: ""Example of an immediate assertion in Verilog with corresponding timing diagram""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p71.jpg,True,"The image contains two code samples in Verilog. Here are the transcriptions:

Sample 2.2 Signed data types:
```verilog
bit b;                // 2-state, single-bit
bit [31:0] b32;       // 2-state, 32-bit unsigned integer
int unsigned ui;      // 2-state, 32-bit unsigned integer
int i;                // 2-state, 32-bit signed integer
byte b8;              // 2-state, 8-bit signed integer
shortint s;           // 2-state, 16-bit signed integer
longint l;            // 2-state, 64-bit signed integer
integer i4;           // 4-state, 32-bit signed integer
time t;               // 4-state, 64-bit unsigned integer
real r;               // 2-state, double precision floating point
```

Sample 2.3 Checking for 4-state values:
```verilog
if ($isunknown(iport) == 1)
    $display(""@%0t: 4-state value detected on iport %b"",
             $time, iport);
```

Remember to follow the proper Verilog syntax and semantics when incorporating these examples into your own work.","
bit b;                // 2-state, single-bit
bit [31:0] b32;       // 2-state, 32-bit unsigned integer
int unsigned ui;      // 2-state, 32-bit unsigned integer
int i;                // 2-state, 32-bit signed integer
byte b8;              // 2-state, 8-bit signed integer
shortint s;           // 2-state, 16-bit signed integer
longint l;            // 2-state, 64-bit signed integer
integer i4;           // 4-state, 32-bit signed integer
time t;               // 4-state, 64-bit unsigned integer
real r;               // 2-state, double precision floating point


if ($isunknown(iport) == 1)
    $display(""@%0t: 4-state value detected on iport %b"",
             $time, iport);
",Educational material on Verilog data types and handling 4-state values in simulation.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p181.jpg,True,"```verilog
property p_req_gnt_1;
  @(posedge clk) (!((req1 && reset)) |-> ##1 gnt1;
endproperty

c_req_gnt_1: cover property(p_req_gnt_1);

property p_req_gnt_2;
  @(posedge clk) (!((req2 && reset)) |-> ##1 gnt2;
endproperty

c_req_gnt_2: cover property(p_req_gnt_2);

property p_req_gnt_3;
  @(posedge clk) (!((req3 && reset)) |-> ##1 gnt3;
endproperty
```","
property p_req_gnt_1;
  @(posedge clk) (!((req1 && reset)) |-> ##1 gnt1;
endproperty

c_req_gnt_1: cover property(p_req_gnt_1);

property p_req_gnt_2;
  @(posedge clk) (!((req2 && reset)) |-> ##1 gnt2;
endproperty

c_req_gnt_2: cover property(p_req_gnt_2);

property p_req_gnt_3;
  @(posedge clk) (!((req3 && reset)) |-> ##1 gnt3;
endproperty
","Caption: ""Waveform and SystemVerilog Assertions (SVA) for verifying the fairness of an arbiter in a Finite State Machine (FSM)""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p437.jpg,True,"The image contains the following Verilog code snippet:

```verilog
reg StateClockRaw;
wire StateClock; // See the next code example below.
// ...
always@(ClkR or ClkW)
    StateClockRaw = !(ClkR && ClkW);
```","
reg StateClockRaw;
wire StateClock; // See the next code example below.
// ...
always@(ClkR or ClkW)
    StateClockRaw = !(ClkR && ClkW);
","""Discussion on creating a synthesizable state clock generator in Verilog with considerations of race conditions and clock drift.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p80.jpg,True,"```
a28: assert property(p28);
```","ssert property(p28);
","""Waveform illustration for SVA (SystemVerilog Assertions) using the 'intersect' construct and analysis of assertion behavior in simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p286.jpg,True,"The image contains code in Verilog, as follows:

Figure 12.5 shows a module with default clocking and unlocked property declaration:
```verilog
module various_clocks(input logic clk1, clk2, a, b, c);
  default clocking NCLK1 @(negedge clk1); endclocking
  property p1; a |=> b; endproperty
  a2: assert property(p1);
  a3: assert property(a[*2] |=> c);
  a4: assert property(@(posedge clk2) p1);
endmodule
```

Figure 12.6 shows a module with default clocking and clocked property declaration:
```verilog
module various_clocks(input logic clk1, clk2, a, b, c);
  default clocking NCLK1 @(negedge clk1); endclocking
  property p1; @(posedge clk2) a |=> b; endproperty
  a2: assert property(a |=> b);
  a3: assert property(a[*2] |=> c);
  a4: assert property(p1);
endmodule
```

Figure 12.7 illustrates a module with default clocking and clocked property declaration with event argument:
```verilog
module various_clocks(input logic clk1, clk2, a, b, c);
  default clocking NCLK1 @(negedge clk1); endclocking
  property p1(event ev = $inferred_clock);
    @ev a |=> b;
  endproperty
  a2: assert property(p1);
  a3: assert property(a[*2] |=> c);
  a4: assert property(p1.(ev(posedge clk2)));
endmodule
```

This code is demonstrating different ways to declare modules with various clocking and property declarations in the Verilog Hardware Description Language (HDL).","
module various_clocks(input logic clk1, clk2, a, b, c);
  default clocking NCLK1 @(negedge clk1); endclocking
  property p1; a |=> b; endproperty
  a2: assert property(p1);
  a3: assert property(a[*2] |=> c);
  a4: assert property(@(posedge clk2) p1);
endmodule


module various_clocks(input logic clk1, clk2, a, b, c);
  default clocking NCLK1 @(negedge clk1); endclocking
  property p1; @(posedge clk2) a |=> b; endproperty
  a2: assert property(a |=> b);
  a3: assert property(a[*2] |=> c);
  a4: assert property(p1);
endmodule


module various_clocks(input logic clk1, clk2, a, b, c);
  default clocking NCLK1 @(negedge clk1); endclocking
  property p1(event ev = $inferred_clock);
    @ev a |=> b;
  endproperty
  a2: assert property(p1);
  a3: assert property(a[*2] |=> c);
  a4: assert property(p1.(ev(posedge clk2)));
endmodule
",Verilog code examples showing modules with various clocking strategies for property declarations.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p285.jpg,True,"The image contains a snippet of Verilog code which is written as follows:

```verilog
module test;
  reg a, b, ci;
  wire sum, co;
  ...
  initial
  begin
    ...
    $show_value(sum);
  end
endmodule
```

The Verilog code is for a module named `test` and it defines some registers (`reg`) and wires. It also shows the usage of a system task `$show_value(sum);` within an `initial` block.","
module test;
  reg a, b, ci;
  wire sum, co;
  ...
  initial
  begin
    ...
    $show_value(sum);
  end
endmodule
","Caption: ""Example of using the $show_value system task in Verilog code, which integrates with C routines using the Programming Language Interface (PLI).""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p292.jpg,True,"```verilog
a_strange_clk: assert property (
    @(posedge clk)
    clk
    else $error(""FAIL: clk=%b"", clk);
);
```
This is the Verilog code snippet presented in the image.","
a_strange_clk: assert property (
    @(posedge clk)
    clk
    else $error(""FAIL: clk=%b"", clk);
);
","""Exploring Advanced Clocking Details and Preponed Value Sampling in Verilog Assertions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p94.jpg,True,"```verilog
property arb (a, b, c, d);
    @(posedge clk) ($fell(a) ##[2:5] $fell(b)) |-> 
    ##1 ($fell(c) && $fell(d)) ##0
    (!c&&d) [*4] ##1 (c&&d) ##1 b;
endproperty

a36_1: assert property(arb(a1, b1, c1, d1));
a36_2: assert property(arb(a2, b2, c2, d2));
a36_3: assert property(arb(a3, b3, c3, d3));
```","
property arb (a, b, c, d);
    @(posedge clk) ($fell(a) ##[2:5] $fell(b)) |-> 
    ##1 ($fell(c) && $fell(d)) ##0
    (!c&&d) [*4] ##1 (c&&d) ##1 b;
endproperty

a36_1: assert property(arb(a1, b1, c1, d1));
a36_2: assert property(arb(a2, b2, c2, d2));
a36_3: assert property(arb(a3, b3, c3, d3));
","""Example of SystemVerilog Assertions (SVA) and their evaluation in simulation waveform.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p89.jpg,True,"The image contains several Verilog code snippets. Here they are:

Nonstandard latch without procedural control construct:
```verilog
always@(a, v)  // Typo! always@(a, b) intended.
    z = a | b;
```

Verilog simple transparent latch:
```verilog
always@(D, Sel)
    if (Sel=='b1)
        Q = D;
```

Continuous assignment for a synthesizable latch:
```verilog
assign z = (Sel=='b1') ? D : z;
```","
always@(a, v)  // Typo! always@(a, b) intended.
    z = a | b;


always@(D, Sel)
    if (Sel=='b1)
        Q = D;


assign z = (Sel=='b1') ? D : z;
","""Explanation of Verilog code for simple transparent latch design and its synthesizability.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p156.jpg,True,"The image contains Verilog code. Here is the text from the image:

```verilog
output [8:0] data_c;
input [7:0] data_o;

parameter master_sva = 1'b1;
parameter master_sva_severity = 1'b1;

// functional description of master

// Block level SVA checks

endmodule

module master (ask_for_it, clk, req, gnt, frame,
irdy, trdy, data_c, r_sel, data_o,
a_master_start1_flag, a_master_start2_flag,
a_master_stop1_flag, a_master_stop2_flag,
a_master_data1_flag, a_master_data2_flag,
a_master_data01_flag, a_master_data02_flag);

input clk, gnt, ask_for_it;
input [1:0] trdy;
output req, frame, irdy, r_sel;
output [8:0] data_c;
input [7:0] data_o;

// debug pins for FPGA prototyping
output a_master_start1_flag;
output a_master_start2_flag;
output a_master_stop1_flag;
output a_master_stop2_flag;
output a_master_data1_flag;
output a_master_data2_flag;
output a_master_data01_flag;
output a_master_data02_flag;

parameter master_sva = 1'b1;
parameter master_sva_severity = 1'b1;
```

This code is a snippet from a Verilog hardware description, defining a module named `master` with various input and output ports, some parameters, and an indication of block-level SVA (SystemVerilog Assertion) checks. The second part of the code snippet also includes some debugging pins specified for FPGA prototyping.","
output [8:0] data_c;
input [7:0] data_o;

parameter master_sva = 1'b1;
parameter master_sva_severity = 1'b1;

// functional description of master

// Block level SVA checks

endmodule

module master (ask_for_it, clk, req, gnt, frame,
irdy, trdy, data_c, r_sel, data_o,
a_master_start1_flag, a_master_start2_flag,
a_master_stop1_flag, a_master_stop2_flag,
a_master_data1_flag, a_master_data2_flag,
a_master_data01_flag, a_master_data02_flag);

input clk, gnt, ask_for_it;
input [1:0] trdy;
output req, frame, irdy, r_sel;
output [8:0] data_c;
input [7:0] data_o;

// debug pins for FPGA prototyping
output a_master_start1_flag;
output a_master_start2_flag;
output a_master_stop1_flag;
output a_master_stop2_flag;
output a_master_data1_flag;
output a_master_data2_flag;
output a_master_data01_flag;
output a_master_data02_flag;

parameter master_sva = 1'b1;
parameter master_sva_severity = 1'b1;
","""Verilog Code Snippet Showing SVA Simulation Methodology for FPGA Prototyping""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p508.jpg,True,"The image contains several snippets of Verilog code. Here are the pieces of code visible in the image:

1.
```verilog
module m1 (a[0]);
input [7:0] a;
wire [7:0] a;
...
```

2.
```verilog
module m1 (a[7:4], a[3:0]);
input [7:0] a;
wire [7:0] a;
...
```

3.
```verilog
module m1 (.a(n,m));
input [3:0] n;
output [3:0] m;
wire [3:0] n, m;
...
```

4.
```verilog
wire scalared [63:0] data_bus;
```

5.
```verilog
wire vectored [31:0] address_bus;
```","
module m1 (a[0]);
input [7:0] a;
wire [7:0] a;
...


module m1 (a[7:4], a[3:0]);
input [7:0] a;
wire [7:0] a;
...


module m1 (.a(n,m));
input [3:0] n;
output [3:0] m;
wire [3:0] n, m;
...


wire scalared [63:0] data_bus;


wire vectored [31:0] address_bus;
","Excerpt from ""The Verilog PLI Handbook"" discussing access methods to vector signals in Verilog modules, illustrating bit-select, part-select, and concatenated port connections.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p62.jpg,True,"```verilog
assign #2 X = A[0] && B[0] || !Clock;

always@(A[0], B[0]) Xreg = A[0] && B[0] || !Clock;

always@(posedge Clock) Yreg = a && b;
```
These are the examples of Verilog code from the image.","
assign #2 X = A[0] && B[0] || !Clock;

always@(A[0], B[0]) Xreg = A[0] && B[0] || !Clock;

always@(posedge Clock) Yreg = a && b;
","""Exploring Verilog Continuous Assignments and Vectors in Digital VLSI Design""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p57.jpg,True,"The image contains Verilog code. Here it is:

```verilog
interface data (input logic clk);
    logic [7:0] a, b;
    logic active_a, active_b;
endinterface : data

module producer (data i);
    initial begin
        i.active_a = 1'b1;
        i.active_b = 1'b0;
    end
    always @(posedge i.clk) begin
        i.active_a <= !i.active_b;
        i.active_b <= !i.active_a;
        i.a <= $random;
        i.b <= $random;
    end
endmodule : producer

module consumer (data i, output logic [7:0] out);
    always @(posedge i.clk) begin
        if (i.active_a) out <= i.a;
        if (i.active_b) out <= i.b;
    end
endmodule : consumer

module top;
    logic clk = 0;
    logic [7:0] result;
    initial repeat (100) #5 clk = !clk;
    data ifc(clk);
    producer prod(.i(ifc));
    consumer cons(.i(ifc), .out(result));
endmodule : top
```

This code is part of a textbook example that explains the use of interfaces in Verilog. The interface is defined to encapsulate signals between a producer and a consumer module. The producer generates random data on a clock edge, and the consumer module passes this data to its output when active. The top module ties everything together.","
interface data (input logic clk);
    logic [7:0] a, b;
    logic active_a, active_b;
endinterface : data

module producer (data i);
    initial begin
        i.active_a = 1'b1;
        i.active_b = 1'b0;
    end
    always @(posedge i.clk) begin
        i.active_a <= !i.active_b;
        i.active_b <= !i.active_a;
        i.a <= $random;
        i.b <= $random;
    end
endmodule : producer

module consumer (data i, output logic [7:0] out);
    always @(posedge i.clk) begin
        if (i.active_a) out <= i.a;
        if (i.active_b) out <= i.b;
    end
endmodule : consumer

module top;
    logic clk = 0;
    logic [7:0] result;
    initial repeat (100) #5 clk = !clk;
    data ifc(clk);
    producer prod(.i(ifc));
    consumer cons(.i(ifc), .out(result));
endmodule : top
","Caption: ""Verilog interface example illustrating the communication between producer and consumer modules.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p275.jpg,True,"The image contains a snippet of Verilog/SystemVerilog code. Here is the text of the code:

```verilog
program no_auto;
    initial begin
        for (int j=0; j<3; j++)
            fork
                $write(j); // Bug - prints final value of index
            join_none
            #0 $display;
    end
endprogram
```","
program no_auto;
    initial begin
        for (int j=0; j<3; j++)
            fork
                $write(j); // Bug - prints final value of index
            join_none
            #0 $display;
    end
endprogram
","Caption: ""Example of a common bug in SystemVerilog when using fork...join_none inside a for-loop which results in the loop variable being overwritten prematurely.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p279.jpg,True,"The image contains code in the Verilog hardware description language. Here is the code presented:

```verilog
@(posedge clk) (pswitch && pmode == normal ##1 !pswitch[*] ##0 ready);
endsequence : begin_mode
initial begin: l1
  @begin_mode setup(mode);
  $display(""Mode started"");
end
//...
endmodule
```

This code snippet includes a sequence definition with the `endsequence` keyword and an `initial` block containing a label `l1`. The `@begin_mode` appears to be an event trigger related to the sequence defined earlier, and the `$display` statement is used to print out a message.","
@(posedge clk) (pswitch && pmode == normal ##1 !pswitch[*] ##0 ready);
endsequence : begin_mode
initial begin: l1
  @begin_mode setup(mode);
  $display(""Mode started"");
end
//...
endmodule
","The image shows a page from a textbook or manual that explains the concept of ""Sequence as Events"" in Verilog, with an example of a sequence named `begin_mode` used for event control in an initial procedure. It also includes exercises related to SystemVerilog Assertions (SVA) and Property Specification Language (PSL) operators.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p261.jpg,True,"Here is the Verilog code from the image:

```verilog
class EthCfg;

  rand bit [3:0] in_use;             // Ports used in test:3,2,1,0
  rand bit [47:0] mac_addr[4];       // MAC addresses
  rand bit [3:0] is_100;             // 100mb mode for ports 3,2,1,0
  rand uint run_for_n_frames;        // # frames in test

  // Force some addr bits when running in unicast mode
  constraint local_unicast {
    foreach (mac_addr[i])
      mac_addr[i][41:40] == 2'b00;
  }

  constraint reasonable {            // Limit test length
    run_for_n_frames inside {[1:100]};
  }

endclass

class Environment;

  EthCfg cfg;
  EthGen gen[4];
  EthMii drv[4];

  function new();
    cfg = new();                     // Construct the cfg
  endfunction

  // Use random configuration to build the environment
  function void build();
    foreach (gen[i]) begin
      gen[i] = new();
      drv[i] = new();
      if (cfg.is_100[i])
        drv[i].set_speed(100);
    end
  endfunction

endclass
```

This code defines two classes, `EthCfg` and `Environment`, meant to configure an Ethernet-based testing environment. The `EthCfg` class includes randomized properties such as used ports, MAC addresses, speed indication, and number of frames for a test, as well as constraints for the randomization. The `Environment` class uses an instance of `EthCfg` to configure other objects representing Ethernet generators and drivers.","
class EthCfg;

  rand bit [3:0] in_use;             // Ports used in test:3,2,1,0
  rand bit [47:0] mac_addr[4];       // MAC addresses
  rand bit [3:0] is_100;             // 100mb mode for ports 3,2,1,0
  rand uint run_for_n_frames;        // # frames in test

  // Force some addr bits when running in unicast mode
  constraint local_unicast {
    foreach (mac_addr[i])
      mac_addr[i][41:40] == 2'b00;
  }

  constraint reasonable {            // Limit test length
    run_for_n_frames inside {[1:100]};
  }

endclass

class Environment;

  EthCfg cfg;
  EthGen gen[4];
  EthMii drv[4];

  function new();
    cfg = new();                     // Construct the cfg
  endfunction

  // Use random configuration to build the environment
  function void build();
    foreach (gen[i]) begin
      gen[i] = new();
      drv[i] = new();
      if (cfg.is_100[i])
        drv[i].set_speed(100);
    end
  endfunction

endclass
","""Verilog code examples for Ethernet switch configuration and environment setup using randomization""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p142.jpg,True,"The image contains Verilog code examples used for defining properties in the context of functional coverage for a simulation environment. Here is the code from the image:

```verilog
property p_req1; // master 1 requesting
    @(posedge clk) $fell (req1) && req2 && req3;
endproperty

property p_req2; // master 2 requesting
    @(posedge clk) $fell (req2) && req1 && req3;
endproperty

property p_req3; // master 3 requesting
    @(posedge clk) $fell (req3) && req1 && req2;
endproperty
``` 

These properties are defined to monitor specific conditions (e.g., the falling edge of a request signal) during the simulation of a system with three possible requesters (masters).","
property p_req1; // master 1 requesting
    @(posedge clk) $fell (req1) && req2 && req3;
endproperty

property p_req2; // master 2 requesting
    @(posedge clk) $fell (req2) && req1 && req3;
endproperty

property p_req3; // master 3 requesting
    @(posedge clk) $fell (req3) && req1 && req2;
endproperty
","Page from a document detailing Verilog SystemVerilog Assertion (SVA) simulation methodology, specifically discussing a coverage plan and functional coverage properties for request scenarios in a sample system.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p43.jpg,True,"The image contains Verilog code. Here is the text of the code snippets present in the image:

```verilog
a5b : assert property(@(posedge clk) s5b);
```

```verilog
a5c : assert property(@(posedge clk) p5a); // Not allowed
```

```verilog
sequence s6;
    @(posedge clk) a ##2 b;
endsequence

property p6;
    not s6;
endproperty

a6 : assert property(p6);
```","
a5b : assert property(@(posedge clk) s5b);


a5c : assert property(@(posedge clk) p5a); // Not allowed


sequence s6;
    @(posedge clk) a ##2 b;
endsequence

property p6;
    not s6;
endproperty

a6 : assert property(p6);
","""Verilog Assertions: Defining and Checking Forbidden Properties in Digital Logic Verification""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p245.jpg,True,"The image contains text from a document discussing unbounded linear temporal operators in the context of Verilog or SystemVerilog Assertions (SVA). There are snippets of code written in Verilog assertion syntax. Here are the code excerpts from the image:

1.
```verilog
property sequence x, untyped y);
  x #-# y;
endproperty
```

2.
```verilog
cov: cover property(p((reg[*z]), (s_eventually ack)));
```

3.
```verilog
initial a: assume property(reset[*m] #-# always !reset);
```

These code snippets represent examples of using temporal operators in SVA to specify certain conditions or events that occur across the progression of time in the simulation of a hardware model.","
property sequence x, untyped y);
  x #-# y;
endproperty


cov: cover property(p((reg[*z]), (s_eventually ack)));


initial a: assume property(reset[*m] #-# always !reset);
","Caption: ""Exploration of unbounded linear temporal operators in SystemVerilog Assertions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p252.jpg,True,"There is Verilog code in the image. Here it is:

```verilog
`timescale 1ns / 1ns
module scientific_alu(a_in, b_in, opcode,
                      result_out, exception, error);

input [63:0] a_in, b_in;
input [3:0] opcode;
output [63:0] result_out;
output        exception, error;

reg           exception, error;
real          a, b, result; // real variables used in this module

// convert real numbers to/from 64-bit vector port connections
assign result_out = $realtobits(result);
always @(a_in) a = $bitstoreal(a_in);
always @(b_in) b = $bitstoreal(b_in);

//call the PLI application which interfaces to the C model
initial
    $scientific_alu(a, b, opcode, result, exception, error);

endmodule
```

The code defines a Verilog module for a scientific arithmetic logic unit (ALU), which appears to interface with a C model using the PLI (Programming Language Interface). The module converts 64-bit input vectors into real numbers and processes them using a function named `$scientific_alu`, after which the results are converted back into a 64-bit output vector.","
`timescale 1ns / 1ns
module scientific_alu(a_in, b_in, opcode,
                      result_out, exception, error);

input [63:0] a_in, b_in;
input [3:0] opcode;
output [63:0] result_out;
output        exception, error;

reg           exception, error;
real          a, b, result; // real variables used in this module

// convert real numbers to/from 64-bit vector port connections
assign result_out = $realtobits(result);
always @(a_in) a = $bitstoreal(a_in);
always @(b_in) b = $bitstoreal(b_in);

//call the PLI application which interfaces to the C model
initial
    $scientific_alu(a, b, opcode, result, exception, error);

endmodule
","Caption: ""Example page from 'The Verilog PLI Handbook' showing a Verilog shell module for a scientific ALU C model, illustrating the integration of C models with Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p249.jpg,True,"The image contains Verilog code. Here it is transcribed below:

```verilog
Sample 6.63 Creating unique array values with a randc helper class

class randc8;
  randc bit [7:0] val;
endclass

class LittleUnqiueArray;
  bit [7:0] ua [64];  // Array of unique values

  function void pre_randomize();
    randc8 rc8;
    rc8 = new();
    foreach (ua[i]) begin
      `SV_RAND_CHECK(rc8.randomize());
      ua[i] = rc8.val;
    end
  endfunction
endclass

Sample 6.64 Unique value generator

// Create unique random values in a range 0:max-1
class RandcRange;
  randc bit [15:0] value;
  int max_value;  // Maximum possible value

  function new(input int max_value = 10);
    this.max_value = max_value;
  endfunction

  constraint c_max_value {value < max_value;}
endclass
```

This code shows examples of SystemVerilog used to create arrays with unique random values. The first example creates it using a helper class `randc8`, while the second example, `RandcRange`, demonstrates a unique value generator with a maximum value constraint.","
Sample 6.63 Creating unique array values with a randc helper class

class randc8;
  randc bit [7:0] val;
endclass

class LittleUnqiueArray;
  bit [7:0] ua [64];  // Array of unique values

  function void pre_randomize();
    randc8 rc8;
    rc8 = new();
    foreach (ua[i]) begin
      `SV_RAND_CHECK(rc8.randomize());
      ua[i] = rc8.val;
    end
  endfunction
endclass

Sample 6.64 Unique value generator

// Create unique random values in a range 0:max-1
class RandcRange;
  randc bit [15:0] value;
  int max_value;  // Maximum possible value

  function new(input int max_value = 10);
    this.max_value = max_value;
  endfunction

  constraint c_max_value {value < max_value;}
endclass
","""Examples of creating unique random values in Verilog using a randc helper class and unique array generator.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p537.jpg,True,"```verilog
rand bit[N] v1, v2;

function bit[N] max(bit[N] a, b);
    if (a > b) return a;
    return b;
endfunction : max

// ...

assign a = ~b & c;
assign b = a & c;
```","
rand bit[N] v1, v2;

function bit[N] max(bit[N] a, b);
    if (a > b) return a;
    return b;
endfunction : max

// ...

assign a = ~b & c;
assign b = a & c;
","""Discussing Checker Modeling with Free Variables in Verilog and Example of a Function to Find Maximum Value""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p57.jpg,True,"```verilog
sequence s15a;
  @(posedge clk) a ##1 b;
endsequence

sequence s15b;
  @(posedge clk) c ##1 d;
endsequence

property p15a;
  s15a |=> s15b;
endproperty

property p15b;
  s15a.ended |-> ##2 s15b.ended;
endproperty

a15a: assert property(p15a);
a15b: assert property(p15b);
```","
sequence s15a;
  @(posedge clk) a ##1 b;
endsequence

sequence s15b;
  @(posedge clk) c ##1 d;
endsequence

property p15a;
  s15a |=> s15b;
endproperty

property p15b;
  s15a.ended |-> ##2 s15b.ended;
endproperty

a15a: assert property(p15a);
a15b: assert property(p15b);
","Caption: ""Verilog code example illustrating the use of sequences and properties in SystemVerilog Assertions (SVA).""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p275.jpg,True,"The image includes a snippet of Verilog code. Here it is:

```verilog
// extra modeling to simplify expressing coverage property
reg [3:0] out_cnt;
always @(posedge clk) begin // Track outstanding req's with counter.
  if (reset_n) begin
    out_cnt <= 0;
  end
  else begin
    if (req & !done) out_cnt <= out_cnt + 1;
    if (done & ! req) out_cnt <= out_cnt - 1;
  end
end

genvar N;
generate for (N=0;N<=9;N= N+ 1)
  cover property (@(posedge clk)
    (req; (!done || out_cnt>1) ##N req);
endgenerate
```

This code is an example of functional coverage for tracking outstanding requests in SystemVerilog. It is from a section of a book that discusses assertion-based design. The code demonstrates how to use a counter to track outstanding requests in a synchronous system using positive edge-triggered logic with respect to a clock signal ""clk"". The counter is incremented when there is a request without completion and decremented when a request is completed without a new one. There is also a procedural `generate for` loop to create a `cover property` statement for the purpose of functional coverage.","
// extra modeling to simplify expressing coverage property
reg [3:0] out_cnt;
always @(posedge clk) begin // Track outstanding req's with counter.
  if (reset_n) begin
    out_cnt <= 0;
  end
  else begin
    if (req & !done) out_cnt <= out_cnt + 1;
    if (done & ! req) out_cnt <= out_cnt - 1;
  end
end

genvar N;
generate for (N=0;N<=9;N= N+ 1)
  cover property (@(posedge clk)
    (req; (!done || out_cnt>1) ##N req);
endgenerate
",Example of SystemVerilog code for tracking and generating functional coverage for outstanding requests using a counter and coverage property.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p261.jpg,True,"The image contains SystemVerilog code related to assertions for counter limits, and PSL (Property Specification Language) code for preventing counter underflow. Here is the code presented in the image:

```systemverilog
property exceed_max;
    @(posedge clk) not (count > max);
endproperty

property no_overflow;
    @(posedge clk) not (count == 0 && $past(inc & !load, 1));
endproperty

assert property (exceed_max);
assert property (no_overflow);
```

And the PSL code snippet is:

```psl
assert never (count == 0 & dec & !load);
```","erilog
property exceed_max;
    @(posedge clk) not (count > max);
endproperty

property no_overflow;
    @(posedge clk) not (count == 0 && $past(inc & !load, 1));
endproperty

assert property (exceed_max);
assert property (no_overflow);

ert never (count == 0 & dec & !load);
","""Excerpt from a document on Assertion-Based Design showing examples of SystemVerilog and PSL code for counter limit checks to prevent overflows and underflows.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p153.jpg,True,"The image contains several Verilog code samples. Here they are:

1.
```verilog
behavioral or RTL: Count <= Count + 1; // Count is reg.
```

2.
```verilog
RTL: Count[1:0] <= Count[1:0] + 2'b01; // Count is reg.
```

3.
```verilog
RTL: always@(posedge Clock) Count[0] <= ~Count[0];
```

4.
```verilog
RTL: always@(Count[0])
      if (Count[0]==1'b0) Count[1] <= ~Count[1];
```

Additionally, there is a comment about D flip-flop instantiations, but those are not code samples, they describe the declarations for structural design in Verilog.","
behavioral or RTL: Count <= Count + 1; // Count is reg.


RTL: Count[1:0] <= Count[1:0] + 2'b01; // Count is reg.


RTL: always@(posedge Clock) Count[0] <= ~Count[0];


RTL: always@(Count[0])
      if (Count[0]==1'b0) Count[1] <= ~Count[1];
","""Page from a textbook covering Digital VLSI Design with Verilog, illustrating the differences between adder expressions and counter statements in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p249.jpg,True,"The image contains a snippet of Verilog code, and here it is transcribed:

```verilog
genvar i;
generate for(i=0;i<=7; i= i + 1)
  cover property @(posedge clk) (L == line_sel && valid[i] & hit);
endgenerate
```

This code is part of a SystemVerilog functional coverage example for tracking cache line hits.","
genvar i;
generate for(i=0;i<=7; i= i + 1)
  cover property @(posedge clk) (L == line_sel && valid[i] & hit);
endgenerate
","Caption: ""SystemVerilog functional coverage example for tracking cache line hits.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p86.jpg,True,"The image contains several snippets of Verilog code spread across different examples. Here are the code excerpts:

Example 4-11:
```verilog
simulation dff_<S>1(q, ck, d);
output [<S-1>:0] q;
input ck; input [<S-1>:0] d;
always @(posedge ck) begin
  q <= d;
end
initial $initState(q);
synthesis dff_<S>(q, ck, d);
output [<S-1>:0] q;
input ck; input [<S-1>:0] d;
cffd r<S-1>:0/.d(d<(<S-1>:0>)).ck(ck), a(q<(<S-1>:0>));
```

Example 4-12:
(Text mentions examples, but no specific code provided)

Example 4-13:
(No complete code provided, only fragments of references to the DFF modules)

Example 4-14:
```verilog
module dff_2(q, ck, d);
output [1:0] q;
input ck; input [1:0] d;
always @(posedge ck) begin
  q <= d;
end
initial $initState(q);
endmodule // dff_2
module dff_4(q, ck, d);
```

The code is intended to be read in the context of the surrounding text, which provides additional information about how these examples should be used and interpreted within the Verilog hardware-description language environment.","
simulation dff_<S>1(q, ck, d);
output [<S-1>:0] q;
input ck; input [<S-1>:0] d;
always @(posedge ck) begin
  q <= d;
end
initial $initState(q);
synthesis dff_<S>(q, ck, d);
output [<S-1>:0] q;
input ck; input [<S-1>:0] d;
cffd r<S-1>:0/.d(d<(<S-1>:0>)).ck(ck), a(q<(<S-1>:0>));


module dff_2(q, ck, d);
output [1:0] q;
input ck; input [1:0] d;
always @(posedge ck) begin
  q <= d;
end
initial $initState(q);
endmodule // dff_2
module dff_4(q, ck, d);
","""Examples of parameterized Verilog flip-flop modules and macros for simulation and synthesis purposes.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p184.jpg,True,"The image contains a textual description rather than actual Verilog code. However, it does provide a binary data stream pattern that would be used in the context of a Verilog design for a SerDes packet format. Here is the binary pattern given:

```
64'b01110001_00011000_01100100_00010000_01111001_00010000_01111010_00000000
```

This pattern is meant to align with the ASCII codes for 'a', 'b', 'y', and 'z', and is intended to be sent repeatedly by a serial data source as described in the text.","110001_00011000_01100100_00010000_01111001_00010000_01111010_00000000
",The image shows a textbook page containing information about the packet format for SerDes (Serializer/Deserializer) communication and how to test a deserializer in Verilog. It includes a binary data pattern used for synchronization in SerDes communication.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p227.jpg,True,"The image contains Verilog code within the text. Here is the code extracted from the image:

```verilog
sequence missAlloc;
  missDCache ##1 allocStart ##1 readMem;
endsequence

sequence rc1(ra,rb);
  rb or (ra and (`true |=> rc1(ra,rb)));
endsequence

property s_rc1(genericSeq,sra,srb);
  (genericSeq,tdisp) |=> rc1(sra,srb);
endproperty

baseP: assert property (@(posedge clk) s_rc1(missAlloc,wdataH,readC))
  else gotoFail;

task tdisp;
  $display($stime,,,""Dcache Miss to Alloc to Read Mem sequence matches"");
endtask
```

This code is provided within the context of a document that appears to discuss the principles of system verification using SystemVerilog's property specification language features.","
sequence missAlloc;
  missDCache ##1 allocStart ##1 readMem;
endsequence

sequence rc1(ra,rb);
  rb or (ra and (`true |=> rc1(ra,rb)));
endsequence

property s_rc1(genericSeq,sra,srb);
  (genericSeq,tdisp) |=> rc1(sra,srb);
endproperty

baseP: assert property (@(posedge clk) s_rc1(missAlloc,wdataH,readC))
  else gotoFail;

task tdisp;
  $display($stime,,,""Dcache Miss to Alloc to Read Mem sequence matches"");
endtask
","""Verilog code snippet demonstrating the use of sequences and properties in a specification for recursive properties in system verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p340.jpg,True,"The image contains Verilog code. Here is the code transcribed from the image:

```verilog
end
end

if(sig1_edge == 1) // rr, rf
begin
    for(i=0; i<8; i++)
    begin
        a <= logical_op_reg[0];
        b <= logical_op_reg[1];
        repeat(1) @(posedge clk);
        logical_op_reg++;
    end
end

end

/*************************************************/
// case 3
// timing relation between 2 signals
/*************************************************/

if(logic_op == 0 && timing == 1)
begin
    if(timing_level == 2'b11) begin
        a = 1'b0; b=1'b0;
    end

    if(timing_level== 2'b00) begin
        a = 1'b1; b=1'b1;
    end

    if(timing_level == 2'b01) begin
        a = 1'b1; b=1'b0;
    end

    if(timing_level == 2'b10) begin
        a = 1'b0; b=1'b1;
    end

    for(i=(min_time-1); i<(max_time+3); i++)
    begin
        repeat(1) @(posedge clk);
        a <= ~a;
    end
```

This Verilog code appears to be part of a simulation or testbench for checking signal edges and timing relationships between two signals.","
end
end

if(sig1_edge == 1) // rr, rf
begin
    for(i=0; i<8; i++)
    begin
        a <= logical_op_reg[0];
        b <= logical_op_reg[1];
        repeat(1) @(posedge clk);
        logical_op_reg++;
    end
end

end

/*************************************************/
// case 3
// timing relation between 2 signals
/*************************************************/

if(logic_op == 0 && timing == 1)
begin
    if(timing_level == 2'b11) begin
        a = 1'b0; b=1'b0;
    end

    if(timing_level== 2'b00) begin
        a = 1'b1; b=1'b1;
    end

    if(timing_level == 2'b01) begin
        a = 1'b1; b=1'b0;
    end

    if(timing_level == 2'b10) begin
        a = 1'b0; b=1'b1;
    end

    for(i=(min_time-1); i<(max_time+3); i++)
    begin
        repeat(1) @(posedge clk);
        a <= ~a;
    end
","""Verilog code segment demonstrating conditional checks and loop iterations for signal processing.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p233.jpg,True,"The image contains a snippet of Verilog code. Here is the text from the image:

```verilog
Specification:
The state machine must follow specified state transitions.

`define readStart (read_enb ##1 readStartState)
`define readID    (readStartState ##1 readIDState)
`define readData  (readIDState ##1 readDataState)
`define readEnd   (readDataState ##1 readEndState)

sequence checkReadStates;
    @(posedge clk)
        readStart
        readID       // readID && !readData
        readData     // readData && !readEnd
        readEnd      ;
endsequence
```

This code defines a set of macros and a sequence for checking the states of a state machine in Verilog using SystemVerilog assertions.","
Specification:
The state machine must follow specified state transitions.

`define readStart (read_enb ##1 readStartState)
`define readID    (readStartState ##1 readIDState)
`define readData  (readIDState ##1 readDataState)
`define readEnd   (readDataState ##1 readEndState)

sequence checkReadStates;
    @(posedge clk)
        readStart
        readID       // readID && !readData
        readData     // readData && !readEnd
        readEnd      ;
endsequence
","Caption: ""Verilog code outlining state transition checks for a state machine using sequence properties.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p190.jpg,True,"The image contains a snippet of code in Verilog. Here is the text of the code provided:

```verilog
FoundPads = 1'b0;
i = starting_value;
for (j=0; j<3; j=j) // No increment.
begin : While_i
    while(1)
    begin
        if ( six pad's; same as above )
        begin
            #1 Nkeeper[2*j+1] = SerVect[i-3]; // MSB.
            #1 Nkeeper[2*j] = SerVect[i-4]; // LSB.
            if (j==3) // We're done:
            begin
                #1 FoundPads = 1'b1;
                disable While_i;
            end
            // If j wasn't 3, jump ahead for another look:
            #1 j = j + 1;
            #1 i = i - 16;
        end
        else // No six-o match this time.
        if (j==0)
            #1 i = i - 1; // First nn not found yet.
        else begin // We found at least one nn, but now failed:
            i = i + 15; // Drop back after jumping by mistake.
            j = 0; // Reset nn counter; we're not in a pad byte.
        end
    end // while (1).
end // While_i.
```

This code appears to be related to finding patterns within a data stream and may be part of a larger program or algorithm.","
FoundPads = 1'b0;
i = starting_value;
for (j=0; j<3; j=j) // No increment.
begin : While_i
    while(1)
    begin
        if ( six pad's; same as above )
        begin
            #1 Nkeeper[2*j+1] = SerVect[i-3]; // MSB.
            #1 Nkeeper[2*j] = SerVect[i-4]; // LSB.
            if (j==3) // We're done:
            begin
                #1 FoundPads = 1'b1;
                disable While_i;
            end
            // If j wasn't 3, jump ahead for another look:
            #1 j = j + 1;
            #1 i = i - 16;
        end
        else // No six-o match this time.
        if (j==0)
            #1 i = i - 1; // First nn not found yet.
        else begin // We found at least one nn, but now failed:
            i = i + 15; // Drop back after jumping by mistake.
            j = 0; // Reset nn counter; we're not in a pad byte.
        end
    end // while (1).
end // While_i.
",Verilog code example demonstrating a search algorithm for pattern matching within a data stream.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p736.jpg,True,"The image contains text describing various function prototypes and their descriptions from The Verilog Programming Language Interface (PLI) Handbook. Here's the text from the code snippets:

```c
void tf_putp(n, value)
void tf_i_putp(n, value, tfinst)
int n
int value
char *tfinst

void tf_putrealp(n, value)
void tf_i_putrealp(n, value, tfinst)
int n
double value
char *tfinst

int tf_read_restart(blockptr, blocklength)
char *blockptr
int blocklength

void tf_real_to_long(real, low, high)
double real
int *low
int *high

void tf_rosynchronize()
void tf_i_rosynchronize(tfinst)
char *tfinst
```

Please note that these are prototypes for functions that relate to tasks in Verilog PLI, and extensive knowledge of PLI and Verilog is requisite to fully understand and implement these functions in a real-world scenario.","tf_putp(n, value)
void tf_i_putp(n, value, tfinst)
int n
int value
char *tfinst

void tf_putrealp(n, value)
void tf_i_putrealp(n, value, tfinst)
int n
double value
char *tfinst

int tf_read_restart(blockptr, blocklength)
char *blockptr
int blocklength

void tf_real_to_long(real, low, high)
double real
int *low
int *high

void tf_rosynchronize()
void tf_i_rosynchronize(tfinst)
char *tfinst
","""Verilog Programming Language Interface (PLI) Functionality and Method Signatures""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p51.jpg,True,"The image contains Verilog code. Here is the code extracted from the image:

```verilog
//Detects when both queue full
// and queue write request simultaneously occur
event_monitor #(EV_Q1_Q2_FULL) dv_q_full_write (ck, reset_n,
                   c_q_full && c_q_write);

module event_monitor (ck, reset_n, test);
    input ck, reset_n, test;
    parameter event_id=0;
//rtl_synthesis off
    `ifdef EVENTS_ON
    always @(posedge ck) begin
        if(reset_n == 1'b1 && test==1'b1) begin
            $display(""EVENT LOG %d:%t:%m"", event_id,
                     $time);
        end
    end
    `endif
//rtl_synthesis on
endmodule // event_monitor
```

The code appears to be part of a textbook or document describing coverage, events, and assertions in Verilog, and it includes a module definition for `event_monitor`.","
//Detects when both queue full
// and queue write request simultaneously occur
event_monitor #(EV_Q1_Q2_FULL) dv_q_full_write (ck, reset_n,
                   c_q_full && c_q_write);

module event_monitor (ck, reset_n, test);
    input ck, reset_n, test;
    parameter event_id=0;
//rtl_synthesis off
    `ifdef EVENTS_ON
    always @(posedge ck) begin
        if(reset_n == 1'b1 && test==1'b1) begin
            $display(""EVENT LOG %d:%t:%m"", event_id,
                     $time);
        end
    end
    `endif
//rtl_synthesis on
endmodule // event_monitor
","Caption: ""Example of a Verilog event monitor module with conditional event logging based on compile-time flag EVENTS_ON.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p722.jpg,True,"The image contains C language code structures related to Verilog PLI (Programming Language Interface). Here's the code written in the image:

```c
typedef struct t_vpi_value {
    int format; /* vpiBinStrVal, vpiOctStrVal, vpiDecStrVal,
                   vpiHexStrVal, vpiScalarVal, vpiIntVal,
                   vpiRealVal, vpiStringVal, vpiVectorVal,
                   vpiStrengthVal, vpiSuppressVal, vpiTimeVal,
                   vpiObjTypeVal */
    union {
        char *str;               /* string value */
        int scalar;              /* vpi0, vpi1, vpiX,
                                    vpiZ, vpiH, vpiL,
                                    vpiDontCare */
        int integer;             /* integer value */
        double real;             /* real value */
        struct t_vpi_time *time; /* time value */
        struct t_vpi_vecval *vector; /* vector value */
        struct t_vpi_strengthval *strength; /* strength value */
        char *misc;              /* reserved */
    } value;
} s_vpi_value, *p_vpi_value;

typedef struct t_vpi_time {
    int type;                   /* vpiScaledRealTime, vpiSimTime,
                                   vpiSuppressTime */
    unsigned int high;          /* when using vpiSimTime */
    unsigned int low;           /* when using vpiSimTime */
    double real;                /* when using vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;

typedef struct t_vpi_vecval {
    /* one aval/bval pair for each bit in vector */
    int aval, bval;             /* bit encoding: a/b: 0/0==0,
                                   1/0==1, 1/1==X, 0/1==Z */
} s_vpi_vecval, *p_vpi_vecval;

typedef struct t_vpi_strengthval {
    int logic;                  /* vpi0, vpi1, vpiX, vpiZ */
    int s0, s1;                 /* Logical-OR of the constants:
                                   vpiSupplyDrive, vpiStrongDrive,
                                   vpiPullDrive, vpiWeakDrive,
                                   vpiLargeCharge, vpiMediumCharge,
                                   vpiSmallCharge, vpiHiZ */
} s_vpi_strengthval, *p_vpi_strengthval;
```

These are typedef struct declarations providing an interface for the Verilog PLI, allowing C programs to interact with Verilog simulation data.","ef struct t_vpi_value {
    int format; /* vpiBinStrVal, vpiOctStrVal, vpiDecStrVal,
                   vpiHexStrVal, vpiScalarVal, vpiIntVal,
                   vpiRealVal, vpiStringVal, vpiVectorVal,
                   vpiStrengthVal, vpiSuppressVal, vpiTimeVal,
                   vpiObjTypeVal */
    union {
        char *str;               /* string value */
        int scalar;              /* vpi0, vpi1, vpiX,
                                    vpiZ, vpiH, vpiL,
                                    vpiDontCare */
        int integer;             /* integer value */
        double real;             /* real value */
        struct t_vpi_time *time; /* time value */
        struct t_vpi_vecval *vector; /* vector value */
        struct t_vpi_strengthval *strength; /* strength value */
        char *misc;              /* reserved */
    } value;
} s_vpi_value, *p_vpi_value;

typedef struct t_vpi_time {
    int type;                   /* vpiScaledRealTime, vpiSimTime,
                                   vpiSuppressTime */
    unsigned int high;          /* when using vpiSimTime */
    unsigned int low;           /* when using vpiSimTime */
    double real;                /* when using vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;

typedef struct t_vpi_vecval {
    /* one aval/bval pair for each bit in vector */
    int aval, bval;             /* bit encoding: a/b: 0/0==0,
                                   1/0==1, 1/1==X, 0/1==Z */
} s_vpi_vecval, *p_vpi_vecval;

typedef struct t_vpi_strengthval {
    int logic;                  /* vpi0, vpi1, vpiX, vpiZ */
    int s0, s1;                 /* Logical-OR of the constants:
                                   vpiSupplyDrive, vpiStrongDrive,
                                   vpiPullDrive, vpiWeakDrive,
                                   vpiLargeCharge, vpiMediumCharge,
                                   vpiSmallCharge, vpiHiZ */
} s_vpi_strengthval, *p_vpi_strengthval;
",Excerpt from The Verilog PLI Handbook showing type definitions for VPI data structures.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p88.jpg,True,"```verilog
@(posedge clk) a |=> !b;
```","
@(posedge clk) a |=> !b;
","""Understanding the Preponed Region in Verilog Assertions and its Impact on Variable Sampling Timing""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p176.jpg,True,"```c
/* reading rc file, handling missing options */
int getConfig(char settings[MAX_SETTINGS][MAX_LEN]) {
    char home[MAX_LEN];
    FILE *fp;                          /* .rc file handler */
    int numSet = 0;                    /* number of settings */
    strcpy(home, getenv(""HOME""));      /* get home path */
    strcat(home, ""/.aeonrc"");          /* full path to rc file */
    // ... (Rest of the code is not shown)
}

char strncpy (char *t, const char* s) {
    for (i = 0; ; i++) { assert (!(t == &home)||(!(i>=MAX_LEN)));
    t[i] = s[i]; if (s[i] == '\0') break; }
}
```

Please note that the code snippet seems to be incomplete with an ellipsis indicating omitted lines in the `getConfig` function and that the function `strncpy` has been written incorrectly according to standard C library conventions. The actual 'strncpy' function in the C standard library takes an additional 'n' parameter that limits the number of characters copied. The version shown here contains a logical error and a typo (`&home` should likely be `&t[MAX_LEN]`). Also, the function doesn't seem to ensure the null-termination of the destination string if the limit (`MAX_LEN`) is reached, which is another potential source of error or vulnerability.","ading rc file, handling missing options */
int getConfig(char settings[MAX_SETTINGS][MAX_LEN]) {
    char home[MAX_LEN];
    FILE *fp;                          /* .rc file handler */
    int numSet = 0;                    /* number of settings */
    strcpy(home, getenv(""HOME""));      /* get home path */
    strcat(home, ""/.aeonrc"");          /* full path to rc file */
    // ... (Rest of the code is not shown)
}

char strncpy (char *t, const char* s) {
    for (i = 0; ; i++) { assert (!(t == &home)||(!(i>=MAX_LEN)));
    t[i] = s[i]; if (s[i] == '\0') break; }
}
","""Figure depicting a discussion on buffer overflow detection in AEON 0.2a with accompanying vulnerable C code snippets.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p390.jpg,True,"The image contains Verilog code. Here it is:

```verilog
`define rd_ptr test_fifo.fil.rd_ptr
`define wr_ptr test_fifo.fil.wr_ptr
`define cnt test_fifo.fil.cnt

module fifo_property (
    input logic [7:0] fifo_data_out,
    input logic        fifo_full, fifo_empty,
    input logic        fifo_write, fifo_read, clk, rst_,
    input logic [7:0]  fifo_data_in
    );

parameter fifo_depth=8;
parameter fifo_width=8;

// ------------------------------------------------
//  1. Check that on reset,
//     rd_ptr=0; wr_ptr=0; cnt=0; fifo_empty=1 and fifo_full=0
// ------------------------------------------------

`ifdef check1
property check_reset;
    @(posedge clk) rst_ |-> `rd_ptr==0; // DUMMY... remove this line and

                                           // replace it with correct check

endproperty

check_resetP: assert property (check_reset) else $display(""%stime,\""t\ FAIL::check_reset\n"");
`endif
```

The code seems to be part of a testbench for a FIFO (First-In-First-Out) memory structure, where the module `fifo_property` is being set up to verify certain properties related to the FIFO's behavior upon reset. The code snippet includes a dummy property for illustration, and the reader would need to replace this with the correct check.","
`define rd_ptr test_fifo.fil.rd_ptr
`define wr_ptr test_fifo.fil.wr_ptr
`define cnt test_fifo.fil.cnt

module fifo_property (
    input logic [7:0] fifo_data_out,
    input logic        fifo_full, fifo_empty,
    input logic        fifo_write, fifo_read, clk, rst_,
    input logic [7:0]  fifo_data_in
    );

parameter fifo_depth=8;
parameter fifo_width=8;

// ------------------------------------------------
//  1. Check that on reset,
//     rd_ptr=0; wr_ptr=0; cnt=0; fifo_empty=1 and fifo_full=0
// ------------------------------------------------

`ifdef check1
property check_reset;
    @(posedge clk) rst_ |-> `rd_ptr==0; // DUMMY... remove this line and

                                           // replace it with correct check

endproperty

check_resetP: assert property (check_reset) else $display(""%stime,\""t\ FAIL::check_reset\n"");
`endif
","""Example of Verilog assertions for checking FIFO properties in a simulation environment""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p384.jpg,True,"There is text that resembles code in the image. Here is the code extracted from the image:

```verilog
/*
KERNEL: 190 clk=1 cstart=0 req=0 gnt=0
KERNEL: 190 test_overlap_nonoverlap FAIL

Q: WHY DOES THE PROPERTY FAIL at 190?

KERNEL: 210 clk=1 cstart=0 req=0 gnt=1
KERNEL: 210 test_overlap_nonoverlap PASS
*/

/* define+nonoverlap

run -all

KERNEL: 10 clk=1 cstart=0 req=0 gnt=0
KERNEL: 30 clk=1 cstart=1 req=0 gnt=0
KERNEL: 50 clk=1 cstart=1 req=1 gnt=0
KERNEL: 70 clk=1 cstart=0 req=0 gnt=0
KERNEL: 70 test_overlap_nonoverlap FAIL

Q: WHY DOES THE PROPERTY FAIL at 70?

KERNEL: 90 clk=1 cstart=0 req=0 gnt=1
KERNEL: 90 test_overlap_nonoverlap PASS

Q: WHY DOES THE PROPERTY PASS at 90?

KERNEL: 110 clk=1 cstart=1 req=1 gnt=0
KERNEL: 130 clk=1 cstart=1 req=1 gnt=0
KERNEL: 150 clk=1 cstart=1 req=1 gnt=1
KERNEL: 170 clk=1 cstart=0 req=1 gnt=0
KERNEL: 170 test_overlap_nonoverlap FAIL

Q: WHY DOES THE PROPERTY FAIL at 170?

KERNEL: 190 clk=1 cstart=0 req=0 gnt=0
KERNEL: 190 test_overlap_nonoverlap FAIL

Q: WHY DOES THE PROPERTY FAIL at 190?

KERNEL: 210 clk=1 cstart=0 req=0 gnt=1
KERNEL: 210 test_overlap_nonoverlap PASS

Q: WHY DOES THE PROPERTY PASS at 210?

*/
```

Please note that these lines appear to be commands for a test or verification environment, possibly associated with the Verilog hardware description language, rather than actual Verilog code. They might be stimuli for a simulation or commands to a testbench.","
/*
KERNEL: 190 clk=1 cstart=0 req=0 gnt=0
KERNEL: 190 test_overlap_nonoverlap FAIL

Q: WHY DOES THE PROPERTY FAIL at 190?

KERNEL: 210 clk=1 cstart=0 req=0 gnt=1
KERNEL: 210 test_overlap_nonoverlap PASS
*/

/* define+nonoverlap

run -all

KERNEL: 10 clk=1 cstart=0 req=0 gnt=0
KERNEL: 30 clk=1 cstart=1 req=0 gnt=0
KERNEL: 50 clk=1 cstart=1 req=1 gnt=0
KERNEL: 70 clk=1 cstart=0 req=0 gnt=0
KERNEL: 70 test_overlap_nonoverlap FAIL

Q: WHY DOES THE PROPERTY FAIL at 70?

KERNEL: 90 clk=1 cstart=0 req=0 gnt=1
KERNEL: 90 test_overlap_nonoverlap PASS

Q: WHY DOES THE PROPERTY PASS at 90?

KERNEL: 110 clk=1 cstart=1 req=1 gnt=0
KERNEL: 130 clk=1 cstart=1 req=1 gnt=0
KERNEL: 150 clk=1 cstart=1 req=1 gnt=1
KERNEL: 170 clk=1 cstart=0 req=1 gnt=0
KERNEL: 170 test_overlap_nonoverlap FAIL

Q: WHY DOES THE PROPERTY FAIL at 170?

KERNEL: 190 clk=1 cstart=0 req=0 gnt=0
KERNEL: 190 test_overlap_nonoverlap FAIL

Q: WHY DOES THE PROPERTY FAIL at 190?

KERNEL: 210 clk=1 cstart=0 req=0 gnt=1
KERNEL: 210 test_overlap_nonoverlap PASS

Q: WHY DOES THE PROPERTY PASS at 210?

*/
","""Verilog simulation results with questions about property failures and passes at specific time points""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p252.jpg,True,"The image contains a snippet of Verilog code. Here is the transcription of the code:

```verilog
// clock half-period:
`define CK_MSTR #5
// reset hold time:
`define TIME_RESET #6
// run with assertion active:
`define ASSERT_ON
module testbench();
    wire ck;
    wire [4:0] c_stimulus;
    wire [2:0] c_codex;
    wire [2:0] c_codez;
    wire       c_reset;
    ck_gen ck_gen (ck);
    stimulus s (.ck (ck), .c_stimulus (c_stimulus), .c_reset(c_reset));
    enum_encode x (.c_error_vector (c_stimulus), .c_code (c_codex));
    enum_encodez z (.c_error_vector (c_stimulus), .c_code (c_codez));

// result checking:
    log_xz_test xz_test(ck, c_stimulus, c_codex, c_codez);
    assert_always #(""1/c_codex != c_codez"") safety
        (ck, ~c_reset, c_codex == c_codez);
endmodule // testbench
```

The code appears to define a sample testbench with clock signal generation and stimulus encoding for verification purposes. It also includes an assertion check as indicated by `assert_always` to ensure the safety property is maintained throughout simulation.","
// clock half-period:
`define CK_MSTR #5
// reset hold time:
`define TIME_RESET #6
// run with assertion active:
`define ASSERT_ON
module testbench();
    wire ck;
    wire [4:0] c_stimulus;
    wire [2:0] c_codex;
    wire [2:0] c_codez;
    wire       c_reset;
    ck_gen ck_gen (ck);
    stimulus s (.ck (ck), .c_stimulus (c_stimulus), .c_reset(c_reset));
    enum_encode x (.c_error_vector (c_stimulus), .c_code (c_codex));
    enum_encodez z (.c_error_vector (c_stimulus), .c_code (c_codez));

// result checking:
    log_xz_test xz_test(ck, c_stimulus, c_codex, c_codez);
    assert_always #(""1/c_codex != c_codez"") safety
        (ck, ~c_reset, c_codex == c_codez);
endmodule // testbench
","Example Verilog code for a testbench module with clock generation, stimuli, and assertion checking.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p246.jpg,True,"There is code in the image. Here's the Verilog code provided:

```verilog
module dff (q, ck, rst, d);
    parameter w = 1;
    input ck, rst;
    input [w-1:0] d;
    output [w-1:0] q;
    reg [w-1:0] q;
    always @ (posedge ck)
        q <= (rst == 1'b0) ? d : {w{1'b0}};
endmodule //dff
``` 

This code defines a Verilog module for a D flip-flop with a parameterized width, clock and reset inputs, data input, and output. The output `q` is registered and changes on the positive edge of the clock `ck`, unless reset `rst` is active, in which case `q` is set to 0. The width `w` is a parameter that allows the flip-flop to handle more than a single bit, according to the specified value.","
module dff (q, ck, rst, d);
    parameter w = 1;
    input ck, rst;
    input [w-1:0] d;
    output [w-1:0] q;
    reg [w-1:0] q;
    always @ (posedge ck)
        q <= (rst == 1'b0) ? d : {w{1'b0}};
endmodule //dff
","Caption: ""Excerpt from a document discussing Verilog flip-flops, latches, and memories with a code example of a D flip-flop.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p118.jpg,True,"```c
task_handle = vpi_handle(vpiSysTfCall, NULL)
if (task_handle == NULL) {
    vpi_printf(""ERROR: could not obtain task handle\n"");
    return(0);
}
```

The above code is an example provided in the text about VPI error handling in a Verilog PLI application. It demonstrates the checking of a return value for `NULL`, which would indicate an error, and error reporting using `vpi_printf`.","handle = vpi_handle(vpiSysTfCall, NULL)
if (task_handle == NULL) {
    vpi_printf(""ERROR: could not obtain task handle\n"");
    return(0);
}
","Excerpt from ""The Verilog PLI Handbook"" discussing VPI error handling in Verilog with code example.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p435.jpg,True,"The image contains Verilog code. Here is the code from the image:

```verilog
`ifdef check4
property checkPCI_trdyDevsel;
    @(posedge clk) disable iff (reset_) !TRDY_ |-> !DEVSel_;
endproperty
assert property (checkPCI_trdyDevsel) else
$display($stime,, ""CHECK4:checkPCI_trdyDevsel FAIL\n"");
`endif

`ifdef check5
property checkPCI_CBE_during_trx;
    @(posedge clk) disable iff (reset_)
        $fell(FRAME_) |-> !($isunknown(C_BE_)) [*0:$] ##0 $rose(FRAME_);
endproperty
assert property (checkPCI_CBE_during_trx) else
$display($stime,, ""CHECK5:checkPCI_CBE_during_trx FAIL\n"");
`endif
```

This code snippet represents properties and assertions in the context of checking a PCI (Peripheral Component Interconnect) protocol property implementation. It uses SystemVerilog constructs to define these properties (`property`, `endproperty`) and assertions (`assert property`). The `$display` function is used to output messages for assertion failures.","
`ifdef check4
property checkPCI_trdyDevsel;
    @(posedge clk) disable iff (reset_) !TRDY_ |-> !DEVSel_;
endproperty
assert property (checkPCI_trdyDevsel) else
$display($stime,, ""CHECK4:checkPCI_trdyDevsel FAIL\n"");
`endif

`ifdef check5
property checkPCI_CBE_during_trx;
    @(posedge clk) disable iff (reset_)
        $fell(FRAME_) |-> !($isunknown(C_BE_)) [*0:$] ##0 $rose(FRAME_);
endproperty
assert property (checkPCI_CBE_during_trx) else
$display($stime,, ""CHECK5:checkPCI_CBE_during_trx FAIL\n"");
`endif
","""Verilog Assertions for PCI Read Protocol Checks""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p91.jpg,True,"The image contains two examples of code. The first example is Verilog code related to a FIFO (First In, First Out) buffer control with assertions to check for overflow and underflow conditions. The second example shows the syntax for a PSL (Property Specification Language) assertion. Here is the complete Verilog code from the image:

```verilog
always @ (posedge clk or negedge FIFO_clr_n)
// Clear FIFO content and reset control
if (!FIFO_clr_n) begin
    top <= 0;
    btm <= 0;
    cnt <= 0;
    for (i=0; i<FIFO_depth; i=i+1)
        FIFO[i] <= 0;
end
// reset FIFO control
else if (!FIFO_reset_n) begin
    top <= 0;
    btm <= 0;
    cnt <= 0;
end
else
    case ({push, pop})
        2'b10 : // WRITE
        begin // assertion checks for overflow
            FIFO[top] <= data_in;
            top <= top + 1;
            cnt <= cnt + 1;
        end
        2'b01 : // READ
        begin // assertion checks for underflow
            btm <= btm + 1;
            cnt <= cnt + 1;
        end
        2'b11 : // WRITE & READ
        begin
            FIFO[top] <= data_in;
            btm <= btm + 1;
            top <= top + 1;
        end
    endcase
// end always

assign data_out = FIFO[btm];

endmodule
```

Below the Verilog code, there is a short note on PSL assertions and an example of PSL assertion syntax:

```verilog
assert never (<Boolean expression>) [@<clock expression>];
```","
always @ (posedge clk or negedge FIFO_clr_n)
// Clear FIFO content and reset control
if (!FIFO_clr_n) begin
    top <= 0;
    btm <= 0;
    cnt <= 0;
    for (i=0; i<FIFO_depth; i=i+1)
        FIFO[i] <= 0;
end
// reset FIFO control
else if (!FIFO_reset_n) begin
    top <= 0;
    btm <= 0;
    cnt <= 0;
end
else
    case ({push, pop})
        2'b10 : // WRITE
        begin // assertion checks for overflow
            FIFO[top] <= data_in;
            top <= top + 1;
            cnt <= cnt + 1;
        end
        2'b01 : // READ
        begin // assertion checks for underflow
            btm <= btm + 1;
            cnt <= cnt + 1;
        end
        2'b11 : // WRITE & READ
        begin
            FIFO[top] <= data_in;
            btm <= btm + 1;
            top <= top + 1;
        end
    endcase
// end always

assign data_out = FIFO[btm];

endmodule


assert never (<Boolean expression>) [@<clock expression>];
","Caption: ""Example of Verilog code for a FIFO buffer with overflow and underflow condition assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p103.jpg,True,"The image contains two code samples written in Verilog. Here are the transcriptions of each:

Sample 2.57 Incorrectly specifying enumerated values
```verilog
typedef enum {FIRST=1, SECOND, THIRD} ordinal_e;
ordinal_e position;
```

Sample 2.58 Correctly specifying enumerated values
```verilog
typedef enum {BAD=0, FIRST=1, SECOND, THIRD} ordinal_e;
ordinal_e position;
```","
typedef enum {FIRST=1, SECOND, THIRD} ordinal_e;
ordinal_e position;


typedef enum {BAD=0, FIRST=1, SECOND, THIRD} ordinal_e;
ordinal_e position;
","""Verilog text discussing enumerated types and their declaration with examples of correct and incorrect specifications.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p353.jpg,True,"```verilog
assign e = Top.CPU.my_let(a)); // ILLEGAL

module sys;
  logic req = 1'b1;
  logic a, b;
  let y = req;
  ...
  always_comb begin
    req = 1'b0;
    b = a | y;
  end
endmodule: sys

module sys;
  logic req = 1'b1;
  logic a, b;
  ...
  always_comb begin
    req = 1'b0;
    b = a | (sys.req); //NOTE: y binds to preceding definition of `req` in the declarative context of `let`
  end
endmodule: top

module CPU;
  logic snoop, cache;
  let data = snoop || cache;
  sequence s;
    data ##1 cache
  endsequence: s
  ...
endmodule: top
```","
assign e = Top.CPU.my_let(a)); // ILLEGAL

module sys;
  logic req = 1'b1;
  logic a, b;
  let y = req;
  ...
  always_comb begin
    req = 1'b0;
    b = a | y;
  end
endmodule: sys

module sys;
  logic req = 1'b1;
  logic a, b;
  ...
  always_comb begin
    req = 1'b0;
    b = a | (sys.req); //NOTE: y binds to preceding definition of `req` in the declarative context of `let`
  end
endmodule: top

module CPU;
  logic snoop, cache;
  let data = snoop || cache;
  sequence s;
    data ##1 cache
  endsequence: s
  ...
endmodule: top
","Caption: ""Verilog code examples showing correct and incorrect usage of 'let' expressions within modules and their effects when expanded.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p234.jpg,True,"The image contains Verilog code. Here's the code as it appears in the image:

```verilog
for (j=0; j<4; j++)
begin:loop
  a_generate: assert property(@(posedge clk)
    (`s_active && bank_addr[1:0] == j)
    |->
    not ##[1: tRRD] (`s_active &&
    (bank_addr[1:0] != j))),
  c_generate: cover property(@(posedge clk)
    (`s_active && bank_addr[1:0] == j)
    |->
    not ##[1: tRRD] (`s_active &&
    (bank_addr[1:0] != j)));
end
endgenerate

property p_xfer128;
@(posedge clk)
((size == 0) && ((dq[m[0] == 0 && (`s_write
|| `s_burst_write))) |->
##2 (($fell (dq[m[1])) && addr == $past (addr, 2))
&&
(`s_write || `s_burst_write))
##1 $rose (dq[m[1])
##1 (($fell (dq[m[2])) && addr == $past (addr, 2))
&&
(`s_write || `s_burst_write))
##1 $rose (dq[m[2])
##1 (($fell (dq[m[3])) && addr == $past (addr, 2))
&&
(`s_write || `s_burst_write))
##1 $rose (dq[m[3]));
endproperty

a_xfer128: assert property(p_xfer128);
c_xfer128: cover property(p_xfer128);
```

Note that the text in the image contains macros (indicated by backticks `` ` ``), which are placeholders for values or expressions that are defined elsewhere in the Verilog code. These macros (`s_active, `s_write, `s_burst_write) would be defined elsewhere in the source code. Also, there are some typographical errors or formatting issues present in the code within the image; for instance, `dq[m[1]` seems to have missing brackets and should likely be `dq[m][1]`. Always double-check with the original source to correct such typographical errors when using this code.","
for (j=0; j<4; j++)
begin:loop
  a_generate: assert property(@(posedge clk)
    (`s_active && bank_addr[1:0] == j)
    |->
    not ##[1: tRRD] (`s_active &&
    (bank_addr[1:0] != j))),
  c_generate: cover property(@(posedge clk)
    (`s_active && bank_addr[1:0] == j)
    |->
    not ##[1: tRRD] (`s_active &&
    (bank_addr[1:0] != j)));
end
endgenerate

property p_xfer128;
@(posedge clk)
((size == 0) && ((dq[m[0] == 0 && (`s_write
|| `s_burst_write))) |->
##2 (($fell (dq[m[1])) && addr == $past (addr, 2))
&&
(`s_write || `s_burst_write))
##1 $rose (dq[m[1])
##1 (($fell (dq[m[2])) && addr == $past (addr, 2))
&&
(`s_write || `s_burst_write))
##1 $rose (dq[m[2])
##1 (($fell (dq[m[3])) && addr == $past (addr, 2))
&&
(`s_write || `s_burst_write))
##1 $rose (dq[m[3]));
endproperty

a_xfer128: assert property(p_xfer128);
c_xfer128: cover property(p_xfer128);
","""Excerpt from a Verilog textbook covering assertions and properties for SDRAM data transfer verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p421.jpg,True,"The image contains Verilog code within a textbook or document. Here is the text of the code snippet provided:

```verilog
property pr1;
  @(posedge clk) req |-> ##2 gnt;
endproperty

reqGnt: assert property (pr1) $display($stime,,""\t %m PASS"");
        else $display($stime,,""\t %m FAIL"");
```

This code is related to a property declaration in SystemVerilog using the implication operator (`|->`) within a temporal assertion context.","
property pr1;
  @(posedge clk) req |-> ##2 gnt;
endproperty

reqGnt: assert property (pr1) $display($stime,,""\t %m PASS"");
        else $display($stime,,""\t %m FAIL"");
","""Example of Verilog code using implication operator with a question and answer on simulation results.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p85.jpg,True,"The image contains two snippets of code. Here they are:

Snippet 1:
```verilog
assert always {!(en1 & en2); // enables are mutually exclusive
```

Snippet 2:
```verilog
cover {c_mem_access; c_write};
```","
assert always {!(en1 & en2); // enables are mutually exclusive


cover {c_mem_access; c_write};
","Caption: ""Examples of PSL usage for asserting properties and defining functional coverage points in Verilog code verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p117.jpg,True,"The image contains Verilog code within a printed document. Here is the code snippet from the image:

```verilog
function automatic void print_csm1l (const ref bit [31:0] a[]);
  bit [31:0] checksum = 0;
  for (int i=0; i<a.size(); i++)
    checksum ^= a[i];
  $display(""The array checksum is %h"", checksum);
endfunction
```

This code defines a function called `print_csm1l` which calculates the checksum of an array passed by reference using the `const ref` argument type, iterates through the array, and XORs its elements into a checksum variable. It then displays the resulting checksum in a hexadecimal format.","
function automatic void print_csm1l (const ref bit [31:0] a[]);
  bit [31:0] checksum = 0;
  for (int i=0; i<a.size(); i++)
    checksum ^= a[i];
  $display(""The array checksum is %h"", checksum);
endfunction
",Text discussing the usage and benefits of `ref` arguments in SystemVerilog functions with an example that calculates an array checksum.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p291.jpg,True,"The image contains Verilog code. Here is the code transcribed from the image:

```verilog
i <= max_cks;
end
FRAME_CHECK:
begin
  // Count clock ticks
  if (start_condition == 1'b1) begin
    if (flag == FLAG_IGNORE_NEW_START && i > 0)
      i <= i-1;
    else if (flag == FLAG_RESET_ON_START)
      i <= num_cks;
    else if (flag == FLAG_ERR_ON_START) begin
      error_count = error_count + 1;
      `ifdef ASSERT_MAX_REPORT_ERROR
        if (error_count <= `ASSERT_MAX_REPORT_ERROR)
      `endif
          $display(""%s : illegal start event : time %0t : %m"", msg, $time);
      if (severity_level == 0) $finish;
    end
  else begin
    // Illegal 'flag' parameter value specified
    // during instantiation!
    error_count = error_count + 1;
    `ifdef ASSERT_MAX_REPORT_ERROR
      if (error_count <= `ASSERT_MAX_REPORT_ERROR)
    `endif
        $display(""%s:illegal flag parameter %0d:time %0t:%m"", msg, flag, $time);
    if (severity_level == 0) $finish;
  end
end
else if (i > 0)
  i<=i-1;

//go to start state on last check
if ((i == 1) || test_condition) begin
  r_state <= FRAME_START;

  // Check that the property is false
  num_cks = max_cks - i + 1;

  if (((num_cks >= min_cks) &&
       (num_cks <= max_cks)) &&
      test_condition!==1'b1) begin
    error_count = error_count + 1;
    `ifdef ASSERT_MAX_REPORT_ERROR
      if (error_count <= `ASSERT_MAX_REPORT_ERROR)
    `endif
        $display(""%s : severity %0d : time %0t : %m"", 
                 msg, severity_level, $time);
```

Please note that some of the `ifdef` conditional compile directives check for a macro `ASSERT_MAX_REPORT_ERROR` which is not defined within the provided code snippet. That would be defined elsewhere in the Verilog codebase or passed as a compiler flag during compilation.","
i <= max_cks;
end
FRAME_CHECK:
begin
  // Count clock ticks
  if (start_condition == 1'b1) begin
    if (flag == FLAG_IGNORE_NEW_START && i > 0)
      i <= i-1;
    else if (flag == FLAG_RESET_ON_START)
      i <= num_cks;
    else if (flag == FLAG_ERR_ON_START) begin
      error_count = error_count + 1;
      `ifdef ASSERT_MAX_REPORT_ERROR
        if (error_count <= `ASSERT_MAX_REPORT_ERROR)
      `endif
          $display(""%s : illegal start event : time %0t : %m"", msg, $time);
      if (severity_level == 0) $finish;
    end
  else begin
    // Illegal 'flag' parameter value specified
    // during instantiation!
    error_count = error_count + 1;
    `ifdef ASSERT_MAX_REPORT_ERROR
      if (error_count <= `ASSERT_MAX_REPORT_ERROR)
    `endif
        $display(""%s:illegal flag parameter %0d:time %0t:%m"", msg, flag, $time);
    if (severity_level == 0) $finish;
  end
end
else if (i > 0)
  i<=i-1;

//go to start state on last check
if ((i == 1) || test_condition) begin
  r_state <= FRAME_START;

  // Check that the property is false
  num_cks = max_cks - i + 1;

  if (((num_cks >= min_cks) &&
       (num_cks <= max_cks)) &&
      test_condition!==1'b1) begin
    error_count = error_count + 1;
    `ifdef ASSERT_MAX_REPORT_ERROR
      if (error_count <= `ASSERT_MAX_REPORT_ERROR)
    `endif
        $display(""%s : severity %0d : time %0t : %m"", 
                 msg, severity_level, $time);
",An excerpt from a textbook showing an example of Verilog code used for assertion-based verification.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p409.jpg,True,"There's no executable Verilog code in the image, but there is a description of a module interface that reads as follows:

```verilog
module test_pci_protocol
```

Below that, there's a diagram showing the conceptual representation of modules (`pci_master`, `pci_protocol_property`, and `pci_target`) and signal connections between them, but it does not include any actual Verilog code.","
module test_pci_protocol
",Verilog simulation testbench setup for PCI protocol with system-level assertions.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p124.jpg,True,"The image contains text describing API functions of Verilog PLI (Programming Language Interface). There are two function prototypes and a code snippet in the image. Here is the code snippet:

```verilog
vpiHandle port_handle, module_handle;

/* add code to obtain handle for a port */
module_handle = vpi_handle(vpiModule, port_handle);
```

The image also includes the prototypes of the `vpi_handle` and `vpi_iterate` functions as follows:

```verilog
vpiHandle vpi_handle(type, reference)
int type
vpiHandle reference
```

```verilog
vpiHandle vpi_iterate(type, reference)
int type
vpiHandle reference
```","
vpiHandle port_handle, module_handle;

/* add code to obtain handle for a port */
module_handle = vpi_handle(vpiModule, port_handle);


vpiHandle vpi_handle(type, reference)
int type
vpiHandle reference


vpiHandle vpi_iterate(type, reference)
int type
vpiHandle reference
","A page from ""The Verilog PLI Handbook"" detailing the use of `vpi_handle` and `vpi_iterate` functions for traversing one-to-one and one-to-many relationships in Verilog PLI.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p208.jpg,True,"The image contains Verilog code. Here is the text from the image:

```verilog
// compare results

genvar k;
generate
for(k=0; k<64; k++)
begin: dchk
a_dp_chk: assert property(
@(posedge clk) (reset && $fell(enable)) |=>
(pix_in[k] == local_array[k])) else $fatal;
end
endgenerate

endmodule

// check that data is put into blocks of 64 correctly

bind data_feeder dp_chk
#(.data_file(""input_image.dat""),
.identity(""INPUT"")) dpchk1
(reset_, clk, latch_en, q0, q1, ...., q61, q62, q63);

// check that the output of first wh transform is // correct

bind datapath dp_chk
#(.data_file(""wh1.dat""), .identity(""WH1"")) dpchk2
reset, clk, dp_enable1,
dw11,dw12,...,dw61,dw62,dw63,dw64);

// check that the transposed data is correct

bind datapath dp_chk
#(.data_file(""xposed.dat""),
.identity(""TRANSPOSE"")) dpchk3
(reset, clk, dp_enable2, dwlt1, dwlt2, ..., dwlt61, dwlt62, dwlt63, dwlt64);

// check that the output of the second wh
// transform is correct
```

Please note, there are ellipses in the code (...) representing where code has been abbreviated or omitted for brevity in the text.","
// compare results

genvar k;
generate
for(k=0; k<64; k++)
begin: dchk
a_dp_chk: assert property(
@(posedge clk) (reset && $fell(enable)) |=>
(pix_in[k] == local_array[k])) else $fatal;
end
endgenerate

endmodule

// check that data is put into blocks of 64 correctly

bind data_feeder dp_chk
#(.data_file(""input_image.dat""),
.identity(""INPUT"")) dpchk1
(reset_, clk, latch_en, q0, q1, ...., q61, q62, q63);

// check that the output of first wh transform is // correct

bind datapath dp_chk
#(.data_file(""wh1.dat""), .identity(""WH1"")) dpchk2
reset, clk, dp_enable1,
dw11,dw12,...,dw61,dw62,dw63,dw64);

// check that the transposed data is correct

bind datapath dp_chk
#(.data_file(""xposed.dat""),
.identity(""TRANSPOSE"")) dpchk3
(reset, clk, dp_enable2, dwlt1, dwlt2, ..., dwlt61, dwlt62, dwlt63, dwlt64);

// check that the output of the second wh
// transform is correct
","Caption: ""Verilog code snippets for result comparison and data checking in hardware design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p130.jpg,True,"The image contains Verilog code. Here is the code from the image:

```verilog
$read_test_vector(""vectors.pat"", input_bus);

always @(posedge clock)
    $read_test_vector(""A.dat"", data_bus);

always @(negedge clock)
    $read_test_vector(""B.dat"", data_bus);
```","
$read_test_vector(""vectors.pat"", input_bus);

always @(posedge clock)
    $read_test_vector(""A.dat"", data_bus);

always @(negedge clock)
    $read_test_vector(""B.dat"", data_bus);
","Caption: ""Excerpt from 'The Verilog PLI Handbook' explaining how multiple instances of system tasks and system functions can reference the same calltf routine in Verilog HDL, with code examples using `$read_test_vector`.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p285.jpg,True,"```verilog
parameter FLAG_ERR_ON_START = 2'b10;

reg r_change;
reg [width-1:0] r_check_value;
reg r_state;
integer i;
integer error_count;
initial error_count = 0;

initial begin
  r_state=CHANGE_START;
  r_change=1'b0;
end

always @(posedge clk) begin
  `ifdef ASSERT_GLOBAL_RESET
  if (ASSERT_GLOBAL_RESET != 1'b0) begin
    `else
    if (reset_n != 0) begin // active low reset_n
    `endif
      case (r_state)
        CHANGE_START:
          if (start_event == 1'b1) begin
            r_change <= 1'b0;
            r_state <= CHANGE_CHECK;
            r_check_value <= test_expr;
            i <= num_clks;
          end
        CHANGE_CHECK:
          begin
            // Count clock ticks
            if (start_event == 1'b1) begin
              if ((flag == FLAG_IGNORE_NEW_START && i > 0)
                i <= i-1;
              else if (flag == FLAG_RESET_ON_START)
                i <= num_clks;
              else if (flag == FLAG_ERR_ON_START) begin
                error_count = error_count + 1;
                `ifdef ASSERT_MAX_REPORT_ERROR
                if (error_count <= ASSERT_MAX_REPORT_ERROR)
                `endif
                  $display(""%s: illegal start event : time %0t : %m"", $time);
                if (`severity_level == 0) $finish;
              end
          else begin
            // Illegal 'flag' parameter value specified
            // during instantiation!
            error_count = error_count + 1;
            `ifdef ASSERT_MAX_REPORT_ERROR
```","
parameter FLAG_ERR_ON_START = 2'b10;

reg r_change;
reg [width-1:0] r_check_value;
reg r_state;
integer i;
integer error_count;
initial error_count = 0;

initial begin
  r_state=CHANGE_START;
  r_change=1'b0;
end

always @(posedge clk) begin
  `ifdef ASSERT_GLOBAL_RESET
  if (ASSERT_GLOBAL_RESET != 1'b0) begin
    `else
    if (reset_n != 0) begin // active low reset_n
    `endif
      case (r_state)
        CHANGE_START:
          if (start_event == 1'b1) begin
            r_change <= 1'b0;
            r_state <= CHANGE_CHECK;
            r_check_value <= test_expr;
            i <= num_clks;
          end
        CHANGE_CHECK:
          begin
            // Count clock ticks
            if (start_event == 1'b1) begin
              if ((flag == FLAG_IGNORE_NEW_START && i > 0)
                i <= i-1;
              else if (flag == FLAG_RESET_ON_START)
                i <= num_clks;
              else if (flag == FLAG_ERR_ON_START) begin
                error_count = error_count + 1;
                `ifdef ASSERT_MAX_REPORT_ERROR
                if (error_count <= ASSERT_MAX_REPORT_ERROR)
                `endif
                  $display(""%s: illegal start event : time %0t : %m"", $time);
                if (`severity_level == 0) $finish;
              end
          else begin
            // Illegal 'flag' parameter value specified
            // during instantiation!
            error_count = error_count + 1;
            `ifdef ASSERT_MAX_REPORT_ERROR
","The image shows a page from a book or document with the heading ""ASSERTION MONITORS"" and a snippet of Verilog code that appears to be related to monitoring state changes and reporting errors based on certain flag conditions in a digital design.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p192.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
@ (posedge clk) bgack |-> not ($isunknown(busgnt));
```

And another snippet below within a `property` construct:

```verilog
property ucheck;
    @(posedge clk) bgack |-> $isunknown(busgnt);
endproperty
```","
@ (posedge clk) bgack |-> not ($isunknown(busgnt));


property ucheck;
    @(posedge clk) bgack |-> $isunknown(busgnt);
endproperty
",A textbook excerpt explaining the use of `$isunknown` in Verilog for checking if an expression contains unknown values ('X' or 'Z').,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p103.jpg,True,"There is indeed code in the image, related to PSL (Property Specification Language) embedded within Verilog. The code in the image is as follows:

```verilog
// PSL assert always (req -> next ack) ;
```

For a recommended technique for PSL properties and assertions spanning multiple lines, the image provides another example:

```verilog
/* PSL
property req_ack = always (req -> next ack);
assert req_ack;
*/
```","
// PSL assert always (req -> next ack) ;


/* PSL
property req_ack = always (req -> next ack);
assert req_ack;
*/
","""Embedding PSL assertions within Verilog code using pragma directives""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p127.jpg,True,"The image contains Verilog code. Here it is:

```verilog
module signed_adder_with_carry_in
(input logic signed [3:0] a, b, // signed 4-bit inputs
input logic ci, // unsigned 1-bit input
output logic signed [3:0] sum, // signed 4-bit output
output logic co); // unsigned 1-bit output

assign {co, sum} = a + b + signed' (ci); // GOTCHA! ci is subtracted
endmodule
```

```verilog
assign {co, sum} = a + b + signed'({1'b0, ci}); // signed 5-bit
// adder

The signed'({1'b0, ci}) operation creates a 2-bit signed operand, with the sign bit always zero. When the 2-bit signed value is sign-extended to the size of the largest vector in the expression context, the sign extension will zero-extend, maintaining the positive value of the carry-in bit.
```","
module signed_adder_with_carry_in
(input logic signed [3:0] a, b, // signed 4-bit inputs
input logic ci, // unsigned 1-bit input
output logic signed [3:0] sum, // signed 4-bit output
output logic co); // unsigned 1-bit output

assign {co, sum} = a + b + signed' (ci); // GOTCHA! ci is subtracted
endmodule


assign {co, sum} = a + b + signed'({1'b0, ci}); // signed 5-bit
// adder

The signed'({1'b0, ci}) operation creates a 2-bit signed operand, with the sign bit always zero. When the 2-bit signed value is sign-extended to the size of the largest vector in the expression context, the sign extension will zero-extend, maintaining the positive value of the carry-in bit.
","Caption: ""Understanding Sign Casting in Verilog Code to Avoid Signed Arithmetic Gotchas""
",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p231.jpg,True,"```verilog
always@(Clk) #10 Clk = !Clk;
Clk is updated while always is disabled; always only runs once.

always@(Clk) #10 Clk <= !Clk;
Clk is updated while always is enabled; always runs on every update.
```","
always@(Clk) #10 Clk = !Clk;
Clk is updated while always is disabled; always only runs once.

always@(Clk) #10 Clk <= !Clk;
Clk is updated while always is enabled; always runs on every update.
","This image contains text explaining the event processing in Verilog simulation, especially how the `always` blocks are read and disabled during simulation to prevent hangs, with example Verilog code snippets.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p133.jpg,True,"The image contains snippets of Verilog code. Here they are:

```verilog
always @(posedge clock)
    if (mem_en && write) mem[addr] <= data_in; // OK, no side effects
```

And the following block defining a function and its usage in an `always` block:

```verilog
always @(posedge clock)
    if ((f(i1,o1) && f(i2,o2)) // GOTCHA! possible side effects
        mem[addr] <= data_in;

function f(input [7:0] d_in, output [7:0] d_out);
    d_out = d_in + 1;
    if (d_out == 255) return 0;
    else              return 1;
endfunction
```","
always @(posedge clock)
    if (mem_en && write) mem[addr] <= data_in; // OK, no side effects


always @(posedge clock)
    if ((f(i1,o1) && f(i2,o2)) // GOTCHA! possible side effects
        mem[addr] <= data_in;

function f(input [7:0] d_in, output [7:0] d_out);
    d_out = d_in + 1;
    if (d_out == 255) return 0;
    else              return 1;
endfunction
","""Discussion of operator short-circuiting behavior in Verilog and its simulation implications, with code examples.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p186.jpg,True,"The image contains a snippet of Verilog code which includes a property definition and assertion for checking a signal pattern. Here is the code:

```verilog
property strictlyOneAck;
    @(posedge clk) $rose(req) |=> (not (!ack[*0:$] ##1 $rose(req)) );
endproperty

strictlyOneAckP: assert property (strictlyOneAck)
    else $display($stime,,,""\tError: strictlyOneAck FAIL"");
```","
property strictlyOneAck;
    @(posedge clk) $rose(req) |=> (not (!ack[*0:$] ##1 $rose(req)) );
endproperty

strictlyOneAckP: assert property (strictlyOneAck)
    else $display($stime,,,""\tError: strictlyOneAck FAIL"");
","""Correct use of the 'not' operator in sequential Verilog assertions to avoid vacuous passes.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p483.jpg,True,"The image contains code from a document or book that pertains to Verilog and ACC (Application Control Constructs) routine usage. Here's the code extracted from the image:

```c
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */
/***********************************************************************
* checktf application
***********************************************************************/
int PLIbook_ShowSignals3_checktf()
{
    int i, numargs;

    acc_initialize();
    numargs = tf_nump();
    if (numargs == 0)
        return(0); /* no arguments is OK, skip remaining checks */
    for (i = 1; i <= numargs; i++) {
        if (tf_typep(i) == TF_NULLPARAM)
            break; /* null argument is OK, skip other checks for this arg */
        else if (acc_fetch_type(acc_handle_tfarg(i)) != accModule)
            tf_error(""$show_all_signals arg must be a module instance."");
    }
    acc_close();
    return(0);
}

/***********************************************************************
* calltf application;
* PLIbook_GetAllSignals(); /* prototype function used by calltf */
***********************************************************************/
void PLIbook_ShowSignals3_calltf()
{
    handle module_h;
    int i, numargs;
    acc_initialize();
    numargs = tf_nump();
    if (numargs == 0) {
        module_h = acc_handle_scope(acc_handle_tfarg(1));
        PLIbook_GetAllSignals(module_h);
    } else {
        for (i = 1; i <= numargs; i++) {
            if (tf_typep(i) == tf_nullparam)
                module_h = acc_handle_scope(acc_handle_tfarg(i));
            PLIbook_GetAllSignals(module_h);
        }
    }
}
```

This code is related to Verilog Procedural Interface (VPI), which is an interface for Verilog that allows interaction between Verilog and C programming language. The code snippets seem to be checking and handling simulation data from a testbench.","ude ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */
/***********************************************************************
* checktf application
***********************************************************************/
int PLIbook_ShowSignals3_checktf()
{
    int i, numargs;

    acc_initialize();
    numargs = tf_nump();
    if (numargs == 0)
        return(0); /* no arguments is OK, skip remaining checks */
    for (i = 1; i <= numargs; i++) {
        if (tf_typep(i) == TF_NULLPARAM)
            break; /* null argument is OK, skip other checks for this arg */
        else if (acc_fetch_type(acc_handle_tfarg(i)) != accModule)
            tf_error(""$show_all_signals arg must be a module instance."");
    }
    acc_close();
    return(0);
}

/***********************************************************************
* calltf application;
* PLIbook_GetAllSignals(); /* prototype function used by calltf */
***********************************************************************/
void PLIbook_ShowSignals3_calltf()
{
    handle module_h;
    int i, numargs;
    acc_initialize();
    numargs = tf_nump();
    if (numargs == 0) {
        module_h = acc_handle_scope(acc_handle_tfarg(1));
        PLIbook_GetAllSignals(module_h);
    } else {
        for (i = 1; i <= numargs; i++) {
            if (tf_typep(i) == tf_nullparam)
                module_h = acc_handle_scope(acc_handle_tfarg(i));
            PLIbook_GetAllSignals(module_h);
        }
    }
}
","Caption: ""Verilog code example of ACC (Access Routines) in use, demonstrating how to obtain handles for multiple module instances.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p494.jpg,True,"The image contains two code examples in Verilog, which are provided below:

First Code Example:
```verilog
a1: assert #0 (e1);

always_comb begin
    // ...
    if (en) begin
        // ...
        a2: assert #0 (e2);
    end else // ...
end
```

Second Code Example (rewritten for Formal Verification - FV):
```verilog
a1: assert property (@(s$global_clock e1));

always_comb begin
    // ...
    if (en) begin
        // ...
        a2: assert property (@(s$global_clock e2));
    end else // ...
end
```

These examples illustrate how deferred assertions in Verilog might be transformed into concurrent assertions for the purpose of formal verification, with specific emphasis on the treatment of the timing of these assertions with respect to a global clock.","
a1: assert #0 (e1);

always_comb begin
    // ...
    if (en) begin
        // ...
        a2: assert #0 (e2);
    end else // ...
end


a1: assert property (@(s$global_clock e1));

always_comb begin
    // ...
    if (en) begin
        // ...
        a2: assert property (@(s$global_clock e2));
    end else // ...
end
","Caption: ""Discussion on the transformation of immediate and deferred assertions in Verilog for Formal Verification, with example Verilog code illustrating the use of assert property in an always_comb block.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p219.jpg,True,"The image contains Verilog code. Here's the code text from the image:

```verilog
module FIFOstateM
    #(parameter AddrHi=4)
     ( output [AddrHi:0] ReadAddr, WriteAddr
     , . . .
     , Clk, Reset
     );
  reg [AddrHi:0] ReadAddrReg, WriteAddrReg;
  . . .
  reg
    EmptyFIFOReg, FullFIFOReg
  , ReadCmdReg, WriteCmdReg;
  . . . 
  // 
  assign #1 ReadAddr = ReadAddrReg;
  assign #1 WriteAddr = WriteAddrReg;
  assign #1 EmptyFIFO = EmptyFIFOReg;
  assign #1 FullFIFO = FullFIFOReg;
  assign #1 ReadCmd = ReadCmdReg;
  assign #1 WriteCmd = WriteCmdReg;
  . . .
```

The code snippet showcases a Verilog module named `FIFOstateM` with continuous assignment statements that include a delay of `#1`. The remaining parts of the code have been omitted and replaced with `. . .` in the text.","
module FIFOstateM
    #(parameter AddrHi=4)
     ( output [AddrHi:0] ReadAddr, WriteAddr
     , . . .
     , Clk, Reset
     );
  reg [AddrHi:0] ReadAddrReg, WriteAddrReg;
  . . .
  reg
    EmptyFIFOReg, FullFIFOReg
  , ReadCmdReg, WriteCmdReg;
  . . . 
  // 
  assign #1 ReadAddr = ReadAddrReg;
  assign #1 WriteAddr = WriteAddrReg;
  assign #1 EmptyFIFO = EmptyFIFOReg;
  assign #1 FullFIFO = FullFIFOReg;
  assign #1 ReadCmd = ReadCmdReg;
  assign #1 WriteCmd = WriteCmdReg;
  . . .
","""Verilog code excerpt discussing the use of blocking assignments and continuous assignments within a FIFO state machine module.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p497.jpg,True,"The image contains a fragment of C code that interfaces with Verilog using the ACC (Application Component Interface) routines. Here is the code snippet from the image:

```c
handle port_handle, module_handle;
/* add code to obtain handle for a port */
module_handle = acc_handle_parent(port_handle);
```

The rest of the text refers to ACC next routines used in Verilog simulations, but does not include any additional code segments.","e port_handle, module_handle;
/* add code to obtain handle for a port */
module_handle = acc_handle_parent(port_handle);
","The image shows a page from a textbook detailing the ACC (Access) Routine Library in the context of Verilog, with an example code snippet and a list of ACC next routines.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p480.jpg,True,"```verilog
assume property (R) ;
```","
assume property (R) ;
","""Explanation of assumptions in formal verification with a Verilog code example for property assumption.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p151.jpg,True,"The image contains some Verilog code. Here's the code from the image:

```verilog
# 110 clk=1read_enb=1 readStartState=1 readIDState=1 readDataState=1 readEndState=0
# 120 clk=0read_enb=1 readStartState=1 readIDState=1 readDataState=1 readEndState=0
# 130 clk=1read_enb=1 readStartState=1 readIDState=1 readDataState=1 readEndState=0
# 140 clk=0read_enb=1 readStartState=1 readIDState=1 readDataState=1 readEndState=1
# 150 clk=1read_enb=1 readStartState=1 readIDState=1 readDataState=1 readEndState=1
# 150 PASS
*/

sequence check_rd_adr;
    { (rd_addr == $past (rd_addr+1) ) && read } [*0:$] ##1 $fell(read);
endsequence

sequence read_cycle;
    {$rose(read) && reset_};
endsequence

property burst_check;
    @(posedge clk) read_cycle |-> check_rd_adr;
endproperty
```

Please note that in the provided code, there might be some syntax errors or omissions in the comments, but I've transcribed it exactly as it appears in the image.","
# 110 clk=1read_enb=1 readStartState=1 readIDState=1 readDataState=1 readEndState=0
# 120 clk=0read_enb=1 readStartState=1 readIDState=1 readDataState=1 readEndState=0
# 130 clk=1read_enb=1 readStartState=1 readIDState=1 readDataState=1 readEndState=0
# 140 clk=0read_enb=1 readStartState=1 readIDState=1 readDataState=1 readEndState=1
# 150 clk=1read_enb=1 readStartState=1 readIDState=1 readDataState=1 readEndState=1
# 150 PASS
*/

sequence check_rd_adr;
    { (rd_addr == $past (rd_addr+1) ) && read } [*0:$] ##1 $fell(read);
endsequence

sequence read_cycle;
    {$rose(read) && reset_};
endsequence

property burst_check;
    @(posedge clk) read_cycle |-> check_rd_adr;
endproperty
","Caption: ""Verilog example illustrating a consecutive repetition range operator and a sequence property for burst read verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p467.jpg,True,"The image contains C++ code for a static wrapper that interfaces with a Verilog transaction level counter. Here is the code:

```cpp
#ifdef __cplusplus
extern ""C"" {
#endif

void* counter7_new() {
    return new Counter7;
}

void counter7_count(void* inst) {
    Counter7 *c7 = (Counter7 *) inst;
    c7->count();
}

void counter7_load(void* inst, const svBitVecVal* i) {
    Counter7 *c7 = (Counter7 *) inst;
    c7->load(i);
}

void counter7_reset(void* inst) {
    Counter7 *c7 = (Counter7 *) inst;
    c7->reset();
}

int counter7_get(void* inst) {
    Counter7 *c7 = (Counter7 *) inst;
    return c7->get();
}

#ifdef __cplusplus
}
#endif
```

This wrapper is used to interface with Verilog or SystemVerilog code, allowing C++ objects and methods to be called from within a Verilog environment, which is a typical use case in hardware verification.","def __cplusplus
extern ""C"" {
#endif

void* counter7_new() {
    return new Counter7;
}

void counter7_count(void* inst) {
    Counter7 *c7 = (Counter7 *) inst;
    c7->count();
}

void counter7_load(void* inst, const svBitVecVal* i) {
    Counter7 *c7 = (Counter7 *) inst;
    c7->load(i);
}

void counter7_reset(void* inst) {
    Counter7 *c7 = (Counter7 *) inst;
    c7->reset();
}

int counter7_get(void* inst) {
    Counter7 *c7 = (Counter7 *) inst;
    return c7->get();
}

#ifdef __cplusplus
}
#endif
","Caption: Example of a static wrapper in C++ for a transaction-level counter, demonstrating interfacing with SystemVerilog.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p301.jpg,True,"The image contains some example code that appears to be written in the context of SystemVerilog, which is a hardware description and verification language. Here's the code that is visible in the image:

```systemverilog
Producer p;
Consumer c;

initial begin
    p = new();
    c = new();
    mbx = new();

    // Run the producer and consumer in parallel 
    fork
        p.run();
        c.run();
    join
end
endprogram
```

This code snippet seems to define a producer-consumer model where both `Producer` and `Consumer` are running in parallel using fork-join constructs. The `mbx` appears to be a mailbox used for communication between the producer and consumer. The text below the code refers to the producer and consumer running in lockstep and proposes using two mailboxes to synchronize the threads.","erilog
Producer p;
Consumer c;

initial begin
    p = new();
    c = new();
    mbx = new();

    // Run the producer and consumer in parallel 
    fork
        p.run();
        c.run();
    join
end
endprogram
","Caption: ""Example of a producer-consumer interprocess communication in Verilog, using thread synchronization with events.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p319.jpg,True,"Here are the Verilog code snippets from the image:

Code snippet associated with Fig. 13.11:

```verilog
a19: assert property(
    @(posedge clk)
    sync_accept_on(reset || $past(reset, , , @(posedge clk)))
    dOut == $past(dIn)
);
```

Code snippet associated with Fig. 13.12:

```verilog
a_abort_subproperties: assert property(
    @(posedge clk)
    a |=> 
    (accept_on (retry) b[*2])
    and
    (reject_on (bad) c |=> !c)
);
```","
a19: assert property(
    @(posedge clk)
    sync_accept_on(reset || $past(reset, , , @(posedge clk)))
    dOut == $past(dIn)
);


a_abort_subproperties: assert property(
    @(posedge clk)
    a |=> 
    (accept_on (retry) b[*2])
    and
    (reject_on (bad) c |=> !c)
);
","""Examples of Verilog assertion properties with abort conditions for reset and multiple subproperties""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p315.jpg,True,"```verilog
class BadTr extends Transaction;
  rand bit bad_csm;

  virtual function void calc_csm();
    super.calc_csm(); // Compute good csm
    if (bad_csm) csm = ~csm; // Corrupt the csm bits
  endfunction

  virtual function void display(input string prefix="""");
    $write(""%sBadTr: bad_csm=%b, "", prefix, bad_csm);
    super.display();
  endfunction
```
","
class BadTr extends Transaction;
  rand bit bad_csm;

  virtual function void calc_csm();
    super.calc_csm(); // Compute good csm
    if (bad_csm) csm = ~csm; // Corrupt the csm bits
  endfunction

  virtual function void display(input string prefix="""");
    $write(""%sBadTr: bad_csm=%b, "", prefix, bad_csm);
    super.display();
  endfunction
","Caption: ""Example of Verilog code demonstrating the extension of a Transaction class to create a BadTr class, including methods to calculate and display checksum.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p145.jpg,True,"```verilog
sequence Sc1;
  a ##[1:2*5] ##1 c;
endsequence

property ab;
  @(posedge clk) a |-> Sc1;
endproperty
```

The image contains this Verilog code snippet showing a sequence and a property using SystemVerilog's consecutive repetition range operator `##[m:n]`.","
sequence Sc1;
  a ##[1:2*5] ##1 c;
endsequence

property ab;
  @(posedge clk) a |-> Sc1;
endproperty
",An educational snippet explaining the Verilog consecutive repetition range operator with a code example and waveform simulation output.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p473.jpg,True,"The image contains two snippets of code, one that appears to be written in Verilog (for the testbench) and another in C (for a function interfacing with the testbench). Here they are:

Verilog Code:
```verilog
import ""DPI-C"" function void mydisplay(inout int h[][]);

program automatic test;
  int a[6:1][8:3];  // Note word ranges are high:low
  initial begin
    foreach (a[i,j]) a[i][j] = i+j;
    mydisplay(a);
    foreach (a[i,j])
      $display(""V: a[%0d][%0d] = %0d"", i, j, a[i][j]);
  end
endprogram
```

C Code:
```c
void mydisplay(const svOpenArrayHandle h) {
  int i, j;
  int lo1 = svLow(h, 1);
  int hi1 = svHigh(h, 1);
  int lo2 = svLow(h, 2);
  int hi2 = svHigh(h, 2);
  for (i=lo1; i<=hi1; i++) {
    for (j=lo2; j<=hi2; j++) {
      int *a = (int*) svGetArrElemPtr2(h, i, j);
      io_printf(""C: a[%d][%d] = %d\n"", i, j, *a);
      *a = i * j;
    }
  }
}
```

These code samples demonstrate how to interface with C/C++ from within Verilog code using the DPI-C import functionality, particularly with multi-dimensional arrays.","
import ""DPI-C"" function void mydisplay(inout int h[][]);

program automatic test;
  int a[6:1][8:3];  // Note word ranges are high:low
  initial begin
    foreach (a[i,j]) a[i][j] = i+j;
    mydisplay(a);
    foreach (a[i,j])
      $display(""V: a[%0d][%0d] = %0d"", i, j, a[i][j]);
  end
endprogram

mydisplay(const svOpenArrayHandle h) {
  int i, j;
  int lo1 = svLow(h, 1);
  int hi1 = svHigh(h, 1);
  int lo2 = svLow(h, 2);
  int hi2 = svHigh(h, 2);
  for (i=lo1; i<=hi1; i++) {
    for (j=lo2; j<=hi2; j++) {
      int *a = (int*) svGetArrElemPtr2(h, i, j);
      io_printf(""C: a[%d][%d] = %d\n"", i, j, *a);
      *a = i * j;
    }
  }
}
","Caption: ""Interfacing Verilog with C using multi-dimensional open arrays and DPI-C functions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p468.jpg,True,"The image contains Verilog code. Here is the transcribed code:

```verilog
module test;
  wire a, b, ci, sum, co;
  addbit u1 (a, b, ci, sum, co);
endmodule

module addbit (a, b, ci, sum, co);
  input a, b, ci;
  output sum, co;
  wire a, b, ci, sum, co;

  xor    g1 (n1, a, b);
  xor #2 g2 (sum, n1, ci);
  and    g3 (n2, a, b);
  and    g4 (n3, n1, ci);
  or  #2 g5 (co, n2, n3);
endmodule
```

This code represents two modules in Verilog, `test` and `addbit`, which likely form part of a digital logic design. The `test` module instantiates the `addbit` module by calling it `u1` and connecting wires to it. The `addbit` module performs some logical operations, defining a simple adder circuit using XOR, AND, and OR gates with the instance names `g1`, `g2`, `g3`, `g4`, and `g5`.","
module test;
  wire a, b, ci, sum, co;
  addbit u1 (a, b, ci, sum, co);
endmodule

module addbit (a, b, ci, sum, co);
  input a, b, ci;
  output sum, co;
  wire a, b, ci, sum, co;

  xor    g1 (n1, a, b);
  xor #2 g2 (sum, n1, ci);
  and    g3 (n2, a, b);
  and    g4 (n3, n1, ci);
  or  #2 g5 (co, n2, n3);
endmodule
","Excerpt from ""The Verilog PLI Handbook,"" detailing the properties of object names in Verilog and presenting code examples to illustrate local, full, and definition names in Verilog modules.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p457.jpg,True,"```verilog
cov_shift: cover property (@(posedge clk) disable iff (rst)
shift_reg == 8'b10000000 && !set
##1 shift_reg == 8'b00000001);
```
The code provided is written in Verilog, which is a hardware description language used to model electronic systems. The code snippet is defining a cover property for formal verification, specifying conditions that need to be observed at the positive edge of a clock signal, with `disable iff (rst)` indicating the property should be disregarded if `rst` (reset) is true. The property checks that `shift_reg` is `8'b10000000` and `!set` (set is not asserted) in one clock cycle, followed by `shift_reg` being `8'b00000001` in the next clock cycle.","
cov_shift: cover property (@(posedge clk) disable iff (rst)
shift_reg == 8'b10000000 && !set
##1 shift_reg == 8'b00000001);
","""Discussion of Complete and Incomplete Methods in Formal Verification with a Verilog cover statement example.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p440.jpg,True,"The image contains a snippet of code that demonstrates interfacing between Verilog models and C functions using TF (Task Functions) routines. Here is the code as displayed in the image:

```c
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */

/* calltf routine: Serves as an interface between Verilog simulation
 * and the C model. Called whenever the C model inputs change value,
 * reads the input values, passes the values to the C model, and
 * writes the C model outputs into simulation.
 */

int PLIbook_ScientificALU_calltf()
{
    #define ALU_A        1 /* system task arg 1 is ALU A input */
    #define ALU_B        2 /* system task arg 2 is ALU B input */
    #define ALU_OP       3 /* system task arg 3 is ALU opcode input */
    #define ALU_RESULT   4 /* system task arg 4 is ALU result output */
    #define ALU_EXCEPT   5 /* system task arg 5 is ALU exception output */
    #define ALU_ERROR    6 /* system task arg 6 is ALU error output */

    double a, b, result;
    int opcode, excep, err;

    /* Read current values of C model inputs from Verilog simulation */
    a       = tf_getrealp(ALU_A);
    b       = tf_getrealp(ALU_B);
    opcode  = tf_getp(ALU_OP);

    /***** Call C model ******/
    PLIbook_ScientificALU_C_model(a, b, opcode, &result, &excep, &err);

    /* Write the C model outputs onto the Verilog signals */
    tf_putrealp(ALU_RESULT, result);
    tf_putp    (ALU_EXCEPT, excep);
    tf_putp    (ALU_ERROR, err);

    return(0);
}

/*******************************************************************/

/* checktf routine: Verifies that ScientificALU() is used correctly.
 * Note: For simplicity, only limited data types are allowed for
 * task arguments. Could add checks to allow other data types.
 */

int PLIbook_ScientificALU_checktf()
{
    acc_initialize();

    if (tf_nump() != 6)
        tf_error(""scientific_alu requires 6 arguments"");
    else {
        /* The next part of the code is not visible in the image. */
    }
}
```

The code defines two functions: `PLIbook_ScientificALU_calltf` and `PLIbook_ScientificALU_checktf`. `PLIbook_ScientificALU_calltf` is presumably used to interface with a C model, reading the input values from the Verilog simulation and passing them to the C model. It then writes the output of the C model back into the Verilog simulation. `PLIbook_ScientificALU_checktf` is used to verify that the task `ScientificALU()`, which is not shown here, is used correctly by ensuring it is invoked with the correct number of arguments.","ude ""veriuser.h"" /* IEEE 1364 PLI TF routine library */

/* calltf routine: Serves as an interface between Verilog simulation
 * and the C model. Called whenever the C model inputs change value,
 * reads the input values, passes the values to the C model, and
 * writes the C model outputs into simulation.
 */

int PLIbook_ScientificALU_calltf()
{
    #define ALU_A        1 /* system task arg 1 is ALU A input */
    #define ALU_B        2 /* system task arg 2 is ALU B input */
    #define ALU_OP       3 /* system task arg 3 is ALU opcode input */
    #define ALU_RESULT   4 /* system task arg 4 is ALU result output */
    #define ALU_EXCEPT   5 /* system task arg 5 is ALU exception output */
    #define ALU_ERROR    6 /* system task arg 6 is ALU error output */

    double a, b, result;
    int opcode, excep, err;

    /* Read current values of C model inputs from Verilog simulation */
    a       = tf_getrealp(ALU_A);
    b       = tf_getrealp(ALU_B);
    opcode  = tf_getp(ALU_OP);

    /***** Call C model ******/
    PLIbook_ScientificALU_C_model(a, b, opcode, &result, &excep, &err);

    /* Write the C model outputs onto the Verilog signals */
    tf_putrealp(ALU_RESULT, result);
    tf_putp    (ALU_EXCEPT, excep);
    tf_putp    (ALU_ERROR, err);

    return(0);
}

/*******************************************************************/

/* checktf routine: Verifies that ScientificALU() is used correctly.
 * Note: For simplicity, only limited data types are allowed for
 * task arguments. Could add checks to allow other data types.
 */

int PLIbook_ScientificALU_checktf()
{
    acc_initialize();

    if (tf_nump() != 6)
        tf_error(""scientific_alu requires 6 arguments"");
    else {
        /* The next part of the code is not visible in the image. */
    }
}
",A textbook page showing Verilog code for interfacing with a C model using TF (task/function) routines.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p326.jpg,True,"The image contains code and text related to the use of the `tf_nump()` function in Verilog. Here is the code from the image:

```verilog
if (tf_nump() != 2 )
    tf_error(""$read_test_vector has %d args, requires 2.\n"", tf_nump());

numargs = tf_nump();
for (i=1; i<= numargs; i++)
    ...
```

In addition, there are snippets illustrating how `tf_nump()` could return different values depending on how a Verilog system task `$read_test_vector` is called:

1. `$read_test_vector(""vectors.pat"", , in);` - `tf_nump() returns 3`
2. `$read_test_vector(in);` - `tf_nump() returns 1`
3. `$read_test_vector();` - `tf_nump() returns 1`
4. `$read_test_vector;` - `tf_nump() returns 0`

Please note that the code snippets are interspersed with text, and I've only included the parts that are clearly code.","
if (tf_nump() != 2 )
    tf_error(""$read_test_vector has %d args, requires 2.\n"", tf_nump());

numargs = tf_nump();
for (i=1; i<= numargs; i++)
    ...
",Verilog Programming: Understanding the Use of `tf_nump()` in TF Routines and Argument Handling,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p331.jpg,True,"The image contains two code snippets written in Verilog. Here's the first one:

```verilog
always @(ev) begin
  automatic dataT d = pipeline.pop_front();
  store[ptr] = d;
  a15: assert property (@(posedge clk) store[const'(ptr)] == d);
  ptr = next_ptr(ptr);
end
```

And here's the second one:

```verilog
logic treg;
logic [3:0] dreg;
logic [7:0] tr;
//...
always @(posedge clk) begin
  if (treg) begin
    for (int i = 0; i < 4; i++) begin
```

Note that the second snippet is incomplete and continues beyond what's shown in the image.","
always @(ev) begin
  automatic dataT d = pipeline.pop_front();
  store[ptr] = d;
  a15: assert property (@(posedge clk) store[const'(ptr)] == d);
  ptr = next_ptr(ptr);
end


logic treg;
logic [3:0] dreg;
logic [7:0] tr;
//...
always @(posedge clk) begin
  if (treg) begin
    for (int i = 0; i < 4; i++) begin
","Caption: ""Excerpt from a technical document illustrating the use of const casting for static variables in procedural concurrent assertions in Verilog, with an example of an assertion within a for-loop.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p329.jpg,True,"The image contains Verilog code. Here it is:

```verilog
// Not recommended
class EthMacFrame;
  typedef enum {II, IEEE} kind_e;
  rand kind_e kind;
  rand bit [47:0] da, sa;
  rand bit [15:0] len;
  
  ...
  rand Vlan vlan_h;
endclass

class Vlan;
  rand bit [15:0] vlan;
endclass
```

The text surrounding the code discusses issues with using composition in the context of creating classes for Ethernet frames in Verilog and provides a critique of the presented code example.","
// Not recommended
class EthMacFrame;
  typedef enum {II, IEEE} kind_e;
  rand kind_e kind;
  rand bit [47:0] da, sa;
  rand bit [15:0] len;
  
  ...
  rand Vlan vlan_h;
endclass

class Vlan;
  rand bit [15:0] vlan;
endclass
",Verilog code example discussing the disadvantages of using composition in building an Ethernet frame class structure.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p325.jpg,True,"```verilog
module b1Unit(input bit clk, rst, ...);
    bit running;
    initial begin: B1
        if (!rst) begin
            a3: assert property (@(posedge clk) running until rst);
            ...
        end
    end
    ...
endmodule
```","
module b1Unit(input bit clk, rst, ...);
    bit running;
    initial begin: B1
        if (!rst) begin
            a3: assert property (@(posedge clk) running until rst);
            ...
        end
    end
    ...
endmodule
","""Explaining the Use of Concurrent Assertions in Verilog Procedural Code""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p454.jpg,True,"This image contains a snippet of code in Verilog. Here is the code from the image:

```verilog
PLIbook_ScientificALU_C_model(enable, a, b, opcode,
                               &result, &excep, &err, instance_p);

/* Write the C model outputs onto the Verilog signals */
tf_putrealp(ALU_RESULT, result);
tf_putp    (ALU_EXCEPT, excep);
tf_putp    (ALU_ERROR, err);

return(0);
}
```

The code appears to be from a book or a document discussing how to interface C models with Verilog using Task Function (TF) routines.","
PLIbook_ScientificALU_C_model(enable, a, b, opcode,
                               &result, &excep, &err, instance_p);

/* Write the C model outputs onto the Verilog signals */
tf_putrealp(ALU_RESULT, result);
tf_putp    (ALU_EXCEPT, excep);
tf_putp    (ALU_ERROR, err);

return(0);
}
","""Interfacing C models with Verilog using TF routines and representing propagation delays.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p179.jpg,True,"```verilog
`define true 1'b1
property check_irdy;
    @(posedge clk) `true[*1:8] intersect ($fell(frame_) ##[1:$] $fell(irdy_));
endproperty

iCheck: assert property (check_irdy);
```

```verilog
property checkRW;
    @(posedge clk)
        $rose(CPU_Start) |=> WRITE_complete [-1] intersect READ_complete [-2];
endproperty
```","
`define true 1'b1
property check_irdy;
    @(posedge clk) `true[*1:8] intersect ($fell(frame_) ##[1:$] $fell(irdy_));
endproperty

iCheck: assert property (check_irdy);


property checkRW;
    @(posedge clk)
        $rose(CPU_Start) |=> WRITE_complete [-1] intersect READ_complete [-2];
endproperty
","""Exploring the use of the 'intersect' operator in Verilog for specifying temporal properties in hardware verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p459.jpg,True,"The image contains C code that appears to be an example from a book related to interfacing with SystemVerilog using C/C++. Here's the code presented in the image:

```c
#include <svdpi.h>
#include <malloc.h>
#include <veriuser.h>

typedef struct { // Structure to hold counter value
    unsigned char cnt;
} c7;

// Construct a counter structure
void* counter7_new() {
    c7* c = (c7*) malloc(sizeof(c7)); // Cast malloc value to c7
    c->cnt = 0;
    return c;
}

// Process the counter inputs
void counter7(c7 *inst,
              svBitVecVal* count,
              const svBitVecVal* i,
              const svBit reset,
              const svBit load) {
    if (reset)
        inst->cnt = 0; // Reset
    else if (load)
        inst->cnt = *i; // Load value
    else
        inst->cnt++; // Count
    inst->cnt &= 0x7f; // Mask upper bit

    *count = inst->cnt; // Write to output
    io_printf(""C: count=%d, i=%d, reset=%d, load=%d\n"",
        *count, *i, reset, load);
}
```

The code shows a simple counter structure being defined and the associated functions to create a new counter and to process inputs for the counter. These functions are typically used in conjunction with SystemVerilog through the DPI (Direct Programming Interface), as suggested by the inclusion of `svdpi.h` and `veriuser.h`, which are associated with SystemVerilog DPI calls.","ude <svdpi.h>
#include <malloc.h>
#include <veriuser.h>

typedef struct { // Structure to hold counter value
    unsigned char cnt;
} c7;

// Construct a counter structure
void* counter7_new() {
    c7* c = (c7*) malloc(sizeof(c7)); // Cast malloc value to c7
    c->cnt = 0;
    return c;
}

// Process the counter inputs
void counter7(c7 *inst,
              svBitVecVal* count,
              const svBitVecVal* i,
              const svBit reset,
              const svBit load) {
    if (reset)
        inst->cnt = 0; // Reset
    else if (load)
        inst->cnt = *i; // Load value
    else
        inst->cnt++; // Count
    inst->cnt &= 0x7f; // Mask upper bit

    *count = inst->cnt; // Write to output
    io_printf(""C: count=%d, i=%d, reset=%d, load=%d\n"",
        *count, *i, reset, load);
}
","""Example of C code interacting with a SystemVerilog counter using DPI-C interface.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p456.jpg,True,"The image shows some Verilog code. Here is the code from the image:

```verilog
// add buffers to all ports, with nets connected to each buffer
// (this example uses the array of instance syntax in the
// from the IEEE 1364-1995 Verilog standard
buf result_buf[63:0] (result_out, result_vector);
buf excep_buf        (exception, exception_reg);
buf error_buf        (error, error_reg);

buf a_buf[63:0]      (a_vector, a_in);
buf b_buf[63:0]      (b_vector, b_in);
buf opcode_buf[3:0]  (opcode_vector, opcode_in);

endmodule
```

The note underneath the code reads:

""NOTE
The preceding example uses the array of instances construct from the IEEE 1364-1995 Verilog standard. This construct was not supported by some Verilog simulators at the time this book was written. A work around is to create a separate instance of a buf primitive for each bit or each vector connected to a module port.""","
// add buffers to all ports, with nets connected to each buffer
// (this example uses the array of instance syntax in the
// from the IEEE 1364-1995 Verilog standard
buf result_buf[63:0] (result_out, result_vector);
buf excep_buf        (exception, exception_reg);
buf error_buf        (error, error_reg);

buf a_buf[63:0]      (a_vector, a_in);
buf b_buf[63:0]      (b_vector, b_in);
buf opcode_buf[3:0]  (opcode_vector, opcode_in);

endmodule
","""Excerpt from a textbook explaining interfacing to C models using TF routines in Verilog, including an example Verilog code snippet.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p327.jpg,True,"The image contains Verilog code examples. Here are the code snippets from it:

Example 14.5:
```verilog
logic clk;
...
always @(clk) begin
    d1 <= i1|i2;
    a5: assert property (d1 |=> i3|i4);
    dout <= f_ecap(d1);
end
```

Example 14.6:
```verilog
event ev;
...
always @(ev) begin
    d1 <= i1|i2;
    a6: assert property (d1 |=> i3|i4);
    dout <= f_ecap(d1);
end
```

Example 14.7:
```verilog
always @(posedge(e1|e2) iff !reset) begin
    d1 <= i1|i2;
    e1N = ~e1;
    a7: assert property (d1 |=> i3|i4);
    dout <= f_ecap(d1);
end
```

Example 14.8:
```verilog
always @(posedge(e1|e2)) begin
    d1 <= i1|i2;
    a8_1: assert property (d1 |=> i3|i4);
    a8_2: assert property (@(negedge e1) |e2);
end
```","
logic clk;
...
always @(clk) begin
    d1 <= i1|i2;
    a5: assert property (d1 |=> i3|i4);
    dout <= f_ecap(d1);
end


event ev;
...
always @(ev) begin
    d1 <= i1|i2;
    a6: assert property (d1 |=> i3|i4);
    dout <= f_ecap(d1);
end


always @(posedge(e1|e2) iff !reset) begin
    d1 <= i1|i2;
    e1N = ~e1;
    a7: assert property (d1 |=> i3|i4);
    dout <= f_ecap(d1);
end


always @(posedge(e1|e2)) begin
    d1 <= i1|i2;
    a8_1: assert property (d1 |=> i3|i4);
    a8_2: assert property (@(negedge e1) |e2);
end
","Caption: ""Examples of Verilog code illustrating when no clock is inferred from logic variables, the use of event variables as clock signals, and the inference rules related to edge operators and procedural assignments in assertion contexts.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p330.jpg,True,"```verilog
always @(posedge clock)
   $read_test_vector(""A.dat"", data_bus);

always @(negedge clock)
   $read_test_vector(""B.dat"", data_bus);
```
These are the lines of Verilog HDL code included in the image.","
always @(posedge clock)
   $read_test_vector(""A.dat"", data_bus);

always @(negedge clock)
   $read_test_vector(""B.dat"", data_bus);
","""Explanation of using the TF work area for unique instance data storage in Verilog HDL, featuring code that reads vectors on clock edges.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p318.jpg,True,"The image contains text and a snippet of Verilog code. Here is the Verilog code from the image:

```verilog
always @(posedge clock)
    $read_test_vector(""vectors.pat"", input_bus);
```

Some important points from the text about the code snippet:

- Task/Function argument number 1 is a string, with the value ""vectors.pat"".
- Task/Function argument number 2 is a signal, with the name input_bus.

Most of the TF routines in the PLI library are used for the purpose of accessing information about user-defined system task/function arguments.","
always @(posedge clock)
    $read_test_vector(""vectors.pat"", input_bus);
","Caption: ""A section from a technical document discussing the advantages of the TF library in Verilog and detailing the usage of system task/function arguments.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p465.jpg,True,"The image provided contains C++ code that is interfacing with SystemVerilog using static methods. Here is the code from the image:

```cpp
extern ""C"" void* counter7_new()
{
    return new Counter7;
}

// Call a counter instance, passing the signal values
extern ""C"" void counter7(void* inst,
                         svBitVecVal* count,
                         const svBitVecVal* i,
                         const svBit reset,
                         const svBit load)
{
    Counter7* c7 = (Counter7 *) inst;
    c7->counter7_signal(count, i, reset, load);
}
```

The `extern ""C""` declaration specifies that the linkage for the functions is to be in ""C"" language linkage, which avoids C++ name mangling and allows these functions to be called from SystemVerilog code. The function `counter7_new` is intended to create a new instance of a `Counter7` object, and the function `counter7` is intended to call a method on that instance, passing signal values to it.","ern ""C"" void* counter7_new()
{
    return new Counter7;
}

// Call a counter instance, passing the signal values
extern ""C"" void counter7(void* inst,
                         svBitVecVal* count,
                         const svBitVecVal* i,
                         const svBit reset,
                         const svBit load)
{
    Counter7* c7 = (Counter7 *) inst;
    c7->counter7_signal(count, i, reset, load);
}
","Caption: ""Interfacing between Verilog and C++ using the Direct Programming Interface (DPI) with static methods for creating and calling a counter instance.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p471.jpg,True,"The image contains two code snippets. One is written in SystemVerilog and the other in C. Below are the contents of the two code snippets:

SystemVerilog code snippet (Sample 12.22):
```verilog
import ""DPI-C"" function void fib_oa(output bit [31:0] data[]);

program automatic test;
    parameter SIZE = 20;
    bit [31:0] data[SIZE], r;

    initial begin
        fib_oa(data, SIZE);
        foreach (data[i])
            $display(i,data[i]);
    end
endprogram
```

C code snippet (Sample 12.23):
```c
void fib_oa(const svOpenArrayHandle data_oa) {
    int i, *data;
    data = (int *) svGetArrayPtr(data_oa);
    data[0] = 1;
    data[1] = 1;
    for (i=2; i<svSize(data_oa, 1); i++)
        data[i] = data[i-1] + data[i-2];
}
```","
import ""DPI-C"" function void fib_oa(output bit [31:0] data[]);

program automatic test;
    parameter SIZE = 20;
    bit [31:0] data[SIZE], r;

    initial begin
        fib_oa(data, SIZE);
        foreach (data[i])
            $display(i,data[i]);
    end
endprogram

fib_oa(const svOpenArrayHandle data_oa) {
    int i, *data;
    data = (int *) svGetArrayPtr(data_oa);
    data[0] = 1;
    data[1] = 1;
    for (i=2; i<svSize(data_oa, 1); i++)
        data[i] = data[i-1] + data[i-2];
}
",Verilog and C code snippets demonstrating the use of open arrays for interfacing between SystemVerilog and C.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p147.jpg,True,"The image contains snippets of SystemVerilog code related to the use of consecutive repetition range operators. Here are the code snippets visible in the image:

Snippet from the first block of text:
```verilog
@(posedge clk) $rose(tagError) |-> ##1 $rose(trErrorBit) ##0 trErrorBit[*1:$] ##0 $rose(mCheck);
```

Snippet from the second block of text:
```verilog
property checkDevSelSpecialCycle;
@(posedge clk)
  $fell(FRAME_) && (CMD == 4'b0001) |-> DEVS EL_ [*1:$] ##0 $rose(FRAME_);
endproperty
```

Note that `DEVS EL_` in the second snippet looks like it might be a typo or an issue with the spacing. It is more likely supposed to be `DEVS_EL` or something similar without the space. This is a common notation for signal names in hardware description languages like Verilog and SystemVerilog.","
@(posedge clk) $rose(tagError) |-> ##1 $rose(trErrorBit) ##0 trErrorBit[*1:$] ##0 $rose(mCheck);


property checkDevSelSpecialCycle;
@(posedge clk)
  $fell(FRAME_) && (CMD == 4'b0001) |-> DEVS EL_ [*1:$] ##0 $rose(FRAME_);
endproperty
",Caption: Examples of SystemVerilog Assertions using Consecutive Repetition Range Operators.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p317.jpg,True,"Here's the code from the image:

```verilog
class Driver;
mailbox#(Transaction) gen2drv; // Mbx betweenGenerator and here

function new(input mailbox#(Transaction) gen2drv);
    this.gen2drv = gen2drv;
endfunction

virtual task run();
    Transaction tr; // Handle to a Transaction object or
                    // a class extended from Transaction
    forever begin
        gen2drv.get(tr); // Get transaction from generator
        tr.calc_csm();   // Process the transaction
        @ifc.cb;
        ifc.cb.src <= tr.src; // Send transaction
        ...
    end
endtask
endclass
```

This code defines a `Driver` class in Verilog that can receive transactions from a generator using a mailbox and process those transactions.","
class Driver;
mailbox#(Transaction) gen2drv; // Mbx betweenGenerator and here

function new(input mailbox#(Transaction) gen2drv);
    this.gen2drv = gen2drv;
endfunction

virtual task run();
    Transaction tr; // Handle to a Transaction object or
                    // a class extended from Transaction
    forever begin
        gen2drv.get(tr); // Get transaction from generator
        tr.calc_csm();   // Process the transaction
        @ifc.cb;
        ifc.cb.src <= tr.src; // Send transaction
        ...
    end
endtask
endclass
",Verilog Driver Class Example: Shows a driver class in Verilog that receives transactions from a generator and processes them for a device under test (DUT).,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p119.jpg,True,"```verilog
logic [5:0] a = 6'b101010;  // 6-bit vector
logic [3:0] b = 4'b1111;    // 4-bit vector
logic [7:0] c;              // 8-bit vector

c = a & b;                  // results in 8-bit 00110101
```
The image contains code that demonstrates a concept in Verilog which involves bit-wise operations and how they are determined either by context or self-determined rules. It outlines an example of a bitwise AND operation and explains the expected output. There's also an explanation provided about self-determined operators and context-determined behavior in Verilog, as well as some cases to consider to avoid potential issues, referred to as ""gotchas.""","
logic [5:0] a = 6'b101010;  // 6-bit vector
logic [3:0] b = 4'b1111;    // 4-bit vector
logic [7:0] c;              // 8-bit vector

c = a & b;                  // results in 8-bit 00110101
","""Understanding Self-Determined and Context-Determined Operators in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p496.jpg,True,"```verilog
always @(posedge clk) begin
    // ...
    for (int i = 0; i < 4; i++) begin
        // ...
        if (en[i]) begin
            // ...
            a1: assert property (a[i] |-> z);
        end
    end
end
```","
always @(posedge clk) begin
    // ...
    for (int i = 0; i < 4; i++) begin
        // ...
        if (en[i]) begin
            // ...
            a1: assert property (a[i] |-> z);
        end
    end
end
",Verilog Code Snippet Showing an Embedded Assertion within a Clock-Driven Always Block,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p39.jpg,True,"Here is the Verilog code contained in the image:

Incorrect code with gotchas:
```verilog
module test (output [7:0] q, input [7:0] d, input ck, rst_n);
  \d-flop \d-0 (.q(q[0]), .\q~(\ ), .\d[0] (d[0]), // GOTCHA!
                .ck(ck), .\rst- (rst_n)); // GOTCHA!
initial begin
  $display(""d = %b"", test.\d-0.\d[0] ); // GOTCHA!
end
endmodule
```

Correct code to avoid the gotchas:
```verilog
module test (output [7:0] q, input [7:0] d, input ck, rst_n);
  \d-flop \d-0 (.q(q[0]), .\q~ (\ ), .\d[0] (d[0]), // CORRECT
                .ck(ck), .\rst- (rst_n)); // CORRECT
initial begin
  $display(""d = %b"", test.\d-0 .\d[0] ); // CORRECT
end
endmodule
```

Please note, in the correct code there is whitespace added after each escaped identifier to properly terminate each identifier as required by Verilog syntax rules.","
module test (output [7:0] q, input [7:0] d, input ck, rst_n);
  \d-flop \d-0 (.q(q[0]), .\q~(\ ), .\d[0] (d[0]), // GOTCHA!
                .ck(ck), .\rst- (rst_n)); // GOTCHA!
initial begin
  $display(""d = %b"", test.\d-0.\d[0] ); // GOTCHA!
end
endmodule


module test (output [7:0] q, input [7:0] d, input ck, rst_n);
  \d-flop \d-0 (.q(q[0]), .\q~ (\ ), .\d[0] (d[0]), // CORRECT
                .ck(ck), .\rst- (rst_n)); // CORRECT
initial begin
  $display(""d = %b"", test.\d-0 .\d[0] ); // CORRECT
end
endmodule
","""Exploring common pitfalls in Verilog coding related to escaped identifiers and hierarchical paths.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p481.jpg,True,"The image contains code relevant to Verilog simulations and the use of ACC routines. Here is the written-out code from the image:

```c
#include ""veriuser.h""                           /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""                          /* IEEE 1364 PLI ACC routine library */
/******************************************************************************************/
/* checktf application                                                                   */
/******************************************************************************************/
int PLIbook_ShowSignals2_checktf()
{
    acc_initialize();
    if (tf_nump() == 0)
        return(0);  /* no arguments is OK, skip remaining checks */
    if (tf_nump() > 1)
        tf_error(""$show_all_signals must have 0 or 1 argument."");
    else if (tf_typep(1) == tf_nullparam)
        return(0);  /* null argument is OK, skip remaining checks */
    else if (acc_fetch_type(acc_handle_tfarg(1)) != accModule)
        tf_error(""$show_all_signals arg must be a module instance."");
    acc_close();
    return(0);
}

/******************************************************************************************/
/* calltf application                                                                     */
/******************************************************************************************/
int PLIbook_ShowSignals2_calltf()
{
    handle module_h, signal_h;
    static int signal_types[6] = {accNet, accReg, accIntegerVar,
                                  accTimeVar, accRealVar, 0 };
```

Please note that the image only shows a portion of the code and does not include the complete code listing.","ude ""veriuser.h""                           /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""                          /* IEEE 1364 PLI ACC routine library */
/******************************************************************************************/
/* checktf application                                                                   */
/******************************************************************************************/
int PLIbook_ShowSignals2_checktf()
{
    acc_initialize();
    if (tf_nump() == 0)
        return(0);  /* no arguments is OK, skip remaining checks */
    if (tf_nump() > 1)
        tf_error(""$show_all_signals must have 0 or 1 argument."");
    else if (tf_typep(1) == tf_nullparam)
        return(0);  /* null argument is OK, skip remaining checks */
    else if (acc_fetch_type(acc_handle_tfarg(1)) != accModule)
        tf_error(""$show_all_signals arg must be a module instance."");
    acc_close();
    return(0);
}

/******************************************************************************************/
/* calltf application                                                                     */
/******************************************************************************************/
int PLIbook_ShowSignals2_calltf()
{
    handle module_h, signal_h;
    static int signal_types[6] = {accNet, accReg, accIntegerVar,
                                  accTimeVar, accRealVar, 0 };
","The image displays a page from a book discussing how to use ACC routines in Verilog HDL, accompanied by an example of Verilog code for a $show_all_signals function.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p129.jpg,True,"The image contains a snippet of Verilog code within a block of text. Here's the code extract:

```verilog
always @(a or b) begin
    $assert_always(a^b);
end
```

This Verilog code defines a simple assertion check that triggers on changes to signals `a` or `b`. The `$assert_always` system task checks the condition `a^b` (which is an exclusive OR in this context) whenever either `a` or `b` changes.","
always @(a or b) begin
    $assert_always(a^b);
end
","Caption: ""A textbook image illustrating elements of Verilog simulation, showing a simulation event queue, a snippet of Verilog code using always block for assertions, and a discussion on asserting at the end of a simulation time slot using PLI routines.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p125.jpg,True,"```
module signed_adder_no_carry_in
(input logic signed [3:0] a, b, // signed 4-bit inputs
 output logic signed [3:0] sum, // signed 4-bit output
 output logic co);              // unsigned 1-bit output

 assign {co, sum} = a + b;      // signed 5-bit adder
endmodule
```
The image provides an example of a signed adder implemented in Verilog without gotchas that simulates and synthesizes correctly."," signed_adder_no_carry_in
(input logic signed [3:0] a, b, // signed 4-bit inputs
 output logic signed [3:0] sum, // signed 4-bit output
 output logic co);              // unsigned 1-bit output

 assign {co, sum} = a + b;      // signed 5-bit adder
endmodule
","""Example of a signed adder in Verilog demonstrating signed arithmetic rules.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p101.jpg,True,"The image contains Verilog code within a PSL (Property Specification Language) example. The code is as follows:

```verilog
assert always (req -> next (!req until_ ack));
```","
assert always (req -> next (!req until_ ack));
","Caption: ""A textbook excerpt explaining the use of the temporal logic 'until' operator in PSL (Property Specification Language), alongside Verilog code demonstrating the PSL event bounded window pattern with an 'assert always' statement.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p410.jpg,True,"The image presents a section of a document discussing some theoretical aspects of program analysis, and it includes an example represented in both C programming language and a ""program in SoNaR format."" Below is the code from the example:

C program:
```c
1 void main()
2 {
3     y = x;
4     while (x != NULL) {
5         x = x->next;
6     }
7 }
```

Program in SoNaR format:
```
P(3) = y:= x
P(4) = if (x≠nil) {goto 5} else {goto 7}
P(5) = x:= [x]
P(6) = goto 4
```

This example appears to illustrate a simple list traversal.","d main()
2 {
3     y = x;
4     while (x != NULL) {
5         x = x->next;
6     }
7 }

 y:= x
P(4) = if (x≠nil) {goto 5} else {goto 7}
P(5) = x:= [x]
P(6) = goto 4
","""Comparison of a simple C program code for list traversal with its equivalent representation in the SONAR format.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p184.jpg,True,"The image contains Verilog SystemVerilog Assertion (SVA) code. Here is the code that appears in the image:

```verilog
property ff;
  a |-> ##[1:5] b; // No need for first_match in the consequent here.
endproperty

property ff;
  a |=> first_match (##[1:5] b); // first_match is redundant here
endproperty

abcProp: cover property (@ (posedge clk) a ##[1:4] b ##1 c);

abcProp: cover property (@ (posedge clk) first_match (a ##[1:4]
  ##1 b ##1 c) );
```

The comments and instructions surrounding the code explain various Verilog concepts such as properties, the ""first_match"" operator, and the use of the ""cover"" construct in assertions.","
property ff;
  a |-> ##[1:5] b; // No need for first_match in the consequent here.
endproperty

property ff;
  a |=> first_match (##[1:5] b); // first_match is redundant here
endproperty

abcProp: cover property (@ (posedge clk) a ##[1:4] b ##1 c);

abcProp: cover property (@ (posedge clk) first_match (a ##[1:4]
  ##1 b ##1 c) );
","The image shows a page from a textbook discussing the use of the ""first_match"" operator in Verilog properties to optimize assertion checks and coverage reports.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p541.jpg,True,"The image contains Verilog code. Here it is:

```verilog
interface simple_bus; // Define the interface.
  logic         req, gnt;
  logic[7:0]    addr, data;
  logic[1:0]    mode;
  logic         start, rdy;
endinterface: simple_bus
#
module memMod
  (simple_bus a, // Access the simple_bus interface.
   input logic clk
  );
  logic avail;
  //
  // When memMod is instantiated in module top, a.req is the
  // ""logic req, gnt;"" signal in the sb_intf instance of the
  // 'simple_bus' interface:
  always @(posedge clk)
    a.gnt <= a.req & avail;
  //
endmodule
#
module cpuMod(simple_bus b, input logic clk);
  ...
endmodule
#
module top;
  logic clk = 0;
  simple_bus sb_intf();            // Instantiate the interface.
  //
  memMod mem(sb_intf, clk);        // Connect the interface by position
  cpuMod cpu(.b(sb_intf), .clk(clk)); // or by name.
endmodule
```","
interface simple_bus; // Define the interface.
  logic         req, gnt;
  logic[7:0]    addr, data;
  logic[1:0]    mode;
  logic         start, rdy;
endinterface: simple_bus
#
module memMod
  (simple_bus a, // Access the simple_bus interface.
   input logic clk
  );
  logic avail;
  //
  // When memMod is instantiated in module top, a.req is the
  // ""logic req, gnt;"" signal in the sb_intf instance of the
  // 'simple_bus' interface:
  always @(posedge clk)
    a.gnt <= a.req & avail;
  //
endmodule
#
module cpuMod(simple_bus b, input logic clk);
  ...
endmodule
#
module top;
  logic clk = 0;
  simple_bus sb_intf();            // Instantiate the interface.
  //
  memMod mem(sb_intf, clk);        // Connect the interface by position
  cpuMod cpu(.b(sb_intf), .clk(clk)); // or by name.
endmodule
","""Example of a Verilog interface declaration and instantiation in a Digital VLSI Design context.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p131.jpg,True,"```verilog
i = 16;

while (i--) ... ; // test i, then decrement; loop will
                  // execute 16 times

while (--i) ... ; // decrement i, then test; loop will
                  // execute 15 times
```

The image contains a snippet of Verilog code explaining the difference between pre-decrement (`--i`) and post-decrement (`i--`) within a `while` loop.","
i = 16;

while (i--) ... ; // test i, then decrement; loop will
                  // execute 16 times

while (--i) ... ; // decrement i, then test; loop will
                  // execute 15 times
","""Understanding Pre- and Post-Increment in Verilog Loops to Avoid Gotchas""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p227.jpg,True,"The image contains two snippets of Verilog code. Here they are transcribed:

1.
```verilog
assign #(3, 5) OutWire_001 = newValue;
```

2.
```verilog
bufif1 #(3,5,7) GateInst_001(OutWire_001, InWire_001, Control_001);
```

This code demonstrates the use of Verilog timing controls (delays) in continuous assignments (`assign`) and primitive gate instantiation (`bufif1`).","
assign #(3, 5) OutWire_001 = newValue;


bufif1 #(3,5,7) GateInst_001(OutWire_001, InWire_001, Control_001);
","""Exploring Intrassignnment Delays and Multivalue Wire-Delay Expressions in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p126.jpg,True,"```c
int module_has_ports(vpiHandle module_handle)
{
    vpiHandle port_iterator;
    port_iterator = vpi_iterate(vpiPort, module_handle);
    if (port_iterator == NULL)
        return(0); /* no ports found */
    else
    {
        vpi_free_object(port_iterator); /* free iterator list */
        return(1); /* ports were found */
    }
}
```

This is the code excerpt from the image, which provides an example of how to check if a Verilog module has any ports using the Verilog Procedural Interface (VPI) and how to properly free an iterator object allocated by `vpi_iterate`.","odule_has_ports(vpiHandle module_handle)
{
    vpiHandle port_iterator;
    port_iterator = vpi_iterate(vpiPort, module_handle);
    if (port_iterator == NULL)
        return(0); /* no ports found */
    else
    {
        vpi_free_object(port_iterator); /* free iterator list */
        return(1); /* ports were found */
    }
}
","The image shows a page from ""The Verilog PLI Handbook, Part One"" detailing the usage of iterator objects and memory management in Verilog PLI, including a code example for freeing a VPI iterator object.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p131.jpg,True,"The image contains several snippets of code written in SystemVerilog, which is a hardware description and verification language.

Here are the code snippets from the image:

1. Sequence operator usage:
``` 
r ##n s
```

2. An example of re-writing a sequence using the syntax described:
``` 
as req ##2 ack.
```

3. An example of a top-level sequential property (Example 6.9):
``` 
initial a1: assert property (@(posedge clk) rst ##20 !rst);
```

4. Another example of an assertion (Example 6.10):
``` 
a1: assert property (@(posedge clk) a ##1 b);
```

These code examples are intended to demonstrate certain constructs in SystemVerilog, such as sequence operators and assertions."," s

q ##2 ack.

al a1: assert property (@(posedge clk) rst ##20 !rst);

ssert property (@(posedge clk) a ##1 b);
","""Verilog Sequential Property Syntax and Examples: Discussion on the use of delay within sequences and the definition of top-level sequential properties for simulation and formal verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p37.jpg,True,"```c
void PLIbook_hello_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type       = vpiSysTask;
    tf_data.tfname     = ""$hello"";
    tf_data.calltf     = PLIbook_hello_calltf;
    tf_data.compiletf  = NULL;
    tf_data.sizetf     = NULL;
    vpi_register_systf(&tf_data);
}
```","PLIbook_hello_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type       = vpiSysTask;
    tf_data.tfname     = ""$hello"";
    tf_data.calltf     = PLIbook_hello_calltf;
    tf_data.compiletf  = NULL;
    tf_data.sizetf     = NULL;
    vpi_register_systf(&tf_data);
}
","A section on ""Registering the $hello system task"" in Chapter 1 explaining the process of registering a PLI application using VPI routines in Verilog, including an example of a VPI register function for a PLI application.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p287.jpg,True,"```verilog
module assert_window (clk, reset_n, start_event, test_expr, end_event);
input clk, reset_n, start_event, test_expr, end_event;
parameter severity_level = 0;
parameter msg=""ASSERT WINDOW VIOLATION"";

//synopsys translate_off
`ifdef ASSERT_ON
// local parameters used as defines
parameter WINDOW_START = 1'b0;
parameter WINDOW_CHECK = 1'b1;

reg r_state;
initial r_state=WINDOW_START;
integer error_count;
initial error_count = 0;

always @(posedge clk) begin
  `ifdef ASSERT_GLOBAL_RESET
```","
module assert_window (clk, reset_n, start_event, test_expr, end_event);
input clk, reset_n, start_event, test_expr, end_event;
parameter severity_level = 0;
parameter msg=""ASSERT WINDOW VIOLATION"";

//synopsys translate_off
`ifdef ASSERT_ON
// local parameters used as defines
parameter WINDOW_START = 1'b0;
parameter WINDOW_CHECK = 1'b1;

reg r_state;
initial r_state=WINDOW_START;
integer error_count;
initial error_count = 0;

always @(posedge clk) begin
  `ifdef ASSERT_GLOBAL_RESET
","""Documentation and example code for the assert_window construct in Verilog for assertion-based verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p132.jpg,True,"Here is the C code provided in the image:

```c
int PLIbook_numargs_vpi()
{
    vpiHandle systf_h, arg_itr, arg_h;
    int tfnum = 0;

#ifdef PLIbookDebug
    s_vpi_error_info err; /* structure for error handling */
#endif

    systf_h = vpi_handle(vpiSysTfCall, NULL);
#ifdef PLIbookDebug /* if error, generate verbose debug message */
    if (vpi_chk_error(&err)) {
        vpi_printf(""ERROR: PLIbook_numargs_vpi() could not obtain handle
to systf call\n"");
        vpi_printf(""File %s, Line %d: %s\n"",
            err.file, err.line, err.message);
    }
#else /* if error, generate brief error message */
    if (systf_h == NULL)
        vpi_printf(""ERROR: PLIbook_numargs_vpi() could not obtain handle
to systf call\n"");
```

The code provided is a C function that is meant to be used with the Verilog PLI (Programming Language Interface) to interact with Verilog simulations. This function, `PLIbook_numargs_vpi`, is intended to count and return the number of arguments in a system task or function call in Verilog. The code snippet provided is incomplete, so it would not work if used as is.","LIbook_numargs_vpi()
{
    vpiHandle systf_h, arg_itr, arg_h;
    int tfnum = 0;

#ifdef PLIbookDebug
    s_vpi_error_info err; /* structure for error handling */
#endif

    systf_h = vpi_handle(vpiSysTfCall, NULL);
#ifdef PLIbookDebug /* if error, generate verbose debug message */
    if (vpi_chk_error(&err)) {
        vpi_printf(""ERROR: PLIbook_numargs_vpi() could not obtain handle
to systf call\n"");
        vpi_printf(""File %s, Line %d: %s\n"",
            err.file, err.line, err.message);
    }
#else /* if error, generate brief error message */
    if (systf_h == NULL)
        vpi_printf(""ERROR: PLIbook_numargs_vpi() could not obtain handle
to systf call\n"");
","Caption: ""Example of a C function 'PLIbook_numargs_vpi' to count the number of arguments in a Verilog system task/function using the VPI routines""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p125.jpg,True,"```verilog
a1: assert property (@(posedge clk) s_eventually always !rst);
```","
a1: assert property (@(posedge clk) s_eventually always !rst);
",Discussion on SystemVerilog assertions and temporal property examples.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p379.jpg,True,"The image contains Verilog code. Here is the content transcribed from the image:

```verilog
always @ (posedge sys_clk)
$display($stime,,""clk=%b req=%b gnt=%b"", sys_clk, sys_req, sys_gnt);

always #10 sys_clk = !sys_clk;

initial
begin
    sys_req = 1'b0;
    @(posedge sys_clk) sys_req = 1'b1; //30
    @(posedge sys_clk) sys_req = 1'b0; //50
    @(posedge sys_clk) sys_req = 1'b0; //70
    @(posedge sys_clk) sys_req = 1'b1; //90
    @(posedge sys_clk) sys_req = 1'b0; //110
    @(posedge sys_clk) sys_req = 1'b0; //130
    
    @(posedge sys_clk);
    @(posedge sys_clk); $finish(2);
end

endmodule
```

This code snippet is an example of a simple Verilog test bench. It simulates toggling a system request signal `sys_req` at specified intervals, while displaying the clock `sys_clk`, request `sys_req`, and grant `sys_gnt` signals at the rising edge of the system clock. After a sequence of events, the simulation is terminated with `$finish(2)`.","
always @ (posedge sys_clk)
$display($stime,,""clk=%b req=%b gnt=%b"", sys_clk, sys_req, sys_gnt);

always #10 sys_clk = !sys_clk;

initial
begin
    sys_req = 1'b0;
    @(posedge sys_clk) sys_req = 1'b1; //30
    @(posedge sys_clk) sys_req = 1'b0; //50
    @(posedge sys_clk) sys_req = 1'b0; //70
    @(posedge sys_clk) sys_req = 1'b1; //90
    @(posedge sys_clk) sys_req = 1'b0; //110
    @(posedge sys_clk) sys_req = 1'b0; //130
    
    @(posedge sys_clk);
    @(posedge sys_clk); $finish(2);
end

endmodule
",Verilog simulation code snippet and output log illustrating SystemVerilog assertions and related lab questions.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p351.jpg,True,"The image contains Verilog code examples that illustrate the use of ""let"" in immediate and concurrent assertions. Here are the code snippets from the image:

First snippet:

```verilog
module abc;
  logic req, gnt;
  let reqack = !req && gnt;
  sequence reqGnt;
    reqack;
  endsequence
endmodule
```

After expanding the 'let' instance:

```verilog
module abc;
  logic req, gnt;
  sequence reqGnt;
    !req && gnt;
  endsequence
endmodule
```

Here's another example:

```verilog
module abc;
  logic clk, r1, r2, req, gnt;
  let xxory (x, y) = x ^ y; //bit wise xor
  let rorq = req || gnt;
  ....
```

The code snippets demonstrate how to declare local parameters within sequences using the ""let"" construct in Verilog.","
module abc;
  logic req, gnt;
  let reqack = !req && gnt;
  sequence reqGnt;
    reqack;
  endsequence
endmodule


module abc;
  logic req, gnt;
  sequence reqGnt;
    !req && gnt;
  endsequence
endmodule


module abc;
  logic clk, r1, r2, req, gnt;
  let xxory (x, y) = x ^ y; //bit wise xor
  let rorq = req || gnt;
  ....
","Caption: ""Exploration of the 'let' construct in Verilog for immediate and concurrent assertions with code examples.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p101.jpg,True,"```verilog
initial begin
    typedef struct {int a;
                    byte b;
                    shortint c;
                    int d;} my_struct_s;
    my_struct_s st = '{32'haaaaa_aaaa,
                      8'hbb,
                      16'hcccc,
                      32'hdddd_dddd};

    byte b[];
  
    // Convert from struct to byte array
    b = { >> {st}};  // {aa aa aa aa bb cc cc dd dd dd dd}

    // Convert from byte array to a struct
    b = '{8'h11, 8'h22, 8'h33, 8'h44, 8'h55, 8'h66, 8'h77,
         8'h88, 8'h99, 8'haa, 8'hbb};
    st = { >> {b}};  // st = 11223344, 55, 6677, 8899aabb
end
```

```verilog
enum {RED, BLUE, GREEN} color;
```","
initial begin
    typedef struct {int a;
                    byte b;
                    shortint c;
                    int d;} my_struct_s;
    my_struct_s st = '{32'haaaaa_aaaa,
                      8'hbb,
                      16'hcccc,
                      32'hdddd_dddd};

    byte b[];
  
    // Convert from struct to byte array
    b = { >> {st}};  // {aa aa aa aa bb cc cc dd dd dd dd}

    // Convert from byte array to a struct
    b = '{8'h11, 8'h22, 8'h33, 8'h44, 8'h55, 8'h66, 8'h77,
         8'h88, 8'h99, 8'haa, 8'hbb};
    st = { >> {b}};  // st = 11223344, 55, 6677, 8899aabb
end


enum {RED, BLUE, GREEN} color;
","""Example of Verilog code demonstrating streaming operators to convert between structured types and byte arrays.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p437.jpg,True,"Here is the Verilog code from the image:

```verilog
sequence PCI_Special_Cycle;
  $fell (frame_) && (cbe == 'b0001);
endsequence

sequence parity_error_check;
  perr[*1:$] ##0 ($rose (irdy && trdy));
endsequence

property
  PCI_Special_Cycle |-> parity_error_check;
endproperty
```

This code defines two sequences and a property in the context of a PCI protocol assertion example according to the text in the image.","
sequence PCI_Special_Cycle;
  $fell (frame_) && (cbe == 'b0001);
endsequence

sequence parity_error_check;
  perr[*1:$] ##0 ($rose (irdy && trdy));
endsequence

property
  PCI_Special_Cycle |-> parity_error_check;
endproperty
","Caption: Example of Verilog assertions for PCI protocol checking, illustrating the use of sequences and properties to validate special cycle behavior and parity error checking.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p93.jpg,True,"The image contains examples of Property Specification Language (PSL) assertions. The code provided in the image is as follows:

Example 3-10 PSL next operator:
```verilog
assert always (req -> next ack) @(posedge clk);
```

Example 3-11 PSL multiple next:
```verilog
assert always (req -> next (next (next ack))) @(posedge clk);
```

Figure 3-2:
```verilog
assert always (req -> next[3] ack) @(posedge clk);
```

These examples are used to demonstrate how to specify assertions in Verilog using PSL.","
assert always (req -> next ack) @(posedge clk);


assert always (req -> next (next (next ack))) @(posedge clk);


assert always (req -> next[3] ack) @(posedge clk);
","Caption: ""Understanding RTL cycle related assertions in Verilog with PSL next operator examples""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p119.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
initial a1: assert property (@(posedge clk) s_eventually !rst);
```

This code represents an initial block in Verilog that asserts a property using SystemVerilog Assertions (SVA). The property in question checks that at some point after a rising edge of the clock (`posedge clk`), the `rst` signal will be deasserted (`!rst`).","
initial a1: assert property (@(posedge clk) s_eventually !rst);
","Verilog code example and discussion on the `s_eventually` property, emphasizing its significance as a liveness assertion in formal verification.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p115.jpg,True,"The image contains two snippets of Verilog code. Here they are:

Snippet 1 (Sample 3.6 Simple task without begin...end):
```verilog
task multiple_lines();
  $display(""First line"");
  $display(""Second line"");
endtask : multiple_lines
```

Snippet 2 (Sample 3.7 Verilog-1995 routine arguments):
```verilog
task mytask1;
  output [31:0] x;
  reg    [31:0] x;
  input        y;
...
endtask
```","
task multiple_lines();
  $display(""First line"");
  $display(""Second line"");
endtask : multiple_lines


task mytask1;
  output [31:0] x;
  reg    [31:0] x;
  input        y;
...
endtask
","""Explanation of SystemVerilog improvements to task and function routines, illustrating the removal of 'begin...end' and showcasing C-style routine arguments.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p423.jpg,True,"The image contains Verilog code within a document. Here is the text of the code snippet with the ""overlap"" operator:

```verilog
sequence sr1;
  req ##2 gnt;
endsequence

property pr1;
  @(posedge clk) cstart |-> sr1;
endproperty

property pr1_for_cover;
  @(posedge clk) cstart ##0 sr1;
endproperty
```

The text also contains a Q&A section discussing the outcomes of test scenarios related to the ""overlap"" operator, but the discussions are not in code form.","
sequence sr1;
  req ##2 gnt;
endsequence

property pr1;
  @(posedge clk) cstart |-> sr1;
endproperty

property pr1_for_cover;
  @(posedge clk) cstart ##0 sr1;
endproperty
","""Example of Verilog code using overlap and nonoverlap operators with explanations and test results.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p236.jpg,True,"The image contains two code segments in Verilog with certain properties defined.

Here is the first code segment:

```verilog
property p_xfer64;
@(posedge clk) ((size == 1) && ((dq[1:0] == 0 &&(`s_write ||`s_burst_write))) |->
##2 (`$fell(dqm[2] && dqm[3]) && addr == $past(addr, 2) && (`s_write ||`s_burst_write))
##1 $rose(dqm[3] && dqm[2]));
endproperty

a_xfer64: assert property(p_xfer64);
c_xfer64: cover property(p_xfer64);
```

Here is the second code segment:

```verilog
property p_wr_rd_burstterminate;
@(posedge clk) (s_burstterminate) |->
$past((`s_burst_write || `s_write || `s_read || `s_burst_read), 1);
endproperty
```

These properties are likely used to describe certain conditions or behaviors expected in a digital system, specifically related to data transfer and read/write operations with some kind of memory, possibly SDRAM as hinted by the context given below the second segment.","
property p_xfer64;
@(posedge clk) ((size == 1) && ((dq[1:0] == 0 &&(`s_write ||`s_burst_write))) |->
##2 (`$fell(dqm[2] && dqm[3]) && addr == $past(addr, 2) && (`s_write ||`s_burst_write))
##1 $rose(dqm[3] && dqm[2]));
endproperty

a_xfer64: assert property(p_xfer64);
c_xfer64: cover property(p_xfer64);


property p_wr_rd_burstterminate;
@(posedge clk) (s_burstterminate) |->
$past((`s_burst_write || `s_write || `s_read || `s_burst_read), 1);
endproperty
","""Verilog Formal Verification Properties and Waveform Illustrating a 64-bit Data Transfer Operation""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p683.jpg,True,"The image contains a partial listing of a C source file named `veriuser.c` that is related to VeriBest PLI applications in Verilog simulators. Here is the code excerpt from the image:

```c
#include ""veriuser.h""
#include ""acc_user.h""

...

int sde_debug_check(int data, int reason);
int sde_debug_call(int data, int reason);
int sde_debug_misc(int data, int reason);
int WavesReadNextVector(int data, int reason);
int WavesOpenVectorFile(int data, int reason);

/* prototypes for the PLI application routines */
extern int PLIbook_ShowVal_checktf(), PLIbook_ShowVal_calltf();
extern int PLIbook_pow_sizetf(), PLIbook_pow_checktf(),
           PLIbook_pow_calltf(), PLIbook_pow_miscft();

...

s_tfcell veriusertfs[] = {
    ...

    /* $sde_debug is used for state diagram debugging */
    {usertask, 0, sde_debug_check,0,sde_debug_call,sde_debug_misc,
    ""$sde_debug"", 0},

    /* $Waves is for the vector file support in Waves Stimulus editor */
    {usertask, 0, WavesOpenVectorFile , WavesOpenVectorFile ,
    WavesReadNextVector , 0, ""$WavesOpenVectorFile"", 0 },
    {usertask, 0, WavesReadNextVector , WavesReadNextVector ,
    WavesReadNextVector, 0, ""$WavesReadNextVector"", 0 },
    ...
};
```

This is a partial listing, so some parts of the code are represented with ellipses (`...`), indicating that content is omitted. The code shows the declaration of some functions and an array of `s_tfcell` struct instances, which define user-defined system tasks and functions for simulation in Verilog using the Programming Language Interface (PLI).","ude ""veriuser.h""
#include ""acc_user.h""

...

int sde_debug_check(int data, int reason);
int sde_debug_call(int data, int reason);
int sde_debug_misc(int data, int reason);
int WavesReadNextVector(int data, int reason);
int WavesOpenVectorFile(int data, int reason);

/* prototypes for the PLI application routines */
extern int PLIbook_ShowVal_checktf(), PLIbook_ShowVal_calltf();
extern int PLIbook_pow_sizetf(), PLIbook_pow_checktf(),
           PLIbook_pow_calltf(), PLIbook_pow_miscft();

...

s_tfcell veriusertfs[] = {
    ...

    /* $sde_debug is used for state diagram debugging */
    {usertask, 0, sde_debug_check,0,sde_debug_call,sde_debug_misc,
    ""$sde_debug"", 0},

    /* $Waves is for the vector file support in Waves Stimulus editor */
    {usertask, 0, WavesOpenVectorFile , WavesOpenVectorFile ,
    WavesReadNextVector , 0, ""$WavesOpenVectorFile"", 0 },
    {usertask, 0, WavesReadNextVector , WavesReadNextVector ,
    WavesReadNextVector, 0, ""$WavesReadNextVector"", 0 },
    ...
};
","""Instructions for linking PLI applications to Verilog simulators, with a sample VeriBest veriuser.c file configuration.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p250.jpg,True,"The image contains Verilog code. Here is the code written down for you:

```verilog
module stimulus(ck,c_stimulus,c_reset);
    input ck;
    output [4:0] c_stimulus;
    output c_reset;
    reg reset;
    reg [4:0] c_stimulus;
    reg [5:0] c_counter;
    reg c_reset;
    wire [5:0] r_counter;

    always @(r_counter) begin
        c_counter = r_counter + 6'd1;
        if (c_counter == 6'h20)
            $finish;
        c_stimulus = c_counter[4:0];
    end

    dff #(6) reg_counter (r_counter,ck,c_reset,c_counter);

    initial begin
        c_counter = 6'd0;
        c_reset = 1'b1;
        `TIME_RESET;
        c_reset = 1'b0;
    end
endmodule // stimulus
```

Please note that the code seems to be part of a chapter dealing with testbenches in Verilog, as indicated by the heading ""CHAPTER 9"" and subsequent text explaining the purpose of the provided example, such as ""Example 9-23"", ""Device under test"", ""Reference model"", and ""Diagnostic logging.""","
module stimulus(ck,c_stimulus,c_reset);
    input ck;
    output [4:0] c_stimulus;
    output c_reset;
    reg reset;
    reg [4:0] c_stimulus;
    reg [5:0] c_counter;
    reg c_reset;
    wire [5:0] r_counter;

    always @(r_counter) begin
        c_counter = r_counter + 6'd1;
        if (c_counter == 6'h20)
            $finish;
        c_stimulus = c_counter[4:0];
    end

    dff #(6) reg_counter (r_counter,ck,c_reset,c_counter);

    initial begin
        c_counter = 6'd0;
        c_reset = 1'b1;
        `TIME_RESET;
        c_reset = 1'b0;
    end
endmodule // stimulus
",Verilog stimulus module for testbench with a counter and conditional finish.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p244.jpg,True,"```verilog
module b_mux (p, s, w, x, y, z);
input [1:0] s;
input [7:0] w, x, y, z;
output [7:0] p;
wire [1:0] s;
wire [7:0] w, x, y, z;
reg [7:0] p;
always @ (s or w or x or y or z)
  case (s)
    2'b00 : p = w;
    2'b01 : p = x;
    2'b10 : p = y;
    2'b11 : p = z;
  endcase
endmodule // b_mux
```","
module b_mux (p, s, w, x, y, z);
input [1:0] s;
input [7:0] w, x, y, z;
output [7:0] p;
wire [1:0] s;
wire [7:0] w, x, y, z;
reg [7:0] p;
always @ (s or w or x or y or z)
  case (s)
    2'b00 : p = w;
    2'b01 : p = x;
    2'b10 : p = y;
    2'b11 : p = z;
  endcase
endmodule // b_mux
",Caption: Verilog code example of a 4-way multiplexer using a casex statement.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p392.jpg,True,"The image contains Verilog code which pertains to properties and assertions for what appears to be a FIFO (First In First Out) buffer. Here is the code:

```verilog
fifo_full_write_stable_wrptrP: assert property (fifo_full_write_stable_wrptr)
else $display($stime,""\t\tFAIL::fifo_full_write_stable_wrptr condition\n"");

`endif

`ifdef check5

// ---------------------------------------------------
// 5. Check that if fifo is empty and you attempt to read
// (but not write)
// that the rd_ptr does not change.
// ---------------------------------------------------

property fifo_empty_read_stable_rdptr;
@(posedge clk) !rst |-> `rd_ptr==0; // DUMMY... remove this line and

                                    //replace it with correct check

endproperty

fifo_empty_read_stable_rdptrP: assert property (fifo_empty_read_stable_rdptr)
else $display($stime,""\t\tFAIL::fifo_empty_read_stable_rdptr condition\n"");

`endif

`ifdef check6

// ---------------------------------------------------
// 6. Write a property to Warn on write to a full fifo
// This property will give Warning with all simulations
// ---------------------------------------------------

property write_on_full_fifo;
@(posedge clk) !rst |-> `rd_ptr==0; // DUMMY... remove this line and

                                    //replace it with correct check

endproperty

write_on_full_fifoP: assert property (write_on_full_fifo)
else $display($stime,""\t\tWARNING::write_on_full_fifo\n"");

`endif
```

This code is used for creating assertions that check various conditions of the FIFO. Assertions in Verilog are used to verify that certain conditions hold during simulation. The comments within the code suggest that in certain places, dummy checks (`rd_ptr==0`) should be replaced with correct checks to correspond to the intended functionality.","
fifo_full_write_stable_wrptrP: assert property (fifo_full_write_stable_wrptr)
else $display($stime,""\t\tFAIL::fifo_full_write_stable_wrptr condition\n"");

`endif

`ifdef check5

// ---------------------------------------------------
// 5. Check that if fifo is empty and you attempt to read
// (but not write)
// that the rd_ptr does not change.
// ---------------------------------------------------

property fifo_empty_read_stable_rdptr;
@(posedge clk) !rst |-> `rd_ptr==0; // DUMMY... remove this line and

                                    //replace it with correct check

endproperty

fifo_empty_read_stable_rdptrP: assert property (fifo_empty_read_stable_rdptr)
else $display($stime,""\t\tFAIL::fifo_empty_read_stable_rdptr condition\n"");

`endif

`ifdef check6

// ---------------------------------------------------
// 6. Write a property to Warn on write to a full fifo
// This property will give Warning with all simulations
// ---------------------------------------------------

property write_on_full_fifo;
@(posedge clk) !rst |-> `rd_ptr==0; // DUMMY... remove this line and

                                    //replace it with correct check

endproperty

write_on_full_fifoP: assert property (write_on_full_fifo)
else $display($stime,""\t\tWARNING::write_on_full_fifo\n"");

`endif
","""Verilog code snippet demonstrating the use of assertion properties to check FIFO stability and warn on invalid operations.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p278.jpg,True,"The image contains Verilog code examples within an educational context. Here's the code written out:

For tristate port driving statements:
```verilog
c_bdp = (~csa_ & ~wa) ? l_a_reg : 18'bz;

tri [0:17] bdp = c_bdp; // preceding flip-flop macro calls
```

Storage element module instances:
```verilog
DFFT_X#(44) reg_addr_a (r_addr[43:0], clk, c_addr[43:0]);
```

For procedural statements, there's control and assignments:
Control (if-else and case statements):
```verilog
// if-else construct
if (expression)
    statement or procedural block
else // Optional else followed by:
    statement or procedural block

// case statement
case (scan_ctl)
    2'd0 : statement or procedural block
    2'd1 : statement or procedural block
    default : statement or procedural block
endcase

// casex statement
casex (c_q0_ctl)
    4'b1_???:c_q0 = r_q1;
    4'b0_0_?? :c_q0 = {c_qctl, c_par_data};
    4'b0_0_1? :c_q0 = r_q0;
    4'b0_1_00 :c_q0 = {2'b0, c_qctl[8:2], c_par_data};
    4'b0_1_01 :c_q0 = {c_qctl, c_par_data};
    4'b0_1_1? :c_q0 = r_q1;
endcase
```

Assignments (non-blocking and blocking):
```verilog
// Non-blocking assignment
icq_0 <= icq_0;

// Blocking assignment
c_io_btab_active = c_io_btab_out[24];
```

This code is intended to illustrate Verilog syntax and usage in different contexts within digital design, such as tristate driving, module instantiation, procedural blocks, and assignments.","
c_bdp = (~csa_ & ~wa) ? l_a_reg : 18'bz;

tri [0:17] bdp = c_bdp; // preceding flip-flop macro calls


DFFT_X#(44) reg_addr_a (r_addr[43:0], clk, c_addr[43:0]);


// if-else construct
if (expression)
    statement or procedural block
else // Optional else followed by:
    statement or procedural block

// case statement
case (scan_ctl)
    2'd0 : statement or procedural block
    2'd1 : statement or procedural block
    default : statement or procedural block
endcase

// casex statement
casex (c_q0_ctl)
    4'b1_???:c_q0 = r_q1;
    4'b0_0_?? :c_q0 = {c_qctl, c_par_data};
    4'b0_0_1? :c_q0 = r_q0;
    4'b0_1_00 :c_q0 = {2'b0, c_qctl[8:2], c_par_data};
    4'b0_1_01 :c_q0 = {c_qctl, c_par_data};
    4'b0_1_1? :c_q0 = r_q1;
endcase


// Non-blocking assignment
icq_0 <= icq_0;

// Blocking assignment
c_io_btab_active = c_io_btab_out[24];
","""Excerpt from a textbook detailing Verilog procedural statements, assignments, and storage element module instances.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p317.jpg,True,"```verilog
assert_always [##(severity_level, options, msg)]
              inst_name (clk, reset_n, test_expr);
```","
assert_always [##(severity_level, options, msg)]
              inst_name (clk, reset_n, test_expr);
","The image shows documentation for the SystemVerilog assertion `assert_always`, detailing its syntax and the purpose of each parameter.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p219.jpg,True,"The image contains quite a bit of Verilog code. Here it is transcribed for you:

```verilog
property illegal_legal_declarations;
    data; //ILLEGAL. `data` needs an explicit data type.
    logic data = 1'b0; //LEGAL. Note that unlike SystemVerilog
                       //variables, local variables have no
                       //default initial value. Also, the assignment
                       //can be any expression and
                       // need not be a constant value

    byte data [ ]; //ILLEGAL - dynamic array type not
                   //allowed.
endproperty

property legal_data_dependency;
    logic data = data_in, data_add = data + 16'h FF; //LEGAL
endproperty

property illegal_data_dependency;
    logic data, data_add = data + 16'FF; //ILLEGAL. `data` used in expression assignment of `data_add`
                                          //is not initialized.
endproperty

sequence illegal_declarations (
    output logic a, // ILLEGAL: `local` keyword is not specified
                    // with direction.

    local inout logic b, c = 1'b0, // ILLEGAL: default actual
                                   // argument illegal for inout

    local d = expr, // ILLEGAL: type must be specified explicitly

    local event e, // ILLEGAL: `event` type is not allowed

    local logic f = g // ILLEGAL: `g` cannot refer to the local
                      // variable declared below. It must be resolved upward from this
                      // declaration

);
```

This code example is from a textbook or some teaching material explaining the legal and illegal declarations of local variables in SystemVerilog properties and sequences.","
property illegal_legal_declarations;
    data; //ILLEGAL. `data` needs an explicit data type.
    logic data = 1'b0; //LEGAL. Note that unlike SystemVerilog
                       //variables, local variables have no
                       //default initial value. Also, the assignment
                       //can be any expression and
                       // need not be a constant value

    byte data [ ]; //ILLEGAL - dynamic array type not
                   //allowed.
endproperty

property legal_data_dependency;
    logic data = data_in, data_add = data + 16'h FF; //LEGAL
endproperty

property illegal_data_dependency;
    logic data, data_add = data + 16'FF; //ILLEGAL. `data` used in expression assignment of `data_add`
                                          //is not initialized.
endproperty

sequence illegal_declarations (
    output logic a, // ILLEGAL: `local` keyword is not specified
                    // with direction.

    local inout logic b, c = 1'b0, // ILLEGAL: default actual
                                   // argument illegal for inout

    local d = expr, // ILLEGAL: type must be specified explicitly

    local event e, // ILLEGAL: `event` type is not allowed

    local logic f = g // ILLEGAL: `g` cannot refer to the local
                      // variable declared below. It must be resolved upward from this
                      // declaration

);
","Caption: ""Examples of legal and illegal declarations of local variables in Verilog code, highlighting syntax rules and initialization requirements.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p288.jpg,True,"The image contains Verilog code written in Property Specification Language (PSL) and SystemVerilog, associated with specifying certain properties of a data packet's behavior. Here are the code snippets from the image:

PSL code (Example 8-5):
```verilog
default clock = (posedge clk);

property PacketLastFirst =
    always {rose(packet);!lastbit [*1]} |=> {rose(packet) [->1] : first};
    
assert PacketLastFirst;
```

SystemVerilog code (Example 8-6):
```verilog
property PacketLastFirst;
    @(posedge clk) $rose(packet);lastbit [->1] |=> $rose (packet) [->1] ##0 first;
endproperty

assert property (PacketLastFirst);
```

These examples demonstrate how to express that if a data packet starts and eventually has a ""lastbit,"" then the next data packet must have the ""first"" bit asserted. The PSL example uses the `always` operator and `|=>` (suffix implication operator), while the SystemVerilog example uses the `property` and `endproperty` keywords along with `assert property` to create assertions based on the desired properties.","
default clock = (posedge clk);

property PacketLastFirst =
    always {rose(packet);!lastbit [*1]} |=> {rose(packet) [->1] : first};
    
assert PacketLastFirst;


property PacketLastFirst;
    @(posedge clk) $rose(packet);lastbit [->1] |=> $rose (packet) [->1] ##0 first;
endproperty

assert property (PacketLastFirst);
","Caption: ""Verilog examples demonstrating the use of PSL and SystemVerilog for specifying an 'eventual next' event in a data packet sequence.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p734.jpg,True,"The image contains Verilog code which defines several structures using `typedef`. Here is the code from the image:

```verilog
typedef struct t_tfnodeinfo {
    short node_type; /* tf_null_node, tf_reg_node, tf_integer_node,
                        tf_real_node, tf_time_node, tf_netvector_node,
                        tf_netscalar_node, tf_memory_node */
    short padding;
    union {
        struct t_vecval *vecval_p;
        struct t_strengthval *strengthval_p;
        char *memoryval_p;
        double *real_val_p;
    } node_value;
    char *node_symbol;
    int node_ngroups;
    int node_vec_size;
    int node_sign;
    int node_ms_index;
    int node_ls_index;
    int node_mem_size;
    int node_lhs_element;
    int node_rhs_element;
    int *node_handle;
} s_tfnodeinfo, *p_tfnodeinfo;

typedef struct t_vecval {
    int avalbits; /* aval/bval encoding: 0/0 == 0, */
    int bvalbits; /* 1/0 == 1, 0/1 == Z, 1/1 == X */
} s_vecval, *p_vecval;

typedef struct t_strengthval {
    int strength0;
    int strength1;
} s_strengthval, *p_strengthval;
```

Below the structs, there are two function prototypes that are part of the Verilog Programming Language Interface (PLI):

```verilog
int tf_nump()
int tf_inump(tfintst)
char *tfintst /* pointer to an instance of a system task/function. */
/* Returns the number of arguments to the calling or a specific system task/function. */
```

Please note that the code refers to the Verilog PLI, which is used for interacting between Verilog HDL simulations and external C functions.","
typedef struct t_tfnodeinfo {
    short node_type; /* tf_null_node, tf_reg_node, tf_integer_node,
                        tf_real_node, tf_time_node, tf_netvector_node,
                        tf_netscalar_node, tf_memory_node */
    short padding;
    union {
        struct t_vecval *vecval_p;
        struct t_strengthval *strengthval_p;
        char *memoryval_p;
        double *real_val_p;
    } node_value;
    char *node_symbol;
    int node_ngroups;
    int node_vec_size;
    int node_sign;
    int node_ms_index;
    int node_ls_index;
    int node_mem_size;
    int node_lhs_element;
    int node_rhs_element;
    int *node_handle;
} s_tfnodeinfo, *p_tfnodeinfo;

typedef struct t_vecval {
    int avalbits; /* aval/bval encoding: 0/0 == 0, */
    int bvalbits; /* 1/0 == 1, 0/1 == Z, 1/1 == X */
} s_vecval, *p_vecval;

typedef struct t_strengthval {
    int strength0;
    int strength1;
} s_strengthval, *p_strengthval;


int tf_nump()
int tf_inump(tfintst)
char *tfintst /* pointer to an instance of a system task/function. */
/* Returns the number of arguments to the calling or a specific system task/function. */
","""Verilog Procedural Interface (PLI) data structures and system task function types from the Verilog PLI Handbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p720.jpg,True,"The image contains functions related to the Verilog Procedural Interface (VPI), which is a standard interface used to write C/C++ programs to interact with Verilog simulators. Here are the functions present in the image:

```c
vpiHandle vpi_iterate(type, reference)
int type                  // constant representing an object type.
vpiHandle reference       // handle for an object.

Returns a handle for a vpiIterator for objects with a one-to-many relationship to a reference object (double arrows in the VPI relationship diagrams). The vpiIterator handle can be passed to vpi_scan() to traverse all objects found.

unsigned int vpi_mcd_close(mcd)
unsigned int mcd         // multi-channel descriptor representing open files

Closes one or more files that were opened with vpi_mcd_open(). Returns 0 if successful, and the mcd of files not closed if an error occurs.

char *vpi_mcd_name(mcd)
unsigned int mcd         // multi-channel descriptor representing an open file

Returns a pointer to a string containing the name of an open file. The mcd must point to a single open file.

unsigned int vpi_mcd_open(file_name)
char *file_name          // name of a file to be opened.

Opens a file for writing and returns a multi-channel descriptor number (mcd). Returns 0 if an error occurred.

int vpi_mcd_printf(mcd, format, arg1,...argn)
int mcd                  // multi-channel descriptor of open files
char *format             // quoted character string of formatted message.
arg1...argn              // arguments to formatted message string.

Prints a formatted message to one or more open files. Uses a format string with formatting controls similar to C printf. The mcd is generated by vpi_mcd_open(). The following mcd values are pre-defined: 1 is stdout, 2 is stderr, 3 is simulator’s current output log file. Returns the number of characters written, or EOF if an error occurred.

int vpi_printf(format, arg1,...argn)
char *format             // quoted character string of formatted message.
arg1...argn              // arguments to formatted message string.

Prints a formatted message to the simulation output channel and the current simulation output log file. Uses one or more format strings with formatting controls similar to C printf. Returns the number of characters written, or EOF if an error occurred.
```

These functions are part of the Verilog Programming Language Interface (PLI) library, which is used to create custom functions and tasks in the context of Verilog simulation.","ndle vpi_iterate(type, reference)
int type                  // constant representing an object type.
vpiHandle reference       // handle for an object.

Returns a handle for a vpiIterator for objects with a one-to-many relationship to a reference object (double arrows in the VPI relationship diagrams). The vpiIterator handle can be passed to vpi_scan() to traverse all objects found.

unsigned int vpi_mcd_close(mcd)
unsigned int mcd         // multi-channel descriptor representing open files

Closes one or more files that were opened with vpi_mcd_open(). Returns 0 if successful, and the mcd of files not closed if an error occurs.

char *vpi_mcd_name(mcd)
unsigned int mcd         // multi-channel descriptor representing an open file

Returns a pointer to a string containing the name of an open file. The mcd must point to a single open file.

unsigned int vpi_mcd_open(file_name)
char *file_name          // name of a file to be opened.

Opens a file for writing and returns a multi-channel descriptor number (mcd). Returns 0 if an error occurred.

int vpi_mcd_printf(mcd, format, arg1,...argn)
int mcd                  // multi-channel descriptor of open files
char *format             // quoted character string of formatted message.
arg1...argn              // arguments to formatted message string.

Prints a formatted message to one or more open files. Uses a format string with formatting controls similar to C printf. The mcd is generated by vpi_mcd_open(). The following mcd values are pre-defined: 1 is stdout, 2 is stderr, 3 is simulator’s current output log file. Returns the number of characters written, or EOF if an error occurred.

int vpi_printf(format, arg1,...argn)
char *format             // quoted character string of formatted message.
arg1...argn              // arguments to formatted message string.

Prints a formatted message to the simulation output channel and the current simulation output log file. Uses one or more format strings with formatting controls similar to C printf. Returns the number of characters written, or EOF if an error occurred.
",Verilog Programming Language Interface (PLI) Functions Documentation.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p53.jpg,True,"There is a line of code present in the image under ""Example 3-5."" It reads:

```verilog
assert_eventually err_num (ck, reset_n, ev1_expr, p_expr, ev2_expr, `ASSERT_ERR_NUM);
```

This code snippet represents an assertion in Verilog which is a hardware description language. The assertion is checking that an error number (designated by `err_num`) eventually occurs given certain conditions on clock (`ck`), reset signal (`reset_n`), event expressions (`ev1_expr` and `ev2_expr`), and some property expression (`p_expr`). The ``ASSERT_ERR_NUM`` appears to be a macro or constant value used within the context of the assertion.","
assert_eventually err_num (ck, reset_n, ev1_expr, p_expr, ev2_expr, `ASSERT_ERR_NUM);
","""Verilog Assertions and Event Monitoring Techniques with an Example Assertion""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p225.jpg,True,"The image contains Verilog code that demonstrates the concept of recursive properties. Here are the snippets of code from the image:

**For non-overlapping implication operator:**
```verilog
property rc1(ra);
    ra and (1'b1 |-> rc1(ra));
endproperty

basep: assert property (@(posedge clk) $fell(rst_) |-> rc1(bStrap)) else gotoFail;
```

**For overlapping implication operator:**
```verilog
property rc1(ra);
    ra and (1'b1 |=> rc1(ra));
endproperty

basep: assert property (@(posedge clk) $fell(rst_) |-> rc1(bStrap)) else gotoFail;
```

These snippets are part of a discussion about recursive properties using non-overlapping (`|->`) and overlapping (`|=>`) implication operators in the context of SystemVerilog assertions.","
property rc1(ra);
    ra and (1'b1 |-> rc1(ra));
endproperty

basep: assert property (@(posedge clk) $fell(rst_) |-> rc1(bStrap)) else gotoFail;


property rc1(ra);
    ra and (1'b1 |=> rc1(ra));
endproperty

basep: assert property (@(posedge clk) $fell(rst_) |-> rc1(bStrap)) else gotoFail;
",Understanding Recursive Properties in Verilog Assertions: The Basics.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p192.jpg,True,"The image does include Verilog code. Here is the code that is visible in the image:

```verilog
always@(posedge StartSearch) // Clocked, maybe sequential logic?
  begin : AlwaysSearch
    for (j=0; j<=3; j=j ) // No increment. '<=' is relational operator!
      begin : While_i
        while(1)
          if ( in pad 0's; same as above )
            begin
              // Nkeeper[2*k+1] = ServVect[i-3]; // MSB of pad count.
              // Nkeeper[2*k]   = ServVect[i-4]; // LSB of pad count.
              if (j==3) // whether done:
                begin
                // Check whether we have 4 apparent nn values; do they count down?
                  begin
                    if1 CountOK = 2'b00;
                    for (k=1; k<=3; k=k+1)
                      begin
                      // Use concatenation to get 2-bit nn values:
                      if1 nPrev = { Nkeeper[2*k-1], Nkeeper[2*k-2] };
                      if1 nNow  = { Nkeeper[2*k+1], Nkeeper[2*k] };
                      if ((nNow==nPrev) if1 CountOK = CountOK + 1;
                      end // for k_
                    if (CountOK==3) // Total of 4 were OK; so,
                      begin // issue a pulse and stop everything:
                      if1 FoundPad = 1'b1;
                      disable AlwaysSearch;
                      end
                    end
                  else begin // If not a down-count, start all over:
                    if1 i = i + 16*j - i; // See * below:
                    if1 j = 0;
                    // Nkeeper = 'b0;
                    // end if // if CountOK.
                    end // if j==3
                  end // end not
                begin // if j==3:
                  if1 j = j + 1;
                  if1 i = i - 16; // Jump ahead, for another padded nn.
                  disable While_i;
                  // end // else not j==3.
                  end // if zero matches.
                else if (j==0) // First nn not found yet:
                  if1 i = i + 1;
                else begin // This was not first apparent nn found.
                  if1 i = i + 16*j - 1; // Drop back after jump by mistake.
                  if1 j = 0; // Reset nn counter.
                  // Nkeeper = 'b0; // Reinit count keeper.
                  end
              end // while(1) block.
            end // While_i labelled block.
    end // always AlwaysSearch.
```

Please note that the code contains incomplete or commented-out lines (e.g., lines starting with `//`) which might not form a functional block of Verilog code as-is. Additionally, there are placeholders like `if ( in pad 0's; same as above )` which indicate that some condition should be placed there. Moreover, snippets like `if1` are not standard Verilog syntax, suggesting that this might be pseudocode or a mix of pseudo and actual Verilog code, probably for illustrative or educational purposes.","
always@(posedge StartSearch) // Clocked, maybe sequential logic?
  begin : AlwaysSearch
    for (j=0; j<=3; j=j ) // No increment. '<=' is relational operator!
      begin : While_i
        while(1)
          if ( in pad 0's; same as above )
            begin
              // Nkeeper[2*k+1] = ServVect[i-3]; // MSB of pad count.
              // Nkeeper[2*k]   = ServVect[i-4]; // LSB of pad count.
              if (j==3) // whether done:
                begin
                // Check whether we have 4 apparent nn values; do they count down?
                  begin
                    if1 CountOK = 2'b00;
                    for (k=1; k<=3; k=k+1)
                      begin
                      // Use concatenation to get 2-bit nn values:
                      if1 nPrev = { Nkeeper[2*k-1], Nkeeper[2*k-2] };
                      if1 nNow  = { Nkeeper[2*k+1], Nkeeper[2*k] };
                      if ((nNow==nPrev) if1 CountOK = CountOK + 1;
                      end // for k_
                    if (CountOK==3) // Total of 4 were OK; so,
                      begin // issue a pulse and stop everything:
                      if1 FoundPad = 1'b1;
                      disable AlwaysSearch;
                      end
                    end
                  else begin // If not a down-count, start all over:
                    if1 i = i + 16*j - i; // See * below:
                    if1 j = 0;
                    // Nkeeper = 'b0;
                    // end if // if CountOK.
                    end // if j==3
                  end // end not
                begin // if j==3:
                  if1 j = j + 1;
                  if1 i = i - 16; // Jump ahead, for another padded nn.
                  disable While_i;
                  // end // else not j==3.
                  end // if zero matches.
                else if (j==0) // First nn not found yet:
                  if1 i = i + 1;
                else begin // This was not first apparent nn found.
                  if1 i = i + 16*j - 1; // Drop back after jump by mistake.
                  if1 j = 0; // Reset nn counter.
                  // Nkeeper = 'b0; // Reinit count keeper.
                  end
              end // while(1) block.
            end // While_i labelled block.
    end // always AlwaysSearch.
",Verilog code example for a packet pad byte search algorithm using RTL design principles.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p342.jpg,True,"The image contains Verilog code. Here it is:

```verilog
begin
for(i=(repetition-1); i<(repetition+3); i++)
begin
    repeat(1) @(posedge clk);
    a <= ~a;
    repeat(start_wait) @(posedge clk);
    b <= ~b;

    // consecutive repeat condition

    repeat((i)) @(posedge clk);
    b <= ~b;
    stop_wait <= $random() % 4;
    repeat(stop_wait[0]) @(posedge clk);
    a <= ~a;
end
end

repeat(2) @(posedge clk);
$finish();
end

initial
forever clk = #25 ~clk;

endmodule

bind sig_sva_tb sig_sva_i1 (a, b, clk);
```

The code snippet appears to be part of a Verilog testbench or a simulation environment where the signal 'clk' is toggled and signals 'a' and 'b' are assigned inverse values at different intervals based on a clock edge (`posedge clk`). There is also usage of the `$random()` system function and a bind directive at the end for associating a module instance.","
begin
for(i=(repetition-1); i<(repetition+3); i++)
begin
    repeat(1) @(posedge clk);
    a <= ~a;
    repeat(start_wait) @(posedge clk);
    b <= ~b;

    // consecutive repeat condition

    repeat((i)) @(posedge clk);
    b <= ~b;
    stop_wait <= $random() % 4;
    repeat(stop_wait[0]) @(posedge clk);
    a <= ~a;
end
end

repeat(2) @(posedge clk);
$finish();
end

initial
forever clk = #25 ~clk;

endmodule

bind sig_sva_tb sig_sva_i1 (a, b, clk);
","""Example of a Verilog testbench code snippet for checking behavior in a digital design using SystemVerilog Assertions (SVA).""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p179.jpg,True,"```verilog
always@(DoPulse)
  begin
    #1 RaceReg = 1'b0;
    #1 RaceReg = 1'b1;
    #1 RaceReg = 1'b0;
  end
//
always@(DoPulse) #1 RaceReg = ~RaceReg;
```","
always@(DoPulse)
  begin
    #1 RaceReg = 1'b0;
    #1 RaceReg = 1'b1;
    #1 RaceReg = 1'b0;
  end
//
always@(DoPulse) #1 RaceReg = ~RaceReg;
","Caption: ""Verilog Conditional Timing and Race Condition Analysis - An excerpt from a Digital VLSI Design textbook discussing simulation of a Verilog module named Racer to study the impact of the order of always blocks on signal updates and race conditions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p277.jpg,True,"Here is the code from the image:

```verilog
genvar T;
generate for (T=0; T<=7; T = T + 1)
  coverproperty (@(posedge clk) (req && reqtag==T));
endgenerate
```","
genvar T;
generate for (T=0; T<=7; T = T + 1)
  coverproperty (@(posedge clk) (req && reqtag==T));
endgenerate
","Caption: ""Example of a SystemVerilog coverage block for verifying maximum outstanding out-of-order transactions using generated properties.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p75.jpg,True,"The image contains multiple snippets of Verilog code. Here they are written out:

First snippet:
```verilog
always @(a or b or c)
begin : b2
  if (c == 8'hff)
  begin
    a2: assert final (a && b);
  end
  else begin
    a3: assert final (a || b);
  end
end

always @(posedge NoGo)
begin : b3
  disable b2;
end
```

Second snippet:
```verilog
assign Frame_ = !Frame_ && IRDY;
assign ACK = Req && Gnt;
always_comb a1: assert final (Frame_ || ACK);
```

Third snippet (the alternative way to write the same deferred immediate assertion as in the second snippet):
```verilog
assign Frame_ = !Frame_ && IRDY;
assign ACK = Req && Gnt;
a1: assert final (Frame_ || ACK);
```","
always @(a or b or c)
begin : b2
  if (c == 8'hff)
  begin
    a2: assert final (a && b);
  end
  else begin
    a3: assert final (a || b);
  end
end

always @(posedge NoGo)
begin : b3
  disable b2;
end


assign Frame_ = !Frame_ && IRDY;
assign ACK = Req && Gnt;
always_comb a1: assert final (Frame_ || ACK);


assign Frame_ = !Frame_ && IRDY;
assign ACK = Req && Gnt;
a1: assert final (Frame_ || ACK);
","""Verilog code examples showcasing the use of immediate assertions and deferred assertion syntax""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p263.jpg,True,"The image contains a fragment of Verilog code for an encoded multiplexer. Here is the code:

```verilog
always @ (select or data0 or data1 or data2 or data3)
case (select)
    2’d0: outdata = data0;
    2’d1: outdata = data1;
    2’d2: outdata = data2;
    2’d3: outdata = data3;
endcase
```

Note: In the Verilog code above, `2’d0, 2’d1, 2’d2, 2’d3` might actually mean `2'd0, 2'd1, 2'd2, 2'd3` where `d` stands for decimal in the Verilog context. It appears to use a typographic quote (’) instead of an apostrophe (') due to font rendering or a similar issue.","
always @ (select or data0 or data1 or data2 or data3)
case (select)
    2’d0: outdata = data0;
    2’d1: outdata = data1;
    2’d2: outdata = data2;
    2’d3: outdata = data3;
endcase
","""Verilog code snippet for an encoded multiplexer with a sensitivity list and case statement""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p247.jpg,True,"The image contains examples of assertions written in Verilog code. Here are the examples provided:

```verilog
// Example 10.11
a1: assert property (
    if (trig) (not p1) until_with p2
);

// Example 10.11 (strong form assertion)
a2: assert property (
    if (trig) (not p1) s_until_with p2
);

// Example 10.12
a1: assert property(
    req ##1 req |-> req s_until_with gnt
);
``` 

These are statements written for property specification typically used in formal verification or simulation environments to check the correctness of Verilog designs.","
// Example 10.11
a1: assert property (
    if (trig) (not p1) until_with p2
);

// Example 10.11 (strong form assertion)
a2: assert property (
    if (trig) (not p1) s_until_with p2
);

// Example 10.12
a1: assert property(
    req ##1 req |-> req s_until_with gnt
);
","Excerpt from a technical document explaining unbounded linear temporal operators in Verilog, with examples of assertions using the `until_with` and `s_until_with` operators.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p98.jpg,True,"The image contains a Verilog code sample. Here is the code:

```verilog
module test;
  import ABC::*;                // Search ABC for symbols
  import XYZ::timeout;          // Just import timeout
  string message = ""Test timed out""; // Hides message in ABC

  initial begin
    #(timeout);                 // From package XYZ
    $display(""Timeout - %s"", message);
    $finish;
  end
endmodule
```

This code demonstrates how to import specific symbols from a package in Verilog.","
module test;
  import ABC::*;                // Search ABC for symbols
  import XYZ::timeout;          // Just import timeout
  string message = ""Test timed out""; // Hides message in ABC

  initial begin
    #(timeout);                 // From package XYZ
    $display(""Timeout - %s"", message);
    $finish;
  end
endmodule
","Caption: ""Extract from a text discussing the importation of specific symbols from a Verilog package, with code example demonstrating how to import all symbols from one package and a single symbol from another.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p521.jpg,True,"Here is the Verilog code from the image:

```verilog
property p1;
  case(a)
    1'b0: p2;
    1'b1: p3;
  endcase
endproperty

property p2;
  p4 or (b and nexttime p1);
endproperty

property p3;
  p4 and nexttime (a |-> p2);
endproperty

property p4;
  a |-> c;
endproperty
```

The text discusses properties (p1, p2, p3, p4) defined in these code snippets and questions related to them, such as which properties are recursive and which are non-recursive.","
property p1;
  case(a)
    1'b0: p2;
    1'b1: p3;
  endcase
endproperty

property p2;
  p4 or (b and nexttime p1);
endproperty

property p3;
  p4 and nexttime (a |-> p2);
endproperty

property p4;
  a |-> c;
endproperty
",A page from a textbook discussing formal semantics of recursive properties in SystemVerilog Assertions (SVA) with examples of property declarations and related questions.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p536.jpg,True,"The image contains a list of ACC fetch routines used in Verilog, along with a short example code. Below is the code from the image:

```verilog
handle module_handle;
char *module_name;

/* obtain a handle for a module */
module_name = acc_fetch_name(module_handle);
```

This snippet shows how to use the `acc_fetch_name()` routine to obtain the name of a Verilog module using a handle for the module.","
handle module_handle;
char *module_name;

/* obtain a handle for a module */
module_name = acc_fetch_name(module_handle);
",List of ACC fetch routines in Verilog and example usage for retrieving a module's name.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p168.jpg,True,"The image contains a segment of a textbook or document related to Verilog, a hardware description language used in the design and modeling of digital systems. Here is the verbatim code excerpt from the image:

```verilog
sequence s_trans2;
  ##63 (c_state == GEN_BLK_ADDR) ##1
  (c_state == WAIT0) ;
endsequence

property p_frame;
  @(posedge clk)
  ((reset_) && (c_state == GEN_BLK_ADDR) &&
  (($past(c_state)== IDLE) ||
  (($past(c_state == NEXT_BLK)))) |-> 
  s_trans2 ##0 s_trans3;
endproperty

a_frame: assert property(p_frame) cnt++;
```

The code defines a Verilog sequence `s_trans2`, which seems to check for a particular condition in a finite state machine transition. A property `p_frame` is also defined and uses this sequence. The last line contains an assertion `a_frame` which asserts the property and increments a counter `cnt`.","
sequence s_trans2;
  ##63 (c_state == GEN_BLK_ADDR) ##1
  (c_state == WAIT0) ;
endsequence

property p_frame;
  @(posedge clk)
  ((reset_) && (c_state == GEN_BLK_ADDR) &&
  (($past(c_state)== IDLE) ||
  (($past(c_state == NEXT_BLK)))) |-> 
  s_trans2 ##0 s_trans3;
endproperty

a_frame: assert property(p_frame) cnt++;
","""Verilog Formal Verification and Functional Coverage Code Examples""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p48.jpg,True,"The image contains Verilog code, here it is transcribed:

```verilog
module ModuleName(...);
    ...
    wire x;
    assign x = a & b | c; // LHS is wire; RHS may be wire or reg(s).
    ...
endmodule

module ModuleName(..., input a, b, c);
    reg x;
    wire y;
    //
    assign y = a & b;
    assign y = y | c; // y driven in two different assigns probably is an error!
    ...
    always @(a,b,c)
    begin
        x = a & b;         // LHS must be reg; RHS may be wire or reg.
        x = x | c;         // x gets (a & b) | c. No problem.
    end
endmodule
```

Additionally, there are examples of binary, hexadecimal, decimal, and octal expressions in the image:

```verilog
1'b1, 1'b0, 1'bx, 1'bz. 8'b000zz_xx11. 64'h33b4_1223_1112_af01.
```

And a note stating that `8'b1010_0010` is the same value as `8'ha2` or `8'hA2` or `8'd162` or `8'o242`.","
module ModuleName(...);
    ...
    wire x;
    assign x = a & b | c; // LHS is wire; RHS may be wire or reg(s).
    ...
endmodule

module ModuleName(..., input a, b, c);
    reg x;
    wire y;
    //
    assign y = a & b;
    assign y = y | c; // y driven in two different assigns probably is an error!
    ...
    always @(a,b,c)
    begin
        x = a & b;         // LHS must be reg; RHS may be wire or reg.
        x = x | c;         // x gets (a & b) | c. No problem.
    end
endmodule


1'b1, 1'b0, 1'bx, 1'bz. 8'b000zz_xx11. 64'h33b4_1223_1112_af01.
","""Excerpt from a digital VLSI design textbook highlighting differences between continuous and procedural assignments in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p55.jpg,True,"The image contains Verilog code defining a property named p14. Here's the code extract from the image:

```verilog
property p14;
    @(posedge clk) a |-> ##[1:$] b ##[0:$] c;
endproperty

a14 : assert property(p14);
```","
property p14;
    @(posedge clk) a |-> ##[1:$] b ##[0:$] c;
endproperty

a14 : assert property(p14);
",Verilog sequence property example and waveform analysis for signal timing verification.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p535.jpg,True,"The image contains several snippets of Verilog code. Here they are:

Example 23.11:
```verilog
checker check1(a, b, event clk = $inferred_clock);
  rand var type(b) v = a;
  always_ff @(clk v <= b;
endchecker : check1
```

Example 23.12:
```verilog
bit [3:0] a;
rand bit [3:0] v;
always_ff @(clk a <= v;
```

Example 23.13:
```verilog
rand bit clk;
bit [3:0] a;
always_ff @clk
  a <= e; // e - deterministic expression defined elsewhere
```

Please note, there are some obvious syntax errors in the provided code snippets (e.g., mismatched parenthesis and semicolons missing at the end of certain lines), so the code as provided may not compile or function as expected in a real-world scenario. These are likely to be errors in the transcription or representation of the code in the image.","
checker check1(a, b, event clk = $inferred_clock);
  rand var type(b) v = a;
  always_ff @(clk v <= b;
endchecker : check1


bit [3:0] a;
rand bit [3:0] v;
always_ff @(clk a <= v;


rand bit clk;
bit [3:0] a;
always_ff @clk
  a <= e; // e - deterministic expression defined elsewhere
","""Understanding the use of free variables in Verilog checker modeling and their assignment to checker variables.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p244.jpg,True,"```c
/**********************************************************************
 * Value change callback application
 **********************************************************************/
PLIbook_MyMonitor_callback(p_cb_data cb_data_p)
{
    vpi_printf(""At time %0.2f:\t %s = %s\n"",
               cb_data_p->time->real,
               cb_data_p->user_data,
               cb_data_p->value->value.str);
}
```","******************************************************************
 * Value change callback application
 **********************************************************************/
PLIbook_MyMonitor_callback(p_cb_data cb_data_p)
{
    vpi_printf(""At time %0.2f:\t %s = %s\n"",
               cb_data_p->time->real,
               cb_data_p->user_data,
               cb_data_p->value->value.str);
}
","""Example of a value change callback function in Verilog PLI from a handbook discussing VPI routines and synchronization.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p55.jpg,True,"The image contains code related to Verilog, specifically discussing default clocking in design assertions. Here is the code from the image:

```verilog
module m (input logic req, clk, output logic gnt);
  default clocking @(posedge clk); endclocking
  // Evaluation of gnt
  ...
  property p_req_granted;
    req |=> gnt;
  endproperty
  a1: assert property (p_req_granted)
      else $error(""Request not granted"");
  a2: assert property(req |=> !req)
      else $error(""Request asserted during two consecutive cycles"");
endmodule : m

default clocking dfltclk @(posedge clk); endclocking
``` 

This snippet demonstrates the usage of the `default clocking` block in a module for specifying the default clock edge for assertions. The explicit clocking event is omitted from the assertions (`a1` and `a2`), as they rely on the default clock defined in the module.","
module m (input logic req, clk, output logic gnt);
  default clocking @(posedge clk); endclocking
  // Evaluation of gnt
  ...
  property p_req_granted;
    req |=> gnt;
  endproperty
  a1: assert property (p_req_granted)
      else $error(""Request not granted"");
  a2: assert property(req |=> !req)
      else $error(""Request asserted during two consecutive cycles"");
endmodule : m

default clocking dfltclk @(posedge clk); endclocking
",This image contains an excerpt from a document explaining clocking blocks in Verilog and demonstrates how to use default clocking with assertions in a Verilog code module.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p277.jpg,True,"The image contains text and a snippet of Verilog code. Here's the code fragment from the image:

```verilog
program automatic bug_free;

initial begin
    for (int j=0; j<3; j++) begin
        automatic int k = j; // Make copy of index
        fork
            begin
                $write(k); // Print copy
            end
        join_none
    end
    #0 $display; // New line after all threads end
end

endprogram
```","
program automatic bug_free;

initial begin
    for (int j=0; j<3; j++) begin
        automatic int k = j; // Make copy of index
        fork
            begin
                $write(k); // Print copy
            end
        join_none
    end
    #0 $display; // New line after all threads end
end

endprogram
",Verilog code snippet demonstrating the use of automatic variables with threads and interprocess communication.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p60.jpg,True,"The image shows a snippet of text from a document about ""Digital VLSI Design with Verilog"" discussing Verilog comments. There is indeed code present in the image and it is listed below:

```verilog
reg a, b;
...
assign x = a & b; // Put the AND of a and b on x.
//
assign y = a /*left operand*/ & b /*right operand*/;
//
assign z = (a>5) ? a & b : a | b;
/* The last assignment puts the AND of a and b on z
   if a is greater than 5; otherwise, it puts the OR
   of a and b on z. */
```","
reg a, b;
...
assign x = a & b; // Put the AND of a and b on x.
//
assign y = a /*left operand*/ & b /*right operand*/;
//
assign z = (a>5) ? a & b : a | b;
/* The last assignment puts the AND of a and b on z
   if a is greater than 5; otherwise, it puts the OR
   of a and b on z. */
","Caption: ""An excerpt from a textbook on Digital VLSI Design with Verilog, highlighting the types of comments used in Verilog code similar to C++ comment syntax.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p154.jpg,True,"The image contains textual content but no actual code. Here is the text present in the image:

```
2. SVA SIMULATION METHODOLOGY

file ""mt.dat"" using a $fwrite statement. A part of the log created for the sample system using this code is shown below.

WRITE: Master 1 writing to Target 1 = 72 at 775
WRITE: Master 1 writing to Target 1 = 77 at 825
WRITE: Master 1 writing to Target 1 = 95 at 875
WRITE: Master 1 writing to Target 1 = 37 at 925
WRITE: Master 1 writing to Target 1 = 216 at 975
WRITE: Master 1 writing to Target 1 = 184 at 1025
WRITE: Master 1 writing to Target 1 = 198 at 1075
WRITE: Master 1 writing to Target 1 = 182 at 1125
READ: Master 3 reading from Target 1 = 72 at 1725
READ: Master 3 reading from Target 1 = 77 at 1775
READ: Master 3 reading from Target 1 = 95 at 1825
READ: Master 3 reading from Target 1 = 37 at 1875
READ: Master 3 reading from Target 1 = 216 at 1925
READ:Master 3 reading from Target 1 = 184 at 1975
READ:Master 3 reading from Target 1 = 198 at 2025
READ:Master 3 reading from Target 1 = 182 at 2075

The transaction logs can be made a lot more fancy and debug friendly depending on the user's application. Note that this code is included within the 'ifdef - 'endif block. This kind of a detailed transaction log might not be needed during long regressions and hence should have the provision to be included conditionally.

2.6 SVA for FPGA Prototyping

A variety of advanced verification methodologies exist today that can help find bugs quickly. Constrained random testbenches and assertions are an important piece in these methodologies. It is very common to write thousands of tests to make sure that all possible functionality has been tested correctly. While most of the bugs are found in the RTL verification, it is still very common to find functional bugs during the verification of implemented gates. Simulating gates has always been a performance bottleneck and will always be. Running all the tests developed during RTL verification on gates is not very practical. Gate level simulation is extremely slow and more and more verification teams are depending on other verification methodologies such as formal verification, FPGA prototyping, etc. as shown in Figure 2-14. By running the verification on the actual silicon, the verification process can be accelerated significantly. This allows running the regression suites developed for RTL exhaustively on actual silicon.
```

It appears to be a textbook or a reference document discussing simulation methodology and FPGA prototyping as related to SVA (SystemVerilog Assertions). The text lists a series of WRITE and READ transactions, which seem to be a sample output from a computer program's log file, but it is not represented as executable code."," SIMULATION METHODOLOGY

file ""mt.dat"" using a $fwrite statement. A part of the log created for the sample system using this code is shown below.

WRITE: Master 1 writing to Target 1 = 72 at 775
WRITE: Master 1 writing to Target 1 = 77 at 825
WRITE: Master 1 writing to Target 1 = 95 at 875
WRITE: Master 1 writing to Target 1 = 37 at 925
WRITE: Master 1 writing to Target 1 = 216 at 975
WRITE: Master 1 writing to Target 1 = 184 at 1025
WRITE: Master 1 writing to Target 1 = 198 at 1075
WRITE: Master 1 writing to Target 1 = 182 at 1125
READ: Master 3 reading from Target 1 = 72 at 1725
READ: Master 3 reading from Target 1 = 77 at 1775
READ: Master 3 reading from Target 1 = 95 at 1825
READ: Master 3 reading from Target 1 = 37 at 1875
READ: Master 3 reading from Target 1 = 216 at 1925
READ:Master 3 reading from Target 1 = 184 at 1975
READ:Master 3 reading from Target 1 = 198 at 2025
READ:Master 3 reading from Target 1 = 182 at 2075

The transaction logs can be made a lot more fancy and debug friendly depending on the user's application. Note that this code is included within the 'ifdef - 'endif block. This kind of a detailed transaction log might not be needed during long regressions and hence should have the provision to be included conditionally.

2.6 SVA for FPGA Prototyping

A variety of advanced verification methodologies exist today that can help find bugs quickly. Constrained random testbenches and assertions are an important piece in these methodologies. It is very common to write thousands of tests to make sure that all possible functionality has been tested correctly. While most of the bugs are found in the RTL verification, it is still very common to find functional bugs during the verification of implemented gates. Simulating gates has always been a performance bottleneck and will always be. Running all the tests developed during RTL verification on gates is not very practical. Gate level simulation is extremely slow and more and more verification teams are depending on other verification methodologies such as formal verification, FPGA prototyping, etc. as shown in Figure 2-14. By running the verification on the actual silicon, the verification process can be accelerated significantly. This allows running the regression suites developed for RTL exhaustively on actual silicon.
","Caption: ""Excerpt from a technical document discussing SVA (SystemVerilog Assertions) simulation methodology and FPGA prototyping, including a sample transaction log.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p140.jpg,True,"Here is the code fragment from the image:

```verilog
Module top(... , );

// port declarations

master
#(.master_sva(1'b1), .master_sva_severity(1'b0))
u1 (ask[2], clk, req1, gnt1, frame1, irdy1, trdy, data1, rsel1, data0);

master
#(.master_sva(1'b1), .master_sva_severity(1'b0))
u2 (ask[1], clk, req2, gnt2, frame2, irdy2, trdy, data2, rsel2, data0);

master
#(.master_sva(1'b1), .master_sva_severity(1'b0))
u3 (ask[0], clk, req3, gnt3, frame3, irdy3, trdy, data3, rsel3, data0);

arbiter
#(.arb_sva(1'b1), .arb_sva_severity(1'b0))
u4 (clk, reset, frame, irdy, req1, req2, req3, gnt1, gnt2, gnt3);

glue
#(.glue_sva(1'b0), .glue_sva_severity(1'b0))
u5 (clk, frame1, irdy1, frame2, irdy2, frame3, irdy3, trdy, rsel1, rsel2, rsel3, data1, data2, data3, sel, data, dataout1, dataout2, data0);
```

Please note that when writing or using the code, you might need to ensure proper indentation and formatting as per the original context from which it was taken. The image may not include all necessary elements for a complete and functional Verilog module, and the exact code structure could depend on surrounding code and declarations not visible in the image.","
Module top(... , );

// port declarations

master
#(.master_sva(1'b1), .master_sva_severity(1'b0))
u1 (ask[2], clk, req1, gnt1, frame1, irdy1, trdy, data1, rsel1, data0);

master
#(.master_sva(1'b1), .master_sva_severity(1'b0))
u2 (ask[1], clk, req2, gnt2, frame2, irdy2, trdy, data2, rsel2, data0);

master
#(.master_sva(1'b1), .master_sva_severity(1'b0))
u3 (ask[0], clk, req3, gnt3, frame3, irdy3, trdy, data3, rsel3, data0);

arbiter
#(.arb_sva(1'b1), .arb_sva_severity(1'b0))
u4 (clk, reset, frame, irdy, req1, req2, req3, gnt1, gnt2, gnt3);

glue
#(.glue_sva(1'b0), .glue_sva_severity(1'b0))
u5 (clk, frame1, irdy1, frame2, irdy2, frame3, irdy3, trdy, rsel1, rsel2, rsel3, data1, data2, data3, sel, data, dataout1, dataout2, data0);
","Caption: ""Excerpt from a document discussing SVA (SystemVerilog Assertions) Simulation Methodology with a snippet of a Verilog module instantiation for a simulation environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p74.jpg,True,"The image contains Verilog code as follows:

```verilog
reg x, y;
...
if (x!=y)
  $strobe(""\n***Time=%04d. x=1b sb y=1b failed.\n"", $time, x, y);
...
// Typical screen output when y unexpectedly goes unknown:
// ""***Time=0912. x=0 m y=x failed.""
```","
reg x, y;
...
if (x!=y)
  $strobe(""\n***Time=%04d. x=1b sb y=1b failed.\n"", $time, x, y);
...
// Typical screen output when y unexpectedly goes unknown:
// ""***Time=0912. x=0 m y=x failed.""
","Caption: ""Verilog simulation techniques and example of a simple assertion using the $time system task in Verilog for Digital VLSI Design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p263.jpg,True,"The image contains a sample of Verilog code. Here it is:

```verilog
program automatic test;

Environment env;

initial begin
  env = new();           // Construct environment
  env.gen_cfg();         // Create random configuration

  // Override random in_use - turn all 4 ports on
  env.cfg.in_use = '1;

  env.build();           // Build the testbench environment
  env.run();             // Run the test
  env.wrap_up();         // Clean up after test & report
end

endprogram
``` 

This code example demonstrates a simple test that overrides a random configuration in Verilog.","
program automatic test;

Environment env;

initial begin
  env = new();           // Construct environment
  env.gen_cfg();         // Create random configuration

  // Override random in_use - turn all 4 ports on
  env.cfg.in_use = '1;

  env.build();           // Build the testbench environment
  env.run();             // Run the test
  env.wrap_up();         // Clean up after test & report
end

endprogram
","Caption: ""Verilog testbench example showing how to override a random configuration in a constrained-random test environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p284.jpg,True,"```verilog
module simple_clock(input logic clk, a, b);
    a1: assert property(
        @(posedge clk)
        a |=> b
    );
endmodule
```","
module simple_clock(input logic clk, a, b);
    a1: assert property(
        @(posedge clk)
        a |=> b
    );
endmodule
","A Verilog module with an assertion property defined, accompanied by an example waveform showing clock signal and inputs.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p288.jpg,True,"The image contains Verilog code. Here is the code extracted from the image:

```verilog
event done[N_GENERATORS];

initial begin
    foreach (gen[i]) begin
        gen[i] = new(done[i]); // Create N generators
        gen[i].run();          // Start them running
    end
end

// Wait for all gen to finish by waiting for each event
foreach (gen[i])
    fork
        automatic int k = i;
        wait (done[k].triggered);
    join_none

wait fork; // Wait for all those triggers to finish
end

event done[N_GENERATORS];
int done_count;

initial begin
    foreach (gen[i]) begin
        gen[i] = new(done[i]); // Create N generators
        gen[i].run();          // Start them running
    end
end

// Wait for all generators to finish
foreach (gen[i])
    fork
        automatic int k = i;
        begin
            wait (done[k].triggered);
            done_count++;
        end
    join_none
wait (done_count==N_GENERATORS); // Wait for triggers
end
```

This Verilog code showcases examples of using events and counter methods to wait for multiple threads in simulation.","
event done[N_GENERATORS];

initial begin
    foreach (gen[i]) begin
        gen[i] = new(done[i]); // Create N generators
        gen[i].run();          // Start them running
    end
end

// Wait for all gen to finish by waiting for each event
foreach (gen[i])
    fork
        automatic int k = i;
        wait (done[k].triggered);
    join_none

wait fork; // Wait for all those triggers to finish
end

event done[N_GENERATORS];
int done_count;

initial begin
    foreach (gen[i]) begin
        gen[i] = new(done[i]); // Create N generators
        gen[i].run();          // Start them running
    end
end

// Wait for all generators to finish
foreach (gen[i])
    fork
        automatic int k = i;
        begin
            wait (done[k].triggered);
            done_count++;
        end
    join_none
wait (done_count==N_GENERATORS); // Wait for triggers
end
","""Verilog code examples demonstrating different methods to wait for multiple threads using wait fork and event triggers.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p82.jpg,True,"```verilog
sequence s29a;
    @(posedge clk) ##[1:2] b;
endsequence

sequence s29b;
    @(posedge clk) ##[2:3] d;
endsequence

property p29;
    @(posedge clk) s28a or s28b;
endproperty

a29: assert property(p29);
```","
sequence s29a;
    @(posedge clk) ##[1:2] b;
endsequence

sequence s29b;
    @(posedge clk) ##[2:3] d;
endsequence

property p29;
    @(posedge clk) s28a or s28b;
endproperty

a29: assert property(p29);
","Caption: ""Verilog code example using the ""or"" construct in SystemVerilog Assertions (SVA), demonstrating sequence combination and property assertion.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p96.jpg,True,"```verilog
|->
  ##[6:10] `free;
endproperty

a_nest1: assert property(p_nest1);
```","
|->
  ##[6:10] `free;
endproperty

a_nest1: assert property(p_nest1);
","""Explanation of a SystemVerilog Assertion (SVA) with nested implication and timing diagram analysis.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p132.jpg,True,"```verilog
`ifdef RTL
assign per = ^in; // calculate parity on 'in'
`else
wire t1, t2, t3;
XOR3 u1 (t1, in[0], in[1], in[2]);
XOR3 u2 (t2, in[3], in[4], in[5]);
XOR3 u3 (t3, in[6], in[7], in[8]);
XOR3 u4 (per, t1, t2, t3);
`endif
```","
`ifdef RTL
assign per = ^in; // calculate parity on 'in'
`else
wire t1, t2, t3;
XOR3 u1 (t1, in[0], in[1], in[2]);
XOR3 u2 (t2, in[3], in[4], in[5]);
XOR3 u3 (t3, in[6], in[7], in[8]);
XOR3 u4 (per, t1, t2, t3);
`endif
","""Verilog Conditional Compilation and XOR Gate Instantiation for Parity Calculation""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p290.jpg,True,"Here is the Verilog code from the image:

```verilog
property p_mintime(event ev1, ev2, time mintime);
    time basetime;
    @(ev1) (1'b1, basetime = $time)
    |=> (@(ev2) $time >= basetime + mintime);
endproperty

a_EV1_EV2_MINTIME: assert property(
    p_mintime(.ev1(EV1), .ev2(EV2), .mintime(MINTIME))
);
```","
property p_mintime(event ev1, ev2, time mintime);
    time basetime;
    @(ev1) (1'b1, basetime = $time)
    |=> (@(ev2) $time >= basetime + mintime);
endproperty

a_EV1_EV2_MINTIME: assert property(
    p_mintime(.ev1(EV1), .ev2(EV2), .mintime(MINTIME))
);
",Verilog assertion example demonstrating proper usage of single leading clock for assertions and the use of timestamps in properties.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p287.jpg,True,"```c
#include ""veriuser.h""
#include ""acc_user.h""
int ShowAValCall()
{
    handle arg_handle;
    arg_handle = acc_handle_tfarg(1);
    io_printf(""signal %s has the value %s\n"",
              acc_fetch_fullname(arg_handle),
              acc_fetch_value(arg_handle, ""%b"", null));
    return(0);
}
```","ude ""veriuser.h""
#include ""acc_user.h""
int ShowAValCall()
{
    handle arg_handle;
    arg_handle = acc_handle_tfarg(1);
    io_printf(""signal %s has the value %s\n"",
              acc_fetch_fullname(arg_handle),
              acc_fetch_value(arg_handle, ""%b"", null));
    return(0);
}
","Caption: ""Example of a Verilog PLI calltf routine in C for displaying signal values during simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p96.jpg,True,"```verilog
a2: assert property (@(posedge clk) a == b)
begin
    a2_success++;
    $info(""a2: a and b have value %b"", a);
end
else begin
    a2_failure++;
    $error(""a2 failure: a = %b, b = %b"", a, b);
end
```","
a2: assert property (@(posedge clk) a == b)
begin
    a2_success++;
    $info(""a2: a and b have value %b"", a);
end
else begin
    a2_failure++;
    $error(""a2 failure: a = %b, b = %b"", a, b);
end
","""Verilog concurrent assertion example with timing diagram and explanation of pass and fail conditions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p435.jpg,True,"The image contains Verilog code as part of a digital VLSI design document. Here is the code provided in the image:

```verilog
fork // unsynthesizable! But do it for now.
// On a write:
if (WriteReq=='1'b1)
begin
    WriteCmdr = '1'b1;
    incrWrite;
end
// On a read:
if (ReadReq=='1'b1)
begin
    ReadCmdr = '1'b1;
    incrRead;
end
join
(transition logic ...)

task incrRead; // Still incorrectly synthesized (but not done yet).
begin
    if (LatchR=='1'b0)
    begin
        LatchR = '1'b1;
        @(posedge StateClock) // Read must not block longer than write.
        ReadCount = ReadCount + 1;
        LatchR = '1'b0;
    end
end
endtask
```

The code segments show a fork-join block typically used in Verilog for running concurrent processes or tasks, and a task definition for `incrRead`. The comments in the code indicate that the fork-join construct is unsynthesizable (cannot be converted into hardware) and that the task `incrRead` is still incorrectly synthesized.","
fork // unsynthesizable! But do it for now.
// On a write:
if (WriteReq=='1'b1)
begin
    WriteCmdr = '1'b1;
    incrWrite;
end
// On a read:
if (ReadReq=='1'b1)
begin
    ReadCmdr = '1'b1;
    incrRead;
end
join
(transition logic ...)

task incrRead; // Still incorrectly synthesized (but not done yet).
begin
    if (LatchR=='1'b0)
    begin
        LatchR = '1'b1;
        @(posedge StateClock) // Read must not block longer than write.
        ReadCount = ReadCount + 1;
        LatchR = '1'b0;
    end
end
endtask
",Verilog code showing a fork-join construct for simultaneous read and write operations with tasks for incrementing read and write counters.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p183.jpg,True,"Here is the Verilog code that is visible in the image:

```verilog
assign req = |req1 || |req2 || |req3;
assign gnt = |gnt1 || |gnt2 || |gnt3;

property p_req_gnt_w;
    @(posedge clk) $rose(req) |->
        ##[2:5] $rose(gnt);
endproperty

a_req_gnt_w : assert property(p_req_gnt_w);
```

Please note that there may be a typo in the code; usually, the bitwise OR operator is a single vertical line `|`, not a double vertical line `||`. Therefore, the code might actually intend to use single vertical lines, like so:

```verilog
assign req = |req1 | |req2 | |req3;
assign gnt = |gnt1 | |gnt2 | |gnt3;
```

Please review the specific context or source from which this image was taken for any additional clarification regarding this code.","
assign req = |req1 || |req2 || |req3;
assign gnt = |gnt1 || |gnt2 || |gnt3;

property p_req_gnt_w;
    @(posedge clk) $rose(req) |->
        ##[2:5] $rose(gnt);
endproperty

a_req_gnt_w : assert property(p_req_gnt_w);


assign req = |req1 | |req2 | |req3;
assign gnt = |gnt1 | |gnt2 | |gnt3;
","Caption: ""Verilog code snippet illustrating the implementation and verification of a timing window protocol for an arbiter in a finite state machine using SystemVerilog Assertions (SVA).""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p73.jpg,True,"The image contains code written in Verilog, which is a hardware description language used to model electronic systems. Here is the code that is visible:

```verilog
bit [7:0] b_unpack[3]; // Unpacked

initial begin
    static int ascend[4] = '{0,1,2,3}; // Initialize 4 elements
    int descend[5];

    descend = '{4,3,2,1,0};              // Set 5 elements
    descend[0:2] = '{7,6,5};             // Set just first 3 elements
    ascend = '{4{8}};                    // Four values of 8
    ascend = '{default:42};              // All elements are set to 42
end
```

The code demonstrates how to declare arrays and initialize them using array literals in SystemVerilog. Please note that the text around the code provides some context for understanding Verilog array declarations, array storage, and initializations.","
bit [7:0] b_unpack[3]; // Unpacked

initial begin
    static int ascend[4] = '{0,1,2,3}; // Initialize 4 elements
    int descend[5];

    descend = '{4,3,2,1,0};              // Set 5 elements
    descend[0:2] = '{7,6,5};             // Set just first 3 elements
    ascend = '{4{8}};                    // Four values of 8
    ascend = '{default:42};              // All elements are set to 42
end
","A textbook excerpt explaining Verilog array declarations and initializations, including unpacked arrays and array literals with examples.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p82.jpg,True,"The image contains a section of text discussing immediate and deferred assertions in Verilog, and it includes a snippet of Verilog code. Here is the code as it appears in the image:

```verilog
function bit check3bits (bit [2:0] expr, value);
  a2: assert (expr > value) else
    $error(""a2 failure: expr = %b, value = %b"", expr, value);
  return (expr > value);
endfunction : check3bits
assign combined = v && check3bits(x, '3`b1);
```

Note that there is a syntax issue with the code snippet provided in the book/document. The binary literal should be written with the base specifier before the value, as in `3'b1` rather than `'3`b1`.","
function bit check3bits (bit [2:0] expr, value);
  a2: assert (expr > value) else
    $error(""a2 failure: expr = %b, value = %b"", expr, value);
  return (expr > value);
endfunction : check3bits
assign combined = v && check3bits(x, '3`b1);
","Caption: ""Exploring the effect of short-circuiting in Verilog expressions and the concept of deferred assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p182.jpg,True,"The image contains Verilog code and accompanying text. Here is the code from the image:

```verilog
c_req_gnt_3: cover property(p_req_gnt_3);

property p_req1;
    @(posedge clk) ($fell(req1) && reset);
endproperty

c_req1: cover property(p_req1);

property p_req2;
    @(posedge clk) ($fell(req2) && reset);
endproperty

c_req2: cover property(p_req2);

property p_req3;
    @(posedge clk) ($fell(req3) && reset);
endproperty

c_req3: cover property(p_req3);
```

The code defines several ""cover properties"" in SystemVerilog, which is used for functional verification of digital systems, alongside standard design. Each `cover property` statement is associated with a property that specifies an event to be monitored during simulation, such as the falling edge of a request signal combined with a reset condition. These are used within a verification environment to track how often certain conditions occur, which is useful for checking the performance and fairness of system components like arbiters.","
c_req_gnt_3: cover property(p_req_gnt_3);

property p_req1;
    @(posedge clk) ($fell(req1) && reset);
endproperty

c_req1: cover property(p_req1);

property p_req2;
    @(posedge clk) ($fell(req2) && reset);
endproperty

c_req2: cover property(p_req2);

property p_req3;
    @(posedge clk) ($fell(req3) && reset);
endproperty

c_req3: cover property(p_req3);
","""Verilog cover properties for functional coverage and arbiter fairness verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p434.jpg,True,"The image contains snippets of Verilog code, which I'll transcribe below:

```verilog
// In this state, we know W == R+1; ...
// Memory command logic:
if (WriteReq=='1'b1) ...
if (ReadReq=='1'b1) ...
//
// Transition logic:
// Set default:
NextState = a_empty;
//
// Check for change:
tempCount = ReadCount+2; // Destination determines wrap-around.
if (WriteCount==tempCount)
    NextState = normal;
else if (WriteCount==ReadCount)
    NextState = empty;
```

The next snippet:

```verilog
// On a write:
if (WriteReq=='1'b1)
    begin
        WriteCmdr = '1'b1;
        incrWrite; // Call task, which blocks on posedge StateClock.
    end
// On a read:
if (ReadReq=='1'b1)
    begin
        ReadCmdr = '1'b1;
        incrRead; // Call task, which blocks on posedge StateClock.
    end
```

Please note that there are ellipsis (`...`) in the code indicating that some parts of the code are not shown in the image. Additionally, the snippet within the parentheses at the bottom seems like a reference to additional content rather than part of the transliterated code:

`(transition logic ...)`

This indicates that there is more content or code related to transition logic not visible in the image.","
// In this state, we know W == R+1; ...
// Memory command logic:
if (WriteReq=='1'b1) ...
if (ReadReq=='1'b1) ...
//
// Transition logic:
// Set default:
NextState = a_empty;
//
// Check for change:
tempCount = ReadCount+2; // Destination determines wrap-around.
if (WriteCount==tempCount)
    NextState = normal;
else if (WriteCount==ReadCount)
    NextState = empty;


// On a write:
if (WriteReq=='1'b1)
    begin
        WriteCmdr = '1'b1;
        incrWrite; // Call task, which blocks on posedge StateClock.
    end
// On a read:
if (ReadReq=='1'b1)
    begin
        ReadCmdr = '1'b1;
        incrRead; // Call task, which blocks on posedge StateClock.
    end
","Caption: ""Excerpt from a textbook discussing Verilog state machine transition logic with code examples for memory command logic and state transitions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p217.jpg,True,"The image contains a table labeled ""Table 2. Automatic Refinement of Calculator Assertions"" which appears to include expressions that are similar to code. Here is the content of that table:

```
Assert. | Iteration | Goal                             | Added Constraint
-------------------------------------------------------------------------
1       | 1         | out_resp[1][0,7] N^3 P = 1       | ~req1_data_in[31] is v^req1_data_in[31],3 
        |           |                                  | 
1       | 2         | out_resp[1][0,7] N^4 P = 1       | ~req1_data_in[31] is v^req1_data_in[31],4
-------------------------------------------------------------------------
2       | 1         | out_resp2[0,7] N^3 P = 2         | ~req1_cmd_in is v^req1_cmd_in,3 
        |           |                                  | 
2       | 2         | out_resp2[0,7] N^3(P = 2 ∧ v^req1_cmd_in,3 = (add ∨ sub)) | req3_cmd_in is v^req3_cmd_in,3
-------------------------------------------------------------------------
3       | 1         | out_resp1[0,9] N^3 P = 1         | ~req1_tag_in is v^req1_tag_in,3 
```

Please note that the text in the ""Added Constraint"" column incorporates mathematical and logical symbols in textual format, and the expressions represent some form of logical constraints or properties that might be related to a formal verification process. The text is not directly executable code but appears to describe constraints in a formal language.",". | Iteration | Goal                             | Added Constraint
-------------------------------------------------------------------------
1       | 1         | out_resp[1][0,7] N^3 P = 1       | ~req1_data_in[31] is v^req1_data_in[31],3 
        |           |                                  | 
1       | 2         | out_resp[1][0,7] N^4 P = 1       | ~req1_data_in[31] is v^req1_data_in[31],4
-------------------------------------------------------------------------
2       | 1         | out_resp2[0,7] N^3 P = 2         | ~req1_cmd_in is v^req1_cmd_in,3 
        |           |                                  | 
2       | 2         | out_resp2[0,7] N^3(P = 2 ∧ v^req1_cmd_in,3 = (add ∨ sub)) | req3_cmd_in is v^req3_cmd_in,3
-------------------------------------------------------------------------
3       | 1         | out_resp1[0,9] N^3 P = 1         | ~req1_tag_in is v^req1_tag_in,3 
","""Academic paper discussing Automatic Refinement and Vacuity Detection for Symbolic Trajectory Evaluation with Verilog code analysis.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p352.jpg,True,"The image contains Verilog code fragments, which I will write out for you:

```verilog
localparam AndDelay = 0.200; // 200 ps 3-input and gate delay.
localparam LatchLagDelay = AndDelay/1.5;
...
reg HoldSlowAnd; // The synchronizing latch storage.
always @(posedge FastClock)
  #LatchLagDelay HoldSlowAnd = SlowAnd; // Sample the slow-domain and.
...
```

And a little further down in the text:

```verilog
assign #(AndDelay/5.0) SyncAnd = HoldFastAnd & HoldSlowAnd;
```

The text is discussing digital VLSI design with Verilog, specifically regarding a latching construct and synchronization between clock domains. There is also a reference to simulation figures which appear to demonstrate the results of simulating the respective Verilog constructs, though the images themselves are of graphical waveform outputs and not code.","
localparam AndDelay = 0.200; // 200 ps 3-input and gate delay.
localparam LatchLagDelay = AndDelay/1.5;
...
reg HoldSlowAnd; // The synchronizing latch storage.
always @(posedge FastClock)
  #LatchLagDelay HoldSlowAnd = SlowAnd; // Sample the slow-domain and.
...


assign #(AndDelay/5.0) SyncAnd = HoldFastAnd & HoldSlowAnd;
",Digital VLSI Design with Verilog: Latching Construct and Simulation Waveforms.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p72.jpg,True,"```verilog
int lo_hi[0:15];            // 16 ints [0]..[15]
int c_style[16];            // 16 ints [0]..[15]

parameter int MEM_SIZE = 256;
parameter int ADDR_WIDTH = $clog2(MEM_SIZE); // $clog2(256) = 8
bit [15:0] mem[MEM_SIZE];
bit [ADDR_WIDTH-1:0] addr;                  // [7:0]

int array2 [0:7][0:3];  // Verbose declaration
int array3 [8][4];      // Compact declaration
array2[7][3] = 1;       // Set last array element
```","
int lo_hi[0:15];            // 16 ints [0]..[15]
int c_style[16];            // 16 ints [0]..[15]

parameter int MEM_SIZE = 256;
parameter int ADDR_WIDTH = $clog2(MEM_SIZE); // $clog2(256) = 8
bit [15:0] mem[MEM_SIZE];
bit [ADDR_WIDTH-1:0] addr;                  // [7:0]

int array2 [0:7][0:3];  // Verbose declaration
int array3 [8][4];      // Compact declaration
array2[7][3] = 1;       // Set last array element
","""Excerpt from a Verilog reference guide discussing fixed-size array declaration, initialization, and address width calculation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p97.jpg,True,"The image contains a snippet of Verilog code. Here is the code from the image:

```verilog
a1: assert property(@(posedge clk) disable iff (rst)
    req |-> nexttime[2] ack);
```

This assertion is an example given in the context of explaining how the `disable iff` operator works in a Verilog assertion, typically used when the reset signal is inactive. The text also discusses issues related to sampling and sensitivity to simulation glitches and offers a solution using the `$sampled` function.","
a1: assert property(@(posedge clk) disable iff (rst)
    req |-> nexttime[2] ack);
","""Exploring the use of 'disable iff' in Verilog assertions for handling resets asynchronously.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p420.jpg,True,"```verilog
always@(posedge ParOutClk)  // 1/2 MHz clock domain of the receiving system.
    if (Reset=='b1 || F_Empty=='b1)
    begin
        ParBuf       <= 'b0;  // Zero the output buffer.
        ParValidReg  <= 'b0;  // Flag its contents as invalid.
    end
    else begin
        // Copy data from the FIFO:
        ParBuf       <= (FIFOReadCmd=='b1) ? FIFO_Out : 'b0;
        // Flag the buffer value validity:
        ParValidReg  <= FIFOReadCmd && (~FIFOEmpty);
    end
```
The image shows some Verilog code, which includes a Verilog `always` block that is triggered on the positive edge of the `ParOutClk` signal, which is presumably a clock signal in the receiving system. It includes an `if` statement that checks if a `Reset` signal is high or if a FIFO is empty (`F_Empty` is high), and then zeros out the `ParBuf` output buffer and sets an invalid flag `ParValidReg`. The `else` branch copies data from a FIFO into `ParBuf` and sets the `ParValidReg` depending on FIFO read-command logic.","
always@(posedge ParOutClk)  // 1/2 MHz clock domain of the receiving system.
    if (Reset=='b1 || F_Empty=='b1)
    begin
        ParBuf       <= 'b0;  // Zero the output buffer.
        ParValidReg  <= 'b0;  // Flag its contents as invalid.
    end
    else begin
        // Copy data from the FIFO:
        ParBuf       <= (FIFOReadCmd=='b1) ? FIFO_Out : 'b0;
        // Flag the buffer value validity:
        ParValidReg  <= FIFOReadCmd && (~FIFOEmpty);
    end
","""Excerpt from a textbook on Digital VLSI Design with Verilog highlighting FIFO implementation considerations and simulation results.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p97.jpg,True,"The image contains Verilog code defining a property with an `if/else` construct. Here is the code as shown in the image:

```verilog
property p_if_else;
    @(posedge clk)
    (s ##1 (start) ##1 (a || b)) |-> 
        if (a)
            (c[-2] ##1 e)
        else
            (d[-2] ##1 f);
endproperty

a_if_else: assert property(p_if_else);
```","
property p_if_else;
    @(posedge clk)
    (s ##1 (start) ##1 (a || b)) |-> 
        if (a)
            (c[-2] ##1 e)
        else
            (d[-2] ##1 f);
endproperty

a_if_else: assert property(p_if_else);
","""Exploring 'if/else' with implication in SystemVerilog Assertions (SVA) for signal behavior verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p286.jpg,True,"The image contains C code associated with a Verilog PLI (Programming Language Interface) application. Here is the code presented in the image:

```c
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */

int PLIbook_ShowVal_checktf()
{
    int arg_type;
    handle arg_handle;

    if (tf_nump() != 1)
        tf_error(""$show_value must have 1 argument."");
    else if (tf_typep(1) == TF_NULLPARAM)
        tf_error(""$show_value arg cannot be null."");
    else {
        arg_handle = acc_handle_tfarg(1);
        arg_type = acc_fetch_type(arg_handle);
        if (!(arg_type == accNet || arg_type == accReg))
            tf_error(""$show_value arg must be a net or reg."");
    }
    return (0);
}
```

This code is an example of a `checktf` routine, which is used to verify the correct usage of a system task or system function in Verilog simulations using the PLI.","ude ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */

int PLIbook_ShowVal_checktf()
{
    int arg_type;
    handle arg_handle;

    if (tf_nump() != 1)
        tf_error(""$show_value must have 1 argument."");
    else if (tf_typep(1) == TF_NULLPARAM)
        tf_error(""$show_value arg cannot be null."");
    else {
        arg_handle = acc_handle_tfarg(1);
        arg_type = acc_fetch_type(arg_handle);
        if (!(arg_type == accNet || arg_type == accReg))
            tf_error(""$show_value arg must be a net or reg."");
    }
    return (0);
}
","""Example of a Verilog PLI checktf routine to validate argument types for a custom system task in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p291.jpg,True,"The image contains a snippet of Verilog code. Here's the code extracted from the image:

```verilog
1 sequence s_ev(event ev);
2   @(ev) 1'b1
3   ##0 (@(ev_enable or ev_wait) 1'b1;
4 endsequence
5 a_order: assert property(
6   @(ev_start) 1'b1
7   |=> (@(ev_enable or ev_wait) (
8     s_ev(ev_wait).triggered
9     -> 
10    s_ev(ev_enable).triggered
11  )
12 );
```
Please note that the line numbers are not part of the Verilog code; they are included for reference.","
1 sequence s_ev(event ev);
2   @(ev) 1'b1
3   ##0 (@(ev_enable or ev_wait) 1'b1;
4 endsequence
5 a_order: assert property(
6   @(ev_start) 1'b1
7   |=> (@(ev_enable or ev_wait) (
8     s_ev(ev_wait).triggered
9     -> 
10    s_ev(ev_enable).triggered
11  )
12 );
","""Verilog assertion example to ensure event ordering using sequences and properties in SystemVerilog.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p289.jpg,True,"The image contains Verilog code related to the use of threads and interprocess communication. The code snippet is from a textbook or similar educational material. Here is the code transcribed from the image:

```verilog
class Generator;
  static int thread_count = 0;

  task run();
    thread_count++; // Start another thread
    fork
      begin
        // Do the real work in here
        // And when done, decrement the thread count
        thread_count--;
      end
    join_none
  endtask
endclass

Generator gen[N_GENERATORS];

initial begin
  // Create N generators
  foreach (gen[i])
    gen[i] = new();

  // Start them running
  foreach (gen[i])
    gen[i].run();

  // Wait for all the generators to complete
  wait (Generator::thread_count == 0);
end
```

This code shows how to create a class representing a generator that has a static thread count and a task for running concurrent threads. Multiple instances of generators are created, and there is a block that waits for all generator threads to complete using a `wait` construct with a class-scope resolution operator.","
class Generator;
  static int thread_count = 0;

  task run();
    thread_count++; // Start another thread
    fork
      begin
        // Do the real work in here
        // And when done, decrement the thread count
        thread_count--;
      end
    join_none
  endtask
endclass

Generator gen[N_GENERATORS];

initial begin
  // Create N generators
  foreach (gen[i])
    gen[i] = new();

  // Start them running
  foreach (gen[i])
    gen[i].run();

  // Wait for all the generators to complete
  wait (Generator::thread_count == 0);
end
","Caption: ""Example of thread synchronization in Verilog using a thread count to manage multiple threads in a Generator class.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p285.jpg,True,"The image contains two pieces of Verilog code. The first one is:

```verilog
module various_clocks(input logic clk1, clk2, a, b, c);
    event e;
    always @(negedge clk1) ->e;
    clocking PCLK2 @(posedge clk2); endclocking
    a2: assert property(@(negedge clk1) a |=> b);
    a3: assert property(@e a[x2] |=> c);
    a4: assert property(@PCLK2 a |=> b);
endmodule
```

The second piece of Verilog code is:

```verilog
module various_clocks(input logic clk1, clk2, a, b, c);
    default clocking NCLK1 @(negedge clk1); endclocking
    clocking PCLK2 @(posedge clk2);
    endclocking a2: assert property(a |=> b);
    a3: assert property(a[x2] |=> c);
    a4: assert property(@PCLK2 a |=> b);
endmodule
```","
module various_clocks(input logic clk1, clk2, a, b, c);
    event e;
    always @(negedge clk1) ->e;
    clocking PCLK2 @(posedge clk2); endclocking
    a2: assert property(@(negedge clk1) a |=> b);
    a3: assert property(@e a[x2] |=> c);
    a4: assert property(@PCLK2 a |=> b);
endmodule


module various_clocks(input logic clk1, clk2, a, b, c);
    default clocking NCLK1 @(negedge clk1); endclocking
    clocking PCLK2 @(posedge clk2);
    endclocking a2: assert property(a |=> b);
    a3: assert property(a[x2] |=> c);
    a4: assert property(@PCLK2 a |=> b);
endmodule
","""Examples of Verilog modules with different clocking and assertion strategies for concurrent assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p68.jpg,True,"The image contains Verilog SystemVerilog Assertion (SVA) code. Here's the code written in the image:

```verilog
Property p21;
    @(posedge clk) $rose(start) |-> ##2 (a[*3]) ##2 stop ##1 !stop;
endproperty

a21: assert property(p21);
```","
Property p21;
    @(posedge clk) $rose(start) |-> ##2 (a[*3]) ##2 stop ##1 !stop;
endproperty

a21: assert property(p21);
","""Introduction to Sequence and Property Syntax in SystemVerilog Assertions (SVA)""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p75.jpg,True,"```verilog
integer x; ....; x = 5;
$display(""%s = [%04b] = [%4b]."", ""The value"", x, x);
```

The snippet of Verilog code provided is for displaying a binary value with leading zeros to fit a width of four bits via `$display` system task.","
integer x; ....; x = 5;
$display(""%s = [%04b] = [%4b]."", ""The value"", x, x);
","Caption: ""Document excerpt explaining Verilog format specifiers and illustrating the use of shift registers.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p141.jpg,True,"The image contains a code snippet written in Verilog. Here is the code from the image:

```verilog
target
#(.target_sva(1'b0), .target_sva_severity(1'b0))
u6 (clk, reset, sel[1], trdy[1], data, dataout1);

target
#(.target_sva(1'b0), .target_sva_severity(1'b0))
u7 (clk, reset, sel[0], trdy[0], data, dataout2);

endmodule
```

This code appears to be a part of a Verilog hardware description involving parametrized instances (`u6` and `u7`) of a module named `target`. Parameters `target_sva` and `target_sva_severity` are being set to zero for both instances.","
target
#(.target_sva(1'b0), .target_sva_severity(1'b0))
u6 (clk, reset, sel[1], trdy[1], data, dataout1);

target
#(.target_sva(1'b0), .target_sva_severity(1'b0))
u7 (clk, reset, sel[0], trdy[0], data, dataout2);

endmodule
","Caption: ""Excerpt from a technical document discussing the configuration of SystemVerilog Assertions (SVA) and considerations for functional coverage in verification environments.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p508.jpg,True,"The image contains text that discusses formal semantics in the context of clocking events, particularly for a hardware description language, likely Verilog or a similar language. It is not code per se but rather shows several transformation rules for boolean expressions and properties in the context of semantic analysis or formal verification. Here are the transformation rules provided in the image:

```
C4 τ(posedge b) = $rising_gclk(b).
C5 τ(negedge b) = $falling_gclk(b).
C6 τ(dege b) = τ(posedge b) || τ(negedge b).
C7 τ(e iff b) = τ(e) && b.
C8 τ(e1 or e2) = τ(e1) || τ(e2).
C9 τ(e1, e2) = τ(e1) || τ(e2).

τ(posedge clk iff enable) = $rising_gclk(clk) && enable

SCR0 $T(r, c) = ($T(r, c)).
SCR1 $T(b, c) != !c [*1] ##1 c && b.
SCR2 $T((l <= v <= h), c) = $T(l, c) ##0 (l <= v = h).
SCR3 $T(c2 ? (c2)', c1) = $T(c2, c).4
SCR4 $T(r1 op r2, c) = $T(r1, c) op $T(r2, c), where op can be any of the operators ##0, ##1, or, and intersect.

SCR5 $T(first_match (r), c) = first_match ($T(r, c)).
SCR6 $T(r[*n], c) = $T(r, c) [*n]. The same rule applies to ranged repetition operators.

PCR0 $T(p, c) = ($T(p, c)).
PCR1 $T(op (r), c) = op ($T(r, c)), where op is either strong or weak.
PCR2 $T((c2 p), c1) = $T(p, c2).5
PCR3 $T(op p, c) = op $T(p, c), where op is any of not, disable iff (b), accept_on(b), and reject_on(b).
PCR4 $T(op p1 op2, c) = $T(p1, c) op $T(p2, c), where op can be any of the operators and, or, implies, and iff.

PCR5 $T(sync_accept_on(b) p, c) = accept_on(b && c) $T(p, c). An analogous rule applies to rewrite the synchronous reject in terms of the asynchronous reject.
```

The footnote mention in the text states, ""This rule can be applied only after applying the clock flow rules in Sect. 12.2.4.1.""

Please note that these rules are likely theoretical or schema-based representations, used for formal reasoning about hardware designs and not executable Verilog code.","osedge b) = $rising_gclk(b).
C5 τ(negedge b) = $falling_gclk(b).
C6 τ(dege b) = τ(posedge b) || τ(negedge b).
C7 τ(e iff b) = τ(e) && b.
C8 τ(e1 or e2) = τ(e1) || τ(e2).
C9 τ(e1, e2) = τ(e1) || τ(e2).

τ(posedge clk iff enable) = $rising_gclk(clk) && enable

SCR0 $T(r, c) = ($T(r, c)).
SCR1 $T(b, c) != !c [*1] ##1 c && b.
SCR2 $T((l <= v <= h), c) = $T(l, c) ##0 (l <= v = h).
SCR3 $T(c2 ? (c2)', c1) = $T(c2, c).4
SCR4 $T(r1 op r2, c) = $T(r1, c) op $T(r2, c), where op can be any of the operators ##0, ##1, or, and intersect.

SCR5 $T(first_match (r), c) = first_match ($T(r, c)).
SCR6 $T(r[*n], c) = $T(r, c) [*n]. The same rule applies to ranged repetition operators.

PCR0 $T(p, c) = ($T(p, c)).
PCR1 $T(op (r), c) = op ($T(r, c)), where op is either strong or weak.
PCR2 $T((c2 p), c1) = $T(p, c2).5
PCR3 $T(op p, c) = op $T(p, c), where op is any of not, disable iff (b), accept_on(b), and reject_on(b).
PCR4 $T(op p1 op2, c) = $T(p1, c) op $T(p2, c), where op can be any of the operators and, or, implies, and iff.

PCR5 $T(sync_accept_on(b) p, c) = accept_on(b && c) $T(p, c). An analogous rule applies to rewrite the synchronous reject in terms of the asynchronous reject.
","""Verilog Formal Semantics: Clocking Events and Unclocked Expressions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p262.jpg,True,"The image contains Verilog/SystemVerilog code samples from a document. Here's the code as written in the image:

```verilog
function void gen_cfg();
    `SV_RAND_CHECK(cfg.randomize()); // Randomize the cfg
endfunction

task run();
    foreach (gen[i])
        if (cfg.in_use[i]) begin
            // Only start the testbench transactors that are in-use
            gen[i].run();
            ...
        end
    endtask

task wrap_up();
    // Not currently used
endtask

endclass : Environment

program automatic test;

    Environment env;

    initial begin
        env = new();                // Construct environment
        env.gen_cfg();              // Create random configuration
        env.build();                // Build the testbench environment
        env.run();                  // Run the test
        env.wrap_up();              // Clean up after test & report
    end

endprogram
```

The code defines a SystemVerilog class called `Environment` with a function `gen_cfg` to generate a random configuration, a `run` task to start testbench transactors that are in-use, and a `wrap_up` task that is not currently used.

Following this, there is a SystemVerilog `program` called `test` which instantiates the `Environment`, constructs it using `new()`, generates a random configuration with `gen_cfg()`, builds the testbench environment with `build()`, runs the test with `run()`, and finally calls `wrap_up()` for cleanup after the test.","
function void gen_cfg();
    `SV_RAND_CHECK(cfg.randomize()); // Randomize the cfg
endfunction

task run();
    foreach (gen[i])
        if (cfg.in_use[i]) begin
            // Only start the testbench transactors that are in-use
            gen[i].run();
            ...
        end
    endtask

task wrap_up();
    // Not currently used
endtask

endclass : Environment

program automatic test;

    Environment env;

    initial begin
        env = new();                // Construct environment
        env.gen_cfg();              // Create random configuration
        env.build();                // Build the testbench environment
        env.run();                  // Run the test
        env.wrap_up();              // Clean up after test & report
    end

endprogram
","""Example of Verilog testbench code with random configuration generation for simulation environments.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p40.jpg,True,"The image contains a snippet of Verilog code within the text. Here is the code that is visible:

```verilog
req_ack: assert property (@(posedge clk) req |-> ##[1:3] ack);
```

This code represents a SystemVerilog assertion statement that asserts a property where upon a positive edge of the `clk` clock signal, whenever `req` is true, `ack` must be true within 1 to 3 clock cycles afterward.
","
req_ack: assert property (@(posedge clk) req |-> ##[1:3] ack);
","The image depicts a page from a document discussing how assertions are checked in Verilog simulation, emulation, and formal analysis, with a focus on simulation. It includes an example of a SystemVerilog assertion code snippet for checking a request-acknowledge protocol.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p276.jpg,True,"The image contains snippets of Verilog code displayed as examples. Here is the code written in the image:

Sample 7.11 Automatic variables in a fork...join_none

```verilog
initial begin
    for (int j=0; j<3; j++)
        fork
            automatic int k = j; // Make copy of index
            begin
                $write(k); // Print copy
            end
        join_none
    #0 $display;
end
```

This sample demonstrates the use of automatic variables inside a `fork...join_none` construct in Verilog to make a copy of an index variable for each thread spawned within a loop. After the threads are completed, a `#0 $display;` delay is utilized to ensure that printing happens after all threads have finished their execution.","
initial begin
    for (int j=0; j<3; j++)
        fork
            automatic int k = j; // Make copy of index
            begin
                $write(k); // Print copy
            end
        join_none
    #0 $display;
end
",Sample code illustrating incorrect and correct usage of fork-join_none constructs in Verilog to handle race conditions with threads.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p54.jpg,True,"```verilog
logic req, gnt;
// Evaluation of gnt
...

clocking cb1k @(posedge clk);
  input req, gnt;
  property p_req_granted;
    req |=> gnt;
  endproperty

  a1: assert property (cb1k.p_req_granted)
  else $error(""Request not granted"");
  a2: assert property(@(posedge clk) req |=> !req)
  else $error(""Request asserted during two consecutive cycles"");
endclocking
```","
logic req, gnt;
// Evaluation of gnt
...

clocking cb1k @(posedge clk);
  input req, gnt;
  property p_req_granted;
    req |=> gnt;
  endproperty

  a1: assert property (cb1k.p_req_granted)
  else $error(""Request not granted"");
  a2: assert property(@(posedge clk) req |=> !req)
  else $error(""Request asserted during two consecutive cycles"");
endclocking
","""Overview and example of a Verilog clocking block declaration for signal synchronization and sampling.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p155.jpg,True,"```verilog
module master (ask_for_it, clk, req, gnt, frame, 
               irdy, trdy, data_c, r_sel, data_o);

input clk, gnt, ask_for_it;
input [1:0] trdy;
output req, frame, irdy, r_sel;
```","
module master (ask_for_it, clk, req, gnt, frame, 
               irdy, trdy, data_c, r_sel, data_o);

input clk, gnt, ask_for_it;
input [1:0] trdy;
output req, frame, irdy, r_sel;
","Caption: ""An excerpt from a technical document discussing FPGA prototyping and showing a sample Verilog code for a master device module.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p61.jpg,True,"The image contains Verilog code examples. Here is the text for the code snippets provided:

For `always` Blocks:

```verilog
...
always                                   // Avoid this style.
    #10 ClockIn <= !ClockIn;
...

always@(ClockIn)                        // Recommended style.
    #10 ClockIn <= !ClockIn;
```

For `initial` Blocks:

```verilog
module TestBench;
reg Astim, Bstim, Cstim, Dstim; // To accept initialization.
...
initial
begin
    `include ""../../VCS/Extras.inc""
    #1 Astim = 1'b0;
    #1 Bstim = 1'b0;
    #1 Cstim = 1'b0;
    #1 Dstim = 1'b0;
    #50 Astim = 1'b1;
    ...
end
...
```

The image is part of a text discussing the use of `always` and `initial` blocks in Verilog, including style recommendations and the behavior of these constructs in simulation and synthesis.","
...
always                                   // Avoid this style.
    #10 ClockIn <= !ClockIn;
...

always@(ClockIn)                        // Recommended style.
    #10 ClockIn <= !ClockIn;


module TestBench;
reg Astim, Bstim, Cstim, Dstim; // To accept initialization.
...
initial
begin
    `include ""../../VCS/Extras.inc""
    #1 Astim = 1'b0;
    #1 Bstim = 1'b0;
    #1 Cstim = 1'b0;
    #1 Dstim = 1'b0;
    #50 Astim = 1'b1;
    ...
end
...
","""Discussion on Verilog 'always' blocks with sensitivity lists and 'initial' blocks used in simulation, emphasizing recommended coding styles.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p523.jpg,True,"```c
#include ""veriuser.h""  /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""  /* IEEE 1364 PLI ACC routine library */

/*************************************************************
 * Sizeitf application
 *************************************************************/

int PLIbook_CountLoads_sizetf()
{
    return(0);
}
```","ude ""veriuser.h""  /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""  /* IEEE 1364 PLI ACC routine library */

/*************************************************************
 * Sizeitf application
 *************************************************************/

int PLIbook_CountLoads_sizetf()
{
    return(0);
}
","Caption: ""Excerpt from a book discussing the ACC routine library in Verilog, specifically illustrating the use of acc_count() function for counting objects within a module.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p534.jpg,True,"The image contains text related to code, but the only portions of actual code are in the pseudocode and code-like snippets provided as examples of Verilog syntax within the text. Here are the code snippets:

1.
```verilog
... // sequence of statements 2
v <= expr2;
end
```

2.
```verilog
if (cond) begin
    ... // sequence of statements 1
    v <= expr1;
    ... // sequence of statements 2
end else begin
    ... // sequence of statements 3
    v <= expr2;
    ... // sequence of statements 4
end
```

3.
```verilog
v <= cond ? expr1 : expr2;
```

4.
```verilog
if (cond) begin
    ... // sequence of statements 1
    ... // sequence of statements 2
end else begin
    ... // sequence of statements 3
    ... // sequence of statements 4
end
```

Please note that these are partial code examples with placeholders (such as `...`, `cond`, `expr1`, `expr2`, etc.) used to illustrate the text's concepts and may not be directly executable without being part of a complete code context.","
... // sequence of statements 2
v <= expr2;
end


if (cond) begin
    ... // sequence of statements 1
    v <= expr1;
    ... // sequence of statements 2
end else begin
    ... // sequence of statements 3
    v <= expr2;
    ... // sequence of statements 4
end


v <= cond ? expr1 : expr2;


if (cond) begin
    ... // sequence of statements 1
    ... // sequence of statements 2
end else begin
    ... // sequence of statements 3
    ... // sequence of statements 4
end
","""Guidelines for normalizing conditional assignments in Verilog for formal verification purposes""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p54.jpg,True,"```verilog
Property p13;
    @(posedge clk) (a && b) |-> ##[0:2] c;
endproperty

a13 : assert property(p13);
```","
Property p13;
    @(posedge clk) (a && b) |-> ##[0:2] c;
endproperty

a13 : assert property(p13);
","""Explaining overlapping timing window in SystemVerilog Assertions (SVA) with property p13 and waveform example.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p49.jpg,True,"The image contains Verilog code included within a textbook or a set of lecture notes. Here is the code snippet extracted from the image:

```verilog
`timescale 1ns/10ps
module Vector;
    reg [15:0] MyBus; // A vector of 16 bits of storage.
    ...
    wire[15:0] mybus; // The verilog MSB always is on the left.
    ...
    MyBus[0:2] = mybus[10:8]; // This is called a ""part select"".
    MyBus = mybus;
    MyBus[0:15] = mybus[15:0];
    ...
endmodule
```","
`timescale 1ns/10ps
module Vector;
    reg [15:0] MyBus; // A vector of 16 bits of storage.
    ...
    wire[15:0] mybus; // The verilog MSB always is on the left.
    ...
    MyBus[0:2] = mybus[10:8]; // This is called a ""part select"".
    MyBus = mybus;
    MyBus[0:15] = mybus[15:0];
    ...
endmodule
",Verilog code demonstrating vector operations and logical operators.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p246.jpg,True,"The image contains excerpts from a text discussing properties in Verilog, along with two examples of Verilog code. The code snippets are as follows:

```verilog
a1: assert property(e1 |=> c until e2);
a2: assert property(e1 |=> c s_until e2);
```

These code snippets demonstrate the usage of ""until"" and ""s_until"" properties in assertions within Verilog, used to enforce temporal logic constraints in hardware design verification.","
a1: assert property(e1 |=> c until e2);
a2: assert property(e1 |=> c s_until e2);
","""Understanding Unbounded Until and Always Operators in Verilog Assertions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p99.jpg,True,"The image contains excerpts from a textbook or document that discusses streaming operators in the context of Verilog or SystemVerilog. Here are the code snippets presented in the image:

```
int i;
real r;
i = int '(10.0 - 0.1); // cast is optional
r = real'(42);          // cast is optional
```

```
initial begin
  int h;
  bit [7:0] b, g[4], j[4] = {'8'ha, '8'hb, '8'hc, '8'hd};
  bit [7:0] q, r, s, t;

  h = { >> {j}};             // 00a0b0c0d pack array into int
  h = { << {j}};             // b030d050 reverse bits
  h = { << byte {j}};        // 0d0c0b0a reverse bytes
  {>>{g}} = { << byte {j}};  // 0d,0c,0b,0a unpack into array
  b = { << {8'b0011_0101}};  // 1010_1100 reverse bits
  b = { << 4 {8'b0011_0101}}; // 0101_0011 reverse nibble
  {>>{q, r, s, t}} = j;      // Scatter j into bytes
  h = {>>{t, s, r, q}};      // Gather bytes into h
end
```

The code showcases how to use the streaming operators (`>>` and `<<`) to manipulate bits and perform operations such as reversing bits, packing arrays into integers, unpacking arrays, and reversing the order of bytes or nibbles.","
real r;
i = int '(10.0 - 0.1); // cast is optional
r = real'(42);          // cast is optional

l begin
  int h;
  bit [7:0] b, g[4], j[4] = {'8'ha, '8'hb, '8'hc, '8'hd};
  bit [7:0] q, r, s, t;

  h = { >> {j}};             // 00a0b0c0d pack array into int
  h = { << {j}};             // b030d050 reverse bits
  h = { << byte {j}};        // 0d0c0b0a reverse bytes
  {>>{g}} = { << byte {j}};  // 0d,0c,0b,0a unpack into array
  b = { << {8'b0011_0101}};  // 1010_1100 reverse bits
  b = { << 4 {8'b0011_0101}}; // 0101_0011 reverse nibble
  {>>{q, r, s, t}} = j;      // Scatter j into bytes
  h = {>>{t, s, r, q}};      // Gather bytes into h
end
","""Verilog Code Examples Demonstrating Static Casting and Streaming Operators""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p251.jpg,True,"```c
#include <math.h>
#include <errno.h>
void PLIbook_ScientificALU_model(
    double *result,   /* output from ALU */
    int    *excep,    /* output; set if result is out of range */
    int    *err,      /* output; set if input is out of range */
    double  a,        /* input */
    double  b,        /* input */
    int     opcode)   /* input */
{ 
    switch (opcode) {
        case 0x0: *result = pow   (a, b); break;
        case 0x1: *result = sqrt  (a);    break;
        case 0x2: *result = exp   (a);    break;
        case 0x3: *result = ldexp (a, (int)b); break;
        case 0x4: *result = fabs  (a);    break;
        case 0x5: *result = fmod  (a, b); break;
        case 0x6: *result = ceil  (a);    break;
        case 0x7: *result = floor (a);    break;
        case 0x8: *result = log   (a);    break;
        case 0x9: *result = log10 (a);    break;
        case 0xA: *result = sin   (a);    break;
        case 0xB: *result = cos   (a);    break;
        case 0xC: *result = tan   (a);    break;
        case 0xD: *result = asin  (a);    break;
        case 0xE: *result = acos  (a);    break;
        case 0xF: *result = atan  (a);    break;
    }
    *err = (errno == EDOM);   /* arg to math func. out of range */
    *excep = (errno == ERANGE); /* result of math func. out of range */
    errno = 0;                 /* clear the error flag */
    if (*err) *result = 0.0;   /* set result to 0 if error occurred */
    return;
}
```","ude <math.h>
#include <errno.h>
void PLIbook_ScientificALU_model(
    double *result,   /* output from ALU */
    int    *excep,    /* output; set if result is out of range */
    int    *err,      /* output; set if input is out of range */
    double  a,        /* input */
    double  b,        /* input */
    int     opcode)   /* input */
{ 
    switch (opcode) {
        case 0x0: *result = pow   (a, b); break;
        case 0x1: *result = sqrt  (a);    break;
        case 0x2: *result = exp   (a);    break;
        case 0x3: *result = ldexp (a, (int)b); break;
        case 0x4: *result = fabs  (a);    break;
        case 0x5: *result = fmod  (a, b); break;
        case 0x6: *result = ceil  (a);    break;
        case 0x7: *result = floor (a);    break;
        case 0x8: *result = log   (a);    break;
        case 0x9: *result = log10 (a);    break;
        case 0xA: *result = sin   (a);    break;
        case 0xB: *result = cos   (a);    break;
        case 0xC: *result = tan   (a);    break;
        case 0xD: *result = asin  (a);    break;
        case 0xE: *result = acos  (a);    break;
        case 0xF: *result = atan  (a);    break;
    }
    *err = (errno == EDOM);   /* arg to math func. out of range */
    *excep = (errno == ERANGE); /* result of math func. out of range */
    errno = 0;                 /* clear the error flag */
    if (*err) *result = 0.0;   /* set result to 0 if error occurred */
    return;
}
","""Example of a C model for a scientific ALU interfaced with Verilog using VPI routines from a textbook chapter on Interfacing to C Models.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p68.jpg,True,"Here is the Verilog code contained in the image:

```verilog
logic clk, a, b;
...
always @ (posedge clk) a <= b;
```

This code snippet demonstrates a simple edge-triggered always block, which assigns the value of `b` to `a` on the positive edge of a clock signal `clk`.","
logic clk, a, b;
...
always @ (posedge clk) a <= b;
","""Exploring SystemVerilog simulation semantics and the concept of simulation races with an example code snippet.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p40.jpg,True,"The image includes a snippet of Verilog code. Here it is:

```verilog
sequence s4;
    @(posedge clk) a ##2 b;
endsequence
``` 

This Verilog code defines a sequence named `s4` that checks for the signal `a` being high at the positive edge of the clock, followed by signal `b` being high exactly two clock cycles after `a` was high.","
sequence s4;
    @(posedge clk) a ##2 b;
endsequence
","Caption: ""Introduction to SystemVerilog Assertions (SVA) – Describing and simulating the timing relationship sequence 's4' using Verilog code followed by a waveform illustration.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p169.jpg,True,"The image contains Verilog code related to SystemVerilog Assertions (SVA) for Finite State Machines. Here is the code written on the page:

```verilog
c_frame: cover property(p_frame);

property p_complete_frame;
    @(posedge clk)
    ((cnt == 16'd4095) && reset_ &&
    (c_state==CNT6)) |-> done_frame;
endproperty

a_complete_frame:
    assert property(p_complete_frame)
    $display (""A complete frame has been transferred\n"");

property p_frame_path1;
    @(posedge clk)
    ((reset_) && (c_state == GEN_BLK_ADDR) &&
    ($past(c_state == NEXT_BLK)) ) |-> s_trans2 ##0 s_trans3;
```

Above and below the code snippets, there is additional descriptive text pertaining to how these properties are used for checking the behavior of finite state machines during simulation.","
c_frame: cover property(p_frame);

property p_complete_frame;
    @(posedge clk)
    ((cnt == 16'd4095) && reset_ &&
    (c_state==CNT6)) |-> done_frame;
endproperty

a_complete_frame:
    assert property(p_complete_frame)
    $display (""A complete frame has been transferred\n"");

property p_frame_path1;
    @(posedge clk)
    ((reset_) && (c_state == GEN_BLK_ADDR) &&
    ($past(c_state == NEXT_BLK)) ) |-> s_trans2 ##0 s_trans3;
","Verilog SystemVerilog Assertions (SVA) for Finite State Machine (FSM) verification, including a waveform diagram and code snippet for property checking.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p537.jpg,True,"```c
int acc_fetch_type(object)
handle object; /* handle for an object. */
```

```c
handle tfarg_handle;
tfarg_handle = acc_handle_tfarg(1);
if (acc_fetch_type(tfarg_handle) != accModule)
    /* report error that argument is not correct */
```","cc_fetch_type(object)
handle object; /* handle for an object. */

e tfarg_handle;
tfarg_handle = acc_handle_tfarg(1);
if (acc_fetch_type(tfarg_handle) != accModule)
    /* report error that argument is not correct */
","A page from ""The Verilog PLI Handbook"" discussing the ACC routine `acc_fetch_type` used for identifying object type properties in Verilog programming.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p150.jpg,True,"The image contains Verilog code. Here is the code as provided in the image:

1. The first code block describes a binary up-counter:
```verilog
reg[3:0] Count;
always@(posedge Clk, posedge Rst)
if (Rst == 1'b1)
    Count <= 4'h0;
else begin
    if (Count < 9)
        Count <= Count + 1;
    else Count <= 4'h0;
end
```

2. The second code block describes preloading the counter to bias the wrap-around:
```verilog
reg[3:0] Count;
always @(posedge Clk, posedge Rst)
if (Rst == 1'b1 || Count == 4'hf)
    Count <= 4'h6;
else Count <= Count + 1;
```

These snippets show two methods to create counters in Verilog with different behaviors regarding how they wrap or count to specific values.","
reg[3:0] Count;
always@(posedge Clk, posedge Rst)
if (Rst == 1'b1)
    Count <= 4'h0;
else begin
    if (Count < 9)
        Count <= Count + 1;
    else Count <= 4'h0;
end


reg[3:0] Count;
always @(posedge Clk, posedge Rst)
if (Rst == 1'b1 || Count == 4'hf)
    Count <= 4'h6;
else Count <= Count + 1;
","Caption: ""Verilog code examples demonstrating a basic binary up-counter, and a method to create a counter that wraps at a specific value other than a power of two.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p74.jpg,True,"The image contains Verilog code snippets. Here they are:

First code snippet:
```verilog
assign a = c || d;
assign b = e || f;

always_comb begin:bl
  a1: cover (b != a) //immediate cover
  a2: cover #0 (b != a); //Observed deferred cover
  a3: cover final (b != a) //Final deferred cover
end
```
Second code snippet (for `assume`):
```verilog
assign a = c || d;
assign b = e || f;

always_comb begin:bl
  a1: assume (b != a) //immediate assume
  a2: assume #0 (b != a); //deferred assume
  a3: assume final (b != a) //deferred assume
end
```
Third code snippet (disabling a deferred assertion):
```verilog
always @(NoGo or Go) begin : b1
  a1: assert final (Go) else $fatal(1, ""Sorry"");
  if (NoGo)
    begin
      disable a1;
    end
end
```","
assign a = c || d;
assign b = e || f;

always_comb begin:bl
  a1: cover (b != a) //immediate cover
  a2: cover #0 (b != a); //Observed deferred cover
  a3: cover final (b != a) //Final deferred cover
end


assign a = c || d;
assign b = e || f;

always_comb begin:bl
  a1: assume (b != a) //immediate assume
  a2: assume #0 (b != a); //deferred assume
  a3: assume final (b != a) //deferred assume
end


always @(NoGo or Go) begin : b1
  a1: assert final (Go) else $fatal(1, ""Sorry"");
  if (NoGo)
    begin
      disable a1;
    end
end
","""Examples of Verilog code for immediate and deferred cover and assume statements, and disabling a deferred assertion.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p262.jpg,True,"The image contains example code from a book discussing functional coverage in PSL and SystemVerilog. Here are the codes provided in the image:

PSL (Property Specification Language) functional coverage for boundary condition:
```verilog
cover { count==max-2; count==max-1 };
cover { count==1; count==0; };
```

SystemVerilog functional coverage for increment/decrement conditions:
```verilog
genvar i;
generate for (i=0; i<=7; i = i + 1)
  cover property @(posedge clk) {(inc, dec, load) === i};
endgenerate
```","
cover { count==max-2; count==max-1 };
cover { count==1; count==0; };


genvar i;
generate for (i=0; i<=7; i = i + 1)
  cover property @(posedge clk) {(inc, dec, load) === i};
endgenerate
","Caption: ""Textbook excerpt on Verilog boundary conditions and counter control with PSL and SystemVerilog code examples for functional coverage.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p276.jpg,True,"The image contains two code snippets in a document related to functional coverage in Verilog and SystemVerilog. The first code snippet is a Verilog example, and the text and code is as follows:

```verilog
reg [3:0] req_cnt;
always @(posedge clk) begin
    if (reset_n) begin
        req_cnt <= 0;
    end
    else begin
        // Increment counter each time event is seen.
        if (req & !ack) req_cnt <= req_cnt + 1;
        if (ack & !req) req_cnt <= req_cnt - 1;
    end
end

// PSL cover ({rose(req_cnt) == MAX_OUTSTANDING});
```

The second code snippet is a SystemVerilog example:

```verilog
genvar N;
generate for (N=1; N<=10; N= N+ 1)
    cover property (@ (posedge clk) (done ##N req));
endgenerate
```

Please note, the PSL cover directive in the first snippet is commented out by using `//`.","
reg [3:0] req_cnt;
always @(posedge clk) begin
    if (reset_n) begin
        req_cnt <= 0;
    end
    else begin
        // Increment counter each time event is seen.
        if (req & !ack) req_cnt <= req_cnt + 1;
        if (ack & !req) req_cnt <= req_cnt - 1;
    end
end

// PSL cover ({rose(req_cnt) == MAX_OUTSTANDING});


genvar N;
generate for (N=1; N<=10; N= N+ 1)
    cover property (@ (posedge clk) (done ##N req));
endgenerate
","Caption: ""Examples of Property Specification Language (PSL) and SystemVerilog functional coverage for different verification scenarios in Verilog HDL.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p144.jpg,True,"The image contains some Verilog code snippets. Here they are written out for you:

```verilog
reg[63:0] WordReg;
reg[7:0]  ByteReg;
reg[15:0] DByteReg;
reg[31:0] BigMem[255:0];
reg[3:0]  LilMem[255:0];
...
BigMem[31]      <= WordReg;
WordReg         <= BigMem;
LilMem[127:126] <= ByteReg;
LilMem          <= ByteReg[3:0];
DByteReg        <= ByteReg;
ByteReg         <= DByteReg + BigMem[31];
WordReg[12:0]   <= BigMem[12:0][0];
```

These snippets demonstrate variable declarations and assignment in Verilog syntax.","
reg[63:0] WordReg;
reg[7:0]  ByteReg;
reg[15:0] DByteReg;
reg[31:0] BigMem[255:0];
reg[3:0]  LilMem[255:0];
...
BigMem[31]      <= WordReg;
WordReg         <= BigMem;
LilMem[127:126] <= ByteReg;
LilMem          <= ByteReg[3:0];
DByteReg        <= ByteReg;
ByteReg         <= DByteReg + BigMem[31];
WordReg[12:0]   <= BigMem[12:0][0];
","Educational material on designing single-port RAM with bidirectional I/O in Verilog, including lab steps and code assignments.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p178.jpg,True,"```verilog
bufif1 (supply1, supply0) inst_name( , , );
bufif1 (strong1, strong0) inst_name( , , );
bufif1 (pull1, pull0) inst_name( , , );
bufif1 (weak1, weak0) inst_name( , , );

wire[3:0] xChoice; // Just to rename xReg.
...
assign Xin = 1'b0;
assign Yin = 1'b1;
...
assign xChoice = xReg;
//
bufif1 (supply1, supply0) SupplyBufX(SupplyOutX, Xin, xChoice[0]);
bufif1 (strong1, strong0) StrongBufX(StrongOutX, Xin, xChoice[1]);
... (2 more X and 4 more Y)

...
assign Xywire = SupplyOutX;
assign Xywire = StrongOutX;
... (6 more) ...
```","
bufif1 (supply1, supply0) inst_name( , , );
bufif1 (strong1, strong0) inst_name( , , );
bufif1 (pull1, pull0) inst_name( , , );
bufif1 (weak1, weak0) inst_name( , , );

wire[3:0] xChoice; // Just to rename xReg.
...
assign Xin = 1'b0;
assign Yin = 1'b1;
...
assign xChoice = xReg;
//
bufif1 (supply1, supply0) SupplyBufX(SupplyOutX, Xin, xChoice[0]);
bufif1 (strong1, strong0) StrongBufX(StrongOutX, Xin, xChoice[1]);
... (2 more X and 4 more Y)

...
assign Xywire = SupplyOutX;
assign Xywire = StrongOutX;
... (6 more) ...
","Caption: ""Verilog buffer instantiation and signal assignment for examining contention in VLSI design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p193.jpg,True,"```verilog
if (CountOK==3)
  ...
else begin // If not a down-count, start all over:
  i = i + i + Jump*i - 1;
  #1 j = 0;
  #1 Nkeeper = 'b0;
  ...
end
```","
if (CountOK==3)
  ...
else begin // If not a down-count, start all over:
  i = i + i + Jump*i - 1;
  #1 j = 0;
  #1 Nkeeper = 'b0;
  ...
end
","Caption: ""Excerpt from a digital VLSI design textbook discussing the challenges of synthesizing behavioral Verilog code, specifically concerning the use of nonblocking assignments and delay statements.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p343.jpg,True,"There is Verilog code in the image. Here it is:

```verilog
sequence s_tchK9a;
    @(posedge clk)
    (!irdyn && !trdyn);
endsequence

sequence s_tchK9b;
    @(posedge clk)
    (!irdym && !stopn);
endsequence

sequence s_tchK9_fast;
    @(posedge clk)
    $fell(framen) ##1 $fell(devseln);
endsequence

property p_tchK9_fast;
    @(posedge clk)
    s_tchK9_fast |-> 
    (!framen && !devseln) throughout
    (##[1:15] (s_tchK9a.ended || s_tchK9b.ended));
endproperty

a_tchK9_fast: assert property(p_tchK9_fast);
c_tchK9_fast: cover property(p_tchK9_fast);
```

The code defines sequences and a property for checking temporal relationships in a hardware verification context using SystemVerilog's Assertion (SVA) feature.","
sequence s_tchK9a;
    @(posedge clk)
    (!irdyn && !trdyn);
endsequence

sequence s_tchK9b;
    @(posedge clk)
    (!irdym && !stopn);
endsequence

sequence s_tchK9_fast;
    @(posedge clk)
    $fell(framen) ##1 $fell(devseln);
endsequence

property p_tchK9_fast;
    @(posedge clk)
    s_tchK9_fast |-> 
    (!framen && !devseln) throughout
    (##[1:15] (s_tchK9a.ended || s_tchK9b.ended));
endproperty

a_tchK9_fast: assert property(p_tchK9_fast);
c_tchK9_fast: cover property(p_tchK9_fast);
","""Verilog code example demonstrating sequences and property for assertion-based verification in system design""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p52.jpg,True,"There is no Verilog code written as plain text in the image; however, a VHDL code snippet is present. Here it is:

```vhdl
assert condition
report message
severity level
```

Please note that the context discusses concepts related to assertions in Verilog and VHDL, referencing figures that show assertion windows, but the code provided is in VHDL, not Verilog.","sert condition
report message
severity level
","""Examples of Invariant and Liveness Assertions in Verilog Timing Diagrams""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p721.jpg,True,"The image contains information related to the IEEE 1364-1995 VPI (Verilog Procedural Interface) Routine Library. It includes two function prototypes and typedef struct definitions in C programming language for interfacing with Verilog simulation. Here is the code from the image:

```c
void vpi_put_delays(object, delay)
vpiHandle object;    /* handle for an object */
p_vpi_delay delay;  /* pointer to an application-allocated s_vpi_delay structure containing delay information. */

Deposits delays or pulse control values stored in an s_vpi_delay structure onto an object.

typedef struct t_vpi_delay {
    struct t_vpi_time *da;   /* ptr to user allocated array of delay values */
    int no_of_delays;        /* number of delays */
    int time_type;           /* vpiScaledRealTime, vpiSimTime, or vpiSuppressTime */
    int mtm_flag;            /* true if using min:typ:max delay value sets */
    int append_flag;         /* true to append delays, false to replace delays */
    int pulsere_flag;        /* true to set pulsere values */
} s_vpi_delay, *p_vpi_delay;

typedef struct t_vpi_time {
    int type;                /* vpiScaledRealTime, vpiSimTime, vpiSuppressTime */
    unsigned int high;       /* when using vpiSimTime */
    unsigned int low;        /* when using vpiSimTime */
    double real;             /* when using vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;

vpiHandle vpi_put_value(object, value, time, flag)
vpiHandle object;    /* handle for an object */
p_vpi_value value;  /* pointer to an application-allocated s_vpi_value structure containing value information. */
p_vpi_time time;    /* pointer to an application-allocated s_vpi_time structure containing the propagation delay information. */
int flag;           /* constant representing the delay mode. */

Deposits logic values stored in an s_vpi_value structure onto an object. The deposit is scheduled after a simulation time stored in an s_vpi_value structure, using event scheduling indicated by flag:

• A flag of vpiNoDelay, vpiInertialDelay, vpiTransportDelay or vpiPureTransportDelay is used to deposit values onto registers, memory words, system functions and sequential UDPs.

• A flag of vpiForceFlag is used to force values onto nets registers, memory words, system functions and sequential UDPs.

• A flag of vpiReleaseFlag is used to release forced values.
```

The code snippets are part of a documentation page describing how to interact with Verilog simulations using the VPI interface.","vpi_put_delays(object, delay)
vpiHandle object;    /* handle for an object */
p_vpi_delay delay;  /* pointer to an application-allocated s_vpi_delay structure containing delay information. */

Deposits delays or pulse control values stored in an s_vpi_delay structure onto an object.

typedef struct t_vpi_delay {
    struct t_vpi_time *da;   /* ptr to user allocated array of delay values */
    int no_of_delays;        /* number of delays */
    int time_type;           /* vpiScaledRealTime, vpiSimTime, or vpiSuppressTime */
    int mtm_flag;            /* true if using min:typ:max delay value sets */
    int append_flag;         /* true to append delays, false to replace delays */
    int pulsere_flag;        /* true to set pulsere values */
} s_vpi_delay, *p_vpi_delay;

typedef struct t_vpi_time {
    int type;                /* vpiScaledRealTime, vpiSimTime, vpiSuppressTime */
    unsigned int high;       /* when using vpiSimTime */
    unsigned int low;        /* when using vpiSimTime */
    double real;             /* when using vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;

vpiHandle vpi_put_value(object, value, time, flag)
vpiHandle object;    /* handle for an object */
p_vpi_value value;  /* pointer to an application-allocated s_vpi_value structure containing value information. */
p_vpi_time time;    /* pointer to an application-allocated s_vpi_time structure containing the propagation delay information. */
int flag;           /* constant representing the delay mode. */

Deposits logic values stored in an s_vpi_value structure onto an object. The deposit is scheduled after a simulation time stored in an s_vpi_value structure, using event scheduling indicated by flag:

• A flag of vpiNoDelay, vpiInertialDelay, vpiTransportDelay or vpiPureTransportDelay is used to deposit values onto registers, memory words, system functions and sequential UDPs.

• A flag of vpiForceFlag is used to force values onto nets registers, memory words, system functions and sequential UDPs.

• A flag of vpiReleaseFlag is used to release forced values.
","""Documentation excerpt for IEEE 1364-1995 VPI Routine Library functions vpi_put_delays and vpi_put_value related to delays and values handling in Verilog simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p735.jpg,True,"The image contains text and code related to the Verilog Hardware Description Language (HDL) and is part of ""APPENDIX C: The IEEE 1364-1995 TF Routine Library"". It includes declarations of functions and structures that are part of Verilog's PLI (Programming Language Interface), specifically TF (Task and Function) routines which are used to interact with Verilog simulations from C code. Below is the code present in the image:

```c
void tf_propagatep(n)
void itf_propagatep(n, tfinst)
int     n                  index number of a system task/function argument.
char    *tfinst            pointer to an instance of a system task/function.

Deposits a value onto argument n of the calling or specific instance of a system task/function, and propagates the value to any continuous assignments that read the argument’s value. The value to be deposited is stored in a s_tfexprinfo structure. The tf_exprinfo() routine must have been previously called to allocate memory for the structure.

typedef struct t_tfexprinfo {
    short   expr_type;      /* tf_nullparam, tf_string, tf_readonly,
                               tf_readonlyreal, tf_readwrite, tf_readwritereal,
                               tf_rwbitselect, tf_rwpartselect, tf_rwmemselect */
    short   padding;
    struct  t_vecval *expr_value_p;
    double  real_value;
    char    *expr_string;
    int     expr_ngroups;
    int     expr_vec_size;
    int     expr_sign;
    int     expr_lhs_select;
    int     expr_rhs_select;
} s_tfexprinfo, *p_tfexprinfo;

typedef struct t_vecval {
    int avalbits;            /* aval/bval encoding: 0/0 == 0, */
    int bvalbits;            /* 1/0 == 1, 0/1 == z, 1/1 == x */
} s_vecval, *p_vecval;

void tf_putlongp(n, lowvalue, highvalue)
void itf_putlongp(n, lowvalue, highvalue, tfinst)
int     n                  index number of a system task/function argument, or 0.
int     lowvalue           lower (right-most) 32-bits of a 64-bit integer.
int     highvalue          upper (left-most) 32-bits of a 64-bit integer.
char    *tfinst            pointer to an instance of a system task/function.

Deposits a 64-bit integer value onto argument n of the calling or specific instance of a system task/function. If n is 0, then the value is deposited as the return of a system function.
```

These pieces of text explain the interface and usage of certain routines and types important for interacting with Verilog simulations.","tf_propagatep(n)
void itf_propagatep(n, tfinst)
int     n                  index number of a system task/function argument.
char    *tfinst            pointer to an instance of a system task/function.

Deposits a value onto argument n of the calling or specific instance of a system task/function, and propagates the value to any continuous assignments that read the argument’s value. The value to be deposited is stored in a s_tfexprinfo structure. The tf_exprinfo() routine must have been previously called to allocate memory for the structure.

typedef struct t_tfexprinfo {
    short   expr_type;      /* tf_nullparam, tf_string, tf_readonly,
                               tf_readonlyreal, tf_readwrite, tf_readwritereal,
                               tf_rwbitselect, tf_rwpartselect, tf_rwmemselect */
    short   padding;
    struct  t_vecval *expr_value_p;
    double  real_value;
    char    *expr_string;
    int     expr_ngroups;
    int     expr_vec_size;
    int     expr_sign;
    int     expr_lhs_select;
    int     expr_rhs_select;
} s_tfexprinfo, *p_tfexprinfo;

typedef struct t_vecval {
    int avalbits;            /* aval/bval encoding: 0/0 == 0, */
    int bvalbits;            /* 1/0 == 1, 0/1 == z, 1/1 == x */
} s_vecval, *p_vecval;

void tf_putlongp(n, lowvalue, highvalue)
void itf_putlongp(n, lowvalue, highvalue, tfinst)
int     n                  index number of a system task/function argument, or 0.
int     lowvalue           lower (right-most) 32-bits of a 64-bit integer.
int     highvalue          upper (left-most) 32-bits of a 64-bit integer.
char    *tfinst            pointer to an instance of a system task/function.

Deposits a 64-bit integer value onto argument n of the calling or specific instance of a system task/function. If n is 0, then the value is deposited as the return of a system function.
","This image shows a section from the IEEE 1364-1995 Verilog TF (Task and Function) Routine Library documentation, detailing the usage of the `tf_propagatep` and `tf_putlongp` functions along with the structure definitions for `t_tfexprinfo` and `t_vecval`.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p289.jpg,True,"The image contains a segment of code pertaining to Property Specification Language (PSL) used in the context of formal verification for hardware designs like Verilog and VHDL. Here is the code extracted from the image:

```verilog
default clock = (posedge clk);

property PendingImmediatelyAfter =
  always { (rose(enable)) } |-> {transfer [-4] ; rose(pending)};
assert PendingImmediatelyAfter;
```

In this PSL code snippet, a property named `PendingImmediatelyAfter` is declared, which specifies behavior to be checked in relation to the rising edge of signal `enable` and the occurrence of signal `pending` after the fourth `transfer`. An assertion is then made to ensure that this property is adhered to in the design.","
default clock = (posedge clk);

property PendingImmediatelyAfter =
  always { (rose(enable)) } |-> {transfer [-4] ; rose(pending)};
assert PendingImmediatelyAfter;
","Caption: ""Exploring the interpretations of 'after' in PSL (Property Specification Language) with examples of Verilog assert statements for temporal logic specification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p218.jpg,True,"The image contains two snippets of Verilog code. Below are the verbatim transcriptions:

```verilog
property checkDelay;
    int lv;
    (readReq, lv=dataDelay) |=> ##[0:lv] readData;
endproperty
```

```verilog
property pr1 (int dSize, csig, enb='1'b1, logic pa, logic pb);
    logic [dSize:0] Ldata;
    @(csig, Ldata=data) enb |-> pa ##2 pb;
endproperty

reqGnt: assert property ( pr1( 'd31, posedge clk, cStart, req, gnt) );
```","
property checkDelay;
    int lv;
    (readReq, lv=dataDelay) |=> ##[0:lv] readData;
endproperty


property pr1 (int dSize, csig, enb='1'b1, logic pa, logic pb);
    logic [dSize:0] Ldata;
    @(csig, Ldata=data) enb |-> pa ##2 pb;
endproperty

reqGnt: assert property ( pr1( 'd31, posedge clk, cStart, req, gnt) );
","Caption: Examples of illegal Verilog code demonstrating that local variables cannot be used in delay ranges and as sizes in bus declarations within properties, as they need to be known at elaboration time.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p279.jpg,True,"The image contains a snippet of code in the Verilog hardware description language. Here is the code from the image:

```verilog
assign c_tab_reset_ctr = r_tab_reset_ctr + 5'h01;
```

This is a continuous assignment statement in Verilog used to assign the right-hand side expression to the left-hand side signal. It adds the hexadecimal value `01` to the `r_tab_reset_ctr` signal and assigns the result to `c_tab_reset_ctr`. The prefix `5'h` specifies that the value is a 5-bit hexadecimal constant.","
assign c_tab_reset_ctr = r_tab_reset_ctr + 5'h01;
","Caption: ""Quick Reference Guide to Verilog Operators""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p387.jpg,True,"The image contains a section of code written in Verilog, the Hardware Description Language. Here is the code from the image:

```verilog
module fifo (fifo_data_out,fifo_full,fifo_empty,fifo_write, fifo_read,clk,rst_,fifo_data_in);

parameter fifo_depth=8;
parameter fifo_width=8;

output logic [(fifo_width - 1):0] fifo_data_out;
output logic fifo_full, fifo_empty;
input logic fifo_write, fifo_read, clk, rst_;
input logic [(fifo_width - 1):0] fifo_data_in;

logic [(fifo_width-1):0] fifomem [0:(fifo_depth-1)];

logic [3:0] wr_ptr, rd_ptr;
logic [3:0] cnt;

always @ (posedge clk or negedge rst_)
  if (!rst_) begin
    rd_ptr <= 0;
    wr_ptr <= 0;
    cnt <= 0;
```
Please note that this code snippet is not complete, as it seems to continue beyond what is visible in the image.","
module fifo (fifo_data_out,fifo_full,fifo_empty,fifo_write, fifo_read,clk,rst_,fifo_data_in);

parameter fifo_depth=8;
parameter fifo_width=8;

output logic [(fifo_width - 1):0] fifo_data_out;
output logic fifo_full, fifo_empty;
input logic fifo_write, fifo_read, clk, rst_;
input logic [(fifo_width - 1):0] fifo_data_in;

logic [(fifo_width-1):0] fifomem [0:(fifo_depth-1)];

logic [3:0] wr_ptr, rd_ptr;
logic [3:0] cnt;

always @ (posedge clk or negedge rst_)
  if (!rst_) begin
    rd_ptr <= 0;
    wr_ptr <= 0;
    cnt <= 0;
",Page from a digital design textbook showing a lab exercise featuring Verilog Register Transfer Level (RTL) code for a First-In-First-Out (FIFO) buffer module.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p316.jpg,True,"The image contains a Verilog code example. Here is the code as written in the image:

```verilog
module counter_0_to_8 (reset_n, clk, inc, dec);
input reset_n, clk, inc, dec;
reg [3:0] count;

always @(posedge clk) begin
  if (reset_n) count = 4'b0;
  else count = count + inc - dec;
end
// OVL check for valid range
assert_always # (0, 0, 0, ""range 0-8 error"")
  valid_count (clk, reset_n, (count >= 4'b0000) && (count <= 4'b1000) );
endmodule
```

This Verilog module defines a simple counter that counts from 0 to 8, with signals to increment or decrement the count. Additionally, it includes an Open Verification Library (OVL) assertion (`assert_always`) that checks to ensure the counter `count` remains within the specified range (0 to 8).","
module counter_0_to_8 (reset_n, clk, inc, dec);
input reset_n, clk, inc, dec;
reg [3:0] count;

always @(posedge clk) begin
  if (reset_n) count = 4'b0;
  else count = count + inc - dec;
end
// OVL check for valid range
assert_always # (0, 0, 0, ""range 0-8 error"")
  valid_count (clk, reset_n, (count >= 4'b0000) && (count <= 4'b1000) );
endmodule
","""A documentation section on checking invariant properties using the assert_always statement in Verilog with example code of a counter module that checks for a legal range.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p302.jpg,True,"There is Verilog code in the image. Here it is:

```verilog
// OVL assert that the FIFO cannot overflow
assert_never no_overflow (clk, reset_n,
                          ({push,pop}==2'b10 && cnt==`DEPTH-1));

// OVL assert that the FIFO cannot underflow
assert_never no_underflow (clk, reset_n, (pop && cnt==0));
```","
// OVL assert that the FIFO cannot overflow
assert_never no_overflow (clk, reset_n,
                          ({push,pop}==2'b10 && cnt==`DEPTH-1));

// OVL assert that the FIFO cannot underflow
assert_never no_underflow (clk, reset_n, (pop && cnt==0));
","Caption: ""Example Verilog code showing the use of Open Verification Library (OVL) assertions to prevent FIFO overflow and underflow conditions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p393.jpg,True,"The image shows a part of a document with Verilog/SystemVerilog code related to SystemVerilog assertions and a FIFO (First-In-First-Out) test module. Here is the code that is visible in the image:

```systemverilog
// -----------------------------------------------------
// 7. Write a property to Warn on read from an empty fifo
//    This property will give Warning with all simulations
// -----------------------------------------------------

`ifdef check7
property read_on_empty_fifo;
    @(posedge clk) rst_ |-> ~rd_ptr==0; // DUMMY... remove this line and
                                        // replace it with correct check

endproperty
read_on_empty_fifoP: assert property (read_on_empty_fifo)
    else $display($stime,""\t\t WARNING::read_on_empty_fifo condition\n"");
`endif

endmodule

*******************************************************************************
test_fifo.sv
*******************************************************************************
module test_fifo;

wire [7:0] fifo_data_out;
wire       fifo_full, fifo_empty;
logic      fifo_write, fifo_read, clk, rst_;
logic [7:0] fifo_data_in;

parameter fifo_depth = 8, fifo_width = 8;

fifo # (fifo_depth, fifo_width) f1 (fifo_data_out,fifo_full,
    fifo_empty,fifo_write,fifo_read,clk,rst_,
    fifo_data_in);

bind fifo_property # (fifo_depth, fifo_width) fibind
    (fifo_data_out,fifo_full,fifo_empty,fifo_write,fifo_read,clk,
     rst_, fifo_data_in);

initial
begin
    clk=0;
    fiforeset;
```

Please note that the code may have been truncated due to the image frame and some comments in the code suggests that the `DUMMY` line in the property `read_on_empty_fifo` should be removed and replaced with the correct check.","erilog
// -----------------------------------------------------
// 7. Write a property to Warn on read from an empty fifo
//    This property will give Warning with all simulations
// -----------------------------------------------------

`ifdef check7
property read_on_empty_fifo;
    @(posedge clk) rst_ |-> ~rd_ptr==0; // DUMMY... remove this line and
                                        // replace it with correct check

endproperty
read_on_empty_fifoP: assert property (read_on_empty_fifo)
    else $display($stime,""\t\t WARNING::read_on_empty_fifo condition\n"");
`endif

endmodule

*******************************************************************************
test_fifo.sv
*******************************************************************************
module test_fifo;

wire [7:0] fifo_data_out;
wire       fifo_full, fifo_empty;
logic      fifo_write, fifo_read, clk, rst_;
logic [7:0] fifo_data_in;

parameter fifo_depth = 8, fifo_width = 8;

fifo # (fifo_depth, fifo_width) f1 (fifo_data_out,fifo_full,
    fifo_empty,fifo_write,fifo_read,clk,rst_,
    fifo_data_in);

bind fifo_property # (fifo_depth, fifo_width) fibind
    (fifo_data_out,fifo_full,fifo_empty,fifo_write,fifo_read,clk,
     rst_, fifo_data_in);

initial
begin
    clk=0;
    fiforeset;
",Verilog code illustrating a SystemVerilog assertion to check for reads from an empty FIFO queue and the setup for a FIFO test module.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p245.jpg,True,"The image contains two Verilog code examples. Here are the transcriptions:

Example 9-17:
```verilog
module b_gc (ck, rst, g_c);
input ck, rst;
output [1:0] r_gc;
wire [1:0] r_gc;
reg [1:0] n;
always @(r_gc)
    case (r_gc)
        2'b00 : n = 2'b01;
        2'b01 : n = 2'b11;
        2'b11 : n = 2'b10;
        2'b10 : n = 2'b00;
    endcase
dff #(2) reg_r ((.q(r_gc), .ck(ck), .d(n), .rst (rst));
endmodule // b_gc
```

Example 9-18:
```verilog
module enum_encode (c_error_vector, c_code);
input [4:0] c_error_vector;
output [2:0] c_code;
reg [2:0] c_code;
always @(c_error_vector)
begin
    casex (c_error_vector)
        5'b1???? : c_code = 3'h1;
        5'b01??? : c_code = 3'h2;
        5'b001?? : c_code = 3'h3;
        5'b0001? : c_code = 3'h4;
        5'b00001 : c_code = 3'h5;
        5'b00000 : c_code = 3'h0;
    endcase
end
endmodule // enum_encode
```","
module b_gc (ck, rst, g_c);
input ck, rst;
output [1:0] r_gc;
wire [1:0] r_gc;
reg [1:0] n;
always @(r_gc)
    case (r_gc)
        2'b00 : n = 2'b01;
        2'b01 : n = 2'b11;
        2'b11 : n = 2'b10;
        2'b10 : n = 2'b00;
    endcase
dff #(2) reg_r ((.q(r_gc), .ck(ck), .d(n), .rst (rst));
endmodule // b_gc


module enum_encode (c_error_vector, c_code);
input [4:0] c_error_vector;
output [2:0] c_code;
reg [2:0] c_code;
always @(c_error_vector)
begin
    casex (c_error_vector)
        5'b1???? : c_code = 3'h1;
        5'b01??? : c_code = 3'h2;
        5'b001?? : c_code = 3'h3;
        5'b0001? : c_code = 3'h4;
        5'b00001 : c_code = 3'h5;
        5'b00000 : c_code = 3'h0;
    endcase
end
endmodule // enum_encode
",Example Verilog modules for gray code conversion and priority encoding.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p149.jpg,True,"```c
for(i = 0; i < n; i++) x[i] = 0;
for(i = 0; i < n; i++) assert(x[i] == 0);
```

The image contains a fragment of C code as shown above."," = 0; i < n; i++) x[i] = 0;
for(i = 0; i < n; i++) assert(x[i] == 0);
",,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p251.jpg,True,"```verilog
module log_xz_test(clk_I,c_stimulus,c_codex,c_codez);
    input clk_I;
    input [4:0] c_stimulus;
    input [2:0] c_codex,c_codez;
    always @(posedge clk_I) begin
        $display ("" %t %b %h %h"", $time, c_stimulus,c_codex,c_codez);
    end
endmodule // log_xz_test
```","
module log_xz_test(clk_I,c_stimulus,c_codex,c_codez);
    input clk_I;
    input [4:0] c_stimulus;
    input [2:0] c_codex,c_codez;
    always @(posedge clk_I) begin
        $display ("" %t %b %h %h"", $time, c_stimulus,c_codex,c_codez);
    end
endmodule // log_xz_test
","Caption: ""Example of a Verilog test module with an always block for signal logging and conditional checking.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p422.jpg,True,"```
property pr1;
  @(posedge clk) req |-> ##2 gnt;
endproperty

reqGnt: assert property (pr1) $display($stime,,""\t %m PASS"");
        else $display($stime,""\t %m FAIL"");
```","ty pr1;
  @(posedge clk) req |-> ##2 gnt;
endproperty

reqGnt: assert property (pr1) $display($stime,,""\t %m PASS"");
        else $display($stime,""\t %m FAIL"");
","""Verilog Assertion Example and Explanation of Implication Result Outcomes""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p114.jpg,True,"The image shows text, which includes Verilog code examples. Here is the code from the image:

Sample 3.3 Case-inside statement with ranges
```verilog
case (graduation_year) inside // <<< Note ""inside"" keyword
    [1950:1959]: $display(""Do you like bobby sox?"");
    [1960:1969]: $display(""Did you go to Woodstock?"");
    [1970:1979]: $display(""Did you dance to disco?"");
endcase
```

Sample 3.4 Void function for debug
```verilog
function void print_state();
    $display(""%0t: state = %s"", $time, cur_state.name());
endfunction
```

Sample 3.5 Ignoring a function's return value
```c
void'($fscanf(file, ""%d"", i));
```","
case (graduation_year) inside // <<< Note ""inside"" keyword
    [1950:1959]: $display(""Do you like bobby sox?"");
    [1960:1969]: $display(""Did you go to Woodstock?"");
    [1970:1979]: $display(""Did you dance to disco?"");
endcase


function void print_state();
    $display(""%0t: state = %s"", $time, cur_state.name());
endfunction

($fscanf(file, ""%d"", i));
","""Excerpt from a technical document discussing the differences between tasks, functions, and void functions in SystemVerilog, illustrating usage with code samples.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p118.jpg,True,"The image contains Verilog code in a textbook or document. Here is the code extracted from the image:

```verilog
a1: assert property (@(posedge clk) sig inside {0, 1, 2, 4});

a2: assert property (@(posedge clk)
    always sig inside {0, 1, 2, 4});
```

The document is explaining how to efficiently write assertions in Verilog, noting that the implicit `always` operator is typically used and suggesting not to explicitly specify it to avoid degradation of simulation performance.","
a1: assert property (@(posedge clk) sig inside {0, 1, 2, 4});

a2: assert property (@(posedge clk)
    always sig inside {0, 1, 2, 4});
","Caption: ""Understanding the S_eventually Property and Efficiency Tips in Verilog Assertions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p237.jpg,True,"There is Verilog code in the image. Here it is:

```verilog
property p_wr_burstterminate;
    @(posedge clk)
      (s_burstterminate) |->
        $past((`s_burst_write || `s_write), 1);
endproperty

c_wr_burstterminate:
    cover property (p_wr_burstterminate);
```

This snippet defines a property `p_wr_burstterminate` for checking a burst terminate operation in synchronous design and uses the SystemVerilog `cover` statement in `c_wr_burstterminate` to track if the property has occurred during simulation.","
property p_wr_burstterminate;
    @(posedge clk)
      (s_burstterminate) |->
        $past((`s_burst_write || `s_write), 1);
endproperty

c_wr_burstterminate:
    cover property (p_wr_burstterminate);
","""Verilog SystemVerilog Assertions (SVA) for memory write operations with burst terminate conditions and coverage checks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p350.jpg,True,"The image contains a piece of Verilog code. Here it is:

```verilog
module abc;
    logic clk, x, y, j;
    logic [7:0] r1;

    let lxor (p, q='1'b0) = p^q;
    
    always @(posedge clk) begin
        for (i = 0; i <= 256; i++) begin
            r1 = lxor(i ); //After expanding the 'let' instance,
            // this will be r1 = i ^ 1'b0;
        end
    end
endmodule
``` 

The code example demonstrates the usage of the `let` construct in Verilog for parameterized expressions, illustrating how it can function like a parameterized macro that gets expanded inline.","
module abc;
    logic clk, x, y, j;
    logic [7:0] r1;

    let lxor (p, q='1'b0) = p^q;
    
    always @(posedge clk) begin
        for (i = 0; i <= 256; i++) begin
            r1 = lxor(i ); //After expanding the 'let' instance,
            // this will be r1 = i ^ 1'b0;
        end
    end
endmodule
","""Exploration of parameterized 'let' declarations in Verilog with example code and explanation of its use within a module.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p223.jpg,True,"The image contains Verilog code which consists of macro definitions for different SDRAM command assertions. Here is the code:

```verilog
`define s_precharge
    (!ras_n && !sel_n[0] && !we_n && cas_n)

`define s_read
    (ras_n && !sel_n[0] && we_n && !cas_n &&
     (burst == 3'b000))

`define s_burst_read
    (ras_n && !sel_n[0] && we_n && !cas_n &&
     (burst != 3'b000))

`define s_write
    (ras_n && !sel_n[0] && !we_n && cas_n)

`define s_autorefresh
    (!ras_n && cas_n && !sel_n[0] && we_n)

`define s_loadmoderegister
    (!ras_n && cas_n && !sel_n[0] && !we_n)

`define s_active
    (!ras_n && !sel_n[0] && cas_n && we_n)

`define s_write
    (!cas_n && !we_n && !sel_n[0] && ras_n &&
     (burst == 3'b000))

`define s_burst_write
    (!cas_n && !we_n && !sel_n[0] && ras_n &&
     (burst != 3'b000))
```

These macro definitions are used to abstract the SDRAM command signals, making them easier to read and reuse in SVA (SystemVerilog Assertions) checkers.","
`define s_precharge
    (!ras_n && !sel_n[0] && !we_n && cas_n)

`define s_read
    (ras_n && !sel_n[0] && we_n && !cas_n &&
     (burst == 3'b000))

`define s_burst_read
    (ras_n && !sel_n[0] && we_n && !cas_n &&
     (burst != 3'b000))

`define s_write
    (ras_n && !sel_n[0] && !we_n && cas_n)

`define s_autorefresh
    (!ras_n && cas_n && !sel_n[0] && we_n)

`define s_loadmoderegister
    (!ras_n && cas_n && !sel_n[0] && !we_n)

`define s_active
    (!ras_n && !sel_n[0] && cas_n && we_n)

`define s_write
    (!cas_n && !we_n && !sel_n[0] && ras_n &&
     (burst == 3'b000))

`define s_burst_write
    (!cas_n && !we_n && !sel_n[0] && ras_n &&
     (burst != 3'b000))
",Verilog macro definitions for various SDRAM command signals.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p92.jpg,True,"The image includes two examples of code declarations using PSL (Property Specification Language) for defining properties in hardware design.

Example 3-8:
```
property mutex (boolean clk, reset, a, b) =
  always ( !(a & b) ) @(posedge clk) abort !reset_n;
```

Example 3-9:
```
property mutex (boolean clk, reset, a, b) =
  always ( !(a & b) ) @(posedge clk) abort !reset_n;

assert mutex(clk_a, master_rst_n, write_en, read_en);
```

These code examples demonstrate how to declare mutex properties for hardware signals by using PSL assertions. Example 3-8 defines the property and Example 3-9 shows the assertion of that property in use.","ty mutex (boolean clk, reset, a, b) =
  always ( !(a & b) ) @(posedge clk) abort !reset_n;

ty mutex (boolean clk, reset, a, b) =
  always ( !(a & b) ) @(posedge clk) abort !reset_n;

assert mutex(clk_a, master_rst_n, write_en, read_en);
","""Text on Assertion-Based Design illustrating PSL property declaration and assertion examples for verifying mutually exclusive conditions in hardware verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p436.jpg,True,"The image contains Verilog code and some specifications. Here is the code presented in the image:

```verilog
property check_dataphase;
    @(posedge clk) $rose(frame_) |-> ##[1:16] ($rose(irdy_)
                                           && trdy_ && devsel_ );
endproperty

`define true 1'b1;
property check_irdy;
    $fell(frame_) |-> `true[*1:16] intersect ($fell(frame_)
                                           ##[1:$] $fell(irdy_));
endproperty

sequence start_PCI_Cycle;
    $fell(irdy_) and (!devsel_) and (!trdy_abort)
endsequence

sequence dataphase_begin;
    (!irdy_) [*0:16] ##0 $fell(trdy_) ;
endsequence

property check_dataphase;
    start_PCI_Cycle |-> dataphase_begin;
endproperty

assert property (check_dataphase);
```

Please note that the code might require additional context for a complete understanding of its functionality, which typically relates to assertions in SystemVerilog used for verifying PCI protocol conformance.","
property check_dataphase;
    @(posedge clk) $rose(frame_) |-> ##[1:16] ($rose(irdy_)
                                           && trdy_ && devsel_ );
endproperty

`define true 1'b1;
property check_irdy;
    $fell(frame_) |-> `true[*1:16] intersect ($fell(frame_)
                                           ##[1:$] $fell(irdy_));
endproperty

sequence start_PCI_Cycle;
    $fell(irdy_) and (!devsel_) and (!trdy_abort)
endsequence

sequence dataphase_begin;
    (!irdy_) [*0:16] ##0 $fell(trdy_) ;
endsequence

property check_dataphase;
    start_PCI_Cycle |-> dataphase_begin;
endproperty

assert property (check_dataphase);
","""Example of SystemVerilog assertions for verifying PCI protocol timing constraints""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p100.jpg,True,"The image contains an excerpt about Verilog, and it includes a code sample. Here's the code from the image:

```verilog
initial begin
  bit [15:0] wq[$] = {16'h1234, 16'h5678};
  bit [7:0] bq[$];

  // Convert word array to byte
  bq = { >> {wq}}; // 12 34 56 78

  // Convert byte array to words
  bq = {8'h98, 8'h76, 8'h54, 8'h32};
  wq = { >> {bq}}; // 9876 5432
end
```

This code converts between word arrays and byte arrays using the streaming operator `{>>{}}` in Verilog.","
initial begin
  bit [15:0] wq[$] = {16'h1234, 16'h5678};
  bit [7:0] bq[$];

  // Convert word array to byte
  bq = { >> {wq}}; // 12 34 56 78

  // Convert byte array to words
  bq = {8'h98, 8'h76, 8'h54, 8'h32};
  wq = { >> {bq}}; // 9876 5432
end
","""Verilog HDL: Using the streaming operator to convert between word arrays and byte arrays""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p124.jpg,True,"The image contains Verilog code. Here is the text representation of the code found in the image:

```verilog
initial a1: assert property(@(posedge clk) !ready until !rst);

initial a2: assert property(@(posedge clk) !read until_with write);
``` 

These lines of code represent assertions in Verilog which check specific properties of signals relative to clock edges.","
initial a1: assert property(@(posedge clk) !ready until !rst);

initial a2: assert property(@(posedge clk) !read until_with write);
","""Understanding 'until' properties in Verilog assertions with code examples and a trace fragment table for signal values across clock ticks.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p133.jpg,True,"The image contains two blocks of Verilog code. Here is the transcription of both:

```verilog
#endif

arg_itr = vpi_iterate(vpiArgument, systf_h);
#ifdef PLIbookDebug /* if error, generate verbose debug message */
if (vpi_chk_error(&err)) {
    vpi_printf(""ERROR: PLIbook_numargs_vpi() could not obtain iterator to systf args\n"");
    vpi_printf(""File %s, Line %d: %s\n"",
               err.file, err.line, err.message);
}
#endif
else /* if error, generate brief error message */
if (systf_h == NULL)
    vpi_printf(""ERROR: PLIbook_numargs_vpi() could not obtain iterator to systf args\n"");
#endif

while (arg_h = vpi_scan(arg_itr)) {
    tfnum++;
}

return(tfnum);
}
```

```verilog
vpiHandle PLIbook_getarg_handle_vpi(int argNum)
{
    vpiHandle systf_h, arg_itr, arg_h;
    int i;
#ifdef PLIbookDebug
    s_vpi_error_info err; /* structure for error handling */
#endif

    if (argNum < 1) {
        vpi_printf(""ERROR: PLIbook_getarg_handle_vpi() argNum invalid\n"");
        return(NULL);
    }

    systf_h = vpi_handle(vpiSysTfCall, NULL);
#ifdef PLIbookDebug /* if error, generate verbose debug message */
    if (vpi_chk_error(&err)) {
        vpi_printf(""ERROR: PLIbook_getarg_handle_vpi() could not obtain handle to systf call\n"");
        vpi_printf(""File %s, Line %d: %s\n"",
                   err.file, err.line, err.message);
    }
#endif
}
```

Please note the second block of code seems incomplete, potentially due to the page being cut off.","
#endif

arg_itr = vpi_iterate(vpiArgument, systf_h);
#ifdef PLIbookDebug /* if error, generate verbose debug message */
if (vpi_chk_error(&err)) {
    vpi_printf(""ERROR: PLIbook_numargs_vpi() could not obtain iterator to systf args\n"");
    vpi_printf(""File %s, Line %d: %s\n"",
               err.file, err.line, err.message);
}
#endif
else /* if error, generate brief error message */
if (systf_h == NULL)
    vpi_printf(""ERROR: PLIbook_numargs_vpi() could not obtain iterator to systf args\n"");
#endif

while (arg_h = vpi_scan(arg_itr)) {
    tfnum++;
}

return(tfnum);
}


vpiHandle PLIbook_getarg_handle_vpi(int argNum)
{
    vpiHandle systf_h, arg_itr, arg_h;
    int i;
#ifdef PLIbookDebug
    s_vpi_error_info err; /* structure for error handling */
#endif

    if (argNum < 1) {
        vpi_printf(""ERROR: PLIbook_getarg_handle_vpi() argNum invalid\n"");
        return(NULL);
    }

    systf_h = vpi_handle(vpiSysTfCall, NULL);
#ifdef PLIbookDebug /* if error, generate verbose debug message */
    if (vpi_chk_error(&err)) {
        vpi_printf(""ERROR: PLIbook_getarg_handle_vpi() could not obtain handle to systf call\n"");
        vpi_printf(""File %s, Line %d: %s\n"",
                   err.file, err.line, err.message);
    }
#endif
}
",Example code demonstrating the use of the Verilog Procedural Interface (VPI) for error handling and iterating over system task/function arguments.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p286.jpg,True,"The image contains Verilog code. Here is the extracted code:

```verilog
if (error_count <= `ASSERT_MAX_REPORT_ERROR)
`endif
$display(""%s : illegal flag parameter %0d : time %0t : %m"", msg,
         flag, $time);
if (severity_level == 0) $finish;
end
end
else if (i > 0)
i <= i-1;
if (r_check_value != test_expr) begin
   r_change <= 1'b1;
end
// go to start state on last check
if (i == 1) begin
   r_state <= CHANGE_START;
   // Check that the property is true
   if ((r_change == 1'b1) && (r_check_value == test_expr)) begin
       error_count = error_count + 1;
       `ifdef ASSERT_MAX_REPORT_ERROR
       if (error_count <=`ASSERT_MAX_REPORT_ERROR)
       `endif
           $display(""%s : severity %0d : time %0t : %m"", msg,
                    severity_level, $time);
       if (severity_level == 0) $finish;
   end
   r_check_value <= test_expr;
end
endcase
end
else begin
   r_state <= CHANGE_START;
   r_change <= 1'b0;
end
end // always
`endif
// synopsys translate_on
endmodule // assert_change
```

Please note that some compiler directives like '`ifdef', '`endif', and '`ASSERT_MAX_REPORT_ERROR' are part of the language's directive feature, used to conditionally compile portions of the code. This image appears to be showing a portion of a book or document detailing Verilog code, specifically regarding assertions or checks within a module in Verilog.","
if (error_count <= `ASSERT_MAX_REPORT_ERROR)
`endif
$display(""%s : illegal flag parameter %0d : time %0t : %m"", msg,
         flag, $time);
if (severity_level == 0) $finish;
end
end
else if (i > 0)
i <= i-1;
if (r_check_value != test_expr) begin
   r_change <= 1'b1;
end
// go to start state on last check
if (i == 1) begin
   r_state <= CHANGE_START;
   // Check that the property is true
   if ((r_change == 1'b1) && (r_check_value == test_expr)) begin
       error_count = error_count + 1;
       `ifdef ASSERT_MAX_REPORT_ERROR
       if (error_count <=`ASSERT_MAX_REPORT_ERROR)
       `endif
           $display(""%s : severity %0d : time %0t : %m"", msg,
                    severity_level, $time);
       if (severity_level == 0) $finish;
   end
   r_check_value <= test_expr;
end
endcase
end
else begin
   r_state <= CHANGE_START;
   r_change <= 1'b0;
end
end // always
`endif
// synopsys translate_on
endmodule // assert_change
","""Example of Verilog assertion code for monitoring property changes over time, from a book or documentation appendix.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p128.jpg,True,"The image contains the following Verilog code:

```verilog
timeunit 1ns;
timeprecision 1ps;
parameter real t_real = 5.5;
parameter time t_time = 5ns;

initial begin
    #t_time $display(""1 %t"", $realtime);
    #t_real $display(""1 %t"", $realtime);
    #t_time $display(""1 %t"", $realtime);
    #t_real $display(""1 %t"", $realtime);
end

initial begin
    #t_time $display(""2 %t"", $time);
    #t_real $display(""2 %t"", $time);
    #t_time $display(""2 %t"", $time);
    #t_real $display(""2 %t"", $time);
end
```

This code is a Verilog simulation example that includes time units and time precision settings, as well as parameter definitions and two initial blocks with delay-based events that display the time.","
timeunit 1ns;
timeprecision 1ps;
parameter real t_real = 5.5;
parameter time t_time = 5ns;

initial begin
    #t_time $display(""1 %t"", $realtime);
    #t_real $display(""1 %t"", $realtime);
    #t_time $display(""1 %t"", $realtime);
    #t_real $display(""1 %t"", $realtime);
end

initial begin
    #t_time $display(""2 %t"", $time);
    #t_real $display(""2 %t"", $time);
    #t_time $display(""2 %t"", $time);
    #t_real $display(""2 %t"", $time);
end
",Verilog Code Example Demonstrating Time Formatting and Delay Using $display Task,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p36.jpg,True,"The image contains both Verilog and C code. Below is the Verilog code snippet found at the top of the page:

```verilog
module test;

initial
  $hello();

endmodule
```

And here is the C code snippet, which is a `calltf` routine associated with the `$hello` system task in Verilog:

```c
#include <stdlib.h>  /* ANSI C standard library */
#include <stdio.h>   /* ANSI C standard input/output library */
#include <vpi_user.h> /* IEEE 1364 PLI VPI routine library */

int PLIbook_hello_calltf(char *user_data)
{
  vpi_printf(""\nHello World!\n\n"");
  return(0);
}
```","
module test;

initial
  $hello();

endmodule

ude <stdlib.h>  /* ANSI C standard library */
#include <stdio.h>   /* ANSI C standard input/output library */
#include <vpi_user.h> /* IEEE 1364 PLI VPI routine library */

int PLIbook_hello_calltf(char *user_data)
{
  vpi_printf(""\nHello World!\n\n"");
  return(0);
}
","Caption: ""Example of integrating C with Verilog using PLI to print 'Hello World' from a Verilog testbench.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p378.jpg,True,"The image contains the following Verilog code:

```verilog
module test_dut;
bit sys_clk, sys_req;
wire sys_gnt;

/* Instantiate 'dut' */
dut dut1 (
    .clk(sys_clk),
    .req(sys_req),
    .gnt(sys_gnt)
);
```

It appears to be part of a lab exercise related to Verilog coding. The comments in the code suggest that this is a test module for a device under test (DUT), with instantiated module 'dut1' including clock, request, and grant signals. There is a placeholder comment prompting the reader to add code to bind 'dut' with 'dut_property' which is another module. The comments also reference a Design module 'dut.v' and a Property module 'dut_property.sv', the interfaces of which are commented out below the main module code.","
module test_dut;
bit sys_clk, sys_req;
wire sys_gnt;

/* Instantiate 'dut' */
dut dut1 (
    .clk(sys_clk),
    .req(sys_req),
    .gnt(sys_gnt)
);
","Caption: ""Exercise instructions for binding a design under test ('dut') with a property module in Verilog as part of a system verification test setup.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p655.jpg,True,"```makefile
# 
# SRCS set to the list of sources that comprise your VPI application
#
SRCS = show_value_vpi.c \
       pow_vpi.c \
       pliBook_vpi_user.c

#
OBJS = $(SRCS:.c=.obj)
CFLAGS = -DMSIC -DWIN32 -I$(CDS_INST_DIR)/tools/verilog/include \
         -I$(USER_INCLUDE) -MD -O2

.c.obj:
	$(CC) $(CFLAGS) -c $<

libvpi.dll: $(OBJS)
	link -dll /out:$@ $(OBJS) $(CDS_INST_DIR)/tools/verilog/lib/verilog.lib
```","e
# 
# SRCS set to the list of sources that comprise your VPI application
#
SRCS = show_value_vpi.c \
       pow_vpi.c \
       pliBook_vpi_user.c

#
OBJS = $(SRCS:.c=.obj)
CFLAGS = -DMSIC -DWIN32 -I$(CDS_INST_DIR)/tools/verilog/include \
         -I$(USER_INCLUDE) -MD -O2

.c.obj:
	$(CC) $(CFLAGS) -c $<

libvpi.dll: $(OBJS)
	link -dll /out:$@ $(OBJS) $(CDS_INST_DIR)/tools/verilog/lib/verilog.lib
","""Instructions on linking PLI applications with Verilog simulators and a partial makefile example for compiling PLI with Cadence tools.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p641.jpg,True,"```c
typedef struct t_vpi_systf_data {
    int type;
    int subtype;
    char *tfname;
    int (*calltf)();
    int (*compiletf)();
    int (*sizetf)();
    char *user_data;
} s_vpi_systf_data, *p_vpi_systf_data;
```","ef struct t_vpi_systf_data {
    int type;
    int subtype;
    char *tfname;
    int (*calltf)();
    int (*compiletf)();
    int (*sizetf)();
    char *user_data;
} s_vpi_systf_data, *p_vpi_systf_data;
","""Verilog PLI Application Registration and s_vpi_systf_data Structure Definition""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p292.jpg,True,"The image contains Verilog code, which is a hardware description language used to model electronic systems. Here is the text from the image:

```verilog
                  msg, severity_level, $time);
if (severity_level == 0) $finish;
end
end
endcase
end
else begin
  r_state <= FRAME_START;
end
end //always
`endif
//synopsys translate_on

endmodule // asert_frame
```

Please note that due to the cropped nature of the image, some parts of the code might be missing at the beginning or end, and as such, this snippet may not represent the complete code.","
                  msg, severity_level, $time);
if (severity_level == 0) $finish;
end
end
endcase
end
else begin
  r_state <= FRAME_START;
end
end //always
`endif
//synopsys translate_on

endmodule // asert_frame
","""Excerpt from a Verilog module displaying assertions and state machine logic in a hardware description context.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p130.jpg,True,"The image contains snippets of Verilog code within a textbook or document about sequence concatenation. Here is the code present in the image:

1.
```verilog
a ##1 b
```

2.
```verilog
req ##1 rtry ##1 ack.
```

3.
```verilog
req ##1 1 ##1 ack.
```","
a ##1 b


req ##1 rtry ##1 ack.


req ##1 1 ##1 ack.
","""Explanation of sequence concatenation in Verilog with examples of Boolean expressions and timing diagrams.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p127.jpg,True,"```c
vpiHandle vpi_handle_multi(type, reference1, reference2)
int type
vpiHandle reference1
vpiHandle reference2

/* Example usage */
inter_mod_path_h = vpi_handle_multi(vpiInterModPath,
                                     in_port_handle,
                                     out_port_handle);

if (inter_mod_path_h != NULL)
    /* inter connection path not found -- process an error */
else
    /* read or modify the inter-connect delay values */
```
The image contains a snippet of code in the context of obtaining inter-module path object handles in Verilog, using the `vpi_handle_multi` function.","ndle vpi_handle_multi(type, reference1, reference2)
int type
vpiHandle reference1
vpiHandle reference2

/* Example usage */
inter_mod_path_h = vpi_handle_multi(vpiInterModPath,
                                     in_port_handle,
                                     out_port_handle);

if (inter_mod_path_h != NULL)
    /* inter connection path not found -- process an error */
else
    /* read or modify the inter-connect delay values */
","""Excerpt from a technical document outlining the use of the `vpi_handle_multi` function in the Verilog Procedural Interface (VPI) for obtaining handles to inter-module path objects.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p114.jpg,True,"The image contains examples of Verilog code. Here is the code as seen in the image:

**Example 3-46**
```verilog
!interrupt throughout (req ##[2:4] ack ##[1:2] gnt)
```

**Example 3-47**
```verilog
// pipeline register of depth 16
sequence pipe_operation;
    int x;
    write_en, (x = data_in) |-> ##16 (data_out == x) ;
endsequence
```

**Syntax 3-5 SystemVerilog implication operators**
```verilog
property_expr ::= sequence_expr |-> property_expr
               | sequence_expr |=> property_expr
```

These segments display uses of SystemVerilog sequence expressions and implications.","
!interrupt throughout (req ##[2:4] ack ##[1:2] gnt)


// pipeline register of depth 16
sequence pipe_operation;
    int x;
    write_en, (x = data_in) |-> ##16 (data_out == x) ;
endsequence


property_expr ::= sequence_expr |-> property_expr
               | sequence_expr |=> property_expr
","""Excerpts on SystemVerilog sequences and implication operators from a book on assertion-based design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p540.jpg,True,"The image contains Verilog code inside a textbook page. Here's the code text presented in the image:

```verilog
module memMod
(input logic req, logic clk, logic start,
 logic[1:0] mode, logic[7:0] addr,
 output bit gnt, bit rdy,
 inout wire[7:0] data
);
 logic avail;
 ...
endmodule
#
module cpuMod
(input logic clk, logic gnt, logic rdy,
 output logic req, logic start, logic[7:0] addr,
 logic[1:0] mode
 inout wire[7:0] data
);
 ...
endmodule
#
module top;
 logic req, gnt, start, rdy;
 logic clk = 0;
 logic[1:0] mode;
 logic[7:0] addr;
 wire[7:0] data;
 memMod mem (req, clk, start, mode, addr, data, gnt, rdy);
 cpuMod cpu (clk, gnt, rdy, data, req, start, addr, mode);
endmodule
```

Please note that there are comments (`...`) to indicate where additional code or logic would be included, but that code is not provided in the text fragment shown in the image.","
module memMod
(input logic req, logic clk, logic start,
 logic[1:0] mode, logic[7:0] addr,
 output bit gnt, bit rdy,
 inout wire[7:0] data
);
 logic avail;
 ...
endmodule
#
module cpuMod
(input logic clk, logic gnt, logic rdy,
 output logic req, logic start, logic[7:0] addr,
 logic[1:0] mode
 inout wire[7:0] data
);
 ...
endmodule
#
module top;
 logic req, gnt, start, rdy;
 logic clk = 0;
 logic[1:0] mode;
 logic[7:0] addr;
 wire[7:0] data;
 memMod mem (req, clk, start, mode, addr, data, gnt, rdy);
 cpuMod cpu (clk, gnt, rdy, data, req, start, addr, mode);
endmodule
","Caption: Excerpt from a textbook discussing the use of interfaces in Verilog to simplify repetitive port declarations in module headers, with an example of generic module design.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p185.jpg,True,"Here is the Verilog code from the image:

1.
```verilog
sequence cde;
  c ##1 d ##1 e;
endsequence

property nots;
  @(posedge clk) a |-> (not(cde));
endproperty

baseP: assert property (nots) else
  gotoFail;
coverP: cover property (nots)
  gotoPass;
```

2.
```verilog
property notab2cd;
  not (a ##1 b |-> c ##1 d);
endproperty
```

3.
```verilog
property notab2cd;
  (a ##1 b) |-> not (c ##1 d);
endproperty
```

The code snippets above define sequences, properties, and utilize the `not` operator within SystemVerilog assertions, which is used for functional verification in hardware design.","
sequence cde;
  c ##1 d ##1 e;
endsequence

property nots;
  @(posedge clk) a |-> (not(cde));
endproperty

baseP: assert property (nots) else
  gotoFail;
coverP: cover property (nots)
  gotoPass;


property notab2cd;
  not (a ##1 b |-> c ##1 d);
endproperty


property notab2cd;
  (a ##1 b) |-> not (c ##1 d);
endproperty
","""Exploring the usage of the 'not' operator in Verilog for property specification and assertion.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p226.jpg,True,"The image contains code examples in Verilog, which are as follows:

```verilog
#(delay) variable1 = value; // 1. regular blocking.
#(delay) variable2 <= value; // 2. regular nonblocking.
variable3 = #(delay) value; // 3. intraassignment blocking.
variable4 <= #(delay) value; // 4. intraassignment nonblocking.
#(delay) variable5 = #(delay) value; // 5. both, blocking.
#(delay) variable6 <= #(delay) value; // 6. both, nonblocking.
```

These examples illustrate different ways of using delays in procedural assignments in Verilog.","
#(delay) variable1 = value; // 1. regular blocking.
#(delay) variable2 <= value; // 2. regular nonblocking.
variable3 = #(delay) value; // 3. intraassignment blocking.
variable4 <= #(delay) value; // 4. intraassignment nonblocking.
#(delay) variable5 = #(delay) value; // 5. both, blocking.
#(delay) variable6 <= #(delay) value; // 6. both, nonblocking.
","""Overview of delay statements in Verilog procedural assignments and discussion on synthesis considerations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p130.jpg,True,"The image contains text and code examples related to the use of pre-increment and post-increment operators in programming. The code from the image is as follows:

```verilog
sum = i++;
sum = ++i;
```

The image further includes code examples within for loops:

```verilog
for (int i=0; i<255; ++i) ... ;
for (int i=0; i<255; i++) ... ;
```

And in the context of variable assignments:

```verilog
i = 10;
j = i++; // assign i to j, then increment i; j gets 10

j = ++i; // increment i, then assign result to j; j gets 11
```

These examples illustrate the difference between pre-increment (++i) and post-increment (i++) operations.","
sum = i++;
sum = ++i;


for (int i=0; i<255; ++i) ... ;
for (int i=0; i<255; i++) ... ;


i = 10;
j = i++; // assign i to j, then increment i; j gets 10

j = ++i; // increment i, then assign result to j; j gets 11
","Explanation of pre-increment and post-increment operators in SystemVerilog, highlighting differences in their behavior with code examples.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p124.jpg,True,"```verilog
{o,u3} = u1 + u2; // First evaluate the self-determined
                  // concatenation on the left-hand side.
                  // This affects the size context of operations
                  // on the right-hand side (which are expanded
                  // to 9-bit size of the concatenation result)

u3 = u1 | lu2;   // First do unary OR of 8-bit vector u3
                 // (self-determined) then zero-extend the 1-bit
                 // unary OR result to 8 bits before doing the
                 // context-determined math operation

s3 = s1 + ls2;   // GOTCHA? First do unary OR of 4-bit vector s2
                 // (self-determined), then zero-extend s1 and the
                 // 1-bit unary OR result to 8 bits (even though s1
                 // is a signed type, the ls2 result is unsigned,
                 // and therefore the right-hand side context
                 // is unsigned)
```

Additionally, towards the bottom of the page, there is this code:

```verilog
s3 = s1 + u2;    // GOTCHA? zero extension (u2 is unsigned)

s3 = 8'(s1) + signed'(u2);    // OK, cast s1 to 8 bits wide (self-
                              // determined) cast u2 to signed and
                              // do sign extension
```","
{o,u3} = u1 + u2; // First evaluate the self-determined
                  // concatenation on the left-hand side.
                  // This affects the size context of operations
                  // on the right-hand side (which are expanded
                  // to 9-bit size of the concatenation result)

u3 = u1 | lu2;   // First do unary OR of 8-bit vector u3
                 // (self-determined) then zero-extend the 1-bit
                 // unary OR result to 8 bits before doing the
                 // context-determined math operation

s3 = s1 + ls2;   // GOTCHA? First do unary OR of 4-bit vector s2
                 // (self-determined), then zero-extend s1 and the
                 // 1-bit unary OR result to 8 bits (even though s1
                 // is a signed type, the ls2 result is unsigned,
                 // and therefore the right-hand side context
                 // is unsigned)


s3 = s1 + u2;    // GOTCHA? zero extension (u2 is unsigned)

s3 = 8'(s1) + signed'(u2);    // OK, cast s1 to 8 bits wide (self-
                              // determined) cast u2 to signed and
                              // do sign extension
","""Understanding self-determined and context-determined operations in Verilog to avoid operator gotchas related to operand expansion.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p232.jpg,True,"The image contains Verilog code. Here is the code transcribed from the image:

```verilog
`timescale 1ns/100ps
module InactiveStratum;
reg Clk, A, Z, Zin;
always@(posedge Clk)
  begin
    A = 1'b1;
    #0 A = 1'b0;
    #0 A = 1'b0;
  end
`ifdef Case1
// Case 1: Z inactive:
always@(A) #0 Z = Zin; always@(A) Zin = A;
`else
// Case 2: Zin inactive:
always@(A) Z = Zin; always@(A) #0 Zin = A;
`endif
//
initial
  begin
    #50 Clk = 1'bz;
    #50 Clk = 1'b0;
    #50 Clk = 1'b1;
    #50 $finish;
  end
endmodule
```

Keep in mind that preprocessor directives like `ifdef` and `endif` are conditional compilation directives, used to include or exclude parts of the code based on the defined conditions. In this case, the code would compile differently depending on whether `Case1` is defined or not.","
`timescale 1ns/100ps
module InactiveStratum;
reg Clk, A, Z, Zin;
always@(posedge Clk)
  begin
    A = 1'b1;
    #0 A = 1'b0;
    #0 A = 1'b0;
  end
`ifdef Case1
// Case 1: Z inactive:
always@(A) #0 Z = Zin; always@(A) Zin = A;
`else
// Case 2: Zin inactive:
always@(A) Z = Zin; always@(A) #0 Zin = A;
`endif
//
initial
  begin
    #50 Clk = 1'bz;
    #50 Clk = 1'b0;
    #50 Clk = 1'b1;
    #50 $finish;
  end
endmodule
",Exploring Conditional Compilation and Event Queue Handling in Verilog Simulation,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p191.jpg,True,"```verilog
property bgcheck;
  @(posedge clk) bgack |->
    !($isunknown(busgnt)) &&
    $onehot(busgnt);
endproperty
```","
property bgcheck;
  @(posedge clk) bgack |->
    !($isunknown(busgnt)) &&
    $onehot(busgnt);
endproperty
",Explanation and usage of Verilog $onehot and $onehot0 system functions for checking bus states.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p100.jpg,True,"The image contains examples of code related to assertion-based design in Verilog and PSL (Property Specification Language). Here's the code extracted from the image:

Example 3-27 OVL assert_cycle_sequence
```verilog
assert_cycle_sequence #(0,3) init_test (clk,1,
    {r_opcode == 'WRITE,
    r_opcode == 'WAIT,
    r_opcode == 'READ});
```

Example 3-28 PSL opcode sequence
```verilog
assert always
    ((r_opcode=='WRITE) -> next {r_opcode=='WAIT; r_opcode=='READ});
```

Example 3-29 PSL eventually operator
```verilog
assert always (req -> eventually ack);
```

Example 3-30 PSL until operator
```verilog
assert always (req -> next {!req until ack});
```

Please note that this code is intended for use in hardware design and verification environments.","
assert_cycle_sequence #(0,3) init_test (clk,1,
    {r_opcode == 'WRITE,
    r_opcode == 'WAIT,
    r_opcode == 'READ});


assert always
    ((r_opcode=='WRITE) -> next {r_opcode=='WAIT; r_opcode=='READ});


assert always (req -> eventually ack);


assert always (req -> next {!req until ack});
","""An educational excerpt on assertion-based design showcasing OVL and PSL code examples for cycle sequence and eventualities in Verilog.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p128.jpg,True,"```verilog
always @(a or b) begin
    $display(`a'b);
end
```","
always @(a or b) begin
    $display(`a'b);
end
","Caption: ""Example of a potential false firing issue in procedural assertions within a Verilog simulation time slot.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p118.jpg,True,"```verilog
logic [5:0] a = 6’b010101;  // 6-bit vector
logic [3:0] b = 4’b1111;    // 4-bit vector
logic [7:0] c;              // 8-bit vector

c = a & b;                  // results in 8-bit 00000101
```
The image contains a section of a document discussing operator gotchas in Verilog, specifically the difference between self-determined and context-determined operators. The code example provided demonstrates context-determined operator behavior.","
logic [5:0] a = 6’b010101;  // 6-bit vector
logic [3:0] b = 4’b1111;    // 4-bit vector
logic [7:0] c;              // 8-bit vector

c = a & b;                  // results in 8-bit 00000101
","A snippet explaining the difference between self-determined and context-determined operators in Verilog, with an example of a context-determined operation.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p480.jpg,True,"The image contains code snippets related to Verilog Programming Interface (PLI) and a Verilog hardware description language (HDL) example. Below is the code present in the image:

```verilog
if (tf_nump() == 0) /* no task/function arguments */
    mod_h = acc_handle_calling_mod_m;
else if (tf_typep(1) == tf_nullparam) /* null argument */
    mod_h = acc_handle_calling_mod_m;
else
    /* a task/function argument exists */
    mod_h = acc_handle_targ(1);
```

And another snippet:

```verilog
module top;
    ...
    always @(posedge clock)
    begin: local
        integer i;
        reg local_bus;
        ...
        $show_all_signals; // list signals in this scope
    end
endmodule
```

These code snippets appear in a document discussing the application of PLI in Verilog. The ACC (Access) routines like `acc_handle_calling_mod_m` and `acc_handle_targ` are used for interfacing with different parts of a Verilog model from C code. The text explains enhancement of a PLI application to work without any arguments and how to use Verilog's named statement groups.","
if (tf_nump() == 0) /* no task/function arguments */
    mod_h = acc_handle_calling_mod_m;
else if (tf_typep(1) == tf_nullparam) /* null argument */
    mod_h = acc_handle_calling_mod_m;
else
    /* a task/function argument exists */
    mod_h = acc_handle_targ(1);


module top;
    ...
    always @(posedge clock)
    begin: local
        integer i;
        reg local_bus;
        ...
        $show_all_signals; // list signals in this scope
    end
endmodule
","Caption: ""Enhancing a Verilog PLI application to handle different argument scenarios and using it to list signals within a local hierarchy scope.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p38.jpg,True,"The image contains several snippets of Verilog code. Here they are transcribed:

```verilog
module \d-flop (output logic c, \q- ,
                input  logic \d[0] ,ck, \rst- );
...
endmodule
```

Further on, the image contains another code segment:

```verilog
logic [7:0] \a ;       // 8-bit vector called \a
logic       \b[0] ;    // 1-bit signal called \a[0]

buf b1(\b[0] , \a[0] );  // GOTCHA: infers a net called \a[0]
buf b2(\b[0] |, \a [0] ); // CORRECT: bit select of vector \a
```

These pieces of code demonstrate how to utilize escaped names in Verilog and some gotchas related to hierarchical naming conventions in the syntax of Verilog design files.","
module \d-flop (output logic c, \q- ,
                input  logic \d[0] ,ck, \rst- );
...
endmodule


logic [7:0] \a ;       // 8-bit vector called \a
logic       \b[0] ;    // 1-bit signal called \a[0]

buf b1(\b[0] , \a[0] );  // GOTCHA: infers a net called \a[0]
buf b2(\b[0] |, \a [0] ); // CORRECT: bit select of vector \a
","""Verilog code snippet highlighting the proper use of escaped names in hierarchical paths to avoid compiler errors.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p470.jpg,True,"The image contains two code snippets written in Verilog and C. Here they are:

The first code snippet (Sample 12.19):
```verilog
import ""DPI-C"" function void fib(output bit [31:0] data[20]);

program automatic test;
    bit [31:0] data[20];

    initial begin
        fib(data);
        foreach (data[i]) $display(i,,data[i]);
    end
endprogram
```

The second code snippet (Sample 12.20):
```c
void fib (svLogicVecVal data[20]) {
    int i;
    data[0].aval = 1;  // Write to both aval
    data[0].bval = 0;  // and bval
    data[1].aval = 1;
    data[1].bval = 0;
    for (i=2; i<20; i++) {
        data[i].aval = data[i-1].aval + data[i-2].aval;
        data[i].bval = 0;  // Don't forget to clear bval
    }
}
```

The third code snippet (Sample 12.21):
```verilog
import ""DPI-C"" function void fib(output logic [31:0] data[20]);

program automatic test;
    logic [31:0] data[20];

    initial begin
        fib(data);
        foreach (data[i]) $display(i,,data[i]);
    end
endprogram
```

Section 12.2.5 ostensibly describes how to convert a 2-state application to 4-state but the content of that section is not shown in the image.","
import ""DPI-C"" function void fib(output bit [31:0] data[20]);

program automatic test;
    bit [31:0] data[20];

    initial begin
        fib(data);
        foreach (data[i]) $display(i,,data[i]);
    end
endprogram

fib (svLogicVecVal data[20]) {
    int i;
    data[0].aval = 1;  // Write to both aval
    data[0].bval = 0;  // and bval
    data[1].aval = 1;
    data[1].bval = 0;
    for (i=2; i<20; i++) {
        data[i].aval = data[i-1].aval + data[i-2].aval;
        data[i].bval = 0;  // Don't forget to clear bval
    }
}


import ""DPI-C"" function void fib(output logic [31:0] data[20]);

program automatic test;
    logic [31:0] data[20];

    initial begin
        fib(data);
        foreach (data[i]) $display(i,,data[i]);
    end
endprogram
","A textbook page describing the use of arrays in SystemVerilog for creating a Fibonacci sequence testbench, featuring code samples for both 2-state and 4-state arrays.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p316.jpg,True,"```verilog
class Base;
  int val;
  function new(input int val); // Has an argument
    this.val = val;
  endfunction
endclass

class Extended extends Base;
  function new(input int val);
    super.new(val); // Must be first line of new
    // Other constructor actions
  endfunction
endclass
```","
class Base;
  int val;
  function new(input int val); // Has an argument
    this.val = val;
  endfunction
endclass

class Extended extends Base;
  function new(input int val);
    super.new(val); // Must be first line of new
    // Other constructor actions
  endfunction
endclass
",Constructors in Verilog Object-Oriented Programming (OOP) with an example of inheriting a base class and using a constructor with arguments.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p302.jpg,True,"The image contains Verilog code that illustrates a producer-consumer model synchronized with a mailbox. Here is the code:

```verilog
program automatic mbx_mbx2;
mailbox #(int) mbx, rtn;

class Producer;
    task run();
        int k;
        for (int i=1; i<4; i++) begin
            $display(""Producer: before put(%0d)"", i);
            mbx.put(i);
            rtn.get(k);
            $display(""Producer: after get(%0d)"", k);
        end
    endtask
endclass : Producer

class Consumer;
    task run();
        int i;
        repeat (3) begin
            $display(""Consumer: before get"");
            mbx.get(i);
            $display(""Consumer: after get(%0d)"", i);
            rtn.put(-i);
        end
    endtask
endclass : Consumer

Producer p;
Consumer c;

initial begin
    p = new();
    c = new();
    mbx = new();
    rtn = new();

    // Run the producer and consumer in parallel
    fork
        p.run();
        c.run();
    join
end

endprogram
```

The text below the code provides additional information:
""The return message in the rtn mailbox is just a negative version of the original integer. You could use any value, but this one can be checked against the original for debugging purposes.""","
program automatic mbx_mbx2;
mailbox #(int) mbx, rtn;

class Producer;
    task run();
        int k;
        for (int i=1; i<4; i++) begin
            $display(""Producer: before put(%0d)"", i);
            mbx.put(i);
            rtn.get(k);
            $display(""Producer: after get(%0d)"", k);
        end
    endtask
endclass : Producer

class Consumer;
    task run();
        int i;
        repeat (3) begin
            $display(""Consumer: before get"");
            mbx.get(i);
            $display(""Consumer: after get(%0d)"", i);
            rtn.put(-i);
        end
    endtask
endclass : Consumer

Producer p;
Consumer c;

initial begin
    p = new();
    c = new();
    mbx = new();
    rtn = new();

    // Run the producer and consumer in parallel
    fork
        p.run();
        c.run();
    join
end

endprogram
",Verilog example for producer-consumer synchronization using mailboxes.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p319.jpg,True,"The image includes Verilog code, and here it is transcribed:

```verilog
always @(posedge clock)
  $read_test_vector(""A.dat"", data_bus);

always @(negedge clock)
  $read_test_vector(""B.dat"", data_bus);
```","
always @(posedge clock)
  $read_test_vector(""A.dat"", data_bus);

always @(negedge clock)
  $read_test_vector(""B.dat"", data_bus);
","Caption: ""Example of Verilog code demonstrating multiple instances of system tasks with different arguments within always blocks triggered by clock edges.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p152.jpg,True,"The image contains Verilog code associated with a SystemVerilog assertion property. Here's the code:

```verilog
property req_gnt;
  @(posedge clk)
    $rose(request) |-> ##1 $rose(grant) ##0 grant[*1:$] ##0 $fell(request) ##1 $fell(grant);
endproperty

tb: assert property (req_gnt) else $display($time, ""_FAIL"");
```

This property is checking for a protocol in which a 'grant' signal must be asserted one clock cycle after a 'request' signal is asserted, must stay asserted as long as the 'request' is asserted, and must de-assert one clock cycle after the 'request' signal is de-asserted. The testbench code asserts this property and displays a fail message if the property is not met.","
property req_gnt;
  @(posedge clk)
    $rose(request) |-> ##1 $rose(grant) ##0 grant[*1:$] ##0 $fell(request) ##1 $fell(grant);
endproperty

tb: assert property (req_gnt) else $display($time, ""_FAIL"");
","""Verilog simulation waveform and assert property checks demonstrating a grant signal requirement with respect to a request signal in a verification scenario.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p464.jpg,True,"The image contains C++ code. Here is the code transcribed from the image:

```cpp
class Counter7 {
public:
    Counter7();
    void counter7_signal(svBitVecVal* count,
                         const svBitVecVal* i,
                         const svBit reset,
                         const svBit load);

private:
    unsigned char cnt;
};

Counter7::Counter7() {
    cnt = 0; // Initialize counter
}

void Counter7::counter7_signal(svBitVecVal* count,
                               const svBitVecVal* i,
                               const svBit reset,
                               const svBit load) {

    if (reset) cnt = 0; // Reset
    else if (load) cnt = *i; // Load
    else          cnt++; // Count
    cnt &= 0x7F; // Mask upper bit
    *count = cnt;
}
```

This code represents a class definition for `Counter7` and its member function implementations for a 7-bit counter. It is intended to work in conjunction with SystemVerilog and C++ via the Direct Programming Interface (DPI).","ss Counter7 {
public:
    Counter7();
    void counter7_signal(svBitVecVal* count,
                         const svBitVecVal* i,
                         const svBit reset,
                         const svBit load);

private:
    unsigned char cnt;
};

Counter7::Counter7() {
    cnt = 0; // Initialize counter
}

void Counter7::counter7_signal(svBitVecVal* count,
                               const svBitVecVal* i,
                               const svBit reset,
                               const svBit load) {

    if (reset) cnt = 0; // Reset
    else if (load) cnt = *i; // Load
    else          cnt++; // Count
    cnt &= 0x7F; // Mask upper bit
    *count = cnt;
}
","""Example of a C++ class for a 7-bit counter designed to connect with a SystemVerilog testbench via the Direct Programming Interface (DPI).""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p440.jpg,True,"```verilog
parameter N = 4;
covergroup pathCg with function sample;
    bit [7:0] inIdx, outIdx, logic [7:0] sourceId, destId;
    cross inIdx, outIdx, sourceId, destId;
endgroup
pathCg pathCg_inst = new();
task samplePathInfo(
    bit [N-1:0] inIdx_lv,
    bit [7:0] outIdx,
    logic [N-1:0] outSourceId_lv, destId_lv; logic [7:0] outSourceId_lv, outDestId_lv;
    int i;
    for (i=0; i<N; i++) begin
        if(inIdx_lv[i] && (sourceId_lv[i] == outSourceId_lv))
        begin
            && (destId_lv[i] == outDestId_lv)
            pathCg_inst.sample(i, outIdx, sourceId_lv[i], destId_lv[i]);
            break;
        end
    end
endtask
property path_cover(outIdx);
    logic [N-1:0] [7:0] sourceId_lv, destId_lv;
    bit [N-1:0] inIdx_lv, logic [7:0] outSourceId_lv;
    @(posedge clkIn)
        ((startIn) && inIdx_lv == startIn,
            sourceId_lv = dataIn) ##1
            destId_lv = dataIn)
        ##0
    @(posedge clkOut)
        (startOut[outIdx], outSourceId_lv = dataOut) ##1
        (1'b1, samplePathInfo(inIdx_lv, outIdx,
            sourceId_lv, destId_lv, outSourceId_lv, dataOut));
endproperty
generate
    for (genvar i = 0; i < N; i++) begin : PORT_OUT
        cover_path: cover property(path_cover(i));
    end
endgenerate
```

The given image contains a fragment of Verilog code, which is related to coverage in the context of hardware verification. It demonstrates the usage of a covergroup and a cover property to monitor the coverage of packet paths in a system.","
parameter N = 4;
covergroup pathCg with function sample;
    bit [7:0] inIdx, outIdx, logic [7:0] sourceId, destId;
    cross inIdx, outIdx, sourceId, destId;
endgroup
pathCg pathCg_inst = new();
task samplePathInfo(
    bit [N-1:0] inIdx_lv,
    bit [7:0] outIdx,
    logic [N-1:0] outSourceId_lv, destId_lv; logic [7:0] outSourceId_lv, outDestId_lv;
    int i;
    for (i=0; i<N; i++) begin
        if(inIdx_lv[i] && (sourceId_lv[i] == outSourceId_lv))
        begin
            && (destId_lv[i] == outDestId_lv)
            pathCg_inst.sample(i, outIdx, sourceId_lv[i], destId_lv[i]);
            break;
        end
    end
endtask
property path_cover(outIdx);
    logic [N-1:0] [7:0] sourceId_lv, destId_lv;
    bit [N-1:0] inIdx_lv, logic [7:0] outSourceId_lv;
    @(posedge clkIn)
        ((startIn) && inIdx_lv == startIn,
            sourceId_lv = dataIn) ##1
            destId_lv = dataIn)
        ##0
    @(posedge clkOut)
        (startOut[outIdx], outSourceId_lv = dataOut) ##1
        (1'b1, samplePathInfo(inIdx_lv, outIdx,
            sourceId_lv, destId_lv, outSourceId_lv, dataOut));
endproperty
generate
    for (genvar i = 0; i < N; i++) begin : PORT_OUT
        cover_path: cover property(path_cover(i));
    end
endgenerate
",Example of Verilog code showing the use of a covergroup and a cover property for coverage of packet paths.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p331.jpg,True,"```c
typedef struct PLIbook_my_data {
    FILE *file_p;              /* pointer to a file */
    char *tfinst_p;            /* a character pointer */
    int temp1, temp2;          /* other integer data */
} PLIbook_my_data_s, *PLIbook_my_data_p;

void my_misc(int user_data, int reason)
{
    PLIbook_my_data_p data_p;

    switch(reason) {
        case REASON_ENDOFCOMPILE: /* miscf called just before time 0 */
            data_p = (PLIbook_my_data_p)malloc(sizeof(PLIbook_my_data_s));
            data_p->file_p = fopen(tf_getcstring(1), ""w"");
            data_p->tfinst_p = tf_getinstance();
            tf_setworkarea((char *)data_p); /* store pointer to data */
            break;
        ...
    }
}
```
This is a C code snippet from a book related to using the Verilog Programming Language Interface (PLI). The snippet demonstrates how to store multiple values in the TF work area by using a structure to hold a file pointer, a character pointer, and two integers.","ef struct PLIbook_my_data {
    FILE *file_p;              /* pointer to a file */
    char *tfinst_p;            /* a character pointer */
    int temp1, temp2;          /* other integer data */
} PLIbook_my_data_s, *PLIbook_my_data_p;

void my_misc(int user_data, int reason)
{
    PLIbook_my_data_p data_p;

    switch(reason) {
        case REASON_ENDOFCOMPILE: /* miscf called just before time 0 */
            data_p = (PLIbook_my_data_p)malloc(sizeof(PLIbook_my_data_s));
            data_p->file_p = fopen(tf_getcstring(1), ""w"");
            data_p->tfinst_p = tf_getinstance();
            tf_setworkarea((char *)data_p); /* store pointer to data */
            break;
        ...
    }
}
","""Storing multiple values in a Verilog TF work area using structures and memory allocation""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p326.jpg,True,"```verilog
always @(posedge clk iff en) begin
    d1 <= i1|i2;
    a4: assert property (d1 |=> i3|i4);
    dout <= f_ecap(d1);
end
```","
always @(posedge clk iff en) begin
    d1 <= i1|i2;
    a4: assert property (d1 |=> i3|i4);
    dout <= f_ecap(d1);
end
",Excerpt from a technical document detailing the rules for clock inferencing in Verilog and providing an example Verilog code illustrating clock inferencing with an `iff` condition in the event control.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p325.jpg,True,"The image contains text and a snippet of code. The code is as follows:

```c
tf_message(ERR_ERROR, ""User"", ""TFARG"", ""Arg %d is illegal in $read_test_vector"", argnum);
```

This line of code is an example usage of the `tf_message()` function, which is used to define error messages in the context of Verilog PLI (Programming Language Interface) applications.

Another snippet shows the definition or a prototype of the `tf_text()` function:

```c
void tf_text(format, arg1,...arg5)
char *format;         /* quoted character string of formatted message. */
arg1...arg5           /* arguments to formatted message string. */
```

There is also pseudo-code given for checking error conditions and using `tf_text()` and `tf_message()`. This part, while informational, is written in a combination of code-like syntax and English descriptions rather than being a compilable code. Here is the pseudo-code:

```c
bool err = FALSE;
if wrong number of arguments
tf_text(""$read_test_vector requires 2 args\n"");
err = TRUE;
if arg 1 is not a string
tf_text(""$read_test_vector arg 1 must be quoted file name\n"");
err = TRUE;
if arg 2 is not a reg data type
tf_text(""$read_test_vector arg 2 must be a reg data type\n"");
err = TRUE;
if (err)
tf_message(ERR_ERROR, ""User"", ""TFARG"", ""System task usage error"");
```","ssage(ERR_ERROR, ""User"", ""TFARG"", ""Arg %d is illegal in $read_test_vector"", argnum);

tf_text(format, arg1,...arg5)
char *format;         /* quoted character string of formatted message. */
arg1...arg5           /* arguments to formatted message string. */

err = FALSE;
if wrong number of arguments
tf_text(""$read_test_vector requires 2 args\n"");
err = TRUE;
if arg 1 is not a string
tf_text(""$read_test_vector arg 1 must be quoted file name\n"");
err = TRUE;
if arg 2 is not a reg data type
tf_text(""$read_test_vector arg 2 must be a reg data type\n"");
err = TRUE;
if (err)
tf_message(ERR_ERROR, ""User"", ""TFARG"", ""System task usage error"");
","Caption: ""Example from The Verilog PLI Handbook demonstrating the use of tf_message() and tf_text() routines for error handling in PLI applications.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p332.jpg,True,"The image contains Verilog code. Here are the excerpts of code visible in the image:

```verilog
dreg[i] <= tr[i + 1];
c16: cover property (dreg[i] ##[1:8] tr[i + 1]);
```

```verilog
always @(posedge clk) begin
    if (treg) begin
        for (int i = 0; i < 4; i++) begin
            dreg[i] <= tr[i + 1];
        end
        c16_0: cover property (dreg[0] ##[1:8] tr[1]);
        c16_1: cover property (dreg[1] ##[1:8] tr[2]);
        c16_2: cover property (dreg[2] ##[1:8] tr[3]);
        c16_3: cover property (dreg[3] ##[1:8] tr[4]);
    end
end
```

```verilog
always @(posedge clk) begin
    if (treg) begin
        for (int i = 0; i < count; i++) begin
            dreg[i] <= tr[i + 1];
            c17: cover property (dreg[i] ##[1:8] tr[i + 1]);
        end
    end
end
```

These snippets are part of examples demonstrating how to use `cover property` in Verilog for verification purposes, to ensure certain conditions are met during simulation.","
dreg[i] <= tr[i + 1];
c16: cover property (dreg[i] ##[1:8] tr[i + 1]);


always @(posedge clk) begin
    if (treg) begin
        for (int i = 0; i < 4; i++) begin
            dreg[i] <= tr[i + 1];
        end
        c16_0: cover property (dreg[0] ##[1:8] tr[1]);
        c16_1: cover property (dreg[1] ##[1:8] tr[2]);
        c16_2: cover property (dreg[2] ##[1:8] tr[3]);
        c16_3: cover property (dreg[3] ##[1:8] tr[4]);
    end
end


always @(posedge clk) begin
    if (treg) begin
        for (int i = 0; i < count; i++) begin
            dreg[i] <= tr[i + 1];
            c17: cover property (dreg[i] ##[1:8] tr[i + 1]);
        end
    end
end
","Caption: ""Exploring Assertions in Verilog For-Loops with Examples of cover property""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p458.jpg,True,"Here is the Verilog code extracted from the image:

```verilog
import ""DPI-C"" function void counter7(output bit [6:0] out,
                                       input bit [6:0] in,
                                       input bit reset, load);

program automatic counter;
  bit [6:0] out, in;
  bit       reset, load;

  initial begin
    $monitor(""SV: out=%3d, in=%3d, reset=%0d, load=%0d\n"",
             out, in, reset, load);

    reset = 0;                                // Default values
    load = 0;
    in = 126;
    counter7(out, in, reset, load);           // Apply default values

    #10 reset = 1;
    counter7(out, in, reset, load);           // Apply reset

    #10 reset = 0;
    load = 1;
    counter7(out, in, reset, load);           // Load in=126

    #10 load = 0;
    counter7(out, in, reset, load);           // Count
  end
endprogram
```

This Verilog code snippet includes a 'DPI-C' import statement for a function called `counter7`, as well as a SystemVerilog automatic program that uses this function. The program sets some initial values, monitors outputs, and calls the `counter7` function several times with different input parameters to demonstrate its use.","
import ""DPI-C"" function void counter7(output bit [6:0] out,
                                       input bit [6:0] in,
                                       input bit reset, load);

program automatic counter;
  bit [6:0] out, in;
  bit       reset, load;

  initial begin
    $monitor(""SV: out=%3d, in=%3d, reset=%0d, load=%0d\n"",
             out, in, reset, load);

    reset = 0;                                // Default values
    load = 0;
    in = 126;
    counter7(out, in, reset, load);           // Apply default values

    #10 reset = 1;
    counter7(out, in, reset, load);           // Apply reset

    #10 reset = 0;
    load = 1;
    counter7(out, in, reset, load);           // Load in=126

    #10 load = 0;
    counter7(out, in, reset, load);           // Count
  end
endprogram
","Caption: ""Example of a SystemVerilog testbench using DPI-C to interface with a C function for a 7-bit counter.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p443.jpg,True,"```c
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
/************************************************************
 * calltf routine: turns on asynchronous callbacks to the misctf
 * routine whenever an argument to the system task changes value.
 ************************************************************/
int PLIbook_ScientificALU_calltf()
{
    tf_asynchon();
    return(0);
}

/************************************************************
 * misctf routine: Serves as an interface between Verilog simulation
 * and the C model. Called whenever the C model inputs change value,
 * reads the input values, and passes the values to the C model, and
 * writes the C model outputs into simulation.
 ************************************************************/
int PLIbook_ScientificALU_misctf(int user_data, int reason, int paramvc)
{
    #define ALU_A        1  /* system task arg 1 is ALU A input */
    #define ALU_B        2  /* system task arg 2 is ALU B input */
    #define ALU_OP       3  /* system task arg 3 is ALU opcode input */
    #define ALU_RESULT   4  /* system task arg 4 is ALU result output */
    #define ALU_EXCEPT   5  /* system task arg 5 is ALU exception output */
    #define ALU_ERROR    6  /* system task arg 6 is ALU error output */

    double a, b, result;
    int opcode, excep, err;

    /* abort if misctf was not called for a task argument value change */
    if (reason != REASON_PARAMVC)
        return(0);

    /* abort if task argument that changed was a model output */
    if (paramvc == ALU_OP)  /* model outputs are after model inputs */
        return(0);

    /* Read current values of C model inputs from Verilog simulation */
    a = tf_getrealp(ALU_A);
    b = tf_getrealp(ALU_B);
    opcode = tf_getp(ALU_OP);

    /****** Call C model ******/
    PLIbook_ScientificALU_C_model(a, b, opcode, &result, &excep, &err);

    /* Write the C model outputs onto the Verilog signals */
    tf_putrealp(ALU_RESULT, result);
    tf_putp (ALU_EXCEPT, excep);
    tf_putp (ALU_ERROR, err);

    return(0);
}
```","ude ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
/************************************************************
 * calltf routine: turns on asynchronous callbacks to the misctf
 * routine whenever an argument to the system task changes value.
 ************************************************************/
int PLIbook_ScientificALU_calltf()
{
    tf_asynchon();
    return(0);
}

/************************************************************
 * misctf routine: Serves as an interface between Verilog simulation
 * and the C model. Called whenever the C model inputs change value,
 * reads the input values, and passes the values to the C model, and
 * writes the C model outputs into simulation.
 ************************************************************/
int PLIbook_ScientificALU_misctf(int user_data, int reason, int paramvc)
{
    #define ALU_A        1  /* system task arg 1 is ALU A input */
    #define ALU_B        2  /* system task arg 2 is ALU B input */
    #define ALU_OP       3  /* system task arg 3 is ALU opcode input */
    #define ALU_RESULT   4  /* system task arg 4 is ALU result output */
    #define ALU_EXCEPT   5  /* system task arg 5 is ALU exception output */
    #define ALU_ERROR    6  /* system task arg 6 is ALU error output */

    double a, b, result;
    int opcode, excep, err;

    /* abort if misctf was not called for a task argument value change */
    if (reason != REASON_PARAMVC)
        return(0);

    /* abort if task argument that changed was a model output */
    if (paramvc == ALU_OP)  /* model outputs are after model inputs */
        return(0);

    /* Read current values of C model inputs from Verilog simulation */
    a = tf_getrealp(ALU_A);
    b = tf_getrealp(ALU_B);
    opcode = tf_getp(ALU_OP);

    /****** Call C model ******/
    PLIbook_ScientificALU_C_model(a, b, opcode, &result, &excep, &err);

    /* Write the C model outputs onto the Verilog signals */
    tf_putrealp(ALU_RESULT, result);
    tf_putp (ALU_EXCEPT, excep);
    tf_putp (ALU_ERROR, err);

    return(0);
}
",An example of a Verilog PLI routine interfacing C and Verilog code for a combinational logic model.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p296.jpg,True,"Yes, there is Verilog code in the image. Here are the two snippets of code presented:

First snippet:

```verilog
reg temp;
always@(aBus) #1 temp <= &aBus;
assign #1 OutBit1 = temp;
generate
for (i=0; i<Max; i = i+1)
    begin: InAnd
        and A(aBus[i], InBus[i], InBus[i+1]);
    end
endgenerate
```

Second snippet:

```verilog
generate
reg temp;
for (i=0; i<Max; i = i+1)
    begin: InAnd
        and A(aBus[i], InBus[i], InBus[i+1]);
    end
always@(aBus) #1 temp = &aBus;
assign #1 OutBit1 = temp;
endgenerate
```","
reg temp;
always@(aBus) #1 temp <= &aBus;
assign #1 OutBit1 = temp;
generate
for (i=0; i<Max; i = i+1)
    begin: InAnd
        and A(aBus[i], InBus[i], InBus[i+1]);
    end
endgenerate


generate
reg temp;
for (i=0; i<Max; i = i+1)
    begin: InAnd
        and A(aBus[i], InBus[i], InBus[i+1]);
    end
always@(aBus) #1 temp = &aBus;
assign #1 OutBit1 = temp;
endgenerate
","""Examples of Verilog generate constructs for digital VLSI design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p180.jpg,True,"```verilog
program automatic test (input logic clock);
  int d_array[3] = '{10,11,12};
  initial begin
    for (int thread_id=0; thread_id<3; thread_id++)
      fork
        $write("" thread_id=%0d "", thread_id);             // GOTCHA!
        $display(""d_array[thread_id]=%0d"", 
                 d_array[thread_id]);                      // GOTCHA!
      join_none                 // don’t wait for each fork to complete
    #10 $finish;
  end
endprogram
```","
program automatic test (input logic clock);
  int d_array[3] = '{10,11,12};
  initial begin
    for (int thread_id=0; thread_id<3; thread_id++)
      fork
        $write("" thread_id=%0d "", thread_id);             // GOTCHA!
        $display(""d_array[thread_id]=%0d"", 
                 d_array[thread_id]);                      // GOTCHA!
      join_none                 // don’t wait for each fork to complete
    #10 $finish;
  end
endprogram
","""Example of a common pitfall in Verilog related to forked threads and variable indexing resulting in unexpected simulation results.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p418.jpg,True,"The image contains Verilog code. Here it is:

```verilog
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */

/**********************************************************/
/* calltf routine */
/**********************************************************/
int PLIbook_MyMonitor1_calltf() {
  tf_asynchon(); /* enable asynchronous misctf callbacks */
  return(0);
}

/**********************************************************/
/* misctf routine */
/**********************************************************/
int PLIbook_MyMonitor1_misctf(int user_data, int reason, int paramvc)
{
  if (reason == REASON_PARAMVC) {
    io_printf(""At %s: t$arg %d changed, new value is %s:\n"",
      tf_strgettime(), paramvc, tf_strgetp(paramvc, 'b'));
  }
  return(0);
}
``` 

The code is from a section titled ""The Verilog PLI Handbook, Part Two,"" under the header ""Example 12-5: $my_monitor1 — asynchronous argument value change callbacks."" It includes a `calltf` routine and a `misctf` routine for a PLI application in Verilog.","
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */

/**********************************************************/
/* calltf routine */
/**********************************************************/
int PLIbook_MyMonitor1_calltf() {
  tf_asynchon(); /* enable asynchronous misctf callbacks */
  return(0);
}

/**********************************************************/
/* misctf routine */
/**********************************************************/
int PLIbook_MyMonitor1_misctf(int user_data, int reason, int paramvc)
{
  if (reason == REASON_PARAMVC) {
    io_printf(""At %s: t$arg %d changed, new value is %s:\n"",
      tf_strgettime(), paramvc, tf_strgetp(paramvc, 'b'));
  }
  return(0);
}
","""Example of Verilog PLI code for asynchronous argument value change callbacks from The Verilog PLI Handbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p403.jpg,True,"The image contains Verilog code. Here is the code present in the image:

```verilog
module top;
  logic clk, rst;

  Rx_if Rx[4] (clk);
  Tx_if Tx[4] (clk);
  test t1 (Rx, Tx, rst); // See testbench in Sample 10-6
  atm_router a1 (Rx[0], Rx[1], Rx[2], Rx[3],
                 Tx[0], Tx[1], Tx[2], Tx[3],
                 clk, rst);

  initial begin
    clk = 0;
    forever #20 clk = !clk;
  end
endmodule : top
```

This code snippet is an example of a top-level module in Verilog that includes an instantiation of an array of interfaces for Rx and Tx, a test module, and an ATM router module, alongside a clock generation process within an `initial` block.","
module top;
  logic clk, rst;

  Rx_if Rx[4] (clk);
  Tx_if Tx[4] (clk);
  test t1 (Rx, Tx, rst); // See testbench in Sample 10-6
  atm_router a1 (Rx[0], Rx[1], Rx[2], Rx[3],
                 Tx[0], Tx[1], Tx[2], Tx[3],
                 clk, rst);

  initial begin
    clk = 0;
    forever #20 clk = !clk;
  end
endmodule : top
","""Example of a Verilog testbench setup with interface array for a 4x4 ATM router.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p135.jpg,True,"Here is the Verilog code provided in the image:

```verilog
module range_solution;
    logic clk, rdy, rdyAck;
    byte rdyNum, rdyAckNum;

    initial
    begin
        clk=1'b0; rdy=0; rdyNum=0; rdyAck=0; rdyAckNum=0;
        #500 $finish(2);
    end

    always
    begin
        #10 clk=~clk;
    end

    initial
    begin
        repeat (4)
        begin
            @(posedge clk) rdy=0;
            @(posedge clk) rdy=1; rdyNum=rdyNum+1;
        end
    end

    initial
    begin
        $monitor($stime,,,,""clk="",clk,,,,""rdy="",rdy,,,,""rdyNum="",rdyNum,,,,
                 ""rdyAckNum"",rdyAckNum,,,,""rdyAck="",rdyAck);
    end
    
    always
    begin
        repeat (4)
        begin
            @(posedge clk); (@posedge clk); (@posedge clk);
            rdyAck=1; rdyAckNum=rdyAckNum+1;
            @(posedge clk) rdyAck=0;
        end
    end

end
```
This Verilog code snippet seems to be part of a simulation example illustrating the use of clock events and possibly synchronizing signals within a digital system.","
module range_solution;
    logic clk, rdy, rdyAck;
    byte rdyNum, rdyAckNum;

    initial
    begin
        clk=1'b0; rdy=0; rdyNum=0; rdyAck=0; rdyAckNum=0;
        #500 $finish(2);
    end

    always
    begin
        #10 clk=~clk;
    end

    initial
    begin
        repeat (4)
        begin
            @(posedge clk) rdy=0;
            @(posedge clk) rdy=1; rdyNum=rdyNum+1;
        end
    end

    initial
    begin
        $monitor($stime,,,,""clk="",clk,,,,""rdy="",rdy,,,,""rdyNum="",rdyNum,,,,
                 ""rdyAckNum"",rdyAckNum,,,,""rdyAck="",rdyAck);
    end
    
    always
    begin
        repeat (4)
        begin
            @(posedge clk); (@posedge clk); (@posedge clk);
            rdyAck=1; rdyAckNum=rdyAckNum+1;
            @(posedge clk) rdyAck=0;
        end
    end

end
","""Example of a Verilog testbench with clock delay range operator and multiple threads for signal control.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p417.jpg,True,"The image contains Verilog code. Here it is transcribed:

```verilog
interface simple_if(input logic clk);
  logic [7:0] addr;
  logic [7:0] data;
  bus_cmd_e cmd;
  modport TARGET
  (
    input addr, cmd, data,
    import task targetRcv (output bus_cmd_e c, logic [7:0] a, d));
  
  modport INITIATOR
  (
    output addr, cmd, data,
    import task initiatorSend(input bus_cmd_e c, logic [7:0] a, d)
  );

  // Parallel send
  task initiatorSend(input bus_cmd_e c, logic [7:0] a, d);
    @(posedge clk);
    cmd <= c;
    addr <= a;
    data <= d;
  endtask

  // Parallel receive
  task targetRcv(output bus_cmd_e c, logic [7:0] a, d);
    @(posedge clk);
    a = addr;        // Use non-blocking assignments to
    d = data;        // immediately sample the bus values
    c = cmd;         // and avoid race conditions
  endtask
endinterface: simple_if
```

This Verilog interface code includes an example of defining a simple interface for a parallel protocol with tasks, signal declarations within the interface, and modports for different roles such as TARGET and INITIATOR. There are also tasks defined for sending and receiving data which use non-blocking assignments to prevent race conditions. This interface is noted in ""Sample 10.31"" within the document.","
interface simple_if(input logic clk);
  logic [7:0] addr;
  logic [7:0] data;
  bus_cmd_e cmd;
  modport TARGET
  (
    input addr, cmd, data,
    import task targetRcv (output bus_cmd_e c, logic [7:0] a, d));
  
  modport INITIATOR
  (
    output addr, cmd, data,
    import task initiatorSend(input bus_cmd_e c, logic [7:0] a, d)
  );

  // Parallel send
  task initiatorSend(input bus_cmd_e c, logic [7:0] a, d);
    @(posedge clk);
    cmd <= c;
    addr <= a;
    data <= d;
  endtask

  // Parallel receive
  task targetRcv(output bus_cmd_e c, logic [7:0] a, d);
    @(posedge clk);
    a = addr;        // Use non-blocking assignments to
    d = data;        // immediately sample the bus values
    c = cmd;         // and avoid race conditions
  endtask
endinterface: simple_if
","Caption: ""Verilog interface example for parallel protocol communication, showcasing the definition of tasks for initiating sending and receiving data.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p121.jpg,True,"The image contains Verilog code snippets. Here they are:

```verilog
bit [3:0] a,b,c;
always @(posedge clk)
begin
    if ($past(a) == 4'h5 ) $display ($stime,,"" 't Past a' = %h"",$past(a));
    if ($past(b) == 4'ha ) $display ($stime,,"" 't Past b' = %h"",$past(b));
    c = ($past(a) & $past(b));
end
```

And another snippet from the image:

```verilog
assert property (@ (posedge clk) done |-> IV (mySig,2, enb, lastVal) $display(....);
```

With the corresponding property definition:

```verilog
property IV(sig, numClocks, enb, lastV);
    (lastV == $past (sig, numClocks, enb));
endproperty
```

These Verilog code snippets illustrate the usage of the `$past` system function, which is used to refer to past values of signals in formal property verification within the SystemVerilog language.","
bit [3:0] a,b,c;
always @(posedge clk)
begin
    if ($past(a) == 4'h5 ) $display ($stime,,"" 't Past a' = %h"",$past(a));
    if ($past(b) == 4'ha ) $display ($stime,,"" 't Past b' = %h"",$past(b));
    c = ($past(a) & $past(b));
end


assert property (@ (posedge clk) done |-> IV (mySig,2, enb, lastVal) $display(....);


property IV(sig, numClocks, enb, lastV);
    (lastV == $past (sig, numClocks, enb));
endproperty
","The image contains an excerpt from a document explaining the use of the $past function in Verilog, along with an example of its usage in code. It showcases a snippet on how to sample past values within a synchronous block in Verilog HDL.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p194.jpg,True,"The image contains Verilog code examples. Here is the code:

```verilog
program test;
...
Bustrans tr;

initial begin
  tr = new;
  $assertoff();  // disable all assertions during reset
  $asserton(tr_rand); // OK, tr randomization turned back on
  rst_n <= 0;

  tr_rand: assert (tr.randomize)
    else $display(""randomization failed"");

  #10 rst_n <= 0;
  $asserton();
  ...
end
endprogram
```

```verilog
program test;
...
Bustrans tr;

initial begin
  tr = new;

  tr_rand: assert (tr.randomize)
    else $display(""randomization failed"");

  $assertoff();  // OK, tr randomization already executed
  rst_n <= 0;
  #10 rst_n <= 0;
  $asserton();
  ...
end
endprogram
```

The text is discussing strategies to handle a particular ""gotcha"" in Verilog/SystemVerilog related to assertions and the use of the `.randomize` method. One approach mentioned is to disable assertions during a reset operation, execute the `.randomize` method, then re-enable assertions immediately after. The second approach is executing the `.randomize` method before the assertions are disabled.","
program test;
...
Bustrans tr;

initial begin
  tr = new;
  $assertoff();  // disable all assertions during reset
  $asserton(tr_rand); // OK, tr randomization turned back on
  rst_n <= 0;

  tr_rand: assert (tr.randomize)
    else $display(""randomization failed"");

  #10 rst_n <= 0;
  $asserton();
  ...
end
endprogram


program test;
...
Bustrans tr;

initial begin
  tr = new;

  tr_rand: assert (tr.randomize)
    else $display(""randomization failed"");

  $assertoff();  // OK, tr randomization already executed
  rst_n <= 0;
  #10 rst_n <= 0;
  $asserton();
  ...
end
endprogram
","Caption: ""Handling Assertions During Randomization in Verilog/SystemVerilog Code""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p355.jpg,True,"```verilog
a_no_start: assert property (
    start |-> !start throughout complete[-1]
);
a_no_complete: assert property (
    complete |-> !complete throughout start[-1]
);
initial
    a_initial_no_complete: assert property (
        !complete throughout start[-1]
    ),
```","
a_no_start: assert property (
    start |-> !start throughout complete[-1]
);
a_no_complete: assert property (
    complete |-> !complete throughout start[-1]
);
initial
    a_initial_no_complete: assert property (
        !complete throughout start[-1]
    ),
","""Verilog assertions for encoding a sequential protocol's control part.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p342.jpg,True,"The image contains a snippet of code, which is provided below:

```c
int vec_size = tf_sizep(2);                  /* bit size of tfarg 2 */
char *vector = malloc(vec_size+1);           /* memory for vector string */
bool VERBOSE = FALSE;                        /* flag for debug output */

if (mc_scan_plusargs(""debug"")) VERBOSE = TRUE; /* set verbose flag */

in_file = (FILE*)tf_getworkarea();           /* retrieve file pointer */

if ((fscanf(in_file, ""%s\n"", vector)) == EOF) { /* read a vector */
    tf_warning(""%sread_test_vector reached End-of-File %s"",
               tf_getcstringp(1));           /* get file name from task arg 1 */
    fclose(in_file);
    tf_dofinish();                           /* exit simulation at end-of-file */
    return(0);
}
if (VERBOSE)
    io_printf(""%sread_test_vector: Value read from file=%s\n"", vector);

/* write test vector value onto system task arg 2 */
if (!(tf_strdelputp(2,vec_size,'b',vector,0,0))) {
    if (VERBOSE)
        tf_error(""%sread_test_vector could not write to arg 2 at time %s"",
                 tf_strgettime() );
}
return(0);
```

This code is related to using the TF (task/function) routines in PLI (Programming Language Interface) applications for Verilog simulators. The code includes reading a vector from a file, handling verbose debugging output, and writing values back into system task arguments.","ec_size = tf_sizep(2);                  /* bit size of tfarg 2 */
char *vector = malloc(vec_size+1);           /* memory for vector string */
bool VERBOSE = FALSE;                        /* flag for debug output */

if (mc_scan_plusargs(""debug"")) VERBOSE = TRUE; /* set verbose flag */

in_file = (FILE*)tf_getworkarea();           /* retrieve file pointer */

if ((fscanf(in_file, ""%s\n"", vector)) == EOF) { /* read a vector */
    tf_warning(""%sread_test_vector reached End-of-File %s"",
               tf_getcstringp(1));           /* get file name from task arg 1 */
    fclose(in_file);
    tf_dofinish();                           /* exit simulation at end-of-file */
    return(0);
}
if (VERBOSE)
    io_printf(""%sread_test_vector: Value read from file=%s\n"", vector);

/* write test vector value onto system task arg 2 */
if (!(tf_strdelputp(2,vec_size,'b',vector,0,0))) {
    if (VERBOSE)
        tf_error(""%sread_test_vector could not write to arg 2 at time %s"",
                 tf_strgettime() );
}
return(0);
","""Sample code from a Verilog textbook demonstrating the use of the TF (task/function) routines for reading a test vector file and using it in simulation""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p359.jpg,True,"```verilog
class Binary;
  rand bit [3:0] val1, val2;

  function new(input bit [3:0] val1, val2);
    this.val1 = val1;
    this.val2 = val2;
  endfunction

  virtual function void print_int(input int val);
    $display(""val=0d%0d"", val);
  endfunction

endclass
```","
class Binary;
  rand bit [3:0] val1, val2;

  function new(input bit [3:0] val1, val2);
    this.val1 = val1;
    this.val2 = val2;
  endfunction

  virtual function void print_int(input int val);
    $display(""val=0d%0d"", val);
  endfunction

endclass
","""Exercises on extending and utilizing a Verilog class for multiplication operations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p109.jpg,True,"The image contains multiple snippets of Verilog code. Here they are transcribed:

First snippet:
```verilog
module designModule (da,db,dclk);
input da,dclk;
output logic db;
reg rda, rdb; // rda and rdb internal reg to designModule

always @(posedge dclk) db <= da;
always @(posedge dclk) rdb <= rda;
endmodule
```

Second snippet:
```verilog
module propertyModule (pa,pb,pclk);
input pa, pb, pclk;

property rc1;
pa |-> pb;
endproperty

baseP: assert property (@(posedge pclk) (rc1)) else $display($stime,,""tproperty FAIL"");
endmodule
```

Third snippet:
```verilog
module test_bindProperty;
logic ta, tb, tclk;

// bind designModule propertyModule dPm (.pa(da),.pb(db),.pclk(dclk));
bind designModule propertyModule dPm (.pa(rda),.pb(rdb),.pclk(dclk));
endmodule
```

Below the code snippets, there is also some text related to the topic, but it was not requested to be transcribed.","
module designModule (da,db,dclk);
input da,dclk;
output logic db;
reg rda, rdb; // rda and rdb internal reg to designModule

always @(posedge dclk) db <= da;
always @(posedge dclk) rdb <= rda;
endmodule


module propertyModule (pa,pb,pclk);
input pa, pb, pclk;

property rc1;
pa |-> pb;
endproperty

baseP: assert property (@(posedge pclk) (rc1)) else $display($stime,,""tproperty FAIL"");
endmodule


module test_bindProperty;
logic ta, tb, tclk;

// bind designModule propertyModule dPm (.pa(da),.pb(db),.pclk(dclk));
bind designModule propertyModule dPm (.pa(rda),.pb(rdb),.pclk(dclk));
endmodule
","""Example of Verilog modules demonstrating VHDL DUT binding with SystemVerilog assertions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p424.jpg,True,"The image contains Verilog code examples. Here is the code present in the image:

```verilog
initial
  $read_stimulus_<base><delay_type>(""file_name"", verilog_reg);
```

And an example usage is also given:

```verilog
initial
  $read_stimulus_ba(""read_stimulus.pat"", input_vector);
```

In the example, `<base>` should be replaced by `b` or `h` (for binary or hex vectors), `<delay_type>` should be replaced by `a` or `r` (for absolute or relative times), `""file_name""` should be the name of the file to be read, and `verilog_reg` should be a Verilog register data type with the same bit width as the patterns to be read.","
initial
  $read_stimulus_<base><delay_type>(""file_name"", verilog_reg);


initial
  $read_stimulus_ba(""read_stimulus.pat"", input_vector);
","Caption: ""Verilog PLI Handbook excerpt detailing the usage of $read_stimulus task variations for file reading and simulation control in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p198.jpg,True,"```verilog
// declarative assertion
assert property (@(posedge clk) disable iff (reset_n)
    enable |-> opcode inside {1, 2, 3, 7})
else $error(""CTL sent illegal opcode (%h) to ALU."", opcode);
```","
// declarative assertion
assert property (@(posedge clk) disable iff (reset_n)
    enable |-> opcode inside {1, 2, 3, 7})
else $error(""CTL sent illegal opcode (%h) to ALU."", opcode);
","Caption: ""SystemVerilog Assertion for Conditional Checking of Valid Opcodes""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p433.jpg,True,"Here is the Verilog code present in the image:

Using `generate`:
```verilog
bit [31:0] x, y; bit clk;
default clocking ck @(posedge clk); endclocking
for (genvar i=0; i<32; i++) begin : loopi
    prop_cov6: cover property (
        x[i] ##1 x[i] ##1 y[i] [- >1]
    );
end : loopi
```

Using a `covergroup`:
```verilog
default clocking ck @(posedge clk); endclocking
covergroup cg_vect
    with function sample (bit [31:0] covered);
    vect: coverpoint covered {
        bins x0 = {covered[0]};
        // enumerate all bit positions
        bins x31 = {covered[31]};
    }
endgroup
cg_vect cg_inst = new();
property p_vector_cov;
    bit [31:0] rose_x, covered;
    @(posedge clk) (1, rose_x = x) ##1 (1, rose_x = x & ~rose_x)
    ##0 (|rose_x, covered = 0)
    ##1 (
        (y & rose_x & ~covered) [- >1],
        covered |= (y & rose_x)
    )
    [+]
    ##0 (covered == rose_x, cg_inst.sample(covered));
endproperty
prop_cov7: cover property (p_vector_cov);
```

This code snippet demonstrates examples of using `generate` constructs and `covergroup` constructs for sequence and property coverage in Verilog.","
bit [31:0] x, y; bit clk;
default clocking ck @(posedge clk); endclocking
for (genvar i=0; i<32; i++) begin : loopi
    prop_cov6: cover property (
        x[i] ##1 x[i] ##1 y[i] [- >1]
    );
end : loopi


default clocking ck @(posedge clk); endclocking
covergroup cg_vect
    with function sample (bit [31:0] covered);
    vect: coverpoint covered {
        bins x0 = {covered[0]};
        // enumerate all bit positions
        bins x31 = {covered[31]};
    }
endgroup
cg_vect cg_inst = new();
property p_vector_cov;
    bit [31:0] rose_x, covered;
    @(posedge clk) (1, rose_x = x) ##1 (1, rose_x = x & ~rose_x)
    ##0 (|rose_x, covered = 0)
    ##1 (
        (y & rose_x & ~covered) [- >1],
        covered |= (y & rose_x)
    )
    [+]
    ##0 (covered == rose_x, cg_inst.sample(covered));
endproperty
prop_cov7: cover property (p_vector_cov);
","""Verilog code snippets illustrating sequence and property coverage using generate loop and covergroup in functional verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p88.jpg,True,"The image contains a code snippet written in Verilog. Here is the code:

```verilog
module bad_comb_logic (input wire in1,
                       output reg out1, out2
                       );

    always @(in1) begin
        out2 = out1; // GOTCHA: out2 is first stores last out1 value
        out1 = in1;  // second, out1 is updated to new value of in1
    end
endmodule
```

This code is used to illustrate an issue highlighted as ""Gotcha 31: Combinational logic assignments in the wrong order"" in the document.","
module bad_comb_logic (input wire in1,
                       output reg out1, out2
                       );

    always @(in1) begin
        out2 = out1; // GOTCHA: out2 is first stores last out1 value
        out1 = in1;  // second, out1 is updated to new value of in1
    end
endmodule
","""Example of a common pitfall in Verilog involving incorrect order of combinational logic assignments leading to unexpected synthesis results.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p427.jpg,True,"The image contains code related to Verilog, a hardware description language used in electronic design automation. Here is the code from the image:

```verilog
default clocking ck @(posedge clk); endclocking
enum int { ... } e;
prop_cov1: cover property ( disable iff (reset)
    a ##[1:100] b
) begin
    my_count++;
    $display(""success of prop_cov1 at time %t"", $time);
end
```

This code is an example of how to use the `cover property` statement in the context of property coverage in Verilog. The `default clocking` statement is used to define a default clocking block for the subsequent property coverage block. The `cover property` statement checks for a particular sequence of events (`a` followed by `b` within 1 to 100 clock cycles) and is disabled if a `reset` condition is true. If the property is successfully covered, `my_count` is incremented, and a message is displayed.","
default clocking ck @(posedge clk); endclocking
enum int { ... } e;
prop_cov1: cover property ( disable iff (reset)
    a ##[1:100] b
) begin
    my_count++;
    $display(""success of prop_cov1 at time %t"", $time);
end
","""Excerpt from a technical document discussing sequence and property coverage in Verilog, with an example code snippet illustrating the use of cover property for efficient coverage recording.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p341.jpg,True,"The image contains Verilog code. Here is the code transcribed from the image:

```verilog
checker check1(a, event clk = $inferred_clock);
  a1: assert property (@clk a);
endchecker : check1

module m(input logic clock, b, en, ...);
  // ...
  always @(posedge clock) begin
    if (en) begin
      // ...
      check1 c1(b);
    end
  end
endmodule : m

module m(input logic clock, b, ...);
  // ...
  always @(posedge clock) begin
    if (en) begin
      // ...
      a1: assert property (@(posedge clock) b);
    end
  end
endmodule : m
```

The code provides examples illustrating procedural checker instances in the context of Verilog assertions.","
checker check1(a, event clk = $inferred_clock);
  a1: assert property (@clk a);
endchecker : check1

module m(input logic clock, b, en, ...);
  // ...
  always @(posedge clock) begin
    if (en) begin
      // ...
      check1 c1(b);
    end
  end
endmodule : m

module m(input logic clock, b, ...);
  // ...
  always @(posedge clock) begin
    if (en) begin
      // ...
      a1: assert property (@(posedge clock) b);
    end
  end
endmodule : m
","Caption: ""Understanding Procedural Checker Instances in Verilog: This excerpt outlines how static assertions within checker declarations become procedural assertions when instantiated in a procedural context, using Verilog code examples to illustrate the concept.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p356.jpg,True,"The image contains a segment of text providing instructions and information about handling propagation delays in Verilog PLI (Programming Language Interface). There is Verilog-related code in the image, and here it is:

```c
double delay;
char *vector;
vector = malloc(tf_sizep(2) + 1);
strcpy(vector, ""zzzzzzzz"");
delay = 5.2;
tf_strrealdelputp(2, tf_sizep(2), ‘h’, vector, delay, 2);
```

Additionally, the image describes how the `tf_strdelputp()`, `tf_strlongdelputp()`, and `tf_strrealdelputp()` routines can be used to specify propagation delays when writing values in Verilog and how they scale to the time unit specified in the Verilog models using the `timescale` compiler directive. There is also a visual illustration showing how a 64-bit Verilog time value is represented using a pair of C `unsigned int` variables.","e delay;
char *vector;
vector = malloc(tf_sizep(2) + 1);
strcpy(vector, ""zzzzzzzz"");
delay = 5.2;
tf_strrealdelputp(2, tf_sizep(2), ‘h’, vector, delay, 2);
","""Verilog PLI Handbook excerpt showing how to write a hex value with propagation delay using Verilog Procedural Interface (PLI) functions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p143.jpg,True,"The image contains Verilog code snippets. Here they are:

First snippet:
```verilog
module top;
    ...
    initial begin
        clock <= 1; // OK, first rising clock after delta
        forever #5 clock = ~clock;
    end
endmodule
```

Second snippet:
```verilog
program automatic test (input logic clock, output logic reset_n);
    initial begin
        reset_n <= 0; // OK, reset activated as verification event
        #10 reset_n <= 1;
        ...
    end
endmodule
```

Third snippet:
```verilog
module top;
    ...
    initial begin
        clock <= 1; // OK, first rising clock after delta
        forever #5 clock = ~clock;
    end
endmodule
```","
module top;
    ...
    initial begin
        clock <= 1; // OK, first rising clock after delta
        forever #5 clock = ~clock;
    end
endmodule


program automatic test (input logic clock, output logic reset_n);
    initial begin
        reset_n <= 0; // OK, reset activated as verification event
        #10 reset_n <= 1;
        ...
    end
endmodule


module top;
    ...
    initial begin
        clock <= 1; // OK, first rising clock after delta
        forever #5 clock = ~clock;
    end
endmodule
","""Verilog code example for clock generation and SystemVerilog test program block addressing race conditions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p63.jpg,True,"```verilog
module buffer8
(output uwire [7:0] y, // variable data type
 input uwire [7:0] a   // variable data type
);
assign a = y; // ERROR! multiple drivers for a;
endmodule
```

```verilog
module buffer8
(output logic [7:0] y, // variable data type
 input logic [7:0] a   // variable data type
);
assign a = y; // ERROR! multiple sources for a;
endmodule
```","
module buffer8
(output uwire [7:0] y, // variable data type
 input uwire [7:0] a   // variable data type
);
assign a = y; // ERROR! multiple drivers for a;
endmodule


module buffer8
(output logic [7:0] y, // variable data type
 input logic [7:0] a   // variable data type
);
assign a = y; // ERROR! multiple sources for a;
endmodule
","""Explanation of a Verilog coding error in module buffer8 with solutions to avoid multiple driver scenarios.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p173.jpg,True,"The image contains two examples of code written, one for SystemVerilog and one for Property Specification Language (PSL).

Here's the SystemVerilog code from the image:

```verilog
always @(posedge clk) begin
    if (reset_n)
        myQfull: cover (q_full) $info(""queue was full"");
end
```

And here's the PSL code from the image:

```verilog
default clock = (posedge clk);
sequence qFullCondition = {reset_n & q_full};
cover qFullCondition;
```","
always @(posedge clk) begin
    if (reset_n)
        myQfull: cover (q_full) $info(""queue was full"");
end


default clock = (posedge clk);
sequence qFullCondition = {reset_n & q_full};
cover qFullCondition;
","Caption: ""Extract from a technical document discussing functional coverage in SystemVerilog and PSL (Property Specification Language) with code examples.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p77.jpg,True,"The image contains a snippet of Verilog code which is as follows:

```verilog
always @(posedge clock or negedge reset_n)
  if (!reset_n) begin
    q1 <= 0;
    q2 <= 0;
    q3 <= 0;    // GOTCHA! q4 is missing from this branch
  end
  else begin
    q1 <= q4;
    q2 <= q1;
    q3 <= q2;
    q4 <= q3;
  end
```","
always @(posedge clock or negedge reset_n)
  if (!reset_n) begin
    q1 <= 0;
    q2 <= 0;
    q3 <= 0;    // GOTCHA! q4 is missing from this branch
  end
  else begin
    q1 <= q4;
    q2 <= q1;
    q3 <= q2;
    q4 <= q3;
  end
","""Common pitfall in Verilog code: Incomplete reset logic for sequential blocks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p241.jpg,True,"The image contains Verilog code. Here is the transcribed code:

```verilog
reg [3:0] OutBusReg;
reg [7:0] DataBusReg;
reg Out2valReg, Out3valReg;
...
always @(negedge Clk)
begin
    OutBusReg <= 4'bzz01;
    DataBusReg <= 8'b1111_0zzz;
    Out2valReg <= 1'b1;
    Out3valReg <= 1'bz;
end

always @(posedge Clk)
begin
    OutBusReg <= 4'b0101;
    DataBusReg <= 8'b1zzz_0000;
    Out2valReg <= 1'b0;
    Out3valReg <= 1'b0;
end
```

The above code includes blocks that define the behavior of certain registers (`OutBusReg`, `DataBusReg`, `Out2valReg`, `Out3valReg`) on the negative and positive edge of a clock signal (`Clk`).","
reg [3:0] OutBusReg;
reg [7:0] DataBusReg;
reg Out2valReg, Out3valReg;
...
always @(negedge Clk)
begin
    OutBusReg <= 4'bzz01;
    DataBusReg <= 8'b1111_0zzz;
    Out2valReg <= 1'b1;
    Out3valReg <= 1'bz;
end

always @(posedge Clk)
begin
    OutBusReg <= 4'b0101;
    DataBusReg <= 8'b1zzz_0000;
    Out2valReg <= 1'b0;
    Out3valReg <= 1'b0;
end
","""Verilog code example for implementing rise, fall, and high-impedance states with regular delays.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p304.jpg,True,"The image contains two sets of pseudocode resembling code for hypothetical threads in a concurrent program, which are meant to illustrate issues with locking discipline and access to shared resources. Here they are represented as (a) for thread T1 and (b) for thread T2:

Thread T1 (a):
```
1a: a = 1;
2a: lock(lk1);
3a: lock(lk2);
4a: y = 1;
5a: unlock(lk2);
6a: x = 0;
7a: unlock(lk1);
```

Thread T2 (b):
```
1b: b = 0;
2b: lock(lk2);
3b: lock(lk1);
4b: z = 2;
5b: unlock(lk1);
6b: x = 1;
7b: unlock(lk2);
```","= 1;
2a: lock(lk1);
3a: lock(lk2);
4a: y = 1;
5a: unlock(lk2);
6a: x = 0;
7a: unlock(lk1);

= 0;
2b: lock(lk2);
3b: lock(lk1);
4b: z = 2;
5b: unlock(lk1);
6b: x = 1;
7b: unlock(lk2);
","Caption: ""Example of thread synchronization using lock primitives in concurrent programming, as described in an academic document.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p157.jpg,True,"The image contains an excerpt of text discussing programming practices in Verilog but also includes an example of Verilog code which is intended to illustrate a point about code indentation. Here is the Verilog code from the image:

```verilog
initial begin
    a = 1;
    if (a);
        $display(""'a' is true""); // statement is not auto-indented
end
```","
initial begin
    a = 1;
    if (a);
        $display(""'a' is true""); // statement is not auto-indented
end
","Caption: ""Discussion of common programming pitfalls in Verilog and suggestions on proper indentation and semicolon use to avoid syntax errors.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p269.jpg,True,"The image contains a snippet of Verilog code which is embedded within a text:

```verilog
module ...
... (500 lines of verilog) ...
reg[7:0] ClockCount;
always@(negedge ClockIn)
begin : Ticker
    if (StartCount=='1'b1)
        ClockCount = 'b0;
    else ClockCount = ClockCount + 8'h1;
    if (ClockCount >= 8'h3a) do_something;
end
```
This snippet discusses Verilog declarations and recommends a practice of declaring variables close to the `always` blocks where they are used.","
module ...
... (500 lines of verilog) ...
reg[7:0] ClockCount;
always@(negedge ClockIn)
begin : Ticker
    if (StartCount=='1'b1)
        ClockCount = 'b0;
    else ClockCount = ClockCount + 8'h1;
    if (ClockCount >= 8'h3a) do_something;
end
","Caption: ""Excerpt from a textbook on Digital VLSI Design with Verilog discussing the Verilog name space and showing an example of Verilog code with variable declarations within a module.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p381.jpg,True,"The image contains a fragment of code in Verilog, from a book or a document that discusses Reading and Writing Values Using TF Routines in Verilog. The code present in the image is as follows:

```verilog
reg [23:0] RAM [0:3]; // array with 24-bit words, 4 words deep

initial
  $dump_mem_hex(RAM[2]);
```

However, please note that the code snippet is incomplete and is meant for illustrative purposes within the document's context.","
reg [23:0] RAM [0:3]; // array with 24-bit words, 4 words deep

initial
  $dump_mem_hex(RAM[2]);
",A page from a textbook explaining the `tf_nodeinfo()` routine used for reading and writing Verilog memory arrays with an example Verilog code snippet for defining a 4-word memory array.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p396.jpg,True,"The image contains several snippets of Verilog/SystemVerilog code. Here they are:

```verilog
property p_no_repeat_ttype(
  varying_ttype, captured_ttype
);
  start[-1:2]
  |-> varying_ttype != captured_ttype;
endproperty

property p_ttype_check;
  transType l_ttype;
  (start && ((ttype == INV || ttype == PRG), l_ttype = ttype)
  |=> 
  (
    (1'b1, l_ttype = ttype) // no effect on instance below
    and
    p_no_repeat_ttype(
      .varying_ttype(ttype), .captured_ttype(l_ttype)
    )
  );
endproperty
```

And another snippet:

```verilog
sequence s_skip(numToSkip);
  (numToSkip > 0 ##0 complete [-1], numToSkip--) [*1 ##1 (numToSkip == 0 ##0 complete[-1])); 
endsequence
```","
property p_no_repeat_ttype(
  varying_ttype, captured_ttype
);
  start[-1:2]
  |-> varying_ttype != captured_ttype;
endproperty

property p_ttype_check;
  transType l_ttype;
  (start && ((ttype == INV || ttype == PRG), l_ttype = ttype)
  |=> 
  (
    (1'b1, l_ttype = ttype) // no effect on instance below
    and
    p_no_repeat_ttype(
      .varying_ttype(ttype), .captured_ttype(l_ttype)
    )
  );
endproperty


sequence s_skip(numToSkip);
  (numToSkip > 0 ##0 complete [-1], numToSkip--) [*1 ##1 (numToSkip == 0 ##0 complete[-1])); 
endsequence
",Verilog Properties and Sequences: Demonstrating Local Variable Mechanics in SystemVerilog Assertions,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p395.jpg,True,"The image contains code related to Verilog programming, specifically dealing with reading and writing values using TF routines. Here is the code text from the image:

```c
tf_dofinish(); /* about simulation */
return(0);
}
else if (info->node_info->node_type != TF_MEMORY_NODE) {
tf_error(""Error: $fill_mem arg is not a memory word -- aborting"");
tf_dofinish(); /* about simulation */
return(0);
}

/* Get the exprinfo structure for tfarg 1 */
if (!tf_exprinfo(1, info->expr_info)) {
  tf_error(""Error: $fill_mem could not get tf_exprinfo for tfarg 1"");
  tf_dofinish(); /* about simulation */
  return(0);
}

tf_setworkarea((char *)info); /* put info pointer in work area */

return(0);
}

/***********************************************************************
 * calltf application
 ***********************************************************************/
int PLIbook_Fillmem_calltf()
{
  int depth, width, ngroups, word_increment, mem_address, i;
  char *mem_ptr, *aval_ptr, *bval_ptr;
  PLIbook_my_data_p info; /* pointer to info structures */

  info = (PLIbook_my_data_p)tf_getworkarea();

  mem_ptr = info->node_info->node_value.memoryval_p;
  width = info->node_info->node_vec_size;
  depth = info->node_info->node_mem_size;
  ngroups = info->node_info->node_ngroups;

  /* Modify current memory values: set aval bits to memory address,
     set bval bits to 0 (2-state logic) */
  word_increment = ngroups * 2; /* 1 word = aval/bval group set */
  for (mem_address = 0; mem_address < 4; /* node_info->node_mem_size; */
       mem_address++) {
    aval_ptr = mem_ptr + (mem_address * word_increment);
    bval_ptr = aval_ptr + ngroups;
    aval_ptr[0] = mem_address;
    bval_ptr[0] = 0x0;
    for (i=1; i<ngroups; i++) {
      aval_ptr[i] = 0x0;
      bval_ptr[i] = 0x0;
    }
  }
}
```

The code is part of a documentation or book (as hinted by the comment and variable names such as `PLIbook_my_data_p` and function names like `PLIbook_Fillmem_calltf`), and it shows how to use task and function routines in Verilog to interface with memory elements within a simulation. The documentation seems to be discussing details from chapter 11, ""Reading and Writing Values Using TF Routines"". It features error handling, fetching information about memory nodes, and modifying memory values. Some parts of the code, especially in the for-loop condition, are commented out or seem to be placeholders (e.g., `/* node_info->node_mem_size; */`).","finish(); /* about simulation */
return(0);
}
else if (info->node_info->node_type != TF_MEMORY_NODE) {
tf_error(""Error: $fill_mem arg is not a memory word -- aborting"");
tf_dofinish(); /* about simulation */
return(0);
}

/* Get the exprinfo structure for tfarg 1 */
if (!tf_exprinfo(1, info->expr_info)) {
  tf_error(""Error: $fill_mem could not get tf_exprinfo for tfarg 1"");
  tf_dofinish(); /* about simulation */
  return(0);
}

tf_setworkarea((char *)info); /* put info pointer in work area */

return(0);
}

/***********************************************************************
 * calltf application
 ***********************************************************************/
int PLIbook_Fillmem_calltf()
{
  int depth, width, ngroups, word_increment, mem_address, i;
  char *mem_ptr, *aval_ptr, *bval_ptr;
  PLIbook_my_data_p info; /* pointer to info structures */

  info = (PLIbook_my_data_p)tf_getworkarea();

  mem_ptr = info->node_info->node_value.memoryval_p;
  width = info->node_info->node_vec_size;
  depth = info->node_info->node_mem_size;
  ngroups = info->node_info->node_ngroups;

  /* Modify current memory values: set aval bits to memory address,
     set bval bits to 0 (2-state logic) */
  word_increment = ngroups * 2; /* 1 word = aval/bval group set */
  for (mem_address = 0; mem_address < 4; /* node_info->node_mem_size; */
       mem_address++) {
    aval_ptr = mem_ptr + (mem_address * word_increment);
    bval_ptr = aval_ptr + ngroups;
    aval_ptr[0] = mem_address;
    bval_ptr[0] = 0x0;
    for (i=1; i<ngroups; i++) {
      aval_ptr[i] = 0x0;
      bval_ptr[i] = 0x0;
    }
  }
}
","""Example of a Verilog TF (task/function) routine for reading and modifying memory values.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p382.jpg,True,"The code in the image is Verilog code, specifically a property declaration for formal verification. Here is the code text:

```verilog
property p_data_and_parity;
    dataType l_data;
    parityType l_parity;
    start ##1
    (
        (dataValid, l_data = data, l_parity = parity)
        within complete[-1]
    )
    |-> parityOfX(l_data, l_parity);
endproperty
```

This code snippet defines a property `p_data_and_parity` that checks for some condition related to `data` and `parity` after the signal `start` and within the given conditions involving `dataValid` and `complete`. This is a pattern often found in SystemVerilog assertions used for checking properties in simulation or formal verification environments.","
property p_data_and_parity;
    dataType l_data;
    parityType l_parity;
    start ##1
    (
        (dataValid, l_data = data, l_parity = parity)
        within complete[-1]
    )
    |-> parityOfX(l_data, l_parity);
endproperty
","""Verilog SVA (SystemVerilog Assertions) property example for data and parity check using local variables""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p337.jpg,True,"The code in the image is as follows:

Verilog code snippet for restrict property syntax:
```verilog
restrict property (property_spec); //Note, no action block.
```

Verilog code snippet for an example usage of restrict property:
```verilog
restrict property (@ (posedge clk) {x, y} == 2'b00);
```

Verilog abort properties syntax:
```verilog
accept_on (abort condition expression) property_expression
sync_accept_on (abort condition expression) property_expression
reject_on (abort condition expression) property_expression
sync_reject_on (abort condition expression) property_expression
```","
restrict property (property_spec); //Note, no action block.


restrict property (@ (posedge clk) {x, y} == 2'b00);


accept_on (abort condition expression) property_expression
sync_accept_on (abort condition expression) property_expression
reject_on (abort condition expression) property_expression
sync_reject_on (abort condition expression) property_expression
","""Text on Verilog Formal Verification using `restrict` keyword and explanation of abort properties such as `accept_on`, `sync_accept_on`, `reject_on`, and `sync_reject_on`.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p244.jpg,True,"```verilog
property p_tCO;
@(posedge clk)
(!sel_n[2] && we_n && !oe_n && 
  ($isunknown(data))) |=> 
  ($isunknown(data))==0;
endproperty

a_tCO: assert property(p_tCO);
c_tCO: cover property(p_tCO);
```","
property p_tCO;
@(posedge clk)
(!sel_n[2] && we_n && !oe_n && 
  ($isunknown(data))) |=> 
  ($isunknown(data))==0;
endproperty

a_tCO: assert property(p_tCO);
c_tCO: cover property(p_tCO);
","""Verilog Timing Check Property for SRAM Chip Select to Output Data Valid""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p167.jpg,True,"The image contains excerpts from a book or document that includes sample Verilog code. Here is the code present in the image:

```verilog
module atm_router(Rx_if.DUT Rx0, Rx1, Rx2, Rx3,
                  Tx_if.DUT Tx0, Tx1, Tx2, Tx3,
                  input logic clk, rst);
    ...
endmodule
```

```verilog
module top;
    bit clk, rst;
    always #5 clk = !clk;

    Rx_if Rx0 (clk), Rx1 (clk), Rx2 (clk), Rx3 (clk);
    Tx_if Tx0 (clk), Tx1 (clk), Tx2 (clk), Tx3 (clk);

    atm_router a1 (Rx0, Rx1, Rx2, Rx3,
                   Tx0, Tx1, Tx2, Tx3, clk, rst); // or just (.*)

    test t1 (Rx0, Rx1, Rx2, Rx3,
             Tx0, Tx1, Tx2, Tx3, clk, rst); // or just (.*)
endmodule : top
```

The code samples are provided for demonstration purposes within the context of the book, showing an example of an ATM router model with interfaces and a top-level module interface for an ATM router setup.","
module atm_router(Rx_if.DUT Rx0, Rx1, Rx2, Rx3,
                  Tx_if.DUT Tx0, Tx1, Tx2, Tx3,
                  input logic clk, rst);
    ...
endmodule


module top;
    bit clk, rst;
    always #5 clk = !clk;

    Rx_if Rx0 (clk), Rx1 (clk), Rx2 (clk), Rx3 (clk);
    Tx_if Tx0 (clk), Tx1 (clk), Tx2 (clk), Tx3 (clk);

    atm_router a1 (Rx0, Rx1, Rx2, Rx3,
                   Tx0, Tx1, Tx2, Tx3, clk, rst); // or just (.*)

    test t1 (Rx0, Rx1, Rx2, Rx3,
             Tx0, Tx1, Tx2, Tx3, clk, rst); // or just (.*)
endmodule : top
","Caption: Excerpts from documentation showing examples of Verilog code for an ATM router module and a top-level module with interfaces, demonstrating the use of modular programming in hardware description.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p451.jpg,True,"The image contains a snippet of text describing some Verilog concepts, specifically about ""covergroup"" and ""coverpoint"", but there is no complete code example that can be transcribed. The text appears to be from a technical document or a book explaining the basics of SystemVerilog coverpoints and contains annotations for further explanation, but no complete code blocks are present. 

The syntax provided at the bottom can be re-written as follows:

```verilog
cover_point ::=
[ [ data_type_or_implicit ] cover_point_identifier : ] coverpoint_expression [ iff (expression) ] bins_or_empty
```

This is a generic syntax definition for a cover_point in SystemVerilog.","
cover_point ::=
[ [ data_type_or_implicit ] cover_point_identifier : ] coverpoint_expression [ iff (expression) ] bins_or_empty
",Annotated educational content explaining the basics of SystemVerilog covergroups and coverpoints with example code and notes on usage.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p168.jpg,True,"```verilog
/* read current simulation time */
current_time.type = vpiScaledRealTime;
vpi_get_time(sysTf_handle, &current_time);

vpi_printf(""\nat time %2.2f, nets in module %s (%s):\n"",
           current_time.real,
           vpi_get_str(vpiFullName, module_handle),
           vpi_get_str(vpiDefName, module_handle));

/* obtain handles to nets in module and read current value */
net_iterator = vpi_iterate(vpiNet, module_handle);
if (net_iterator == NULL)
   vpi_printf("" no nets found in this module\n"");
else {
   current_value.format = vpiBinStrVal; /* read values as a string */
   while ( (net_handle = vpi_scan(net_iterator)) != NULL ) {
      vpi_get_value(net_handle, &current_value);
      vpi_printf("" net %-10s value is %s (binary)\n"",
                 vpi_get_str(vpiName, net_handle),
                 current_value.value.str;
   }
}
return(0);
}
```","
/* read current simulation time */
current_time.type = vpiScaledRealTime;
vpi_get_time(sysTf_handle, &current_time);

vpi_printf(""\nat time %2.2f, nets in module %s (%s):\n"",
           current_time.real,
           vpi_get_str(vpiFullName, module_handle),
           vpi_get_str(vpiDefName, module_handle));

/* obtain handles to nets in module and read current value */
net_iterator = vpi_iterate(vpiNet, module_handle);
if (net_iterator == NULL)
   vpi_printf("" no nets found in this module\n"");
else {
   current_value.format = vpiBinStrVal; /* read values as a string */
   while ( (net_handle = vpi_scan(net_iterator)) != NULL ) {
      vpi_get_value(net_handle, &current_value);
      vpi_printf("" net %-10s value is %s (binary)\n"",
                 vpi_get_str(vpiName, net_handle),
                 current_value.value.str;
   }
}
return(0);
}
","Example Verilog PLI code for reading simulation time and net values, with a table showing 4-state logic value encoding.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p250.jpg,True,"```verilog
endsequence

property p_read;
    @(negedge clk2x) s_read.matched |-> 
        ##3 ($isunknown (data))
        ##1 ($isunknown (data) == 0);
endproperty

a_read: assert property(p_read);
c_read: cover property(p_read);

sequence s_write;
    @(posedge clk)
    (ras_n && !sel_n[0] && !we_n && !cas_n);
endsequence
```","
endsequence

property p_read;
    @(negedge clk2x) s_read.matched |-> 
        ##3 ($isunknown (data))
        ##1 ($isunknown (data) == 0);
endproperty

a_read: assert property(p_read);
c_read: cover property(p_read);

sequence s_write;
    @(posedge clk)
    (ras_n && !sel_n[0] && !we_n && !cas_n);
endsequence
","""Verilog code example delineating read and write properties for DDR SDRAM operations, accompanied by a waveform diagram.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p323.jpg,True,"The image contains a snippet of Verilog code representing a test-bench. Here's the code from the image:

```verilog
module eventuallyP ( );
    bit clk, frame, b, c;

    property checkAB;
        @(posedge clk)
        c |-> s_eventually [2:5] $fell(frame_);
    endproperty

    delayD1: assert property (checkAB) else $display(""At %0tns eventually FAIL \n"",$stime);
    delayD1c: cover property (checkAB) $display(""At %0tns eventually PASS \n"",$stime);

    always begin #5ns clk=~clk; end

    initial
    begin
        clk=0;
        frame_=1; c=1;
        @(negedge clk) c=0;
        repeat (3) @(posedge clk);
        frame_=0;
        repeat (2) @(posedge clk);

        frame_=1; c=1;
        repeat (1) @(posedge clk);
        frame_=1; c=0;
        repeat (6) @(posedge clk);
        frame_=0;

        repeat (2) @(posedge clk) ;$finish(2);
    end

    initial $monitor($stime,,,""clk=%b frame_=%b c=%b"",clk,frame_,c);
endmodule
```

This Verilog module appears to simulate a property check within a digital system, using SystemVerilog assertions (SVA) to ensure that when the condition 'c' becomes true, 'frame_' must fall within 2 to 5 clock cycles afterward (`s_eventually [2:5] $fell(frame_)`). The module also includes some procedural blocks to generate a clock signal and test the property by manipulating the 'frame_' and 'c' variables. Additionally, the `$monitor` system call is used for observing changes in signal values during simulation.","
module eventuallyP ( );
    bit clk, frame, b, c;

    property checkAB;
        @(posedge clk)
        c |-> s_eventually [2:5] $fell(frame_);
    endproperty

    delayD1: assert property (checkAB) else $display(""At %0tns eventually FAIL \n"",$stime);
    delayD1c: cover property (checkAB) $display(""At %0tns eventually PASS \n"",$stime);

    always begin #5ns clk=~clk; end

    initial
    begin
        clk=0;
        frame_=1; c=1;
        @(negedge clk) c=0;
        repeat (3) @(posedge clk);
        frame_=0;
        repeat (2) @(posedge clk);

        frame_=1; c=1;
        repeat (1) @(posedge clk);
        frame_=1; c=0;
        repeat (6) @(posedge clk);
        frame_=0;

        repeat (2) @(posedge clk) ;$finish(2);
    end

    initial $monitor($stime,,,""clk=%b frame_=%b c=%b"",clk,frame_,c);
endmodule
","""Example of Verilog code demonstrating a test bench, temporal properties, and simulation log.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p278.jpg,True,"The image contains Verilog code related to assertions and properties in the context of hardware verification. Here is the code presented in the image:

```verilog
property p_mchk16;
@(posedge clk)
($rose (framen) && $fell (irdyn))
##1 $fell (framen) |->
$rose (irdyn);
endproperty

a_mchk16: assert property(p_mchk16);
c_mchk16: cover property(p_mchk16);

property p_mchk17;
@(posedge clk)
(!irdyn && framen)
##1 $fell (framen) |->
$rose (irdyn);
endproperty

a_mchk17: assert property(p_mchk17);
c_mchk17: cover property(p_mchk17);
```

This code snippet defines two properties, `p_mchk16` and `p_mchk17`, which are used to assert and cover specific conditions in the design under verification. It uses SystemVerilog assertion constructs such as `assert` and `cover` to check the timing and sequence of signals in relation to the positive edge of the clock (`posedge clk`).","
property p_mchk16;
@(posedge clk)
($rose (framen) && $fell (irdyn))
##1 $fell (framen) |->
$rose (irdyn);
endproperty

a_mchk16: assert property(p_mchk16);
c_mchk16: cover property(p_mchk16);

property p_mchk17;
@(posedge clk)
(!irdyn && framen)
##1 $fell (framen) |->
$rose (irdyn);
endproperty

a_mchk17: assert property(p_mchk17);
c_mchk17: cover property(p_mchk17);
",Example of SystemVerilog Assertions (SVA) for verifying fast back-to-back transactions in Verilog hardware description language.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p626.jpg,True,"The image contains Verilog code mixed with some C functions. The code is related to the Verilog Programming Language Interface (PLI), which allows for interaction between Verilog and C code within Verilog simulations. Here is the code present in the image:

```c
/* Read current values of C model inputs from Verilog simulation */
value_s.format = accRealVal;
acc_fetch_value(ALUdata->a_h, ""%f"", &value_s);
a = value_s.value.real;

acc_fetch_value(ALUdata->b_h, ""%f"", &value_s);
b = value_s.value.real;

value_s.format = accIntVal;
acc_fetch_value(ALUdata->opcode_h, ""%d"", &value_s);
opcode = value_s.value.integer;

/***** Call C model *****/
PLIbook_ScientificALU_C_model(0, a, b, opcode, &result, &excep, &err);

/* Write the C model outputs onto the Verilog signals */
delay_s.model = accNoDelay;
delay_s.time = time_s;
delay_s.time.type = accRealTime;
delay_s.time.real = 0.0;

value_s.format = accRealVal;
value_s.value.real = result;
acc_set_value(ALUdata->result_h, &value_s, &delay_s);

value_s.format = accIntVal;
value_s.value.integer = excep;
acc_set_value(ALUdata->excep_h, &value_s, &delay_s);

value_s.value.integer = err;
acc_set_value(ALUdata->err_h, &value_s, &delay_s);

acc_close();
return(0);
}

/***********************************************************************
* calltf routine: Registers a callback to the C model interface
* whenever the clock input to the C model changes value
***********************************************************************/
int PLIbook_ScientificALU_calltf()
{
    PLIbook_SciALU_data_p ALUdata;

    acc_initialize();

    ALUdata=(PLIbook_SciALU_data_p)malloc(sizeof(PLIbook_SciALU_data_s));

    /* get handles for all signals in Verilog which connect to C model */
    ALUdata->clock_h = acc_handle_tfarg(ALU_CLOCK);
    ALUdata->a_h = acc_handle_tfarg(ALU_A);
    ALUdata->b_h = acc_handle_tfarg(ALU_B);
```

Please note that the image only shows part of the code, which means it may be referencing variables, functions, and macros not fully defined within the visible portion of text. This code interacts with a C model and passes values between the Verilog simulation and the C model using the PLI.","ad current values of C model inputs from Verilog simulation */
value_s.format = accRealVal;
acc_fetch_value(ALUdata->a_h, ""%f"", &value_s);
a = value_s.value.real;

acc_fetch_value(ALUdata->b_h, ""%f"", &value_s);
b = value_s.value.real;

value_s.format = accIntVal;
acc_fetch_value(ALUdata->opcode_h, ""%d"", &value_s);
opcode = value_s.value.integer;

/***** Call C model *****/
PLIbook_ScientificALU_C_model(0, a, b, opcode, &result, &excep, &err);

/* Write the C model outputs onto the Verilog signals */
delay_s.model = accNoDelay;
delay_s.time = time_s;
delay_s.time.type = accRealTime;
delay_s.time.real = 0.0;

value_s.format = accRealVal;
value_s.value.real = result;
acc_set_value(ALUdata->result_h, &value_s, &delay_s);

value_s.format = accIntVal;
value_s.value.integer = excep;
acc_set_value(ALUdata->excep_h, &value_s, &delay_s);

value_s.value.integer = err;
acc_set_value(ALUdata->err_h, &value_s, &delay_s);

acc_close();
return(0);
}

/***********************************************************************
* calltf routine: Registers a callback to the C model interface
* whenever the clock input to the C model changes value
***********************************************************************/
int PLIbook_ScientificALU_calltf()
{
    PLIbook_SciALU_data_p ALUdata;

    acc_initialize();

    ALUdata=(PLIbook_SciALU_data_p)malloc(sizeof(PLIbook_SciALU_data_s));

    /* get handles for all signals in Verilog which connect to C model */
    ALUdata->clock_h = acc_handle_tfarg(ALU_CLOCK);
    ALUdata->a_h = acc_handle_tfarg(ALU_A);
    ALUdata->b_h = acc_handle_tfarg(ALU_B);
","""Example of Verilog PLI code for interfacing Verilog simulations with a C model, showing how to read and write signal values.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p45.jpg,True,"```verilog
/*** A gate level 1 bit adder model ***/
`timescale 1ns / 1ns
module addbit (a, b, ci, sum, co);
  input  a, b, ci;
  output sum, co;
  wire a, b, ci, sum, co,
       n1, n2, n3;

  xor
       (n1, a, b);
  xor #2 (sum, n1, ci);
  and
       (n2, a, b);
  and
       (n3, n1, ci);
  or #2 (co, n2, n3);
endmodule
```","
/*** A gate level 1 bit adder model ***/
`timescale 1ns / 1ns
module addbit (a, b, ci, sum, co);
  input  a, b, ci;
  output sum, co;
  wire a, b, ci, sum, co,
       n1, n2, n3;

  xor
       (n1, a, b);
  xor #2 (sum, n1, ci);
  and
       (n2, a, b);
  and
       (n3, n1, ci);
  or #2 (co, n2, n3);
endmodule
",A page from a book showing Verilog code for a one-bit adder and its test simulation output using Verilog-XL.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p140.jpg,True,"Here is the Verilog code from the image:

```verilog
module dff (clk, d, q, qb);
    input  clk, d;
    output q, qb;

    wire clk, d, q, qb;
    ...
endmodule
```

This code represents a module declaration for a D flip-flop in Verilog. The module is named `dff` and has inputs `clk` and `d` for the clock and data signals, respectively. It also has outputs `q` and its complement `qb`. The internal wire declarations repeat the same signal names, allowing for connections inside the module, which would be detailed in the ellipses portion of the code.","
module dff (clk, d, q, qb);
    input  clk, d;
    output q, qb;

    wire clk, d, q, qb;
    ...
endmodule
","Excerpt from ""The Verilog PLI Handbook"" detailing hierarchy traversal across module ports with an example Verilog code module and an explanation of `lowconn` and `highconn` connections.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p157.jpg,True,"The image contains Verilog code. Here it is:

```verilog
a3: assert property (@(posedge clk) disable iff (rst) a);

a4: assert property (@(posedge clk)
    disable iff ($sampled(rst)) a);

a1: assert property (@(posedge clk) a)
    else $error(""Error: a = \b%b."", a);

a2: assert property (@(posedge clk) a)
    else $error(""Error: a = \b%b."", $sampled(a));
```

These are code snippets demonstrating the use of assertions with the Verilog hardware description language, including the use of system functions `$sampled` and `$past`.","
a3: assert property (@(posedge clk) disable iff (rst) a);

a4: assert property (@(posedge clk)
    disable iff ($sampled(rst)) a);

a1: assert property (@(posedge clk) a)
    else $error(""Error: a = \b%b."", a);

a2: assert property (@(posedge clk) a)
    else $error(""Error: a = \b%b."", $sampled(a));
","""Understanding the use of $sampled function in Verilog assertions and its effect on error reporting.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p154.jpg,True,"The image contains a snippet of Verilog code related to the Verilog Procedural Interface (VPI). Here is the code transcribed from the image:

```verilog
vpi_get_vlog_info(&sim_info);

/* get system function arg--completef already verified correctness */
systf_h = vpi_handle(vpiSysTfCall, NULL);
arg_itr = vpi_iterate(vpiArgument, systf_h);
arg_h = vpi_scan(arg_itr);
vpi_free_object(arg_itr); /* free iterator -- did not scan to null */

/* read target option name from first tfarg */
value_s.format = vpiStringVal;
vpi_get_value(arg_h, &value_s);
option_name = value_s.value.str;

/* test for target option and return true/false to system function */
found = PLIbook_GetOptions(option_name,sim_info.argc,sim_info.argv);
value_s.format = vpiIntVal;
value_s.value.integer = found;
vpi_put_value(systf_h, &value_s, NULL, vpiNoDelay);
return(0);
}

int PLIbook_optfound = 0; /* global variable for option found flag */
int PLIbook_indent = 0; /* global variable to format text indenting */

int PLIbook_GetOptions(char *option, int argc, char **argv)
{
    int i;
    PLIbook_optfound = 0;
    PLIbook_indent = 0;
    for (i=0; i<argc; i++) {
        #ifdef PLIbook_verbose
        vpi_printf(""%s\n"", *argv);
        #endif
        if (strcmp(*argv, option) == 0) {
            PLIbook_optfound = 1;
        }
        if (strcmp(*argv, ""-f"") == 0) {
            argv++; /* next arg is address to array of strings */
            i++;
            PLIbook_ScanCommandLine(option, (char **)argv);
        }
        argv++; /* increment to next argument */
    }
    return(PLIbook_optfound);
}

void PLIbook_ScanCommandLine(char *option, char **arg)
{
    int i;

    #ifdef PLIbook_verbose
    PLIbook_indent += 4; /* increase text indentation */
```

This code demonstrates how to interact with Verilog simulation information and to get and set options via the VPI layer. Note that the function definitions for `PLIbook_GetOptions` and `PLIbook_ScanCommandLine` are incomplete, as the image doesn't show the entire contents.","
vpi_get_vlog_info(&sim_info);

/* get system function arg--completef already verified correctness */
systf_h = vpi_handle(vpiSysTfCall, NULL);
arg_itr = vpi_iterate(vpiArgument, systf_h);
arg_h = vpi_scan(arg_itr);
vpi_free_object(arg_itr); /* free iterator -- did not scan to null */

/* read target option name from first tfarg */
value_s.format = vpiStringVal;
vpi_get_value(arg_h, &value_s);
option_name = value_s.value.str;

/* test for target option and return true/false to system function */
found = PLIbook_GetOptions(option_name,sim_info.argc,sim_info.argv);
value_s.format = vpiIntVal;
value_s.value.integer = found;
vpi_put_value(systf_h, &value_s, NULL, vpiNoDelay);
return(0);
}

int PLIbook_optfound = 0; /* global variable for option found flag */
int PLIbook_indent = 0; /* global variable to format text indenting */

int PLIbook_GetOptions(char *option, int argc, char **argv)
{
    int i;
    PLIbook_optfound = 0;
    PLIbook_indent = 0;
    for (i=0; i<argc; i++) {
        #ifdef PLIbook_verbose
        vpi_printf(""%s\n"", *argv);
        #endif
        if (strcmp(*argv, option) == 0) {
            PLIbook_optfound = 1;
        }
        if (strcmp(*argv, ""-f"") == 0) {
            argv++; /* next arg is address to array of strings */
            i++;
            PLIbook_ScanCommandLine(option, (char **)argv);
        }
        argv++; /* increment to next argument */
    }
    return(PLIbook_optfound);
}

void PLIbook_ScanCommandLine(char *option, char **arg)
{
    int i;

    #ifdef PLIbook_verbose
    PLIbook_indent += 4; /* increase text indentation */
","An excerpt from ""The Verilog PLI Handbook"" showing code to parse simulation options using the Verilog Procedural Interface (VPI).",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p143.jpg,True,"The image contains text describing concepts related to finite and infinite repetition ranges in a context that seems related to formal verification or hardware design. However, there is no actual Verilog code on this page. The closest item is a mathematical or conceptual representation of the repetition ranges, which is not Verilog code but rather an explanation of the syntax and meaning of these constructs in a formal description:

```
s[∗n:m]  ≡  s[∗n].
s[∗n:m]  ≡  s[∗n:m−1]  or  s[∗n], m < n.
```

```
s[∗0:$]  ≡  s[∗0]  or  s[∗1:$].
s[∗n:$]  ≡  s[∗n−1]  ##1  s[∗1:$], n > 1.
```

These representations are not executable Verilog code but help explain sequence repetition syntax for someone using temporal logic or similar formalisms, typically used in assertions for hardware verification.","]  ≡  s[∗n].
s[∗n:m]  ≡  s[∗n:m−1]  or  s[∗n], m < n.

]  ≡  s[∗0]  or  s[∗1:$].
s[∗n:$]  ≡  s[∗n−1]  ##1  s[∗1:$], n > 1.
","This image contains excerpts discussing finite and infinite repetition ranges in Verilog code, along with an efficiency tip and an explanation of repetition shorthand syntax.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p51.jpg,True,"Here's the Verilog code from the image:

```verilog
always @(posedge clock)
    if (chip_out !== $pow(base,exponent))
        ...

initial
    $monitor(""output = %f"", $pow(base,exponent));

assign temp = i + $pow(base,exponent);
```

And the code example explaining the system task/function arguments:

```verilog
module top (...);
    ...
    reg [15:0] in1;
    ...
    my_chip u1 (in1, out1);
    ...
    initial
        $cell_count(u1);
    ...
    always @(posedge clock)
        $read_vector_file(""vectors.pat"", in1);
    ...
endmodule
```

The code snippets provided in the image are demonstrating how to use Verilog with certain system functions and tasks and how to pass arguments to them.","
always @(posedge clock)
    if (chip_out !== $pow(base,exponent))
        ...

initial
    $monitor(""output = %f"", $pow(base,exponent));

assign temp = i + $pow(base,exponent);


module top (...);
    ...
    reg [15:0] in1;
    ...
    my_chip u1 (in1, out1);
    ...
    initial
        $cell_count(u1);
    ...
    always @(posedge clock)
        $read_vector_file(""vectors.pat"", in1);
    ...
endmodule
",Verilog code excerpts demonstrating the use of $pow function and system task/function arguments in a simulation environment.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p632.jpg,True,"Here is the code present in the image:

```c
/***************************************************************
 * Definition for a structure to store output values when the ALU is
 * latched. When enable is 1, the ALU returns the currently calculated
 * outputs, and when 0, the ALU returns the latched previous results.
 ***************************************************************/
#include <stdio.h>
typedef struct Plibook_SciALUoutputs *PLIbook_SciALUoutputs_p;
typedef struct Plibook_SciALUoutputs {
    char *instance_p; /* shows which task instance owns this space */
    double result;    /* stored result of previous operation */
```

The code snippet includes a comment describing a C structure used for storing output values of a latched ALU (Arithmetic Logic Unit) in a scientific application. It demonstrates how to create a pointer type to this structure and how to define the structure, which includes a character pointer `instance_p` to indicate the owning task instance and a `double` type `result` to store the result of a previous operation.","***********************************************************
 * Definition for a structure to store output values when the ALU is
 * latched. When enable is 1, the ALU returns the currently calculated
 * outputs, and when 0, the ALU returns the latched previous results.
 ***************************************************************/
#include <stdio.h>
typedef struct Plibook_SciALUoutputs *PLIbook_SciALUoutputs_p;
typedef struct Plibook_SciALUoutputs {
    char *instance_p; /* shows which task instance owns this space */
    double result;    /* stored result of previous operation */
",Example of Verilog PLI for a scientific ALU with latched outputs.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p287.jpg,True,"The image contains Verilog code. Here's the text for the code:

```verilog
sequence s_tchk7;
@(posedge clk)
first_match(s_tchk7a and s_tchk7b);
endsequence

property p_tchk7;
@(posedge clk) s_tchk7.ended |=> framen;
endproperty

a_tchk7: assert property(p_tchk7);
c_tchk7: cover property(p_tchk7);
```

The text also includes some description of how the sequence and property are used in the context of the SystemVerilog Assertions (SVA) for a protocol interface.","
sequence s_tchk7;
@(posedge clk)
first_match(s_tchk7a and s_tchk7b);
endsequence

property p_tchk7;
@(posedge clk) s_tchk7.ended |=> framen;
endproperty

a_tchk7: assert property(p_tchk7);
c_tchk7: cover property(p_tchk7);
","""Excerpt from a document showing Verilog code for a sequence and a property used in SystemVerilog Assertions (SVA) for protocol interface, along with a waveform diagram demonstrating a PCI target check.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p365.jpg,True,"There is no actual Verilog code in the image; this is a segment from a document describing the syntax for PSL (Property Specification Language) which often accompanies Verilog for formal verification purposes. 

The content in the image is specifying the grammar for various PSL constructs, such as `assert` statements, `assume` statements, and so on. Here's the text detailing the syntax:

```
Assert_Statement                ::= 
    assert Property [ report String ];(see B.8.3.4)
Assume_Statement                ::= 
    assume Property ;(see B.8.3.4)
Assume_Guarantee_Statement      ::= 
    assume_guarantee Property [ report String ];(see B.8.3.4)
Restrict_Statement              ::= 
    restrict Sequence ; (see A.3.5)
Restrict_Guarantee_Statement    ::= 
    restrict_guarantee Sequence [ report String]; (see A.3.5)
Cover_Statement                 ::= 
    cover Sequence [ report String ];(see B.8.3.5)
Fairness_Statement              ::= 
    fairness Boolean;
    | Strong fairness Boolean , Boolean ;(see B.8.3.7)

B.8.3.4 PSL properties

Property                        ::= 
    Replicator Property
    | FL_Property
    | OBE_Property
Replicator                      ::= 
    forall Name [ IndexRange ] in ValueSet :
IndexRange                      ::= 
    LEFT_SYM finite_Range RIGHT_SYM
    |('' HDL_RANGE'')
ValueSet                        ::= 
    { ValueRange { , ValueRange } }
    | boolean
ValueRange                      ::= 
    Value (see B.8.3.7)
    | FiniteRange(see B.8.3.5)
FL_Property                     ::= 
    Boolean (see B.8.3.7)
    | ( FL_Property )
    | Sequence [!]
    | property_Name [ ( Actual_Parameter_List ) ]
    | FL_Property @ CLOCK_EXPRESSION
    | FL_Property abort Boolean

: Logical Operators :
```

This syntax is not executable code, but rather a formal representation of how certain statements and expressions should be composed when writing PSL for use with hardware description languages like Verilog.","_Statement                ::= 
    assert Property [ report String ];(see B.8.3.4)
Assume_Statement                ::= 
    assume Property ;(see B.8.3.4)
Assume_Guarantee_Statement      ::= 
    assume_guarantee Property [ report String ];(see B.8.3.4)
Restrict_Statement              ::= 
    restrict Sequence ; (see A.3.5)
Restrict_Guarantee_Statement    ::= 
    restrict_guarantee Sequence [ report String]; (see A.3.5)
Cover_Statement                 ::= 
    cover Sequence [ report String ];(see B.8.3.5)
Fairness_Statement              ::= 
    fairness Boolean;
    | Strong fairness Boolean , Boolean ;(see B.8.3.7)

B.8.3.4 PSL properties

Property                        ::= 
    Replicator Property
    | FL_Property
    | OBE_Property
Replicator                      ::= 
    forall Name [ IndexRange ] in ValueSet :
IndexRange                      ::= 
    LEFT_SYM finite_Range RIGHT_SYM
    |('' HDL_RANGE'')
ValueSet                        ::= 
    { ValueRange { , ValueRange } }
    | boolean
ValueRange                      ::= 
    Value (see B.8.3.7)
    | FiniteRange(see B.8.3.5)
FL_Property                     ::= 
    Boolean (see B.8.3.7)
    | ( FL_Property )
    | Sequence [!]
    | property_Name [ ( Actual_Parameter_List ) ]
    | FL_Property @ CLOCK_EXPRESSION
    | FL_Property abort Boolean

: Logical Operators :
",PSL (Property Specification Language) syntax and properties for formal verification in hardware design described in Verilog.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p492.jpg,True,"The image contains Verilog code. Here it is:

```verilog
bit[3:0] adr1;

covergroup cg @(posedge clk);
    ac: coverpoint adr1
    {
        ignore_bins igvalues0 = {[4,5]};
        ignore_bins igvalues1 = {[6:15]};
    }
endgroup
gc gcInst = new();
```

And the second snippet on the page is:

```verilog
covergroup cg1 @(posedge clk);
    coverpoint a {
        bins b[] = {0, 1, 2, 3};
        ignore_bins ignore_vals = {0, 3} iff ctd;
    }
endgroup
```","
bit[3:0] adr1;

covergroup cg @(posedge clk);
    ac: coverpoint adr1
    {
        ignore_bins igvalues0 = {[4,5]};
        ignore_bins igvalues1 = {[6:15]};
    }
endgroup
gc gcInst = new();


covergroup cg1 @(posedge clk);
    coverpoint a {
        bins b[] = {0, 1, 2, 3};
        ignore_bins ignore_vals = {0, 3} iff ctd;
    }
endgroup
","Caption: ""Demonstrating the use of 'ignore_bins' in Verilog for excluding specific values from coverage in a covergroup.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p486.jpg,True,"Here is the Verilog code extracted from the image:

```verilog
bit[7:0] adr1;
bit adr2;

covergroup cg @(posedge clk);
  ac: coverpoint adr1
  {
    bins ar1 = (8'h00 => 8'hff);
  }
  dc: coverpoint adr2
  {
    bins ar2 = (1'b1 => 1'b0);
  }

  accd: cross ac,dc;
endgroup
gc gcInst = new;
```

This code snippet is an example of system Verilog code for functional coverage, specifically for transition coverage using covergroups and coverpoints.","
bit[7:0] adr1;
bit adr2;

covergroup cg @(posedge clk);
  ac: coverpoint adr1
  {
    bins ar1 = (8'h00 => 8'hff);
  }
  dc: coverpoint adr2
  {
    bins ar2 = (1'b1 => 1'b0);
  }

  accd: cross ac,dc;
endgroup
gc gcInst = new;
","Caption: ""Example of Verilog code defining coverage bins for transition coverage analysis to ensure that certain state transitions are exercised in the verification process.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p293.jpg,True,"The image contains verilog code. Here is the code excerpt from the image:

```verilog
sequence s_tchk11a;
    @(posedge clk)
        ($fell(framen) && (cxben[1:0] == 2'b10));
endsequence

sequence s_tchk11b;
    @(posedge clk)
```

The code defines two sequences in SystemVerilog Assertion (SVA), which is a part of the IEEE SystemVerilog standard used for specifying properties and assertions about hardware designs. The sequences are typically used in formal verification or simulation to check the correctness of a hardware design against its specification.","
sequence s_tchk11a;
    @(posedge clk)
        ($fell(framen) && (cxben[1:0] == 2'b10));
endsequence

sequence s_tchk11b;
    @(posedge clk)
","""Example of a SystemVerilog Assertion (SVA) for a PCI protocol interface with waveform simulation and explanation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p371.jpg,True,"The image contains no executable code but rather a keyword and operator tables for Verilog assertions. Here is the text from the tables:

Keyword Table
Keywords specific to assertions sequences, properties and templates.

```
property       endproperty       sequence         endsequence
and            or                intersect        within
throughout     first_match       ended            matched
assert         assume            cover
```

Operator table

```
Name                        Operator          Description
Consecutive repetition      s1 [* N:M]        Repetition of s1 N, or 
                                              between N to M times.

Goto repetition            s1 [-> N:M]       Repetition of s1 (N to M 
                                              times) in nonconsecutive 
                                              cycles, ending on s1.

Nonconsecutive repetition  s1 [= N:M]        Repetition of s1 N to M 
                                              times in nonconsecutive 
                                              cycles, maybe ending on 
                                              s1.

Temporal delay             # # N             Concatenation of two 
                            ## [N:M]         sequence elements.

Not                         not p1           Invert result of evaluation 
                                              of the property.

And                         s1 and s2        Both sequence/properties 
                            p1 and p2        occur at some time.

Intersection                s1 intersect s2  Both sequences occur at 
                                              the same time.

Or                          s1 or s2         Either sequence/property 
                            p1 or p2         occurs.

Condition                   if (expr) p1     Based on evaluation of 
                            if (expr) p1     expr, evaluate property p1 
                            else p2          if true, or p2 if false.

Boolean until               b throughout s1  B must be true until 
                                              sequence s1 completes 
                                              (results in a match).

Within                      s1 within s2     s1 and s2 must occur. 
                                              Lengths of s1 and s2 must 
                                              follow s1 <= s2.

Ended                        s1.ended        Sequence s1 matched 
                                              (ended) at this time.

Matched (from different     s1.matched       Sequence s1 (on another 
clock domain)                                 clock) ended at this time.

First match                  first_match (s1) First occurrence of 
                                               sequence, rest ignored.
```

Page number at the bottom suggests this is from a book or a manual, specifically page 354, titled ""Assertion-Based Design.""","ty       endproperty       sequence         endsequence
and            or                intersect        within
throughout     first_match       ended            matched
assert         assume            cover

                      Operator          Description
Consecutive repetition      s1 [* N:M]        Repetition of s1 N, or 
                                              between N to M times.

Goto repetition            s1 [-> N:M]       Repetition of s1 (N to M 
                                              times) in nonconsecutive 
                                              cycles, ending on s1.

Nonconsecutive repetition  s1 [= N:M]        Repetition of s1 N to M 
                                              times in nonconsecutive 
                                              cycles, maybe ending on 
                                              s1.

Temporal delay             # # N             Concatenation of two 
                            ## [N:M]         sequence elements.

Not                         not p1           Invert result of evaluation 
                                              of the property.

And                         s1 and s2        Both sequence/properties 
                            p1 and p2        occur at some time.

Intersection                s1 intersect s2  Both sequences occur at 
                                              the same time.

Or                          s1 or s2         Either sequence/property 
                            p1 or p2         occurs.

Condition                   if (expr) p1     Based on evaluation of 
                            if (expr) p1     expr, evaluate property p1 
                            else p2          if true, or p2 if false.

Boolean until               b throughout s1  B must be true until 
                                              sequence s1 completes 
                                              (results in a match).

Within                      s1 within s2     s1 and s2 must occur. 
                                              Lengths of s1 and s2 must 
                                              follow s1 <= s2.

Ended                        s1.ended        Sequence s1 matched 
                                              (ended) at this time.

Matched (from different     s1.matched       Sequence s1 (on another 
clock domain)                                 clock) ended at this time.

First match                  first_match (s1) First occurrence of 
                                               sequence, rest ignored.
","""Reference tables showing Verilog assertion keywords and operators for assertion-based design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p194.jpg,True,"There is code in this image. Here it is:

```verilog
sequence s_def(a, event b, int c, d, untyped s);
```

Additional expressions which resemble code in the context of the sequence definition and explanation are:

```verilog
b ##1 s
```

```verilog
(a + c == d) ##1 s
```

```verilog
posedge clk
```

```verilog
((2'b11 + v) + 1 == 0) ##1 v
```

These are excerpts of Verilog code and related expressions provided in the image as part of explanations related to sequence interface and expressions in Verilog.","
sequence s_def(a, event b, int c, d, untyped s);


b ##1 s


(a + c == d) ##1 s


posedge clk


((2'b11 + v) + 1 == 0) ##1 v
","""Verilog Sequence and Property Declarations with Examples of Sequence Expressions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p236.jpg,True,"```verilog
module b (p, w, x, y, z);
  input [7:0] w, x, y, z;
  output [7:0] p;
  wire [7:0] p, w, x, y, z;
  assign p = (w | x) & (y | z);
endmodule // b
```","
module b (p, w, x, y, z);
  input [7:0] w, x, y, z;
  output [7:0] p;
  wire [7:0] p, w, x, y, z;
  assign p = (w | x) & (y | z);
endmodule // b
","Caption: ""An excerpt from a Verilog reference detailing expressions and operators, including a code example of a Verilog module performing bitwise operations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p198.jpg,True,"The image contains code written in Verilog, specifically related to classes and object copying. Here's the code from the image:

```verilog
class Transaction;
    bit [31:0] addr, csm, data[8];
    static int count = 0;
    int id;
    Statistics stats;  // Handle points to Statistics object

    function new();
        stats = new();  // Construct a new Statistics object
        id = count++;
    endfunction
endclass

Transaction src, dst;
initial begin
    src = new();                // Create a Transaction object
    src.stats.startT = 42;      // Results in Figure 5-5
    dst = new src;              // Copy src to dst with new operator
                                // Results in Figure 5-6
    dst.stats.startT = 96;      // Changes stats for dst & src
    $display(src.stats.startT); // 96, see Figure 5-7
end
```

This code snippet shows how a class named `Transaction` is defined and how objects of this class are copied. It demonstrates a situation where copying an object containing a handle to another object (referred to as `stats` in the code) results in a shallow copy, sharing the same `Statistics` object between both `Transaction` objects. The code includes a static variable `count` that is used to assign a unique `id` to each new `Transaction` object created, incrementing with each new object.","
class Transaction;
    bit [31:0] addr, csm, data[8];
    static int count = 0;
    int id;
    Statistics stats;  // Handle points to Statistics object

    function new();
        stats = new();  // Construct a new Statistics object
        id = count++;
    endfunction
endclass

Transaction src, dst;
initial begin
    src = new();                // Create a Transaction object
    src.stats.startT = 42;      // Results in Figure 5-5
    dst = new src;              // Copy src to dst with new operator
                                // Results in Figure 5-6
    dst.stats.startT = 96;      // Changes stats for dst & src
    $display(src.stats.startT); // 96, see Figure 5-7
end
","A textbook page explaining the concept of shallow copying in object-oriented programming, using a Verilog example.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p86.jpg,True,"```c
vpiHandle systf_handle, arg_iterator, arg_handle;
int tfarg_type;

systf_handle = vpi_handle(vpiSysTfCall, NULL);
arg_iterator = vpi_iterate(vpiArgument, systf_handle);
arg_handle = vpi_scan(arg_iterator);
tfarg_type = vpi_get(vpiType, arg_handle);
if (tfarg_type != vpiModule) {
    /* report error that argument is not correct */
}
```","ndle systf_handle, arg_iterator, arg_handle;
int tfarg_type;

systf_handle = vpi_handle(vpiSysTfCall, NULL);
arg_iterator = vpi_iterate(vpiArgument, systf_handle);
arg_handle = vpi_scan(arg_iterator);
tfarg_type = vpi_get(vpiType, arg_handle);
if (tfarg_type != vpiModule) {
    /* report error that argument is not correct */
}
","""Excerpt from The Verilog PLI Handbook, showing Verilog code that uses the VPI library to check object type properties in simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p92.jpg,True,"```verilog
/* show_all_nets Registration Data
 * (add this function name to the vlog_startup_routines array)
 ****************************************************************/
void PLIbook_ShowNets_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type      = vpiSysTask;
    tf_data.tfname    = ""$show_all_nets"";
    tf_data.calltf    = PLIbook_ShowNets_calltf;
    tf_data.compiletf = PLIbook_ShowNets_compiletf;
    tf_data.sizetf    = NULL;
    vpi_register_systf(&tf_data);
    return;
}

/****************************************************************
 * compiletf routine
 ****************************************************************/
int PLIbook_ShowNets_compiletf(char *user_data)
{
    vpiHandle systf_handle, arg_iterator, arg_handle;
    int       tfarg_type;

    /* obtain a handle to the system task instance */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handles to system task arguments */
    arg_iterator = vpi_iterate(vpiArgument, systf_handle);
    if (arg_iterator == NULL) {
        vpi_printf(""ERROR: $show_all_nets requires 1 argument\n"");
        tf_do_finish(); /* abort simulation */
        return(0);
    }

    /* check the type of object in system task arguments */
    arg_handle = vpi_scan(arg_iterator);
    tfarg_type = vpi_get(vpiType, arg_handle);
    if (tfarg_type != vpiModule) {
        vpi_printf(""ERROR: $show_all_nets arg1 must be module instance\n"");
        vpi_free_object(arg_iterator); /* free iterator memory */
        tf_do_finish(); /* abort simulation */
        return(0);
    }

    /* check that there is only 1 system task argument */
    arg_handle = vpi_scan(arg_iterator);
    if (arg_handle != NULL) {
        vpi_printf(""ERROR: $show_all_nets can only have 1 argument\n"");
        vpi_free_object(arg_iterator); /* free iterator memory */
        tf_do_finish(); /* abort simulation */
        return (0);
    }
}
```","
/* show_all_nets Registration Data
 * (add this function name to the vlog_startup_routines array)
 ****************************************************************/
void PLIbook_ShowNets_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type      = vpiSysTask;
    tf_data.tfname    = ""$show_all_nets"";
    tf_data.calltf    = PLIbook_ShowNets_calltf;
    tf_data.compiletf = PLIbook_ShowNets_compiletf;
    tf_data.sizetf    = NULL;
    vpi_register_systf(&tf_data);
    return;
}

/****************************************************************
 * compiletf routine
 ****************************************************************/
int PLIbook_ShowNets_compiletf(char *user_data)
{
    vpiHandle systf_handle, arg_iterator, arg_handle;
    int       tfarg_type;

    /* obtain a handle to the system task instance */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handles to system task arguments */
    arg_iterator = vpi_iterate(vpiArgument, systf_handle);
    if (arg_iterator == NULL) {
        vpi_printf(""ERROR: $show_all_nets requires 1 argument\n"");
        tf_do_finish(); /* abort simulation */
        return(0);
    }

    /* check the type of object in system task arguments */
    arg_handle = vpi_scan(arg_iterator);
    tfarg_type = vpi_get(vpiType, arg_handle);
    if (tfarg_type != vpiModule) {
        vpi_printf(""ERROR: $show_all_nets arg1 must be module instance\n"");
        vpi_free_object(arg_iterator); /* free iterator memory */
        tf_do_finish(); /* abort simulation */
        return(0);
    }

    /* check that there is only 1 system task argument */
    arg_handle = vpi_scan(arg_iterator);
    if (arg_handle != NULL) {
        vpi_printf(""ERROR: $show_all_nets can only have 1 argument\n"");
        vpi_free_object(arg_iterator); /* free iterator memory */
        tf_do_finish(); /* abort simulation */
        return (0);
    }
}
",Verilog PLI Code Snippet for Registering and Validating a System Task,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p197.jpg,True,"```
$midpd_delays(<port_name>, <t_rise>, <t_fall>, <t_toz>);

Example:
$midpd_delays(in1, 2.7, 2.2, 1.0);
```","_delays(<port_name>, <t_rise>, <t_fall>, <t_toz>);

Example:
$midpd_delays(in1, 2.7, 2.2, 1.0);
","Caption: An excerpt from a document explaining how to use the VPI routines in Verilog for writing delays into an object, along with an example of the `$mipd_delays` function call to add delays to an input port of a module.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p243.jpg,True,"The image contains Verilog code. Here it is:

```verilog
sequence e6(f);
    @(posedge clk_e2) f;
endsequence

a3: assert property (@(posedge clk_a) a |=> e6(e4.triggered));

always @(posedge clk_a) begin
    @(e4); d = a;
end
```

This code snippet includes a sequence declaration, an assertion, and an always block.","
sequence e6(f);
    @(posedge clk_e2) f;
endsequence

a3: assert property (@(posedge clk_a) a |=> e6(e4.triggered));

always @(posedge clk_a) begin
    @(e4); d = a;
end
","Verilog code demonstrating the use of sequences, assertions, and clocking in a hardware description context.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p330.jpg,True,"The image shows a page from a text, likely a textbook or technical document, about Verilog. There is a small amount of Verilog code present:

```verilog
parameter start_wait = 2
parameter repetition = 3
```

These lines define two parameters, presumably to be used in a Verilog module or testbench. The `start_wait` parameter is set to 2, and the `repetition` parameter is set to 3. The context suggests these parameters relate to generating waveforms or controlling the timing of test conditions.","
parameter start_wait = 2
parameter repetition = 3
",Waveform diagrams for 'repeat after' and 'repeat until' conditions in a Verilog testbench context.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p324.jpg,True,"The image conveys a section from a document or textbook about system-level verification using SystemVerilog or a similar hardware description and verification language. Here is the code from the image:

```verilog
$fell(a) |-> ##[min_time : max_time] $fell(b);
endproperty

// on a given clock edge, if the leading signal
// has a rising edge, then within ""min_time"" to
// ""max_time"" cycles the trailing signal must
// have a rising edge

property p6_w_rr;
    @(posedge clk)
    $rose(a) |-> ##[min_time : max_time] $rose(b);
endproperty

// on a given clock edge, if the leading signal
// has a falling edge, then within ""min_time"" to
// ""max_time"" cycles the trailing signal must
// have a rising edge

property p6_w_fr;
    @(posedge clk)
    $fell(a) |-> ##[min_time : max_time] $rose(b);
endproperty

// on a given clock edge, if the leading signal
// has a rising edge, then within ""min_time"" to
// ""max_time"" cycles the trailing signal must
// have a falling edge

property p6_w_rf;
    @(posedge clk)
    $rose(a) |-> ##[min_time : max_time] $fell(b);
endproperty

a6_w_rr: assert property(p6_w_rr);
a6_w_ff: assert property(p6_w_ff);
a6_w_rf: assert property(p6_w_rf);
a6_w_fr: assert property(p6_w_fr);
```

This code specifies various properties with temporal assertions. It demonstrates the use of immediate assertions and properties in SystemVerilog to check the temporal relationship between two signals (a and b) relative to each other after a clock edge on 'clk'. The `'##[min_time : max_time]` notation indicates a delay range within which the second event should occur after the first event. The `$fell`, `$rose`, and `assert property` constructs are part of the SystemVerilog Assertions (SVA) feature of the language.","
$fell(a) |-> ##[min_time : max_time] $fell(b);
endproperty

// on a given clock edge, if the leading signal
// has a rising edge, then within ""min_time"" to
// ""max_time"" cycles the trailing signal must
// have a rising edge

property p6_w_rr;
    @(posedge clk)
    $rose(a) |-> ##[min_time : max_time] $rose(b);
endproperty

// on a given clock edge, if the leading signal
// has a falling edge, then within ""min_time"" to
// ""max_time"" cycles the trailing signal must
// have a rising edge

property p6_w_fr;
    @(posedge clk)
    $fell(a) |-> ##[min_time : max_time] $rose(b);
endproperty

// on a given clock edge, if the leading signal
// has a rising edge, then within ""min_time"" to
// ""max_time"" cycles the trailing signal must
// have a falling edge

property p6_w_rf;
    @(posedge clk)
    $rose(a) |-> ##[min_time : max_time] $fell(b);
endproperty

a6_w_rr: assert property(p6_w_rr);
a6_w_ff: assert property(p6_w_ff);
a6_w_rf: assert property(p6_w_rf);
a6_w_fr: assert property(p6_w_fr);
",Verilog code snippet with temporal assertions checking signal timing relationships.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p257.jpg,True,"The image contains some Verilog code written as part of the text. Here is the code that is visible in the image:

```verilog
dcheck : assert property (data_check(aff1.wr_ptr)) else
    $display($stime,,,""FAIL: DATA CHECK"");
dcheckc : cover property (data_check(aff1.wr_ptr))
    $display($stime,,,""PASS: DATA CHECK"");
```

This code snippet shows two assertions in SystemVerilog, which are using the `assert` and `cover` keywords to define properties that should be checked during simulation of the design. The `$display` system function is used to output a message with a timestamp depending on whether the assertion passed or failed.","
dcheck : assert property (data_check(aff1.wr_ptr)) else
    $display($stime,,,""FAIL: DATA CHECK"");
dcheckc : cover property (data_check(aff1.wr_ptr))
    $display($stime,,,""PASS: DATA CHECK"");
","Caption: ""Verilog code snippet demonstrating the use of assertions for automated Clock Domain Crossing (CDC) verification along with a flow diagram of the verification methodology.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p519.jpg,True,"Here is the Verilog code present in the image:

```verilog
covergroup cg (int xb, yb) ;
  coverpoint x {bins xbins[] = { [0:xb] }; }
  coverpoint y {bins ybins[] = { [0:yb] }; }
endgroup
cg cv1 = new (1,2); // cv1.x has 2 bins, cv1.y has 3 bins
cg cv2 = new (3,6); // cv2.x has 4 bins, cv2.y has 7 bins
initial begin
  cv1.x.get_inst_coverage(covered, total); // total = 2 :: Coverage for coverpoint instance 'x'
  cv1.get_inst_coverage(covered, total); // total = 5 :: Coverage for covergroup instance 'cv1'
  for: covergroup instance 'cv1'
    cg::x::get_coverage(covered, total); // total = 6 :: Coverage for all instances of Coverpoint 'x'
  cg::get_coverage(covered, total); // total = 16 :: Coverage for all instances of covergroup 'cg'
end
```","
covergroup cg (int xb, yb) ;
  coverpoint x {bins xbins[] = { [0:xb] }; }
  coverpoint y {bins ybins[] = { [0:yb] }; }
endgroup
cg cv1 = new (1,2); // cv1.x has 2 bins, cv1.y has 3 bins
cg cv2 = new (3,6); // cv2.x has 4 bins, cv2.y has 7 bins
initial begin
  cv1.x.get_inst_coverage(covered, total); // total = 2 :: Coverage for coverpoint instance 'x'
  cv1.get_inst_coverage(covered, total); // total = 5 :: Coverage for covergroup instance 'cv1'
  for: covergroup instance 'cv1'
    cg::x::get_coverage(covered, total); // total = 6 :: Coverage for all instances of Coverpoint 'x'
  cg::get_coverage(covered, total); // total = 16 :: Coverage for all instances of covergroup 'cg'
end
","Caption: Extract from a technical document detailing the usage of the `get_coverage` and `get_inst_coverage` methods in Verilog coverage analysis, with accompanying code examples.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p318.jpg,True,"The image contains Verilog code that appears to be discussing properties for checking timing relationships between signals in what might be a digital design verification context. Here is the code from the image:

```verilog
// clock cycles the trailing signal is low
property p3_w2_hl;
  @(posedge clk) a ## [min_time : max_time] !b;
endproperty

// On a given clock edge, the leading signal is
// low and between ""min_time"" and ""max_time""
// clock cycles the trailing signal is high
property p3_w3_lh;
  @(posedge clk) !a ## [min_time : max_time] b;
endproperty

// On a given clock edge, the leading signal is
// low and between ""min_time"" and ""max_time""
// clock cycles the trailing signal is low
property p3_w4_ll;
  @(posedge clk) !a ## [min_time : max_time] !b;
endproperty

a3_w1: assert property(p3_w1_hh);
a3_w2: assert property(p3_w2_hl);
a3_w3: assert property(p3_w3_lh);
a3_w4: assert property(p3_w4_ll);

// On a given clock edge, if the leading signal
// is high, then after ""min_time"" clock cycles
// the trailing signal must be high
property p5_f_hh;
  @(posedge clk) a |-> ##min_time b;
endproperty

// On a given clock edge, if the leading signal
// is high, then after ""min_time"" clock cycles
// the trailing signal must be low
property p5_f_hl;
  @(posedge clk) a |-> ##min_time !b;
endproperty
```

These are formal property declarations using SystemVerilog Assertions (SVA). The properties describe various timing constraints and relationships between a pair of signals `a` and `b` in relation to clock edges (posedge clk). After the property declarations, there are `assert` statements that invoke these properties to ensure that the defined conditions hold true in the design.","
// clock cycles the trailing signal is low
property p3_w2_hl;
  @(posedge clk) a ## [min_time : max_time] !b;
endproperty

// On a given clock edge, the leading signal is
// low and between ""min_time"" and ""max_time""
// clock cycles the trailing signal is high
property p3_w3_lh;
  @(posedge clk) !a ## [min_time : max_time] b;
endproperty

// On a given clock edge, the leading signal is
// low and between ""min_time"" and ""max_time""
// clock cycles the trailing signal is low
property p3_w4_ll;
  @(posedge clk) !a ## [min_time : max_time] !b;
endproperty

a3_w1: assert property(p3_w1_hh);
a3_w2: assert property(p3_w2_hl);
a3_w3: assert property(p3_w3_lh);
a3_w4: assert property(p3_w4_ll);

// On a given clock edge, if the leading signal
// is high, then after ""min_time"" clock cycles
// the trailing signal must be high
property p5_f_hh;
  @(posedge clk) a |-> ##min_time b;
endproperty

// On a given clock edge, if the leading signal
// is high, then after ""min_time"" clock cycles
// the trailing signal must be low
property p5_f_hl;
  @(posedge clk) a |-> ##min_time !b;
endproperty
","Caption: ""Excerpt from a textbook showing Verilog code that defines timing properties and assertions for signal relationships in hardware verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p211.jpg,True,"This image contains Verilog code within the context of an example on a textbook or document page. The code is related to assertions in Verilog and SystemVerilog. Here is the Verilog code from the image:

```verilog
// OVL assertion
// assert that ack must occur within 100 cycles after a req.
assert_frame #(0,100) req_ack (clk, 1, req, ack);
```

This is followed by SystemVerilog code, which provides a similar assertion using SystemVerilog syntax:

```systemverilog
// declarative assertion
assert property (@ (posedge clk) disable iff (reset_n)
                 (req |-> ##[1:100] ack) else
                 $error (""ack did not occur within 100 cycles after req"");
```

The surrounding text provides context and explanation for the assertions, indicating their purpose within verification for hardware design.","
// OVL assertion
// assert that ack must occur within 100 cycles after a req.
assert_frame #(0,100) req_ack (clk, 1, req, ack);

erilog
// declarative assertion
assert property (@ (posedge clk) disable iff (reset_n)
                 (req |-> ##[1:100] ack) else
                 $error (""ack did not occur within 100 cycles after req"");
","""Verilog and SystemVerilog assert examples for time limit sequence checks and event-bounded window pattern discussions from Assertion-Based Design document.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p280.jpg,True,"The image contains Verilog code. Here is the code as visible in the image:

On the left side:
```verilog
property pr1;
    @(posedge clk) req |-> ##2 gnt;
endproperty

reqGnt: assert property (pr1) else failtask;

task failtask;
    $display($stime,, ""FROM failtask - 0"");
    @(posedge clk) $display($stime,, ""FROM failtask - 1"");
    @(posedge clk) $display($stime,, ""FROM failtask - 2"");
    @(posedge clk) $display($stime,, ""FROM failtask - 3"");
    @(posedge clk) $display($stime,, ""FROM failtask - 4"");
endtask
```

On the right side, it's slightly obscured but likely symmetric to the left side and is most likely to have similar if not identical code:
```verilog
property pr1;
    @(posedge clk) req |-> ##2 gnt;
endproperty

reqGnt: assert property (pr1) else failtask;

task failtask;
    $display($stime,, ""FROM failtask - 0"");
endtask
``` 

This code is part of a discussion on nested implications in properties within Verilog syntax, showcasing an example and simulation output.","
property pr1;
    @(posedge clk) req |-> ##2 gnt;
endproperty

reqGnt: assert property (pr1) else failtask;

task failtask;
    $display($stime,, ""FROM failtask - 0"");
    @(posedge clk) $display($stime,, ""FROM failtask - 1"");
    @(posedge clk) $display($stime,, ""FROM failtask - 2"");
    @(posedge clk) $display($stime,, ""FROM failtask - 3"");
    @(posedge clk) $display($stime,, ""FROM failtask - 4"");
endtask


property pr1;
    @(posedge clk) req |-> ##2 gnt;
endproperty

reqGnt: assert property (pr1) else failtask;

task failtask;
    $display($stime,, ""FROM failtask - 0"");
endtask
","Caption: ""Explanation of the intricacies of using nested implications in Verilog properties with an example of a simulation log highlighting potential pitfalls.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p123.jpg,True,"The image contains Verilog code. Here is the code extracted from the image:

```verilog
...
always@( ClockIn, Reset ) // This is the synchronizing clock.
begin
  if (Reset=='b1)
  begin
    AdjustFreq = 2'b01;
    VarClockCount = 2'b01;
  end
  else // CounterClock is the clock to synchronize. Notice that it
       // is not on the sensitivity list; the inferred latch may be
       // expected to cause synthesis problems.
  if (CounterClock=='b1)
    VarClockCount = VarClockCount + 2'b01;
  else begin
    case (VarClockCount)
      2'b00: AdjustFreq = 2'b11; // Better speed it up.
      2'b01: AdjustFreq = 2'b01; // Seems matched.
      default: AdjustFreq = 2'b00; // Better slow it down.
    endcase
    VarClockCount = 2'b00; // Initialize for next ClockIn edge.
  end
end
```

This code snippet appears to be part of a clock synchronization mechanism in a digital system, possibly a phase-locked loop (PLL) control system. The `always` block is triggered by changes in `ClockIn` and `Reset` signals. The logical operations within address synchronization to a reference clock (`CounterClock`) by adjusting an `AdjustFreq` value based on the value of `VarClockCount`. The mention of a potential inferred latch due to the absence of `CounterClock` in the sensitivity list implies that synthesis tools could interpret part of the code as a latch instead of the intended logic, which could lead to issues during the synthesis of the Verilog code to a hardware description.","
...
always@( ClockIn, Reset ) // This is the synchronizing clock.
begin
  if (Reset=='b1)
  begin
    AdjustFreq = 2'b01;
    VarClockCount = 2'b01;
  end
  else // CounterClock is the clock to synchronize. Notice that it
       // is not on the sensitivity list; the inferred latch may be
       // expected to cause synthesis problems.
  if (CounterClock=='b1)
    VarClockCount = VarClockCount + 2'b01;
  else begin
    case (VarClockCount)
      2'b00: AdjustFreq = 2'b11; // Better speed it up.
      2'b01: AdjustFreq = 2'b01; // Seems matched.
      default: AdjustFreq = 2'b00; // Better slow it down.
    endcase
    VarClockCount = 2'b00; // Initialize for next ClockIn edge.
  end
end
","Caption: ""Extract from a technical document illustrating Verilog code for a clock comparator module used to handle variable clock edges within a synchronizing system.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p221.jpg,True,"```verilog
constraint ab {

`ifdef VENDOR_A
  solve a before b hard; // add proprietary 'hard' specification
`else
  solve a before b;
`endif

if (a inside {32, 64, 128, 256})
  a == b;
else
  a > b;
)
```","
constraint ab {

`ifdef VENDOR_A
  solve a before b hard; // add proprietary 'hard' specification
`else
  solve a before b;
`endif

if (a inside {32, 64, 128, 256})
  a == b;
else
  a > b;
)
","Caption: ""Exploring Verilog Code Conditional Compilation and Proprietary Extensions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p137.jpg,True,"```verilog
xor (^) operator. For example,

reg [HiBit:0] DataVector; // One bit narrower than DataWithParity.
reg [HiBit+1:0] DataWithParity;
...
// Compute and store parity value:
DataWithParity = {^DataVector, DataVector};
// Check parity on read:
DataVector = (DataWithParity[HiBit+1]==1'b0) // '0' means good parity.
             ? DataWithParity // DataVector discards MSB parity bit.
             : 'bx; // Assign all '1'x' on parity error.
```
This is the code segment from the image related to parity checking and handling in Verilog.","
xor (^) operator. For example,

reg [HiBit:0] DataVector; // One bit narrower than DataWithParity.
reg [HiBit+1:0] DataWithParity;
...
// Compute and store parity value:
DataWithParity = {^DataVector, DataVector};
// Check parity on read:
DataVector = (DataWithParity[HiBit+1]==1'b0) // '0' means good parity.
             ? DataWithParity // DataVector discards MSB parity bit.
             : 'bx; // Assign all '1'x' on parity error.
","""Excerpt on parity checking in digital VLSI design with an example of Verilog code for computing and storing parity.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p294.jpg,True,"The image contains Verilog code, which is associated with RTL (Register Transfer Level) design. The code provided is for an asynchronous FIFO (First-In-First-Out) module. Here is the code that is visible in the image:

```verilog
module asynchronous_fifo (
    // Outputs
    fifo_out, full, empty,
    // Inputs
    wclk, wclk_reset_n, write_en,
    rclk, rclk_reset_n, read_en,
    fifo_in
);

`define FF_DLY 1'b1
parameter D_WIDTH = 20;
parameter D_DEPTH = 4;
parameter A_WIDTH = 2;

input               wclk_reset_n;
input               rclk_reset_n;
input               wclk;
input               rclk;
input               write_en;
input               read_en;
input [D_WIDTH-1:0] fifo_in;

output [D_WIDTH-1:0] fifo_out;
output              full;
output              empty;

reg [D_WIDTH-1:0] reg_mem[0:D_DEPTH-1];
reg [A_WIDTH:0]   wr_ptr;
reg [A_WIDTH:0]   wr_ptr_gray;
reg [A_WIDTH:0]   wr_ptr_gray_rclk_q;
reg [A_WIDTH:0]   wr_ptr_gray_rclk_q2;
reg [A_WIDTH:0]   rd_ptr;
```

The code snippet defines the module `asynchronous_fifo` with its inputs, outputs, and some internal register declarations. It also includes parameters for defining data width, FIFO depth, and an address width. It appears that the code is part of a textbook or a printed material discussing the design and assertions for an asynchronous FIFO in Verilog. However, the complete code is not provided in this image.","
module asynchronous_fifo (
    // Outputs
    fifo_out, full, empty,
    // Inputs
    wclk, wclk_reset_n, write_en,
    rclk, rclk_reset_n, read_en,
    fifo_in
);

`define FF_DLY 1'b1
parameter D_WIDTH = 20;
parameter D_DEPTH = 4;
parameter A_WIDTH = 2;

input               wclk_reset_n;
input               rclk_reset_n;
input               wclk;
input               rclk;
input               write_en;
input               read_en;
input [D_WIDTH-1:0] fifo_in;

output [D_WIDTH-1:0] fifo_out;
output              full;
output              empty;

reg [D_WIDTH-1:0] reg_mem[0:D_DEPTH-1];
reg [A_WIDTH:0]   wr_ptr;
reg [A_WIDTH:0]   wr_ptr_gray;
reg [A_WIDTH:0]   wr_ptr_gray_rclk_q;
reg [A_WIDTH:0]   wr_ptr_gray_rclk_q2;
reg [A_WIDTH:0]   rd_ptr;
","Caption: ""Excerpt from a textbook showing the introduction and partial Verilog code for an asynchronous FIFO design with gray code counters for read and write pointers.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p205.jpg,True,"The image contains two snippets of code. Here is the first code snippet:

```verilog
// declarative assertion
assert property ( @(posedge clk) disable iff (reset_n)
    not ($past(invalidate) & hit))
else $error(""Cache hit occurred while previous invalidate active"");
```

And the second code snippet:

```verilog
// declarative assertion
// assert that address will not change values after a request is made.
assert always (!req_valid -> prev(addr)==addr) @(posedge clk);
```

The text describes these as examples of SystemVerilog and PSL (Property Specification Language) past event patterns used for declarative assertions in hardware description and verification.","
// declarative assertion
assert property ( @(posedge clk) disable iff (reset_n)
    not ($past(invalidate) & hit))
else $error(""Cache hit occurred while previous invalidate active"");


// declarative assertion
// assert that address will not change values after a request is made.
assert always (!req_valid -> prev(addr)==addr) @(posedge clk);
","Caption: ""Examples of System Verilog and PSL assertions for verifying past event patterns in hardware design, demonstrating illegal cache transactions and checking for stable signals.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p209.jpg,True,"The image contains Verilog code which is written as follows:

```verilog
property p_req_ack2;
  @(posedge clk)
    $rose(req) |-> ##[1:$] $rose(ack) ##1 $rose(done); // GOTCHA!
endproperty

property p_req_ack2;
  @(posedge clk)
    $rose(req) |-> ##[1:5] $rose(ack) ##[1:$] $rose(done); // GOTCHA!
endproperty
```","
property p_req_ack2;
  @(posedge clk)
    $rose(req) |-> ##[1:$] $rose(ack) ##1 $rose(done); // GOTCHA!
endproperty

property p_req_ack2;
  @(posedge clk)
    $rose(req) |-> ##[1:5] $rose(ack) ##[1:$] $rose(done); // GOTCHA!
endproperty
","""Understanding Assertion Gotchas in Verilog with Examples of Non-Failing Assertions Due to Open-Ended Delays""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p239.jpg,True,"The image includes a snippet of Verilog code. Here it is transcribed:

```verilog
...
// width is the width of the data being piped
// depth is the number of pipe stages
parameter WIDTH=4;
parameter DEPTH=3;
parameter N = WIDTH*DEPTH; // size of register * # stages
reg [N-1:0] pipeline;

wire [WIDTH-1:0] data_in;
// output upper bits (WIDTH) of the pipe
wire [WIDTH-1:0] data_out = pipeline[N-1:N-WIDTH];

always @(posedge clk) begin
    if (flush)
        pipeline <= {(N){1'b0}};
    else // shift value in pipe
        if (!stall)
            pipeline <= {pipeline[N-1-WIDTH:0], data_in[WIDTH-1:0]};
end
```

This code defines a simple pipeline register system in Verilog using parameters for width and depth, a register to hold the pipeline data, and some combinational logic to handle flushing (clearing) and stalling (holding) the pipeline state.","
...
// width is the width of the data being piped
// depth is the number of pipe stages
parameter WIDTH=4;
parameter DEPTH=3;
parameter N = WIDTH*DEPTH; // size of register * # stages
reg [N-1:0] pipeline;

wire [WIDTH-1:0] data_in;
// output upper bits (WIDTH) of the pipe
wire [WIDTH-1:0] data_out = pipeline[N-1:N-WIDTH];

always @(posedge clk) begin
    if (flush)
        pipeline <= {(N){1'b0}};
    else // shift value in pipe
        if (!stall)
            pipeline <= {pipeline[N-1-WIDTH:0], data_in[WIDTH-1:0]};
end
","Caption: ""Example code for a simple Verilog pipeline register with a flush and stall mechanism.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p132.jpg,True,"Here is the Verilog code present in the image:

```verilog
property p_target_datain;
  @(posedge clk)
    ($fell(trdy) ##3 (datain[8])) |-> 
    not ($isunknown(datain)) [*7];
endproperty

property p_target_dataout;
  @(posedge clk)
    ($fell(trdy) ##3 (!datain[8])) |=> 
    not ($isunknown(dataout)) [*7];
endproperty
```

The code is defining two properties using SystemVerilog Assertions (SVA), typically used to define certain conditions or aspects of the design that must always be true.

The other snippet of the Verilog code in the image is:

```verilog
module target(....);

// port declarations

parameter target_sva = 1'b1;
parameter target_sva_severity = 1'b1;

// target design description
// target SVA property description
// SVA Checks

always@(posedge clk)
begin
  if(target_sva)
  begin
    a_sel_trdy_start:
      assert property(p_sel_trdy_start)
  end
end

// more code could be following
```

This code represents the skeleton of a Verilog module for a hardware design, where some parameters are set, and it includes a procedural block (`always`) that handles an assertion check based on the clock edge (`posedge clk`). Note that the comment `// more code could be following` indicates that this is not the complete code, and there is probably additional code not captured in this image snippet.","
property p_target_datain;
  @(posedge clk)
    ($fell(trdy) ##3 (datain[8])) |-> 
    not ($isunknown(datain)) [*7];
endproperty

property p_target_dataout;
  @(posedge clk)
    ($fell(trdy) ##3 (!datain[8])) |=> 
    not ($isunknown(dataout)) [*7];
endproperty


module target(....);

// port declarations

parameter target_sva = 1'b1;
parameter target_sva_severity = 1'b1;

// target design description
// target SVA property description
// SVA Checks

always@(posedge clk)
begin
  if(target_sva)
  begin
    a_sel_trdy_start:
      assert property(p_sel_trdy_start)
  end
end

// more code could be following
","""Excerpt from a document illustrating Verilog SystemVerilog Assertion (SVA) properties and methodology for simulation checks in hardware design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p490.jpg,True,"There is no complete code in the image, but there are snippets and references to code. Here are the snippets from the image:

1. Module instantiation:
```verilog
module MemBIST_Tst(...)
module Mem
```

2. Describing a sequence of test values:
```
32'h0e0e_0e0e, 32'h1e1e_1e1e, ..., 32'hffff_ffff.
```

The text discusses how to simulate Verilog code for a memory test bench (MemBIST_Tst.v) and references a memory module file (Mem.v). The discussion details the requirements for writing a memory Built-In Self-Test (BIST). It then outlines example test patterns to validate the memory hardware by writing and reading different values.","
module MemBIST_Tst(...)
module Mem

0e_0e0e, 32'h1e1e_1e1e, ..., 32'hffff_ffff.
","Page from a textbook on Digital VLSI Design with Verilog, detailing a Built-In Self-Test (BIST) for memory modules with example Verilog code snippets.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p126.jpg,True,"The image contains Verilog code written in the SystemVerilog Assertions (SVA) format. Here are the code snippets presented in the image:

```verilog
property p_sel_1;
    @(posedge clk)
        (rsel1 || rsel2 || rsel3) |=> sel == 2'b10;
endproperty

property p_sel_0;
    @(posedge clk)
        (!rsel1 && !rsel2 && !rsel3) |=> sel == 2'b01;
endproperty

property p_rsel1_write;
    @(posedge clk)
        ((rsel1 || !rsel1) ##3 ($fell(trdy[1]) || $fell(trdy[0])) ##3 data[8]) |-> 
            (data == $past(data1)) [*7];
endproperty
```

These snippets are assertions that check the behavior of the glue logic in hardware description.","
property p_sel_1;
    @(posedge clk)
        (rsel1 || rsel2 || rsel3) |=> sel == 2'b10;
endproperty

property p_sel_0;
    @(posedge clk)
        (!rsel1 && !rsel2 && !rsel3) |=> sel == 2'b01;
endproperty

property p_rsel1_write;
    @(posedge clk)
        ((rsel1 || !rsel1) ##3 ($fell(trdy[1]) || $fell(trdy[0])) ##3 data[8]) |-> 
            (data == $past(data1)) [*7];
endproperty
","Caption: ""Excerpt from a document detailing SVA (SystemVerilog Assertions) simulation methodology for glue logic verification with sample properties written in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p578.jpg,True,"The image contains two snippets of Verilog code. Here is the code extracted from the image:

1.
```verilog
bufif1 g1 (...);
```

2.
```verilog
bufif1 #5 g2 (...);
```","
bufif1 g1 (...);


bufif1 #5 g2 (...);
","""Verilog Delay Values and ACC Routines in HDL Design""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p209.jpg,True,"The image contains the following Verilog code:

```verilog
assert property(@clk disable iff (rst) req |-> nexttime[n] gnt);
```

It also contains another snippet of code:

```verilog
checker request_granted(sequence req, property gnt,
    untyped n = 1, string msg = """");
event clk = $inferred_clock, untyped rst = $inferred_disable);
default clocking @clk; endclocking
default disable iff rst;
a1: assert property(req |-> nexttime[n] gnt) else $error(msg);
endchecker : request_granted
```

These are examples of code snippets demonstrating syntax for assertions and checker declarations in Verilog.","
assert property(@clk disable iff (rst) req |-> nexttime[n] gnt);


checker request_granted(sequence req, property gnt,
    untyped n = 1, string msg = """");
event clk = $inferred_clock, untyped rst = $inferred_disable);
default clocking @clk; endclocking
default disable iff rst;
a1: assert property(req |-> nexttime[n] gnt) else $error(msg);
endchecker : request_granted
","Caption: ""Excerpt discussing checker declaration and argument types in Verilog, alongside an example of a Verilog assertion with checker usage.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p205.jpg,True,"The image contains an example of a basic Verilog class called ""Transactor"". Here is the code presented in the image:

```verilog
class Transactor; // Generic class
    Transaction tr;

    task run();
        forever begin
            // Get transaction from upstream block
            ...
            // Do some processing
            ...
            // Send it to downstream block
            ...
        end
    endtask

endclass
```

The code provided is a simplified example and is not complete; it contains ellipses (...) to denote that details are omitted.","
class Transactor; // Generic class
    Transaction tr;

    task run();
        forever begin
            // Get transaction from upstream block
            ...
            // Do some processing
            ...
            // Send it to downstream block
            ...
        end
    endtask

endclass
","""Example of a Basic Transactor Class in Verilog for Object-Oriented Programming in Testbench Development""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p236.jpg,True,"```c
if ((fscanf(StimData->file_ptr, ""%d %s\n"", &delay, vector)) == EOF) {
    /* At EOF, schedule ReadStimEnd callback at end of this time */
    time_s.type = vpiSimTime;
    time_s.low = 0;
    time_s.high = 0;
    data_s.reason = cbReadOnlySynch;
    data_s.cb_rtn = PLIbook_ReadStimEnd;
    data_s.obj = NULL;
    data_s.time = &time_s;
    data_s.value = NULL;
    data_s.user_data = (char *)StimData->file_ptr;
    vpi_register_cb(&data_s);
}

if (StimData->debug) {
    vpi_printf(""Values read from file: delay=%d vector=%s\n"",
        delay, vector);
}

/* convert absolute delay from file to relative delay if needed */
time_s.type = vpiScaledRealTime;
if (StimData->mode == 0 || StimData->mode == 2) {
    vpi_get_time(cb_data->obj, &time_s);
    time_s.real = ((double)delay - time_s.real);
} else {
    time_s.real = (double)delay;
}

/* schedule the vector to be applied after the delay period */
if (StimData->mode == 0 || StimData->mode == 1) {
    value_s.format = vpiBinStrVal;
} else {
    value_s.format = vpiHexStrVal;
}
value_s.value.str = vector;
vpi_put_value(StimData->obj_h, &value_s, &time_s, vpiTransportDelay);

/* schedule callback to this routine when time to read next vector */
data_s.reason = cbAfterDelay;
data_s.cb_rtn = PLIbook_ReadNextStim;
data_s.obj = systf_h; /* object required for scaled delays */
data_s.time = &time_s;
data_s.value = NULL;
data_s.user_data = (char *)systf_h;
vpi_register_cb(&data_s);
if (vpi_chk_error(NULL))
    vpi_printf(""An error occurred registering ReadNextStim callback\n"");
return(0);
}

/**********************************************************************
* StartOfSim callback -- opens the test vector file and saves the
* file pointer and other info in an instance-specific work area.
**********************************************************************/
```
This is a snippet of C code intermixed with Verilog Procedural Interface (VPI) calls. The code seems to be used for reading stimuli from a file and scheduling them to stimulate a model in a Verilog simulation at different times, depending on the delay read from the file. It includes checks for end-of-file, debug printing, deals with different modes regarding absolute or relative delays, formats for binary and hexadecimal strings, and registers callbacks for simulation events.","fscanf(StimData->file_ptr, ""%d %s\n"", &delay, vector)) == EOF) {
    /* At EOF, schedule ReadStimEnd callback at end of this time */
    time_s.type = vpiSimTime;
    time_s.low = 0;
    time_s.high = 0;
    data_s.reason = cbReadOnlySynch;
    data_s.cb_rtn = PLIbook_ReadStimEnd;
    data_s.obj = NULL;
    data_s.time = &time_s;
    data_s.value = NULL;
    data_s.user_data = (char *)StimData->file_ptr;
    vpi_register_cb(&data_s);
}

if (StimData->debug) {
    vpi_printf(""Values read from file: delay=%d vector=%s\n"",
        delay, vector);
}

/* convert absolute delay from file to relative delay if needed */
time_s.type = vpiScaledRealTime;
if (StimData->mode == 0 || StimData->mode == 2) {
    vpi_get_time(cb_data->obj, &time_s);
    time_s.real = ((double)delay - time_s.real);
} else {
    time_s.real = (double)delay;
}

/* schedule the vector to be applied after the delay period */
if (StimData->mode == 0 || StimData->mode == 1) {
    value_s.format = vpiBinStrVal;
} else {
    value_s.format = vpiHexStrVal;
}
value_s.value.str = vector;
vpi_put_value(StimData->obj_h, &value_s, &time_s, vpiTransportDelay);

/* schedule callback to this routine when time to read next vector */
data_s.reason = cbAfterDelay;
data_s.cb_rtn = PLIbook_ReadNextStim;
data_s.obj = systf_h; /* object required for scaled delays */
data_s.time = &time_s;
data_s.value = NULL;
data_s.user_data = (char *)systf_h;
vpi_register_cb(&data_s);
if (vpi_chk_error(NULL))
    vpi_printf(""An error occurred registering ReadNextStim callback\n"");
return(0);
}

/**********************************************************************
* StartOfSim callback -- opens the test vector file and saves the
* file pointer and other info in an instance-specific work area.
**********************************************************************/
",Verilog PLI code for handling simulation input stimuli with scheduled callback functions.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p221.jpg,True,"Here is the Verilog code from the image:

```verilog
bind module_name checker_name checker_inst (args);
```

```verilog
bind module_inst checker_name checker_inst (args);
```

```verilog
bind module_name: module_inst_1, ..., module_inst_n
checker_name checker_inst(args);
```

```verilog
module top;
  logic clock, snda, sndb, sndc, rcva, rcvb, rcvc;
  ...
  trans ta(clock, snda, rcva);
  trans tb(clock, sndb, rcvb);
  trans t2(clock, sndc, rcvc);
endmodule : top

module trans #(DEL=1) (input logic clock, in,
                       output logic out);
  if (DEL == 1) begin : b
    always @(posedge clock)
      out <= in;
  end
  else begin : b
    logic [DEL - 2:0] tmp;
    always @(posedge clock) begin
      tmp[0] <= in;
      for (int i = 1; i < DEL - 1; i++)
        tmp[i] <= tmp[i - 1];
    end
  end
endmodule
``` 

These snippets show how to use the `bind` directive in SystemVerilog to bind a checker to module instances and a Verilog module definition for a module named `trans` with a parameterized delay `DEL`.","
bind module_name checker_name checker_inst (args);


bind module_inst checker_name checker_inst (args);


bind module_name: module_inst_1, ..., module_inst_n
checker_name checker_inst(args);


module top;
  logic clock, snda, sndb, sndc, rcva, rcvb, rcvc;
  ...
  trans ta(clock, snda, rcva);
  trans tb(clock, sndb, rcvb);
  trans t2(clock, sndc, rcvc);
endmodule : top

module trans #(DEL=1) (input logic clock, in,
                       output logic out);
  if (DEL == 1) begin : b
    always @(posedge clock)
      out <= in;
  end
  else begin : b
    logic [DEL - 2:0] tmp;
    always @(posedge clock) begin
      tmp[0] <= in;
      for (int i = 1; i < DEL - 1; i++)
        tmp[i] <= tmp[i - 1];
    end
  end
endmodule
","""Verilog Code Example and Explanation of Checker Binding in SystemVerilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p183.jpg,True,"```verilog
dff_xc reg_erj_last (
  .q(erj_last),
  .q_x(erj_last_n),
  .ck(ck),
  .d(ci_erj_last),
  .reset_n(reset_n),
  .i_scan(i_scan)
);
```","
dff_xc reg_erj_last (
  .q(erj_last),
  .q_x(erj_last_n),
  .ck(ck),
  .d(ci_erj_last),
  .reset_n(reset_n),
  .i_scan(i_scan)
);
","""Verilog Register Instantiation and Discussion on User Task/Function Naming Conventions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p547.jpg,True,"The image contains two snippets of code. Here they are:

Snippet 1:
```verilog
assign v = e;
assume property (@global_clock v === e);
```

Snippet 2:
```verilog
rand bit v;
bit a;
...
assign v = a;
a1: assert property (@$global_clock v == a);
```
Please note that the ellipsis (`...`) on line 3 in the second snippet indicates that there may be some omitted content, or it is just a placeholder for other code not shown in this example.","
assign v = e;
assume property (@global_clock v === e);


rand bit v;
bit a;
...
assign v = a;
a1: assert property (@$global_clock v == a);
","""Discussion on the limitations of free variables in Verilog simulations and their assignment semantics, with a code example illustrating the issue.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p550.jpg,True,"The image shows text with function prototypes related to ACC (Application Call Interface) routines used in Verilog. Here are the prototypes:

```verilog
handle acc_handle_tfinst()
```

```verilog
double acc_fetch_itfarg(n, tfinst)
int     n               // position number of a PLI system task/function arg.
handle  tfinst          // handle for an instance of a PLI system task/function
```

```verilog
int acc_fetch_itfarg_int(n, tfinst)
int     n               // position number of a PLI system task/function arg.
handle  tfinst          // handle for an instance of a PLI system task/function
```

```verilog
char *acc_fetch_itfarg_str(n, tfinst)
int     n               // position number of a PLI system task/function arg.
handle  tfinst          // handle for an instance of a PLI system task/function
```

```verilog
handle acc_handle_itfarg(n, tfinst)
int     n               // position number of a PLI system task/function argument.
handle  tfinst          // handle for an instance of a PLI system task/function
```

These are not complete code examples with implementation details, but only the prototypes for certain functions that can be used in Verilog PLI applications to interact with system tasks or functions within simulation environments.","
handle acc_handle_tfinst()


double acc_fetch_itfarg(n, tfinst)
int     n               // position number of a PLI system task/function arg.
handle  tfinst          // handle for an instance of a PLI system task/function


int acc_fetch_itfarg_int(n, tfinst)
int     n               // position number of a PLI system task/function arg.
handle  tfinst          // handle for an instance of a PLI system task/function


char *acc_fetch_itfarg_str(n, tfinst)
int     n               // position number of a PLI system task/function arg.
handle  tfinst          // handle for an instance of a PLI system task/function


handle acc_handle_itfarg(n, tfinst)
int     n               // position number of a PLI system task/function argument.
handle  tfinst          // handle for an instance of a PLI system task/function
","""Excerpt from a textbook on ACC (Access) Routines in Verilog for reading and modifying system task/function values""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p553.jpg,True,"The image contains two sections of code. Below is the first section from the top of the page, which seems to be a Verilog code snippet:

```verilog
checker gen_mutex(output bit out1, out2);
    default clocking @($global_clock); endclocking
    rand bit x, y;
    m1: assume property($onehot0({x, y}));
    assign {out1, out2} = {x, y};
endchecker : gen_mutex
```

And here's the second section of code from the bottom of the page:

```Verilog
typedef enum logic[1:0] {
    txa_data    = 2'b10,
    txa_control = 2'b01,
    txa_void    = 2'b00,
    txa_forbid  = 2'b11
} txa_t;
```

These snippets are from a text discussing checkers as generators in the context of Verilog/SystemVerilog hardware description and verification language.","
checker gen_mutex(output bit out1, out2);
    default clocking @($global_clock); endclocking
    rand bit x, y;
    m1: assume property($onehot0({x, y}));
    assign {out1, out2} = {x, y};
endchecker : gen_mutex


typedef enum logic[1:0] {
    txa_data    = 2'b10,
    txa_control = 2'b01,
    txa_void    = 2'b00,
    txa_forbid  = 2'b11
} txa_t;
",Synthesizable testbench example using Verilog checker construction to generate mutually exclusive stimuli.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p33.jpg,True,"Here is the Verilog code from the image:

For concurrent assertion:
```verilog
a_cc: assert property(@(posedge clk) not (a && b));
```

For immediate assertion:
```verilog
always_comb
begin
  a_ia: assert (a && b);
end
```","
a_cc: assert property(@(posedge clk) not (a && b));


always_comb
begin
  a_ia: assert (a && b);
end
","Caption: ""Example of a concurrent assertion and its waveform in Verilog, along with an explanation of immediate assertions in digital design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p239.jpg,True,"The image contains text and a snippet of code in Verilog, a hardware description language. The code is from a sample demonstrating how to include an external constraint in a class. Here's the code:

```verilog
// packet.sv
class Packet;
    rand bit [7:0] length;
    rand bit [7:0] payload[];

    constraint c_valid {length > 0;
                        payload.size() == length;}

    constraint c_external;
endclass
```","
// packet.sv
class Packet;
    rand bit [7:0] length;
    rand bit [7:0] payload[];

    constraint c_valid {length > 0;
                        payload.size() == length;}

    constraint c_external;
endclass
","The image shows a textbook or document page detailing how to specify constraints within Verilog tests using in-line and external constraints, accompanied by an example of Verilog code defining a class with such constraints.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p197.jpg,True,"The image contains an example of Verilog code. Here it is transcribed:

```verilog
case (select)
  2'b00 : mux = a;
  2'b01 : mux = b;
  2'b10 : mux = c;
  2'b11 : mux = d;
  default : mux = 'bZ;
endcase
```","
case (select)
  2'b00 : mux = a;
  2'b01 : mux = b;
  2'b10 : mux = c;
  2'b11 : mux = d;
  default : mux = 'bZ;
endcase
","Caption: ""Example of a Verilog case statement highlighting best practices for RTL design by avoiding X-intercepting and X-assignments.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p321.jpg,True,"There is code in the image. Here is the Verilog code extracted from the image:

```verilog
(r) cmos optional_inst_name (out, in, N_ctl, P_ctl)
```

This line of code is defining a CMOS switch in Verilog with an optional instance name and ports for output, input, and control signals for the N-type and P-type transistors.","
(r) cmos optional_inst_name (out, in, N_ctl, P_ctl)
","Caption: ""CMOS NOT gate schematic and the explanation of CMOS primitives in Verilog from a Digital VLSI Design textbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p447.jpg,True,"```verilog
always @(posedge SerClock, posedge Reset)
begin : ClkGen
    if (Reset=='b1) // Respond to external reset.
    begin
        ParClkr <= '1'b0;
        Count32 <= 'b0;
    end
    else begin // If not a reset:
        if (SerValid==YES)
        begin
            // Resynchronize this one:
            if (doParSync==YES)
            begin
                ParClkr <= '1'b0; // Put low immediately.
                Count32 <= 'b0;
            end
            else begin
                Count32 <= Count32 + 1;
                if (Count32=='h50) ParClkr <= ~ParClkr;
            end
        end // if SerValid.
    end // not a reset.
end // ClkGen.

assign SerClock = (SerValid==YES) ? SerClk : '1'b0;
```","
always @(posedge SerClock, posedge Reset)
begin : ClkGen
    if (Reset=='b1) // Respond to external reset.
    begin
        ParClkr <= '1'b0;
        Count32 <= 'b0;
    end
    else begin // If not a reset:
        if (SerValid==YES)
        begin
            // Resynchronize this one:
            if (doParSync==YES)
            begin
                ParClkr <= '1'b0; // Put low immediately.
                Count32 <= 'b0;
            end
            else begin
                Count32 <= Count32 + 1;
                if (Count32=='h50) ParClkr <= ~ParClkr;
            end
        end // if SerValid.
    end // not a reset.
end // ClkGen.

assign SerClock = (SerValid==YES) ? SerClk : '1'b0;
","Caption: ""Excerpt from a digital VLSI design book discussing Verilog code for improving a clock generator by making it sensitive to the positive edge and addressing synthesizer design concerns.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p335.jpg,True,"The image contains Verilog code under two sections: ""16.1.6 ANSI Port and Parameter Options"" and ""16.1.7 Traditional Module Header Format and Options."" Here is the code from those sections:

From section 16.1.6:
```verilog
module ALU #(parameter DataHiBit=31, OutDelay=5, RegDelay=6)
            (output[DataHiBit:0] OutBus, ...);
...
ALU     #(31,5,8) // Must supply first two to change third one.
        .ALU1    (.OutBus(ResultWire), ...);
...
ALU     // Illegal.
.ALU2   (.OutBus(ResultWire[63:32]), ...);
...
endmodule
```

From section 16.1.7:
```verilog
module ALU (OutBus, InBus, Clock); // Parens & contents optional.
parameter DataHiBit=31, OutDelay=5, RegDelay=6;
output[DataHiBit:0] OutBus;
input ...
reg[DataHiBit:0] OutBus;
...
```

These snippets illustrate different styles of defining modules and parameters in Verilog HDL.","
module ALU #(parameter DataHiBit=31, OutDelay=5, RegDelay=6)
            (output[DataHiBit:0] OutBus, ...);
...
ALU     #(31,5,8) // Must supply first two to change third one.
        .ALU1    (.OutBus(ResultWire), ...);
...
ALU     // Illegal.
.ALU2   (.OutBus(ResultWire[63:32]), ...);
...
endmodule


module ALU (OutBus, InBus, Clock); // Parens & contents optional.
parameter DataHiBit=31, OutDelay=5, RegDelay=6;
output[DataHiBit:0] OutBus;
input ...
reg[DataHiBit:0] OutBus;
...
","""Explaining Verilog ANSI Port and Parameter Options and the Traditional Module Header Format""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p140.jpg,True,"The image contains Verilog code within a technical document. Below is the code:

```verilog
wire a, b, q;
reg [1:0] s;
reg [1:0] en_n;
//...

always @(s) begin
  case (s) //rtl_synthesis full_case
    2'b00: en_n = 2'b11;
    2'b01: en_n = 2'b10;
    2'b10: en_n = 2'b01;
  endcase
end

assign q = (~en_n[0]) ? a : 1'bz;
assign q = (~en_n[1]) ? b : 1'bz;
```

This snippet includes declaration of wires and registers, an always block with a case statement using the `//rtl_synthesis full_case` directive, and continuous assignments using the ternary operator for signal `q`.","
wire a, b, q;
reg [1:0] s;
reg [1:0] en_n;
//...

always @(s) begin
  case (s) //rtl_synthesis full_case
    2'b00: en_n = 2'b11;
    2'b01: en_n = 2'b10;
    2'b10: en_n = 2'b01;
  endcase
end

assign q = (~en_n[0]) ? a : 1'bz;
assign q = (~en_n[1]) ? b : 1'bz;
","""Verilog code example highlighting the importance of RTL coding practices for formal verification and the differences between RTL simulation and gate-level simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p593.jpg,True,"The image contains C code that is used to access and print values of parameters in a Verilog model using the Verilog Programming Language Interface (PLI). Here is the code extracted from the image:

```c
#include ""veriuser.h""                /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""                /* IEEE 1364 PLI ACC routine library */
/***********************************************************************
* PLI application
***********************************************************************/

int PLIbook_ListParams_calltf()
{
    handle module_h, param_h;

    acc_initialize();
    acc_configure(accDisplayWarnings, ""true"");

    module_h = acc_handle_tfarg(1);
    io_printf(""\nConstants in module %s:\n"", acc_fetch_fullname(module_h));

    param_h = null;
    while (param_h = acc_next_parameter(module_h, param_h)) {
        io_printf(""  . Parameter %s is: "", acc_fetch_fullname(param_h));
        switch (acc_fetch_paramtype(param_h)) {
            case accRealParam:
                io_printf(""%f\n"", acc_fetch_paramval(param_h));
                break;
            case accIntegerParam:
                io_printf(""%d\n"", (int)acc_fetch_paramval(param_h));
                break;
            case accStringParam:
                io_printf(""%s\n"", (char *)(int)acc_fetch_paramval(param_h));
                break;
        }
    }
    acc_close();
    return(0);
}
```

Please note that the `acc_user.h` and `veriuser.h` header files are specific to the Verilog PLI library which interfaces C code with Verilog code in simulation environments.","ude ""veriuser.h""                /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""                /* IEEE 1364 PLI ACC routine library */
/***********************************************************************
* PLI application
***********************************************************************/

int PLIbook_ListParams_calltf()
{
    handle module_h, param_h;

    acc_initialize();
    acc_configure(accDisplayWarnings, ""true"");

    module_h = acc_handle_tfarg(1);
    io_printf(""\nConstants in module %s:\n"", acc_fetch_fullname(module_h));

    param_h = null;
    while (param_h = acc_next_parameter(module_h, param_h)) {
        io_printf(""  . Parameter %s is: "", acc_fetch_fullname(param_h));
        switch (acc_fetch_paramtype(param_h)) {
            case accRealParam:
                io_printf(""%f\n"", acc_fetch_paramval(param_h));
                break;
            case accIntegerParam:
                io_printf(""%d\n"", (int)acc_fetch_paramval(param_h));
                break;
            case accStringParam:
                io_printf(""%s\n"", (char *)(int)acc_fetch_paramval(param_h));
                break;
        }
    }
    acc_close();
    return(0);
}
","""Example of using the Verilog Programming Language Interface (PLI) to access and print parameter values in a Verilog module.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p587.jpg,True,"This image contains explanatory text and configuration commands, rather than a complete block of code typically defined in Verilog. However, I will provide the configuration commands that are present:

```verilog
acc_configure(accPathDelayCount, ""1"");
acc_configure(accPathDelayCount, ""2"");
acc_configure(accPathDelayCount, ""3"");
acc_configure(accPathDelayCount, ""6"");
acc_configure(accPathDelayCount, ""12"");
```

These commands are used to set the configuration for the number of module path delays to be modified in a programming interface related to Verilog hardware description language, known as the Programming Language Interface (PLI). The default configuration is stated as `""6""`.","
acc_configure(accPathDelayCount, ""1"");
acc_configure(accPathDelayCount, ""2"");
acc_configure(accPathDelayCount, ""3"");
acc_configure(accPathDelayCount, ""6"");
acc_configure(accPathDelayCount, ""12"");
","""Excerpt from The Verilog PLI Handbook detailing the use and configuration of delay modification in Verilog simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p154.jpg,True,"The image contains a snippet of Verilog code. Here is the code transcribed from the image:

```verilog
module m (s, a, b, y, z);
    input s;
    input a, b;
    output y, z;
    wire s, a, b;
    wire y, z;
    assign y = s ? a : z;
    assign z = s ? y : b;
endmodule // m
```","
module m (s, a, b, y, z);
    input s;
    input a, b;
    output y, z;
    wire s, a, b;
    wire y, z;
    assign y = s ? a : z;
    assign z = s ? y : b;
endmodule // m
","""Exploring Solutions to False Paths in Digital Design with Verilog Code Example""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p586.jpg,True,"The image contains text that includes the syntax for a couple of Verilog ACC (access) routines. Here is the code that is visible:

```verilog
bool acc_append_delays(object, d1, d2,... d12)
handle object         // handle for a primitive, module path, timing check, module 
                      // input port or module input port bit select.
double d1...d12       // delay values.

bool acc_replace_delays(object, d1, d2,... d12)
handle object         // handle for a primitive, module path, timing check, module
                      // input port, module input port bit select, or inter-module 
                      // path.
double d1... d12      // delay values.
```

These are the function declarations for appending and replacing delay values in Verilog objects using the ACC library. These functions are not complete executable code on their own, but rather the signatures for these ACC routines that define how they should be called.","
bool acc_append_delays(object, d1, d2,... d12)
handle object         // handle for a primitive, module path, timing check, module 
                      // input port or module input port bit select.
double d1...d12       // delay values.

bool acc_replace_delays(object, d1, d2,... d12)
handle object         // handle for a primitive, module path, timing check, module
                      // input port, module input port bit select, or inter-module 
                      // path.
double d1... d12      // delay values.
","""Excerpt from a textbook detailing how to write delay values into Verilog objects using ACC routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p155.jpg,True,"The image contains Verilog code. Here it is:

The first block of code:
```verilog
module m (a, d);
    input a;
    output d;
    reg b, d;
    wire c;
    always @(a or c)
    begin
        b = a;
        d = c;
    end
    assign c = b;
endmodule // m
```

The second block of code:
```verilog
module m (a, d);
    input a;
    output d;
    reg b, c, d;
    always @(a)
    begin
        b = a;
        c = b;
        d = c;
    end
endmodule // m
```

The third block of code:
```verilog
module m (a, d);
    input a;
    output d;
    wire b, c, d;
    assign b = a;
    assign d = c;
    assign c = b;
endmodule // m
```","
module m (a, d);
    input a;
    output d;
    reg b, d;
    wire c;
    always @(a or c)
    begin
        b = a;
        d = c;
    end
    assign c = b;
endmodule // m


module m (a, d);
    input a;
    output d;
    reg b, c, d;
    always @(a)
    begin
        b = a;
        c = b;
        d = c;
    end
endmodule // m


module m (a, d);
    input a;
    output d;
    wire b, c, d;
    assign b = a;
    assign d = c;
    assign c = b;
endmodule // m
","""Exploring Different Verilog Coding Styles to Eliminate Combinatorial Logic Feedback""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p592.jpg,True,"The image contains a snippet of code, which appears to be written in a programming language used for electronic design, possibly C with some functions related to Verilog hardware description language using ACC (access) routines. Here is the code extracted from the image:

```c
/* verify new delays took affect */
acc_configure(accMinTypMaxDelays, ""false"");
rise = fall = toz = 0.0;
acc_fetch_delays(port_h, &rise, &fall, &toz);
io_printf(""Port %s new delays: (%1.2f, %1.2f, %1.2f)\n\n"",
    acc_fetch_name(port_h),
    rise, fall, toz);
```

Please note that this might not be the complete code, as there might be parts not visible in the provided image excerpt.","rify new delays took affect */
acc_configure(accMinTypMaxDelays, ""false"");
rise = fall = toz = 0.0;
acc_fetch_delays(port_h, &rise, &fall, &toz);
io_printf(""Port %s new delays: (%1.2f, %1.2f, %1.2f)\n\n"",
    acc_fetch_name(port_h),
    rise, fall, toz);
","Caption: ""A page from a technical document discussing ACC (Application Compiler Constructs) routines for reading and modifying values in Verilog, including code examples and descriptions of functions acc_fetch_paramtype() and acc_fetch_paramval().""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p334.jpg,True,"Here is the Verilog code from the image:

```verilog
ModuleName #(.ParamName1(value1), .ParamName2(value2) ...) 
    moduleInstName(.PortName1(NetName1), ...);

ModuleName #(value1, value2, ...)
    moduleInstName(.PortName1(NetName1), ...);
```

And the example provided in the text:

```verilog
// Note: 377 = 12'h179; -377 = 12'he87.
parameter signed[31:0] mul_coeff = -120*Pi; // Gets -376.9911 -> -377.
// If the next were overridden by -120*Pi, it would get 32'hffff_fe87:
parameter signed[31:0] div_coeff = 32'h0000_0179;
```","
ModuleName #(.ParamName1(value1), .ParamName2(value2) ...) 
    moduleInstName(.PortName1(NetName1), ...);

ModuleName #(value1, value2, ...)
    moduleInstName(.PortName1(NetName1), ...);


// Note: 377 = 12'h179; -377 = 12'he87.
parameter signed[31:0] mul_coeff = -120*Pi; // Gets -376.9911 -> -377.
// If the next were overridden by -120*Pi, it would get 32'hffff_fe87:
parameter signed[31:0] div_coeff = 32'h0000_0179;
","Caption: ""Excerpt from a textbook on Digital VLSI Design with Verilog discussing parameter instantiation formats and values in Verilog, including code examples and recommendations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p169.jpg,True,"The image contains a snippet of Verilog code in the form of a comment and a module declaration. Here is the code:

```verilog
//D-flip-flop with scan, reset, and inverted output
module dff_srn ( ...
```","
//D-flip-flop with scan, reset, and inverted output
module dff_srn ( ...
","Caption: ""Best Practices for Verilog RTL Style and Module Organization""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p446.jpg,True,"```verilog
always@(negedge SerClock, posedge Reset)
begin : Decode4
    if (Reset==YES)
    begin
        DecodeReg = 'b0;
        doParSync = NO;
        SyncOK = NO;
        UnLoad = NO;
    end
    else begin : PacketFind // Look for packet alignment:
        UnLoad = NO;
        doParSync = NO;
        if ( FrameSR[7:0]==PAD0 )
        begin : FoundPAD0
            SyncOK = YES;
            if ( FrameSR[23:16]==PAD1 && FrameSR[39:32]==PAD2
                 && FrameSR[55:48]==PAD3 )
            begin // All pads indicate all frames aligned:
                DecodeReg = { FrameSR[63:56], FrameSR[47:40]
                              , FrameSR[31:24], FrameSR[15:8] };
                UnLoad = YES;
            end
            else // Found a PAD0, but reset failed; so, synchronize:
            begin
                doParSync = YES;
                SyncOK = NO;
            end
        end // FoundPAD0.
    end // PacketFind.
end
```
","
always@(negedge SerClock, posedge Reset)
begin : Decode4
    if (Reset==YES)
    begin
        DecodeReg = 'b0;
        doParSync = NO;
        SyncOK = NO;
        UnLoad = NO;
    end
    else begin : PacketFind // Look for packet alignment:
        UnLoad = NO;
        doParSync = NO;
        if ( FrameSR[7:0]==PAD0 )
        begin : FoundPAD0
            SyncOK = YES;
            if ( FrameSR[23:16]==PAD1 && FrameSR[39:32]==PAD2
                 && FrameSR[55:48]==PAD3 )
            begin // All pads indicate all frames aligned:
                DecodeReg = { FrameSR[63:56], FrameSR[47:40]
                              , FrameSR[31:24], FrameSR[15:8] };
                UnLoad = YES;
            end
            else // Found a PAD0, but reset failed; so, synchronize:
            begin
                doParSync = YES;
                SyncOK = NO;
            end
        end // FoundPAD0.
    end // PacketFind.
end
","""Example of Verilog code using an always block for edge-triggered logic design with explanations on procedural complexity and clock edge detection.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p545.jpg,True,"```c
#include <stdio.h>            /* ANSI C standard I/O library */
#include ""veriuser.h""         /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""         /* IEEE 1364 PLI ACC routine library */
/***********************************************************************
* calltf application
***********************************************************************/

/* prototypes of subroutines used by calltf routine */
void PLIbook_ScanCommandFile();

int PLIbook_InvokeCommands_calltf()
{
    int  argc, i;
    char **argv;

    acc_initialize();
    acc_configure(accDisplayWarnings, ""true"");

    argc = acc_fetch_argc();
    argv = acc_fetch_argv();

    io_printf(""\nSimulation invocation commands:\n"");
    for (i=0; i<argc; i++) {
        io_printf("" %8s\n"", *argv);
        if (strcmp(*argv, ""-f"") == 0)
            argv++; /* next arg is address to array of strings */
            i++;
            PLIbook_ScanCommandFile((char **)*argv);
        }
        argv++; /* increment to next argument */
    }
    io_printf(""\n\n"");
    acc_close();
    return(0);
}

int PLIbook_indent = 0; /* global variable to format text indenting */

void PLIbook_ScanCommandFile(char *arg)
{
    int i;
    PLIbook_indent += 4; /* increase text indentation */
    while ( *arg != NULL ) { /* loop until null termination */
```
The image contains a code excerpt from what appears to be a Verilog PLI (Programming Language Interface) application using a combination of C and PLI specific functions for interfacing with a Verilog simulator.","ude <stdio.h>            /* ANSI C standard I/O library */
#include ""veriuser.h""         /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""         /* IEEE 1364 PLI ACC routine library */
/***********************************************************************
* calltf application
***********************************************************************/

/* prototypes of subroutines used by calltf routine */
void PLIbook_ScanCommandFile();

int PLIbook_InvokeCommands_calltf()
{
    int  argc, i;
    char **argv;

    acc_initialize();
    acc_configure(accDisplayWarnings, ""true"");

    argc = acc_fetch_argc();
    argv = acc_fetch_argv();

    io_printf(""\nSimulation invocation commands:\n"");
    for (i=0; i<argc; i++) {
        io_printf("" %8s\n"", *argv);
        if (strcmp(*argv, ""-f"") == 0)
            argv++; /* next arg is address to array of strings */
            i++;
            PLIbook_ScanCommandFile((char **)*argv);
        }
        argv++; /* increment to next argument */
    }
    io_printf(""\n\n"");
    acc_close();
    return(0);
}

int PLIbook_indent = 0; /* global variable to format text indenting */

void PLIbook_ScanCommandFile(char *arg)
{
    int i;
    PLIbook_indent += 4; /* increase text indentation */
    while ( *arg != NULL ) { /* loop until null termination */
","""Sample page from The Verilog PLI Handbook with Verilog PLI code example for printing invocation commands.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p552.jpg,True,"```verilog
1  program gen_mutex(output bit out1, out2, clk);
2  class Mutex;
3      rand bit x, y;
4      constraint c {
5          $onehot0({x, y});
6      }
7  endclass : Mutex
8  
9  Mutex vals = new;
10 
11 initial begin
12     clk = 1'b1;
13     for (int i = 0; i < 100; i++) begin
14         #5 clk = !clk;
15         #5 clk = !clk;
16         vals.randomize();
17         out1 = vals.x;
18         out2 = vals.y;
19     end
20 end
21 endprogram : gen_mutex
```","
1  program gen_mutex(output bit out1, out2, clk);
2  class Mutex;
3      rand bit x, y;
4      constraint c {
5          $onehot0({x, y});
6      }
7  endclass : Mutex
8  
9  Mutex vals = new;
10 
11 initial begin
12     clk = 1'b1;
13     for (int i = 0; i < 100; i++) begin
14         #5 clk = !clk;
15         #5 clk = !clk;
16         vals.randomize();
17         out1 = vals.x;
18         out2 = vals.y;
19     end
20 end
21 endprogram : gen_mutex
","Caption: ""Example of a conventional SystemVerilog testbench implementing mutually exclusive stimuli generation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p196.jpg,True,"The image contains examples of Verilog code. Here are the snippets provided:

Example 8-5
a) X intercept in if-else
```verilog
if (f===1'b0)
    g=2'b00;
else
    if (f===1'bX)
        g=2'b0X;
    else
        g=2'b01;
```

b) X intercept in case
```verilog
reg[1:0]d,e;
...
begin
    case (d)
        2'b00:   e = 2'b01;
        2'b0X:   e = 2'bX1;
        2'b01:   e = 2'b11;
        2'bX0:   e = 2'bXX;
        2'bXX:   e = 2'bXX;
        2'b10:   e = 2'b10;
        2'b1X:   e = 2'bX0;
        2'b11:   e = 2'b00;
    endcase
end
```

Example 8-6
```verilog
reg [1:0]d,e;
...
begin
    e = {~(d),~d[1]};
end
```

These Verilog code examples are discussing how to handle `X` states (don't-cares) in Verilog's conditional constructs such as if-else and case statements.","
if (f===1'b0)
    g=2'b00;
else
    if (f===1'bX)
        g=2'b0X;
    else
        g=2'b01;


reg[1:0]d,e;
...
begin
    case (d)
        2'b00:   e = 2'b01;
        2'b0X:   e = 2'bX1;
        2'b01:   e = 2'b11;
        2'bX0:   e = 2'bXX;
        2'bXX:   e = 2'bXX;
        2'b10:   e = 2'b10;
        2'b1X:   e = 2'bX0;
        2'b11:   e = 2'b00;
    endcase
end


reg [1:0]d,e;
...
begin
    e = {~(d),~d[1]};
end
","""Handling X-states in Verilog: Using if-else and case statements with examples""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p238.jpg,True,"The image contains Verilog code. Here's the text of the code provided:

```verilog
class Rising;
  bit [7:0] low;             // Not random
  rand bit [7:0] med, hi;    // Random variable
  constraint up
    { low < med; med < hi; } // See Section 6.4.2
endclass

initial begin
  Rising r;
  r = new();
  r.randomize();             // Randomize med, hi; low untouched
  r.randomize(med);          // Randomize only med
  r.randomize(low);          // Randomize only low, even though not rand
end
```

This code snippet demonstrates how to randomize a subset of variables in a class in Verilog.","
class Rising;
  bit [7:0] low;             // Not random
  rand bit [7:0] med, hi;    // Random variable
  constraint up
    { low < med; med < hi; } // See Section 6.4.2
endclass

initial begin
  Rising r;
  r = new();
  r.randomize();             // Randomize med, hi; low untouched
  r.randomize(med);          // Randomize only med
  r.randomize(low);          // Randomize only low, even though not rand
end
","Caption: ""Excerpt from a document discussing how to check and randomize values using constraints in Verilog, with an example of randomizing individual variables within a class.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p182.jpg,True,"There is code present in the image. Here it is:

```verilog
wire [15:0] r_bus_l, r_bus_r;
...
r_bus_driver r_bus_driver_l (.r_bus (r_bus_l)), ...
...
r_bus_driver r_bus_driver_r (.r_bus (r_bus_r)), ...
...
wire [31:0] r_bus;
...
r_bus_driver r_bus_driver_l (.r_bus_p (r_bus[31:16])), ...
...
r_bus_driver r_bus_driver_r (.r_bus_p (r_bus[15:0])), ...
```","
wire [15:0] r_bus_l, r_bus_r;
...
r_bus_driver r_bus_driver_l (.r_bus (r_bus_l)), ...
...
r_bus_driver r_bus_driver_r (.r_bus (r_bus_r)), ...
...
wire [31:0] r_bus;
...
r_bus_driver r_bus_driver_l (.r_bus_p (r_bus[31:16])), ...
...
r_bus_driver r_bus_driver_r (.r_bus_p (r_bus[15:0])), ...
","Caption: ""Best practices for naming signals and ports in Verilog to maintain consistency and readability across different modules and instances in digital design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p220.jpg,True,"The image contains a section from a document, and it includes some Verilog code. Here is the code transcribed from the image:

```verilog
module m1(logic clock, req, ack);
    ...
    a1: assert property (@(posedge clock) req |=> ack);
endmodule : m1
```

```verilog
module m2(input logic clock, rst, req, ack);
    default disable iff rst;
    ...
    check mycheck(req, ack, posedge clock);
endmodule : m2
```

```verilog
a1: assert property (@(posedge clock) disable iff (0)
    req |=> ack);
```

```verilog
module m2(input logic clock, rst, req, ack);
    default disable iff rst;
    
    checker check(a, b, event clk);
        a1: assert property (@clk a |=> b);
    endchecker : check
    //...
    check mycheck(req, ack, posedge clock);
endmodule : m2
```

```verilog
assert property (@(posedge clock) disable iff (rst)
    req |=> ack);
```

These snippets of code show examples of modules, properties, and assertions in Verilog, which is a hardware description language commonly used for designing digital circuits.","
module m1(logic clock, req, ack);
    ...
    a1: assert property (@(posedge clock) req |=> ack);
endmodule : m1


module m2(input logic clock, rst, req, ack);
    default disable iff rst;
    ...
    check mycheck(req, ack, posedge clock);
endmodule : m2


a1: assert property (@(posedge clock) disable iff (0)
    req |=> ack);


module m2(input logic clock, rst, req, ack);
    default disable iff rst;
    
    checker check(a, b, event clk);
        a1: assert property (@clk a |=> b);
    endchecker : check
    //...
    check mycheck(req, ack, posedge clock);
endmodule : m2


assert property (@(posedge clock) disable iff (rst)
    req |=> ack);
","""Exploring nuances in Verilog checkers and context inference related to assertion name resolution and default disable conditions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p237.jpg,True,"```c
int PLIbook_StartOfSim(p_cb_data cb_data)
{
    char        *file_name;
    FILE        *vector_file;
    vpiHandle   systf_h, tfarg_itr, tfarg1_h, tfarg2_h;
    s_cb_data   data_s;
    s_vpi_time  time_s;
    s_vpi_value argVal;
    s_vpi_vlog_info options_s;
    p_ReadStimData StimData; /* pointer to a ReadStimData structure */
    int         i, debug;

    /* retrieve system task handle from user_data */
    systf_h = (vpiHandle)cb_data->user_data;

    /* get tfarg handles (compiletf already verified args are correct) */
    tfarg_itr = vpi_iterate(vpiArgument, systf_h);
    tfarg1_h = vpi_scan(tfarg_itr);
    tfarg2_h = vpi_scan(tfarg_itr);
    vpi_free_object(tfarg_itr); /* free iterator--did not scan to null */

    /* read file name from first tfarg */
    argVal.format = vpiStringVal;
    vpi_get_value(tfarg1_h, &argVal);
    if (argVal.value.str == NULL) {
        vpi_printf(""ERROR: $read_stimulus_?? could not get file name\n"");
        return(0);
    }
    file_name = argVal.value.str;
    if ( !(vector_file = fopen(file_name, ""r"")) ) {
        vpi_printf(""$read_stimulus_?? could not open file %s\n"", file_name);
        tf_dofinish();
        return(0);
    }

    /* check for +readstim_debug invocation option */
    debug = 0; /* assume not invoked with debug flag */
    vpi_get_vlog_info(&options_s);
    for (i=1; i<options_s.argc; i++) {
        if (strcmp(options_s.argv[i], ""+readstim_debug"") == 0) {
            debug = 1; /* invocation option found */
            break;
        }
    }

    /* allocate memory to store information about this instance */
    StimData = (p_ReadStimData)malloc(sizeof(s_ReadStimData));
    StimData->file_ptr = vector_file;
    StimData->obj_h = tfarg2_h;
    StimData->debug = debug;
    PLIbook_set_vpiworkarea(systf_h, (char *)StimData);
    return(0);
}
```","LIbook_StartOfSim(p_cb_data cb_data)
{
    char        *file_name;
    FILE        *vector_file;
    vpiHandle   systf_h, tfarg_itr, tfarg1_h, tfarg2_h;
    s_cb_data   data_s;
    s_vpi_time  time_s;
    s_vpi_value argVal;
    s_vpi_vlog_info options_s;
    p_ReadStimData StimData; /* pointer to a ReadStimData structure */
    int         i, debug;

    /* retrieve system task handle from user_data */
    systf_h = (vpiHandle)cb_data->user_data;

    /* get tfarg handles (compiletf already verified args are correct) */
    tfarg_itr = vpi_iterate(vpiArgument, systf_h);
    tfarg1_h = vpi_scan(tfarg_itr);
    tfarg2_h = vpi_scan(tfarg_itr);
    vpi_free_object(tfarg_itr); /* free iterator--did not scan to null */

    /* read file name from first tfarg */
    argVal.format = vpiStringVal;
    vpi_get_value(tfarg1_h, &argVal);
    if (argVal.value.str == NULL) {
        vpi_printf(""ERROR: $read_stimulus_?? could not get file name\n"");
        return(0);
    }
    file_name = argVal.value.str;
    if ( !(vector_file = fopen(file_name, ""r"")) ) {
        vpi_printf(""$read_stimulus_?? could not open file %s\n"", file_name);
        tf_dofinish();
        return(0);
    }

    /* check for +readstim_debug invocation option */
    debug = 0; /* assume not invoked with debug flag */
    vpi_get_vlog_info(&options_s);
    for (i=1; i<options_s.argc; i++) {
        if (strcmp(options_s.argv[i], ""+readstim_debug"") == 0) {
            debug = 1; /* invocation option found */
            break;
        }
    }

    /* allocate memory to store information about this instance */
    StimData = (p_ReadStimData)malloc(sizeof(s_ReadStimData));
    StimData->file_ptr = vector_file;
    StimData->obj_h = tfarg2_h;
    StimData->debug = debug;
    PLIbook_set_vpiworkarea(systf_h, (char *)StimData);
    return(0);
}
","""Example of a Verilog simulation synchronization using VPI callbacks in a technical document.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p546.jpg,True,"The image contains two pieces of Verilog code within examples. Here are the snippets:

Example 23.25:
```verilog
checker check(..., event clk);
rand bit v;
...
m1: assume property (@(clk v |-> ##3 1’b0));
endchecker : check
```

Example 23.26:
```verilog
checker check(..., event clk);
rand bit v, w;
...
m1: assume final ($onehot0({v,w}));
m2: assume property (@clk v |=> w);
endchecker : check
```","
checker check(..., event clk);
rand bit v;
...
m1: assume property (@(clk v |-> ##3 1’b0));
endchecker : check


checker check(..., event clk);
rand bit v, w;
...
m1: assume final ($onehot0({v,w}));
m2: assume property (@clk v |=> w);
endchecker : check
","Caption: ""Examples of Verilog checkers with assumptions on free variables and efficiency tips for using free variables in formal verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p579.jpg,True,"The image contains code examples related to Verilog. Here are the code snippets provided in the image:

```
bufif1 #(3, 4, 5) g3(...);

bufif1 #(2:3.4, 3:4.5, 5:6.7) g4(...);
```

Additionally, there are function prototypes for the ACC (Application Compiler Construct) routine `acc_fetch_delays`:

```verilog
bool acc_fetch_delays(object, d1, d2, ... d12)
```

```verilog
bool acc_fetch_delays(object, dset_array)
```

These routines are used to read the delay values of any Verilog object. The actual content and layout structures, such as data types and arguments, are described in the accompanying text, which provides more context on how the functions are used within Verilog PLI (Programming Language Interface)."," #(3, 4, 5) g3(...);

bufif1 #(2:3.4, 3:4.5, 5:6.7) g4(...);


bool acc_fetch_delays(object, d1, d2, ... d12)


bool acc_fetch_delays(object, dset_array)
","Caption: ""Excerpt from The Verilog PLI Handbook detailing the usage of tri-state buffers with specified delays and the acc_fetch_delays() ACC routine for reading delay values in Verilog objects.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p127.jpg,True,"The image contains code written in a hardware description language, which appears to be SystemVerilog assertions. Here is the text of the code:

```
Glue_chk4: During a write transaction, if the signal “rsel2” is not tri-
stated, then the data from master device two should be written to the
respective target device.

property p_rsel2_write;
  @(posedge clk)
    ((!sel2 || !rsel2) ##3 ($fell (trdy[1]) ||
    $fell(trdy[0])) ##3 data2[8]) |-> 
    (data == $past(data2)) [*7];
endproperty

Glue_chk5: During a write transaction, if the signal “rsel3” is not tri-
stated, then the data from master device three should be written to the
respective target device.

property p_rsel3_write;
  @(posedge clk)
    ((rsel3 || !rsel3) ##3 ($fell (trdy[1]) ||
    $fell(trdy[0])) ##3 data3[8]) |-> 
    (data == $past(data3)) [*7];
Endproperty

Glue_chk6: During a read transaction, if target device one is selected,
then data read from target one (dataout1) should be fed back to the
respective master.

property p_read1;
  @(posedge clk)
    ($fell (trdy[1]) ##4 !data[8]) |->
    (dataout1 == data0) [*7];
endproperty

Glue_chk7: During a read transaction, if target device zero is selected,
then data read from target zero (dataout2) should be fed back to the
respective master.

property p_read0;
  @(posedge clk)
    ($fell (trdy[0]) ##4 !data[8]) |->
    (dataout2 == data0) [*7];
endproperty
```

This code appears to be setting up some formal properties for verification purposes, essentially specifying the desired behavior of a system and how data should be transmitted or received under various conditions. These properties can then be used to check that the implementation adheres to the described behavior.","hk4: During a write transaction, if the signal “rsel2” is not tri-
stated, then the data from master device two should be written to the
respective target device.

property p_rsel2_write;
  @(posedge clk)
    ((!sel2 || !rsel2) ##3 ($fell (trdy[1]) ||
    $fell(trdy[0])) ##3 data2[8]) |-> 
    (data == $past(data2)) [*7];
endproperty

Glue_chk5: During a write transaction, if the signal “rsel3” is not tri-
stated, then the data from master device three should be written to the
respective target device.

property p_rsel3_write;
  @(posedge clk)
    ((rsel3 || !rsel3) ##3 ($fell (trdy[1]) ||
    $fell(trdy[0])) ##3 data3[8]) |-> 
    (data == $past(data3)) [*7];
Endproperty

Glue_chk6: During a read transaction, if target device one is selected,
then data read from target one (dataout1) should be fed back to the
respective master.

property p_read1;
  @(posedge clk)
    ($fell (trdy[1]) ##4 !data[8]) |->
    (dataout1 == data0) [*7];
endproperty

Glue_chk7: During a read transaction, if target device zero is selected,
then data read from target zero (dataout2) should be fed back to the
respective master.

property p_read0;
  @(posedge clk)
    ($fell (trdy[0]) ##4 !data[8]) |->
    (dataout2 == data0) [*7];
endproperty
","""Examples of SystemVerilog properties for checking data transactions during write and read processes.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p491.jpg,True,"The image includes a figure with Verilog code within it. The code is as follows:

```verilog
MemBIST_Top.v          Mem.v
------------------      ------------------
|                |      |                |
| module         |      | module Mem     |
| MemBIST_Top    |      |                |
|                |      |                |
| Mem Mem_U1     |      |                |
|                |      |                |
------------------      ------------------
```

It appears that the figure is addressing how to structure the module `MemBIST_Top` that includes another module named `Mem`. The text surrounding this figure seems to describe steps for creating a Built-In Self Test (BIST) wrapper for the memory testing in a digital system. There is no explicit procedural code shown in the image, but rather a diagram representing the structure of Verilog modules.","
MemBIST_Top.v          Mem.v
------------------      ------------------
|                |      |                |
| module         |      | module Mem     |
| MemBIST_Top    |      |                |
|                |      |                |
| Mem Mem_U1     |      |                |
|                |      |                |
------------------      ------------------
","Caption: ""This image describes the creation of a BIST (Built-In Self-Test) wrapper module in Verilog for testing memory, detailing steps for planning the interface and modifying module I/Os, along with a visual representation of the `MemBIST_Top.v` wrapper module instantiation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p26.jpg,True,"The image contains Verilog code, which is specifically for SystemVerilog Assertions (SVA). Here is the code excerpt from the image:

```verilog
assert property(@(posedge clk) req |-> nexttime[4] grant);
```

This line is used to assert a property in Verilog, where the assertion checks that whenever `req` is true at the positive edge of the clock, `grant` should be true at exactly four clock cycles later.","
assert property(@(posedge clk) req |-> nexttime[4] grant);
","""Understanding Assertions in SystemVerilog for Precise Design Intent Specification""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p208.jpg,True,"The image contains Verilog code. Here's the transcribed text of the code from the image:

Example 9.4:
```verilog
checker request_granted(req, gnt, n = 1, clk, rst);
  a1: assert property(@(clk disable iff (rst))
    req |-> nexttime[n] gnt);
endchecker : request_granted
```

Example 9.5:
```verilog
checker request_granted(req, gnt, n = 1,
  clk = $inferred_clock, rst = $inferred_disable);
  a1: assert property(@(clk disable iff (rst))
    req |-> nexttime[n] gnt);
endchecker : request_granted
```

Example 9.6:
```verilog
checker request_granted(req, gnt, n = 1,
  clk = $inferred_clock, rst = $inferred_disable);
  default clocking @(clk); endclocking
  default disable iff rst;
  a1: assert property(req |-> nexttime[n] gnt);
endchecker : request_granted
```

These examples illustrate how to write checkers in Verilog, including the use of default arguments and context inferences for clock and reset signals.","
checker request_granted(req, gnt, n = 1, clk, rst);
  a1: assert property(@(clk disable iff (rst))
    req |-> nexttime[n] gnt);
endchecker : request_granted


checker request_granted(req, gnt, n = 1,
  clk = $inferred_clock, rst = $inferred_disable);
  a1: assert property(@(clk disable iff (rst))
    req |-> nexttime[n] gnt);
endchecker : request_granted


checker request_granted(req, gnt, n = 1,
  clk = $inferred_clock, rst = $inferred_disable);
  default clocking @(clk); endclocking
  default disable iff rst;
  a1: assert property(req |-> nexttime[n] gnt);
endchecker : request_granted
","""Verilog code examples demonstrating default arguments and context inference in checkers.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p133.jpg,True,"The image contains a snippet of Verilog code. Here is the code transcribed from the image:

```verilog
else if(target_sva_severity) $fatal;
a_sel_trdy_stop:
    assert property(p_sel_trdy_stop)
    else if(target_sva_severity) $fatal;

a_write:
    assert property(p_write)
    else if(target_sva_severity) $fatal;

a_read:
    assert property(p_read)
    else if(target_sva_severity) $fatal;

a_target_datain:
    assert property(p_target_datain)
    else if(target_sva_severity) $fatal;

a_target_dataout:
    assert property(p_target_dataout)
    else if(target_sva_severity) $fatal;

c_sel_trdy_start:
    cover property(p_sel_trdy_start);

c_sel_trdy_stop: cover property(p_sel_trdy_stop);
c_write: cover property(p_write);
c_read: cover property(p_read);
c_target_datain: cover property(p_target_datain);
c_target_dataout:
    cover property(p_target_dataout);

end
end
endmodule
```

Please note that the code may be incomplete and might not function as intended without additional context or the complete source code.","
else if(target_sva_severity) $fatal;
a_sel_trdy_stop:
    assert property(p_sel_trdy_stop)
    else if(target_sva_severity) $fatal;

a_write:
    assert property(p_write)
    else if(target_sva_severity) $fatal;

a_read:
    assert property(p_read)
    else if(target_sva_severity) $fatal;

a_target_datain:
    assert property(p_target_datain)
    else if(target_sva_severity) $fatal;

a_target_dataout:
    assert property(p_target_dataout)
    else if(target_sva_severity) $fatal;

c_sel_trdy_start:
    cover property(p_sel_trdy_start);

c_sel_trdy_stop: cover property(p_sel_trdy_stop);
c_write: cover property(p_write);
c_read: cover property(p_read);
c_target_datain: cover property(p_target_datain);
c_target_dataout:
    cover property(p_target_dataout);

end
end
endmodule
","""Sample Verilog code demonstrating the use of assertions and cover properties.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p238.jpg,True,"```verilog
// for Example 7-2
default clock = (posedge clk);
cover { !full; full };
cover { !empty; empty };
```","
// for Example 7-2
default clock = (posedge clk);
cover { !full; full };
cover { !empty; empty };
","""Explanation and illustration of fixed depth pipeline register behavior with stall and flush capabilities in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p208.jpg,True,"The image contains two snippets of Verilog code. Here are the contents of the code present on the page:

1.

```verilog
assert property (p_req_ack) $display(""passed"");
else $display(""failed"");
```

2.

```verilog
assert property (p_req_ack)
if (cnt_en) req_ack_count++;  // assertion pass statement
else $fatal;                   // GOTCHA! this is not the
                               // assertion fail statement
```

3.

```verilog
assert property (p_req_ack)
begin
    if (cnt_en) req_ack_count++;  // OK, assertion pass statement
end
else $fatal;                      // OK, assertion fail statement
```","
assert property (p_req_ack) $display(""passed"");
else $display(""failed"");


assert property (p_req_ack)
if (cnt_en) req_ack_count++;  // assertion pass statement
else $fatal;                   // GOTCHA! this is not the
                               // assertion fail statement


assert property (p_req_ack)
begin
    if (cnt_en) req_ack_count++;  // OK, assertion pass statement
end
else $fatal;                      // OK, assertion fail statement
","""Common pitfall in Verilog assertion usage highlighted in a textbook example""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p136.jpg,True,"```verilog
module RAM (output[7:0] Obus, output ParityErr
            , input[7:0] Ibus
            , input[3:0] Adr, input Clk, Read
            );
    reg[8:0] Storage[15:0]; // MSB is parity bit.
    reg[7:0] ObusReg;       // Parity is not used for data.
    /
    assign #1 Obus = ObusReg;
    assign ParityErr= (Read=='1'b1) ? (^Storage[Adr]) : 1'b0;
    /
    always@(posedge Clk)
        if (Read=='1'b0)
            Storage[Adr] <= {^Ibus, Ibus}; // Create & store parity bit.
        else
            ObusReg <= Storage[Adr];       // Discard old parity bit.
endmodule

reg[7:0] DataByte;        // The 8 bit datum, without parity.
reg[8:0] StoredDataByte;   // High bit will be 9th (parity) bit.
...
StoredDataByte <= {^DataByte, DataByte}; // A 9-bit expression.

Likewise, two bytes stored in variables could be concatenated by an assignment such as
Word <= {HiByte, LoByte};.
```","
module RAM (output[7:0] Obus, output ParityErr
            , input[7:0] Ibus
            , input[3:0] Adr, input Clk, Read
            );
    reg[8:0] Storage[15:0]; // MSB is parity bit.
    reg[7:0] ObusReg;       // Parity is not used for data.
    /
    assign #1 Obus = ObusReg;
    assign ParityErr= (Read=='1'b1) ? (^Storage[Adr]) : 1'b0;
    /
    always@(posedge Clk)
        if (Read=='1'b0)
            Storage[Adr] <= {^Ibus, Ibus}; // Create & store parity bit.
        else
            ObusReg <= Storage[Adr];       // Discard old parity bit.
endmodule

reg[7:0] DataByte;        // The 8 bit datum, without parity.
reg[8:0] StoredDataByte;   // High bit will be 9th (parity) bit.
...
StoredDataByte <= {^DataByte, DataByte}; // A 9-bit expression.

Likewise, two bytes stored in variables could be concatenated by an assignment such as
Word <= {HiByte, LoByte};.
","""Example of Parity Error Checking in Verilog using Concatenation Operator""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p220.jpg,True,"```verilog
constraint ab {
  solve a before b hard;  // 'hard' enforces solve before
  if (a inside {32, 64, 128, 256})
    a == b;
  else
    a > b;
}
```","
constraint ab {
  solve a before b hard;  // 'hard' enforces solve before
  if (a inside {32, 64, 128, 256})
    a == b;
  else
    a > b;
}
","""Page discussing non-standard language extensions in Verilog and SystemVerilog with example code that uses a vendor-specific keyword.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p204.jpg,True,"There is some written text related to Verilog and SystemVerilog assertions, specifically discussing past event patterns. However, there is also a snippet of conceptual Verilog code present in the image. The text introduces the `$past` system function, which is a construct in SystemVerilog. Here is the snippet of code provided:

```
$past(bit_vector_expr [, number_of_ticks])
```

This is not a complete Verilog code statement but rather shows the usage of the `$past` function, which takes a bit vector expression and an optional number of ticks as arguments, to access the value of a signal in the past. If `number_of_ticks` is not specified, it defaults to one.","bit_vector_expr [, number_of_ticks])
","""Understanding Past Event Patterns in Verilog for System Verification""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p295.jpg,True,"The image contains Verilog code, which is related to the design of an asynchronous FIFO (First-In-First-Out) memory structure. Here is the code from the image:

```verilog
reg [A_WIDTH:0] rd_ptr_gray;
reg [A_WIDTH:0] rd_ptr_gray_wclk_q;
reg [A_WIDTH:0] rd_ptr_gray_wclk_q2;

reg full;
reg empty;

wire [A_WIDTH:0] nxt_wr_ptr;
wire [A_WIDTH:0] nxt_rd_ptr;
wire [A_WIDTH:0] nxt_wr_ptr_gray;
wire [A_WIDTH:0] nxt_rd_ptr_gray;
wire [A_WIDTH-1:0] wr_addr;
wire [A_WIDTH-1:0] rd_addr;
wire full_d;
wire empty_d;

assign wr_addr = wr_ptr[A_WIDTH-1:0];
assign rd_addr = rd_ptr[A_WIDTH-1:0];

always @ (posedge wclk)
    if (write_en) reg_mem[wr_addr] <= `FF_DLY fifo_in;

assign fifo_out = reg_mem[rd_addr];

always @ (posedge wclk or negedge wclk_reset_n)
    if (!wclk_reset_n) begin
        wr_ptr <= `FF_DLY {A_WIDTH{1'b0}};
        wr_ptr_gray <= `FF_DLY {A_WIDTH{1'b0}};
    end else begin
        wr_ptr <= `FF_DLY nxt_wr_ptr;
        wr_ptr_gray <= `FF_DLY nxt_wr_ptr_gray;
    end

assign nxt_wr_ptr = (write_en) ? wr_ptr+1 : wr_ptr;
assign nxt_wr_ptr_gray = ((nxt_wr_ptr>>1) ^ nxt_wr_ptr);

always @ (posedge rclk or negedge rclk_reset_n)
    if (!rclk_reset_n) begin
        rd_ptr <= `FF_DLY {A_WIDTH{1'b0}};
        rd_ptr_gray <= `FF_DLY {A_WIDTH{1'b0}};
    end else begin
        rd_ptr <= `FF_DLY nxt_rd_ptr;
        rd_ptr_gray <= `FF_DLY nxt_rd_ptr_gray;
    end
```

The code uses parameter `A_WIDTH` (not defined within the visible part) to set the width of the pointers and addresses, and `FF_DLY` (also not defined within the visible part) which appears to be a macro or parameter for handling delays or data synchronization.

It features standard FIFO operations such as writing to the FIFO memory, generating write and read pointers, and converting them to Gray code to better handle asynchronous clock domain crossings. Moreover, it includes conditions to handle the reset behavior of the FIFO.","
reg [A_WIDTH:0] rd_ptr_gray;
reg [A_WIDTH:0] rd_ptr_gray_wclk_q;
reg [A_WIDTH:0] rd_ptr_gray_wclk_q2;

reg full;
reg empty;

wire [A_WIDTH:0] nxt_wr_ptr;
wire [A_WIDTH:0] nxt_rd_ptr;
wire [A_WIDTH:0] nxt_wr_ptr_gray;
wire [A_WIDTH:0] nxt_rd_ptr_gray;
wire [A_WIDTH-1:0] wr_addr;
wire [A_WIDTH-1:0] rd_addr;
wire full_d;
wire empty_d;

assign wr_addr = wr_ptr[A_WIDTH-1:0];
assign rd_addr = rd_ptr[A_WIDTH-1:0];

always @ (posedge wclk)
    if (write_en) reg_mem[wr_addr] <= `FF_DLY fifo_in;

assign fifo_out = reg_mem[rd_addr];

always @ (posedge wclk or negedge wclk_reset_n)
    if (!wclk_reset_n) begin
        wr_ptr <= `FF_DLY {A_WIDTH{1'b0}};
        wr_ptr_gray <= `FF_DLY {A_WIDTH{1'b0}};
    end else begin
        wr_ptr <= `FF_DLY nxt_wr_ptr;
        wr_ptr_gray <= `FF_DLY nxt_wr_ptr_gray;
    end

assign nxt_wr_ptr = (write_en) ? wr_ptr+1 : wr_ptr;
assign nxt_wr_ptr_gray = ((nxt_wr_ptr>>1) ^ nxt_wr_ptr);

always @ (posedge rclk or negedge rclk_reset_n)
    if (!rclk_reset_n) begin
        rd_ptr <= `FF_DLY {A_WIDTH{1'b0}};
        rd_ptr_gray <= `FF_DLY {A_WIDTH{1'b0}};
    end else begin
        rd_ptr <= `FF_DLY nxt_rd_ptr;
        rd_ptr_gray <= `FF_DLY nxt_rd_ptr_gray;
    end
",Asynchronous FIFO Design using Verilog Code.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p281.jpg,True,"The image contains Verilog code. Here is the code written in the image:

```verilog
sequence bSeq;
  ##[1:5] b;
endsequence

sequence dSeq;
  ##2 d ##2 e;
endsequence

property mClocks;
  @(posedge clk) a |-> bSeq ##1 c |-> dSeq;
endproperty

//...
```

Below the code, there are examples describing how properties in Verilog SystemVerilog can be written with single or multiple implications which are considered equivalent.

```verilog
P1: assert property (@(posedge clk) req |-> ##2 gnt |-> ##2 gntAck);
P1: assert property (@(posedge clk) req ##2 gnt |-> ##2 gntAck);

P2: assert property (@(posedge clk) req |=> gnt |=> gntAck);
P2: assert property (@(posedge clk) req ##1 gnt |=> gntAck);
```

Please note that this code is a part of a textbook or educational material discussing Verilog or SystemVerilog sequences and properties.","
sequence bSeq;
  ##[1:5] b;
endsequence

sequence dSeq;
  ##2 d ##2 e;
endsequence

property mClocks;
  @(posedge clk) a |-> bSeq ##1 c |-> dSeq;
endproperty

//...


P1: assert property (@(posedge clk) req |-> ##2 gnt |-> ##2 gntAck);
P1: assert property (@(posedge clk) req ##2 gnt |-> ##2 gntAck);

P2: assert property (@(posedge clk) req |=> gnt |=> gntAck);
P2: assert property (@(posedge clk) req ##1 gnt |=> gntAck);
","""Example of nested implications in Verilog properties and suggestions for simplification""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p210.jpg,True,"Here is the code from the image:

```verilog
// declarative assertion
// assert that ack must occur within 100 cycles after a req
// the ack can overlap with the req

assert always ({req} |-> {[*0:100];ack}) @(posedge clk);
```","
// declarative assertion
// assert that ack must occur within 100 cycles after a req
// the ack can overlap with the req

assert always ({req} |-> {[*0:100];ack}) @(posedge clk);
","Caption: ""Example of a Property Specification Language (PSL) time limit sequence check in Verilog, allowing for a single-cycle overlap between request and acknowledgment signals.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p319.jpg,True,"The image displays snippets of Verilog code defining properties. Here is the code present in the image:

```verilog
// On a given clock edge, if the leading signal
// is low, then after ""min_time"" clock cycles
// the trailing signal must be high

property p5_f_lh;
    @(posedge clk) !a |-> ##min_time b;
endproperty

// On a given clock edge, if the leading signal
// is low, then after ""min_time"" clock cycles
// the trailing signal must be low

property p5_f_ll;
    @(posedge clk) !a |-> ##min_time !b;
endproperty

a5_f_lh: assert property(p5_f_lh);
a5_f_ll: assert property(p5_f_ll);
```
There's more code in the image, but it's either incomplete snippets, or it repeats the above pattern for different conditions in the properties.","
// On a given clock edge, if the leading signal
// is low, then after ""min_time"" clock cycles
// the trailing signal must be high

property p5_f_lh;
    @(posedge clk) !a |-> ##min_time b;
endproperty

// On a given clock edge, if the leading signal
// is low, then after ""min_time"" clock cycles
// the trailing signal must be low

property p5_f_ll;
    @(posedge clk) !a |-> ##min_time !b;
endproperty

a5_f_lh: assert property(p5_f_lh);
a5_f_ll: assert property(p5_f_ll);
","Caption: ""Example of Verilog temporal properties defining signal relationships with minimum and maximum timing constraints for system verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p256.jpg,True,"The image contains Verilog code which is used for clock domain crossing (CDC) verification using assertions. Here is the code from the image:

```verilog
property Tx_to_Rx_CDC_DataCheck;
  local Data;
  @(posedge Txclk) ($changed(TxData)) |-> 
    (1'b1, (Data = TxData)) ##1 
    @(posedge RxClk) (Rx1Data === Data) ##1 (Rxdata === Data);
endproperty: Tx_to_Rx_CDC_DataCheck

assert property (Tx_to_Rx_CDC_DataCheck);

sequence rd_detect(ptr);
  ##[0:$] (read_en && !empty && (affl.rd_ptr == ptr));
endsequence

property data_check(wrptr);
  integer ptr, data;
  @(posedge wclk) disable iff (!wclk_reset_n || !rclk_reset_n)
    (write_en && !full, ptr=wrptr, data=fifo_in,
    $display($stime,""Assertion Disp wr_ptr=%h data=%h"", affl.wr_ptr, fifo_in))
  |-> 
    @(negedge rclk) first_match(rd_detect(ptr),
    $display($stime,"","","" Assertion Disp FIRST_MATCH ptr=%h Compare data=%h fifo_out=%h"", ptr, data, fifo_out))
    ##0 (fifo_out === data);
endproperty
```

The code defines properties and sequences to be used for assertions in a system with multiple clock domains, meaning a signal is transferred from one domain (transmit, Tx) to another (receive, Rx). Assertions are critical in verifying that data integrity is maintained as signals cross clock domains in hardware designs.","
property Tx_to_Rx_CDC_DataCheck;
  local Data;
  @(posedge Txclk) ($changed(TxData)) |-> 
    (1'b1, (Data = TxData)) ##1 
    @(posedge RxClk) (Rx1Data === Data) ##1 (Rxdata === Data);
endproperty: Tx_to_Rx_CDC_DataCheck

assert property (Tx_to_Rx_CDC_DataCheck);

sequence rd_detect(ptr);
  ##[0:$] (read_en && !empty && (affl.rd_ptr == ptr));
endsequence

property data_check(wrptr);
  integer ptr, data;
  @(posedge wclk) disable iff (!wclk_reset_n || !rclk_reset_n)
    (write_en && !full, ptr=wrptr, data=fifo_in,
    $display($stime,""Assertion Disp wr_ptr=%h data=%h"", affl.wr_ptr, fifo_in))
  |-> 
    @(negedge rclk) first_match(rd_detect(ptr),
    $display($stime,"","","" Assertion Disp FIRST_MATCH ptr=%h Compare data=%h fifo_out=%h"", ptr, data, fifo_out))
    ##0 (fifo_out === data);
endproperty
",Verilog Assertions for Clock Domain Crossing Verification,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p325.jpg,True,"The image contains Verilog code. Here it is:

```verilog
// sample Verilog test code for timing
// relationship between two signals

if(timing_level == 2'b11) begin
    a = 1'b0; b=1'b0; end
if(timing_level== 2'b00) begin
    a = 1'b1; b=1'b1; end
if(timing_level == 2'b01) begin
    a = 1'b1; b=1'b0; end
if(timing_level == 2'b10) begin
    a = 1'b0; b=1'b1; end

for(i=(min_time-1); i<(max_time+3); i++)
begin
    repeat(1) @(posedge clk);
    a <= ~a;
    if(i == 0)
    begin
        b <= ~b;
        repeat(1) @(posedge clk);
        a <= ~a; b <= ~b;
    end
    else
    begin
        repeat(1) @(posedge clk);
        a<= ~a;
```

This code segment appears to be incomplete, as the last `begin` block doesn't have a corresponding `end` statement, suggesting that there is more code beyond what is shown in the image. The code is related to changing the values of signals `a` and `b` based on some timing_level condition and iterating over a timing loop to generate test stimulus based on signal edges for a clock (`clk`) signal.","
// sample Verilog test code for timing
// relationship between two signals

if(timing_level == 2'b11) begin
    a = 1'b0; b=1'b0; end
if(timing_level== 2'b00) begin
    a = 1'b1; b=1'b1; end
if(timing_level == 2'b01) begin
    a = 1'b1; b=1'b0; end
if(timing_level == 2'b10) begin
    a = 1'b0; b=1'b1; end

for(i=(min_time-1); i<(max_time+3); i++)
begin
    repeat(1) @(posedge clk);
    a <= ~a;
    if(i == 0)
    begin
        b <= ~b;
        repeat(1) @(posedge clk);
        a <= ~a; b <= ~b;
    end
    else
    begin
        repeat(1) @(posedge clk);
        a<= ~a;
","Caption: ""Example Verilog code for testing timing relationships between two digital signals.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p331.jpg,True,"The image contains text that relates to a conceptual framework within which Verilog code might be used, but no actual lines of Verilog code are present in the image. It appears to be a page from a technical book or documentation that includes a figure illustrating an Assertion-Based Test Bench (ATB) environment and a table describing parameter definitions with their functionality in the context of a testing structure for digital design verification.

The text in the image describes three parts of the testing structure but does not include any Verilog code. Instead, it includes a table of parameter definitions which looks like this:

```
Parameter                   Functionality
parameter sig_edge = 0;     Defines if signals involved are edge sensitive, 0 indicates no, 1 indicates yes
parameter sig1_edge = 1;    Defines the edge of the leading signal, 1 means rising edge and 0 means falling edge (used only for logical relationship)
parameter logic_op = 0;     Defines if the assertions involve logical relationship, 0 indicates no, indicates yes
parameter timing = 1;       Defines if the assertions involve temporal relationship, 0 indicates no, 1 indicates yes
parameter min_time = 2;     Defines timing information, maximum time should be
```

Please note that while the table entries look like parameter declarations, they do not constitute executable Verilog code. They are descriptions of parameters in a hypothetical configuration scenario.","ter                   Functionality
parameter sig_edge = 0;     Defines if signals involved are edge sensitive, 0 indicates no, 1 indicates yes
parameter sig1_edge = 1;    Defines the edge of the leading signal, 1 means rising edge and 0 means falling edge (used only for logical relationship)
parameter logic_op = 0;     Defines if the assertions involve logical relationship, 0 indicates no, indicates yes
parameter timing = 1;       Defines if the assertions involve temporal relationship, 0 indicates no, 1 indicates yes
parameter min_time = 2;     Defines timing information, maximum time should be
","""Overview of an Assertion-Based Test Bench (ATB) Environment in Verilog with Parameter Definitions Table""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p242.jpg,True,"The image contains snippets of Verilog code. Here they are transcribed for you:

```verilog
sequence RdS;
    @(posedge BusClk) $fell (as_) ##1 rd ##[1:5] oe_;
endsequence

property checkP;
    @(negedge sysclk) RdS.matched |=> rdDataLatch ##0 ($isunknown(data) == 0);
endproperty
```

And further down in the image:

```verilog
module clock_inference;
    logic a, b, c, d;

    default clocking cb @(posedge clk_d); endclocking

    sequence e4;
        $rose(b) ##1 c;
    endsequence

    a1: assert property (@(posedge clk_a) |=> e4.triggered);

    sequence e5;
        @(posedge clk_e1) a ##[1:3] e4.triggered ##1 c;
    endsequence

    a2: assert property (@(posedge clk_a) |=> e5.matched);
```

The accompanying annotations provide context and explanations regarding clock inference and assertion properties in the code.","
sequence RdS;
    @(posedge BusClk) $fell (as_) ##1 rd ##[1:5] oe_;
endsequence

property checkP;
    @(negedge sysclk) RdS.matched |=> rdDataLatch ##0 ($isunknown(data) == 0);
endproperty


module clock_inference;
    logic a, b, c, d;

    default clocking cb @(posedge clk_d); endclocking

    sequence e4;
        $rose(b) ##1 c;
    endsequence

    a1: assert property (@(posedge clk_a) |=> e4.triggered);

    sequence e5;
        @(posedge clk_e1) a ##[1:3] e4.triggered ##1 c;
    endsequence

    a2: assert property (@(posedge clk_a) |=> e5.matched);
","Caption: ""Excerpt from a document illustrating sequence and property declarations in SystemVerilog for clock inference and signal matching.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p196.jpg,True,"The image contains Verilog code from a book. Here's the code as it appears in the image:

```verilog
vpi_printf(""Delays for %s = (%2.f:%2.f:%2.f, %2.f:%2.f:%2.f)\n"",
    path_name,
    delay_array[0].real, delay_array[1].real, delay_array[2].real,
    delay_array[3].real, delay_array[4].real, delay_array[5].real);
}

char *PLIbook_BuildPathName(vpiHandle modpath_h)
{
    vpiHandle term_itr, term_h, net_h;
    static char path_name[2050]; /* character array to hold path name */
    char *term_name;

    path_name[0] = '\0'; /* clear the path name string */

    term_itr = vpi_iterate(vpiModPathIn, modpath_h);
    if (term_itr == NULL)
        return(""UNKNOWN PATH NAME"");
    term_h = vpi_scan(term_itr);
    net_h = vpi_handle(vpiExpr, term_h);
    if (net_h == NULL)
        return(""UNKNOWN PATH NAME"");
    term_name = vpi_get_str(vpiName, net_h);
    strcat(path_name, term_name);
    vpi_free_object(term_itr); /* free iterator--did not scan to null */

    strcat(path_name, ""s"");

    term_itr = vpi_iterate(vpiModPathOut, modpath_h);
    if (term_itr == NULL)
        return(""UNKNOWN PATH NAME"");
    term_h = vpi_scan(term_itr);
    net_h = vpi_handle(vpiExpr, term_h);
    if (net_h == NULL)
        return(""UNKNOWN PATH NAME"");
    term_name = vpi_get_str(vpiName, net_h);
    strcat(path_name, term_name);
    vpi_free_object(term_itr); /* free iterator--did not scan to null */

    return(path_name);
}
```

This code snippet seems to relate to functions used within the Verilog Procedural Interface (PLI), which is a standard interface for Verilog simulators that allows users to interact with Verilog simulations from C programs. The specific functions presented are used for printing delay information and building a path name from a module path handle.","
vpi_printf(""Delays for %s = (%2.f:%2.f:%2.f, %2.f:%2.f:%2.f)\n"",
    path_name,
    delay_array[0].real, delay_array[1].real, delay_array[2].real,
    delay_array[3].real, delay_array[4].real, delay_array[5].real);
}

char *PLIbook_BuildPathName(vpiHandle modpath_h)
{
    vpiHandle term_itr, term_h, net_h;
    static char path_name[2050]; /* character array to hold path name */
    char *term_name;

    path_name[0] = '\0'; /* clear the path name string */

    term_itr = vpi_iterate(vpiModPathIn, modpath_h);
    if (term_itr == NULL)
        return(""UNKNOWN PATH NAME"");
    term_h = vpi_scan(term_itr);
    net_h = vpi_handle(vpiExpr, term_h);
    if (net_h == NULL)
        return(""UNKNOWN PATH NAME"");
    term_name = vpi_get_str(vpiName, net_h);
    strcat(path_name, term_name);
    vpi_free_object(term_itr); /* free iterator--did not scan to null */

    strcat(path_name, ""s"");

    term_itr = vpi_iterate(vpiModPathOut, modpath_h);
    if (term_itr == NULL)
        return(""UNKNOWN PATH NAME"");
    term_h = vpi_scan(term_itr);
    net_h = vpi_handle(vpiExpr, term_h);
    if (net_h == NULL)
        return(""UNKNOWN PATH NAME"");
    term_name = vpi_get_str(vpiName, net_h);
    strcat(path_name, term_name);
    vpi_free_object(term_itr); /* free iterator--did not scan to null */

    return(path_name);
}
","Caption: ""Excerpt from The Verilog PLI Handbook detailing functions for manipulating and querying path and net names, and writing delay values into Verilog objects using the Programming Language Interface (PLI).""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p181.jpg,True,"The image contains Verilog code related to the illustration of scoping rules. Here is the code from the image:

First Example:
```verilog
module m;
  logic clk, a, b, c, d;
  let let_exp = a && b;

  always @(posedge clk) begin: B1
    let let_exp = c || d;
    a <= let_exp;
    b <= a;
  end
  assign c = let_exp;
  assign d = b;
endmodule
```

Equivalent code after expanding the let expression:
```verilog
module m;
  logic clk, a, b, c, d;
  always @(posedge clk) begin: B1
    a <= c || d;
    b <= a;
  end
  assign c = a && b;
  assign d = b;
endmodule
```

Example with macro replacement:
```verilog
`define macro_exp a && b
module m;
  logic clk, a, b, c, d;
  always @(posedge clk) begin: B1
    `define macro_exp c || d
    a <= `macro_exp;
    b <= a;
  end
  assign c = `macro_exp;
  assign d = b;
endmodule
```","
module m;
  logic clk, a, b, c, d;
  let let_exp = a && b;

  always @(posedge clk) begin: B1
    let let_exp = c || d;
    a <= let_exp;
    b <= a;
  end
  assign c = let_exp;
  assign d = b;
endmodule


module m;
  logic clk, a, b, c, d;
  always @(posedge clk) begin: B1
    a <= c || d;
    b <= a;
  end
  assign c = a && b;
  assign d = b;
endmodule


`define macro_exp a && b
module m;
  logic clk, a, b, c, d;
  always @(posedge clk) begin: B1
    `define macro_exp c || d
    a <= `macro_exp;
    b <= a;
  end
  assign c = `macro_exp;
  assign d = b;
endmodule
","""Exploring Verilog `let` declarations and scoping rules with example code and comparisons to macro definitions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p93.jpg,True,"The image contains an excerpt from a technical document discussing ""How to Use the VPI Routines"", which are associated with Verilog Programming Interface (VPI), a C interface to Verilog simulators. The code snippet presented within the image is a VPI callback function written in C that appears to interact with a Verilog simulation. Here is the code from the image:

```c
return(0);
}

/***********************************************************************
 * calltf routine                                                      *
 ***********************************************************************/
int PLIbook_ShowNets_calltf(char *user_data)
{
    vpiHandle systf_handle, arg_iterator, module_handle,
              net_iterator, net_handle;
    s_vpi_time current_time;
    s_vpi_value current_value;

    /* obtain a handle to the system task instance */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handle to system task argument */
    /* compiler has already verified only 1 arg with correct type */
    arg_iterator = vpi_iterate(vpiArgument, systf_handle);
    module_handle = vpi_scan(arg_iterator);
    vpi_free_object(arg_iterator);  /* free iterator memory */

    /* read current simulation time */
    current_time.type = vpiScaledRealTime;
    vpi_get_time(systf_handle, &current_time);

    vpi_printf(""\nAt time %2.2f, nets in module %s (%s):\n"",
               current_time.real,
               vpi_get_str(vpiFullName, module_handle),
               vpi_get_str(vpiDefName, module_handle));

    /* obtain handles to nets in module and read current value */
    net_iterator = vpi_iterate(vpiNet, module_handle);
    if (net_iterator == NULL)
        vpi_printf("" no nets found in this module\n"");
    else {
        current_value.format = vpiBinStrVal; /* read values as a string */
        while ((net_handle = vpi_scan(net_iterator)) != NULL) {
            vpi_get_value(net_handle, &current_value);
            vpi_printf("" net %-10s value is %s (binary)\n"",
                       vpi_get_str(vpiName, net_handle),
                       current_value.value.str);
        }
    }
    return(0);
}
```

This function is designed to print the values of nets within a module in a Verilog simulation at a specific time. It demonstrates how to use several VPI routines for accessing simulation data from within a C application.","n(0);
}

/***********************************************************************
 * calltf routine                                                      *
 ***********************************************************************/
int PLIbook_ShowNets_calltf(char *user_data)
{
    vpiHandle systf_handle, arg_iterator, module_handle,
              net_iterator, net_handle;
    s_vpi_time current_time;
    s_vpi_value current_value;

    /* obtain a handle to the system task instance */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handle to system task argument */
    /* compiler has already verified only 1 arg with correct type */
    arg_iterator = vpi_iterate(vpiArgument, systf_handle);
    module_handle = vpi_scan(arg_iterator);
    vpi_free_object(arg_iterator);  /* free iterator memory */

    /* read current simulation time */
    current_time.type = vpiScaledRealTime;
    vpi_get_time(systf_handle, &current_time);

    vpi_printf(""\nAt time %2.2f, nets in module %s (%s):\n"",
               current_time.real,
               vpi_get_str(vpiFullName, module_handle),
               vpi_get_str(vpiDefName, module_handle));

    /* obtain handles to nets in module and read current value */
    net_iterator = vpi_iterate(vpiNet, module_handle);
    if (net_iterator == NULL)
        vpi_printf("" no nets found in this module\n"");
    else {
        current_value.format = vpiBinStrVal; /* read values as a string */
        while ((net_handle = vpi_scan(net_iterator)) != NULL) {
            vpi_get_value(net_handle, &current_value);
            vpi_printf("" net %-10s value is %s (binary)\n"",
                       vpi_get_str(vpiName, net_handle),
                       current_value.value.str);
        }
    }
    return(0);
}
","""Example of using Verilog Procedural Interface (VPI) routines in a Verilog simulation environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p87.jpg,True,"The image contains Verilog code. Here it is:

```verilog
module test;
    wire a, b, ci, sum, co;

    addbit u1 (a, b, ci, sum, co);
endmodule

module addbit (a, b, ci, sum, co);
    input a, b, ci;
    output sum, co;

    wire a, b, ci, sum, co;

    xor      g1 (n1, a, b);
    xor #2   g2 (sum, n1, ci);
    and      g3 (n2, a, b);
    and      g4 (n3, n1, ci);
    or  #2   g5 (co, n2, n3);
endmodule
```

It's a simple example of a Verilog design, which is used to illustrate certain concepts related to using the VPI (Verilog Procedural Interface) routines, as mentioned in the chapter title. There's a schematic representation of object names and instance names such as ""u1"" for the instance of `addbit`, ""g1"" for the `xor` gate, and so on.","
module test;
    wire a, b, ci, sum, co;

    addbit u1 (a, b, ci, sum, co);
endmodule

module addbit (a, b, ci, sum, co);
    input a, b, ci;
    output sum, co;

    wire a, b, ci, sum, co;

    xor      g1 (n1, a, b);
    xor #2   g2 (sum, n1, ci);
    and      g3 (n2, a, b);
    and      g4 (n3, n1, ci);
    or  #2   g5 (co, n2, n3);
endmodule
",Verilog code example presenting a basic adder structure and information on using VPI routines to read logic values in Verilog.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p199.jpg,True,"Here is the Verilog code from the image:

```verilog
class Transaction;
  bit [31:0] addr, csm, data[8]; // No Statistic handle

  function Transaction copy();
    copy = new();                 // Construct destination
    copy.addr = addr;             // Fill in data values
    copy.csm = csm;
    copy.data = data;             // Array copy
  endfunction
endclass
```","
class Transaction;
  bit [31:0] addr, csm, data[8]; // No Statistic handle

  function Transaction copy();
    copy = new();                 // Construct destination
    copy.addr = addr;             // Fill in data values
    copy.csm = csm;
    copy.data = data;             // Array copy
  endfunction
endclass
","Caption: ""Illustration of shallow copying in object-oriented programming depicted along with a sample Verilog code demonstrating a simple class with a custom copy function.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p237.jpg,True,"The image displays a table from a Verilog tutorial explaining various operators used in Verilog code. These are not code snippets but rather part of a reference guide for coding in Verilog. Below are the tables of operators transcribed from the image:

Bit-wise.

```
Operator | Context | Function
-----------------------------------
&         | a & b   | and
|         | a | b   | or
^         | a ^ b   | exclusive or
~^        | a ~^ b  | exclusive nor
```

Logical.

```
Operator | Context | Function
-----------------------------------
&&        | a && b  | and
||        | a || b  | or
```

Relational.

```
Operator | Context | Function
------------------------------------
==        | a == b  | equality
!=        | a != b  | inequality
>         | a > b   | greater than
<         | a < b   | less than
>=        | a >= b  | greater or equal
<=        | a <= b  | less than or equal
```

Shift.

```
Operator | Context | Function
-------------------------------------------
<<        | a << b  | logical shift left
>>        | a >> b  | logical shift right
```

Unary operators

Bit-wise.

```
Operator | Context | Function
-----------------------------------
~         | ~a      | invert a
```","or | Context | Function
-----------------------------------
&         | a & b   | and
|         | a | b   | or
^         | a ^ b   | exclusive or
~^        | a ~^ b  | exclusive nor

or | Context | Function
-----------------------------------
&&        | a && b  | and
||        | a || b  | or

or | Context | Function
------------------------------------
==        | a == b  | equality
!=        | a != b  | inequality
>         | a > b   | greater than
<         | a < b   | less than
>=        | a >= b  | greater or equal
<=        | a <= b  | less than or equal

or | Context | Function
-------------------------------------------
<<        | a << b  | logical shift left
>>        | a >> b  | logical shift right

or | Context | Function
-----------------------------------
~         | ~a      | invert a
","""Overview of Verilog Operators: Bit-wise, Logical, Relational, Shift, and Unary Operators""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p182.jpg,True,"The image contains the following Verilog code:

```verilog
module test;
  reg [7:0] reg1, reg2;
  initial
  begin
    reg1 = 0; reg2 = 0;
    $put_value(reg1, reg2);
    $display(""reg1=%d reg2=%d"", reg1, reg2);
    $strobe(""reg1=%d reg2=%d"", reg1, reg2);
    #1 $finish;
  end
endmodule
```

The code snippet is part of an example illustrating the potential problem of putting a value into simulation using a delay of zero in a Verilog HDL simulation environment.","
module test;
  reg [7:0] reg1, reg2;
  initial
  begin
    reg1 = 0; reg2 = 0;
    $put_value(reg1, reg2);
    $display(""reg1=%d reg2=%d"", reg1, reg2);
    $strobe(""reg1=%d reg2=%d"", reg1, reg2);
    #1 $finish;
  end
endmodule
","""Exploring the concepts of no delay versus zero delay in Verilog PLI with example code snippet.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p195.jpg,True,"The image contains excerpts from a text discussing Verilog sequence expressions and the use of untyped arguments. There is one line of code present in the image:

```verilog
sequence s_def(bit [1:0] a, event b, int c, d, sequence s);
```

This line defines a sequence in Verilog where `s_def` is the name of the sequence and it takes parameters of different types (a 2-bit vector, an event, an integer, an untyped parameter `d`, and another sequence `s`).","
sequence s_def(bit [1:0] a, event b, int c, d, sequence s);
","""Excerpt from a text on Verilog discussing the use of sequence expressions and untyped arguments in sequence declarations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p487.jpg,True,"The image contains Verilog code within it. Here is the code snippet extracted from the image:

```verilog
bit[7:0] adr1;
covergroup cg @(posedge clk);
ac: coverpoint adr1
{
    bins adrb2 = (1=>2=>3);
    bins adrb3[] = (1,2 => 3,4);
    bins adrb5 = ('hf [*3]);
    bins adrb6 = ('ha [->3]);
}
```

This code defines a covergroup for functional coverage in Verilog, which is used for verifying that certain conditions have occurred during simulation.","
bit[7:0] adr1;
covergroup cg @(posedge clk);
ac: coverpoint adr1
{
    bins adrb2 = (1=>2=>3);
    bins adrb3[] = (1,2 => 3,4);
    bins adrb5 = ('hf [*3]);
    bins adrb6 = ('ha [->3]);
}
","""Exploring Verilog transition coverage in coverage groups with examples of bin definitions and coverage results.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p292.jpg,True,"The image contains Verilog code defining a property for a hardware verification process. Here is the code extracted from the image:

```verilog
property p_tchk10;
    @(posedge clk)
        (!irdyn && !trdyn && !devesln && !framen) |->
        ##[1:8] (!irdyn && (!trdyn || !stopn));
endproperty

a_tchk10: assert property(p_tchk10);
c_tchk10: cover property(p_tchk10);
```","
property p_tchk10;
    @(posedge clk)
        (!irdyn && !trdyn && !devesln && !framen) |->
        ##[1:8] (!irdyn && (!trdyn || !stopn));
endproperty

a_tchk10: assert property(p_tchk10);
c_tchk10: cover property(p_tchk10);
","The image displays an excerpt from a book or document that discusses Verilog properties for checking signal timings in simulation. It includes a specific example of a Verilog property `p_tchk10` related to latency checking in data transmission, along with assert and cover statements.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p364.jpg,True,"This image includes text related to Property Specification Language (PSL) and its directives within the context of Verilog, which is a hardware description language. Here's the content presented as text:

```
property Name [ ( Formal_Parameter_List ) ]
DEF_SYM Property;

Formal_Parameter_List ::=
    Formal_Parameter { ; Formal_Parameter }

Formal_Parameter ::=
    ParamType Name { , Name }

ParamType ::=
    const | boolean | property | sequence

Sequence_Declaration ::=
    sequence Name [ ( Formal_Parameter_List ) ]
    DEF_SYM Sequence ;(see B.8.3.5)

Endpoint_Declaration ::=
    endpoint Name [ ( Formal_Parameter_List ) ]
    DEF_SYM Sequence ;(see B.8.3.5)

Clock_Declaration ::=
    default clock DEF_SYM Clock_Expression ;(see B.8.3.7)

Clock_Expression ::=
    Boolean
    | ‘(‘ HDL_CLK_EXPR ‘)’

Actual_Parameter_List ::=
    Actual_Parameter { , Actual_Parameter }

Actual_Parameter ::=
     Number | Boolean | Property | Sequence (see B.8.3.7) (see B.8.3.4) (see B.8.3.5)

B.8.3.3 PSL directives

PSL Directive ::=
    [ Label: ] Verification_Directive

Label ::=
    HDL_or_PSL_Identifier

HDL_or_PSL_Identifier ::=
    System Verilog_Identifier
    | Verilog_Identifier
    | VHDL_Identifier
    | GDL_Identifier
    | PSL_Identifier

Verification_Directive ::=
    Assert_Statement
    | Assume_Statement
    | Assume_Guarantee_Statement
    | Restrict_Statement
    | Restrict_Guarantee_Statement
    | Cover_Statement
    | Fairness_Statement
```

The content on the image describes syntax for defining properties, sequences, clocks, and parameters in PSL. It also lists different types of identifiers and directives related to verification, such as assertions, assumptions, restrictions, coverage, and fairness statements.","ty Name [ ( Formal_Parameter_List ) ]
DEF_SYM Property;

Formal_Parameter_List ::=
    Formal_Parameter { ; Formal_Parameter }

Formal_Parameter ::=
    ParamType Name { , Name }

ParamType ::=
    const | boolean | property | sequence

Sequence_Declaration ::=
    sequence Name [ ( Formal_Parameter_List ) ]
    DEF_SYM Sequence ;(see B.8.3.5)

Endpoint_Declaration ::=
    endpoint Name [ ( Formal_Parameter_List ) ]
    DEF_SYM Sequence ;(see B.8.3.5)

Clock_Declaration ::=
    default clock DEF_SYM Clock_Expression ;(see B.8.3.7)

Clock_Expression ::=
    Boolean
    | ‘(‘ HDL_CLK_EXPR ‘)’

Actual_Parameter_List ::=
    Actual_Parameter { , Actual_Parameter }

Actual_Parameter ::=
     Number | Boolean | Property | Sequence (see B.8.3.7) (see B.8.3.4) (see B.8.3.5)

B.8.3.3 PSL directives

PSL Directive ::=
    [ Label: ] Verification_Directive

Label ::=
    HDL_or_PSL_Identifier

HDL_or_PSL_Identifier ::=
    System Verilog_Identifier
    | Verilog_Identifier
    | VHDL_Identifier
    | GDL_Identifier
    | PSL_Identifier

Verification_Directive ::=
    Assert_Statement
    | Assume_Statement
    | Assume_Guarantee_Statement
    | Restrict_Statement
    | Restrict_Guarantee_Statement
    | Cover_Statement
    | Fairness_Statement
",Syntax specification for properties and PSL (Property Specification Language) directives in Verilog/SystemVerilog.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p286.jpg,True,"The image contains two Verilog sequences written in SystemVerilog Assertion (SVA) syntax:

```verilog
sequence s_tchk7a;
    @(posedge clk)
    $fell (framen) ##[1:8] $fell(irdyn);
endsequence

sequence s_tchk7b;
    @(posedge clk)
    $fell (framen) ##[1:5]
    $fell(devseln) && $fell(stopn) && trdyn;
endsequence
```

These sequences appear to be part of a larger context of code that is used to specify certain conditions or assertions, likely in the context of hardware verification for a PCI transaction.","
sequence s_tchk7a;
    @(posedge clk)
    $fell (framen) ##[1:8] $fell(irdyn);
endsequence

sequence s_tchk7b;
    @(posedge clk)
    $fell (framen) ##[1:5]
    $fell(devseln) && $fell(stopn) && trdyn;
endsequence
","""Excerpt from a technical document showing a waveform timing diagram for a PCI Target check, followed by example SystemVerilog sequences for simulation checks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p493.jpg,True,"The image contains Verilog code related to coverage bins with examples. Here's the code that is present in the image:

```verilog
covergroup cg1 @(posedge clk);
  coverpoint a {
    bins b1[] = {0, 1, 2, 3};
    bins b2 = {[5:8], 9};
    ignore_bins ignore_vals = {0, 3, 1, 2;};
  }
endgroup

covergroup CG @(posedge clk);
  coverpoint var1 {
    wildcard bins b1 = { 1'bx };
    ignore_bins ign = {0,1};
  }
endgroup // CG
```

This code snippet demonstrates the concept of `ignore_bins` in a coverage group, which is used in hardware verification to mark specific values that should not be counted for coverage purposes.","
covergroup cg1 @(posedge clk);
  coverpoint a {
    bins b1[] = {0, 1, 2, 3};
    bins b2 = {[5:8], 9};
    ignore_bins ignore_vals = {0, 3, 1, 2;};
  }
endgroup

covergroup CG @(posedge clk);
  coverpoint var1 {
    wildcard bins b1 = { 1'bx };
    ignore_bins ign = {0,1};
  }
endgroup // CG
",Verilog code discussion about 'ignore_bins' in coverage analysis with examples of bin specifications.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p478.jpg,True,"The image contains a snippet of Verilog code inside a textbook or educational material, as well as some explanatory text discussing the concept of ""cross coverage"" in functional coverage. Here is the Verilog code present in the image:

```verilog
bit [1:0] offset, adr;

covergroup cg1 @(posedge clk);
    coverpoint offset {
        bins ofsbin[] = {[0:3]};
    } // 4 bins of 'offset'
    coverpoint adr {
        bins adrbn[] = {[0:3]};
    } // 4 bins of 'adr'

    // cross of adr and offset gives 16 cross bins (4 bins of 'ofst' * 4 bins of 'adr')
    adr_ofst: cross ar, ofst;
    
endgroup

cg1 cg1Inst = new;
```

Additionally, there is a part of a bin expression at the end of the page:

```verilog
bins <adrbn[2],ofsbin[0]> = 0 1ZERO
``` 

The text provides further context, explaining the concept of cross coverage within Verilog and how that relates to the bins and coverpoints when running simulations and checking the coverage of different scenarios.","
bit [1:0] offset, adr;

covergroup cg1 @(posedge clk);
    coverpoint offset {
        bins ofsbin[] = {[0:3]};
    } // 4 bins of 'offset'
    coverpoint adr {
        bins adrbn[] = {[0:3]};
    } // 4 bins of 'adr'

    // cross of adr and offset gives 16 cross bins (4 bins of 'ofst' * 4 bins of 'adr')
    adr_ofst: cross ar, ofst;
    
endgroup

cg1 cg1Inst = new;


bins <adrbn[2],ofsbin[0]> = 0 1ZERO
","""Exploring the Basics of Cross Coverage in Verilog Functional Coverage""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p50.jpg,True,"The image displays an excerpt from ""The Verilog PLI Handbook,"" featuring information about Verilog code though no complete examples of Verilog code are provided. The text refers to user-defined system tasks and functions as well as how to use system tasks and functions in Verilog, however, there are partial code fragments suggesting syntax. Here's what is visible as partial or example code fragments:

1. Examples of legal user-defined system task and function names:
```
$rand64
$cell_count
$GetVector
```

2. Syntax referring to when a system task can be called in Verilog:
```verilog
always @(posedge clock)
$read_test_vector(""vectors.pat"", input_vector);
```

Please note that these are not complete code segments but a snippet and an example of usage within the text.","4
$cell_count
$GetVector


always @(posedge clock)
$read_test_vector(""vectors.pat"", input_vector);
","""Overview of Verilog PLI user-defined system tasks and functions, including an example of a procedural system task call.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p155.jpg,True,"```c
while ( *arg != NULL ) { /* loop until null termination */
#ifdef PLIbook_verbose
    for (i=0; i<PLIbook_indent; i++)
        vpi_printf("" "");
    vpi_printf(""%s\n"", *arg);
#endif
    if (strcmp(*arg, option) == 0) {
        PLIbook_optfound = 1;
    }
    if (strcmp(*arg, ""-f"") == 0) {
        arg++; /* next arg is address to array of strings */
        PLIbook_ScanCommandFile(option, (char **)*arg);
    }
    arg++;
}
#ifdef PLIbook_verbose
    PLIbook_indent -= 4; /* decrease text indentation */
#endif
return;
}
```

This is the code provided in the image. It is written in C and it appears to be part of a larger program that processes command line arguments, possibly for a simulation tool that uses the Verilog Programming Interface (VPI). The specific purpose of this code snippet is to manipulate options for the tool, checking for verbosity and presence of certain flags (like ""-f""), and managing indentation for display purposes."," ( *arg != NULL ) { /* loop until null termination */
#ifdef PLIbook_verbose
    for (i=0; i<PLIbook_indent; i++)
        vpi_printf("" "");
    vpi_printf(""%s\n"", *arg);
#endif
    if (strcmp(*arg, option) == 0) {
        PLIbook_optfound = 1;
    }
    if (strcmp(*arg, ""-f"") == 0) {
        arg++; /* next arg is address to array of strings */
        PLIbook_ScanCommandFile(option, (char **)*arg);
    }
    arg++;
}
#ifdef PLIbook_verbose
    PLIbook_indent -= 4; /* decrease text indentation */
#endif
return;
}
","""Excerpt from a technical document detailing VPI Routine Library for Verilog and a code snippet for comparing VPI object handles.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p633.jpg,True,"```c
int excep;
int err;
PLIbook_SciALUoutputs_p next_ALU_outputs; // next stack location
} PLIbook_SciALUoutputs_s;

/* declare global stack pointer */
static PLIbook_SciALUoutputs_p ALU_outputs_stack = NULL;

/********************************************************************
* C model of a Scientific Arithmetic Logic Unit.
* Latched outputs version.
********************************************************************/

#include <math.h>
#include <errno.h>
void PLIbook_ScientificALU_C_model(
    int enable,          /* input; 0 = latched */
    double a,            /* input */
    double b,            /* input */
    int opcode,          /* input */
    double *result,      /* output from ALU */
    int *excep,          /* output; set if result is out of range */
    int *err,            /* output; set if input is out of range */
    char instance_p[]    /* input; pointer to system task instance */
)
{
    PLIbook_SciALUoutputs_p ALU_outputs;

    /* Locate the output storage in the stack for this model instance */
    /* If no storage is found, then allocate a storage block and add */
    /* the storage to the stack. */
    ALU_outputs = ALU_outputs_stack; /* top-of-stack is in global var. */
    while (ALU_outputs && (ALU_outputs->instance_p != instance_p))
        ALU_outputs = ALU_outputs->next_ALU_outputs;

    /* If no storage area found for this model instance, create one */
    if (ALU_outputs == NULL) {
        ALU_outputs = 
            (PLIbook_SciALUoutputs_p)malloc(sizeof(PLIbook_SciALUoutputs_s));
        ALU_outputs->instance_p = instance_p; /* set owner of this space */
        ALU_outputs->next_ALU_outputs = NULL;
    }
    ALU_outputs_stack = ALU_outputs; /* save new top-of-stack */

    if (enable) { /* ALU is not latched, calculate outputs and store */
        switch (opcode) {
            case 0x0: ALU_outputs->result = pow (a, b); break;
            case 0x1: ALU_outputs->result = sqrt (a); break;
            case 0x2: ALU_outputs->result = exp (a); break;
            case 0x3: ALU_outputs->result = ldexp (a, (int)b); break;
            case 0x4: ALU_outputs->result = fabs (a); break;
            case 0x5: ALU_outputs->result = fmod (a, b); break;
            case 0x6: ALU_outputs->result = ceil (a); break;
            case 0x7: ALU_outputs->result = floor (a); break;
            case 0x8: ALU_outputs->result = log (a); break;
        }
    }
}
```
This is the C code shown in the image, which represents the C model of a Scientific Arithmetic Logic Unit (ALU) with latched outputs. It includes routines to perform various mathematical operations based on the opcode provided.","xcep;
int err;
PLIbook_SciALUoutputs_p next_ALU_outputs; // next stack location
} PLIbook_SciALUoutputs_s;

/* declare global stack pointer */
static PLIbook_SciALUoutputs_p ALU_outputs_stack = NULL;

/********************************************************************
* C model of a Scientific Arithmetic Logic Unit.
* Latched outputs version.
********************************************************************/

#include <math.h>
#include <errno.h>
void PLIbook_ScientificALU_C_model(
    int enable,          /* input; 0 = latched */
    double a,            /* input */
    double b,            /* input */
    int opcode,          /* input */
    double *result,      /* output from ALU */
    int *excep,          /* output; set if result is out of range */
    int *err,            /* output; set if input is out of range */
    char instance_p[]    /* input; pointer to system task instance */
)
{
    PLIbook_SciALUoutputs_p ALU_outputs;

    /* Locate the output storage in the stack for this model instance */
    /* If no storage is found, then allocate a storage block and add */
    /* the storage to the stack. */
    ALU_outputs = ALU_outputs_stack; /* top-of-stack is in global var. */
    while (ALU_outputs && (ALU_outputs->instance_p != instance_p))
        ALU_outputs = ALU_outputs->next_ALU_outputs;

    /* If no storage area found for this model instance, create one */
    if (ALU_outputs == NULL) {
        ALU_outputs = 
            (PLIbook_SciALUoutputs_p)malloc(sizeof(PLIbook_SciALUoutputs_s));
        ALU_outputs->instance_p = instance_p; /* set owner of this space */
        ALU_outputs->next_ALU_outputs = NULL;
    }
    ALU_outputs_stack = ALU_outputs; /* save new top-of-stack */

    if (enable) { /* ALU is not latched, calculate outputs and store */
        switch (opcode) {
            case 0x0: ALU_outputs->result = pow (a, b); break;
            case 0x1: ALU_outputs->result = sqrt (a); break;
            case 0x2: ALU_outputs->result = exp (a); break;
            case 0x3: ALU_outputs->result = ldexp (a, (int)b); break;
            case 0x4: ALU_outputs->result = fabs (a); break;
            case 0x5: ALU_outputs->result = fmod (a, b); break;
            case 0x6: ALU_outputs->result = ceil (a); break;
            case 0x7: ALU_outputs->result = floor (a); break;
            case 0x8: ALU_outputs->result = log (a); break;
        }
    }
}
","""Excerpt from a book on interfacing C models with Verilog using ACC routines, showing code for a scientific arithmetic logic unit (ALU).""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p627.jpg,True,"The image does contain code. Here it is:

```verilog
ALUdata->opcode_h = acc_handle_tfarg(ALU_OP);
ALUdata->result_h = acc_handle_tfarg(ALU_RESULT);
ALUdata->excep_h = acc_handle_tfarg(ALU_EXCEPT);
ALUdata->err_h = acc_handle_tfarg(ALU_ERROR);

/* add VCL flag to the clock input to the C model */
/* pass pointer to storage for handles as user_data value */
acc_vcl_add(ALUdata->clock_h, PLIDbook_ScientificALU_interface,
            (char*)ALUdata, vcl_verilog_logic);

acc_close();
return(0);
}
```

The code seems to be a snippet likely from a Verilog simulation and interfacing example, involving ACC (Access) routines used for interfacing Verilog with C models. The `acc_vcl_add` function is used for adding a Value Change Link (VCL) callback to a given signal.","
ALUdata->opcode_h = acc_handle_tfarg(ALU_OP);
ALUdata->result_h = acc_handle_tfarg(ALU_RESULT);
ALUdata->excep_h = acc_handle_tfarg(ALU_EXCEPT);
ALUdata->err_h = acc_handle_tfarg(ALU_ERROR);

/* add VCL flag to the clock input to the C model */
/* pass pointer to storage for handles as user_data value */
acc_vcl_add(ALUdata->clock_h, PLIDbook_ScientificALU_interface,
            (char*)ALUdata, vcl_verilog_logic);

acc_close();
return(0);
}
","A text excerpt discussing the synchronization strategies for interfacing C models with Verilog simulations using ACC routines, accompanied by sample ACC Verilog code.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p279.jpg,True,"The image contains Verilog code in the form of properties defined for SystemVerilog Assertions (SVA). Below are the properties from the image:

```verilog
property p_mcov1;
@(posedge clk)
`s_IO_READ ##1 (devseln)[*5] |=> $rose (irdyn);
endproperty

property p_mcov2;
@(posedge clk)
`s_IO_WRITE ##1 (devseln)[*5] |=> $rose (irdyn);
endproperty
```","
property p_mcov1;
@(posedge clk)
`s_IO_READ ##1 (devseln)[*5] |=> $rose (irdyn);
endproperty

property p_mcov2;
@(posedge clk)
`s_IO_WRITE ##1 (devseln)[*5] |=> $rose (irdyn);
endproperty
","Caption: ""Example of SystemVerilog Assertions for Protocol Interface Checking in a PCI Master""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p156.jpg,True,"The image contains Verilog code in two examples. Here are the code snippets extracted from the image:

Example 7.7:
```verilog
c_changed: cover final (sig != $sampled(sig))
  $info(""%t: sig value changed"", $time);
```

Example 7.8:
```verilog
a1: assert property (@(posedge clk) $sampled(a));

a2: assert property (@(posedge clk) a);
```","
c_changed: cover final (sig != $sampled(sig))
  $info(""%t: sig value changed"", $time);


a1: assert property (@(posedge clk) $sampled(a));

a2: assert property (@(posedge clk) a);
","Caption: ""Overview of Verilog sampled value functions and examples of using `$sampled` in system functions and assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p141.jpg,True,"```verilog
int PLIbook_PortInfo_calltf(char *user_data)
{
  vpiHandle systf_h, arg_itr, mod_h,
            port_itr, port_h, lowconn_h, highconn_h;
  int lowconn_type, highconn_type;
}
```","
int PLIbook_PortInfo_calltf(char *user_data)
{
  vpiHandle systf_h, arg_itr, mod_h,
            port_itr, port_h, lowconn_h, highconn_h;
  int lowconn_type, highconn_type;
}
","Caption: ""Diagram and example code snippet for traversing module ports and their connections using Verilog Procedural Interface (VPI) in a Verilog simulation environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p44.jpg,True,"The image contains two snippets of code. Below is the transcription for both:

1. C source code for the register function for `$show_value`:

```c
void PLIbook_ShowVal_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type        = vpiSysTask;
    tf_data.tfname      = ""$show_value"";
    tf_data.calltf      = PLIbook_ShowVal_calltf;
    tf_data.compiletf   = PLIbook_ShowVal_compiletf;
    tf_data.sizetf      = NULL;
    vpi_register_systf(&tf_data);
    return;
}
```

2. Verilog HDL source code for a test case for the `$show_value` application:

```verilog
`timescale 1ns / 1ns
module test;
    reg a, b, ci, clk;
    wire sum, co;
    addbit il (a, b, ci, sum, co);
    initial
    begin
       clk = 0;
       a = 0;
       b = 0;
       ci = 0;
       #10 a = 1;
       #10 b = 1;
       $show_value(sum);
       $show_value(co);
       $show_value(il.n3);
       #10 $stop;
       $finish;
    end
endmodule
```

These code snippets demonstrate the usage of the Verilog Programming Language Interface (PLI) within Verilog hardware description language.","PLIbook_ShowVal_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type        = vpiSysTask;
    tf_data.tfname      = ""$show_value"";
    tf_data.calltf      = PLIbook_ShowVal_calltf;
    tf_data.compiletf   = PLIbook_ShowVal_compiletf;
    tf_data.sizetf      = NULL;
    vpi_register_systf(&tf_data);
    return;
}


`timescale 1ns / 1ns
module test;
    reg a, b, ci, clk;
    wire sum, co;
    addbit il (a, b, ci, sum, co);
    initial
    begin
       clk = 0;
       a = 0;
       b = 0;
       ci = 0;
       #10 a = 1;
       #10 b = 1;
       $show_value(sum);
       $show_value(co);
       $show_value(il.n3);
       #10 $stop;
       $finish;
    end
endmodule
","""Verilog PLI Handbook excerpt showing C code to register a Verilog PLI function and a Verilog HDL test case example utilizing the $show_value PLI application.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p169.jpg,True,"The image includes snippets of Verilog code. Here are the snippets provided:

```verilog
reg [39:0] data; /* little endian -- LSB is bit 0 */
reg [0:39] data2; /* big endian -- LSB is bit 39 */
reg [40:1] data3; /* little endian -- LSB is bit 1 */
```","
reg [39:0] data; /* little endian -- LSB is bit 0 */
reg [0:39] data2; /* big endian -- LSB is bit 39 */
reg [40:1] data3; /* little endian -- LSB is bit 1 */
","Caption: ""Illustration of Verilog vector bit mapping and endian conventions for vector declarations in Verilog, with respect to C integer representation using aval/bval pairs.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p322.jpg,True,"The image contains information about the ""eventually"" and ""s_eventually"" operators in Verilog. Below is the code appearing in the image:

```verilog
property p1;
  s_eventually $fell(frame_);
endproperty

property p2;
  s_eventually [2:5] $fell(frame_);
endproperty p2;
```

This code defines two properties, `p1` and `p2`, using the `s_eventually` operator in Verilog syntax. The properties are meant to hold for sequences related to the falling edge of a signal called `frame_`. The first property `p1` does not specify a range, meaning it waits for the falling edge of `frame_` eventually at any time in the future. The second property `p2` specifies a range `[2:5]`, meaning it expects the falling edge of `frame_` to occur within 2 to 5 clock cycles.","
property p1;
  s_eventually $fell(frame_);
endproperty

property p2;
  s_eventually [2:5] $fell(frame_);
endproperty p2;
","""Introduction to Verilog's eventually and strong eventually ('s_eventually') operators with code examples.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p251.jpg,True,"The image contains Verilog code which is related to SystemVerilog Assertions (SVA) for memories. Here is the code extracted from the image:

```verilog
property p_write;
    @(posedge clk2x) s_write.matched
    |-> ##1 ($isunknown(data) == 0)
         ##1 ($isunknown(data) == 0);
endproperty

a_write: assert property(p_write);
c_write: cover property(p_write);
```

The code snippet defines a property `p_write` for asserting the conditions of a write operation in the context of memory interfacing. The image also includes a waveform diagram related to DDR-SDRAM burst write operations.","
property p_write;
    @(posedge clk2x) s_write.matched
    |-> ##1 ($isunknown(data) == 0)
         ##1 ($isunknown(data) == 0);
endproperty

a_write: assert property(p_write);
c_write: cover property(p_write);
","""Verilog code snippet demonstrating SystemVerilog Assertions (SVA) for memory operations, accompanied by a waveform diagram illustrating DDR-SDRAM burst write operations.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p245.jpg,True,"The image contains a snippet of code written in Verilog, specifically a SystemVerilog Assertion (SVA) for verifying certain properties in digital design. Here is the code:

```verilog
property p_tAa;
@(posedge clk) (!sel_n[2] && we_n && !oe_n) |=> ((addr == $past(addr,1)) ##0 (!$isunknown(data))==0);
endproperty
```

This code describes a property used in formal verification to ensure that under certain conditions on the signals `sel_n`, `we_n`, `oe_n`, and `addr`, the `data` is not unknown (`$isunknown(data) == 0`), respecting the timing defined by the clock (`posedge clk`). The `##0` symbol indicates a zero cycle delay between the change in the `addr` signal and the check for unknown `data`.","
property p_tAa;
@(posedge clk) (!sel_n[2] && we_n && !oe_n) |=> ((addr == $past(addr,1)) ##0 (!$isunknown(data))==0);
endproperty
","Caption: ""SystemVerilog Assertions (SVA) for memory interface timing verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p336.jpg,True,"The image contains snippets of code in Verilog. Here is the code present in the image:

```
#    70  rst=0  clk=1  x=1  y=0  z=0
#    80  rst=1  clk=0  x=1  y=0  z=0  //rst=1, so disable the property
#    90  rst=1  clk=1  x=1  y=0  z=0
#   100  rst=1  clk=0  x=1  y=0  z=0
#   110  rst=1  clk=1  x=1  y=0  z=0
#   120  rst=1  clk=0  x=1  y=0  z=0
#   130  rst=1  clk=1  x=1  y=0  z=0
#   140  rst=1  clk=0  x=1  y=0  z=0
#   150  rst=1  clk=1  x=1  y=0  z=0
#   160  rst=0  clk=0  x=1  y=1  z=0  //rst=0, so enable the property
#   170  rst=0  clk=1  x=1  y=1  z=0
#   180  rst=0  clk=0  x=1  y=1  z=0
#   180  PASS  //Pass at negedge of clock
```

Please note that these are not complete Verilog statements. It appears to be a series of comments outlining a testbench or waveform diagram with different signal values at different time units. The values for `rst`, `clk`, `x`, `y`, and `z` are provided at different timesteps, which are commented with either enabling or disabling a property in the context of formal verification. There's also a comment indicating a ""PASS"" condition at the negative edge of the clock.","0  rst=0  clk=1  x=1  y=0  z=0
#    80  rst=1  clk=0  x=1  y=0  z=0  //rst=1, so disable the property
#    90  rst=1  clk=1  x=1  y=0  z=0
#   100  rst=1  clk=0  x=1  y=0  z=0
#   110  rst=1  clk=1  x=1  y=0  z=0
#   120  rst=1  clk=0  x=1  y=0  z=0
#   130  rst=1  clk=1  x=1  y=0  z=0
#   140  rst=1  clk=0  x=1  y=0  z=0
#   150  rst=1  clk=1  x=1  y=0  z=0
#   160  rst=0  clk=0  x=1  y=1  z=0  //rst=0, so enable the property
#   170  rst=0  clk=1  x=1  y=1  z=0
#   180  rst=0  clk=0  x=1  y=1  z=0
#   180  PASS  //Pass at negedge of clock
","This image contains text explaining the ""restrict"" property for formal verification in Verilog, alongside code examples illustrating property declarations and tests.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p78.jpg,True,"There is a line of code in the image. Here it is:

```verilog
vpiHandle primitive_handle, net_handle;
```","
vpiHandle primitive_handle, net_handle;
","A page from ""The Verilog PLI Handbook"" describing the `vpiHandle` data type and cautioning against sharing handles between VPI and ACC routines.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p166.jpg,True,"The image contains Verilog code for defining interfaces in a hardware description language context. Here is the code written as text:

Sample 4.47 Rx interface with modports and clocking block
```verilog
interface Rx_if (input logic clk);
    logic [7:0] data;
    logic soc, en, clav, rclk;

    clocking cb @(posedge clk);
        output data, soc, clav; // Directions are relative
        input en;               // to the testbench
    endclocking : cb

    modport DUT (output en, rclk,
                 input data, soc, clav);

    modport TB (clocking cb);
endinterface : Rx_if
```

Sample 4.48 Tx interface with modports and clocking block
```verilog
interface Tx_if (input logic clk);
    logic [7:0] data;
    logic soc, en, clav, tclk;

    clocking cb @(posedge clk);
        input data, soc, en;
        output clav;
    endclocking : cb

    modport DUT (output data, soc, en, tclk,
                 input clk, clav);

    modport TB (clocking cb);
endinterface : Tx_if
```
This Verilog code illustrates how to create an Rx (Receiver) and a Tx (Transmitter) interface with modports to specify which signals are inputs and outputs, and a clocking block to define how timing sensitive communication should occur based on the rising edge of the clock signal (`posedge clk`).","
interface Rx_if (input logic clk);
    logic [7:0] data;
    logic soc, en, clav, rclk;

    clocking cb @(posedge clk);
        output data, soc, clav; // Directions are relative
        input en;               // to the testbench
    endclocking : cb

    modport DUT (output en, rclk,
                 input data, soc, clav);

    modport TB (clocking cb);
endinterface : Rx_if


interface Tx_if (input logic clk);
    logic [7:0] data;
    logic soc, en, clav, tclk;

    clocking cb @(posedge clk);
        input data, soc, en;
        output clav;
    endclocking : cb

    modport DUT (output data, soc, en, tclk,
                 input clk, clav);

    modport TB (clocking cb);
endinterface : Tx_if
",Caption: Examples of Verilog ATM Rx and Tx interface definitions with modports and clocking blocks.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p394.jpg,True,"The image contains code written in C, likely intended to interface with Verilog simulations through the PLI (Programming Language Interface). Here is the code present in the image:

```c
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
/***********************************************************************
* checktf application
***********************************************************************/
int PLIbook_FillMem_checktf()
{
    if (tf_nump() != 2)
        tf_error(""Usage: $fill_mem(mem_word_select,word_select_address);"");
    return(0);
}

/***********************************************************************
* misctf application
*
* The misctf application is used to call tf_nodeinfo() at the
* beginning of simulation, so that the memory allocated by
* tf_nodeinfo() and tf_exprinfo() is only allocated one time for each
* instance of $fill_mem.
***********************************************************************/
typedef struct PLIbook_my_data {
    p_tfnodeinfo node_info; /* pointer to structure for tf_nodeinfo() */
    p_tfexprinfo expr_info; /* pointer to structure for tf_exprinfo() */
} PLIbook_my_data_s, *PLIbook_my_data_p;

int PLIbook_FillMem_misctf(int user_data, int reason)
{
    PLIbook_my_data_p info; /* pointer to info structures */

    if (reason != REASON_ENDOFCOMPILE)
        return(0); /* exit now if this is not the start of simulation */

    /* allocate memory for structure to store info structure */
    info = (PLIbook_my_data_p)malloc(sizeof(PLIbook_my_data_s));
    
    /* allocate memory for an s_nodeinfo and an s_tfexprinfo structure */
    info->node_info = (p_tfnodeinfo)malloc(sizeof(s_tfnodeinfo));
    info->expr_info = (p_tfexprinfo)malloc(sizeof(s_tfexprinfo));

    /* Get the nodeinfo structure for tfarg 1 */
    if (!tf_nodeinfo(1, info->node_info)) {
        tf_error(""Error: $fill_mem could not get tf_nodeinfo for tfarg 1"");
```

The code snippet ends there and does not include the ending curly bracket or any other parts of functions that may follow. It is important to have the entire function and context to understand the complete functionality and use of the code.","ude ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
/***********************************************************************
* checktf application
***********************************************************************/
int PLIbook_FillMem_checktf()
{
    if (tf_nump() != 2)
        tf_error(""Usage: $fill_mem(mem_word_select,word_select_address);"");
    return(0);
}

/***********************************************************************
* misctf application
*
* The misctf application is used to call tf_nodeinfo() at the
* beginning of simulation, so that the memory allocated by
* tf_nodeinfo() and tf_exprinfo() is only allocated one time for each
* instance of $fill_mem.
***********************************************************************/
typedef struct PLIbook_my_data {
    p_tfnodeinfo node_info; /* pointer to structure for tf_nodeinfo() */
    p_tfexprinfo expr_info; /* pointer to structure for tf_exprinfo() */
} PLIbook_my_data_s, *PLIbook_my_data_p;

int PLIbook_FillMem_misctf(int user_data, int reason)
{
    PLIbook_my_data_p info; /* pointer to info structures */

    if (reason != REASON_ENDOFCOMPILE)
        return(0); /* exit now if this is not the start of simulation */

    /* allocate memory for structure to store info structure */
    info = (PLIbook_my_data_p)malloc(sizeof(PLIbook_my_data_s));
    
    /* allocate memory for an s_nodeinfo and an s_tfexprinfo structure */
    info->node_info = (p_tfnodeinfo)malloc(sizeof(s_tfnodeinfo));
    info->expr_info = (p_tfexprinfo)malloc(sizeof(s_tfexprinfo));

    /* Get the nodeinfo structure for tfarg 1 */
    if (!tf_nodeinfo(1, info->node_info)) {
        tf_error(""Error: $fill_mem could not get tf_nodeinfo for tfarg 1"");
","Caption: ""Verilog PLI code example for memory manipulation using tf_nodeinfo() function from The Verilog PLI Handbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p397.jpg,True,"```verilog
sequence s_skip(
    local input bit [0:$clog2(MAX_OUTSTANDING)] numToSkip
);
    {numToSkip > 0 ##0 complete[-1], numToSkip--} [*]
    ##1 (numToSkip == 0 ##0 complete[-1]);
endsequence

property p_fifo_data_check;
    datatype data;
    bit [0:$clog2(MAX_OUTSTANDING)] numAhead;
    {(start, data = dataIn, numAhead = outstanding)
    ##1 s_skip(.numToSkip(numAhead))
    |->
    dataOut == data;
}
endproperty

a_fifo_data_check: assert property (p_fifo_data_check);
```
This is the Verilog code snippet that's presented in the image. It shows a `sequence` and a `property` definition, used for checking a FIFO protocol data, followed by an `assert` statement to check the defined property.","
sequence s_skip(
    local input bit [0:$clog2(MAX_OUTSTANDING)] numToSkip
);
    {numToSkip > 0 ##0 complete[-1], numToSkip--} [*]
    ##1 (numToSkip == 0 ##0 complete[-1]);
endsequence

property p_fifo_data_check;
    datatype data;
    bit [0:$clog2(MAX_OUTSTANDING)] numAhead;
    {(start, data = dataIn, numAhead = outstanding)
    ##1 s_skip(.numToSkip(numAhead))
    |->
    dataOut == data;
}
endproperty

a_fifo_data_check: assert property (p_fifo_data_check);
","Caption: ""Verilog code snippet illustrating a FIFO protocol data check sequence and property declaration, with an accompanying explanation on variable passing in sequence methods.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p380.jpg,True,"There is code in this image, and it appears to be an excerpt from a programming book or document related to Verilog, specifically dealing with the Verilog Procedural Interface (PLI). Here's the code as shown in the image:

```c
io_printf("" node_is_index = %d\n"", node_info.node_is_index);
io_printf("" node_mem_size = %d\n"", node_info.node_mem_size);
io_printf("" node_lhs_element = %d\n"", node_info.node_lhs_element);
io_printf("" node_rhs_element = %d\n"", node_info.node_rhs_element);

switch (node_info.node_type) {
    case TF_REG_NODE:
        io_printf("" reg value (in hex):\n"");
        for (i=0; i<node_info.node_ngruops; i++) {
            io_printf(""    avalbits[%d] = %x\n"",
                i, node_info.node_value.vecval_p[i].avalbits);
            io_printf(""    bvalbits[%d] = %x\n"",
                i, node_info.node_value.vecval_p[i].bvalbits);
        }
        break;
    case TF_INTEGER_NODE:
        io_printf("" integer value (in hex):\n"");
        io_printf(""    avalbits[0] = %x\n"",
            node_info.node_value.vecval_p[0].avalbits);
        io_printf(""    bvalbits[0] = %x\n"",
            node_info.node_value.vecval_p[0].bvalbits);
        break;
    case TF_TIME_NODE:
        io_printf("" time value (in hex):\n"");
        io_printf(""    (avalbits[1],avalbits[0]) = %x%x\n"",
            node_info.node_value.vecval_p[1].avalbits,
            node_info.node_value.vecval_p[0].avalbits);
        io_printf(""    (bvalbits[1],bvalbits[0]) = %x%x\n"",
            node_info.node_value.vecval_p[1].bvalbits,
            node_info.node_value.vecval_p[0].bvalbits);
        break;
    case TF_REAL_NODE:
        io_printf("" real value = %f\n"",
            node_info.node_value.real_val_p);
        break;
    case TF_NETSCALAR_NODE:
        io_printf("" scalar net value with strength (in hex):\n"");
        io_printf(""    strength0 = %x\n"",
            node_info.node_value.strengthval_p->strength0);
        io_printf(""    strength1 = %x\n"",
            node_info.node_value.strengthval_p->strength1);
        break;
    case TF_NETVECTOR_NODE:
        for (i=0; i<node_info.node_ngruops; i++) {
            io_printf(""    avalbits[%d] = %x\n"",
                i, node_info.node_value.vecval_p[i].avalbits);
            io_printf(""    bvalbits[%d] = %x\n"",
                i, node_info.node_value.vecval_p[i].bvalbits);
        }
        break;
    case TF_MEMORY_NODE:
        io_printf("" memory arrays are not supported in this example\n"");
        break;
}
```

Please note that there could be minor inaccuracies due to text that is hard to read or obscured. Additionally, it's worth noting that ""node_ngruops"" seems to be misspelled and should likely be ""node_ngroups"". This could be a typographical error in the document itself.","intf("" node_is_index = %d\n"", node_info.node_is_index);
io_printf("" node_mem_size = %d\n"", node_info.node_mem_size);
io_printf("" node_lhs_element = %d\n"", node_info.node_lhs_element);
io_printf("" node_rhs_element = %d\n"", node_info.node_rhs_element);

switch (node_info.node_type) {
    case TF_REG_NODE:
        io_printf("" reg value (in hex):\n"");
        for (i=0; i<node_info.node_ngruops; i++) {
            io_printf(""    avalbits[%d] = %x\n"",
                i, node_info.node_value.vecval_p[i].avalbits);
            io_printf(""    bvalbits[%d] = %x\n"",
                i, node_info.node_value.vecval_p[i].bvalbits);
        }
        break;
    case TF_INTEGER_NODE:
        io_printf("" integer value (in hex):\n"");
        io_printf(""    avalbits[0] = %x\n"",
            node_info.node_value.vecval_p[0].avalbits);
        io_printf(""    bvalbits[0] = %x\n"",
            node_info.node_value.vecval_p[0].bvalbits);
        break;
    case TF_TIME_NODE:
        io_printf("" time value (in hex):\n"");
        io_printf(""    (avalbits[1],avalbits[0]) = %x%x\n"",
            node_info.node_value.vecval_p[1].avalbits,
            node_info.node_value.vecval_p[0].avalbits);
        io_printf(""    (bvalbits[1],bvalbits[0]) = %x%x\n"",
            node_info.node_value.vecval_p[1].bvalbits,
            node_info.node_value.vecval_p[0].bvalbits);
        break;
    case TF_REAL_NODE:
        io_printf("" real value = %f\n"",
            node_info.node_value.real_val_p);
        break;
    case TF_NETSCALAR_NODE:
        io_printf("" scalar net value with strength (in hex):\n"");
        io_printf(""    strength0 = %x\n"",
            node_info.node_value.strengthval_p->strength0);
        io_printf(""    strength1 = %x\n"",
            node_info.node_value.strengthval_p->strength1);
        break;
    case TF_NETVECTOR_NODE:
        for (i=0; i<node_info.node_ngruops; i++) {
            io_printf(""    avalbits[%d] = %x\n"",
                i, node_info.node_value.vecval_p[i].avalbits);
            io_printf(""    bvalbits[%d] = %x\n"",
                i, node_info.node_value.vecval_p[i].bvalbits);
        }
        break;
    case TF_MEMORY_NODE:
        io_printf("" memory arrays are not supported in this example\n"");
        break;
}
","""Excerpt from The Verilog PLI Handbook demonstrating a switch-case statement for different node types in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p268.jpg,True,"The image contains two Verilog code examples. Here they are:

First Verilog Task example:
```verilog
task automatic CheckToggle(input[1:0] BitNo);
begin
    @(InBus[BitNo]) #1 ToggledReg = BitNo;
end
endtask
```

Second Verilog Function example:
```verilog
function automatic[31:0] Factorial(input[3:0] N);
begin
    if (N > 1)
        Factorial = N * Factorial(N-1);
    else
        Factorial = 1;
end
endfunction
```","
task automatic CheckToggle(input[1:0] BitNo);
begin
    @(InBus[BitNo]) #1 ToggledReg = BitNo;
end
endtask


function automatic[31:0] Factorial(input[3:0] N);
begin
    if (N > 1)
        Factorial = N * Factorial(N-1);
    else
        Factorial = 1;
end
endfunction
","The image contains an excerpt from a document explaining the use of 'automatic' keyword in Verilog tasks and functions, with examples of a toggle task and a recursive factorial function.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p76.jpg,True,"```verilog
always @ (posedge clock or negedge reset_n) // no begin
    if (!reset_n) state_e <= RESET;          // first statement
    else state_e <= nstate_e;                // ERROR instead of gotcha!
    fsm_out <= decode_func(nstate_e);        // ERROR instead of gotcha!

always @ (posedge clock or negedge reset_n) // no begin
    if (!reset_n) begin  // multiple statements in if branch
        q1 <= 1'b0;
        q2 <= 1'b0;
    end
    else begin           // multiple statements in else branch
        q1 <= d1;
        q2 <= d2;
    end
```","
always @ (posedge clock or negedge reset_n) // no begin
    if (!reset_n) state_e <= RESET;          // first statement
    else state_e <= nstate_e;                // ERROR instead of gotcha!
    fsm_out <= decode_func(nstate_e);        // ERROR instead of gotcha!

always @ (posedge clock or negedge reset_n) // no begin
    if (!reset_n) begin  // multiple statements in if branch
        q1 <= 1'b0;
        q2 <= 1'b0;
    end
    else begin           // multiple statements in else branch
        q1 <= d1;
        q2 <= d2;
    end
","""Common pitfall in Verilog regarding the use of begin...end blocks in if...else statements within sequential procedural blocks with reset logic.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p172.jpg,True,"The image contains two snippets of code related to Verilog.

The first code snippet is:

```verilog
#define COVERAGE 2
task ovl_error;
input [8*63:0] err_msg;
begin
    if (severity_level != `COVERAGE) begin
        error_count = error_count + 1;
        `ifdef ASSERT_MAX_REPORT_ERROR
        if (error_count <= `ASSERT_MAX_REPORT_ERROR)
        `endif
            $display(""OVL_ERROR :%s:%s:%0s: severity %0d : time %0t:%m"", assert_name, msg, err_msg, severity_level, $time);
        if (severity_level == 0) ovl_finish;
    end
    else
        $display(""OVL_COV :%s:%s:%0s : severity %0d : time %0t:%m"", assert_name, msg, err_msg, severity_level, $time);
end
endtask
```

The second code snippet is:

```verilog
assert_always #(`COVERAGE, 0, ""Q_FULL"") myQfull (clk, reset_n, !q_full);
```

These code examples are from a section on using OVL (Open Verification Library) for functional coverage, a concept in hardware design verification using Verilog/SystemVerilog.","
#define COVERAGE 2
task ovl_error;
input [8*63:0] err_msg;
begin
    if (severity_level != `COVERAGE) begin
        error_count = error_count + 1;
        `ifdef ASSERT_MAX_REPORT_ERROR
        if (error_count <= `ASSERT_MAX_REPORT_ERROR)
        `endif
            $display(""OVL_ERROR :%s:%s:%0s: severity %0d : time %0t:%m"", assert_name, msg, err_msg, severity_level, $time);
        if (severity_level == 0) ovl_finish;
    end
    else
        $display(""OVL_COV :%s:%s:%0s : severity %0d : time %0t:%m"", assert_name, msg, err_msg, severity_level, $time);
end
endtask


assert_always #(`COVERAGE, 0, ""Q_FULL"") myQfull (clk, reset_n, !q_full);
","""Example of modifying and using OVL (Assertion-Based Verification) for functional coverage in Verilog/SystemVerilog.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p156.jpg,True,"The image contains two snippets of Verilog code. Here they are:

First code snippet:
```verilog
module foo;
  reg a;
  initial begin
    a = 1;
    if (a); // semicolon is wrong, but NOT syntax error
      $display(""a is true""); // GOTCHA! also prints when 'a'
                             // is false
  end
endmodule
```

Second code snippet:
```verilog
module bar;
  reg a;
  initial begin
    a = 1;
    if (a); // semicolon is NOT an error
      $display(""a is true"");
    else
      // SYNTAX ERROR! 'else' does not
      // follow 'if'
      $display(""a is false"");
  end
endmodule
```","
module foo;
  reg a;
  initial begin
    a = 1;
    if (a); // semicolon is wrong, but NOT syntax error
      $display(""a is true""); // GOTCHA! also prints when 'a'
                             // is false
  end
endmodule


module bar;
  reg a;
  initial begin
    a = 1;
    if (a); // semicolon is NOT an error
      $display(""a is true"");
    else
      // SYNTAX ERROR! 'else' does not
      // follow 'if'
      $display(""a is false"");
  end
endmodule
","Caption: ""A guide explaining the pitfalls of misplaced semicolons in Verilog if statements, stressing that a semicolon after if is legal but can cause unexpected execution flow.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p240.jpg,True,"The image contains Verilog code. Here is the code transcribed from the image:

```verilog
module EventCtlLatch(output xLatch, yLatch, input a, b, c);
reg xReg, yReg;
assign xLatch = xReg;
assign yLatch = yReg;

always@(a)
  begin: aLatcherc
    if (a==1'b1)
      xReg <= b & c;
  end

always@(b)
  begin: bLatcherc
    if (b==1'b1)
      yReg <= (b | c) ^ a;
  end
endmodule // EventCtlLatch.
```","
module EventCtlLatch(output xLatch, yLatch, input a, b, c);
reg xReg, yReg;
assign xLatch = xReg;
assign yLatch = yReg;

always@(a)
  begin: aLatcherc
    if (a==1'b1)
      xReg <= b & c;
  end

always@(b)
  begin: bLatcherc
    if (b==1'b1)
      yReg <= (b | c) ^ a;
  end
endmodule // EventCtlLatch.
",Verilog Example of Event-Controlled Latches with Simulation Waveform Output,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p254.jpg,True,"There is no code written directly in the image; however, there is a reference to a file which is likely to contain Verilog code:

```
(tcbn90ghp_v2001.v);
```

This looks like a filename for a Verilog file, but the actual content of the file is not shown in the image.","0ghp_v2001.v);
","""Simulation and Synthesis Instructions for a Synchronous Counter in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p142.jpg,True,"The image contains Verilog code which is written as follows:

```verilog
module test (input logic clock, output logic reset_n, ...);

initial begin
  reset_n <= 0;                // OK, reset activated after delta
  #10 reset_n = 1;
  ...
end
endmodule

module top;
  ...
  initial begin
    clock <= 1;                // OK, first rising clock after delta
    forever #5 clock = ~clock;
  end
endmodule

module test (input logic clock, output logic reset_n, ...);

initial begin
  reset_n = 0;                // OK, reset activated before delta
  #10 reset_n = 1;
  ...
end
endmodule
```

Please note that the snippets are independent and illustrate two different initializations as mentioned in the surrounding text about asynchronous and synchronous resets in Verilog.","
module test (input logic clock, output logic reset_n, ...);

initial begin
  reset_n <= 0;                // OK, reset activated after delta
  #10 reset_n = 1;
  ...
end
endmodule

module top;
  ...
  initial begin
    clock <= 1;                // OK, first rising clock after delta
    forever #5 clock = ~clock;
  end
endmodule

module test (input logic clock, output logic reset_n, ...);

initial begin
  reset_n = 0;                // OK, reset activated before delta
  #10 reset_n = 1;
  ...
end
endmodule
","""Best practices for initializing Verilog designs with asynchronous and synchronous resets, highlighting the use of blocking and nonblocking assignments.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p62.jpg,True,"The image contains Verilog code. Here is the code presented:

```verilog
module top
(output wire [7:0] out, // net data type
 input wire [7:0] in // net data type
);

buffer8 b1 (.y(out), .a(in));
endmodule

module buffer8
(output wire [7:0] y, // net data type
 input wire [7:0] a // net data type
);

assign a = y; // GOTCHA! this should have been y = a;
endmodule
```

Please note the comment at the end of the code, which indicates a mistake in the assignment statement. It should be `y = a;` instead of `a = y;`.","
module top
(output wire [7:0] out, // net data type
 input wire [7:0] in // net data type
);

buffer8 b1 (.y(out), .a(in));
endmodule

module buffer8
(output wire [7:0] y, // net data type
 input wire [7:0] a // net data type
);

assign a = y; // GOTCHA! this should have been y = a;
endmodule
","""Port Coercion in Verilog: A common gotcha where input ports are unintentionally used as output, leading to unexpected behavior in hardware design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p89.jpg,True,"```verilog
always @(in1) begin
    out1 = in1;  // out1 is first updated to new value of in1
    out2 = out1; // OK, second out2 gets new value of out1
end
```","
always @(in1) begin
    out1 = in1;  // out1 is first updated to new value of in1
    out2 = out1; // OK, second out2 gets new value of out1
end
","""Common Verilog RTL modeling gotcha and how to correctly order assignments in combinational logic to avoid synthesis-simulation mismatches.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p357.jpg,True,"The image contains text and two fragments of Verilog code. Here are the code fragments:

1.
```verilog
`timescale 1ns/1ns
module test_chip1;
    ...
    always @(posedge clk)
        $read_test_vector(""chip1.vectors"", chip1_in);
    ...
```

2.
```verilog
`timescale 1ps/1fs
module test_chip2;
    ...
    always @(posedge clk)
        $read_test_vector(""chip2.vectors"", chip2_in);
    ...
```
These code examples demonstrate how `timescale` directive is used in Verilog modules to define the time unit and precision for delays.","
`timescale 1ns/1ns
module test_chip1;
    ...
    always @(posedge clk)
        $read_test_vector(""chip1.vectors"", chip1_in);
    ...


`timescale 1ps/1fs
module test_chip2;
    ...
    always @(posedge clk)
        $read_test_vector(""chip2.vectors"", chip2_in);
    ...
","""Excerpt from a textbook showing a discussion of time scaling in Verilog code and PLI applications with examples of Verilog modules.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p340.jpg,True,"The image contains Verilog code within a text discussing procedural assertion evaluations. Here is the code excerpt from the image:

```verilog
always @(*) begin: B2
  a25_1: assert property (@(negedge clk) !(dreg & tr));
  if (c1_long) begin
    for (int i=0; i<4; i++) begin
      dreg[i] = tr[i+1];
      treg = flogic (dreg[i]);
      a25_2: assert property (@(posedge clk) dreg[i] |=> r12);
    end
  end
end
if (retry_cond) disable B2;
end
```

This is an example showing how to use a `disable` statement to purge all assertion evaluations in a block labeled `B2`.","
always @(*) begin: B2
  a25_1: assert property (@(negedge clk) !(dreg & tr));
  if (c1_long) begin
    for (int i=0; i<4; i++) begin
      dreg[i] = tr[i+1];
      treg = flogic (dreg[i]);
      a25_2: assert property (@(posedge clk) dreg[i] |=> r12);
    end
  end
end
if (retry_cond) disable B2;
end
","Caption: ""Example of using the disable statement in Verilog to control assertion evaluation within a procedural block.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p358.jpg,True,"```verilog
driver drv;
drv = driver::type_id::create(""drv"", this);
```","
driver drv;
drv = driver::type_id::create(""drv"", this);
","""Understanding UVM Factory Build and Object Creation in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p432.jpg,True,"Here is the Verilog code that appears in the image:

```verilog
default clocking ck @(posedge clk); endclocking
int unsigned tick_counter = 0;
covergroup delay_cg with function sample (int unsigned delay);
    cp: coverpoint delay {
        bins delays [100] : [(1:100)];
    }
endgroup
delay_cg delay_cg_inst new();
always @ck
    tick_counter <= tick_counter+1;
property p_delay_coverage;
    int unsigned start_tick;
    disable iff (reset) @(posedge clk)
    (a, start_tick = tick_counter)
    ##[1:$] b_eventually![0:100] 
    (b, 
    delay_cg_inst.sample(tick_counter-start_tick),
    $display(""prop_cov5 success, time %t, delay %0d"",
             $time, tick_counter-start_tick)
    );
endproperty
prop_cov5: cover property(p_delay_coverage);
```

This code is related to hardware verification using SystemVerilog, a hardware description and verification language used to model, design, simulate, and verify integrated circuits and mixed-signal systems. This snippet shows the definition of clocking blocks, coverage groups, properties, and the always block for incrementing a tick counter.","
default clocking ck @(posedge clk); endclocking
int unsigned tick_counter = 0;
covergroup delay_cg with function sample (int unsigned delay);
    cp: coverpoint delay {
        bins delays [100] : [(1:100)];
    }
endgroup
delay_cg delay_cg_inst new();
always @ck
    tick_counter <= tick_counter+1;
property p_delay_coverage;
    int unsigned start_tick;
    disable iff (reset) @(posedge clk)
    (a, start_tick = tick_counter)
    ##[1:$] b_eventually![0:100] 
    (b, 
    delay_cg_inst.sample(tick_counter-start_tick),
    $display(""prop_cov5 success, time %t, delay %0d"",
             $time, tick_counter-start_tick)
    );
endproperty
prop_cov5: cover property(p_delay_coverage);
","Caption: ""Verilog code example demonstrating the use of covergroups and properties for coverage analysis in hardware verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p199.jpg,True,"```verilog
// declarative assertion
assert property (@(posedge clk) disable iff (reset_n)
(valid_read |-> $countones(reg_select) == 1))
else $error(""REG block performed illegal register selection (%b)"", select);
```","
// declarative assertion
assert property (@(posedge clk) disable iff (reset_n)
(valid_read |-> $countones(reg_select) == 1))
else $error(""REG block performed illegal register selection (%b)"", select);
","Caption: ""Example of a SystemVerilog assertion to check for legal signal selection during valid operation states.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p425.jpg,True,"The image contains a snippet of code which is part of a technical document or book related to Verilog simulations. Here is the text of the code as shown in the image:

```c
#include <stdio.h>             /* ANSI C standard I/O library */
#include ""veriuser.h""          /* IEEE 1364 PLI TF routine library */

/* prototypes of sub-functions */
char *PLIbook_reason_name();

/**********************************************************************/
/* structure definition for data used by the misctf routine           */
/**********************************************************************/
typedef struct PLIbook_stim_data {
    FILE *file_ptr;             /* pointer to the test vector file */
    long file_position;         /* position within file of next byte to read */
    char *vector;               /* pointer to stimulus vector */
    char dummy_msg[201];        /* dummy message field to show save/restart */
} PLIbook_stim_data_s, *PLIbook_stim_data_p;

/**********************************************************************/
/* checktf routine                                                    */
/**********************************************************************/
int PLIbook_ReadStimulus_checktf()
{
    bool err = FALSE;

    if (tf_nump() != 2) {
        tf_text(""$read_stimulus_?? requires 2 arguments\n"");
        err = TRUE;
    }
    if (tf_typep(1) != tf_string) {
        tf_text(""$read_stimulus_?? arg 1 must be a string\n"");
        err = TRUE;
    }
    if (tf_typep(2) != tf_readwrite) {
        tf_text(""$read_stimulus_?? arg 2 must be a register data type"");
        err = TRUE;
    }
    if (err)
        tf_message(ERR_ERROR, """", """", """"); /* print stored messages */
    return(0);
}

/**********************************************************************/
/* calltf routine                                                     */
/**********************************************************************/
int PLIbook_ReadStimulus_calltf()
{
    /* call the misctf routine at the end of current */
    tf_setdelay(0); /* time step, with REASON_REACTIVATE; the misctf */
    /* routine reads the stimulus file. */
    
    return(0);
}
```

This code appears to be a part of a chapter titled ""CHAPTER 12: Synchronizing to Verilog Simulations Using Misctf Routines"" and the example number is ""Example 12-7: `$read_stimulus_ba` — using several `misctf` routine callbacks"". The code shows C functions intended to be used with the Programming Language Interface (PLI) of IEEE 1364, which is a standard for the Verilog hardware description language. The PLI allows users to write custom C functions that interface with a Verilog simulator.","ude <stdio.h>             /* ANSI C standard I/O library */
#include ""veriuser.h""          /* IEEE 1364 PLI TF routine library */

/* prototypes of sub-functions */
char *PLIbook_reason_name();

/**********************************************************************/
/* structure definition for data used by the misctf routine           */
/**********************************************************************/
typedef struct PLIbook_stim_data {
    FILE *file_ptr;             /* pointer to the test vector file */
    long file_position;         /* position within file of next byte to read */
    char *vector;               /* pointer to stimulus vector */
    char dummy_msg[201];        /* dummy message field to show save/restart */
} PLIbook_stim_data_s, *PLIbook_stim_data_p;

/**********************************************************************/
/* checktf routine                                                    */
/**********************************************************************/
int PLIbook_ReadStimulus_checktf()
{
    bool err = FALSE;

    if (tf_nump() != 2) {
        tf_text(""$read_stimulus_?? requires 2 arguments\n"");
        err = TRUE;
    }
    if (tf_typep(1) != tf_string) {
        tf_text(""$read_stimulus_?? arg 1 must be a string\n"");
        err = TRUE;
    }
    if (tf_typep(2) != tf_readwrite) {
        tf_text(""$read_stimulus_?? arg 2 must be a register data type"");
        err = TRUE;
    }
    if (err)
        tf_message(ERR_ERROR, """", """", """"); /* print stored messages */
    return(0);
}

/**********************************************************************/
/* calltf routine                                                     */
/**********************************************************************/
int PLIbook_ReadStimulus_calltf()
{
    /* call the misctf routine at the end of current */
    tf_setdelay(0); /* time step, with REASON_REACTIVATE; the misctf */
    /* routine reads the stimulus file. */
    
    return(0);
}
","""Example of Verilog code using PLI callbacks for synchronizing simulations with C routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p120.jpg,True,"The image contains Verilog code as follows:

```verilog
always @(posedge clk)
begin
    if ($stable(a)) $display($stime,,,""'a' stable from previous clock"");
    if ($stable(b)) $display($stime,,,""'b' stable from previous clock"");

    if ($stable(a) && $stable(b))
        $display($stime,,,""'a' AND 'b' Stable this clock"");
end
```","
always @(posedge clk)
begin
    if ($stable(a)) $display($stime,,,""'a' stable from previous clock"");
    if ($stable(b)) $display($stime,,,""'b' stable from previous clock"");

    if ($stable(a) && $stable(b))
        $display($stime,,,""'a' AND 'b' Stable this clock"");
end
","""Example of Verilog procedural block using sampled value functions to determine signal stability.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p416.jpg,True,"The image contains two Verilog code snippets.

First snippet:
```verilog
program automatic test # (NUM_XI=2, BIT_WIDTH=8) ;
virtual x_if #(.BIT_WIDTH(BIT_WIDTH)) .TB vxi[NUM_XI] ;

...
```

Second snippet:
```verilog
class Driver;
virtual x_if #(.BIT_WIDTH(BIT_WIDTH)) xi;

//...
endclass
```","
program automatic test # (NUM_XI=2, BIT_WIDTH=8) ;
virtual x_if #(.BIT_WIDTH(BIT_WIDTH)) .TB vxi[NUM_XI] ;

...


class Driver;
virtual x_if #(.BIT_WIDTH(BIT_WIDTH)) xi;

//...
endclass
","""Explaining Procedural Code in Verilog Interfaces with Examples of Parameterized Testbench and Driver Class""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p283.jpg,True,"The following Verilog code is included in the image:

```verilog
...
wire[7:0] QWire;
// 

generate 
genvar i;
for(i=0; i<=7; i=i+1)
begin : IxedBus  // Here is the block name.
DFFa   FF (.Q(QWire[i]), .D(DBus[i]), .Clr(Rst), .Clk(Clk) );
notif1 Nuf (DBusBuf[i], QWire[i], QEna[i]);
end
endgenerate
```

And another snippet:

```verilog
for(i=0; i<=7; i=i+1)
begin : IxedBus  // Here is the block name.
DFFa   FF (.Q(QWire), .D(DBus[i]), .Clr(Rst), .Clk(Clk) );
notif1 Nuf (DBusBuf[i], QWire, QEna[i]);
end
```
This code is part of a textual discussion of Verilog `generate` constructs, particularly looping constructs and their use in naming and instantiating hardware blocks within generated structures.","
...
wire[7:0] QWire;
// 

generate 
genvar i;
for(i=0; i<=7; i=i+1)
begin : IxedBus  // Here is the block name.
DFFa   FF (.Q(QWire[i]), .D(DBus[i]), .Clr(Rst), .Clk(Clk) );
notif1 Nuf (DBusBuf[i], QWire[i], QEna[i]);
end
endgenerate


for(i=0; i<=7; i=i+1)
begin : IxedBus  // Here is the block name.
DFFa   FF (.Q(QWire), .D(DBus[i]), .Clr(Rst), .Clk(Clk) );
notif1 Nuf (DBusBuf[i], QWire, QEna[i]);
end
",Verilog Generate Construct Example - Demonstrating the Use of Generate Loops in Module Instantiation.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p195.jpg,True,"The image contains Verilog code with two classes demonstrating improper use of constraints. I'll write the code from the image for you:

First class bad1:
```verilog
class bad1;
  rand bit [7:0] lo, med, hi;
  constraint increasing { lo < med < hi; } // GOTCHA!
endclass
```

Second class bad2:
```verilog
class bad2;
  rand bit [7:0] a, b, c;
  constraint equal {a == b == c; }
endclass
```","
class bad1;
  rand bit [7:0] lo, med, hi;
  constraint increasing { lo < med < hi; } // GOTCHA!
endclass


class bad2;
  rand bit [7:0] a, b, c;
  constraint equal {a == b == c; }
endclass
","""Common pitfalls in SystemVerilog constraints for random variable ordering and equality""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p368.jpg,True,"```verilog
bit complete_justified;
always @(posedge clk)
    complete_justified = 1'b0;
task t_justify_complete;
    @(negedge clk)
    complete_justified = 1'b1;
endtask : complete_justified
property p_start_and_data_checks;
    tagType tag;
    dataType data;
    (start, tag = tagIn, data = dataIn)
    |=>
    (
        !(start && tagIn == tag)
        throughout
        (complete && tagOut == tag) [-1]
    )
    ##0 (1'b1, t_justify_complete)
    ##0 dataOut == data;
endproperty
a_start_and_data_checks: assert property (
    p_start_and_data_checks
);
a_complete_check: assert property (
    complete |=> complete_justified
);
```","
bit complete_justified;
always @(posedge clk)
    complete_justified = 1'b0;
task t_justify_complete;
    @(negedge clk)
    complete_justified = 1'b1;
endtask : complete_justified
property p_start_and_data_checks;
    tagType tag;
    dataType data;
    (start, tag = tagIn, data = dataIn)
    |=>
    (
        !(start && tagIn == tag)
        throughout
        (complete && tagOut == tag) [-1]
    )
    ##0 (1'b1, t_justify_complete)
    ##0 dataOut == data;
endproperty
a_start_and_data_checks: assert property (
    p_start_and_data_checks
);
a_complete_check: assert property (
    complete |=> complete_justified
);
","Caption: ""A textbook excerpt showing Verilog code for tag protocol checks with assertions and properties in SystemVerilog.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p181.jpg,True,"The image contains Verilog code. Here it is written out:

```verilog
program test (input logic clock);
  int d_array[3] = '{10,11,12};
  initial begin
    for (int i=0; i<3; i++)
      fork
        automatic int thread_id = i; // local var for each thread
        $write(""thread_id=%0d "", thread_id);
        $display(""d_array[thread_id]=%0d"",
                 d_array[thread_id]);
      join_none // don’t wait for each fork to complete
    #10 $finish;
  end
endprogram

program automatic test (input logic clock); // default storage
// is automatic
```

Please note that this code is related to a discussion about avoiding gotchas in concurrent programming with threads in Verilog. The first block shows how to use an automatic storage class for local variables within each forked concurrent thread, while the last line shows how to declare an entire program with automatic storage by default.","
program test (input logic clock);
  int d_array[3] = '{10,11,12};
  initial begin
    for (int i=0; i<3; i++)
      fork
        automatic int thread_id = i; // local var for each thread
        $write(""thread_id=%0d "", thread_id);
        $display(""d_array[thread_id]=%0d"",
                 d_array[thread_id]);
      join_none // don’t wait for each fork to complete
    #10 $finish;
  end
endprogram

program automatic test (input logic clock); // default storage
// is automatic
","""Exploring multi-threading gotchas and proper use of automatic variables in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p364.jpg,True,"The image contains a snippet of Verilog code from a section discussing code coverage in functional verification. Here is the code:

```verilog
module dff (output logic q, q_l,
            input  logic clk, d, reset_l);

    always @(posedge clk or negedge reset_l) begin
        q <= d;
        q_l <= !d;
    end

endmodule
```

The text describes this as an incomplete D-flip flop model missing a path, and the reset logic was accidentally left out. This is used to illustrate the importance of code coverage in a verification process.","
module dff (output logic q, q_l,
            input  logic clk, d, reset_l);

    always @(posedge clk or negedge reset_l) begin
        q <= d;
        q_l <= !d;
    end

endmodule
","An educational excerpt on code coverage in functional verification for digital designs, featuring an example of Verilog code for an incomplete D-flip flop.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p134.jpg,True,"The image contains Verilog code. Here it is:

```verilog
always begin
    #10 clk=!clk;
end

initial
begin
    repeat (5) begin @(posedge clk) rdy=~rdy; end
end

initial $monitor($stime,,,,""clk="",clk,,,,""rdy="",rdy,,,,""rdyAck="",rdyAck);

initial
begin
    repeat (4) begin @(posedge clk); end
    rdyAck=1;
end

sequence rdyAckCheck;
    (1'b1, $display($stime,,,,""ENTER SEQUENCE rdy ARRIVES""))
    ##[1:5]
    ((rdyAck), $display($stime,,,,""rdyAck ARRIVES""));
endsequence

gcheck: assert property (@(posedge clk) $rose (rdy) |-> rdyAckCheck)
begin $display($stime,,,,""PASS""); end
    else begin $display($stime,,,,""FAIL""); end

endmodule

/* Simulation log
   0     clk=0   rdy=0   rdyAck=0
  10     clk=1   rdy=1   rdyAck=0
  20     clk=0   rdy=1   rdyAck=0
  30     clk=1   rdy=0   rdyAck=0
  30     ENTER SEQUENCE rdy ARRIVES ← First 'rdy' is detected
  40     clk=0   rdy=0   rdyAck=0
  50     clk=1   rdy=1   rdyAck=0
  60     clk=0   rdy=1   rdyAck=0
  70     clk=1   rdy=0   rdyAck=1
  70     ENTER SEQUENCE rdy ARRIVES ← Second 'rdy' is detected
  80     clk=0   rdy=0   rdyAck=1
*/
```

This code appears to be a testbench or part of one for a digital system simulation written in Verilog. It includes constructs such as always blocks, initial blocks, sequences, and the assert property used in the formal verification of hardware designs. It also contains comments that provide a simulation log.","
always begin
    #10 clk=!clk;
end

initial
begin
    repeat (5) begin @(posedge clk) rdy=~rdy; end
end

initial $monitor($stime,,,,""clk="",clk,,,,""rdy="",rdy,,,,""rdyAck="",rdyAck);

initial
begin
    repeat (4) begin @(posedge clk); end
    rdyAck=1;
end

sequence rdyAckCheck;
    (1'b1, $display($stime,,,,""ENTER SEQUENCE rdy ARRIVES""))
    ##[1:5]
    ((rdyAck), $display($stime,,,,""rdyAck ARRIVES""));
endsequence

gcheck: assert property (@(posedge clk) $rose (rdy) |-> rdyAckCheck)
begin $display($stime,,,,""PASS""); end
    else begin $display($stime,,,,""FAIL""); end

endmodule

/* Simulation log
   0     clk=0   rdy=0   rdyAck=0
  10     clk=1   rdy=1   rdyAck=0
  20     clk=0   rdy=1   rdyAck=0
  30     clk=1   rdy=0   rdyAck=0
  30     ENTER SEQUENCE rdy ARRIVES ← First 'rdy' is detected
  40     clk=0   rdy=0   rdyAck=0
  50     clk=1   rdy=1   rdyAck=0
  60     clk=0   rdy=1   rdyAck=0
  70     clk=1   rdy=0   rdyAck=1
  70     ENTER SEQUENCE rdy ARRIVES ← Second 'rdy' is detected
  80     clk=0   rdy=0   rdyAck=1
*/
","Caption: ""Example of Verilog code demonstrating clock toggling, sequence checking with assertions, and simulation output log.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p402.jpg,True,"The image contains Verilog code which is part of a sample testbench. Here is the code transcribed from the image:

```verilog
program automatic test(Rx_if.TB Rx0, Rx1, Rx2, Rx3,
                       Tx_if.TB Tx0, Tx1, Tx2, Tx3,
                       output logic rst);

  bit [7:0] bytes[`ATM_SIZE];

  initial begin
    // Reset the device
    rst <= 1;
    Rx0.cb.data <= '0;
    ...
    receive_cell0;
    ...
  end

  task receive_cell0();
    @(Tx0.cb);
    Tx0.cb.clav <= 1;             // Assert ready to receive
    wait (Tx0.cb.soc == 1);       // Wait for Start of Cell

    for (int i=0; i<`ATM_SIZE; i++) begin
      wait (Tx0.cb.en == 0);      // Wait for enable
      @(Tx0.cb);
      bytes[i] = Tx0.cb.data;
      @(Tx0.cb);
      Tx0.cb.clav <= 0;           // Deassert flow control
    end
  endtask

endprogram
```

Please note that the ellipses (`...`) indicate that there is additional code or content which is not shown in the image.","
program automatic test(Rx_if.TB Rx0, Rx1, Rx2, Rx3,
                       Tx_if.TB Tx0, Tx1, Tx2, Tx3,
                       output logic rst);

  bit [7:0] bytes[`ATM_SIZE];

  initial begin
    // Reset the device
    rst <= 1;
    Rx0.cb.data <= '0;
    ...
    receive_cell0;
    ...
  end

  task receive_cell0();
    @(Tx0.cb);
    Tx0.cb.clav <= 1;             // Assert ready to receive
    wait (Tx0.cb.soc == 1);       // Wait for Start of Cell

    for (int i=0; i<`ATM_SIZE; i++) begin
      wait (Tx0.cb.en == 0);      // Wait for enable
      @(Tx0.cb);
      bytes[i] = Tx0.cb.data;
      @(Tx0.cb);
      Tx0.cb.clav <= 0;           // Deassert flow control
    end
  endtask

endprogram
","Caption: ""Sample Verilog testbench code demonstrating the use of physical interfaces in a test scenario for an ATM Router.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p197.jpg,True,"The image contains Verilog code. Here it is written out:

```verilog
class Negs;
  rand int data;
  rand byte address; // GOTCHA! address can be negative
endclass

class Negs;
  rand int data;
  rand byte address; // OK, address constrained to non-negative
  constraint pos
    { data >= 0;
      address >= 0; }
endclass
```","
class Negs;
  rand int data;
  rand byte address; // GOTCHA! address can be negative
endclass

class Negs;
  rand int data;
  rand byte address; // OK, address constrained to non-negative
  constraint pos
    { data >= 0;
      address >= 0; }
endclass
","Caption: ""Avoiding negative values in randomization in Verilog by using constraints to ensure non-negative values.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p369.jpg,True,"The image contains code excerpts written in the C programming language that handle tasks related to reading and writing values using TF routines, which are likely related to Verilog simulation functions. Here is the code from the image:

```c
io_printf(""\n\n"");
return(0);

/**********************************************************************
* calltf application
**********************************************************************/
int PLIbook_ReadAddStateValue_calltf()
{
    p_tfexprinfo info_p;        /* pointer to structure for tf_exprinfo() */
    p_vecval     val_array;     /* pointer to value array in info struct */
    int i;

    info_p = (p_tfexprinfo)tf_getworkarea(); /* retrieve info pointer */
    tf_evaluatep(1);                          /* re-read value of arg 1 */

    switch (info_p->expr_type) {
        case TF_STRING:
            io_printf("" string value = %s\n"", info_p->expr_string); break;
        case TF_READONLYREAL:
        case TF_READWRITEREAL:
            io_printf("" real value = %f\n"", info_p->real_value); break;
        case TF_READONLY:
        case TF_READWRITE:
        case TF_RWBITSELECT:
        case TF_RWPARTSELECT:
        case TF_RWMMEMSELECT:
            val_array = info_p->expr_value_p;
            io_printf("" vector value (in hex):\n"");
            for (i=0; i<info_p->expr_ngroups; i++) {
                // ... (code likely continues, but is not visible in the image)
            }
            break;
            // ... (code likely continues, but is not visible in the image)
    }
    // ... (code likely continues, but is not visible in the image)
}
```

Please note that this is a snippet from what appears to be a technical book or manual, and the full code likely extends beyond what is visible. The `...` indicates parts of the code that are missing or not shown in the image. The code uses `tf_` prefixed functions and structures, which suggests it's for a PLI (Programming Language Interface) application in Verilog simulation environments.","intf(""\n\n"");
return(0);

/**********************************************************************
* calltf application
**********************************************************************/
int PLIbook_ReadAddStateValue_calltf()
{
    p_tfexprinfo info_p;        /* pointer to structure for tf_exprinfo() */
    p_vecval     val_array;     /* pointer to value array in info struct */
    int i;

    info_p = (p_tfexprinfo)tf_getworkarea(); /* retrieve info pointer */
    tf_evaluatep(1);                          /* re-read value of arg 1 */

    switch (info_p->expr_type) {
        case TF_STRING:
            io_printf("" string value = %s\n"", info_p->expr_string); break;
        case TF_READONLYREAL:
        case TF_READWRITEREAL:
            io_printf("" real value = %f\n"", info_p->real_value); break;
        case TF_READONLY:
        case TF_READWRITE:
        case TF_RWBITSELECT:
        case TF_RWPARTSELECT:
        case TF_RWMMEMSELECT:
            val_array = info_p->expr_value_p;
            io_printf("" vector value (in hex):\n"");
            for (i=0; i<info_p->expr_ngroups; i++) {
                // ... (code likely continues, but is not visible in the image)
            }
            break;
            // ... (code likely continues, but is not visible in the image)
    }
    // ... (code likely continues, but is not visible in the image)
}
","""Excerpt from a book detailing Reading and Writing Values Using TF Routines in Verilog with code examples""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p281.jpg,True,"The image includes some Verilog code for generating an array of flip-flops with a specific structure. Here is the code:

```verilog
// module I/O's include 8-bit DBusBuf output, and DBus & QEna inputs.
...
generate
  genvar i;
  for(i=0; i<=7; i=i+1)
  begin : BuffedBus          // Here is the block name.
    wire QWire, QWireNot;
    DFFa   FF (.Q(QWire), .D(DBus[i]), .Clr(Rst), .Clk(Clk) );
    not    Inv(QWireNot, QWire);
    bufif1 Buf(DBusBuf[i], QWireNot, QEna[i]);
  end
endgenerate
```

This code creates a loop using the `generate...endgenerate` construct in Verilog to create an array of named blocks (labelled ""BuffedBus"") that instantiate flip-flops (`DFFa`), inverters (`not`), and three-state buffers (`bufif1`). The `genvar i;` statement declares a variable `i` that is used as the loop index to generate the array of named blocks from 0 to 7.","
// module I/O's include 8-bit DBusBuf output, and DBus & QEna inputs.
...
generate
  genvar i;
  for(i=0; i<=7; i=i+1)
  begin : BuffedBus          // Here is the block name.
    wire QWire, QWireNot;
    DFFa   FF (.Q(QWire), .D(DBus[i]), .Clr(Rst), .Clk(Clk) );
    not    Inv(QWireNot, QWire);
    bufif1 Buf(DBusBuf[i], QWireNot, QEna[i]);
  end
endgenerate
","Caption: ""Example of a Verilog generate loop to create an array of flip-flops with inverting three-state buffers for an 8-bit bus.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p372.jpg,True,"The image contains Verilog code within the text. Here's the Verilog code from the image:

```verilog
class Transactor;
  Transaction tr;
  mailbox #(Transaction) mbx;
  covergroup CovDst5;
    coverpoint tr.dst;
  endgroup

  function new(input mailbox #(Transaction) mbx);
    CovDst5 = new(); // Instantiate covergroup
    this.mbx = mbx;
  endfunction

  task run();
    forever begin
      mbx.get(tr); // Get next transaction
      ifc.cb.dst <= tr.dst; // Send into DUT
      ifc.cb.data <= tr.data;
      CovDst5.sample(); // Gather coverage
    end
  endtask

endclass
```","
class Transactor;
  Transaction tr;
  mailbox #(Transaction) mbx;
  covergroup CovDst5;
    coverpoint tr.dst;
  endgroup

  function new(input mailbox #(Transaction) mbx);
    CovDst5 = new(); // Instantiate covergroup
    this.mbx = mbx;
  endfunction

  task run();
    forever begin
      mbx.get(tr); // Get next transaction
      ifc.cb.dst <= tr.dst; // Send into DUT
      ifc.cb.data <= tr.data;
      CovDst5.sample(); // Gather coverage
    end
  endtask

endclass
","Caption: ""Defining a functional coverage cover group inside a Verilog class.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p414.jpg,True,"The image contains a snippet of Verilog code. Here's the code from the image:

```verilog
program automatic test (x_if xi[NUM_XI]);

vx_if vxi[NUM_XI];
Driver driver[];

initial begin
    // Build phase
    // Connect the local virtual interfaces to the top
    vxi = xi;                               // Assign the interface array
    driver = new[NUM_XI];
    
    foreach (vxi[i])                        // Create NUM_XI drivers
        driver[i] = new(vxi[i], i);

    // Reset phase
    foreach (vxi[i])
        fork
            begin
                driver[i].reset();
                driver[i].load_op();
            end
        join
    //...
end

endprogram
```

This code is from a section discussing parameterized interfaces and virtual interfaces in Verilog/SystemVerilog. The code represents a testbench that uses virtual interfaces.","
program automatic test (x_if xi[NUM_XI]);

vx_if vxi[NUM_XI];
Driver driver[];

initial begin
    // Build phase
    // Connect the local virtual interfaces to the top
    vxi = xi;                               // Assign the interface array
    driver = new[NUM_XI];
    
    foreach (vxi[i])                        // Create NUM_XI drivers
        driver[i] = new(vxi[i], i);

    // Reset phase
    foreach (vxi[i])
        fork
            begin
                driver[i].reset();
                driver[i].load_op();
            end
        join
    //...
end

endprogram
","Caption: ""Example of a testbench program in Verilog demonstrating the use of parameterized and virtual interfaces.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p122.jpg,True,"```verilog
$lastV == $past(Sig, numClocks, enb);
```

```verilog
property IV(Sig,numClocks,enb,lastV);
  (lastV == $past(Sig, numClocks, enb));
endproperty
```

```verilog
assert property (@(posedge clk) done |- !V(mySig, 2, enb, lastVal)) else
  $display($stime,, ""FAIL Expected lastVal=%h\n"",lastVal);
```

```verilog
cover property (@(posedge clk) done |- !V(mySig, 2, enb, lastVal))
  $display($stime,, ""PASS Expected lastVal=%h\n"",lastVal);
```

```verilog
always @(posedge clk)
  $display($stime,, ""clk=%b mySig=%h past=%h enb=%h done=%b"", clk, mySig,
    $past(mySig, 2, enb), enb, done);
```

The snippet contains several fragments of Verilog code demonstrating how to use system functions such as `$past` within properties, assertions, and procedural blocks to check for past values of signals in simulation using SystemVerilog's temporal logic features.","
$lastV == $past(Sig, numClocks, enb);


property IV(Sig,numClocks,enb,lastV);
  (lastV == $past(Sig, numClocks, enb));
endproperty


assert property (@(posedge clk) done |- !V(mySig, 2, enb, lastVal)) else
  $display($stime,, ""FAIL Expected lastVal=%h\n"",lastVal);


cover property (@(posedge clk) done |- !V(mySig, 2, enb, lastVal))
  $display($stime,, ""PASS Expected lastVal=%h\n"",lastVal);


always @(posedge clk)
  $display($stime,, ""clk=%b mySig=%h past=%h enb=%h done=%b"", clk, mySig,
    $past(mySig, 2, enb), enb, done);
","""Verilog Sampled Value Functions and Gating Expressions in SystemVerilog Assertions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p418.jpg,True,"The image contains code examples written in the context of Verilog, specifically for SystemVerilog Assertions (SVA). Here are the pieces of code from the image:

1.
```verilog
property illegal_disable(logic b, property p);
    disable iff (b)
    p and nexttime illegal_disable(b, p);
endproperty
```

2.
```verilog
property always_with_disable(logic b, property p);
    disable iff (b)
    my_always(p);
endproperty
```

3.
```verilog
property illegal_stuck(property p);
    p and nexttime[0] illegal_stuck(p);
endproperty
``` 

These code snippets discuss certain restrictions on recursive properties in SVA and provide examples of what not to do according to these restrictions.","
property illegal_disable(logic b, property p);
    disable iff (b)
    p and nexttime illegal_disable(b, p);
endproperty


property always_with_disable(logic b, property p);
    disable iff (b)
    my_always(p);
endproperty


property illegal_stuck(property p);
    p and nexttime[0] illegal_stuck(p);
endproperty
",Verilog SVA recursive properties: restrictions on using 'disable iff' within recursive declarations and ensuring time advance to avoid illegal constructs.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p136.jpg,True,"Yes, the image contains Verilog code. Here's the code transcribed:

```verilog
sequence rdyAckCheck;
    byte localData;
    /* local variable 'localData' declaration. Note this is a dynamic variable. For every entry into the sequence it will create a new instance of localData and trigger an independent thread. */

    /* Store rdyNum in the local variable 'localData' */
    ('1'b1,localData=rdyNum,$display($stime,,,""rdy ARRIVES: "",,""LOCAL rdyNum="",localData))

##[1:5]

    /* Compare rdyAckNum with the rdyNum stored in 'localData' */
    ((rdyAck && rdyAckNum==localData),
    $display($stime,,,""rdyAck ARRIVES "",,""LOCAL"",,""rdyNum="",localData,,,""rdyAck="",rdyAckNum));

endsequence

gcheck: assert property (@(posedge clk) (rdy) |-> rdyAckCheck)
begin $display($stime,,,""PASS""); end
    else begin
    $display($stime,,,""FAIL"",,,""rdyNum="",rdyNum,,,""rdyAckNum="",rdyAckNum); end

endmodule
```

The code is a part of a Verilog module and includes definitions of a sequence called `rdyAckCheck`, an assertion `gcheck`, and some simulation output.","
sequence rdyAckCheck;
    byte localData;
    /* local variable 'localData' declaration. Note this is a dynamic variable. For every entry into the sequence it will create a new instance of localData and trigger an independent thread. */

    /* Store rdyNum in the local variable 'localData' */
    ('1'b1,localData=rdyNum,$display($stime,,,""rdy ARRIVES: "",,""LOCAL rdyNum="",localData))

##[1:5]

    /* Compare rdyAckNum with the rdyNum stored in 'localData' */
    ((rdyAck && rdyAckNum==localData),
    $display($stime,,,""rdyAck ARRIVES "",,""LOCAL"",,""rdyNum="",localData,,,""rdyAck="",rdyAckNum));

endsequence

gcheck: assert property (@(posedge clk) (rdy) |-> rdyAckCheck)
begin $display($stime,,,""PASS""); end
    else begin
    $display($stime,,,""FAIL"",,,""rdyNum="",rdyNum,,,""rdyAckNum="",rdyAckNum); end

endmodule
",Verilog code snippet demonstrating the use of sequences and assertions for checking properties in a testbench.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p295.jpg,True,"This image includes a snippet of Verilog code within a `generate` block. Here is the Verilog code transcribed:

```verilog
generate
for (i=0; i<Max; i = i+1)
  begin: Stuff
    reg temp;
    and A(bus[i], InBus[i], InBus[i+1]);
    always@(Abus) #1 temp <= &A;Bus;
    assign #1 OutBit1 = temp;
  end
endgenerate
```","
generate
for (i=0; i<Max; i = i+1)
  begin: Stuff
    reg temp;
    and A(bus[i], InBus[i], InBus[i+1]);
    always@(Abus) #1 temp <= &A;Bus;
    assign #1 OutBit1 = temp;
  end
endgenerate
","""Exploration of synthesis constraints and Verilog generate block for FIFO implementation in a digital design course document.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p183.jpg,True,"```verilog
initial begin
  do_action();
  fork     // isolate following statements as a separate thread
    begin
      start_a_thread(10);
      start_a_thread(30);
      #15 disable fork;         // OK, only affects the fork...join
    end
  join
  #100;   // wait for all threads to complete
end
```","
initial begin
  do_action();
  fork     // isolate following statements as a separate thread
    begin
      start_a_thread(10);
      start_a_thread(30);
      #15 disable fork;         // OK, only affects the fork...join
    end
  join
  #100;   // wait for all threads to complete
end
","A textbook excerpt discussing multi-threaded programming gotchas in Verilog, highlighting the importance of enclosing a `disable fork` statement within a `fork...join` block to avoid unintended side effects on other threads.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p342.jpg,True,"The image contains Verilog code snippets. Here they are:

Example 14.27:
```verilog
checker check(a, event clk);
  always_ff @(clk)
    a1: assert property (@(clk) a);
endchecker : check

module m(input logic clock, b, en);
  // ...
  always @(posedge clock) begin
    if (en) begin
      // ...
      check mycheck(b, negedge clock);
    end
  end
endmodule : m
```

Conceptually equivalent code to Example 14.27:
```verilog
module m(input logic clock, b, en);
  // ...
  always @(posedge clock) begin
    if (en) begin
      // ...
    end
  end
  always_ff @(negedge clock)
    a1: assert property (@(negedge clock) b);
endmodule : m
```

Example 14.28:
```verilog
checker check(a, event clk = $inferred_clock);
  initial
    a1: assert property (@(clk s_eventually) a);
endchecker : check

module m(input logic clock, b, en);
  // ...
  always @(posedge clock) begin
    if (en) begin
      // ...
    end
  end
endmodule : m
```

There is additional text providing context and explanations. If you need any specific information from the text, please let me know.","
checker check(a, event clk);
  always_ff @(clk)
    a1: assert property (@(clk) a);
endchecker : check

module m(input logic clock, b, en);
  // ...
  always @(posedge clock) begin
    if (en) begin
      // ...
      check mycheck(b, negedge clock);
    end
  end
endmodule : m


module m(input logic clock, b, en);
  // ...
  always @(posedge clock) begin
    if (en) begin
      // ...
    end
  end
  always_ff @(negedge clock)
    a1: assert property (@(negedge clock) b);
endmodule : m


checker check(a, event clk = $inferred_clock);
  initial
    a1: assert property (@(clk s_eventually) a);
endchecker : check

module m(input logic clock, b, en);
  // ...
  always @(posedge clock) begin
    if (en) begin
      // ...
    end
  end
endmodule : m
","""Example of Verilog code illustrating procedural checker instances and their usage within a module.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p355.jpg,True,"The image includes two segments of Verilog code. The first piece of code is:

```verilog
tf_strdelputp(2, 16, 'H', ""F5xz"", 0, 0);
```

And the second piece of code is:

```verilog
char value_str[5];
strcpy(value_str, ""1x0z"");
tf_strdelputp(1, 4, 'b', value_str, 25, 0);
```

These code examples demonstrate how to write values to system tasks or functions in Verilog. The first code writes a literal C string with a hexadecimal value, and the second code writes a binary value that is stored in a string.","
tf_strdelputp(2, 16, 'H', ""F5xz"", 0, 0);


char value_str[5];
strcpy(value_str, ""1x0z"");
tf_strdelputp(1, 4, 'b', value_str, 25, 0);
","Caption: ""Understanding Verilog TF Routines: Legal Value Characters, Delay, and Mode Definitions with Code Examples""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p428.jpg,True,"```verilog
// Construct an environment instance
function Environment::new(input vUtopiaRx Rx[], input vUtopiaTx Tx[], input int numRx, numTx, input vCPU_T mif);
    this.Rx = new[Rx.size()]();
    foreach (Rx[i]) this.Rx[i] = Rx[i];
    this.Tx = new[Tx.size()]();
    foreach (Tx[i]) this.Tx[i] = Tx[i];
    this.numRx = numRx;
    this.numTx = numTx;
    this.mif = mif;
    cfg = new(numRx,numTx);

    if (`$test$plusargs(""ntb_random_seed"")) begin
        int seed;
        `$value$plusargs(""ntb_random_seed=%d"", seed);
        $display(""Simulation run with random seed=%0d"", seed);
    end else
        $display(""Simulation run with default random seed"");
endfunction : new

// Randomize the configuration descriptor
function void Environment::gen_cfg();
    `SV_RAND_CHECK(cfg.randomize());
    cfg.display();
endfunction : gen_cfg

// Build the environment objects for this test
function void Environment::build();
    cpu = new(mif, cfg);
    gen = new[numRx];
    drv = new[numRx];
    gen2drv = new[numRx];
    drv2gen = new[numRx];
    scb = new(cfg);
    cov = new();

    // Build generators
    foreach(gen[i]) begin
        gen2drv[i] = new();
    end
```","
// Construct an environment instance
function Environment::new(input vUtopiaRx Rx[], input vUtopiaTx Tx[], input int numRx, numTx, input vCPU_T mif);
    this.Rx = new[Rx.size()]();
    foreach (Rx[i]) this.Rx[i] = Rx[i];
    this.Tx = new[Tx.size()]();
    foreach (Tx[i]) this.Tx[i] = Tx[i];
    this.numRx = numRx;
    this.numTx = numTx;
    this.mif = mif;
    cfg = new(numRx,numTx);

    if (`$test$plusargs(""ntb_random_seed"")) begin
        int seed;
        `$value$plusargs(""ntb_random_seed=%d"", seed);
        $display(""Simulation run with random seed=%0d"", seed);
    end else
        $display(""Simulation run with default random seed"");
endfunction : new

// Randomize the configuration descriptor
function void Environment::gen_cfg();
    `SV_RAND_CHECK(cfg.randomize());
    cfg.display();
endfunction : gen_cfg

// Build the environment objects for this test
function void Environment::build();
    cpu = new(mif, cfg);
    gen = new[numRx];
    drv = new[numRx];
    gen2drv = new[numRx];
    drv2gen = new[numRx];
    scb = new(cfg);
    cov = new();

    // Build generators
    foreach(gen[i]) begin
        gen2drv[i] = new();
    end
",Example code of environment class methods in SystemVerilog as part of a testbench.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p427.jpg,True,"```c
/* read next line from the file */
if ( (fscanf(data_p->file_ptr, ""%d %s\n"", 
    &delay, data_p->vector)) == EOF) {
    tf_rosynchronize(); /* if end of file, schedule a callback */
    break;              /* at the end of the current time step */
}
if (debug)
    io_printf(""*** values read from file: delay = %d vector = %s\n"",
              delay, data_p->vector);

/* set flag for test vector radix */
switch(user_data) {
    case 0:
    case 1: base = 'b'; break; /* vectors are in binary format */
    case 2:
    case 3: base = 'h'; break; /* vectors are in hex format */
}

/* convert absolute delays to relative to current time */
switch(user_data) {
    case 0:
    case 2: /* using absolute delays; convert to relative */
            delay = delay - tf_gettime();
}

/* schedule the vector to be applied after the delay period */
tf_strdelputp(2, tf_sizep(2), base, data_p->vector, delay, 0);

/* schedule reactive callback to this routine after delay time */
tf_setdelay(delay);
break;

case REASON_ROSYNCH: /* miscft called at end of time step */
    io_printf(""\n%sread_stimulus_?? has encountered end-of-file.\n"");
    tf_dofinish;
    break;

case REASON_FINISH: /* miscft called at end of simulation */
    io_printf(""\nPLI is processing finish at simulation time %s\n\n"",
              tf_strgettime());
    /* get the pointer to the application data from the work area */
    data_p = (PLIbook_stim_data_p)tf_getworkarea();
    /* close file */
    if (data_p->file_ptr) fclose(data_p->file_ptr);
    /* de-allocate storage */
    free(data_p);
    break;
``` 

Note that there are some case statements without a `break;`. In practical use, this would cause fall-through behavior in a `switch` statement where execution continues with the next `case` block until a `break;` is encountered or the `switch` ends. This can be a deliberate programming choice to share code for multiple cases, or an error if not intentional.","ad next line from the file */
if ( (fscanf(data_p->file_ptr, ""%d %s\n"", 
    &delay, data_p->vector)) == EOF) {
    tf_rosynchronize(); /* if end of file, schedule a callback */
    break;              /* at the end of the current time step */
}
if (debug)
    io_printf(""*** values read from file: delay = %d vector = %s\n"",
              delay, data_p->vector);

/* set flag for test vector radix */
switch(user_data) {
    case 0:
    case 1: base = 'b'; break; /* vectors are in binary format */
    case 2:
    case 3: base = 'h'; break; /* vectors are in hex format */
}

/* convert absolute delays to relative to current time */
switch(user_data) {
    case 0:
    case 2: /* using absolute delays; convert to relative */
            delay = delay - tf_gettime();
}

/* schedule the vector to be applied after the delay period */
tf_strdelputp(2, tf_sizep(2), base, data_p->vector, delay, 0);

/* schedule reactive callback to this routine after delay time */
tf_setdelay(delay);
break;

case REASON_ROSYNCH: /* miscft called at end of time step */
    io_printf(""\n%sread_stimulus_?? has encountered end-of-file.\n"");
    tf_dofinish;
    break;

case REASON_FINISH: /* miscft called at end of simulation */
    io_printf(""\nPLI is processing finish at simulation time %s\n\n"",
              tf_strgettime());
    /* get the pointer to the application data from the work area */
    data_p = (PLIbook_stim_data_p)tf_getworkarea();
    /* close file */
    if (data_p->file_ptr) fclose(data_p->file_ptr);
    /* de-allocate storage */
    free(data_p);
    break;
","""Example of Verilog code integrated with C for file handling, debugging, and scheduling simulation events.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p430.jpg,True,"Here is the Verilog code presented in the image:

```verilog
covergroup cover_delay @(posedge clk);
    dl_pt: coverpoint delay {
        bins delays [100] : {[1:110]};
    }
    dt_pt: coverpoint data;
    dlXdt: cross dt_pt, dl_pt;
endgroup
cover_delay cover_delay_inst = new();
```

And further down in the image, there is a snippet of a function definition:

```verilog
covergroup cover_delay
    with function sample(int unsigned delay, logic [7:0] data);
```

This code defines coverage groups and cover points to monitor the functional coverage of a Verilog design.","
covergroup cover_delay @(posedge clk);
    dl_pt: coverpoint delay {
        bins delays [100] : {[1:110]};
    }
    dt_pt: coverpoint data;
    dlXdt: cross dt_pt, dl_pt;
endgroup
cover_delay cover_delay_inst = new();


covergroup cover_delay
    with function sample(int unsigned delay, logic [7:0] data);
","Caption: ""An example of Verilog code demonstrating the use of a coverage group for tracking occurrence counts and correlated pairs of values using coverpoints and cross coverage in system-level verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p356.jpg,True,"The image contains two code snippets in Verilog. Here they are:

First snippet from Fig. 15.4:
```verilog
dataType last_dataIn;
always @(posedge clk)
    if (s$sampled(start))
        last_dataIn <= $sampled(dataIn);
a_seq_data_check: assert property (
    start ##1 complete[-1]
    |-> dataOut == last_dataIn
);
```

Second snippet from Fig. 15.5:
```verilog
property p_seq_data_check;
    dataType data;
    (start, data = dataIn) ##1 complete[-1]
    |-> dataOut == data;
endproperty
a_seq_data_check: assert property (p_seq_data_check);
```

These snippets illustrate the encoding of sequential protocol data checks, one without local variables (Fig. 15.4) and the other with a local variable (Fig. 15.5).","
dataType last_dataIn;
always @(posedge clk)
    if (s$sampled(start))
        last_dataIn <= $sampled(dataIn);
a_seq_data_check: assert property (
    start ##1 complete[-1]
    |-> dataOut == last_dataIn
);


property p_seq_data_check;
    dataType data;
    (start, data = dataIn) ##1 complete[-1]
    |-> dataOut == data;
endproperty
a_seq_data_check: assert property (p_seq_data_check);
","""Examples of Verilog assertions to check sequential protocol data with and without using local variables.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p341.jpg,True,"```c
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include <stdlib.h>   /* ANSI C standard library */
#include <stdio.h>    /* ANSI C standard input/output library */
/***************************************************************
 * checktf routine
 ***************************************************************/
int PLIbook_ReadVector_checktf()
{
    if (tf_nump() != 2) /* check for two system task/function */
        tf_error(""$read_test_vector(\""<file>\"",<reg_variable>);"");
    if (tf_typep(1) != TF_STRING) /* check that first arg is a string */
        tf_error(""$read_test_vector arg 1 must be a quoted file name"");
    if (tf_typep(2) != TF_READWRITE) /* check that 2nd arg is reg type */
        tf_error(""$read_test_vector arg 2 must be a register data type"");
    return (0);
}

/***************************************************************
 * miscft routine
 * Use the miscft routine to open test vector file at the beginning
 * of simulation, and save the file pointer in the work area for the
 * instance of $read_test_vector that called the miscft routine.
 ***************************************************************/
int PLIbook_ReadVector_miscft(int user_data, int reason)
{
    FILE *in_file;
    char *file_name;
    
    if (reason == REASON_ENDOFCOMPILE) { /* time to open vector file */
        if ( (in_file = fopen(tf_getcstringp(1), ""r"")) == NULL)
            tf_error(""$read_test_vector cannot open file %s"",
                     tf_getcstringp(1));
        tf_setworkarea((char*)in_file); /* save file pointer in workarea */
    }
    return(0);
}

/***************************************************************
 * calltf routine
 ***************************************************************/
int PLIbook_ReadVector_calltf()
{
    FILE *in_file;
```","ude ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include <stdlib.h>   /* ANSI C standard library */
#include <stdio.h>    /* ANSI C standard input/output library */
/***************************************************************
 * checktf routine
 ***************************************************************/
int PLIbook_ReadVector_checktf()
{
    if (tf_nump() != 2) /* check for two system task/function */
        tf_error(""$read_test_vector(\""<file>\"",<reg_variable>);"");
    if (tf_typep(1) != TF_STRING) /* check that first arg is a string */
        tf_error(""$read_test_vector arg 1 must be a quoted file name"");
    if (tf_typep(2) != TF_READWRITE) /* check that 2nd arg is reg type */
        tf_error(""$read_test_vector arg 2 must be a register data type"");
    return (0);
}

/***************************************************************
 * miscft routine
 * Use the miscft routine to open test vector file at the beginning
 * of simulation, and save the file pointer in the work area for the
 * instance of $read_test_vector that called the miscft routine.
 ***************************************************************/
int PLIbook_ReadVector_miscft(int user_data, int reason)
{
    FILE *in_file;
    char *file_name;
    
    if (reason == REASON_ENDOFCOMPILE) { /* time to open vector file */
        if ( (in_file = fopen(tf_getcstringp(1), ""r"")) == NULL)
            tf_error(""$read_test_vector cannot open file %s"",
                     tf_getcstringp(1));
        tf_setworkarea((char*)in_file); /* save file pointer in workarea */
    }
    return(0);
}

/***************************************************************
 * calltf routine
 ***************************************************************/
int PLIbook_ReadVector_calltf()
{
    FILE *in_file;
","""Example of Verilog PLI (Programming Language Interface) code for reading test vectors using TF routines from 'The Verilog PLI Handbook'.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p154.jpg,True,"The image contains Verilog code. Here is the code in the image:

```verilog
module mbox_example1 ( ... );
  logic [15:0] a, b;
  int i, j, s;
  struct packed {int u, v, w;} d_in, d_out;

  mailbox mbox1 = new; // typeless mailbox

  initial begin
    mbox1.put(a); // OK: can put message of any data type
    mbox1.put(i); // OK: can put message of any data type
    mbox1.put(d_in); // OK: can put message of any data type

    s = mbox1.try_get(d_out); // must check status to see if OK
    case (s)
      1: $display(""try_get() succeeded"");
      0: $display(""try_get() failed, no message in mailbox"");
      default: $display(""try_get() failed due to type error"");
    endcase
  end
endmodule

typedef struct {int a, b} data_packet_t;

mailbox #(data_packet_t) mbox2 = new; // typed mailbox
```

This code demonstrates two different usages of a mailbox in Verilog/SystemVerilog for inter-process communication: a typeless mailbox and a typed mailbox, along with describing how to handle the return value of the `try_get()` method. The code also has a definition for a `typedef` structured data type named `data_packet_t` that is used for the typed mailbox `mbox2`.","
module mbox_example1 ( ... );
  logic [15:0] a, b;
  int i, j, s;
  struct packed {int u, v, w;} d_in, d_out;

  mailbox mbox1 = new; // typeless mailbox

  initial begin
    mbox1.put(a); // OK: can put message of any data type
    mbox1.put(i); // OK: can put message of any data type
    mbox1.put(d_in); // OK: can put message of any data type

    s = mbox1.try_get(d_out); // must check status to see if OK
    case (s)
      1: $display(""try_get() succeeded"");
      0: $display(""try_get() failed, no message in mailbox"");
      default: $display(""try_get() failed due to type error"");
    endcase
  end
endmodule

typedef struct {int a, b} data_packet_t;

mailbox #(data_packet_t) mbox2 = new; // typed mailbox
","Caption: Example of a Verilog code snippet illustrating the use of a typeless mailbox and how to handle the try_get() method, along with a description of typed mailboxes to prevent run-time errors.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p170.jpg,True,"Here is the Verilog code present in the image:

```verilog
`ifdef COVERAGE_ON
// look for a queue-full condition
always @(posedge clk) begin
    if (reset_n == 1'b1 && q_full) begin
        $display(""COV_Q_FULL@ %0d:%t:%m"", $time);
    end // end if (...q_full...)
end
`endif
```","
`ifdef COVERAGE_ON
// look for a queue-full condition
always @(posedge clk) begin
    if (reset_n == 1'b1 && q_full) begin
        $display(""COV_Q_FULL@ %0d:%t:%m"", $time);
    end // end if (...q_full...)
end
`endif
","""Verilog example showing RTL functional coverage for a queue-full condition""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p74.jpg,True,"```verilog
always @(a or b)  // ""or"" is separator, not operator
    sum = a + b;

always @(a | b)  // GOTCHA! ""|"" is operator
    sum = a + b;

always @(a && b)  // GOTCHA!
    sum = a + b;

always @(a == b)  // GOTCHA!
    sum = a + b;
```

The image contains these snippets of Verilog code.","
always @(a or b)  // ""or"" is separator, not operator
    sum = a + b;

always @(a | b)  // GOTCHA! ""|"" is operator
    sum = a + b;

always @(a && b)  // GOTCHA!
    sum = a + b;

always @(a == b)  // GOTCHA!
    sum = a + b;
","""Understanding Sensitivity Lists Gotchas in Verilog and How to Avoid Them""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p524.jpg,True,"Here is the Verilog code from the image:

```verilog
assign WireX = A && B, WireY = C||(D^E), WireZ = WireY | A && D;

wire WireX = A && B;
```

```verilog
ALU U1 ( .Result(Res), .Ain(A), .Bin(B), .Clk(GatedClock) );
...
bufif1 ClockGater (GatedClock, Clock, Ena);
```

These are examples provided in the context of discussing Verilog coding styles and recommendations.","
assign WireX = A && B, WireY = C||(D^E), WireZ = WireY | A && D;

wire WireX = A && B;


ALU U1 ( .Result(Res), .Ain(A), .Bin(B), .Clk(GatedClock) );
...
bufif1 ClockGater (GatedClock, Clock, Ena);
",Page discussing certain Verilog coding practices and constructs to avoid with examples.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p60.jpg,True,"Here is the Verilog code found in the image:

```verilog
module top;
    wire [7:0] data;
    wire [7:0] addr;
    
    block1 b1 (.data,      // implicit port connections
               .addr);
    
endmodule: top

module block1 (input [7:0] data,
               input [3:0] addr,
               input [3:0] byte_en);
   ...
endmodule: block1
```

The text discusses a solution to avoid a gotcha in SystemVerilog, where implicit port connections using either dot-name or dot-star module instantiations can help make it obvious in the code when there's a port size mismatch.","
module top;
    wire [7:0] data;
    wire [7:0] addr;
    
    block1 b1 (.data,      // implicit port connections
               .addr);
    
endmodule: top

module block1 (input [7:0] data,
               input [3:0] addr,
               input [3:0] byte_en);
   ...
endmodule: block1
","Excerpt from a book discussing pitfalls in Verilog code declarations and how to avoid them using SystemVerilog, including an example of an implicit port connection in a Verilog module.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p140.jpg,True,"The image contains several blocks of Verilog code. I'll transcribe them for you:

```verilog
module chip (input logic clock, input logic reset_n, ...);

always_ff @(posedge clock, negedge reset_n) // asynchronous reset
    if (!reset_n) q <= 0;
    else q <= d;
endmodule

module test (input logic clock, output logic reset_n, ...);

initial begin
    reset_n = 0;      // GOTCHA! activating reset at time zero
    #10 reset_n = 1;
    ...
end
endmodule

module top;
    logic clock, reset_n, ...;
    test test (.*);                // connect testbench to design
    chip dut (.*);

    initial begin
        clock = 0;                 // OK! first rising clock edge at time 5
        forever #5 clock = ~clock;
    end
endmodule
```

The Verilog code here is defining three modules (`chip`, `test`, and `top`) and illustrates a concept known as a ""gotcha"" related to the order of activation of procedural blocks within Verilog/SystemVerilog simulations.","
module chip (input logic clock, input logic reset_n, ...);

always_ff @(posedge clock, negedge reset_n) // asynchronous reset
    if (!reset_n) q <= 0;
    else q <= d;
endmodule

module test (input logic clock, output logic reset_n, ...);

initial begin
    reset_n = 0;      // GOTCHA! activating reset at time zero
    #10 reset_n = 1;
    ...
end
endmodule

module top;
    logic clock, reset_n, ...;
    test test (.*);                // connect testbench to design
    chip dut (.*);

    initial begin
        clock = 0;                 // OK! first rising clock edge at time 5
        forever #5 clock = ~clock;
    end
endmodule
","""Exploration of asynchronous resets in Verilog and potential gotchas with activation order of procedural blocks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p396.jpg,True,"Here is the code in the image:

```c
mem_address = tf_getp(2); /* get address to propagate changes */
tf_evaluate(1);            /* update expr_info structure */
info->expr_info->expr_value_p[mem_address].avalbits = mem_address;
info->expr_info->expr_value_p[mem_address].bvalbits = 0x0;

tf_propagatep(1); /* propagate memory changes into simulation */

return(0);
}
```
And further down:

```c
char *aval_ptr, *bval_ptr;
aval_ptr = node_info.node_value.memoryval_p
           + (word_increment * memory_address);
bval_ptr = aval_ptr + node_info.node_n_groups;
```

```c
int group_num;
group_num = bit_num / 8;
```

This excerpt provides information about manipulating memory within a Verilog PLI (Programming Language Interface) using C-like syntax.","ddress = tf_getp(2); /* get address to propagate changes */
tf_evaluate(1);            /* update expr_info structure */
info->expr_info->expr_value_p[mem_address].avalbits = mem_address;
info->expr_info->expr_value_p[mem_address].bvalbits = 0x0;

tf_propagatep(1); /* propagate memory changes into simulation */

return(0);
}

*aval_ptr, *bval_ptr;
aval_ptr = node_info.node_value.memoryval_p
           + (word_increment * memory_address);
bval_ptr = aval_ptr + node_info.node_n_groups;

roup_num;
group_num = bit_num / 8;
","""Excerpt from The Verilog PLI Handbook detailing methods for accessing and manipulating individual bits within a Verilog array word using C code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p168.jpg,True,"```verilog
always @(clock0)
  clock6 <= #6 clock0;  // OK, 6ns intra-assignment delay
```","
always @(clock0)
  clock6 <= #6 clock0;  // OK, 6ns intra-assignment delay
","""Understanding inertial and transport delay in Verilog code and avoiding common simulation gotchas.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p381.jpg,True,"```verilog
property p_type_vs_data;
    transType l_ttype;
    (start, l_ttype = ttype)
    ##1 (dataValid within complete[->1])
    -> ttypeAllowsData(l_ttype);
endproperty

sequence s_compare_two_data_and_parity;
    dataType l_data;
    parityType l_parity;
    start
    ##1 (dataValid[->1], l_data = data, l_parity = parity)
    ##1 dataValid[->1]
    ##0 data == l_data && parity == l_parity;
endsequence
```","
property p_type_vs_data;
    transType l_ttype;
    (start, l_ttype = ttype)
    ##1 (dataValid within complete[->1])
    -> ttypeAllowsData(l_ttype);
endproperty

sequence s_compare_two_data_and_parity;
    dataType l_data;
    parityType l_parity;
    start
    ##1 (dataValid[->1], l_data = data, l_parity = parity)
    ##1 dataValid[->1]
    ##0 data == l_data && parity == l_parity;
endsequence
","Caption: ""Example of Verilog local variable assignments in SystemVerilog property and sequence declarations, illustrating the syntax and usage for capturing values during sequence evaluation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p518.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
initial $sdf_annotate(""Intro_TopNetlist.sdf"");
```","
initial $sdf_annotate(""Intro_TopNetlist.sdf"");
","Caption: ""Instructions for back-annotating a Verilog netlist with SDF timing information and comparing simulation waveforms with original netlist timings.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p48.jpg,True,"Here is the Verilog code from the image:

```verilog
package chip_types;
  typedef enum logic [1:0] {HOLD, LOAD, READY} states_t;
endpackage

package bus_types;
  localparam HOLD = 32;
  ...
endpackage

module chip (...);
  import chip_types::*; // wildcard import of a package
  import bus_types::*; // wildcard import of another package
  
  states_t state_e, nstate_e;
  
  always_ff @(posedge clock, negedge reset_n)
    if (!reset_n) state_e <= HOLD; // GOTCHA: HOLD has multiple definitions
    else state_e <= nstate_e; // definitions
  ...
endmodule
```

And there is more code about avoiding the gotcha as well:

```verilog
import chip_types::*; // wildcard import of a package
import bus_types::*; // wildcard import of another package
import chip_types::HOLD; // explicit import of HOLD
```","
package chip_types;
  typedef enum logic [1:0] {HOLD, LOAD, READY} states_t;
endpackage

package bus_types;
  localparam HOLD = 32;
  ...
endpackage

module chip (...);
  import chip_types::*; // wildcard import of a package
  import bus_types::*; // wildcard import of another package
  
  states_t state_e, nstate_e;
  
  always_ff @(posedge clock, negedge reset_n)
    if (!reset_n) state_e <= HOLD; // GOTCHA: HOLD has multiple definitions
    else state_e <= nstate_e; // definitions
  ...
endmodule


import chip_types::*; // wildcard import of a package
import bus_types::*; // wildcard import of another package
import chip_types::HOLD; // explicit import of HOLD
","Caption: ""Understanding Verilog Gotchas: Collisions in Wildcard Importing from Multiple Packages""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p399.jpg,True,"The image contains the following code written in Verilog:

```verilog
typedef enum {ADD, SUB, MULT, DIV} opcode_e;

class Transaction;
  rand opcode_e opcode;
  rand byte operand1;
  rand byte operand2;
endclass

Transaction tr;
```

The code is part of an exercise related to Verilog hardware description language, specifically focusing on the use of enumerations, classes, and randomization for verification purposes.","
typedef enum {ADD, SUB, MULT, DIV} opcode_e;

class Transaction;
  rand opcode_e opcode;
  rand byte operand1;
  rand byte operand2;
endclass

Transaction tr;
","""Exercises for Verilog Functional Coverage and Constrained Random Verification""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p382.jpg,True,"The image contains examples of Verilog code snippets pertaining to array declaration syntax. Here they are:

```verilog
reg [23:0] RAM1 [0:3]; //first word is address 0
reg [23:0] RAM1 [3:0]; //first word is address 3
reg [24:1] RAM1 [0:3]; //least-significant bit is bit 0
reg [24:1] RAM1 [3:0]; //least-significant bit is bit 23
reg [24:1] RAM1 [0:3]; //least-significant bit is bit 1
reg [24:1] RAM1 [1:4]; //first word is address 1
```

Please note that these are declarations for one-dimensional arrays in Verilog with various addressing and bit numbering configurations.","
reg [23:0] RAM1 [0:3]; //first word is address 0
reg [23:0] RAM1 [3:0]; //first word is address 3
reg [24:1] RAM1 [0:3]; //least-significant bit is bit 0
reg [24:1] RAM1 [3:0]; //least-significant bit is bit 23
reg [24:1] RAM1 [0:3]; //least-significant bit is bit 1
reg [24:1] RAM1 [1:4]; //first word is address 1
","Caption: ""Understanding one-dimensional array declaration in Verilog and mapping Verilog memory arrays to C character arrays, as explained in The Verilog PLI Handbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p395.jpg,True,"Here is the Verilog code from the image:

```verilog
property p_no_repeat_ttype (
    ttype varying_ttype, captured_ttype
);
    start [->1:2]
    |->
        varying_ttype != captured_ttype;
endproperty

property p_ttype_check;
    ttype l_ttype;
    (start && ((ttype == INV || ttype == PRG), l_ttype = ttype)
    |=> p_no_repeat_ttype (
           .varying_ttype(ttype),
           .captured_ttype(l_ttype)
       );
endproperty
```","
property p_no_repeat_ttype (
    ttype varying_ttype, captured_ttype
);
    start [->1:2]
    |->
        varying_ttype != captured_ttype;
endproperty

property p_ttype_check;
    ttype l_ttype;
    (start && ((ttype == INV || ttype == PRG), l_ttype = ttype)
    |=> p_no_repeat_ttype (
           .varying_ttype(ttype),
           .captured_ttype(l_ttype)
       );
endproperty
","""Explanation of passing local variable values into SystemVerilog properties and sequences, with code examples""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p320.jpg,True,"The image contains excerpts of text explaining properties in Verilog, specifically the ""always"" and ""s_always"" properties. There are also snippets of code showcasing how these properties are used. Here is the code:

```verilog
property reset_always;
    @(posedge clk) POR[*5] |=> always !reset;
endproperty
```

```verilog
property p1;
    @(posedge clk) a |-> always [3:$] b;
endproperty
```

```verilog
property p2;
    @(posedge clk) a |-> s_always [3:10] b;
endproperty
```

These code examples describe various ways to use the `always` and `s_always` properties in Verilog assertions for checking temporal properties of signals in a hardware design.","
property reset_always;
    @(posedge clk) POR[*5] |=> always !reset;
endproperty


property p1;
    @(posedge clk) a |-> always [3:$] b;
endproperty


property p2;
    @(posedge clk) a |-> s_always [3:10] b;
endproperty
","This image provides an explanation of the ""always"" and ""s_always"" properties in Verilog, demonstrating the use of these properties to create assertions with unbounded and bounded ranges, respectively, using examples of Verilog code.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p170.jpg,True,"```verilog
interface my_if(input bit clk);
  bit write;
  bit [15:0] data_in;
  bit [7:0] address;
  logic [15:0] data_out;
endinterface
```","
interface my_if(input bit clk);
  bit write;
  bit [15:0] data_in;
  bit [7:0] address;
  logic [15:0] data_out;
endinterface
","""Verilog interface code for an ARM AHB compliant system.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p446.jpg,True,"The image includes a snippet of code which appears to be related to assertions and functional coverage in Verilog or SystemVerilog. Here is the code extracted from the image:

```verilog
property pr1;
    @(posedge clk) Rd |-> ##2 RdAck;
endproperty

rdAckCheck: assert property (pr1);

crdAckCheck: cover property (pr1);

covergroup PCICcommands @(posedge clk);
    coverpoint PCICreadCmds;
    coverpoint PCICwriteCmds;
endgroup
```

This code establishes properties for simulation assertions and functional coverage, and then creates a covergroup with two coverpoints, possibly for tracking the coverage of certain commands (`PCICreadCmds` and `PCICwriteCmds`) in a PCI-Express-like interface scenario. The exact commands or signals these refer to, such as `Rd` or `RdAck`, are not defined within this snippet and would depend on the greater context of the entire testbench or module.","
property pr1;
    @(posedge clk) Rd |-> ##2 RdAck;
endproperty

rdAckCheck: assert property (pr1);

crdAckCheck: cover property (pr1);

covergroup PCICcommands @(posedge clk);
    coverpoint PCICreadCmds;
    coverpoint PCICwriteCmds;
endgroup
",Functional Coverage and Assertion Based Verification Methodology in Verilog.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p168.jpg,True,"```verilog
$rising_gclk(e) =
  $sampled(LSB(e))!== 1 && $future_gclk(LSB(e)) === 1

$falling_gclk(e) =
  $sampled(LSB(e))!== 0 && $future_gclk(LSB(e)) === 0

$changing_gclk(e) =
  $sampled(e)!== $future_gclk(e)

$steady_gclk(e) =
  $sampled(e)=== $future_gclk(e)
```

```verilog
always @(posedge clk) a <= $future_gclk(b) && c;
a1_illegal: assert final (a -> $future_gclk(b));
a2_illegal: assert property (@(posedge clk)
  disable iff (rst || $rising_gclk(interrupt)) req |=> gnt);
a3_illegal: assert property (@(posedge clk) req |->
  $future_gclk (ack && $rising_gclk(gnt));
```","
$rising_gclk(e) =
  $sampled(LSB(e))!== 1 && $future_gclk(LSB(e)) === 1

$falling_gclk(e) =
  $sampled(LSB(e))!== 0 && $future_gclk(LSB(e)) === 0

$changing_gclk(e) =
  $sampled(e)!== $future_gclk(e)

$steady_gclk(e) =
  $sampled(e)=== $future_gclk(e)


always @(posedge clk) a <= $future_gclk(b) && c;
a1_illegal: assert final (a -> $future_gclk(b));
a2_illegal: assert property (@(posedge clk)
  disable iff (rst || $rising_gclk(interrupt)) req |=> gnt);
a3_illegal: assert property (@(posedge clk) req |->
  $future_gclk (ack && $rising_gclk(gnt));
","The image presents a section from documentation or a textbook discussing Sampled Value Functions in Verilog, describing different future global clocking sampled value functions and providing guidelines on their use, including restrictions and examples of incorrect usage.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p164.jpg,True,"The image contains a Verilog code snippet for a testbench module. Here is the code transcribed from the image:

```verilog
module test_ports (
    // 4 x Level 1 Utopia ATM layer Rx Interfaces
    Rx_clk_0, Rx_clk_1, Rx_clk_2, Rx_clk_3,
    Rx_data_0, Rx_data_1, Rx_data_2, Rx_data_3,
    Rx_soc_0, Rx_soc_1, Rx_soc_2, Rx_soc_3,
    Rx_en_0, Rx_en_1, Rx_en_2, Rx_en_3,
    Rx_clav_0, Rx_clav_1, Rx_clav_2, Rx_clav_3,

    // 4 x Level 1 Utopia ATM layer Tx Interfaces
    Tx_clk_0, Tx_clk_1, Tx_clk_2, Tx_clk_3,
    Tx_data_0, Tx_data_1, Tx_data_2, Tx_data_3,
    Tx_soc_0, Tx_soc_1, Tx_soc_2, Tx_soc_3,
    Tx_en_0, Tx_en_1, Tx_en_2, Tx_en_3,
    Tx_clav_0, Tx_clav_1, Tx_clav_2, Tx_clav_3,

    rst, clk); // Miscellaneous control signals

// 4 x Level 1 Utopia Rx Interfaces
input     Rx_clk_0, Rx_clk_1, Rx_clk_2, Rx_clk_3;
input [7:0] Rx_data_0, Rx_data_1, Rx_data_2, Rx_data_3;
reg [7:0] Rx_data_0, Rx_data_1, Rx_data_2, Rx_data_3;
output    Rx_soc_0, Rx_soc_1, Rx_soc_2, Rx_soc_3;
reg       Rx_soc_0, Rx_soc_1, Rx_soc_2, Rx_soc_3;
input     Rx_en_0, Rx_en_1, Rx_en_2, Rx_en_3;
output    Rx_clav_0, Rx_clav_1, Rx_clav_2, Rx_clav_3;
reg       Rx_clav_0, Rx_clav_1, Rx_clav_2, Rx_clav_3;

// 4 x Level 1 Utopia Tx Interfaces
input     Tx_clk_0, Tx_clk_1, Tx_clk_2, Tx_clk_3;
input [7:0] Tx_data_0, Tx_data_1, Tx_data_2, Tx_data_3;
input     Tx_soc_0, Tx_soc_1, Tx_soc_2, Tx_soc_3;
input     Tx_en_0, Tx_en_1, Tx_en_2, Tx_en_3;
output    Tx_clav_0, Tx_clav_1, Tx_clav_2, Tx_clav_3;
reg       Tx_clav_0, Tx_clav_1, Tx_clav_2, Tx_clav_3;

// Miscellaneous control interfaces
output rst;
reg    rst;
input  clk;

initial begin
    // Reset the device
    rst <= 1;
    Rx_data_0 <= 0;
    ...
end

endmodule
``` 

Please note that the ellipsis (`...`) in the initial block indicates that there is more code or comments that are not displayed in the image.","
module test_ports (
    // 4 x Level 1 Utopia ATM layer Rx Interfaces
    Rx_clk_0, Rx_clk_1, Rx_clk_2, Rx_clk_3,
    Rx_data_0, Rx_data_1, Rx_data_2, Rx_data_3,
    Rx_soc_0, Rx_soc_1, Rx_soc_2, Rx_soc_3,
    Rx_en_0, Rx_en_1, Rx_en_2, Rx_en_3,
    Rx_clav_0, Rx_clav_1, Rx_clav_2, Rx_clav_3,

    // 4 x Level 1 Utopia ATM layer Tx Interfaces
    Tx_clk_0, Tx_clk_1, Tx_clk_2, Tx_clk_3,
    Tx_data_0, Tx_data_1, Tx_data_2, Tx_data_3,
    Tx_soc_0, Tx_soc_1, Tx_soc_2, Tx_soc_3,
    Tx_en_0, Tx_en_1, Tx_en_2, Tx_en_3,
    Tx_clav_0, Tx_clav_1, Tx_clav_2, Tx_clav_3,

    rst, clk); // Miscellaneous control signals

// 4 x Level 1 Utopia Rx Interfaces
input     Rx_clk_0, Rx_clk_1, Rx_clk_2, Rx_clk_3;
input [7:0] Rx_data_0, Rx_data_1, Rx_data_2, Rx_data_3;
reg [7:0] Rx_data_0, Rx_data_1, Rx_data_2, Rx_data_3;
output    Rx_soc_0, Rx_soc_1, Rx_soc_2, Rx_soc_3;
reg       Rx_soc_0, Rx_soc_1, Rx_soc_2, Rx_soc_3;
input     Rx_en_0, Rx_en_1, Rx_en_2, Rx_en_3;
output    Rx_clav_0, Rx_clav_1, Rx_clav_2, Rx_clav_3;
reg       Rx_clav_0, Rx_clav_1, Rx_clav_2, Rx_clav_3;

// 4 x Level 1 Utopia Tx Interfaces
input     Tx_clk_0, Tx_clk_1, Tx_clk_2, Tx_clk_3;
input [7:0] Tx_data_0, Tx_data_1, Tx_data_2, Tx_data_3;
input     Tx_soc_0, Tx_soc_1, Tx_soc_2, Tx_soc_3;
input     Tx_en_0, Tx_en_1, Tx_en_2, Tx_en_3;
output    Tx_clav_0, Tx_clav_1, Tx_clav_2, Tx_clav_3;
reg       Tx_clav_0, Tx_clav_1, Tx_clav_2, Tx_clav_3;

// Miscellaneous control interfaces
output rst;
reg    rst;
input  clk;

initial begin
    // Reset the device
    rst <= 1;
    Rx_data_0 <= 0;
    ...
end

endmodule
",Verilog code example illustrating a testbench module with Utopia ATM layer interfaces and control signal ports.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p452.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
covergroup g1 @(posedge clk);
  oc : coverpoint offset iff (!reset) {}
endgroup

g1 g1_inst = new;
``` 

The code is a part of an example discussing ""coverpoint"" basics related to functional coverage in Verilog for hardware verification.","
covergroup g1 @(posedge clk);
  oc : coverpoint offset iff (!reset) {}
endgroup

g1 g1_inst = new;
",An educational excerpt explaining the basics of coverpoints in Verilog with an example of code and a simulation log showing coverage results.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p334.jpg,True,"The image contains excerpts from a document which describes aspects of Verilog code related to `$inferred_clock` and `$inferred_disable`. The code present in the image reads as follows:

```verilog
module (....,clk, rst,...);
  default clocking @ (negedge clk); endclocking
  default disable iff rst;
```

```verilog
property inferB(a, b, c, clk=$inferred_clock, reset=$inferred_disable);
  disable iff (reset) a |=> b || c;
endproperty

assert property (inferB(x, y, z));
```

```verilog
assert property inferB (a, b, c, posedge clk, reset);
```

The page is describing how to use default clocking and reset blocks in Verilog with the `$inferred_clock` and `$inferred_disable` constructs. It provides an example of module declaration with default clocking and reset conditions, as well as property and assertion definitions that use these defaults.","
module (....,clk, rst,...);
  default clocking @ (negedge clk); endclocking
  default disable iff rst;


property inferB(a, b, c, clk=$inferred_clock, reset=$inferred_disable);
  disable iff (reset) a |=> b || c;
endproperty

assert property (inferB(x, y, z));


assert property inferB (a, b, c, posedge clk, reset);
","""Explanation of Verilog's `$inferred_clock` and `$inferred_disable` constructs with code examples""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p247.jpg,True,"```verilog
c_tAVAV_not: cover property(p_tAVAV_not);

property p_tELOV;
  @(posedge clk)
    (!oe_n && $fell(sel_n[3])) |-> ##14 $isunknown(data) ##1 ($isunknown(data)==0);
endproperty

a_tELOV: assert property(p_tELOV);
c_tELOV: cover property(p_tELOV);
```","
c_tAVAV_not: cover property(p_tAVAV_not);

property p_tELOV;
  @(posedge clk)
    (!oe_n && $fell(sel_n[3])) |-> ##14 $isunknown(data) ##1 ($isunknown(data)==0);
endproperty

a_tELOV: assert property(p_tELOV);
c_tELOV: cover property(p_tELOV);
","""Verilog SystemVerilog Assertion (SVA) for memory interface timing, featuring properties and waveform diagram.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p619.jpg,True,"The image includes a snippet of Verilog code. Here is the code from the image:

```verilog
module chip (...)
    ...
    scientific_alu v1 (a, b, opcode, result, exceP, err);
    ...
endmodule
```

This example demonstrates how to instantiate a module named `scientific_alu` inside another module called `chip`. The `scientific_alu` module is presumably a representation of a C model encapsulated in a Verilog module.","
module chip (...)
    ...
    scientific_alu v1 (a, b, opcode, result, exceP, err);
    ...
endmodule
","This image includes text from a document that describes how to interface to C models using ACC (Application-Specific Integrated Circuit Compiler) routines in Verilog, with a specific focus on creating a combinational logic interface to a C model. It also includes an example of a Verilog module declaration for a chip that utilizes a scientific ALU.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p631.jpg,True,"The image contains a snippet of code from a chapter discussing how to interface C models using ACC routines. Here's the code from the image:

```c
acc_vcl_add(opcode_h, PLIbook_ScientificALU_interface,
            instance_p, vcl_verilog_logic);

acc_close();
return(0);
}
``` 

This code is likely a small part of a larger codebase, and it seems to be interfacing with hardware description using Verilog in the context of C programming.","cl_add(opcode_h, PLIbook_ScientificALU_interface,
            instance_p, vcl_verilog_logic);

acc_close();
return(0);
}
","""Extract from a textbook on interfacing Verilog with C models using ACC routines, discussing synchronization with future simulation time steps and memory allocation for C models.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p140.jpg,True,"The image contains a segment of a document discussing certain aspects of Verilog, specifically in the context of SystemVerilog assertions. There is a code snippet provided in the document:

```verilog
a1: assert property (@(posedge clk) !sig ##1 sig |=> sig[*4]);
```

The text also mentions that using an empty sequence in an assertion is illegal and provides an example:

```verilog
assert property (@(posedge clk) s[*0]);
```

Please note that, as the document mentions, this latter usage of an empty sequence is considered illegal in this context.","
a1: assert property (@(posedge clk) !sig ##1 sig |=> sig[*4]);


assert property (@(posedge clk) s[*0]);
","""Discussion of consecutive repetition and zero repetition in Verilog with an example assertion for signal high state.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p52.jpg,True,"Here is the Verilog code from the image:

```verilog
module top;
  reg [7:0] in1;
  wire [7:0] out1;
  bottom b1 (in1[7:4], out1[7:4]);
  bottom b2 (in2[3:0], out2[3:0]);
endmodule

module bottom (in, out);
  ...
endmodule
```

And another code snippet provided further down the image:

```verilog
module top;
  ...
  middle m1 (...); //module instance
  middle m2 (...); //module instance

  initial
    $my_app_1(in1, out1); //system task instance

  always @(posedge clock)
    $my_app_1(in2, out2); //system task instance
endmodule

module middle (...);
  ...
  bottom b1 (...); //module instance
  bottom b2 (...); //module instance
endmodule
```

The ellipses (...) in the code snippets indicate places where the code has been abbreviated or not specified.","
module top;
  reg [7:0] in1;
  wire [7:0] out1;
  bottom b1 (in1[7:4], out1[7:4]);
  bottom b2 (in2[3:0], out2[3:0]);
endmodule

module bottom (in, out);
  ...
endmodule


module top;
  ...
  middle m1 (...); //module instance
  middle m2 (...); //module instance

  initial
    $my_app_1(in1, out1); //system task instance

  always @(posedge clock)
    $my_app_1(in2, out2); //system task instance
endmodule

module middle (...);
  ...
  bottom b1 (...); //module instance
  bottom b2 (...); //module instance
endmodule
","Excerpt from ""The Verilog PLI Handbook"" showing Verilog code examples for module instantiation and system task usage.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p158.jpg,True,"The image contains excerpts of a text discussing SystemVerilog Assertions (SVA) and includes some Verilog code samples. Here are the code samples written in the image:

Sample 4.37 (Checking a signal with an if-statement):
```verilog
arbif.cb.request <= 2'b01;
repeat (2) @arbif.cb;
if (arbif.cb.grant != 2'b01)
    $display(""Error, grant != 2'b01"");
```

Sample 4.38 (Simple immediate assertion):
```verilog
arbif.cb.request <= 2'b01;
repeat (2) @arbif.cb;
a1: assert (arbif.cb.grant == 2'b01);
```

Sample 4.39 (Error from failed immediate assertion): This is not a code example but rather the output text when a test fails.
```
""test.sv"", 7: top.t1.a1: started at 55ns failed at 55ns
Offending ('arbif.cb.grant == 2'b1')
```","
arbif.cb.request <= 2'b01;
repeat (2) @arbif.cb;
if (arbif.cb.grant != 2'b01)
    $display(""Error, grant != 2'b01"");


arbif.cb.request <= 2'b01;
repeat (2) @arbif.cb;
a1: assert (arbif.cb.grant == 2'b01);

sv"", 7: top.t1.a1: started at 55ns failed at 55ns
Offending ('arbif.cb.grant == 2'b1')
","""Excerpt from a technical document discussing SystemVerilog Assertions (SVA) and the use of immediate assertions in testbenches.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p143.jpg,True,"The image contains a snippet of Verilog-related code in a C function. Here is the code:

```c
char *PLIbook_fetch_type_str_vpi(int type)
{
    switch (type) {
        case vpiNet          : return(""vpiNet"");
        case vpiNetBit       : return(""vpiNetBit"");
        case vpiReg          : return(""vpiReg"");
        case vpiRegBit       : return(""vpiRegBit"");
        case vpiPortSelect   : return(""vpiPortSelect"");
        case vpiTIntegerVar  : return(""vpiIntegerVar"");
        case vpiTimeVar      : return(""vpiTimeVar"");
        case vpiMemoryWord   : return(""vpiMemoryWord"");
        case vpiVarSelect    : return(""vpiVarSelect"");
        case vpiConstant     : return(""vpiConstant"");
        case vpiParameter    : return(""vpiParameter"");
        case vpiFuncCall     : return(""vpiFuncCall"");
        case vpiSysFuncCall  : return(""vpiSysFuncCall"");
        case vpiOperation    : return(""vpiOperation"");
        default              : return(""UNDEFINED TYPE"");
    }
}
```

This function takes an integer type and uses a switch statement to return a string that corresponds to a Verilog Programming Interface (VPI) object type. It's typical in simulation environments where Verilog is used to model and simulate hardware.","*PLIbook_fetch_type_str_vpi(int type)
{
    switch (type) {
        case vpiNet          : return(""vpiNet"");
        case vpiNetBit       : return(""vpiNetBit"");
        case vpiReg          : return(""vpiReg"");
        case vpiRegBit       : return(""vpiRegBit"");
        case vpiPortSelect   : return(""vpiPortSelect"");
        case vpiTIntegerVar  : return(""vpiIntegerVar"");
        case vpiTimeVar      : return(""vpiTimeVar"");
        case vpiMemoryWord   : return(""vpiMemoryWord"");
        case vpiVarSelect    : return(""vpiVarSelect"");
        case vpiConstant     : return(""vpiConstant"");
        case vpiParameter    : return(""vpiParameter"");
        case vpiFuncCall     : return(""vpiFuncCall"");
        case vpiSysFuncCall  : return(""vpiSysFuncCall"");
        case vpiOperation    : return(""vpiOperation"");
        default              : return(""UNDEFINED TYPE"");
    }
}
","""Verilog VPI Routine for Mapping Object Types to Strings""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p154.jpg,True,"The image contains examples of Verilog code. Below, I have transcribed the code from the image:

Example 7.2:
```verilog
a_mutex: assert final ($onehot0(bus_in));
```

Example 7.3:
```verilog
a_nowr: assert property (@(posedge clk) $onehot0({read, write}));
```

Alternative solution for Example 7.3:
```verilog
a_nowr_x: assert property (@(posedge clk) $countbits({read, write}, 1'b1, 1'bx, 1'b2) <= 1);
```

Example 7.4:
```verilog
a_onehot: assert property (@(posedge clk) disable iff (rst) $onehot(state));
```

These code snippets discuss the usage of `$onehot0` and `$onehot` system functions and assertions in Verilog for checking mutual exclusion and one-hot encoding in bit vectors.","
a_mutex: assert final ($onehot0(bus_in));


a_nowr: assert property (@(posedge clk) $onehot0({read, write}));


a_nowr_x: assert property (@(posedge clk) $countbits({read, write}, 1'b1, 1'bx, 1'b2) <= 1);


a_onehot: assert property (@(posedge clk) disable iff (rst) $onehot(state));
","""Verilog code examples demonstrating the use of the SystemVerilog `onehot0` and `onehot` functions for mutual exclusion and one-hot encoding checking.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p625.jpg,True,"```c
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */

#define ALU_CLOCK 1 /* system task arg 1 is ALU clock input */
#define ALU_A 2 /* system task arg 2 is ALU A input */
#define ALU_B 3 /* system task arg 3 is ALU B input */
#define ALU_OP 4 /* system task arg 4 is ALU opcode input */
#define ALU_RESULT 5 /* system task arg 5 is ALU result output */
#define ALU_EXCEPT 6 /* system task arg 6 is ALU exception output */
#define ALU_ERRORP 7 /* system task arg 7 is ALU error output */

/******************************************************************
 * Definition for a structure to hold the data to be passed from
 * a callout routine to the ALU interface (a VCL consumer routine).
 ******************************************************************/
typedef struct PLIbook_SciALU_data {
  handle clock_h, a_h, b_h, opcode_h, result_h, excep_h, err_h;
} PLIbook_SciALU_data_s, *PLIbook_SciALU_data_p;

/******************************************************************
 * VCL simulation callback routine: Serves as an interface between
 * Verilog simulation and the C model. Called whenever the C model
 * clock input changes value, reads the values of all model inputs,
 * passes the values to the C model, and writes the C model outputs
 * into simulation.
 ******************************************************************/
int PLIbook_ScientificALU_interface (p_vc_record vc_record)
{
  double a, b, result;
  int opcode, excep, err;
  s_setval_value value_s;
  s_setval_delay delay_s;
  s_acc_time time_s;

  PLIbook_SciALU_data_p ALUdata;

  acc_initialize();

  /* Retrieve pointer to ALU data structure from VCL user_data field */
  ALUdata = (PLIbook_SciALU_data_p)vc_record->user_data;
``` 

Please note that the text is cut off and this code snippet may be incomplete or continued on the next page not visible in the image.","ude ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */

#define ALU_CLOCK 1 /* system task arg 1 is ALU clock input */
#define ALU_A 2 /* system task arg 2 is ALU A input */
#define ALU_B 3 /* system task arg 3 is ALU B input */
#define ALU_OP 4 /* system task arg 4 is ALU opcode input */
#define ALU_RESULT 5 /* system task arg 5 is ALU result output */
#define ALU_EXCEPT 6 /* system task arg 6 is ALU exception output */
#define ALU_ERRORP 7 /* system task arg 7 is ALU error output */

/******************************************************************
 * Definition for a structure to hold the data to be passed from
 * a callout routine to the ALU interface (a VCL consumer routine).
 ******************************************************************/
typedef struct PLIbook_SciALU_data {
  handle clock_h, a_h, b_h, opcode_h, result_h, excep_h, err_h;
} PLIbook_SciALU_data_s, *PLIbook_SciALU_data_p;

/******************************************************************
 * VCL simulation callback routine: Serves as an interface between
 * Verilog simulation and the C model. Called whenever the C model
 * clock input changes value, reads the values of all model inputs,
 * passes the values to the C model, and writes the C model outputs
 * into simulation.
 ******************************************************************/
int PLIbook_ScientificALU_interface (p_vc_record vc_record)
{
  double a, b, result;
  int opcode, excep, err;
  s_setval_value value_s;
  s_setval_delay delay_s;
  s_acc_time time_s;

  PLIbook_SciALU_data_p ALUdata;

  acc_initialize();

  /* Retrieve pointer to ALU data structure from VCL user_data field */
  ALUdata = (PLIbook_SciALU_data_p)vc_record->user_data;
","""Verilog code example illustrating the interfacing to C models using ACC (Application Compiler Constructs) routines""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p290.jpg,True,"The image contains Verilog code, specifically for SystemVerilog sequences and properties. Here is the code written in the image:

```verilog
@(posedge clk)
$fell(framen) ##1 $fell(devseln);
endsequence

sequence s_tchk9_medium;
@(posedge clk)
$fell(framen) ##2 $fell(devseln);
endsequence

sequence s_tchk9_slow;
@(posedge clk)
$fell(framen) ##3 $fell(devseln);
endsequence

sequence s_tchk9_subtractive;
@(posedge clk)
$fell(framen) ##4 $fell(devseln);
endsequence

property p_tchk9_fast;
@(posedge clk)
s_tchk9_fast |-> ##[0:15]
(!devseln) throughout
(s_tchk9a.ended || s_tchk9b.ended);
endproperty

a_tchk9_fast: assert property(p_tchk9_fast);
c_tchk9_fast: cover property(p_tchk9_fast);

property p_tchk9_medium;
@(posedge clk)
s_tchk9_medium |-> ##[0:14]
(!devseln) throughout
(s_tchk9a.ended || s_tchk9b.ended);
endproperty

a_tchk9_medium: assert property(p_tchk9_medium);
c_tchk9_medium: cover property(p_tchk9_medium);

property p_tchk9_slow;
@(posedge clk)
s_tchk9_slow |-> ##[0:13]
(!devseln) throughout
(s_tchk9a.ended || s_tchk9b.ended);
```

Note: The code seems to define temporal assertions in a hardware verification context, used to check signal transitions and timing relations in a digital system. `@(posedge clk)` indicates that these are checked at the rising edge of a clock signal. The `$fell(...)` built-in SystemVerilog function is used to detect falling edges of signals.","
@(posedge clk)
$fell(framen) ##1 $fell(devseln);
endsequence

sequence s_tchk9_medium;
@(posedge clk)
$fell(framen) ##2 $fell(devseln);
endsequence

sequence s_tchk9_slow;
@(posedge clk)
$fell(framen) ##3 $fell(devseln);
endsequence

sequence s_tchk9_subtractive;
@(posedge clk)
$fell(framen) ##4 $fell(devseln);
endsequence

property p_tchk9_fast;
@(posedge clk)
s_tchk9_fast |-> ##[0:15]
(!devseln) throughout
(s_tchk9a.ended || s_tchk9b.ended);
endproperty

a_tchk9_fast: assert property(p_tchk9_fast);
c_tchk9_fast: cover property(p_tchk9_fast);

property p_tchk9_medium;
@(posedge clk)
s_tchk9_medium |-> ##[0:14]
(!devseln) throughout
(s_tchk9a.ended || s_tchk9b.ended);
endproperty

a_tchk9_medium: assert property(p_tchk9_medium);
c_tchk9_medium: cover property(p_tchk9_medium);

property p_tchk9_slow;
@(posedge clk)
s_tchk9_slow |-> ##[0:13]
(!devseln) throughout
(s_tchk9a.ended || s_tchk9b.ended);
","Caption: ""Verilog code excerpt showcasing SystemVerilog assertions and sequences for clock timing checks.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p491.jpg,True,"```
covergroup gc @(posedge clk);
  ac: coverpoint adr1
  {
    wildcard bins ainc = { 4'b 11?? };
    wildcard bins adrb1[ ] = { 2'b0x => 2'b1x};
    wildcard bins adrb2 = { 2'b0x => 2'b1x};
  }
endgroup
gc gcInst = new();
```","roup gc @(posedge clk);
  ac: coverpoint adr1
  {
    wildcard bins ainc = { 4'b 11?? };
    wildcard bins adrb1[ ] = { 2'b0x => 2'b1x};
    wildcard bins adrb2 = { 2'b0x => 2'b1x};
  }
endgroup
gc gcInst = new();
","""Understanding wildcard bins in Verilog code for functional coverage.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p209.jpg,True,"```
module dff (q, d, ck);
  output [7:0] q;
  input [7:0] d;
  input ck;
  always @(posedge ck)
    q <= d;
  //rtl_synthesis off
  initial
    q = 8'h00;
  //rtl_synthesis on
endmodule //dff
```"," dff (q, d, ck);
  output [7:0] q;
  input [7:0] d;
  input ck;
  always @(posedge ck)
    q <= d;
  //rtl_synthesis off
  initial
    q = 8'h00;
  //rtl_synthesis on
endmodule //dff
","Caption: ""Example of a Verilog module for a flip-flop with initial block placement criticized for invalidating later initialization testing with RTL simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p284.jpg,True,"```verilog
sequence s_tchk6a;
    @(posedge clk)
    (!irdyn && !trdyn && !devseln && !framen);
endsequence

sequence s_tchk6b;
    @(posedge clk)
    ($fell (stopn) && $rose (trdyn) && !framen);
endsequence

sequence s_tchk6c;
    @(posedge clk)
    $rose (framen) ##[0:8] (!irdyn && !stopn);
endsequence

sequence s_tchk6;
```","
sequence s_tchk6a;
    @(posedge clk)
    (!irdyn && !trdyn && !devseln && !framen);
endsequence

sequence s_tchk6b;
    @(posedge clk)
    ($fell (stopn) && $rose (trdyn) && !framen);
endsequence

sequence s_tchk6c;
    @(posedge clk)
    $rose (framen) ##[0:8] (!irdyn && !stopn);
endsequence

sequence s_tchk6;
","""Example of Verilog sequences for PCI protocol validation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p366.jpg,True,"The image contains text that describes various temporal logic operators typically used in formal verification of hardware designs, particularly when dealing with temporal properties in Verilog or SystemVerilog Assertions (SVA). The operators look like pseudocode or a syntax specification, and they are not executable code. However, they represent the concept of how to express properties in a property specification language. The operators include logical, primitive Linear Temporal Logic (LTL) operators, simple temporal operators, and extended next (event) operators. Here is the text representation:

```
| NOT_OP FL_Property
| FL_Property AND_OP FL_Property
| FL_Property OR_OP FL_Property
:
| FL_Property -> FL_Property
| FL_Property <-> FL_Property
: Primitive LTL Operators :
| X FL_Property
| X! FL_Property
| F FL_Property
| G FL_Property
| [ FL_Property U FL_Property ]
| [ FL_Property W FL_Property ]
: Simple Temporal Operators:
| always FL_Property
| never FL_Property
| next FL_Property
| next! FL_Property
| eventually! FL_Property
:
| FL_Property until! FL_Property
| FL_Property until FL_Property
| FL_Property until!_ FL_Property
| FL_Property until_ FL_Property
:
| FL_Property before! FL_Property
| FL_Property before FL_Property
| FL_Property before!_ FL_Property
| FL_Property before_ FL_Property
: Extended Next (Event) Operators :(see B.8.3.7)
| X[ Number | ( FL_Property ) ]
| X![ Number | ( FL_Property ) ]
| next [ Number | ( FL_Property ) ]
| next![ Number | ( FL_Property ) ]
:(see B.8.3.5)
| next_a [finite_Range ] ( FL_Property )
| next_a! [finite_Range ] ( FL_Property )
| next_e [finite_Range ] ( FL_Property )
| next_e! [finite_Range ] ( FL_Property )
:
| next_event! ( Boolean ) ( FL_Property )
| next_event ( Boolean ) ( FL_Property )
| next_event! (Boolean) [positive_Number] ( FL_Property )
| next_event ( Boolean ) [positive_Number] ( FL_Property )
```

Note that this is a high-level description of syntax and not actual Verilog or SystemVerilog code. Each operator is used to specify how certain conditions or sequences of events should behave over time concerning a hardware design's simulation or formal verification process.","OP FL_Property
| FL_Property AND_OP FL_Property
| FL_Property OR_OP FL_Property
:
| FL_Property -> FL_Property
| FL_Property <-> FL_Property
: Primitive LTL Operators :
| X FL_Property
| X! FL_Property
| F FL_Property
| G FL_Property
| [ FL_Property U FL_Property ]
| [ FL_Property W FL_Property ]
: Simple Temporal Operators:
| always FL_Property
| never FL_Property
| next FL_Property
| next! FL_Property
| eventually! FL_Property
:
| FL_Property until! FL_Property
| FL_Property until FL_Property
| FL_Property until!_ FL_Property
| FL_Property until_ FL_Property
:
| FL_Property before! FL_Property
| FL_Property before FL_Property
| FL_Property before!_ FL_Property
| FL_Property before_ FL_Property
: Extended Next (Event) Operators :(see B.8.3.7)
| X[ Number | ( FL_Property ) ]
| X![ Number | ( FL_Property ) ]
| next [ Number | ( FL_Property ) ]
| next![ Number | ( FL_Property ) ]
:(see B.8.3.5)
| next_a [finite_Range ] ( FL_Property )
| next_a! [finite_Range ] ( FL_Property )
| next_e [finite_Range ] ( FL_Property )
| next_e! [finite_Range ] ( FL_Property )
:
| next_event! ( Boolean ) ( FL_Property )
| next_event ( Boolean ) ( FL_Property )
| next_event! (Boolean) [positive_Number] ( FL_Property )
| next_event ( Boolean ) [positive_Number] ( FL_Property )
","""List of temporal operators in Verilog for assertion-based design""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p221.jpg,True,"The image contains a snippet of a document discussing the use of tool-directing comments in Verilog code, which are vendor-specific properties used in the design process. There is no complete block of Verilog code, but there are lines that represent comments in Verilog code used to control certain tool behaviors during the design process. Here are the lines that mimic Verilog comments from the document:

```
// rtl_synthesis off
// Diagnostic non-hardware Verilog code
// rtl_synthesis on

// <vendor-name> coverage off
// Diagnostic non-hardware Verilog code
// <vendor-name> coverage on
```

And a template for creating standardized tool-directing comments:

```
// rtl_<application-name> <application-keyword>
```

Where `<application-name>` is a placeholder for a generic name of an application, such as `coverage` or `synthesis`.","_synthesis off
// Diagnostic non-hardware Verilog code
// rtl_synthesis on

// <vendor-name> coverage off
// Diagnostic non-hardware Verilog code
// <vendor-name> coverage on

_<application-name> <application-keyword>
","""Examining Vendor-Specific Commenting Practices in Verilog Code""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p91.jpg,True,"There is code in the image. Here is the code provided in the image:

```c
#include <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard input/output library */
#include ""vpi_user.h""   /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h""   /* IEEE 1364 PLI TF routine library */
/* using TF routines for simulation control */

/* prototypes of the PLI application routines */
int PLIbook_ShowNets_compiletf(), PLIbook_ShowNets_calltf();
```","ude <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard input/output library */
#include ""vpi_user.h""   /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h""   /* IEEE 1364 PLI TF routine library */
/* using TF routines for simulation control */

/* prototypes of the PLI application routines */
int PLIbook_ShowNets_compiletf(), PLIbook_ShowNets_calltf();
","""Documentation on creating a complete PLI application using VPI routines in Verilog, with a focus on the `$show_all_nets` example.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p183.jpg,True,"The image contains Verilog code examples. Here is the code from the image:

First code block (Example 8.2):
```verilog
let orReduct(x) = |x;
module m;
  logic [2:0] sel;
  logic [7:0] [1:0] data;
  logic a, b, v, w;
  assign v = a && orReduct(sel);
  assign w = orReduct(data);
  //...
endmodule
```

After substitution, the code takes the following form:
```verilog
module m;
  logic [2:0] sel;
  logic [7:0] [1:0] data;
  logic a, b, v, w;
  assign v = a && (|sel);
  assign w = (|data);
  //...
endmodule
```

Second code block (Example 8.3):
```verilog
module m;
  logic [2:0] sel;
  logic [7:0] [1:0] data;
  logic a, b, v, w;
  let orReduct(x = sel) = |x;
  assign v = a && orReduct();
```

This code is demonstrating the use of ""let"" constructs within Verilog for defining functions or expressions, and how it behaves with and without providing actual argument expressions.","
let orReduct(x) = |x;
module m;
  logic [2:0] sel;
  logic [7:0] [1:0] data;
  logic a, b, v, w;
  assign v = a && orReduct(sel);
  assign w = orReduct(data);
  //...
endmodule


module m;
  logic [2:0] sel;
  logic [7:0] [1:0] data;
  logic a, b, v, w;
  assign v = a && (|sel);
  assign w = (|data);
  //...
endmodule


module m;
  logic [2:0] sel;
  logic [7:0] [1:0] data;
  logic a, b, v, w;
  let orReduct(x = sel) = |x;
  assign v = a && orReduct();
","Caption: ""Verilog code examples depicting the use of untyped formal arguments with the 'let' construct and the resulting code after substitution.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p194.jpg,True,"There is a snippet of code pertaining to flag values:

```
mtm_flag = 1
pulse_flag = 1
```

And also a snippet of an expression involving array indexing:

```
no_of_delay * 9
```

These lines appear to be written in a C-like syntax, likely representing variables used in a context related to Verilog or within a C program interfacing with Verilog through PLI (Programming Language Interface).","ag = 1
pulse_flag = 1

delay * 9
","""Verilog Programming Language Interface (PLI) Reference Guide Showing Steps for Reading Delay Values and a Table of Delay Array Elements""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p197.jpg,True,"The image contains Verilog code snippets related to properties, assertions, and clocking in a module. Here are the code segments visible in the image:

```verilog
a_imply: assert property(
    disable iff (!reset)
    @(posedge clock) !d ##1 d |-> a |-> b until c);
```

```verilog
module m;
    bit clock, reset, a, b, c, d;
    default clocking @(posedge clock); endclocking
    ...
    property p1(event clk = $inferred_clock, bit x, property p);
        @clk !x ##1 x |-> p;
    endproperty
    property p2;
        disable iff (reset) a |-> (b until c);
    endproperty
    a_illegal: assert property(p1(.x(d), .p(p2())));
    ...
endmodule
```

```verilog
a_illegal: assert property( @(posedge clk) !d ##1 d |->
    disable iff (!reset) (a |-> (b until c)) );
```

The code examples depict how to use `disable iff` within property specifications and assertions, and the text discusses the correct usage and potential issues that can arise if not used properly. The specific context is related to SystemVerilog, a hardware description and verification language used to model, design, and verify electronic systems.","
a_imply: assert property(
    disable iff (!reset)
    @(posedge clock) !d ##1 d |-> a |-> b until c);


module m;
    bit clock, reset, a, b, c, d;
    default clocking @(posedge clock); endclocking
    ...
    property p1(event clk = $inferred_clock, bit x, property p);
        @clk !x ##1 x |-> p;
    endproperty
    property p2;
        disable iff (reset) a |-> (b until c);
    endproperty
    a_illegal: assert property(p1(.x(d), .p(p2())));
    ...
endmodule


a_illegal: assert property( @(posedge clk) !d ##1 d |->
    disable iff (!reset) (a |-> (b until c)) );
","Caption: ""Discussion and examples of proper usage of 'disable iff' in Verilog Assertions (SVA).""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p235.jpg,True,"```verilog
assign o [7:0] = i[7:0] | j[7:0];

assign o [7] = i[7] | j[7];
assign o [6] = i[6] | j[6];
assign o [5] = i[5] | j[5];
assign o [4] = i[4] | j[4];
assign o [3] = i[3] | j[3];
assign o [2] = i[2] | j[2];
assign o [1] = i[1] | j[1];
assign o [0] = i[0] | j[0];

module b_c(o, i, j);
    parameter w = 1;  // 1 is the default value
    input [w-1:0] i;
    output [w-1:0] o;
    wire [w-1:0] o;
    assign o = i | j;
endmodule // b_c

b_c #8 (c, r, w, x); // 8-bit instantiation of b_c

mem #(32,8,5) c1 (...); // ""5"" is the address register width
```
These are the code snippets present in the image, which pertain to Verilog, a hardware description language used to model electronic systems.","
assign o [7:0] = i[7:0] | j[7:0];

assign o [7] = i[7] | j[7];
assign o [6] = i[6] | j[6];
assign o [5] = i[5] | j[5];
assign o [4] = i[4] | j[4];
assign o [3] = i[3] | j[3];
assign o [2] = i[2] | j[2];
assign o [1] = i[1] | j[1];
assign o [0] = i[0] | j[0];

module b_c(o, i, j);
    parameter w = 1;  // 1 is the default value
    input [w-1:0] i;
    output [w-1:0] o;
    wire [w-1:0] o;
    assign o = i | j;
endmodule // b_c

b_c #8 (c, r, w, x); // 8-bit instantiation of b_c

mem #(32,8,5) c1 (...); // ""5"" is the address register width
","""Explanation of bit-wise assignment and parameterization in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p85.jpg,True,"The image contains descriptions and sample code fragments related to the Verilog Programming Interface (VPI). Here are the code fragments found in the image:

1.
```c
int vpi_get(property, object)
int property;
vpiHandle object;
```

This function returns the value associated with integer and boolean properties of an object.

2.
```c
char *vpi_get_str(property, object)
int property;
vpiHandle object;
```

This function returns a pointer to a string containing the value associated with string properties of an object.

3.
```c
int obj_type;
obj_type = vpi_get(vpiType, <object_handle>)
```

This snippet shows how to use `vpi_get` to obtain the `type` property of a Verilog object. The `vpiType` and `<object_handle>` are placeholders where the former is a constant representing the type property and the latter is the handle to the Verilog object.","pi_get(property, object)
int property;
vpiHandle object;

*vpi_get_str(property, object)
int property;
vpiHandle object;

bj_type;
obj_type = vpi_get(vpiType, <object_handle>)
","""Verilog VPI Routines Documentation on Accessing Object Properties""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p779.jpg,True,"This image contains text describing part of the IEEE 1364-1995 ACC Routine Library, specifically two functions `acc_vcl_delete` and `acc_version`. While this is related to Verilog and programming, there are no code blocks or source code examples present. The text merely explains the function prototypes and their usage, which are part of the Verilog programming language ACC library documentation.

Here are the function prototypes as shown in the image:

```c
void acc_vcl_delete(handle object, int *consumer, char *user_data, int vcl_flag);

char *acc_version();
```

The description for `acc_vcl_delete` indicates that it removes a value change link monitor on an object, and it takes parameters such as a handle for the object, a pointer to a consumer, a user-defined data value, and a VCL flag. The `acc_version` function returns a pointer to a character string with the version of ACC routines.","acc_vcl_delete(handle object, int *consumer, char *user_data, int vcl_flag);

char *acc_version();
","""Excerpt from the IEEE 1364-1995 ACC Routine Library documentation detailing functions for interacting with Verilog simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p327.jpg,True,"The image contains code written in the context of Verilog or SystemVerilog properties. Here is the code extracted from the image:

```verilog
// on a given clock edge the leading signal has a 
// rising edge and after ""start_wait"" cycles, the 
// trailing signal is high ""repetition"" times

property p7_c_rpt_rh;
@(posedge clk)
$rose(a) ##start_wait b[*repetition];
endproperty

// on a given clock edge the leading signal has a 
// rising edge and after ""start_wait"" cycles, the 
// trailing signal is low ""repetition"" times

property p7_c_rpt_rl;
@(posedge clk)
$rose(a) ##start_wait !b[*repetition];
endproperty

// on a given clock edge the leading signal has a 
// falling edge and after ""start_wait"" cycles, the 
// trailing signal is high ""repetition"" times

property p7_c_rpt_fh;
@(posedge clk)
$fell(a) ##start_wait b[*repetition];
endproperty
```

These properties are presumably used for formal verification or assertions within a simulation environment to ensure that the signal behavior conforms to specifications. Each property checks for a specific condition regarding the leading (`a`) and trailing (`b`) signals after a given clock edge, with a waiting period (`start_wait`) and a specified number of repetition cycles (`repetition`).","
// on a given clock edge the leading signal has a 
// rising edge and after ""start_wait"" cycles, the 
// trailing signal is high ""repetition"" times

property p7_c_rpt_rh;
@(posedge clk)
$rose(a) ##start_wait b[*repetition];
endproperty

// on a given clock edge the leading signal has a 
// rising edge and after ""start_wait"" cycles, the 
// trailing signal is low ""repetition"" times

property p7_c_rpt_rl;
@(posedge clk)
$rose(a) ##start_wait !b[*repetition];
endproperty

// on a given clock edge the leading signal has a 
// falling edge and after ""start_wait"" cycles, the 
// trailing signal is high ""repetition"" times

property p7_c_rpt_fh;
@(posedge clk)
$fell(a) ##start_wait b[*repetition];
endproperty
","Caption: ""Verilog code examples for property declarations in SystemVerilog, demonstrating repetition properties based on signal edges and states.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p240.jpg,True,"The image contains the following Verilog code:

```
sequence aRb(aFell,bRose);
    @(posedge clk) $fell(aFell) ##1 $rose(bRose);
endsequence

property endCycle;
    @(posedge clk1) $rose(c) |=> @(posedge clk) aRb(a,b).matched;
endproperty
base: assert property (endCycle) else gotoFail;
```

This Verilog code appears to be defining a sequence named `aRb` and a property named `endCycle`, used in assertion-based verification within the context of hardware design using SystemVerilog.","ce aRb(aFell,bRose);
    @(posedge clk) $fell(aFell) ##1 $rose(bRose);
endsequence

property endCycle;
    @(posedge clk1) $rose(c) |=> @(posedge clk) aRb(a,b).matched;
endproperty
base: assert property (endCycle) else gotoFail;
","""Understanding non-overlapping implication in Verilog assertions with a timing diagram example.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p333.jpg,True,"The image contains Verilog code. Here is the code as it appears in the image:

```verilog
`include ""config.v""

input logic a, b, clk;

// List definitions of all properties under test

// code to selectively include assertions

always@(posedge clk)
begin

// logical relationship between two level
// sensitive signals

if(logic_op == 1 && timing == 0 && sig_edge == 0)
begin
    a_1_hh : assert property(p_1_hh);
    a_1_hl : assert property(p_1_hl);
    a_1_lh : assert property(p_1_lh);
    a_1_ll : assert property(p_1_ll);
end

// logical relationship between two edge
// sensitive signals FF,FR

if(logic_op == 1 && timing == 0 && sig_edge == 1
&& sig1_edge == 0)
begin
    a2_ff : assert property(p2_ff);
    a2_fr : assert property(p2_fr);
end

// logical relationship between 2 edge sensitive
// signals RF,RR

if(logic_op == 1 && timing == 0 && sig_edge == 1
&& sig1_edge == 1)
begin
    a2_rf : assert property(p2_rf);
    a2_rr : assert property(p2_rr);
end

// timing relationship between 2 level sensitive
```

Please note that the code snippet appears to be incomplete as it cuts off at the bottom of the page.","
`include ""config.v""

input logic a, b, clk;

// List definitions of all properties under test

// code to selectively include assertions

always@(posedge clk)
begin

// logical relationship between two level
// sensitive signals

if(logic_op == 1 && timing == 0 && sig_edge == 0)
begin
    a_1_hh : assert property(p_1_hh);
    a_1_hl : assert property(p_1_hl);
    a_1_lh : assert property(p_1_lh);
    a_1_ll : assert property(p_1_ll);
end

// logical relationship between two edge
// sensitive signals FF,FR

if(logic_op == 1 && timing == 0 && sig_edge == 1
&& sig1_edge == 0)
begin
    a2_ff : assert property(p2_ff);
    a2_fr : assert property(p2_fr);
end

// logical relationship between 2 edge sensitive
// signals RF,RR

if(logic_op == 1 && timing == 0 && sig_edge == 1
&& sig1_edge == 1)
begin
    a2_rf : assert property(p2_rf);
    a2_rr : assert property(p2_rr);
end

// timing relationship between 2 level sensitive
","""Verilog code showcasing conditional assertions based on logic and timing relationships in a digital system""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p268.jpg,True,"Here is the Verilog code from the image:

```verilog
always @(posedge clk) begin
    for (i=0; i<10; i++) begin
        a1: assertproperty (req[const'(i)] && ack[const'(i)])
        else
            $error (""Assertion a1 FAIL: Index i = %0d"", const'(i)); //Action Block
    end
end
```","
always @(posedge clk) begin
    for (i=0; i<10; i++) begin
        a1: assertproperty (req[const'(i)] && ack[const'(i)])
        else
            $error (""Assertion a1 FAIL: Index i = %0d"", const'(i)); //Action Block
    end
end
","Caption: ""An excerpt from a document explaining the use of constant casting in Verilog assertions and action blocks within an 'always' block utilizing a for loop.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p297.jpg,True,"The image contains Verilog code, which defines a module for testing an asynchronous FIFO. Here is the code from the image:

```verilog
module test_asynchronous_fifo
(
    fifo_out, full, empty,
    wclk, wclk_reset_n, write_en,
    rclk, rclk_reset_n, read_en,
    fifo_in
);

parameter D_WIDTH = 20;
parameter D_DEPTH = 4;
parameter A_WIDTH = 2;

output wclk_reset_n;
output rclk_reset_n;
output wclk;
output rclk;
output write_en;
output read_en;

output [D_WIDTH-1:0] fifo_in;

logic wclk_reset_n;
logic rclk_reset_n;
logic wclk;
logic rclk;
logic write_en;
logic read_en;
logic [D_WIDTH-1:0] fifo_in;

input [D_WIDTH-1:0] fifo_out;
input full;
input empty;

asynchronous_fifo aff1
(
    fifo_out, full, empty,
    wclk, wclk_reset_n, write_en,
    rclk, rclk_reset_n, read_en,
    fifo_in
);
/*
```

The text at the bottom of the image is cut off, so I have only provided the part of the code that is completely visible. The module `test_asynchronous_fifo` is apparently used to instantiate and test an asynchronous FIFO named `aff1`, using various parameters and input/output signals.","
module test_asynchronous_fifo
(
    fifo_out, full, empty,
    wclk, wclk_reset_n, write_en,
    rclk, rclk_reset_n, read_en,
    fifo_in
);

parameter D_WIDTH = 20;
parameter D_DEPTH = 4;
parameter A_WIDTH = 2;

output wclk_reset_n;
output rclk_reset_n;
output wclk;
output rclk;
output write_en;
output read_en;

output [D_WIDTH-1:0] fifo_in;

logic wclk_reset_n;
logic rclk_reset_n;
logic wclk;
logic rclk;
logic write_en;
logic read_en;
logic [D_WIDTH-1:0] fifo_in;

input [D_WIDTH-1:0] fifo_out;
input full;
input empty;

asynchronous_fifo aff1
(
    fifo_out, full, empty,
    wclk, wclk_reset_n, write_en,
    rclk, rclk_reset_n, read_en,
    fifo_in
);
/*
","The image displays the beginning of a Verilog test bench for an asynchronous FIFO (First-In-First-Out) queue, including the declaration of module parameters, inputs, and outputs.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p206.jpg,True,"The image contains text discussing the ""Future event pattern"" used in system verification within Verilog, and it includes a snippet of code. Below is the Verilog code extracted from the image:

```verilog
// declarative assertion
// assert req_valid will never be active high for more than 1 cycle

assert always (req_valid -> next !req_valid) @(posedge clk)
  abort !reset_n;
``` 

This code is part of the example 6-27 which showcases a PSL (Property Specification Language) future event pattern check for a single cycle pulse.","
// declarative assertion
// assert req_valid will never be active high for more than 1 cycle

assert always (req_valid -> next !req_valid) @(posedge clk)
  abort !reset_n;
","""Understanding the Future Event Pattern in Verilog for Protocol Validation""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p222.jpg,True,"The image contains Verilog/SystemVerilog code as follows:

```verilog
logic [7:0] data;          // 8-bit vector

data = {4'hF, bus};        // concatenate values into a vector

int data [4];              // array of 4 integers

data = '{0, 1, 2, 3};      // list of separate values

typedef struct {
    int a, b;
    logic [3:0] opcode;
    instruction_word;
} instruction_word;

instruction_word = '{7, 5, 3}; // list of separate values
```

These code snippets demonstrate the difference between concatenation and array/structure literals in Verilog/SystemVerilog.","
logic [7:0] data;          // 8-bit vector

data = {4'hF, bus};        // concatenate values into a vector

int data [4];              // array of 4 integers

data = '{0, 1, 2, 3};      // list of separate values

typedef struct {
    int a, b;
    logic [3:0] opcode;
    instruction_word;
} instruction_word;

instruction_word = '{7, 5, 3}; // list of separate values
","""Explaining the difference between array literals and concatenations in Verilog and SystemVerilog with code examples""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p134.jpg,True,"```verilog
reg[7:0] Buf8;
reg[7:0] MemByte[3:0][1023:0]; // 2-D (call byte 3 the high-order byte).
reg[31:0] MemWord[1023:0]; // 1-D.
integer i, j;
...
i = 3;
Buf8 < = MemByte[i][j]; // High-order byte (3,i) stored in Buf8.
Buf8 < = MemByte[j][i]; // Low-order byte stored.
Buf8 < = MemByteWord[j][31:24]; // Part-select; high-order byte stored.
Buf8 < = MemByteWord[i][(j*8) +: (i-1)*8]; // ILLEGAL! i is a variable!.
...
```

Please note that the code contains a typo: `Buf8 < =` should be `Buf8 <=` (getting rid of the space between `<` and `=`). The correct context-sensitive token for non-blocking assignment in Verilog is `<=`. Additionally, there is an incorrect identifier: `MemByteWord` should be `MemWord` to match the declared variable.","
reg[7:0] Buf8;
reg[7:0] MemByte[3:0][1023:0]; // 2-D (call byte 3 the high-order byte).
reg[31:0] MemWord[1023:0]; // 1-D.
integer i, j;
...
i = 3;
Buf8 < = MemByte[i][j]; // High-order byte (3,i) stored in Buf8.
Buf8 < = MemByte[j][i]; // Low-order byte stored.
Buf8 < = MemByteWord[j][31:24]; // Part-select; high-order byte stored.
Buf8 < = MemByteWord[i][(j*8) +: (i-1)*8]; // ILLEGAL! i is a variable!.
...
","Caption: ""Verilog memory access limitations and multidimensional array examples in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p120.jpg,True,"```
`timescale 1ns/100ps
`define HalfPeriod32BitBus 500.0 // ns half-period at 1 MHz.
`define VFOBaseDelay `HalfPeriod32BitBus/32.0 // At 32 MHz.
`define VFO_DelayDelta 1 // ns.
`define VFO_MaxDelta 2 // ns.
```

The image contains Verilog code in the form of macro definitions, setting up basic timing parameters for a simulation environment.","cale 1ns/100ps
`define HalfPeriod32BitBus 500.0 // ns half-period at 1 MHz.
`define VFOBaseDelay `HalfPeriod32BitBus/32.0 // At 32 MHz.
`define VFO_DelayDelta 1 // ns.
`define VFO_MaxDelta 2 // ns.
","""Excerpt from a digital VLSI design textbook discussing the use of macros in Verilog for frequency control in a PLL design, along with an example of code defining time units and constants.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p212.jpg,True,"The image contains two pieces of code. One is an example of a PSL (Property Specification Language) assertion, and the other is an example of a SystemVerilog assertion using the same principle. Here are the code excerpts:

PSL example (Example 6-37):
```verilog
// declarative assertion
// a new request cannot start before the first one completes
assert always (req->next:!req until_ack) @ (posedge clk);
```

SystemVerilog example (Example 6-38):
```verilog
// declarative assertion
// a new request cannot start before the first one completes
assert property (@ (posedge clk) disable iff (reset_n)
    (req |=> (!req throughout ack [->1])));
```","
// declarative assertion
// a new request cannot start before the first one completes
assert always (req->next:!req until_ack) @ (posedge clk);


// declarative assertion
// a new request cannot start before the first one completes
assert property (@ (posedge clk) disable iff (reset_n)
    (req |=> (!req throughout ack [->1])));
","Caption: ""Verilog and PSL code examples for asserting event-bounded window patterns in hardware design verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p283.jpg,True,"The image contains Verilog code within the text as part of a discussion on cyclic dependency in SystemVerilog Assertions (SVA). Here is the Verilog code from the image:

```verilog
sequence s1;
    @(posedge clk) a ##1 b ##1 s2;
endsequence

sequence s2;
    @(posedge clk) c ##1 d ##1 s1;
endsequence

property p1;
    @(posedge clk) a |=> p2;
endproperty

property p2;
    @(posedge clk) c |=> p1;
endproperty

p2c: assert property (p2);
```

This code defines two cyclic dependencies: one illegal dependency between two sequences `s1` and `s2`, and one legal dependency between two properties `p1` and `p2`. The assertion `p2c` checks the property `p2` through an assert statement.","
sequence s1;
    @(posedge clk) a ##1 b ##1 s2;
endsequence

sequence s2;
    @(posedge clk) c ##1 d ##1 s1;
endsequence

property p1;
    @(posedge clk) a |=> p2;
endproperty

property p2;
    @(posedge clk) c |=> p1;
endproperty

p2c: assert property (p2);
",Analyzing Verilog Code and Explaining Cyclic Dependency Rules in SystemVerilog Assertions (SVAs),True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p108.jpg,True,"The image contains Verilog code, which appears to be part of a digital VLSI design text discussing a voltage-controlled oscillator (VFO). Here is the code from the image:

```verilog
module VFO (output ClockOut, input[1:0] AdjustFreq, input Reset);
    reg     PLLClock;
    real    VFO_Delay;
    assign  ClockOut = PLLClock;
    //
    always@(PLLClock, Reset)
    if (Reset=='b1)
    begin
        VFO_Delay = 'VFOBaseDelay;
        PLLClock    = '1'b0;
    end
    else begin
        case (AdjustFreq)
        2'b11: VFO_Delay = VFO_Delay - 'VFO_Delta;
        2'b00: VFO_Delay = VFO_Delay + 'VFO_Delta;
        // Otherwise, leave VFO_Delay alone.
        endcase
        #VFO_Delay PLLClock <= ~PLLClock; // The oscillator.
    end
endmodule // VFO.
```

The code is intended to simulate the behavior of a VFO, and it contains comments that explain certain parts, such as the use of blocking and nonblocking assignments. Note that some syntax (like `'VFOBaseDelay`; `'1'b0` or `'VFO_Delta`) appears to use placeholders instead of actual values or parameters, so those parts would need to be adapted to actual numbers or defined parameters in a complete context. The hash `#` symbol is used for specifying delays in Verilog, but their usage here seems to be part of a schematic pseudocode. The literals are not common syntactical elements in Verilog (i.e., a value would be given directly, such as 1'b0 instead of '1'b0), and they might be a mistake or a placeholder for actual values.","
module VFO (output ClockOut, input[1:0] AdjustFreq, input Reset);
    reg     PLLClock;
    real    VFO_Delay;
    assign  ClockOut = PLLClock;
    //
    always@(PLLClock, Reset)
    if (Reset=='b1)
    begin
        VFO_Delay = 'VFOBaseDelay;
        PLLClock    = '1'b0;
    end
    else begin
        case (AdjustFreq)
        2'b11: VFO_Delay = VFO_Delay - 'VFO_Delta;
        2'b00: VFO_Delay = VFO_Delay + 'VFO_Delta;
        // Otherwise, leave VFO_Delay alone.
        endcase
        #VFO_Delay PLLClock <= ~PLLClock; // The oscillator.
    end
endmodule // VFO.
","""Excerpt from a Digital VLSI Design textbook demonstrating pseudocode and Verilog implementation for a Variable Frequency Oscillator (VFO) control system.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p24.jpg,True,"```verilog
module m(input logic c, clk);
  logic a = 1'b0;
  logic b = 1'b1;
  always @(posedge clk) begin
    a <= c;
    b <= !c;
  end
  // assertion
  a1: assert property (@(posedge clk) a != b)
    else $error(""a != b does not hold"");
endmodule : m
```","
module m(input logic c, clk);
  logic a = 1'b0;
  logic b = 1'b1;
  always @(posedge clk) begin
    a <= c;
    b <= !c;
  end
  // assertion
  a1: assert property (@(posedge clk) a != b)
    else $error(""a != b does not hold"");
endmodule : m
","Caption: Example of a Verilog module implementing an assert statement for design verification, as shown in a textbook or a document discussing assertions in SystemVerilog.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p493.jpg,True,"The image contains a fragment of Verilog code. Here is the code as it appears in the image:

```verilog
wire ClkRw, Resetw, ...; // Assigned from MemBIST_Top module inputs.
...
BIST #(
    .AddrHi(AddrHi),
    .Dwid(Dwid)
)
BIST_U1
(
    .DataO(), .Addr(), .ReadCmd(), .WriteCmd() // outputs.
    , .Testing(), .TestOK()                    // outputs.
    , .DoSelfTest(), .ParityErr(), .DataI()    // inputs.
    , .Clk(ClkRw), .Reset(Resetw)              // inputs.
);
```

Note: In the verilog code, ClkRw and ""Resetw"" are named ""*w"" because they have been declared wires.","
wire ClkRw, Resetw, ...; // Assigned from MemBIST_Top module inputs.
...
BIST #(
    .AddrHi(AddrHi),
    .Dwid(Dwid)
)
BIST_U1
(
    .DataO(), .Addr(), .ReadCmd(), .WriteCmd() // outputs.
    , .Testing(), .TestOK()                    // outputs.
    , .DoSelfTest(), .ParityErr(), .DataI()    // inputs.
    , .Clk(ClkRw), .Reset(Resetw)              // inputs.
);
",A Verilog code snippet for instantiating a BIST (Built-In Self-Test) module along with related instructions on implementing and testing BIST functionality.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p125.jpg,True,"```verilog
a_master_data02:
    assert property(p_master_data02)
    else if(master_sva_severity) $fatal;

c_master_start1: cover property(p_master_start1);
c_master_start2: cover property(p_master_start2);
c_master_stop1: cover property(p_master_stop1);
c_master_stop2: cover property(p_master_stop2);
c_master_data1: cover property(p_master_data1);
c_master_data2: cover property(p_master_data2);
c_master_data01: cover property(p_master_data01);
c_master_data02: cover property(p_master_data02);

end

end

endmodule
```","
a_master_data02:
    assert property(p_master_data02)
    else if(master_sva_severity) $fatal;

c_master_start1: cover property(p_master_start1);
c_master_start2: cover property(p_master_start2);
c_master_stop1: cover property(p_master_stop1);
c_master_stop2: cover property(p_master_stop2);
c_master_data1: cover property(p_master_data1);
c_master_data2: cover property(p_master_data2);
c_master_data01: cover property(p_master_data01);
c_master_data02: cover property(p_master_data02);

end

end

endmodule
","Caption: ""Verilog code snippet demonstrating assertions and coverage properties, accompanied by related waveform simulation output for master checks.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p131.jpg,True,"The image contains several snippets of Verilog code which are properties written for formal verification purposes. The code is shown below:

1. The first property:
```verilog
property p_sel_trdy_stop;
    @(posedge clk) $fell (sel_bit) |=> trdy;
endproperty
```

2. The second property:
```verilog
property p_write;
    @(posedge clk)
    (datain[8] && sel_bit && (wi != 0)) |->
    (wi == ($past(wi) + 1));
endproperty
```

3. The third property:
```verilog
property p_read;
    @(posedge clk)
    (!datain[8] && sel_bit && (ri != 63)) |->
    (ri == ($past(ri) + 1));
endproperty
```

These properties define certain conditions related to signals and clocks in a digital system and are used in formal verification to describe and test the behavior of Verilog designs.","
property p_sel_trdy_stop;
    @(posedge clk) $fell (sel_bit) |=> trdy;
endproperty


property p_write;
    @(posedge clk)
    (datain[8] && sel_bit && (wi != 0)) |->
    (wi == ($past(wi) + 1));
endproperty


property p_read;
    @(posedge clk)
    (!datain[8] && sel_bit && (ri != 63)) |->
    (ri == ($past(ri) + 1));
endproperty
","""Excerpt from a document illustrating SystemVerilog properties for checking proper increment of write and read pointers in hardware transactions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p209.jpg,True,"The image contains fragments of code written in C that is meant for use with the Verilog Procedural Interface (VPI). Here is the visible code extracted as best as I can from the image:

```c
/* *****************************************************************
 * define storage structure for file pointer and vector handle.
 * *****************************************************************/
typedef struct PLIbook_MyAppData {
    FILE    *file_ptr;    /* test vector file pointer */
    vpiHandle obj_h;      /* pointer to store an object handle */
} PLIbook_MyAppData_s, *PLIbook_MyAppData_p;

/* *****************************************************************
 * StartOfSim callback--opens a test vector file and saves the file
 * pointer and the system task handle in the work area storage.
 * *****************************************************************/
int PLIbook_StartOfSim(p_cb_data cb_data)
{
    FILE
        *vector_file;
    vpiHandle
        systf_h, tfarg_itr, tfarg1_h, tfarg2_h;
    PLIbook_MyAppData_p vector_data;  /* MyAppData structure pointer */
    
    vector_data = 
        (PLIbook_MyAppData_p)malloc(sizeof(PLIbook_MyAppData_s));
    
    /* get tfarg handles */
    
    /* read file name from first tfarg and open the file */
    
    /* store file pointer and tfarg2 handle in the work area */
    /* for this instance */
    vector_data->file_ptr = vector_file;
    vector_data->obj_h = tfarg2_h;
    PLIbook_set_vpiworkarea(systf_h, (char *)vector_data);

    return(0);
}

/* *****************************************************************
 * Calltf routine
 * *****************************************************************/
int ReadVectorcalltf(char *user_data)
{
    FILE
        *vector_file;
    vpiHandle
        systf_h, tfarg2_h;
    PLIbook_MyAppData_p vector_data;  /* MyAppData structure pointer */
    
    systf_h = vpi_handle(vpiSysTfCall, NULL);
    
    /* get MyAppData pointer from work area for this task instance */
    vector_data = (PLIbook_MyAppData_p)PLIbook_get_vpiworkarea(systf_h);
```

Please note that the code snippets here are incomplete and are meant to be part of a larger source file. They involve the implementation of callbacks for use with VPI, for interacting between C code and Verilog simulations.","***************************************************************
 * define storage structure for file pointer and vector handle.
 * *****************************************************************/
typedef struct PLIbook_MyAppData {
    FILE    *file_ptr;    /* test vector file pointer */
    vpiHandle obj_h;      /* pointer to store an object handle */
} PLIbook_MyAppData_s, *PLIbook_MyAppData_p;

/* *****************************************************************
 * StartOfSim callback--opens a test vector file and saves the file
 * pointer and the system task handle in the work area storage.
 * *****************************************************************/
int PLIbook_StartOfSim(p_cb_data cb_data)
{
    FILE
        *vector_file;
    vpiHandle
        systf_h, tfarg_itr, tfarg1_h, tfarg2_h;
    PLIbook_MyAppData_p vector_data;  /* MyAppData structure pointer */
    
    vector_data = 
        (PLIbook_MyAppData_p)malloc(sizeof(PLIbook_MyAppData_s));
    
    /* get tfarg handles */
    
    /* read file name from first tfarg and open the file */
    
    /* store file pointer and tfarg2 handle in the work area */
    /* for this instance */
    vector_data->file_ptr = vector_file;
    vector_data->obj_h = tfarg2_h;
    PLIbook_set_vpiworkarea(systf_h, (char *)vector_data);

    return(0);
}

/* *****************************************************************
 * Calltf routine
 * *****************************************************************/
int ReadVectorcalltf(char *user_data)
{
    FILE
        *vector_file;
    vpiHandle
        systf_h, tfarg2_h;
    PLIbook_MyAppData_p vector_data;  /* MyAppData structure pointer */
    
    systf_h = vpi_handle(vpiSysTfCall, NULL);
    
    /* get MyAppData pointer from work area for this task instance */
    vector_data = (PLIbook_MyAppData_p)PLIbook_get_vpiworkarea(systf_h);
","Caption: ""Verilog code example showing the implementation of VPI callbacks for simulation synchronization.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p194.jpg,True,"The image contains an excerpt from a document or book describing X-state problems in RTL (Register Transfer Level) simulation using the Verilog hardware description language. It includes an example of Verilog code which I’ll transcribe for you:

```verilog
reg [15:0] a,b,c;
...
begin
    b = 16'b0000000000000000;
    c = 16'b000000000000X000;
    a = b + c;
    $display(""a = %b"",a);
end
```
The code defines a sequential block that assigns binary values to registers `b` and `c`, where `b` is set to 16 binary zeros and `c` is set to a 16-bit binary number with an 'X' (unknown state) at the fourth position from the right. Then, `a` is assigned the result of the addition of `b` and `c`, and the result is displayed. The discussion in the text pertains to how the X-state (the unknown value 'X') is propagated through the simulation.","
reg [15:0] a,b,c;
...
begin
    b = 16'b0000000000000000;
    c = 16'b000000000000X000;
    a = b + c;
    $display(""a = %b"",a);
end
","Caption: ""Discussion of X-state pessimism in RTL simulation with an example of Verilog addition operation handling unknown values (X) in input operands.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p221.jpg,True,"The image contains a snippet of code in Verilog, which is a hardware description language used to model electronic systems. Here is the text from the code in the image:

```c
/* write the vector to the second system task argument */
value_s.format = vpiBinStrVal;
value_s.value.str = vector;
vpi_put_value(arg2_h, &value_s, NULL, vpiNoDelay);

return(0);
}

/******************************************************************************/
/* StartOfSim callback -- opens the test vector file and saves the
 * pointer and the system task handle in the work area storage.
 ******************************************************************************/
int PlIbook_StartOfSim(p_cb_data cb_data)
{
    s_vpi_value argVal;
    char        *file_name;
    FILE        *vector_file;
    vpiHandle   systf_h, arg_itr, arg1_h, arg2_h;

    PlIbook_Data_p vector_data; /* pointer to a ReadVecData structure */

    vector_data = (PlIbook_Data_p)malloc(sizeof(PlIbook_Data_s));

    /* retrieve system task handle from user_data */
    systf_h = (vpiHandle)cb_data->user_data;

    /* get argument handles (compiletf already verified only 2 args) */
    arg_itr = vpi_iterate(vpiArgument, systf_h);
    arg1_h = vpi_scan(arg_itr);
    arg2_h = vpi_scan(arg_itr);
    vpi_free_object(arg_itr); /* free iterator -- did not scan to null */

    /* read file name from first tfarg */
    argVal.format = vpiStringVal;
    vpi_get_value(arg1_h, &argVal);
    if (vpi_chk_error(NULL)) {
        vpi_printf(""ERROR: $read_test_vector could not get file name\n"");
        return(0);
    }
    file_name = argVal.value.str;

    if (!(vector_file = fopen(file_name, ""r""))) {
        vpi_printf(""$read_test_vector could not open file %s"", file_name);
        tf_dofinish;
        return(0);
    }

    /* store file pointer and tfarg2_h in work area for this instance */
    vector_data->file_ptr = vector_file;
    vector_data->obj_h = arg2_h;
    PlIbook_setpworkarea(systf_h, (char *)vector_data);

    return(0);
}
```

This code appears to be related to the synchronization of Verilog simulations using VPI callbacks. It includes functions to write a vector to a system task argument, start a simulation callback, and handle the reading of a test vector file. There are sections for handling errors and storing data in a work area as well.","ite the vector to the second system task argument */
value_s.format = vpiBinStrVal;
value_s.value.str = vector;
vpi_put_value(arg2_h, &value_s, NULL, vpiNoDelay);

return(0);
}

/******************************************************************************/
/* StartOfSim callback -- opens the test vector file and saves the
 * pointer and the system task handle in the work area storage.
 ******************************************************************************/
int PlIbook_StartOfSim(p_cb_data cb_data)
{
    s_vpi_value argVal;
    char        *file_name;
    FILE        *vector_file;
    vpiHandle   systf_h, arg_itr, arg1_h, arg2_h;

    PlIbook_Data_p vector_data; /* pointer to a ReadVecData structure */

    vector_data = (PlIbook_Data_p)malloc(sizeof(PlIbook_Data_s));

    /* retrieve system task handle from user_data */
    systf_h = (vpiHandle)cb_data->user_data;

    /* get argument handles (compiletf already verified only 2 args) */
    arg_itr = vpi_iterate(vpiArgument, systf_h);
    arg1_h = vpi_scan(arg_itr);
    arg2_h = vpi_scan(arg_itr);
    vpi_free_object(arg_itr); /* free iterator -- did not scan to null */

    /* read file name from first tfarg */
    argVal.format = vpiStringVal;
    vpi_get_value(arg1_h, &argVal);
    if (vpi_chk_error(NULL)) {
        vpi_printf(""ERROR: $read_test_vector could not get file name\n"");
        return(0);
    }
    file_name = argVal.value.str;

    if (!(vector_file = fopen(file_name, ""r""))) {
        vpi_printf(""$read_test_vector could not open file %s"", file_name);
        tf_dofinish;
        return(0);
    }

    /* store file pointer and tfarg2_h in work area for this instance */
    vector_data->file_ptr = vector_file;
    vector_data->obj_h = arg2_h;
    PlIbook_setpworkarea(systf_h, (char *)vector_data);

    return(0);
}
",A snippet of C code showing how to interface with Verilog simulations using VPI callbacks for file handling and starting simulations.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p550.jpg,True,"```verilog
a12: assert property (start_t && 2'b10 == in_data ##1 end_t[-1]
                    |-> out_data == 2'b10);
a13: assert property (start_t && 2'b11 == in_data ##1 end_t[-1]
                    |-> out_data == 2'b11);

checker data_consistency2(start_t, end_t, in_data, out_data,
                          event clk = $inferred_clock,
                          untyped rst = $inferred_disable);
default clocking @clk; endclocking
default disable iff rst;

property data_consistent;
    var type(in_data) data;
    start_t, data = in_data) ##1 end_t[-1]
    |-> out_data == data;
endproperty : data_consistent

a2: assert property (data_consistent);
endchecker : data_consistency2
```

This image contains Verilog code related to assertion properties and a definition of a `checker` block that uses these assertions.","
a12: assert property (start_t && 2'b10 == in_data ##1 end_t[-1]
                    |-> out_data == 2'b10);
a13: assert property (start_t && 2'b11 == in_data ##1 end_t[-1]
                    |-> out_data == 2'b11);

checker data_consistency2(start_t, end_t, in_data, out_data,
                          event clk = $inferred_clock,
                          untyped rst = $inferred_disable);
default clocking @clk; endclocking
default disable iff rst;

property data_consistent;
    var type(in_data) data;
    start_t, data = in_data) ##1 end_t[-1]
    |-> out_data == data;
endproperty : data_consistent

a2: assert property (data_consistent);
endchecker : data_consistency2
","""Verilog code for formal verification with an explanation of rigid variable support in simulation.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p119.jpg,True,"The image contains Verilog SystemVerilog Assertion (SVA) code. Here is the code transcribed from the image:

```verilog
property p_arb_onehot0;
    @(posedge clk) $onehot0(state);
endproperty

property p_req_gnt;
    @(posedge clk) $rose(req) |-> ##[2:5] $rose(gnt);
endproperty

property p_gnt_frame;
    @(posedge clk) $rose(gnt) |-> $fell(frame && irdy);
endproperty

property p_frame_gnt;
    @(posedge clk) $rose(frame && irdy) |=> $fell(gnt);
Endproperty
```

These are SystemVerilog assertions that are used for checking the behavior of an arbiter in a hardware design. Each `property` defines a specific condition to be asserted in the design under verification.","
property p_arb_onehot0;
    @(posedge clk) $onehot0(state);
endproperty

property p_req_gnt;
    @(posedge clk) $rose(req) |-> ##[2:5] $rose(gnt);
endproperty

property p_gnt_frame;
    @(posedge clk) $rose(gnt) |-> $fell(frame && irdy);
endproperty

property p_frame_gnt;
    @(posedge clk) $rose(frame && irdy) |=> $fell(gnt);
Endproperty
",A textbook extract detailing SystemVerilog Assertions (SVA) for checking arbiter behavior in hardware simulation.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p547.jpg,True,"The image contains Verilog code examples. Here is the code transcribed from the image:

```verilog
always @(posedge clock)
    $read_test_vector(""vectors.pat"", input_bus);
```

And further down in the image, there is another snippet:

```verilog
always @(posedge clock)
    $read_test_vector(""A.dat"", data_bus);

always @(negedge clock)
    $read_test_vector(""B.dat"", data_bus);
```

These snippets illustrate how to call a user-defined system task `$read_test_vector` with different arguments based on the clock edge (positive or negative).","
always @(posedge clock)
    $read_test_vector(""vectors.pat"", input_bus);


always @(posedge clock)
    $read_test_vector(""A.dat"", data_bus);

always @(negedge clock)
    $read_test_vector(""B.dat"", data_bus);
","Caption: ""Explanation and examples of Verilog system task/function arguments and invocation of multiple instances of system tasks and functions with Verilog code snippets.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p30.jpg,True,"The image contains Verilog code. Here is the code that is visible in the image:

```
repeat (1) @(posedge clk);
fork: a_to_b

begin
    @(posedge b)
    $display
    (""SUCCESS: b arrived in time\n"", $time);
    disable a_to_b;
end

begin
    repeat (3) @(posedge clk);
    $display
    (""ERROR:b did not arrive in time\n"", $time);
    disable a_to_b;
end

join

end

// SVA Checker

a_to_b_chk:
assert property
(@(posedge clk) $rose(a) |-> ##[1:3] $rose(b));
```

This code snippet is related to SystemVerilog Assertions (SVA), showing an example of concurrent assertions utilized in hardware verification to ensure that certain conditions hold true within a design."," (1) @(posedge clk);
fork: a_to_b

begin
    @(posedge b)
    $display
    (""SUCCESS: b arrived in time\n"", $time);
    disable a_to_b;
end

begin
    repeat (3) @(posedge clk);
    $display
    (""ERROR:b did not arrive in time\n"", $time);
    disable a_to_b;
end

join

end

// SVA Checker

a_to_b_chk:
assert property
(@(posedge clk) $rose(a) |-> ##[1:3] $rose(b));
","""Verilog code excerpt demonstrating SystemVerilog Assertions (SVA) for timing checks.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p66.jpg,True,"The image contains pseudocode related to the algorithm for solving generalized Streett[1] games. Here is the pseudocode written out:

```plaintext
1  foreach v ∈ V and j ∈ [n] do
2      B_j(v) := ∅; C_j(v) := |{w : (v, w) ∈ δ}|; r_j(v) := (0, 1);
3  L := {(v, j) ∈ V × [n] | g_j(v) and p1 ∈ L(v)};
4  while L ≠ ∅ do
5      let (v, j) ∈ L; L := L \ {(v, j)};
6      τ := r_j(v);
7      B_j(v) := best_j(v); C_j(v) := cnt_j(v);
8      r_j(v) := incr_j(best_j(v));
9      P := {w ∈ V | (w, v) ∈ ρ};
10     foreach w ∈ P such that (w, j) ≠ L do
11         if w ∈ V0 and t = B_j(w) and C_j(w) > 1 then C_j(w)--;
12         if w ∈ V0 and t = B_j(w) and C_j(w) = 1 then L := L ∪ {(w, j)};
13         if w ∈ V1 and t = B_j(w) then C_j(w)++;
14         if w ∈ V1 and t > B_j(w) then L := L ∪ {(w, j)};
15     endfor
16 endwhile
```

This pseudocode is not specifically Verilog code; rather, it appears to be a generalized representation of a computational procedure or algorithm, which could be implemented in any programming language, including hardware description languages like Verilog.","xt
1  foreach v ∈ V and j ∈ [n] do
2      B_j(v) := ∅; C_j(v) := |{w : (v, w) ∈ δ}|; r_j(v) := (0, 1);
3  L := {(v, j) ∈ V × [n] | g_j(v) and p1 ∈ L(v)};
4  while L ≠ ∅ do
5      let (v, j) ∈ L; L := L \ {(v, j)};
6      τ := r_j(v);
7      B_j(v) := best_j(v); C_j(v) := cnt_j(v);
8      r_j(v) := incr_j(best_j(v));
9      P := {w ∈ V | (w, v) ∈ ρ};
10     foreach w ∈ P such that (w, j) ≠ L do
11         if w ∈ V0 and t = B_j(w) and C_j(w) > 1 then C_j(w)--;
12         if w ∈ V0 and t = B_j(w) and C_j(w) = 1 then L := L ∪ {(w, j)};
13         if w ∈ V1 and t = B_j(w) then C_j(w)++;
14         if w ∈ V1 and t > B_j(w) then L := L ∪ {(w, j)};
15     endfor
16 endwhile
","Efficient algorithm for solving generalized Streett games, described within a scholarly paper.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p544.jpg,True,"The image presents two snippets of Verilog code. Here they are:

Example 23.20:
```verilog
checker check(..., clk = $inferred_clock);
  rand bit v;
  rand bit w = 1’b0;

  always_ff @clk
    v <= ...;
  ...
endchecker : check
```

Example 23.21:
```verilog
checker check1(sequence s, ..., event clk1, clk2);
  rand bit [3:0] v, r;
  ...
  m1: assume property (@clk1 $|-> @clk2 v + w < 7);
endchecker : check1
```","
checker check(..., clk = $inferred_clock);
  rand bit v;
  rand bit w = 1’b0;

  always_ff @clk
    v <= ...;
  ...
endchecker : check


checker check1(sequence s, ..., event clk1, clk2);
  rand bit [3:0] v, r;
  ...
  m1: assume property (@clk1 $|-> @clk2 v + w < 7);
endchecker : check1
","Caption: ""Excerpts from a textbook discussing the use of checkers with randomization and assumptions in Verilog for formal verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p235.jpg,True,"The image contains snippets of code that appear to be related to the Verilog Hardware Description Language (HDL) and interfacing Verilog simulations with C using VPI callbacks. The code is partially visible, but I'll type out what is available:

```c
s_cb_data          data_s;
s_vpi_time         time_s;
vpiHandle          systf_h;
p_ReadStimData     StimData; /* pointer to a ReadStimData structure */

/* get ReadStimData pointer from work area for this task instance */
systf_h = vpi_handle(vpiSysTfCall, NULL);
StimData = (p_ReadStimData)PLIbook_get_vpivorkarea(systf_h);

/* look at user data to set the stimulus mode flag */
if (strcmp(user_data, ""ba"") == 0) StimData->mode = 0;
else if (strcmp(user_data, ""br"") == 0) StimData->mode = 1;
else if (strcmp(user_data, ""ha"") == 0) StimData->mode = 2;
else                                    StimData->mode = 3;

/* setup immediate callback to ReadNextStim routine */
systf_h = vpi_handle(vpiSysTfCall, NULL);
time_s.type      = vpiSimTime;
time_s.low       = 0;
time_s.high      = 0;
data_s.reason    = cbReadWriteSynch;
data_s.cb_rtn    = PLIbook_ReadNextStim;
data_s.obj       = NULL;
data_s.time      = &time_s;
data_s.value     = NULL;
data_s.user_data = (char *)systf_h;
vpi_register_cb(&data_s);

return(0);
}

/******************************************************************
 * ReadNextStim callback -- Reads a time and vector from a file.
 * Schedules the vector to be applied at the specified time.
 * Schedules a callback to self that same time (to read next line).
******************************************************************/
int PLIbook_ReadNextStim(p_cb_data cb_data)
{
char vector[1024]; /* fixed max. size, should use malloc instead */
int               delay;
vpiHandle         systf_h;
s_cb_data         data_s;
s_vpi_time        time_s;
s_vpi_value        value_s;
p_ReadStimData     StimData; /* pointer to a ReadStimData structure */

/* retrieve system task handle from user_data */
systf_h = (vpiHandle)cb_data->user_data;

/* get ReadStimData pointer from work area for this task instance */
StimData = (p_ReadStimData)PLIbook_get_vpivorkarea(systf_h);

/* read next line from the file */
```

Please note that the function definitions and other parts of the code are not fully visible in the image, so I have included the visible parts only.","data          data_s;
s_vpi_time         time_s;
vpiHandle          systf_h;
p_ReadStimData     StimData; /* pointer to a ReadStimData structure */

/* get ReadStimData pointer from work area for this task instance */
systf_h = vpi_handle(vpiSysTfCall, NULL);
StimData = (p_ReadStimData)PLIbook_get_vpivorkarea(systf_h);

/* look at user data to set the stimulus mode flag */
if (strcmp(user_data, ""ba"") == 0) StimData->mode = 0;
else if (strcmp(user_data, ""br"") == 0) StimData->mode = 1;
else if (strcmp(user_data, ""ha"") == 0) StimData->mode = 2;
else                                    StimData->mode = 3;

/* setup immediate callback to ReadNextStim routine */
systf_h = vpi_handle(vpiSysTfCall, NULL);
time_s.type      = vpiSimTime;
time_s.low       = 0;
time_s.high      = 0;
data_s.reason    = cbReadWriteSynch;
data_s.cb_rtn    = PLIbook_ReadNextStim;
data_s.obj       = NULL;
data_s.time      = &time_s;
data_s.value     = NULL;
data_s.user_data = (char *)systf_h;
vpi_register_cb(&data_s);

return(0);
}

/******************************************************************
 * ReadNextStim callback -- Reads a time and vector from a file.
 * Schedules the vector to be applied at the specified time.
 * Schedules a callback to self that same time (to read next line).
******************************************************************/
int PLIbook_ReadNextStim(p_cb_data cb_data)
{
char vector[1024]; /* fixed max. size, should use malloc instead */
int               delay;
vpiHandle         systf_h;
s_cb_data         data_s;
s_vpi_time        time_s;
s_vpi_value        value_s;
p_ReadStimData     StimData; /* pointer to a ReadStimData structure */

/* retrieve system task handle from user_data */
systf_h = (vpiHandle)cb_data->user_data;

/* get ReadStimData pointer from work area for this task instance */
StimData = (p_ReadStimData)PLIbook_get_vpivorkarea(systf_h);

/* read next line from the file */
","""Excerpt from a textbook explaining the usage of VPI callbacks in Verilog simulations for synchronizing stimulus data.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p222.jpg,True,"```verilog
out <= tmp[DEL - 2];
end
end
endmodule : trans

checker eventually_granted(sequence req, property gnt,
event clk = $inferred_clock);
assert property(@(clk req |=> s_eventually gnt));
endchecker : eventually_granted

bind trans eventually_granted
  check_in2out(in, out, posedge clock);

module trans #(DEL=1) (input logic clock, in,
                       output logic out);
...
eventually_granted check_in2out(in, out, posedge clock);
endmodule : trans

checker request_granted(sequence req, property gnt, int n = 1,
event clk = $inferred_clock, untyped rst = $inferred_disable);
a1: assert property(@(clk disable iff (rst)
  req |-> nexttime[n] gnt));
endchecker : request_granted

bind trans: ta, tb request_granted
  delay1(in, out,, posedge clock);
bind trans: tc request_granted
  delay2(in, out, 2, posedge clock);
```","
out <= tmp[DEL - 2];
end
end
endmodule : trans

checker eventually_granted(sequence req, property gnt,
event clk = $inferred_clock);
assert property(@(clk req |=> s_eventually gnt));
endchecker : eventually_granted

bind trans eventually_granted
  check_in2out(in, out, posedge clock);

module trans #(DEL=1) (input logic clock, in,
                       output logic out);
...
eventually_granted check_in2out(in, out, posedge clock);
endmodule : trans

checker request_granted(sequence req, property gnt, int n = 1,
event clk = $inferred_clock, untyped rst = $inferred_disable);
a1: assert property(@(clk disable iff (rst)
  req |-> nexttime[n] gnt));
endchecker : request_granted

bind trans: ta, tb request_granted
  delay1(in, out,, posedge clock);
bind trans: tc request_granted
  delay2(in, out, 2, posedge clock);
","""Verilog Code Excerpt Showing Module and Assertion-Based Checker Examples""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p180.jpg,True,"```verilog
module ab0(...);
...
module ab_muxin4(...);
...
module ab_tbd_queue2(...);
...
```","
module ab0(...);
...
module ab_muxin4(...);
...
module ab_tbd_queue2(...);
...
","Caption: ""Excerpt from a book showing best practices for naming Verilog modules to avoid name clashes and support simulation performance profiling.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p336.jpg,True,"The image contains a snippet of code in the Verilog language. Here is the code extracted from the image:

```verilog
defparam hierarchical_path_to_parameter = new_value;
```

This code line is demonstrating the use of the `defparam` keyword in Verilog, which is used to override the value of a parameter at a hierarchical path.","
defparam hierarchical_path_to_parameter = new_value;
","""Discussion of the use of `defparam` in Verilog for parameter overrides and recommendation against its use due to potential introduction of defects in VLSI design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p591.jpg,True,"Here is the code snippet from the image:

```c
#include ""veriuser.h""                  /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""                  /* IEEE 1364 PLI ACC routine library */
/********************************************************************
* calltf application
********************************************************************/
int PLIbook_MipdDelays_calltf()
{
    double delay_array[9];
    double rise, fall, toz;
    handle port_h;
    int i;

    acc_initialize();
    acc_configure(accDisplayWarnings, ""true"");
    acc_configure(accMinTypMaxDelays, ""true"");
    port_h = acc_handle_tfarg(1);

    /* most simulators return loconn handle, not port handle */
    if ( (acc_fetch_type(port_h) != accPort)
      && (acc_fetch_type(port_h) != accPortBit) )
        port_h = acc_next_port(port_h, null);
    if ( (acc_fetch_type(port_h) != accPort)
      && (acc_fetch_type(port_h) != accPortBit) ) {
        io_printf(""ERR: $mipd_delays could not obtain port handle\n"");
        return(0);
    }

    for (i = 0; i < 9; i++)
        delay_array[i] = acc_fetch_tfarg(i+2);

    acc_replace_delays(port_h, delay_array);
}
```

This code appears to be part of the Verilog Programming Language Interface (PLI), which allows custom C code to interface with Verilog simulators. The code implements a function to modify delays using the ACC (Access) library, which is part of the Verilog PLI.","ude ""veriuser.h""                  /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""                  /* IEEE 1364 PLI ACC routine library */
/********************************************************************
* calltf application
********************************************************************/
int PLIbook_MipdDelays_calltf()
{
    double delay_array[9];
    double rise, fall, toz;
    handle port_h;
    int i;

    acc_initialize();
    acc_configure(accDisplayWarnings, ""true"");
    acc_configure(accMinTypMaxDelays, ""true"");
    port_h = acc_handle_tfarg(1);

    /* most simulators return loconn handle, not port handle */
    if ( (acc_fetch_type(port_h) != accPort)
      && (acc_fetch_type(port_h) != accPortBit) )
        port_h = acc_next_port(port_h, null);
    if ( (acc_fetch_type(port_h) != accPort)
      && (acc_fetch_type(port_h) != accPortBit) ) {
        io_printf(""ERR: $mipd_delays could not obtain port handle\n"");
        return(0);
    }

    for (i = 0; i < 9; i++)
        delay_array[i] = acc_fetch_tfarg(i+2);

    acc_replace_delays(port_h, delay_array);
}
","""Verilog PLI for Adding Delays to Module Inputs Using an Array""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p156.jpg,True,"The image you provided contains two Verilog code examples. Here they are transcribed:

Example 7-6:

a) Functionally-specified case
```verilog
module c (r_o, c_n);
  input [1:0] r_o;
  output [1:0] c_n;
  reg [1:0] c_n;
  always @(r_o)
    // synthesis full_case
    case (r_o)
      2'b00: c_n = 2'b01;
      2'b01: c_n = 2'b10;
      2'b10: c_n = 2'b00;
    endcase
endmodule // c
```

b) Fully-specified case
```verilog
module c (r_o, c_n);
  input [1:0] r_o;
  output [1:0] c_n;
  reg [1:0] c_n;
  always @(r_o)
    case (r_o)
      2'b00: c_n = 2'b01;
      2'b01: c_n = 2'b10;
      2'b10: c_n = 2'b00;
      2'b11: c_n = 2'b00; // handles the ""impossible"" case
    endcase
endmodule // c
```

These code snippets illustrate how to define a module in Verilog with a simple case statement specifying different behaviors based on the input signals. The first example shows a functionally-specified case with three states, and the second one is a fully-specified case that also covers the 'impossible' state with the input `2'b11`.","
module c (r_o, c_n);
  input [1:0] r_o;
  output [1:0] c_n;
  reg [1:0] c_n;
  always @(r_o)
    // synthesis full_case
    case (r_o)
      2'b00: c_n = 2'b01;
      2'b01: c_n = 2'b10;
      2'b10: c_n = 2'b00;
    endcase
endmodule // c


module c (r_o, c_n);
  input [1:0] r_o;
  output [1:0] c_n;
  reg [1:0] c_n;
  always @(r_o)
    case (r_o)
      2'b00: c_n = 2'b01;
      2'b01: c_n = 2'b10;
      2'b10: c_n = 2'b00;
      2'b11: c_n = 2'b00; // handles the ""impossible"" case
    endcase
endmodule // c
","""Textbook excerpt explaining fully-specified case statements in Verilog with example code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p585.jpg,True,"The image contains a snippet of code in C that appears to interface with Verilog through the PLI (Programming Language Interface). Here is the code transcribed from the image:

```c
#include ""veriuser.h""                /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""                /* IEEE 1364 PLI ACC routine library */
/***********************************************************************
 * calltf application
 ***********************************************************************/
int PLIbook_PathDelays_calltf()
{
    handle module_h, path_h;
    double delay_set[18];
    int i;
    
    acc_initialize();
    acc_configure(accDisplayWarnings, ""true"");
    
    acc_configure(accMinTypMaxDelays, ""true"");
    acc_configure(accPathDelayCount, ""6"");
    
    module_h = acc_handle_tfarg(1);
    io_printf(""\nPath delays in module %s:\n"", acc_fetch_fullname(module_h));
    
    path_h = null;                   /* start with known value for target handle */
    while (path_h = acc_next_modpath(module_h, path_h)) {
        io_printf("" %-12s : "", acc_fetch_name(path_h));
        
        acc_fetch_delays(path_h, delay_set);
        for(i=0; i<18; i++) {
            if ( i == 0 )             /* format output like Verilog syntax */
                io_printf(""{"");
            else if ( (i % 3) )
                io_printf("":"");
            else
                io_printf("","");
            io_printf(""%1.1f"", delay_set[i]);
        }
        io_printf(""}\n\n"");
    }
    acc_close();
    return(0);
}
```

This is a C function that uses the Verilog Programming Language Interface (PLI) to access and print the path delays within a Verilog module. It's a part of the Verilog PLI Handbook, Part Two.","ude ""veriuser.h""                /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""                /* IEEE 1364 PLI ACC routine library */
/***********************************************************************
 * calltf application
 ***********************************************************************/
int PLIbook_PathDelays_calltf()
{
    handle module_h, path_h;
    double delay_set[18];
    int i;
    
    acc_initialize();
    acc_configure(accDisplayWarnings, ""true"");
    
    acc_configure(accMinTypMaxDelays, ""true"");
    acc_configure(accPathDelayCount, ""6"");
    
    module_h = acc_handle_tfarg(1);
    io_printf(""\nPath delays in module %s:\n"", acc_fetch_fullname(module_h));
    
    path_h = null;                   /* start with known value for target handle */
    while (path_h = acc_next_modpath(module_h, path_h)) {
        io_printf("" %-12s : "", acc_fetch_name(path_h));
        
        acc_fetch_delays(path_h, delay_set);
        for(i=0; i<18; i++) {
            if ( i == 0 )             /* format output like Verilog syntax */
                io_printf(""{"");
            else if ( (i % 3) )
                io_printf("":"");
            else
                io_printf("","");
            io_printf(""%1.1f"", delay_set[i]);
        }
        io_printf(""}\n\n"");
    }
    acc_close();
    return(0);
}
","""Verilog PLI example for listing path delays in a module using Verilog-XL ACC routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p323.jpg,True,"Here is the Verilog code that is visible in the image:

```verilog
trireg (medium) #(3,3,10) TriS;
trireg (medium) #(6,7,30) TriM;
trireg (large) #(15,16,50) TriL;
// Pass transistor network:
tran (TriM, TriS); // left always wins.
tran (TriM, TriL); // right always wins.
// NMOS network:
rnmos #1 (TriM, TriS, vdd); // input has no effect.
rnmos #1 (TriS, TriL, vdd); // input controls output.
rnmos #1 (TriM, TriL, vdd); // Contention on output.
```

The image contains an example of a trireg declaration as well as some code lines that demonstrate the use of trireg nets with a pass transistor network and an NMOS network in Verilog.","
trireg (medium) #(3,3,10) TriS;
trireg (medium) #(6,7,30) TriM;
trireg (large) #(15,16,50) TriL;
// Pass transistor network:
tran (TriM, TriS); // left always wins.
tran (TriM, TriL); // right always wins.
// NMOS network:
rnmos #1 (TriM, TriS, vdd); // input has no effect.
rnmos #1 (TriS, TriL, vdd); // input controls output.
rnmos #1 (TriM, TriL, vdd); // Contention on output.
","Caption: ""Excerpts from a textbook on Digital VLSI Design with Verilog, illustrating the concept and example code for trireg nets in Verilog and outlining the deliverables for a Component Lab exercise involving switch-level models.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p337.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
module ANSItop #(parameter A=1, B=3, parameter signed[4:1] List=4'b1010)
    (output[3:0] BusOut, output ClockOut
    , input[3:0] BusIn, input ClockIn
    , input[1:0] Select
    );
reg ClockOutReg;
assign {2, 3} ClockOut = ClockOutReg;
...
endmodule
```

The code is a module definition with parameters and a partial list of I/O ports, along with a register declaration and an incomplete assign statement.","
module ANSItop #(parameter A=1, B=3, parameter signed[4:1] List=4'b1010)
    (output[3:0] BusOut, output ClockOut
    , input[3:0] BusIn, input ClockIn
    , input[1:0] Select
    );
reg ClockOutReg;
assign {2, 3} ClockOut = ClockOutReg;
...
endmodule
",Verilog Module Header Conversion and Parameter Override Assignment,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p552.jpg,True,"```c
char *acc_fetch_value(object, format_str, value)
handle object;                    /* handle for a net or register */
char *format_str;                 /* character string controlling the radix of the retrieved value; must be “%b”, “%o”, “%d”, “%h”, “%v” or “%x%”. */
p_acc_value value;                /* pointer to an application-allocated s_acc_value structure to receive the value as an aval/bval pair. Only used if format_str is “%o%”. */
```
","*acc_fetch_value(object, format_str, value)
handle object;                    /* handle for a net or register */
char *format_str;                 /* character string controlling the radix of the retrieved value; must be “%b”, “%o”, “%d”, “%h”, “%v” or “%x%”. */
p_acc_value value;                /* pointer to an application-allocated s_acc_value structure to receive the value as an aval/bval pair. Only used if format_str is “%o%”. */
",A textbook page explaining how to read and modify Verilog values using ACC routines and detailing the acc_fetch_value() function for converting Verilog logic values to C representations.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p545.jpg,True,"The image contains excerpts of code written in Verilog, which is a hardware description language commonly used in the design of electronic systems. Here is the code from the image:

```verilog
checker check1(sequence s, ..., event clk1, clk2);
  rand bit [3:0] v, w, r;
  ...
  check2 mycheck(s, v, w, clk1, clk2);
endchecker : check1

checker check2(sequence s, untyped a, b, event clk1, clk2);
  m1: assume property (@clk1 s |-> @clk2 a + b < 7);
endchecker : check2

checker check1(sequence s, ..., event clk1, clk2);
  rand bit [3:0] v, w, r;
  ...
  always @clk1
    w <= v + 1;
  m1: assume property (@clk1 s |-> @clk2 v + w < 7);
endchecker : check1

checker check(..., event clk);
  default clocking @clk; endclocking
  rand bit [3:0] v, w;
  ...
  m1: assume property (v + w < 2);
  m2: assume property (v + w > 3);
endchecker : check
```

Please note that the code fragments in the image are snippets and may not be complete or contextually cohesive.","
checker check1(sequence s, ..., event clk1, clk2);
  rand bit [3:0] v, w, r;
  ...
  check2 mycheck(s, v, w, clk1, clk2);
endchecker : check1

checker check2(sequence s, untyped a, b, event clk1, clk2);
  m1: assume property (@clk1 s |-> @clk2 a + b < 7);
endchecker : check2

checker check1(sequence s, ..., event clk1, clk2);
  rand bit [3:0] v, w, r;
  ...
  always @clk1
    w <= v + 1;
  m1: assume property (@clk1 s |-> @clk2 v + w < 7);
endchecker : check1

checker check(..., event clk);
  default clocking @clk; endclocking
  rand bit [3:0] v, w;
  ...
  m1: assume property (v + w < 2);
  m2: assume property (v + w > 3);
endchecker : check
","""Exploring the use of free variables in Verilog checkers and their randomization in simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p67.jpg,True,"```plaintext
1 foreach (Pi, Qi) ∈ P do
2   wini := ∅; old_wini := V;
3   i := 1;
4   while wini ≠ old_wini do
5     old_wini := wini;
6     avoid := avoid_set(Qi, old_wini);
7     imm_wini := (avoid ∩ Pi) ∨ old_wini;
8     wini := back_reach(imm_wini);
9     i := i ⊕ 1;
10 endwhile
```","xt
1 foreach (Pi, Qi) ∈ P do
2   wini := ∅; old_wini := V;
3   i := 1;
4   while wini ≠ old_wini do
5     old_wini := wini;
6     avoid := avoid_set(Qi, old_wini);
7     imm_wini := (avoid ∩ Pi) ∨ old_wini;
8     wini := back_reach(imm_wini);
9     i := i ⊕ 1;
10 endwhile
","""An algorithm for computing winning states in generalized response games, represented as pseudocode in a research document.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p181.jpg,True,"The image contains example Verilog code. Here is the code transcribed from the image:

Example 7-17
a) Submodules with consistent names

```verilog
module dr5(a, s, t);
input a;
output [1:0] s, t;
...
endmodule // dr5

module rc5(s, t, z);
input [1:0] s, t;
output z;
...
endmodule // rc5
```

b) Module instantiating dr5 and rc5

```verilog
module nu4();
dr5 dr();
rc5 rc();
endmodule // nu4
```

c) Consistent names imply connections

```verilog
module nu4 (a,z);
input a;
output z;
wire [1:0] s;
wire [1:0] t;
dr5 dr (
.a (a),
.s (s),
.t (t));
rc5 rc (
.s (s),
.t (t),
.z (z));
endmodule // nu4
```","
module dr5(a, s, t);
input a;
output [1:0] s, t;
...
endmodule // dr5

module rc5(s, t, z);
input [1:0] s, t;
output z;
...
endmodule // rc5


module nu4();
dr5 dr();
rc5 rc();
endmodule // nu4


module nu4 (a,z);
input a;
output z;
wire [1:0] s;
wire [1:0] t;
dr5 dr (
.a (a),
.s (s),
.t (t));
rc5 rc (
.s (s),
.t (t),
.z (z));
endmodule // nu4
","Caption: ""Verilog code example demonstrating the importance of consistent port naming for module instantiation and connections.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p234.jpg,True,"The image contains a snippet of C code that is intended to be used with Verilog PLI (Programming Language Interface). Here's the code as it appears in the image:

```c
int tfarg_type, err = 0;
char *file_name;

systf_h = vpi_handle(vpiSysTfCall, NULL);
arg_itr = vpi_iterate(vpiArgument, systf_h);
if (arg_itr == NULL) {
    vpi_printf(""ERROR: $read_stimulus_?? requires 2 arguments\n"");
    tf_dofinish();
    return(0);
}
arg_h = vpi_scan(arg_itr); /* get handle for first tfarg */
if ((vpi_get(vpiType, arg_h) != vpiConstant) {
    vpi_printf(""$read_stimulus_?? arg 1 must be a quoted file name\n"");
    err = 1;
}
else if (vpi_get(vpiConstType, arg_h) != vpiStringConst) {
    vpi_printf(""$read_stimulus_?? arg 1 must be a string\n"");
    err = 1;
}
arg_h = vpi_scan(arg_itr); /* get handle for second tfarg */
tfarg_type = vpi_get(vpiType, arg_h);
if ((tfarg_type != vpiReg) &&
    (tfarg_type != vpiIntegerVar) &&
    (tfarg_type != vpiTimeVar)) {
    vpi_printf(""$read_stimulus_?? arg 2 must be a register type\n"");
    err = 1;
}
if (vpi_scan(arg_itr) != NULL) {
    vpi_printf(""$read_stimulus_?? requires only 2 arguments\n"");
    vpi_free_object(arg_itr);
    err = 1;
}
if (err)
    tf_dofinish();

/* setup a callback for start of simulation */
cb_data_s.reason = cbStartOfSimulation;
cb_data_s.cb_rtn = PLIbook_StartOfSim;
cb_data_s.obj = NULL;
cb_data_s.time = NULL;
cb_data_s.value = NULL;
cb_data_s.user_data = (char *)systf_h; /* pass systf_h to callback */
vpi_register_cb(&cb_data_s);

return(0);
}

/***********************************************************************
 * callback routine -- registers an immediate callback to the
 * ReadNextStim application.
 ***********************************************************************/
int PLIbook_ReadStim_calltf(char *user_data)
```

Please note that the snippet seems to be incomplete, as it begins and ends abruptly, indicating that there should be more code before and after the provided parts.","farg_type, err = 0;
char *file_name;

systf_h = vpi_handle(vpiSysTfCall, NULL);
arg_itr = vpi_iterate(vpiArgument, systf_h);
if (arg_itr == NULL) {
    vpi_printf(""ERROR: $read_stimulus_?? requires 2 arguments\n"");
    tf_dofinish();
    return(0);
}
arg_h = vpi_scan(arg_itr); /* get handle for first tfarg */
if ((vpi_get(vpiType, arg_h) != vpiConstant) {
    vpi_printf(""$read_stimulus_?? arg 1 must be a quoted file name\n"");
    err = 1;
}
else if (vpi_get(vpiConstType, arg_h) != vpiStringConst) {
    vpi_printf(""$read_stimulus_?? arg 1 must be a string\n"");
    err = 1;
}
arg_h = vpi_scan(arg_itr); /* get handle for second tfarg */
tfarg_type = vpi_get(vpiType, arg_h);
if ((tfarg_type != vpiReg) &&
    (tfarg_type != vpiIntegerVar) &&
    (tfarg_type != vpiTimeVar)) {
    vpi_printf(""$read_stimulus_?? arg 2 must be a register type\n"");
    err = 1;
}
if (vpi_scan(arg_itr) != NULL) {
    vpi_printf(""$read_stimulus_?? requires only 2 arguments\n"");
    vpi_free_object(arg_itr);
    err = 1;
}
if (err)
    tf_dofinish();

/* setup a callback for start of simulation */
cb_data_s.reason = cbStartOfSimulation;
cb_data_s.cb_rtn = PLIbook_StartOfSim;
cb_data_s.obj = NULL;
cb_data_s.time = NULL;
cb_data_s.value = NULL;
cb_data_s.user_data = (char *)systf_h; /* pass systf_h to callback */
vpi_register_cb(&cb_data_s);

return(0);
}

/***********************************************************************
 * callback routine -- registers an immediate callback to the
 * ReadNextStim application.
 ***********************************************************************/
int PLIbook_ReadStim_calltf(char *user_data)
",Verilog PLI code for processing simulation arguments and setting up a callback for the start of simulation.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p220.jpg,True,"The image contains a snippet of Verilog PLI (Programming Language Interface) code. Here is the code as shown in the image:

```c
arg_h = vpi_scan(arg_itr); /* get handle for second tfarg */
tfarg_type = vpi_get(vpiType, arg_h);
if ( (tfarg_type != vpiReg) &&
     (tfarg_type != vpiIntegerVar) &&
     (tfarg_type != vpiTimeVar) ) {
    vpi_printf(""%sread_test_vector arg 2 must be a register type\n"");
    err = 1;
}

if (vpi_scan(arg_itr) != NULL) {
    vpi_printf(""%sread_test_vector requires only 2 arguments\n"");
    vpi_free_object(arg_itr);
    err = 1;
}
if (err)
    tf_dofinish();

/* setup a callback for start of simulation */
cb_data_s.reason     = cbStartOfSimulation;
cb_data_s.cb_rtn     = PLIbook_StartOfSim;
cb_data_s.obj        = NULL;
cb_data_s.time       = NULL;
cb_data_s.value      = NULL;
cb_data_s.user_data  = (char *)systf_h; /* pass sysfl_h to callback */
vpi_register_cb(&cb_data_s);
return(0);
```

```c
/***********************************************************************
 * application calltf routine                                          *
 ***********************************************************************/
int PLIbook_ReadVector_calltf(char *user_data)
{
    s_cb_data            data_s;
    s_vpi_time           time_s;
    s_vpi_value          value_s;
    FILE                 *vector_file;
    PLI_INT32            sysTf_h, arg2_h;
    PLIbook_Data_p       vector_data; /* pointer to a ReadVecData structure */
    char                 vector[1024]; /* fixed vector size, could use malloc'*/

    sysTf_h = vpi_handle(vpiSysTfCall, NULL);

    /* get ReadVecData pointer from a work area for this task instance */
    /* the data in the work area was loaded at the start of simulation */
    vector_data = (PLIbook_Data_p)PLIbook_get_vpivorkarea(sysTf_h);
    vector_file = vector_data->file_ptr;
    arg2_h = vector_data->obj_h;

    /* read next line from the file */
    if ( (fscanf(vector_file, ""%s\n"", vector)) == EOF) {
        vpi_printf(""%sread_test_vector reached End-Of-File\n"");
        fclose(vector_data->file_ptr);
        tf_dofinish();
        return(0);
    }
}
```

This code is used as part of the Verilog PLI to interact with Verilog simulators from C functions. The `vpi_...` functions are PLI library calls for registering callbacks and interacting with the simulation elements. The code includes error checking and handles for Verilog objects."," = vpi_scan(arg_itr); /* get handle for second tfarg */
tfarg_type = vpi_get(vpiType, arg_h);
if ( (tfarg_type != vpiReg) &&
     (tfarg_type != vpiIntegerVar) &&
     (tfarg_type != vpiTimeVar) ) {
    vpi_printf(""%sread_test_vector arg 2 must be a register type\n"");
    err = 1;
}

if (vpi_scan(arg_itr) != NULL) {
    vpi_printf(""%sread_test_vector requires only 2 arguments\n"");
    vpi_free_object(arg_itr);
    err = 1;
}
if (err)
    tf_dofinish();

/* setup a callback for start of simulation */
cb_data_s.reason     = cbStartOfSimulation;
cb_data_s.cb_rtn     = PLIbook_StartOfSim;
cb_data_s.obj        = NULL;
cb_data_s.time       = NULL;
cb_data_s.value      = NULL;
cb_data_s.user_data  = (char *)systf_h; /* pass sysfl_h to callback */
vpi_register_cb(&cb_data_s);
return(0);

*******************************************************************
 * application calltf routine                                          *
 ***********************************************************************/
int PLIbook_ReadVector_calltf(char *user_data)
{
    s_cb_data            data_s;
    s_vpi_time           time_s;
    s_vpi_value          value_s;
    FILE                 *vector_file;
    PLI_INT32            sysTf_h, arg2_h;
    PLIbook_Data_p       vector_data; /* pointer to a ReadVecData structure */
    char                 vector[1024]; /* fixed vector size, could use malloc'*/

    sysTf_h = vpi_handle(vpiSysTfCall, NULL);

    /* get ReadVecData pointer from a work area for this task instance */
    /* the data in the work area was loaded at the start of simulation */
    vector_data = (PLIbook_Data_p)PLIbook_get_vpivorkarea(sysTf_h);
    vector_file = vector_data->file_ptr;
    arg2_h = vector_data->obj_h;

    /* read next line from the file */
    if ( (fscanf(vector_file, ""%s\n"", vector)) == EOF) {
        vpi_printf(""%sread_test_vector reached End-Of-File\n"");
        fclose(vector_data->file_ptr);
        tf_dofinish();
        return(0);
    }
}
","""Example of Verilog Programming Language Interface (PLI) code for handling simulation callbacks and reading test vectors from a file.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p195.jpg,True,"The image contains two snippets of Verilog code. Here is the transcription of both:

Example 8-3:

```verilog
reg [1:0] d,e;
...
begin
  d = 2'b0X;
  case (d)
    2'b00: e = 2'b01;
    2'b01: e = 2'b11;
    2'b10: e = 2'b10;
    2'b11: e = 2'b00;
    default: e = 2'bXX;
  endcase
  $display("" e = %b"",e);
end
```

Example 8-4:

```verilog
reg [1:0] d,e;
...
begin
  case (d)
    2'b00: e = 2'b01;
    2'b01: e = 2'b11;
    2'b10: e = 2'b10;
    default: e = 2'b00;
  endcase
  $display("" e = %b"",e);
end
```

These code examples illustrate the usage of case statements in Verilog.","
reg [1:0] d,e;
...
begin
  d = 2'b0X;
  case (d)
    2'b00: e = 2'b01;
    2'b01: e = 2'b11;
    2'b10: e = 2'b10;
    2'b11: e = 2'b00;
    default: e = 2'bXX;
  endcase
  $display("" e = %b"",e);
end


reg [1:0] d,e;
...
begin
  case (d)
    2'b00: e = 2'b01;
    2'b01: e = 2'b11;
    2'b10: e = 2'b10;
    default: e = 2'b00;
  endcase
  $display("" e = %b"",e);
end
","""Examples of Verilog code demonstrating case statements and X-state handling in RTL simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p546.jpg,True,"Here is the code from the image:

```c
for (i=0; i<=PLIbook_indent; i++)
    io_printf("" "");
io_printf(""%s\n"", *arg);
if (strcmp(*arg, ""-f"") == 0) {
    arg++; /* next arg is address to array of strings */
    PLIbook_ScanCommandLine((char **) *arg);
}
arg++;
PLIbook_indent -= 4; /* decrease text indentation */
return;
```

This code appears to be written in C or a similar language, and it includes a comment indicating that it is part of some routine involving reading command line arguments and potentially dealing with indentation in text output.","i=0; i<=PLIbook_indent; i++)
    io_printf("" "");
io_printf(""%s\n"", *arg);
if (strcmp(*arg, ""-f"") == 0) {
    arg++; /* next arg is address to array of strings */
    PLIbook_ScanCommandLine((char **) *arg);
}
arg++;
PLIbook_indent -= 4; /* decrease text indentation */
return;
","Caption: ""Extract from a textbook on accessing and modifying Verilog object values using ACC (access) routines, listing object types that these routines can interact with.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p118.jpg,True,"Here is the Verilog code from the image:

```verilog
assign frame = frame1 && frame2 && frame3;
assign irdy = irdy1 && irdy2 && irdy3;
assign gnt = !gnt1 || !gnt2 || !gnt3;
assign req = !req1 || !req2 || !req3;
```

These lines appear to be assignment statements used for signal processing or control within a digital system, likely for an arbiter in a computer system as mentioned in the document.","
assign frame = frame1 && frame2 && frame3;
assign irdy = irdy1 && irdy2 && irdy3;
assign gnt = !gnt1 || !gnt2 || !gnt3;
assign req = !req1 || !req2 || !req3;
","""Excerpt from a document discussing SVA simulation methodology and showing example Verilog code for arbiter verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p130.jpg,True,"The image contains two sections of Verilog SystemVerilog Assertion (SVA) code. Here is the written version of the code from the image:

```verilog
property p_sel_trdy_start;
    @(posedge clk) $rose (sel_bit) |-> ##1 trdy ##1 !trdy;
endproperty
```

This Verilog SVA code is defining a property called `p_sel_trdy_start` that specifies a sequence of events relating to the `trdy` signal following a rising edge on a `sel_bit` signal with a certain timing constraint relative to the clock edge.

The second section of code is for another target check but does not include the actual code, just a description:

""Target_chk2: At the end of a transaction, the “sel_bit” signal is de-asserted. One clock cycle after that, the signal “trdy” should be de-asserted.""","
property p_sel_trdy_start;
    @(posedge clk) $rose (sel_bit) |-> ##1 trdy ##1 !trdy;
endproperty
","""Verilog SystemVerilog Assertions (SVA) for Target Verification""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p579.jpg,True,"The image contains text with embedded expressions that appear to relate to Verilog code or a similar hardware description language and the concept of expression sampling. However, there isn't a complete block of code as might be found in a source file. Here are the expressions provided which appear to illustrate the concept discussed in the text:

Example A.10:
```
$sampled(a && s.triggered) = $sampled(a) && $sampled(s.triggered),
```

Example A.11:
```
$sampled(f(a, b)) = f($sampled(a), $sampled(b)).
```

These examples demonstrate how the `$sampled` function might be used in the context of expressions involving variables, sequences, and function application within the scope of expression sampling in Verilog or a related simulation context.","ed(a && s.triggered) = $sampled(a) && $sampled(s.triggered),

ed(f(a, b)) = f($sampled(a), $sampled(b)).
","""Exploring the nuances of expression sampling in Verilog with example code and discussion on variable sampling methodology.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p208.jpg,True,"The image includes a sample of Verilog code. Here it is:

```verilog
always @(posedge clock)
  $read_test_vector(""A.dat"", data_bus);

always @(negedge clock)
  $read_test_vector(""B.dat"", data_bus);
``` 

This Verilog code represents two process blocks that are triggered on the positive and negative edge of a clock signal, respectively. Each block calls a function (presumably a PLI application) named `$read_test_vector` with a file name and a bus signal as arguments.","
always @(posedge clock)
  $read_test_vector(""A.dat"", data_bus);

always @(negedge clock)
  $read_test_vector(""B.dat"", data_bus);
","This image is a page from ""The Verilog PLI Handbook, Part One"", detailing techniques for storing multiple values in the PLI application work area, and includes an example of Verilog code.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p213.jpg,True,"The image contains a section of text describing the use of randomization in SystemVerilog along with a sample of SystemVerilog code. Here is the code snippet from the image:

```verilog
class Packet;
  // The random variables
  rand bit [31:0] src, dst, data[8];
  randc bit [ 7:0] kind;
  // Limit the values for src
  constraint c {src > 10;
                src < 15;}
endclass

Packet p;
initial begin
  p = new(); // Create a packet
  if (!p.randomize())
    $finish;
  transmit(p);
end
``` 

This code snippet defines a simple class with random variables and constraints, and illustrates how to create, randomize, and use an instance of that class.","
class Packet;
  // The random variables
  rand bit [31:0] src, dst, data[8];
  randc bit [ 7:0] kind;
  // Limit the values for src
  constraint c {src > 10;
                src < 15;}
endclass

Packet p;
initial begin
  p = new(); // Create a packet
  if (!p.randomize())
    $finish;
  transmit(p);
end
","Caption: ""An excerpt from a textbook showing a section on Randomization in SystemVerilog with an example of a simple packet class with random variables and constraints.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p31.jpg,True,"```verilog
typedef enum logic[1:0] {
  txa_data = 2'b10, txa_control = 2'b01,
  txa_void = 2'b00, txa_forbid = 2'b11 } txa_t;
typedef logic [5:0] tag_t;
typedef logic [23:0] data_t;
typedef struct packed { txa_t txa; tag_t tag; data_t data; } packet_t;
typedef struct packed { logic ack_received; tag_t tag; } ack_t;
checker spec (
  packet_t tx_packet, // Packet to be transmitted
  packet_t rx_packet, // Last received packet
  logic sent,         // Packet sent
  ack_t ack,          // Acknowledge
  logic timeout,      // Timeout active
  logic err,          // Error signal
  event clk,          // System clock
  logic rst           // Reset
);
default clocking @clk; endclocking
default disable iff rst;
// Legal transaction type
// Legal txa_t(tx_a) = txa != txa_forbid;
// Non-void packet sent
// packet_sent = sent && tx_packet.txa != txa_void;
// Right acknowledgment received
// right_ack = ack.ack_received && ack.tag == tx_packet.tag;
// Transmitted packet is always legal
tx_packet_legal: assert property (legal_txa(tx_packet.txa))
  else $error(""Transmitted packet is malformed"");
// Received packet is always legal
rx_packet_legal: assert property (legal_txa(rx_packet.txa))
  else $error(""Received packet is malformed"");
// No acknowledgment thrice
sequence no_ack_thrice;
  (!right_ack[+] ##1 timeout)[*3];
endsequence
// Despair - raise error flag
no_ack: assert property (packet_sent ##1 no_ack_thrice |-> always err) else $error(""Err indication does not persist"");
endchecker : spec
```","
typedef enum logic[1:0] {
  txa_data = 2'b10, txa_control = 2'b01,
  txa_void = 2'b00, txa_forbid = 2'b11 } txa_t;
typedef logic [5:0] tag_t;
typedef logic [23:0] data_t;
typedef struct packed { txa_t txa; tag_t tag; data_t data; } packet_t;
typedef struct packed { logic ack_received; tag_t tag; } ack_t;
checker spec (
  packet_t tx_packet, // Packet to be transmitted
  packet_t rx_packet, // Last received packet
  logic sent,         // Packet sent
  ack_t ack,          // Acknowledge
  logic timeout,      // Timeout active
  logic err,          // Error signal
  event clk,          // System clock
  logic rst           // Reset
);
default clocking @clk; endclocking
default disable iff rst;
// Legal transaction type
// Legal txa_t(tx_a) = txa != txa_forbid;
// Non-void packet sent
// packet_sent = sent && tx_packet.txa != txa_void;
// Right acknowledgment received
// right_ack = ack.ack_received && ack.tag == tx_packet.tag;
// Transmitted packet is always legal
tx_packet_legal: assert property (legal_txa(tx_packet.txa))
  else $error(""Transmitted packet is malformed"");
// Received packet is always legal
rx_packet_legal: assert property (legal_txa(rx_packet.txa))
  else $error(""Received packet is malformed"");
// No acknowledgment thrice
sequence no_ack_thrice;
  (!right_ack[+] ##1 timeout)[*3];
endsequence
// Despair - raise error flag
no_ack: assert property (packet_sent ##1 no_ack_thrice |-> always err) else $error(""Err indication does not persist"");
endchecker : spec
","""Excerpt from a textbook showing a Verilog system specification with a focus on types, assertions, and sequences.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p207.jpg,True,"The image contains Verilog code defining classes for printing utilities as well as a memory transaction class with an incomplete function that needs to be filled in. Here is the Verilog code from the image:

```verilog
class PrintUtilities;

    function void print_4(input string name,
                          input [3:0] val_4bits);
        $display(""%t: %s = %h"", $time, name, val_4bits);
    endfunction

    function void print_8(input string name,
                          input [7:0] val_8bits);
        $display(""%t: %s = %h"", $time, name, val_8bits);
    endfunction

endclass

class MemTrans;
    bit [7:0] data_in;
    bit [3:0] address;
    PrintUtilities print;

    function new();
        print = new();
    endfunction

    function void print_all;
        // Fill in function body
    endfunction

endclass
```

The `print_all` function is meant to be completed to print out `data_in` and `address` using the `PrintUtilities` class. However, the exact implementation of that function is not provided in the image.","
class PrintUtilities;

    function void print_4(input string name,
                          input [3:0] val_4bits);
        $display(""%t: %s = %h"", $time, name, val_4bits);
    endfunction

    function void print_8(input string name,
                          input [7:0] val_8bits);
        $display(""%t: %s = %h"", $time, name, val_8bits);
    endfunction

endclass

class MemTrans;
    bit [7:0] data_in;
    bit [3:0] address;
    PrintUtilities print;

    function new();
        print = new();
    endfunction

    function void print_all;
        // Fill in function body
    endfunction

endclass
",Verilog OOP Exercise: Implementing and using a print utility class.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p25.jpg,True,"The image contains two segments of Verilog code. Here they are transcribed:

First module:
```verilog
module reqgranted1(input logic req, grant, clk);
    bit [2:0] ctr = '0';
    always @(posedge clk) begin
        if (req) ctr <= 1;
        else if (ctr > 0 && ctr < 4) ctr <= ctr + 1;
        else if (ctr == 4) begin 
            if (!grant) $display(""Request not granted."");
        ctr <= '0';
        end
    end
endmodule : reqgranted1
```

Second module:
```verilog
module reqgranted2(input logic req, grant, clk);
    bit [3:0] sreg = '0';
    always @(posedge clk) begin
        sreg <= {sreg[2:0], req};
        if (sreg[3] && !grant) $display(""Request not granted."");
    end
endmodule : reqgranted2
```","
module reqgranted1(input logic req, grant, clk);
    bit [2:0] ctr = '0';
    always @(posedge clk) begin
        if (req) ctr <= 1;
        else if (ctr > 0 && ctr < 4) ctr <= ctr + 1;
        else if (ctr == 4) begin 
            if (!grant) $display(""Request not granted."");
        ctr <= '0';
        end
    end
endmodule : reqgranted1


module reqgranted2(input logic req, grant, clk);
    bit [3:0] sreg = '0';
    always @(posedge clk) begin
        sreg <= {sreg[2:0], req};
        if (sreg[3] && !grant) $display(""Request not granted."");
    end
endmodule : reqgranted2
","""Examples of Verilog Code for Checking Request-Grant Evaluations in Digital Design""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p124.jpg,True,"The image contains Verilog code related to SystemVerilog Assertions (SVA), specifically used for simulation methodology. Here's the code from the image:

```verilog
// SVA SIMULATION METHODOLOGY

// Master design description

// SVA property description

// SVA Checks

always@(posedge clk)
begin
    if(master_sva)
    begin
        a_master_start1:
            assert property(p_master_start1)
            else if(master_sva_severity) $fatal;
        
        a_master_start2:
            assert property(p_master_start2)
            else if(master_sva_severity) $fatal;

        a_master_stop1:
            assert property(p_master_stop1)
            else if(master_sva_severity) $fatal;

        a_master_stop2:
            assert property(p_master_stop2)
            else if(master_sva_severity) $fatal;

        a_master_data1:
            assert property(p_master_data1)
            else if(master_sva_severity) $fatal;

        a_master_data2:
            assert property(p_master_data2)
            else if(master_sva_severity) $fatal;

        a_master_data01:
            assert property(p_master_data01)
            else if(master_sva_severity) $fatal;
```

This snippet is an example of how to use assertions within an `always` block, triggered on the positive edge of a clock signal `clk`. Each `assert property` is checking a specific SVA property (like `p_master_start1`, `p_master_stop1`, etc.), and if the assertion fails and the `master_sva_severity` condition is true, a fatal error is triggered using `$fatal`.","
// SVA SIMULATION METHODOLOGY

// Master design description

// SVA property description

// SVA Checks

always@(posedge clk)
begin
    if(master_sva)
    begin
        a_master_start1:
            assert property(p_master_start1)
            else if(master_sva_severity) $fatal;
        
        a_master_start2:
            assert property(p_master_start2)
            else if(master_sva_severity) $fatal;

        a_master_stop1:
            assert property(p_master_stop1)
            else if(master_sva_severity) $fatal;

        a_master_stop2:
            assert property(p_master_stop2)
            else if(master_sva_severity) $fatal;

        a_master_data1:
            assert property(p_master_data1)
            else if(master_sva_severity) $fatal;

        a_master_data2:
            assert property(p_master_data2)
            else if(master_sva_severity) $fatal;

        a_master_data01:
            assert property(p_master_data01)
            else if(master_sva_severity) $fatal;
",An excerpt from a document on SVA (SystemVerilog Assertions) Simulation Methodology showing a sample code block with assertions for verification.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p492.jpg,True,"The image contains some Verilog code. Below is the extractable Verilog code snippet:

```verilog
module MemBIST_Top
  Mem Mem_U1
  BIST BIST_U1
  (port map copied
  from Mem_U1)
```

The code snippet is a module definition for `MemBIST_Top` which contains instances of `Mem` and `BIST` modules.

Please note that the text ""(port map copied from Mem_U1)"" is a comment likely describing that the mapping of ports of the `BIST_U1` instance should be replicated from the `Mem_U1` instance. The syntax for the port map is not complete and should be viewed in context for absolute accuracy.","
module MemBIST_Top
  Mem Mem_U1
  BIST BIST_U1
  (port map copied
  from Mem_U1)
","""Guide to implementing BIST (Built-In Self-Test) in a Verilog-based VLSI design with a focus on memory testing and interfacing.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p109.jpg,True,"The image contains a snippet of Verilog code. Here is the code written out:

```verilog
module JerkyComparator
    (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
    
reg[1:0] Adjr;
assign AdjustFreq = Adjr;
reg[1:0] HiCount;             // To count 1's of the PLL clock.
// 
always@(ClockIn, Reset)
    if (Reset=='b1)
        begin
            Adjr = 2'b01; // 2'b01 or 2'b10 are no-change codes.
            HiCount = 'b0;
        end
    else if (PLLClock=='b1)
        HiCount = HiCount + 2'b01;
    else
        begin
            case (HiCount)
                2'b00: Adjr = 2'b11; // Better speed it up.
                2'b01: Adjr = 2'b01; // Seems matched.
                default: Adjr = 2'b00; // Must be too fast.
            endcase
            HiCount = 'b0; // Initialize for next ClockIn edge.
        end
endmodule // JerkyComparator.
```

This Verilog module is named `JerkyComparator`, and it appears to be handling a frequency adjustment mechanism, possibly for a phase-locked loop (PLL) given the inputs `ClockIn`, `PLLClock`, and `Reset`. The actual behavior of the code depends on the `ClockIn`, `Reset`, and `PLLClock` signals, adjusting the `AdjustFreq` output according to the value of `HiCount`.","
module JerkyComparator
    (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
    
reg[1:0] Adjr;
assign AdjustFreq = Adjr;
reg[1:0] HiCount;             // To count 1's of the PLL clock.
// 
always@(ClockIn, Reset)
    if (Reset=='b1)
        begin
            Adjr = 2'b01; // 2'b01 or 2'b10 are no-change codes.
            HiCount = 'b0;
        end
    else if (PLLClock=='b1)
        HiCount = HiCount + 2'b01;
    else
        begin
            case (HiCount)
                2'b00: Adjr = 2'b11; // Better speed it up.
                2'b01: Adjr = 2'b01; // Seems matched.
                default: Adjr = 2'b00; // Must be too fast.
            endcase
            HiCount = 'b0; // Initialize for next ClockIn edge.
        end
endmodule // JerkyComparator.
",Verilog code example of a JerkyComparator module designed for frequency matching with an explanation on blocking assignments.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p121.jpg,True,"The image contains snippets of Verilog code. Here are the code excerpts from the image:

First code snippet:
```verilog
always@(Reset, SampleCmd, VFO_ClockOut)
if (Reset=='b1)
begin
    BaseDelay      = 'VFOBaseDelay;
    VFO_Delta      = 'VFO_DelayDelta;
    VFO_MaxDelta   = 'VFO_MaxDelta;
    VFO_Delay      = 'VFOBaseDelay;
    VFO_ClockOut   = 1'b0;
end
else (below)
```

Second code snippet:
```verilog
else // as above.
if (SampleCmd == 'b1)
begin
    if ( AdjustFreq2>'b01
      && (BaseDelay - VFO_MaxDelta < VFO_Delay) )
        // If floor is lower than current:
        VFO_Delay = VFO_Delay - VFO_Delta;
    else if (AdjustFreq<'b01
      && (fill this in)
    // else, leave VFO_Delay alone.
end
```

Third code snippet:
```verilog
always@(Reset, SampleCmd, VFO_ClockOut)
if (Reset=='b1)
    ... (as above) ...
else begin
    ... (freq. adjustments) ...
    `ifdef DC
    // No delayed nonblocking assignments:
    //VFO_Delay VFO_ClockOut = ~VFO_ClockOut;
    `else
    VFO_Delay VFO_ClockOut <= ~VFO_ClockOut;
    `endif
end // main else.
```

There are placeholders in the code such as '`VFOBaseDelay;` where you might need to define the actual delays depending on the context this code is used in, and a directive `ifdef DC` that suggests the presence of conditional compilation blocks. Additionally, there is an incomplete condition in the second code snippet marked as ""(fill this in)"" that requires additional context or information to be completed.","
always@(Reset, SampleCmd, VFO_ClockOut)
if (Reset=='b1)
begin
    BaseDelay      = 'VFOBaseDelay;
    VFO_Delta      = 'VFO_DelayDelta;
    VFO_MaxDelta   = 'VFO_MaxDelta;
    VFO_Delay      = 'VFOBaseDelay;
    VFO_ClockOut   = 1'b0;
end
else (below)


else // as above.
if (SampleCmd == 'b1)
begin
    if ( AdjustFreq2>'b01
      && (BaseDelay - VFO_MaxDelta < VFO_Delay) )
        // If floor is lower than current:
        VFO_Delay = VFO_Delay - VFO_Delta;
    else if (AdjustFreq<'b01
      && (fill this in)
    // else, leave VFO_Delay alone.
end


always@(Reset, SampleCmd, VFO_ClockOut)
if (Reset=='b1)
    ... (as above) ...
else begin
    ... (freq. adjustments) ...
    `ifdef DC
    // No delayed nonblocking assignments:
    //VFO_Delay VFO_ClockOut = ~VFO_ClockOut;
    `else
    VFO_Delay VFO_ClockOut <= ~VFO_ClockOut;
    `endif
end // main else.
","""Excerpt from an educational document showing Verilog code for a reset block and partial implementation of frequency adjustment in a voltage-controlled oscillator (VCO) design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p282.jpg,True,"The image contains Verilog code. Here it is:

```
P3: assert property (@(posedge clk) a |-> b |-> c);
P3: assert property (@(posedge clk) a ##0 b |-> c);

sequence abc;
  @(posedge clk) a ##1 b ##1 c;
endsequence

sequence abcRule;
  @(posedge clk);
  cycleStart ##1 abc ##1 cycleEnd
endsequence

sequence s1;
  @(posedge clk) a ##1 b ##1 c;
endsequence

sequence s2;
  @(posedge clk) d ##1 e;
endsequence

property s1tos2;
  @(posedge clk) s1 |=> s2;
```

The code is part of a text discussing how sequences can be used within other sequences in Verilog. It also shows how sequences can be used as antecedents or consequents in properties.","sert property (@(posedge clk) a |-> b |-> c);
P3: assert property (@(posedge clk) a ##0 b |-> c);

sequence abc;
  @(posedge clk) a ##1 b ##1 c;
endsequence

sequence abcRule;
  @(posedge clk);
  cycleStart ##1 abc ##1 cycleEnd
endsequence

sequence s1;
  @(posedge clk) a ##1 b ##1 c;
endsequence

sequence s2;
  @(posedge clk) d ##1 e;
endsequence

property s1tos2;
  @(posedge clk) s1 |=> s2;
","""Subsequence in Verilog Assertions: Clock Inference and Usage as Antecedent or Consequent""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p207.jpg,True,"The image contains Verilog code. Here are the code excerpts present:

```verilog
// assert req_valid will never be active high for more than 1 cycle
assert_next_one_req(clk, reset_n, req_valid, !req_valid);
```

```verilog
// declarative assertion
// assert that a cache hit never occurs after an invalidate
assert never ({invalidate; hit}) @ (posedge clk);
```

```verilog
// declarative assertion
// assert cache will not return a hit within 4 cycles after invalidate
assert always ({invalidate} |=> {!hit[*4]}) @ (posedge clk);
``` 

These code snippets are examples of assertions used in hardware verification through Verilog or similar hardware description languages.","
// assert req_valid will never be active high for more than 1 cycle
assert_next_one_req(clk, reset_n, req_valid, !req_valid);


// declarative assertion
// assert that a cache hit never occurs after an invalidate
assert never ({invalidate; hit}) @ (posedge clk);


// declarative assertion
// assert cache will not return a hit within 4 cycles after invalidate
assert always ({invalidate} |=> {!hit[*4]}) @ (posedge clk);
","""Examples of Verilog Assertions for Single Cycle Pulse Check and Cache Invalidate/Hit Sequence Validation""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p296.jpg,True,"The image contains Verilog code. Here it is:

```verilog
assign nxt_rd_ptr = (read_en) ? rd_ptr+1 : rd_ptr;
assign nxt_rd_ptr_gray = (nxt_rd_ptr>>1) ^ nxt_rd_ptr;

// check full
always @ (posedge wclk or negedge wclk_reset_n)
    if (!wclk_reset_n)
        {rd_ptr_gray_wclk_q2, rd_ptr_gray_wclk_q} <= #`FF_DLY
            {{A_WIDTH{1'b0}}, {A_WIDTH{1'b0}}};
    else
        {rd_ptr_gray_wclk_q2, rd_ptr_gray_wclk_q} <= #`FF_DLY
            {rd_ptr_gray_wclk_q, rd_ptr_gray};

assign full_d = (nxt_wr_ptr_gray == {~rd_ptr_gray_wclk_q2[A_WIDTH:A_WIDTH-1], rd_ptr_gray_wclk_q2[A_WIDTH-2:0]});

always @ (posedge wclk or negedge wclk_reset_n)
    if (!wclk_reset_n)
        full <= #`FF_DLY 1'b0;
    else
        full <= #`FF_DLY full_d;

// check empty
always @ (posedge rclk or negedge rclk_reset_n)
    if (!rclk_reset_n)
        {wr_ptr_gray_rclk_q2, wr_ptr_gray_rclk_q} <= #`FF_DLY
            {{A_WIDTH{1'b0}}, {A_WIDTH{1'b0}}};
    else
        {wr_ptr_gray_rclk_q2, wr_ptr_gray_rclk_q} <= #`FF_DLY
            {wr_ptr_gray_rclk_q, wr_ptr_gray};

assign empty_d = (nxt_rd_ptr_gray == wr_ptr_gray_rclk_q2);

always @ (posedge rclk or negedge rclk_reset_n)
    if (!rclk_reset_n)
        empty <= #`FF_DLY 1'b1;
    else
        empty <= #`FF_DLY empty_d;
        
endmodule
```

This is a snippet of a module in Verilog that seems to include logic for managing full and empty conditions in an asynchronous FIFO (First-In First-Out) queue. The `always` blocks are sensitive to the positive edge of a clock signal or the negative edge of a reset signal. The code also uses non-blocking assignments with delays in the form `#`FF_DLY`, where `FF_DLY` is likely a parameter or macro previously defined to represent a delay cycle used for synchronizing signals.","
assign nxt_rd_ptr = (read_en) ? rd_ptr+1 : rd_ptr;
assign nxt_rd_ptr_gray = (nxt_rd_ptr>>1) ^ nxt_rd_ptr;

// check full
always @ (posedge wclk or negedge wclk_reset_n)
    if (!wclk_reset_n)
        {rd_ptr_gray_wclk_q2, rd_ptr_gray_wclk_q} <= #`FF_DLY
            {{A_WIDTH{1'b0}}, {A_WIDTH{1'b0}}};
    else
        {rd_ptr_gray_wclk_q2, rd_ptr_gray_wclk_q} <= #`FF_DLY
            {rd_ptr_gray_wclk_q, rd_ptr_gray};

assign full_d = (nxt_wr_ptr_gray == {~rd_ptr_gray_wclk_q2[A_WIDTH:A_WIDTH-1], rd_ptr_gray_wclk_q2[A_WIDTH-2:0]});

always @ (posedge wclk or negedge wclk_reset_n)
    if (!wclk_reset_n)
        full <= #`FF_DLY 1'b0;
    else
        full <= #`FF_DLY full_d;

// check empty
always @ (posedge rclk or negedge rclk_reset_n)
    if (!rclk_reset_n)
        {wr_ptr_gray_rclk_q2, wr_ptr_gray_rclk_q} <= #`FF_DLY
            {{A_WIDTH{1'b0}}, {A_WIDTH{1'b0}}};
    else
        {wr_ptr_gray_rclk_q2, wr_ptr_gray_rclk_q} <= #`FF_DLY
            {wr_ptr_gray_rclk_q, wr_ptr_gray};

assign empty_d = (nxt_rd_ptr_gray == wr_ptr_gray_rclk_q2);

always @ (posedge rclk or negedge rclk_reset_n)
    if (!rclk_reset_n)
        empty <= #`FF_DLY 1'b1;
    else
        empty <= #`FF_DLY empty_d;
        
endmodule
","""Verilog code snippet showing the implementation of full and empty flags in an asynchronous FIFO design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p135.jpg,True,"The image contains Verilog code for a simple RAM model. Below is the code written in the image:

```verilog
module RAM (output[7:0] Obus
           , input[7:0] Ibus
           , input[3:0] Adr, input Clk, Read
           );

reg[7:0] Storage[15:0];
reg[7:0] ObusReg;
// ...
assign #1 Obus = ObusReg;
// ...
always @(posedge Clk)
    if (Read=='b0)
        Storage[Adr] <= Ibus;
    else
        ObusReg <= Storage[Adr];
endmodule
```

This code defines a simple RAM module with an 8-bit data bus, 4-bit address, and control signals for the clock and read operation. The RAM storage is implemented as an array of 16 8-bit registers. The module can perform read or write operations based on the `Read` signal at the rising edge of the clock (`Clk`).","
module RAM (output[7:0] Obus
           , input[7:0] Ibus
           , input[3:0] Adr, input Clk, Read
           );

reg[7:0] Storage[15:0];
reg[7:0] ObusReg;
// ...
assign #1 Obus = ObusReg;
// ...
always @(posedge Clk)
    if (Read=='b0)
        Storage[Adr] <= Ibus;
    else
        ObusReg <= Storage[Adr];
endmodule
","""Excerpt from a Digital VLSI Design textbook showing an example of a simple RAM model written in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p223.jpg,True,"The image contains Verilog code, and I'll write it out for you:

```verilog
int data [4]; // array of 4 integers

initial begin
    `ifdef VENDOR_A
        data = '{0, 1, 2, 3}; // IEEE 1800 list of values
    `else
        data = {0, 1, 2, 3}; // old SV 3.1a list of values
    `endif
...
end
```","
int data [4]; // array of 4 integers

initial begin
    `ifdef VENDOR_A
        data = '{0, 1, 2, 3}; // IEEE 1800 list of values
    `else
        data = {0, 1, 2, 3}; // old SV 3.1a list of values
    `endif
...
end
","""Excerpt from a book discussing tool compatibility issues in Verilog/SystemVerilog and demonstrating the use of conditional compilation to handle different syntax versions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p269.jpg,True,"```verilog
sequence cde;
  c ##1 d ##1 e;
endsequence

property nots;
  @(posedge clk) (a, tdisp1) |-> (!not(cde,tdisp1));
endproperty

baseP: assert property (nots) else gotoFail;

sequence cde;
  c ##1 d ##1 e{tdisp1};
endsequence

task tdisp1;
  $display($stime,,"" %m c=%b d=%b e=%b"",c,d,e);
endtask
```","
sequence cde;
  c ##1 d ##1 e;
endsequence

property nots;
  @(posedge clk) (a, tdisp1) |-> (!not(cde,tdisp1));
endproperty

baseP: assert property (nots) else gotoFail;

sequence cde;
  c ##1 d ##1 e{tdisp1};
endsequence

task tdisp1;
  $display($stime,,"" %m c=%b d=%b e=%b"",c,d,e);
endtask
","Caption: ""Illustration of how to call subroutines in Verilog code, with an example of attaching a display task to expressions and sequences.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p332.jpg,True,"```verilog
module sig_sva (a, b, clk);

// include the parameter definitions
```","
module sig_sva (a, b, clk);

// include the parameter definitions
","A Verilog code snippet with a list of parameters and their functionalities for checking a system using stimulus generation, alongside an excerpt showing the beginning of a SystemVerilog Assertions (SVA) module definition.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p241.jpg,True,"The image contains code written in SystemVerilog which is a hardware description and verification language. Here is the code depicted in the image:

```verilog
sequence aRb(aFell,bRose);
    @(posedge clk) sFell(aFell) ##1 sRose(bRose);
endsequence

property endCycle;
    @(posedge clk) $rose(c) |-> @(posedge clk) aRb(a,b).matched;
endproperty
base: assert property (endCycle) else gotoFail;
```","
sequence aRb(aFell,bRose);
    @(posedge clk) sFell(aFell) ##1 sRose(bRose);
endsequence

property endCycle;
    @(posedge clk) $rose(c) |-> @(posedge clk) aRb(a,b).matched;
endproperty
base: assert property (endCycle) else gotoFail;
","""Understanding the .matched operator in Verilog Assertions with example code and timing diagram.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p255.jpg,True,"The image contains a snippet of Verilog code in it. Here's the code as displayed in the image:

```verilog
property TxData_stable;
    @(posedge TxClk) $changed(TxData) |-> $stable(TxData) [*2];
endproperty

assert property (TxData_stable);
```

This code defines a property `TxData_stable` for use in formal verification, to assert that the `TxData` signal remains stable for two clock cycles after a change is detected at the positive edge of the clock signal `TxClk`.","
property TxData_stable;
    @(posedge TxClk) $changed(TxData) |-> $stable(TxData) [*2];
endproperty

assert property (TxData_stable);
","""Clock Domain Crossing Verification in Verilog using Assertions and Timing Diagrams""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p326.jpg,True,"```
repeat ((i-1)) @(posedge clk);
b<= ~b;
repeat(1) @(posedge clk);
b<= ~b;
end
```"," ((i-1)) @(posedge clk);
b<= ~b;
repeat(1) @(posedge clk);
b<= ~b;
end
","""Example of Verilog testbench code demonstrating signal repetition and timing checks, along with timing diagrams.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p778.jpg,True,"The image contains text and snippets of code related to the Verilog Programming Language Interface (PLI). Here is the code that is visible in the image:

```c
void acc_vcl_add(object, consumer, user_data, vcl_flag)
handle object;                /* handle for a net, register, event, port, primitive output terminal or primitive inout terminal. */
int *consumer;                /* unquoted name of a C consumer routine. */
char *user_data;              /* user-defined data value. */
int vcl_flag;                 /* constant: vcl_verilog_logic, vcl_verilog_strength. */

/* Adds a vc_record structure, which contains information about the change. */

typedef struct t_vc_record {
    int vc_reason;             /* one of: logic_value_change,
                                           strength_value_change,
                                           vector_value_change,
                                           sregister_value_change,
                                           vregister_value_change,
                                           integer_value_change,
                                           real_value_change,
                                           time_value_change,
                                           event_value_change */

    int vc_hightime;          /* upper 32-bits of sim. time */
    int vc_lowtime;           /* lower 32-bits of sim. time */
    char *user_data;          /* value passed to acc_vcl_add() */
    union {
        unsigned char logic_value;   /* for logic_value_change;
                                         one of: vc10, vc11,
                                                 vc1Z, vc1X */
        double real_value;           /* for real_value_change */
        handle vector_handle;        /* object that changed for vector_value_change,
                                        vregister_value_change,
                                        integer_value_change,
                                        time_value_change */
        s_strengths strengths_s;     /* strength_value_change */
    } out_value;
} s_vc_record, *p_vc_record;

typedef struct t_strengths {
    unsigned char logic_value;  /* one of: vc10, vc11,
                                            vc1Z, vc1X */
    unsigned char strength1;    /* one of: vc1Supply, */
    unsigned char strength2;    /* vc1Strong, vc1Pull,
                                            vc1Large, vc1Weak,
                                            vc1Medium, vc1Small,
                                            vc1HighZ */
} s_strengths, *p_strengths;
```
This code defines C structures used for interacting with Verilog simulator through the PLI, such as `t_vc_record` and `t_strengths`, as well as a function prototype `void acc_vcl_add()` to add a value change link monitor to a simulated object.","acc_vcl_add(object, consumer, user_data, vcl_flag)
handle object;                /* handle for a net, register, event, port, primitive output terminal or primitive inout terminal. */
int *consumer;                /* unquoted name of a C consumer routine. */
char *user_data;              /* user-defined data value. */
int vcl_flag;                 /* constant: vcl_verilog_logic, vcl_verilog_strength. */

/* Adds a vc_record structure, which contains information about the change. */

typedef struct t_vc_record {
    int vc_reason;             /* one of: logic_value_change,
                                           strength_value_change,
                                           vector_value_change,
                                           sregister_value_change,
                                           vregister_value_change,
                                           integer_value_change,
                                           real_value_change,
                                           time_value_change,
                                           event_value_change */

    int vc_hightime;          /* upper 32-bits of sim. time */
    int vc_lowtime;           /* lower 32-bits of sim. time */
    char *user_data;          /* value passed to acc_vcl_add() */
    union {
        unsigned char logic_value;   /* for logic_value_change;
                                         one of: vc10, vc11,
                                                 vc1Z, vc1X */
        double real_value;           /* for real_value_change */
        handle vector_handle;        /* object that changed for vector_value_change,
                                        vregister_value_change,
                                        integer_value_change,
                                        time_value_change */
        s_strengths strengths_s;     /* strength_value_change */
    } out_value;
} s_vc_record, *p_vc_record;

typedef struct t_strengths {
    unsigned char logic_value;  /* one of: vc10, vc11,
                                            vc1Z, vc1X */
    unsigned char strength1;    /* one of: vc1Supply, */
    unsigned char strength2;    /* vc1Strong, vc1Pull,
                                            vc1Large, vc1Weak,
                                            vc1Medium, vc1Small,
                                            vc1HighZ */
} s_strengths, *p_strengths;
","""Excerpt from the Verilog PLI Handbook detailing the acc_vcl_add function and associated data structures for value change linkage in Verilog simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p84.jpg,True,"The image includes two pieces of example code which seem to relate to the Verilog Procedural Interface (VPI), a standard interface used to link Verilog HDL simulators with C programs, such as hardware verification tools.

Here are the code snippets:

1.

```c
int vpi_free_object(object)
vpiHandle object; /* handle for an object. */
```

2.

```c
int vpi_printf(format, arg1,...,argn)
char *format; /* quoted character string of formatted message. */
arg1...argn; /* arguments to formatted message string. */
```

The first function, `vpi_free_object`, is described as a routine to release memory allocated for a VPI iterator object. The second function, `vpi_printf`, is for printing messages from PLI applications, akin to the C `printf` function but with simulator-specific behavior regarding output.","pi_free_object(object)
vpiHandle object; /* handle for an object. */

pi_printf(format, arg1,...,argn)
char *format; /* quoted character string of formatted message. */
arg1...argn; /* arguments to formatted message string. */
","""Verilog PLI Handbook excerpt discussing memory management functions and message printing in VPI applications""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p234.jpg,True,"The image contains Verilog code for defining modules and their interconnects. Here's the code:

```verilog
module b_c(i, j);
    input [7:0] i, j;
    output [7:0] o;
    wire [7:0] o;
    assign o = i | j;
endmodule // b_c

module b_d(i, j);
    input [7:0] i, j;
    output [7:0] o;
    wire [7:0] o;
    assign o = i & j;
endmodule // b_d

module b (p, w, x, y, z);
    input [7:0] w, x, y, z;
    output [7:0] p;
    wire [7:0] p, r, s;

    b_c c1(r, w, x, y, z);
    b_c c2(s, x, z);
    b_d d0(p, r, s);
endmodule // b
```

The code example describes two submodules `b_c` and `b_d` performing bitwise OR and AND operations, respectively, on 8-bit input vectors `i` and `j`. The main module `b` uses these submodules to compute a result `p` from inputs `w`, `x`, `y`, and `z`.","
module b_c(i, j);
    input [7:0] i, j;
    output [7:0] o;
    wire [7:0] o;
    assign o = i | j;
endmodule // b_c

module b_d(i, j);
    input [7:0] i, j;
    output [7:0] o;
    wire [7:0] o;
    assign o = i & j;
endmodule // b_d

module b (p, w, x, y, z);
    input [7:0] w, x, y, z;
    output [7:0] p;
    wire [7:0] p, r, s;

    b_c c1(r, w, x, y, z);
    b_c c2(s, x, z);
    b_d d0(p, r, s);
endmodule // b
","""Example of multi-bit interconnect and behavior in Verilog HDL, showcasing module declarations and bit-width specifications.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p181.jpg,True,"```c
int PLIbook_ReadNextStim()
{
    ...
    s_vpi_time time_s;
    s_vpi_value value_s;

    /* obtain system task handle and Verilog vector handle */
    ...
}
```","LIbook_ReadNextStim()
{
    ...
    s_vpi_time time_s;
    s_vpi_value value_s;

    /* obtain system task handle and Verilog vector handle */
    ...
}
","""Excerpt from a textbook explaining the steps for reading and modifying values using Verilog Procedural Interface (VPI) routines, with a code snippet demonstrating the initialization of time and value structures.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p196.jpg,True,"The image contains a section from a document that explains the syntax of property declarations in Verilog. There is code in the image, which is presented as an example. Here is the Verilog code from the image:

```verilog
module m;
  bit clock, reset, a, b, c, d;
  default clocking @(posedge clock); endclocking
  ...
  property p1(bit rst, event clk = $inferred_clock, untyped x, property p);
    disable iff (rst) @clk |-> ##1 x |-> p;
  endproperty

  property p2;
    a |-> (b until c);
  endproperty

  a_imply: assert property(p1(.rst(reset), .x(d), .p(p2)));
  ...
endmodule
``` 

This Verilog code snippet is meant to illustrate how property declarations work within a module. It includes a module `m` with `bit` definitions, a `default clocking` statement, two property declarations `p1` and `p2`, and an assert statement using those properties.","
module m;
  bit clock, reset, a, b, c, d;
  default clocking @(posedge clock); endclocking
  ...
  property p1(bit rst, event clk = $inferred_clock, untyped x, property p);
    disable iff (rst) @clk |-> ##1 x |-> p;
  endproperty

  property p2;
    a |-> (b until c);
  endproperty

  a_imply: assert property(p1(.rst(reset), .x(d), .p(p2)));
  ...
endmodule
","The image displays a textbook page discussing the syntax and semantics of property declarations in Verilog, along with an example Verilog module that uses assertions to verify properties.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p195.jpg,True,"The image contains a snippet of C code related to Verilog Programming Interface (VPI) routines. Here's the code:

```c
int PLIbook_ReadDelays_calltf(char *user_data)
{
    vpiHandle systf_h, arg_itr, mod_h, path_itr, path_h;

    /* obtain a handle to the system task instance */
    systf_h = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handle to system task argument; */
    /* complaint has already verified only 1 arg with correct type */
    arg_itr = vpi_iterate(vpiArgument, systf_h);
    mod_h = vpi_scan(arg_itr);
    vpi_free_object(arg_itr); /* free iterator--did not scan to null */

    vpi_printf(""\nModule %s paths:\n"", vpi_get_str(vpiDefName, mod_h));
    path_itr = vpi_iterate(vpiModPath, mod_h);
    if (path_itr != NULL)
    {
        while ((path_h = vpi_scan(path_itr)) != NULL) {
            PLIbook_PrintDelays(path_h);
        }
    }
    else
    {
        vpi_printf("" No path delays found.\n"");
    }
    return(0);
}

void PLIbook_PrintDelays(vpiHandle modpath_h)
{
    char *path_name; /* pointer to path name string */
    s_vpi_delay delay_struct; /* structure to setup delays */
    s_vpi_time delay_array[6]; /* structure to receive delays */

    delay_struct.da = delay_array;
    delay_struct.no_of_delays = 2;
    delay_struct.time_type = vpiScaledRealTime;
    delay_struct.mtm_flag = 1;
    delay_struct.append_flag = 0;
    delay_struct.pulsere_flag = 0;

    vpi_get_delays(modpath_h, &delay_struct);
    path_name = PLIbook_BuildPathName(modpath_h);
}
```

Please note that the code seems to deal with reading and printing delays in Verilog modules. It is using Verilog Procedural Interface (VPI) routines, which are typically used to interface C code with Verilog simulations.","LIbook_ReadDelays_calltf(char *user_data)
{
    vpiHandle systf_h, arg_itr, mod_h, path_itr, path_h;

    /* obtain a handle to the system task instance */
    systf_h = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handle to system task argument; */
    /* complaint has already verified only 1 arg with correct type */
    arg_itr = vpi_iterate(vpiArgument, systf_h);
    mod_h = vpi_scan(arg_itr);
    vpi_free_object(arg_itr); /* free iterator--did not scan to null */

    vpi_printf(""\nModule %s paths:\n"", vpi_get_str(vpiDefName, mod_h));
    path_itr = vpi_iterate(vpiModPath, mod_h);
    if (path_itr != NULL)
    {
        while ((path_h = vpi_scan(path_itr)) != NULL) {
            PLIbook_PrintDelays(path_h);
        }
    }
    else
    {
        vpi_printf("" No path delays found.\n"");
    }
    return(0);
}

void PLIbook_PrintDelays(vpiHandle modpath_h)
{
    char *path_name; /* pointer to path name string */
    s_vpi_delay delay_struct; /* structure to setup delays */
    s_vpi_time delay_array[6]; /* structure to receive delays */

    delay_struct.da = delay_array;
    delay_struct.no_of_delays = 2;
    delay_struct.time_type = vpiScaledRealTime;
    delay_struct.mtm_flag = 1;
    delay_struct.append_flag = 0;
    delay_struct.pulsere_flag = 0;

    vpi_get_delays(modpath_h, &delay_struct);
    path_name = PLIbook_BuildPathName(modpath_h);
}
",Verilog VPI Routines Example: Reading Module Path Delays,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p182.jpg,True,"The image contains Verilog code. Here is the code extracted from the image:

First block:
```verilog
module m;
logic clk, a, b, c, d;
always @(posedge clk) begin: B1
    a <= c || d;
    b <= a;
end
assign c = c || d;
assign d = b;
endmodule
```

Second block:
```verilog
`define macro_exp a && b
module m;
logic clk, a, b, c, d;
always @(posedge clk) begin
`define macro_exp c || d
    a <= `macro_exp;
    b <= a;
`undef macro_exp
`define macro_exp a && b
end
assign c = `macro_exp;
assign d = b;
endmodule
```","
module m;
logic clk, a, b, c, d;
always @(posedge clk) begin: B1
    a <= c || d;
    b <= a;
end
assign c = c || d;
assign d = b;
endmodule


`define macro_exp a && b
module m;
logic clk, a, b, c, d;
always @(posedge clk) begin
`define macro_exp c || d
    a <= `macro_exp;
    b <= a;
`undef macro_exp
`define macro_exp a && b
end
assign c = `macro_exp;
assign d = b;
endmodule
","""Exploring the Differences in Scoping and Substitution between `let` Declarations and Macros in Verilog Code""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p90.jpg,True,"The image includes a portion of Verilog code and some related text. Here is the Verilog code provided in the image:

```verilog
vpiHandle module_handle;
s_vpi_time current_time;

current_time.type = vpiScaledRealTime;
vpi_get_time(module_handle, &current_time);
vpi_printf(""\nAt time %2.f, nets in module %s (%s):\n"", current_time.real,
           vpi_get_str(vpiFullName, module_handle),
           vpi_get_str(vpiDefName, module_handle));
```

This code seems to be used for retrieving and printing the current simulation time using the `vpi_get_time()` function in a Verilog PLI (Programming Language Interface) application.","
vpiHandle module_handle;
s_vpi_time current_time;

current_time.type = vpiScaledRealTime;
vpi_get_time(module_handle, &current_time);
vpi_printf(""\nAt time %2.f, nets in module %s (%s):\n"", current_time.real,
           vpi_get_str(vpiFullName, module_handle),
           vpi_get_str(vpiDefName, module_handle));
","Caption: ""Excerpt from The Verilog PLI Handbook detailing the retrieval of simulation time using VPI routines in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p208.jpg,True,"The image contains Verilog code. Here is the content:

```verilog
always
begin
    @(posedge ck);
    e1 <=2'b00;
    @(posedge ck);
    e1 <=2'b01;
    @(posedge ck);
    e1 <=2'b11;
    @(posedge ck);
    e1 <=2'b10;
end
```","
always
begin
    @(posedge ck);
    e1 <=2'b00;
    @(posedge ck);
    e1 <=2'b01;
    @(posedge ck);
    e1 <=2'b11;
    @(posedge ck);
    e1 <=2'b10;
end
","Caption: ""Page from a textbook showing an example of Verilog code for edge-triggered behavior using always blocks, with a discussion on implicit state machines and initial blocks in RTL design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p490.jpg,True,"The image contains Verilog code associated with a covergroup for PCI commands. Here is the code transcribed from the image:

```verilog
// PCI C/BE Commands
enum {jack, SpecialC, IORead, IOWrite, MemRead, MemWrite, ConfRead, ConfWrite, MemRMWt, DualAddr, MemReadLine, MemWrInv} pciCommands;

covergroup pciCommands_cover @(posedge clk);
    pciCmdCover : coverpoint pciCommands
    {
        bins picreads [] = {IORead, MemRead, ConfRead, MemRMult, MemReadLine};
        bins picwrites [] = {IOWrite, MemWrite, ConfWrite, MemWrInv};
        bins misc [] = {jack, SpecialC};

        bins R2W [] = (IORead, MemRead, ConfRead, MemRMult, MemReadLine => IOWrite, MemWrite, ConfWrite, MemWrInv);
        bins WR2 [] = (IOWrite, MemWrite, ConfWrite, MemWrInv => IORead, MemRead, ConfRead, MemRMult, MemReadLine);
    }
endgroup
```

This code defines an `enum` for PCI commands and a `covergroup` that is set to trigger at the positive edge of the `clk` signal. The `covergroup` includes various `coverpoints` with bins that categorize the different types of PCI command operations and transitions for coverage analysis.","
// PCI C/BE Commands
enum {jack, SpecialC, IORead, IOWrite, MemRead, MemWrite, ConfRead, ConfWrite, MemRMWt, DualAddr, MemReadLine, MemWrInv} pciCommands;

covergroup pciCommands_cover @(posedge clk);
    pciCmdCover : coverpoint pciCommands
    {
        bins picreads [] = {IORead, MemRead, ConfRead, MemRMult, MemReadLine};
        bins picwrites [] = {IOWrite, MemWrite, ConfWrite, MemWrInv};
        bins misc [] = {jack, SpecialC};

        bins R2W [] = (IORead, MemRead, ConfRead, MemRMult, MemReadLine => IOWrite, MemWrite, ConfWrite, MemWrInv);
        bins WR2 [] = (IOWrite, MemWrite, ConfWrite, MemWrInv => IORead, MemRead, ConfRead, MemRMult, MemReadLine);
    }
endgroup
","""Verilog covergroup for PCI Cycle Types and transition coverage example.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p367.jpg,True,"The image contains text related to PSL (Property Specification Language) elements and syntax; it is not Verilog code itself. Here is the transcription of the content:

```
FL_Property )
:
| next_event_a! ( Boolean ) | finite_positive_Range | ( FL_Property )
| next_event_a ( Boolean ) | finite_positive_Range | ( FL_Property )
| next_event_e! ( Boolean ) | finite_positive_Range | ( FL_Property )
| next_event_e ( Boolean ) | finite_positive_Range | ( FL_Property )

: Operators on SEREs (see B.8.3.5)
| Sequence ( FL_Property )
| Sequence |=> FL_Property
| Sequence |-> FL_Property

B.8.3.5 Sequences

Sequence ::= 
{ SERE_or_SequenceInstance } | {@clock_Boolean }
| [ SERE_Element ] ContiguousRepeat
| Boolean IndependentRepeat

SEREorSequenceInstance ::=
SERE
| sequence_Name [ ( Actual_Parameter_List ) ]

ContiguousRepeat ::=
[ * [ Count ] ]
[ [+ ] ]

IndependentRepeat ::=
[ = Count ]
[ -> [ positive_Count ] ]

Count ::=
Number | Range

Range ::=
LowBound RANGE_SYM HighBound

LowBound ::=
Number | MIN_VAL

HighBound ::=
Number | MAX_VAL
```

The text outlines various constructs, operators, and syntax rules used to define sequences and properties in PSL, which is a formal language used to specify properties or assertions about hardware in a temporal context, typically for use in verifying hardware designs. Verilog is a hardware description language, and while PSL is often used alongside HDLs like Verilog or VHDL, the syntax rules presented here are specific to PSL.","perty )
:
| next_event_a! ( Boolean ) | finite_positive_Range | ( FL_Property )
| next_event_a ( Boolean ) | finite_positive_Range | ( FL_Property )
| next_event_e! ( Boolean ) | finite_positive_Range | ( FL_Property )
| next_event_e ( Boolean ) | finite_positive_Range | ( FL_Property )

: Operators on SEREs (see B.8.3.5)
| Sequence ( FL_Property )
| Sequence |=> FL_Property
| Sequence |-> FL_Property

B.8.3.5 Sequences

Sequence ::= 
{ SERE_or_SequenceInstance } | {@clock_Boolean }
| [ SERE_Element ] ContiguousRepeat
| Boolean IndependentRepeat

SEREorSequenceInstance ::=
SERE
| sequence_Name [ ( Actual_Parameter_List ) ]

ContiguousRepeat ::=
[ * [ Count ] ]
[ [+ ] ]

IndependentRepeat ::=
[ = Count ]
[ -> [ positive_Count ] ]

Count ::=
Number | Range

Range ::=
LowBound RANGE_SYM HighBound

LowBound ::=
Number | MIN_VAL

HighBound ::=
Number | MAX_VAL
","""PSL Property Specification Language for Verilog and sequence operators reference.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p285.jpg,True,"The image contains code related to SystemVerilog Assertions (SVA) for protocol interfaces. Here is the code:

```verilog
@(posedge clk)
s_tchk6a.ended ##[1:8] s_tchk6b;
endsequence

property p_tchk6;
@(posedge clk)
s_tchk6.ended |=> s_tchk6c;
endproperty

a_tchk6: assert property(p_tchk6);
c_tchk6: cover property(p_tchk6);

sequence s_tchk6_1;
@(posedge clk)
(!irdyn && !trdyn && !devseln && !framen)
##[1:8] ($fell (stopn) && trdyn && framen);
endsequence

property p_tchk6_1;
@(posedge clk)
s_tchk6_1.ended |=> (irdyn && stopn);
endproperty

a_tchk6_1: assert property(p_tchk6_1);
c_tchk6_1: cover property(p_tchk6_1);
```","
@(posedge clk)
s_tchk6a.ended ##[1:8] s_tchk6b;
endsequence

property p_tchk6;
@(posedge clk)
s_tchk6.ended |=> s_tchk6c;
endproperty

a_tchk6: assert property(p_tchk6);
c_tchk6: cover property(p_tchk6);

sequence s_tchk6_1;
@(posedge clk)
(!irdyn && !trdyn && !devseln && !framen)
##[1:8] ($fell (stopn) && trdyn && framen);
endsequence

property p_tchk6_1;
@(posedge clk)
s_tchk6_1.ended |=> (irdyn && stopn);
endproperty

a_tchk6_1: assert property(p_tchk6_1);
c_tchk6_1: cover property(p_tchk6_1);
","Caption: ""Excerpt from a document on SystemVerilog Assertions (SVA) illustrating sequences and properties for protocol interface verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p373.jpg,True,"Here is the code snippet from the image:

```verilog
sequence_expr ::= [ cycle_delay_range ]
                  sequence_expr { sequence_expr cycle_delay_range }

cycle_delay_range ::=
                  ## constant_expression
                  ## [′] constant_expression [′] constant_expression [′]
                  ## [′] constant_expression [′] ‘$’ [′] -- Infinite range.
```

And in the examples given, we have:

```verilog
1 ##1 a - means a must be true in cycle 1.

1 ##1 a ##1 b - means a must be true in cycle 1, b must be true in cycle 2.

a ##[0:2] b same as a & b or (a ##1 b) or (a ##1 | ##1 b)

a ##[2:3] b same as (a ##1 | ##1 b) or (a ##1 | ##1 | ##1 b)
```","
sequence_expr ::= [ cycle_delay_range ]
                  sequence_expr { sequence_expr cycle_delay_range }

cycle_delay_range ::=
                  ## constant_expression
                  ## [′] constant_expression [′] constant_expression [′]
                  ## [′] constant_expression [′] ‘$’ [′] -- Infinite range.


1 ##1 a - means a must be true in cycle 1.

1 ##1 a ##1 b - means a must be true in cycle 1, b must be true in cycle 2.

a ##[0:2] b same as a & b or (a ##1 b) or (a ##1 | ##1 b)

a ##[2:3] b same as (a ##1 | ##1 b) or (a ##1 | ##1 | ##1 b)
","""Understanding Temporal Delay in Verilog Sequences""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p291.jpg,True,"The image contains verilog code. Here it is:

```verilog
endproperty

a_tchk9_slow: assert property(p_tchk9_slow);
c_tchk9_slow: cover property(p_tchk9_slow);

property p_tchk9_subtractive;
@(posedge clk)
s_tchk9_subtractive |-> ##[0:12]
  (!devseln) throughout
  (s_tchk9a.ended || s_tchk9b.ended);
endproperty

a_tchk9_subtractive:
  assert property(p_tchk9_subtractive);
c_tchk9_subtractive:
  cover property(p_tchk9_subtractive);
```

This code snippet appears to be related to SystemVerilog Assertions (SVA) for protocol interface checking. It defines properties and uses assertions and cover statements to specify and verify behavior in response to certain conditions in a hardware design.","
endproperty

a_tchk9_slow: assert property(p_tchk9_slow);
c_tchk9_slow: cover property(p_tchk9_slow);

property p_tchk9_subtractive;
@(posedge clk)
s_tchk9_subtractive |-> ##[0:12]
  (!devseln) throughout
  (s_tchk9a.ended || s_tchk9b.ended);
endproperty

a_tchk9_subtractive:
  assert property(p_tchk9_subtractive);
c_tchk9_subtractive:
  cover property(p_tchk9_subtractive);
","""Example of SystemVerilog Assertions (SVA) for protocol interface verification and timing diagram for PCI target check9""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p104.jpg,True,"```
A0 =  s1 == -x + y
A1 =  s2 = x + y
A2 =  A1
     -8 ≤ x ≤ -4
A3 =  y = x + s1
     s2 = 2x + s1
     s1 ≤ 1
```

The remaining contents of the image are text and mathematical explanations related to the topic of strict inequalities in an algorithmic context, but there is no more program code.","s1 == -x + y
A1 =  s2 = x + y
A2 =  A1
     -8 ≤ x ≤ -4
A3 =  y = x + s1
     s2 = 2x + s1
     s1 ≤ 1
",Academic publication excerpt discussing a method for handling strict inequalities in a linear arithmetic solver with a focus on the incremental solving approach.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p484.jpg,True,"This image contains Verilog code. Here is the Verilog code present in the image:

```verilog
module top;
  logic [ 0 : 3 ] a, b;

  covergroup cg @(posedge clk);
    coverpoint a {
      bins low[ ] = {[ 0 : 7 ]};
      bins high = {[ 8 : 15 ]};
    }
    coverpoint b {
      bins two[ ] = b with (item%2 == 0 );
      bins three[ ] = b with (item%3 == 0 );
    }
    X: cross a, b
    {
      bins xab = binsof ((b.two) with (b > 5)) || binsof ((a.low)
      with (a < 7 ));
    }
  endgroup

endmodule
```
This code demonstrates the use of a `covergroup` within a `module` in Verilog to define coverage metrics with coverpoints and cross coverage between different bins. The code is educational and is part of a discussion on functional coverage, specifically showing how to use the ""with"" clause and conditional bins creation.","
module top;
  logic [ 0 : 3 ] a, b;

  covergroup cg @(posedge clk);
    coverpoint a {
      bins low[ ] = {[ 0 : 7 ]};
      bins high = {[ 8 : 15 ]};
    }
    coverpoint b {
      bins two[ ] = b with (item%2 == 0 );
      bins three[ ] = b with (item%3 == 0 );
    }
    X: cross a, b
    {
      bins xab = binsof ((b.two) with (b > 5)) || binsof ((a.low)
      with (a < 7 ));
    }
  endgroup

endmodule
","""Verilog functional coverage example demonstrating the use of 'with' clause and cross bins to create tuples for coverage analysis.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p155.jpg,True,"The image contains two snippets of Verilog code, which are part of solutions to example problems regarding assertion system functions in Verilog. Here are the code snippets:

First Code Snippet:
```verilog
a_tract: assert property (@(posedge clk)
  $countones(transmitters) <= trmax);
```

Second Code Snippet:
```verilog
a_valid_data: assert property (@(posedge clk)
  read |-> !$isunknown(data));
```","
a_tract: assert property (@(posedge clk)
  $countones(transmitters) <= trmax);


a_valid_data: assert property (@(posedge clk)
  read |-> !$isunknown(data));
","Caption: ""Excerpt from a technical document detailing Verilog system functions for counting ones in a bit vector and checking for unknown bits.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p142.jpg,True,"```c
/* get module handle from first system task argument. Assume the */
/* compiletf routine has already verified correct argument type. */
systf_h = vpi_handle(vpiSysTfCall, NULL);
if (systf_h == NULL) {
    vpi_printf(""ERROR: list_pathout_ports could not obtain handle to systf call\n"");
    return(0);
}
arg_itr = vpi_iterate(vpiArgument, systf_h);
if (systf_h == NULL) {
    vpi_printf(""ERROR: list_pathout_ports could not obtain iterator to systf args\n"");
    return(0);
}
mod_h = vpi_scan(arg_itr);
vpi_free_object(arg_itr); /* free it since did not scan until null */

vpi_printf(""\nModule %s (instance %s)\n"",
           vpi_get_str(vpiDefName, mod_h),
           vpi_get_str(vpiFullName, mod_h));

port_itr = vpi_iterate(vpiPort, mod_h);
if (!port_itr) {
   vpi_printf("" No ports found\n"");
   return(0);
}
while (port_h = vpi_scan(port_itr)) {
    vpi_printf("" Port name is %s\n"", vpi_get_str(vpiName, port_h));
    vpi_printf("" Size is %d\n"", vpi_get(vpiSize, port_h));
    switch (vpi_get(vpiDirection, port_h)) {
        case vpiInput: vpi_printf("" Direction is input\n""); break;
        case vpiOutput: vpi_printf("" Direction is output\n""); break;
        case vpiInOut: vpi_printf("" Direction is inout\n""); break;
    }
    
    lowconn_h = vpi_handle(vpiLowConn, port_h);
    lowconn_type = vpi_get(vpiType, lowconn_h);
    vpi_printf("" Low conn data type is %s\n"",
               PLIbook_fetch_type_str_vpi(lowconn_type));
    
    highconn_h = vpi_handle(vpiHighConn, port_h);
    if (!highconn_h) {
        vpi_printf("" No high conn\n"");
        return(0);
    }
    highconn_type = vpi_get(vpiType, highconn_h);
    vpi_printf("" High conn data type is %s\n"",
               PLIbook_fetch_type_str_vpi(highconn_type));
}
return(0);
```
The image contains a page from ""The Verilog PLI Handbook, Part One"" with a snippet of C code that is used within the context of Verilog Programming Language Interface (PLI). Please use this code in accordance with the relevant copyright and licensing if applicable.","t module handle from first system task argument. Assume the */
/* compiletf routine has already verified correct argument type. */
systf_h = vpi_handle(vpiSysTfCall, NULL);
if (systf_h == NULL) {
    vpi_printf(""ERROR: list_pathout_ports could not obtain handle to systf call\n"");
    return(0);
}
arg_itr = vpi_iterate(vpiArgument, systf_h);
if (systf_h == NULL) {
    vpi_printf(""ERROR: list_pathout_ports could not obtain iterator to systf args\n"");
    return(0);
}
mod_h = vpi_scan(arg_itr);
vpi_free_object(arg_itr); /* free it since did not scan until null */

vpi_printf(""\nModule %s (instance %s)\n"",
           vpi_get_str(vpiDefName, mod_h),
           vpi_get_str(vpiFullName, mod_h));

port_itr = vpi_iterate(vpiPort, mod_h);
if (!port_itr) {
   vpi_printf("" No ports found\n"");
   return(0);
}
while (port_h = vpi_scan(port_itr)) {
    vpi_printf("" Port name is %s\n"", vpi_get_str(vpiName, port_h));
    vpi_printf("" Size is %d\n"", vpi_get(vpiSize, port_h));
    switch (vpi_get(vpiDirection, port_h)) {
        case vpiInput: vpi_printf("" Direction is input\n""); break;
        case vpiOutput: vpi_printf("" Direction is output\n""); break;
        case vpiInOut: vpi_printf("" Direction is inout\n""); break;
    }
    
    lowconn_h = vpi_handle(vpiLowConn, port_h);
    lowconn_type = vpi_get(vpiType, lowconn_h);
    vpi_printf("" Low conn data type is %s\n"",
               PLIbook_fetch_type_str_vpi(lowconn_type));
    
    highconn_h = vpi_handle(vpiHighConn, port_h);
    if (!highconn_h) {
        vpi_printf("" No high conn\n"");
        return(0);
    }
    highconn_type = vpi_get(vpiType, highconn_h);
    vpi_printf("" High conn data type is %s\n"",
               PLIbook_fetch_type_str_vpi(highconn_type));
}
return(0);
","""Example of Verilog PLI (Programming Language Interface) code showcasing module handling and port iteration.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p159.jpg,True,"The image contains a segment of code written in Verilog. Here is the code from the image:

```verilog
a40: assert (arbif.cb.grant == 2'b01)
else $error(""Grant not asserted"");
```

In this Verilog code snippet, `a40:` is a label for the assertion statement that checks if the signal `arbif.cb.grant` is equal to the binary value `01`. If the assertion fails, it triggers an `$error` system task with the message ""Grant not asserted"".","
a40: assert (arbif.cb.grant == 2'b01)
else $error(""Grant not asserted"");
",Verilog code example with a custom error message for an immediate assertion and its simulated error output.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p309.jpg,True,"The image contains some Verilog code. Here is the text of the code provided in the image:

```verilog
sequence a_wait_b;
    @(posedge clk) A |-> (##[1:$] B);
endsequence

awb: assert property (strong(a_wait_b)) else $display($stime, ""a_wait_b FAIL""); //default 'weak'

awbc: cover property (weak(a_wait_b)) $display($stime,""a_wait_b PASS""); //default 'strong'
```

This code is demonstrating the use of strong and weak sequences in system verilog assertions and covers.","
sequence a_wait_b;
    @(posedge clk) A |-> (##[1:$] B);
endsequence

awb: assert property (strong(a_wait_b)) else $display($stime, ""a_wait_b FAIL""); //default 'weak'

awbc: cover property (weak(a_wait_b)) $display($stime,""a_wait_b PASS""); //default 'strong'
","""Explanation of strong and weak sequences in SystemVerilog with an example code snippet and their implications during simulation.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p624.jpg,True,"The image contains a snippet of code, which appears to be written in C for use with Verilog PLI (Programming Language Interface). Here is the transcription of the code:

```c
if (!(acc_object_of_type(acc_handle_targ(ALU_RESULT), accRealVar)))
    tf_error(""%sscientific_alu arg 1 must be a real variable\n"");
if (!(acc_object_of_type(acc_handle_targ(ALU_EXCEPT), accReg)))
    tf_error(""%scientific_alu arg 2 must be a reg\n"");
else if (acc_fetch_size(acc_handle_targ(ALU_EXCEPT)) != 1)
    tf_error(""%scientific_alu arg 2 must be scalar\n"");
if (!(acc_object_of_type(acc_handle_targ(ALU_ERROR), accReg)))
    tf_error(""%scientific_alu arg 3 must be a reg\n"");
else if (acc_fetch_size(acc_handle_targ(ALU_ERROR)) != 1)
    tf_error(""%scientific_alu arg 3 must be scalar\n"");

acc_close();
return(0);
}
```

Please note that there seem to be formatting issues with the `tf_error` function calls in the given code, as the format specifier (usually a placeholder like `%s`) is followed immediately by the error string without a corresponding argument to replace the specifier. This may be a typographical error in the text.","(acc_object_of_type(acc_handle_targ(ALU_RESULT), accRealVar)))
    tf_error(""%sscientific_alu arg 1 must be a real variable\n"");
if (!(acc_object_of_type(acc_handle_targ(ALU_EXCEPT), accReg)))
    tf_error(""%scientific_alu arg 2 must be a reg\n"");
else if (acc_fetch_size(acc_handle_targ(ALU_EXCEPT)) != 1)
    tf_error(""%scientific_alu arg 2 must be scalar\n"");
if (!(acc_object_of_type(acc_handle_targ(ALU_ERROR), accReg)))
    tf_error(""%scientific_alu arg 3 must be a reg\n"");
else if (acc_fetch_size(acc_handle_targ(ALU_ERROR)) != 1)
    tf_error(""%scientific_alu arg 3 must be scalar\n"");

acc_close();
return(0);
}
","""Excerpt from 'The Verilog PLI Handbook' demonstrating Verilog code for a sequential logic interface to a C model.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p630.jpg,True,"The image shows a page from ""The Verilog PLI Handbook, Part Two,"" which contains excerpts of code blending Verilog and C. Here is the transcribed code from the image:

```c
/****** Call C model *******/
PLIbook_ScientificALU_C_model(a, b, opcode, &result, &excep, &err);

/* Write the C model outputs onto the Verilog signals */
delay_s.model         = accNoDelay;
delay_s.time          = time_s;
delay_s.time.type     = accRealTime;
delay_s.time.real     = 0.0;

value_s.format        = accRealVal;
value_s.value.real    = result;
acc_set_value(result_h, &value_s, &delay_s);

value_s.format        = accIntVal;
value_s.value.integer = excep;
acc_set_value(excep_h, &value_s, &delay_s);

value_s.value.integer = err;
acc_set_value(err_h, &value_s, &delay_s);

acc_close();
return(0);
}

/*********************************************************************
* callback routine: Registers a callback to the C model interface
* whenever any input to the C model changes value
*********************************************************************/
int PLIbook_ScientificALU_calltf()
{
  handle a_h, b_h, opcode_h;
  char *instance_p;

  acc_initialize();

  /* get handles for signals in task args which are C model inputs */
  a_h       = acc_handle_tfarg(ALU_A);
  b_h       = acc_handle_tfarg(ALU_B);
  opcode_h  = acc_handle_tfarg(ALU_OP);

  /* get pointer for this system task instance to pass to VCL app. */
  instance_p = tf_getinstance();

  /* set the TF work area for this instance to null */
  tf_setworkarea(NULL);

  /* add VCL flags to all signals which are inputs to the C model */
  /* pass handle for task instance as the user_data value          */
  acc_vcl_add(a_h,        PLIbook_ScientificALU_interface,
              instance_p, vcl_verilog_logic);
  acc_vcl_add(b_h,        PLIbook_ScientificALU_interface,
              instance_p, vcl_verilog_logic);
```

The code displayed is part of a Verilog PLI (Programming Language Interface) application that integrates C functions with Verilog hardware description language. This is used to extend the capabilities of Verilog simulators.","** Call C model *******/
PLIbook_ScientificALU_C_model(a, b, opcode, &result, &excep, &err);

/* Write the C model outputs onto the Verilog signals */
delay_s.model         = accNoDelay;
delay_s.time          = time_s;
delay_s.time.type     = accRealTime;
delay_s.time.real     = 0.0;

value_s.format        = accRealVal;
value_s.value.real    = result;
acc_set_value(result_h, &value_s, &delay_s);

value_s.format        = accIntVal;
value_s.value.integer = excep;
acc_set_value(excep_h, &value_s, &delay_s);

value_s.value.integer = err;
acc_set_value(err_h, &value_s, &delay_s);

acc_close();
return(0);
}

/*********************************************************************
* callback routine: Registers a callback to the C model interface
* whenever any input to the C model changes value
*********************************************************************/
int PLIbook_ScientificALU_calltf()
{
  handle a_h, b_h, opcode_h;
  char *instance_p;

  acc_initialize();

  /* get handles for signals in task args which are C model inputs */
  a_h       = acc_handle_tfarg(ALU_A);
  b_h       = acc_handle_tfarg(ALU_B);
  opcode_h  = acc_handle_tfarg(ALU_OP);

  /* get pointer for this system task instance to pass to VCL app. */
  instance_p = tf_getinstance();

  /* set the TF work area for this instance to null */
  tf_setworkarea(NULL);

  /* add VCL flags to all signals which are inputs to the C model */
  /* pass handle for task instance as the user_data value          */
  acc_vcl_add(a_h,        PLIbook_ScientificALU_interface,
              instance_p, vcl_verilog_logic);
  acc_vcl_add(b_h,        PLIbook_ScientificALU_interface,
              instance_p, vcl_verilog_logic);
","Excerpt from ""The Verilog PLI Handbook"" showing integration of C model outputs with Verilog signals using the Verilog Programming Language Interface (PLI).",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p53.jpg,True,"```verilog
module bottom (...);
    ...
    initial
        $my_app_2(in3, out3); //system task instance

    always @(posedge clock)
        $my_app_2(in4, out4); //system task instance
endmodule
```","
module bottom (...);
    ...
    initial
        $my_app_2(in3, out3); //system task instance

    always @(posedge clock)
        $my_app_2(in4, out4); //system task instance
endmodule
","""Verilog code snippet demonstrating the use of system tasks within initial and always blocks for simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p453.jpg,True,"```verilog
covergroup AR;
  coverpoint s0 iff(!reset);
endgroup

typedef enum {QUIET, BUSY} stateM;

function stateM cPoint_State_function(bit valid, ready);
  if (valid == 0) return QUIET;
  if ((valid & ~ready) == 0) return BUSY;
endfunction

...

covergroup cg @(posedge clk);
  cpStateM: coverpoint cPoint_State_function (valid, ready);
endgroup

cg cgInst = new(1'b0,1'b1);
```","
covergroup AR;
  coverpoint s0 iff(!reset);
endgroup

typedef enum {QUIET, BUSY} stateM;

function stateM cPoint_State_function(bit valid, ready);
  if (valid == 0) return QUIET;
  if ((valid & ~ready) == 0) return BUSY;
endfunction

...

covergroup cg @(posedge clk);
  cpStateM: coverpoint cPoint_State_function (valid, ready);
endgroup

cg cgInst = new(1'b0,1'b1);
","""Excerpt from a technical document showing Verilog coverpoint syntax with conditional expression and function example.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p169.jpg,True,"The image contains Verilog code snippets from a document that is discussing assertion system functions and tasks. Here are the code segments extracted from the image:

1. Code for an assertion to ensure a signal is stable:
```verilog
a_stable: assert property (@$global_clock $steady_gclk(sig));
```

2. Code for an assertion example that checks signal stability between clock ticks:
```verilog
a1: assert property (@$global_clock disable iff (rst)
  $changing_gclk(sig) |-> $rising_gclk(clk));
```

3. Another example of an assertion using past sampled value function:
```verilog
a2: assert property (@$global_clock disable iff (rst)
  ##1 $changed(sig) |-> $rose(clk));
```

4. Code for an assertion example for enabling a signal when another signal is about to change:
```verilog
a1: assert property (@sig !en);
```

These snippets represent various assertions that are used to ensure signal integrity and behavior in Verilog-based hardware design verification.","
a_stable: assert property (@$global_clock $steady_gclk(sig));


a1: assert property (@$global_clock disable iff (rst)
  $changing_gclk(sig) |-> $rising_gclk(clk));


a2: assert property (@$global_clock disable iff (rst)
  ##1 $changed(sig) |-> $rose(clk));


a1: assert property (@sig !en);
","Caption: ""Examples of Verilog Assertion Properties for Signal Stability and Clock Sampling""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p618.jpg,True,"```verilog
`timescale 1ns / 1ns
module scientific_alu(a_in, b_in, opcode,
                      result_out, exception, error);

input [63:0] a_in, b_in;
input [3:0] opcode;
output [63:0] result_out;
output exception, error;

real a, b, result; // real variables used in this module
reg exception, error;

// convert real numbers to/from 64-bit vector port connections
assign result_out = $realtobits(result);
always @(a_in) a = $bitstoreal(a_in);
always @(b_in) b = $bitstoreal(b_in);

//call the PLI application which interfaces to the C model
initial
   $scientific_alu(a, b, opcode, result, exception, error);

endmodule
```","
`timescale 1ns / 1ns
module scientific_alu(a_in, b_in, opcode,
                      result_out, exception, error);

input [63:0] a_in, b_in;
input [3:0] opcode;
output [63:0] result_out;
output exception, error;

real a, b, result; // real variables used in this module
reg exception, error;

// convert real numbers to/from 64-bit vector port connections
assign result_out = $realtobits(result);
always @(a_in) a = $bitstoreal(a_in);
always @(b_in) b = $bitstoreal(b_in);

//call the PLI application which interfaces to the C model
initial
   $scientific_alu(a, b, opcode, result, exception, error);

endmodule
","""Verilog Shell Module for a Combinational Logic Scientific ALU""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p246.jpg,True,"```
property p_write_protect;
    @(posedge clk)
        (!sel_n[3]) |-> wp_n == 0;
endproperty

a_write_protect:
    assert property (p_write_protect);
c_write_protect:
    cover property (p_write_protect);

property p_tAVAV_not;
    @(posedge clk)
        (!sel_n[3] && $fall(oe_n)) |-> not ##[0:15] $rose(oe_n);
endproperty

property p_tAVAV;
    @(posedge clk)
        (!sel_n[3] && $fell(oe_n)) |-> ##[16:900] $rose(oe_n);
endproperty

a_tAVAV: assert property(p_tAVAV);
a_tAVAV_not: assert property(p_tAVAV_not);

c_tAVAV: cover property(p_tAVAV);
```","ty p_write_protect;
    @(posedge clk)
        (!sel_n[3]) |-> wp_n == 0;
endproperty

a_write_protect:
    assert property (p_write_protect);
c_write_protect:
    cover property (p_write_protect);

property p_tAVAV_not;
    @(posedge clk)
        (!sel_n[3] && $fall(oe_n)) |-> not ##[0:15] $rose(oe_n);
endproperty

property p_tAVAV;
    @(posedge clk)
        (!sel_n[3] && $fell(oe_n)) |-> ##[16:900] $rose(oe_n);
endproperty

a_tAVAV: assert property(p_tAVAV);
a_tAVAV_not: assert property(p_tAVAV_not);

c_tAVAV: cover property(p_tAVAV);
","""Verilog code examples demonstrating assertions and coverage for write protection and timing checks in a flash memory system.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p335.jpg,True,"The image contains Verilog code. Here is the code transcribed from the image:

```verilog
module defaultP ( );
bit clk, x, y, z, rst, reset;

default clocking negclock @ (negedge clk); endclocking
default disable iff rst;

property inferB (a, b, c, clk=$inferred_clock, reset=$inferred_disable);
  @ (clk) disable iff (reset) a |=> b || c;
endproperty

assert property (inferB (x, y, z) ) else $display ($stime,, ""FAIL"");
cover property (inferB (x, y, z) ) $display ($stime,, ""PASS"");

initial
begin
  clk=0; rst=0; x=1; y=0; z=0;
  #80; rst=1;
  #80; y=1; rst=0;
  #80 $finish;
end

always #10 clk=!clk;

initial $monitor($stime,, ""rst=%b clk=%b x=%b y=%b z=%b"", rst, clk,x,y,z);

endmodule
```

This code snippet is an example of a Verilog module that showcases some IEEE 1800-2009/2012 features such as properties, assertions, and clocking blocks. The code also includes simulation logs within the image, below the module code.","
module defaultP ( );
bit clk, x, y, z, rst, reset;

default clocking negclock @ (negedge clk); endclocking
default disable iff rst;

property inferB (a, b, c, clk=$inferred_clock, reset=$inferred_disable);
  @ (clk) disable iff (reset) a |=> b || c;
endproperty

assert property (inferB (x, y, z) ) else $display ($stime,, ""FAIL"");
cover property (inferB (x, y, z) ) $display ($stime,, ""PASS"");

initial
begin
  clk=0; rst=0; x=1; y=0; z=0;
  #80; rst=1;
  #80; y=1; rst=0;
  #80 $finish;
end

always #10 clk=!clk;

initial $monitor($stime,, ""rst=%b clk=%b x=%b y=%b z=%b"", rst, clk,x,y,z);

endmodule
","Example of Verilog code with assertions, properties, and initial blocks demonstrating IEEE-1800-2009/2012 features.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p321.jpg,True,"The image contains snippets of Verilog code. Here are the pieces of code extracted from the image:

1. Assertion with ""always"":
```verilog
P1: assert property p1p (@ (posedge clk) always bstrap1==0);
```

2. Assertion without ""always"":
```verilog
P1: assert property p1p (@ (posedge clk) bstrap1==0);
```

3. Example of using ""initial"" block with ""always"":
```verilog
initial
begin
    P1: assert p1p (@ (posedge clk) always bstrap1==0);
end
```

4. Example of a property definition with ""always"":
```verilog
property xx_chk (logic aStrobe, logic data);
    @(posedge clk) disable iff (rst)
    $rose(aStrobe) [-1] |=> always (!($isunknown(data) && $stable(data)));
endproperty
```

These represent various uses of assertions and the ""always"" keyword in SystemVerilog to check for certain conditions or properties in the hardware description and verification process.","
P1: assert property p1p (@ (posedge clk) always bstrap1==0);


P1: assert property p1p (@ (posedge clk) bstrap1==0);


initial
begin
    P1: assert p1p (@ (posedge clk) always bstrap1==0);
end


property xx_chk (logic aStrobe, logic data);
    @(posedge clk) disable iff (rst)
    $rose(aStrobe) [-1] |=> always (!($isunknown(data) && $stable(data)));
endproperty
","""Explanation and examples of using the 'always' keyword in Verilog assertions and properties.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p394.jpg,True,"The image contains Verilog code snippets related to assertion properties. Here is the code transcribed from the image:

First snippet:
```verilog
a_mult_match: assert property(
    (a[*1:2] or b[*1:2]) |-> c
);
```

Second snippet:
```verilog
property p_mult_match_loc_var;
    byte l_v;
    ((a[*1:2], 1_v = e) or (b[*1:2], 1_v = f)) |-> g != 1_v;
endproperty
a_mult_match_loc_var: assert property(p_mult_match);
```

Third snippet:
```verilog
a_mult_match_2: assert property(
    (a |-> g != e)
    and (b |-> g != f)
    and (a[*2] |-> g != $past(e))
    and (b[*2] |-> g != $past(f))
);
```","
a_mult_match: assert property(
    (a[*1:2] or b[*1:2]) |-> c
);


property p_mult_match_loc_var;
    byte l_v;
    ((a[*1:2], 1_v = e) or (b[*1:2], 1_v = f)) |-> g != 1_v;
endproperty
a_mult_match_loc_var: assert property(p_mult_match);


a_mult_match_2: assert property(
    (a |-> g != e)
    and (b |-> g != f)
    and (a[*2] |-> g != $past(e))
    and (b[*2] |-> g != $past(f))
);
","This image includes explanatory text and examples related to the concept of ""Multiplicity of Matching with Local Variables"" in Verilog assertion properties.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p383.jpg,True,"The image contains Verilog code. Here it is:

```verilog
reg [msb:lsb] RAM [first_address:last_address];
```

There is another line of example code provided below:

```verilog
reg [23:0] RAM [0:3]; //lsb is lowest bit, ascending addresses
```","
reg [msb:lsb] RAM [first_address:last_address];


reg [23:0] RAM [0:3]; //lsb is lowest bit, ascending addresses
","""Understanding the mapping between Verilog array numbering and C array numbering along with example Verilog memory declarations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p380.jpg,True,"```verilog
sequence s3 (
  local input byte l_a, l_b,
  local input byte l_c[8],
  local input byte l_d,
  local input byte l_e,
  local input bit l_f,
  local input bit [0:3] l_g, l_h
);
  ...
endsequence

property p1_v3(local input byte l_byte = data);
  byte l_byteMasked = l_byte & mask;
  ...
endproperty
```

This Verilog code contains examples of legal declarations for sequences and properties with default and local parameters.","
sequence s3 (
  local input byte l_a, l_b,
  local input byte l_c[8],
  local input byte l_d,
  local input byte l_e,
  local input bit l_f,
  local input bit [0:3] l_g, l_h
);
  ...
endsequence

property p1_v3(local input byte l_byte = data);
  byte l_byteMasked = l_byte & mask;
  ...
endproperty
",An excerpt from a technical document showcasing legal declarations and restrictions in Verilog code for defining local variables within a sequence construct.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p169.jpg,True,"The image contains an excerpt from what seems to be a book or a document discussing common pitfalls or ""gotchas"" in object-oriented and multithreaded programming, specifically related to Verilog. Here is the code present in the image:

```verilog
class Foo;
  int data; // property
  function int get (...); // method
    ...
  endfunction
  task put (...);
    ...
  endtask
endclass

class Bar;
  Foo f = new; // create object f
  f.data = 3; // GOTCHA! illegal assignment statement
endclass
```

Note: The document points out that procedural programming statements such as the assignment statement `f.data = 3` are not allowed in Verilog class definitions, and that this will result in a compilation error. The text under the code snippet also indicates that the examples in the chapter are contrived to illustrate the gotchas and might not be as obvious or easy to debug in real design and verification code.","
class Foo;
  int data; // property
  function int get (...); // method
    ...
  endfunction
  task put (...);
    ...
  endtask
endclass

class Bar;
  Foo f = new; // create object f
  f.data = 3; // GOTCHA! illegal assignment statement
endclass
","Chapter on Verilog Object Oriented and Multi-Threaded Programming Gotchas, highlighting common mistakes in class definitions.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p397.jpg,True,"The image contains a snippet of a text along with some code written in C, not Verilog. Here is the code presented:

```c
int group_bit;
group_bit = bit_num % 8;

char mask;
mask = 0x01;
mask = mask << group_bit;

char aval_bit_value, bval_bit_value;
aval_bit_value = aval_ptr[group_num] & mask;
bval_bit_value = bval_ptr[group_num] & mask;
```

This C code pertains to operations for determining a specific bit within a group, setting a mask to isolate that bit, and reading the value of the target bit using a bitwise AND operation. The snippet also describes that the full example can be found in a file named `dump_mem_bin`, and additional related files `dump_memory_tf.c`, `dump_and_fill_mem_test.v`, and `dump_and_fill_mem_test.log` are mentioned to be on an accompanying CD.","roup_bit;
group_bit = bit_num % 8;

char mask;
mask = 0x01;
mask = mask << group_bit;

char aval_bit_value, bval_bit_value;
aval_bit_value = aval_ptr[group_num] & mask;
bval_bit_value = bval_ptr[group_num] & mask;
","""Excerpt from a textbook detailing the process of reading and manipulating individual bits in Verilog using TF routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p49.jpg,True,"The image contains code written in the context of Verilog, a hardware description language. Here is the code provided in the image:

```verilog
logic [1:0] select;  // 2-bit vector

always_comb begin
  case (select)
    00: y = a;
    01: y = b;
    10: y = c;          // GOTCHA! This branch is never selected
    11: y = d;          // GOTCHA! This branch is never selected
  endcase
end
``` 

The code contains a Verilog case statement that is intended to implement a 4-to-1 multiplexer behavior based on the value of `select`. The comments indicate a potential gotcha where the branches corresponding to 10 and 11 may never be selected due to a misunderstanding about literal integers defaulting to a decimal base.","
logic [1:0] select;  // 2-bit vector

always_comb begin
  case (select)
    00: y = a;
    01: y = b;
    10: y = c;          // GOTCHA! This branch is never selected
    11: y = d;          // GOTCHA! This branch is never selected
  endcase
end
","An excerpt from ""Verilog and SystemVerilog Gotchas"" discussing the default base of literal integers in Verilog, including a code example demonstrating a common mistake with case statements.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p61.jpg,True,"```verilog
module top;
  wire [7:0] data;
  wire [7:0] addr;
  block1 b1 (.*,
             .addr(addr[7:4]), // explicitly shows size mismatch
             .byte_en() );     // explicitly shows unconnected
endmodule: top

module block1 (input [7:0] data,
               input [3:0] addr,
               input [3:0] byte_en);
  ...
endmodule: block1
```","
module top;
  wire [7:0] data;
  wire [7:0] addr;
  block1 b1 (.*,
             .addr(addr[7:4]), // explicitly shows size mismatch
             .byte_en() );     // explicitly shows unconnected
endmodule: top

module block1 (input [7:0] data,
               input [3:0] addr,
               input [3:0] byte_en);
  ...
endmodule: block1
","Caption: ""Verilog code example illustrating size mismatches and unconnected ports in module instantiations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p141.jpg,True,"Here is the Verilog code that is visible in the image:

```verilog
module chip (input logic clock, input logic reset_n, ...);

  always_ff @(posedge clock)  // synchronous reset
    if (!reset_n) q <= 0;
    else
      q <= d;
endmodule

module test (input logic clock, output logic reset_n, ...);

  initial begin
    reset_n = 0;  // GOTCHA! activating reset at time zero 
    #10 reset_n = 1;
    ...
  end
endmodule

module top;
  logic clock, reset_n, ...;
  test test (.*);
  chip dut (.*);

  initial begin
    clock = 1;  // GOTCHA! first rising clock edge at time zero 
    
    forever #5 clock = ~clock;
  end
endmodule
```

The code includes three modules (`chip`, `test`, and `top`) with examples of synchronous reset and clock initialization. There is a commentary on potential issues when activating the reset at time zero and generating the first rising clock edge at time zero, marked with ""GOTCHA!"" indicating common pitfalls in Verilog programming.","
module chip (input logic clock, input logic reset_n, ...);

  always_ff @(posedge clock)  // synchronous reset
    if (!reset_n) q <= 0;
    else
      q <= d;
endmodule

module test (input logic clock, output logic reset_n, ...);

  initial begin
    reset_n = 0;  // GOTCHA! activating reset at time zero 
    #10 reset_n = 1;
    ...
  end
endmodule

module top;
  logic clock, reset_n, ...;
  test test (.*);
  chip dut (.*);

  initial begin
    clock = 1;  // GOTCHA! first rising clock edge at time zero 
    
    forever #5 clock = ~clock;
  end
endmodule
","Excerpt from a text discussing common pitfalls in programming Verilog, with example code illustrating synchronous reset implementation and a cautionary note about avoiding race conditions at time zero.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p155.jpg,True,"The image contains text explaining a programming ""gotcha"" related to Verilog, specifically about triggering on clocking blocks, and it includes a snippet of Verilog code. Here is the code in the image:

```verilog
program automatic test (input logic clk,
                        input logic grant,
                        output logic request
);
  clocking cb @(posedge clk);
    output request;
    input grant;
  endclocking
  
  initial begin
    @(posedge cb) // GOTCHA: cannot select edge of clocking block
    $display(""At %0d: clocking block triggered"", $time);
    ...
  end
endprogram

initial begin
  @(cb) // OK: delay until clocking block event occurs
  $display(""At %0d: clocking block triggered"", $time);
  ...
end
endprogram
```

In the first block of code, there is a comment highlighting the gotcha by pointing out the incorrect use of `@(posedge cb)` which results in a compilation error. The second block corrects this by using `@(cb)` to properly wait for the clocking block event.","
program automatic test (input logic clk,
                        input logic grant,
                        output logic request
);
  clocking cb @(posedge clk);
    output request;
    input grant;
  endclocking
  
  initial begin
    @(posedge cb) // GOTCHA: cannot select edge of clocking block
    $display(""At %0d: clocking block triggered"", $time);
    ...
  end
endprogram

initial begin
  @(cb) // OK: delay until clocking block event occurs
  $display(""At %0d: clocking block triggered"", $time);
  ...
end
endprogram
","""Best practices for using clocking blocks in Verilog testbench code to avoid compilation errors.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p75.jpg,True,"Here is the Verilog code present in the image:

The first code snippet:
```verilog
always @(state_e) begin
  nstate_e = HOLD;                            // first statement in block
  case (state_e)                              // second statement in block
    HOLD: if (ready) nstate_e = LOAD;
    LOAD: if (done) nstate_e = HOLD;
  endcase
end
```

The second code snippet:
```verilog
always @(posedge clock or negedge reset_n) // good code
  if (!reset_n) state_e <= RESET;
  else state_e <= nstate_e;
```

The third code snippet (labeled as a GOTCHA):
```verilog
always @(posedge clock or negedge reset_n) begin
  if (!reset_n) state_e <= RESET;          // first statement
  else state_e <= nstate_e;
  fsm_out <= decode_func(nstate_e);        // GOTCHA! second statement
end
```","
always @(state_e) begin
  nstate_e = HOLD;                            // first statement in block
  case (state_e)                              // second statement in block
    HOLD: if (ready) nstate_e = LOAD;
    LOAD: if (done) nstate_e = HOLD;
  endcase
end


always @(posedge clock or negedge reset_n) // good code
  if (!reset_n) state_e <= RESET;
  else state_e <= nstate_e;


always @(posedge clock or negedge reset_n) begin
  if (!reset_n) state_e <= RESET;          // first statement
  else state_e <= nstate_e;
  fsm_out <= decode_func(nstate_e);        // GOTCHA! second statement
end
","""Exploring Common Pitfalls in Verilog Sequential Modeling with begin...end Groups""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p171.jpg,True,"```verilog
module cover_monitor (clk, reset_n, test);
input clk, reset_n, test;
parameter event_id=""COV_"";
`ifdef COVERAGE_ON
// look for test condition
always @(posedge clk) begin
  if (reset_n == 1'b0 & & test) begin
    $display ("" %s @ %0t:%t%m"", event_id, $time);
  end // end if (...test...)
end
`endif
endmodule
```

```verilog
// detect a queue full condition
cover_monitor # (""COV_Q1_FULL"") dv_q_full(clk, reset_n, q1_full);
```","
module cover_monitor (clk, reset_n, test);
input clk, reset_n, test;
parameter event_id=""COV_"";
`ifdef COVERAGE_ON
// look for test condition
always @(posedge clk) begin
  if (reset_n == 1'b0 & & test) begin
    $display ("" %s @ %0t:%t%m"", event_id, $time);
  end // end if (...test...)
end
`endif
endmodule


// detect a queue full condition
cover_monitor # (""COV_Q1_FULL"") dv_q_full(clk, reset_n, q1_full);
","""Verilog code examples demonstrating a coverage module and its instantiation for assertion-based design methods in hardware verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p431.jpg,True,"```verilog
default clocking ck @(posedge clk); endclocking
covergroup delay_cg
  with function sample(int unsigned delay);
    dl_pt: coverpoint delay {
      bins delays [100] : {[1:100]};
    }
endgroup
delay_cg delay_cg_inst = new();
property p_delay_coverage;
  int unsigned ticks_l;
  disable iff (reset)
    (a, ticks_l = 0)
    ##[ ticks_l < 100, ticks_l++] [->1]
    b,
    delay_cg_inst.sample(ticks_l),                      // match item
    $display(""prop_cov4 success, time %t, delay %0d"",
             $time, ticks_l)                            // match item
  ;
endproperty
prop_cov4: cover property(p_delay_coverage);
```

This image shows a piece of Verilog code that discusses combining covergroups and assertions.","
default clocking ck @(posedge clk); endclocking
covergroup delay_cg
  with function sample(int unsigned delay);
    dl_pt: coverpoint delay {
      bins delays [100] : {[1:100]};
    }
endgroup
delay_cg delay_cg_inst = new();
property p_delay_coverage;
  int unsigned ticks_l;
  disable iff (reset)
    (a, ticks_l = 0)
    ##[ ticks_l < 100, ticks_l++] [->1]
    b,
    delay_cg_inst.sample(ticks_l),                      // match item
    $display(""prop_cov4 success, time %t, delay %0d"",
             $time, ticks_l)                            // match item
  ;
endproperty
prop_cov4: cover property(p_delay_coverage);
",Verilog code snippet showcasing the combination of covergroups and assertions for delay coverage collection.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p426.jpg,True,"```c
/*********************************************************************/
/* misctf routine                                                    */
/*********************************************************************/
int PLIbook_ReadStimulus_misctf(int user_data, int reason)
{
    int         delay, foo;
    char        base;
    PLIbook_stim_data_p data_p;

    bool        debug = FALSE;
    if(mc_scan_plusargs(""read_stimulus_debug"")) debug = TRUE;

    if (debug)
        io_printf(""*** read_stimulus misctf called for %s at time %s **\n"",
                  PLIbook_reason_name(reason), tf_strgettime());

    switch(reason) {
        case REASON_ENDOFCOMPILE: /* misctf called at start of simulation */

        /* Check work area to see if application data is already
           allocated and the vector file opened. This check is necessary
           because REASON_RESTART can occur before REASON_ENDOFCOMPILE */
           data_p = (PLIbook_stim_data_p)tf_getworkarea();
           if (data_p)
               return(0); /* abort if work area already contains data */

        /* allocate a memory block for data storage */
           data_p=(PLIbook_stim_data_p)malloc(sizeof(PLIbook_stim_data_s));

        /* store a pointer to the application data in the work area */
           tf_setworkarea((char *)data_p);

        /* fill in the application data fields */
           data_p->file_ptr = fopen(tf_getcstringp(1), ""r"");
           if ( !data_p->file_ptr ) {
               tf_error(""read_stimulus_?? could not open file %s"",
                        tf_getcstringp(1));
               tf_dofinish(); /* exit simulation if cannot open file */
               break;
           }
           data_p->file_position = ftell(data_p->file_ptr);
           data_p->vector = (char *) malloc((tf_sizep(2) * 8) + 1);
           strcpy(data_p->dummy_msg, ""Hello world"");
           break;

        case REASON_REACTIVATE: /* misctf called by tf_setdelay */

        /* get the pointer to the data structure from the work area */
           data_p = (PLIbook_stim_data_p)tf_getworkarea();
```","*****************************************************************/
/* misctf routine                                                    */
/*********************************************************************/
int PLIbook_ReadStimulus_misctf(int user_data, int reason)
{
    int         delay, foo;
    char        base;
    PLIbook_stim_data_p data_p;

    bool        debug = FALSE;
    if(mc_scan_plusargs(""read_stimulus_debug"")) debug = TRUE;

    if (debug)
        io_printf(""*** read_stimulus misctf called for %s at time %s **\n"",
                  PLIbook_reason_name(reason), tf_strgettime());

    switch(reason) {
        case REASON_ENDOFCOMPILE: /* misctf called at start of simulation */

        /* Check work area to see if application data is already
           allocated and the vector file opened. This check is necessary
           because REASON_RESTART can occur before REASON_ENDOFCOMPILE */
           data_p = (PLIbook_stim_data_p)tf_getworkarea();
           if (data_p)
               return(0); /* abort if work area already contains data */

        /* allocate a memory block for data storage */
           data_p=(PLIbook_stim_data_p)malloc(sizeof(PLIbook_stim_data_s));

        /* store a pointer to the application data in the work area */
           tf_setworkarea((char *)data_p);

        /* fill in the application data fields */
           data_p->file_ptr = fopen(tf_getcstringp(1), ""r"");
           if ( !data_p->file_ptr ) {
               tf_error(""read_stimulus_?? could not open file %s"",
                        tf_getcstringp(1));
               tf_dofinish(); /* exit simulation if cannot open file */
               break;
           }
           data_p->file_position = ftell(data_p->file_ptr);
           data_p->vector = (char *) malloc((tf_sizep(2) * 8) + 1);
           strcpy(data_p->dummy_msg, ""Hello world"");
           break;

        case REASON_REACTIVATE: /* misctf called by tf_setdelay */

        /* get the pointer to the data structure from the work area */
           data_p = (PLIbook_stim_data_p)tf_getworkarea();
","Caption: ""Example of a Verilog PLI misctf routine used for reading stimulus data during simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p340.jpg,True,"The image contains a fragment of code written in the Verilog hardware description language. Here is the code snippet:

```verilog
reg [19:0] input_vector;

always @(posedge clock)
    $read_test_vector(""vector_file"", input_vector);
```

This Verilog code defines a 20-bit register named `input_vector` and specifies a procedural block that triggers on the positive edge of a clock signal (`posedge clock`). Inside the block, a system task named `$read_test_vector` is called with two arguments: the string `""vector_file""` and the `input_vector` register.","
reg [19:0] input_vector;

always @(posedge clock)
    $read_test_vector(""vector_file"", input_vector);
","""Overview of Verilog PLI TF Routines and Example Code Snippet for Reading Test Vectors""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p357.jpg,True,"The image contains the following Verilog code:

```verilog
bit [0:`$clog2(MAX_OUTSTANDING)] outstanding;
initial
    outstanding <= '0;
always @(posedge clk)
    outstanding <= outstanding + $sampled(start - complete);
```

This code snippet is related to encoding the number of outstanding transactions in a system as described in the accompanying text.","
bit [0:`$clog2(MAX_OUTSTANDING)] outstanding;
initial
    outstanding <= '0;
always @(posedge clk)
    outstanding <= outstanding + $sampled(start - complete);
","Caption: ""Verilog example of encoding the number of outstanding transactions in a hardware design, illustrating the use of the `$clog2` function and the `always` block to maintain state.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p343.jpg,True,"The image contains multiple snippets of Verilog code. Here are the code segments provided:

1.
```verilog
check mycheck(b, negedge clock);
end
end
endmodule : m
```

2.
```verilog
module m(input logic clock, b, en);
// ...
always @(posedge clock) begin
    if (en) begin
        // ...
    end
end
initial
    a1: assert property (@(negedge clock) s_eventually b);
endmodule : m
```

3.
```verilog
checker check(a, b, event clk = $inferred_clock);
a1: assert property(@clk a |=> b);
endchecker : check
module m(input logic clock, logic [7:0] req, ack);
// ...
always @(posedge clock) begin
    for (int i = 0; i < 8; i++)
        if (i == 3) begin
            // ...
            check mycheck(req[i], ack[i]);
        end
end
endmodule : m
```

This code highlights some Verilog constructs related to procedural concurrent assertions and checker instantiation in procedural loops.","
check mycheck(b, negedge clock);
end
end
endmodule : m


module m(input logic clock, b, en);
// ...
always @(posedge clock) begin
    if (en) begin
        // ...
    end
end
initial
    a1: assert property (@(negedge clock) s_eventually b);
endmodule : m


checker check(a, b, event clk = $inferred_clock);
a1: assert property(@clk a |=> b);
endchecker : check
module m(input logic clock, logic [7:0] req, ack);
// ...
always @(posedge clock) begin
    for (int i = 0; i < 8; i++)
        if (i == 3) begin
            // ...
            check mycheck(req[i], ack[i]);
        end
end
endmodule : m
","""Excerpt from a document discussing procedural concurrent assertions and checker instantiation in Verilog code.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p429.jpg,True,"The image contains Verilog code. Here it is:

```verilog
gen[i] = new(gen2drv[i], drv2gen[i], cfg.cells_per_chan[i], i);
drv[i] = new(gen2drv[i], drv2gen[i], Rx[i], i);
end

// Build monitors
mon = new[numTx];
foreach (mon[i])
  mon[i] = new(Tx[i], i);

// Connect scoreboard to drivers & monitors with callbacks
begin
  Scb_Driver_cbs sdc = new(scb);
  Scb_Monitor_cbs smc = new(scb);
  foreach (drv[i]) drv[i].cbsq.push_back(sdc);
  foreach (mon[i]) mon[i].cbsq.push_back(smc);
end

// Connect coverage to monitor with callbacks
begin
  Cov_Monitor_cbs smc = new(cov);
  foreach (mon[i])
    mon[i].cbsq.push_back(smc);
end

endfunction : build

//-----------------------------------------------------
// Start the transactors: generators, drivers, monitors
// Channels that are not in use don't get started
task Environment::run();
  int num_gen_running;

  // The CPU interface initializes before anyone else
  cpu.run();

  num_gen_running = numRx;

  // For each input RX channel, start generator and driver
  foreach(gen[i]) begin
    int j=i;  // Automatic var holds index in spawned threads
    fork
      begin
        if (cfg.in_use_Rx[j])
          gen[j].run();  // Wait for generator to finish
          num_gen_running--; // Decrement driver count
      end
      if (cfg.in_use_Rx[j]) drv[j].run();
    join_none
end
``` 

Please note that some lines may be partial due to the page cropping, and there could be additional context or code that is not visible in the image.","
gen[i] = new(gen2drv[i], drv2gen[i], cfg.cells_per_chan[i], i);
drv[i] = new(gen2drv[i], drv2gen[i], Rx[i], i);
end

// Build monitors
mon = new[numTx];
foreach (mon[i])
  mon[i] = new(Tx[i], i);

// Connect scoreboard to drivers & monitors with callbacks
begin
  Scb_Driver_cbs sdc = new(scb);
  Scb_Monitor_cbs smc = new(scb);
  foreach (drv[i]) drv[i].cbsq.push_back(sdc);
  foreach (mon[i]) mon[i].cbsq.push_back(smc);
end

// Connect coverage to monitor with callbacks
begin
  Cov_Monitor_cbs smc = new(cov);
  foreach (mon[i])
    mon[i].cbsq.push_back(smc);
end

endfunction : build

//-----------------------------------------------------
// Start the transactors: generators, drivers, monitors
// Channels that are not in use don't get started
task Environment::run();
  int num_gen_running;

  // The CPU interface initializes before anyone else
  cpu.run();

  num_gen_running = numRx;

  // For each input RX channel, start generator and driver
  foreach(gen[i]) begin
    int j=i;  // Automatic var holds index in spawned threads
    fork
      begin
        if (cfg.in_use_Rx[j])
          gen[j].run();  // Wait for generator to finish
          num_gen_running--; // Decrement driver count
      end
      if (cfg.in_use_Rx[j]) drv[j].run();
    join_none
end
","""Excerpt from a Verilog testbench code demonstrating object initialization and interconnection within a SystemVerilog environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p425.jpg,True,"The image contains an example of Verilog code which is shown below:

```verilog
default clocking ck @ (posedge clk); endclocking
int my_count = 0;
seq_cov: cover sequence ( disable iff (reset)
    a ##[1:100] b
) begin
    my_count++;
    $display(""match of seq_cov at time %t"", $time);
end
```

This code snippet is demonstrating the use of a cover sequence syntactical form in Verilog. It sets up a coverage point to detect when signal `a` is followed by signal `b` within 100 clock ticks, and if this sequence occurs, it increments a counter `my_count` and displays a message.","
default clocking ck @ (posedge clk); endclocking
int my_count = 0;
seq_cov: cover sequence ( disable iff (reset)
    a ##[1:100] b
) begin
    my_count++;
    $display(""match of seq_cov at time %t"", $time);
end
","Caption: ""Example of a Verilog cover sequence for detecting a sequence of events within a specified number of clock cycles, including a disable iff condition and a counter for coverage tracking.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p432.jpg,True,"The image includes some code snippets related to interfacing C models with Verilog using TF routines. Here are the code snippets present in the image:

Verilog Shell Module (Step 1 - This appears to be pseudo-code or a representation):
```
void
C_model(...)
{
}
```

PLI Interface to C Model (Step 3 - Also seems to be pseudo or representation code):
```
int
c_mod_calltf()
{
}
```

C Model (Step 2 - Indicated by a box labeled module):
```
module
C_model(...)
endmodule
```

Please note that these code snippets might not be complete or syntactically correct Verilog or C code but rather schematic representations of where actual code would go in a larger system.","_model(...)
{
}

mod_calltf()
{
}


C_model(...)
endmodule
","Information on interfacing Verilog simulations with C models using TF routines, including a block diagram that outlines the steps involved.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p401.jpg,True,"The image contains the following Verilog code:

```verilog
// Rx interface with modports and clocking block
interface Rx_if (input logic clk);
  logic [7:0] data;
  logic soc, en, clav, rclk;

  clocking cb @(posedge clk);
    output data, soc, clav; // Directions are relative
    input en;               // to the testbench
  endclocking : cb

  modport TB (clocking cb);

  modport DUT (output en, rclk,
               input data, soc, clav);
endinterface : Rx_if

// Tx interface with modports and clocking block
interface Tx_if (input logic clk);
  logic [7:0] data;
  logic soc, en, clav, tclk;

  clocking cb @(posedge clk);
    input data, soc, en;
    output clav;
  endclocking : cb

  modport TB (clocking cb);

  modport DUT (output data, soc, en, tclk,
               input clav);
endinterface : Tx_if
```

This code provides examples of Verilog interfaces with modports and clocking blocks for an Rx (Receive) interface and a Tx (Transmit) interface.","
// Rx interface with modports and clocking block
interface Rx_if (input logic clk);
  logic [7:0] data;
  logic soc, en, clav, rclk;

  clocking cb @(posedge clk);
    output data, soc, clav; // Directions are relative
    input en;               // to the testbench
  endclocking : cb

  modport TB (clocking cb);

  modport DUT (output en, rclk,
               input data, soc, clav);
endinterface : Rx_if

// Tx interface with modports and clocking block
interface Tx_if (input logic clk);
  logic [7:0] data;
  logic soc, en, clav, tclk;

  clocking cb @(posedge clk);
    input data, soc, en;
    output clav;
  endclocking : cb

  modport TB (clocking cb);

  modport DUT (output data, soc, en, tclk,
               input clav);
endinterface : Tx_if
",Sample Verilog interfaces for an ATM router with clocking blocks and modports.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p182.jpg,True,"The image contains Verilog code. Here is the code transcribed from the image:

```verilog
program automatic test;

task start_a_thread (int delay);
  fork
    begin
      $display(""%0d start_a_thread(%0d) - started"", $time, delay);
      #(delay);
      $display(""%0d start_a_thread(%0d) - complete"", $time, delay);
    end
  join_none
endtask

initial begin
  do_action();
  start_a_thread(10);
  start_a_thread(30);
  #15 disable fork; // GOTCHA!
  #100; // wait for all threads to complete
end

task do_action;
  start_a_thread(20);
endtask

endprogram
```

This piece of code illustrates a problem described as ""Disable fork kills too many threads,"" where using `disable fork` can unintentionally stop threads outside the scope of the code that contains the `disable` statement.","
program automatic test;

task start_a_thread (int delay);
  fork
    begin
      $display(""%0d start_a_thread(%0d) - started"", $time, delay);
      #(delay);
      $display(""%0d start_a_thread(%0d) - complete"", $time, delay);
    end
  join_none
endtask

initial begin
  do_action();
  start_a_thread(10);
  start_a_thread(30);
  #15 disable fork; // GOTCHA!
  #100; // wait for all threads to complete
end

task do_action;
  start_a_thread(20);
endtask

endprogram
","""Example of a Verilog 'disable fork' pitfall where it inadvertently terminates threads beyond the intended scope""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p368.jpg,True,"The image includes Verilog code within an excerpt from a book. Here is the code:

```verilog
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
/***********************************************************************
* misctf application
*
* The misctf application is used to call tf_exprinfo() at the
* beginning of simulation, so that the memory allocated by
* tf_exprinfo() is only allocated one time for each instance of
* $read_4state_value.
***********************************************************************/
int PLIbook_Read4StateValue_misctf(int user_data, int reason)
{
  p_tf_exprinfo info_p; /* pointer to structure for tf_exprinfo() */
  p_vectorial val_array; /* pointer to value array in info struct */
  int i;
  if (reason != REASON_ENDOFCOMPILE)
    return(0); /* exit now if this is not the start of simulation */

  /* allocate memory for an s_tf_exprinfo structure */
  info_p = (p_tf_exprinfo)malloc(sizeof(s_tf_exprinfo));
  tf_exprinfo(1, info_p); /* read expression info for arg 1 */
  set_workarea((char *)info_p); /* save info point in workarea */

  io_printf(""Expression info:\n"");
  switch (info_p->expr_type) {
    case TF_NULLPARAM:    io_printf("" type = TF_NULLPARAM\n""); break;
    case TF_STRING:       io_printf("" type = TF_STRING\n""); break;
    case TF_READONLY:     io_printf("" type = TF_READONLY\n""); break;
    case TF_READONLYREAL: io_printf("" type = TF_READONLYREAL\n""); break;
    case TF_READWRITE:    io_printf("" type = TF_READWRITE\n""); break;
    case TF_READWRITEREAL:io_printf("" type = TF_READWRITEREAL\n""); break;
    case TF_RWBITSELECT:  io_printf("" type = TF_RWBITSELECT\n""); break;
    case TF_RWPARTSELECT: io_printf("" type = TF_RWPARTSELECT\n""); break;
    case TF_RWMEMSELECT:  io_printf("" type = TF_RWMEMSELECT\n""); break;
    default:              io_printf("" type is unknown (%d)\n"", info_p->expr_type);
  }
}
```

This Verilog code is related to the Verilog Programming Language Interface (PLI) and demonstrates the use of `tf_exprinfo()` function and a misctf application to handle expressions during simulation.","
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
/***********************************************************************
* misctf application
*
* The misctf application is used to call tf_exprinfo() at the
* beginning of simulation, so that the memory allocated by
* tf_exprinfo() is only allocated one time for each instance of
* $read_4state_value.
***********************************************************************/
int PLIbook_Read4StateValue_misctf(int user_data, int reason)
{
  p_tf_exprinfo info_p; /* pointer to structure for tf_exprinfo() */
  p_vectorial val_array; /* pointer to value array in info struct */
  int i;
  if (reason != REASON_ENDOFCOMPILE)
    return(0); /* exit now if this is not the start of simulation */

  /* allocate memory for an s_tf_exprinfo structure */
  info_p = (p_tf_exprinfo)malloc(sizeof(s_tf_exprinfo));
  tf_exprinfo(1, info_p); /* read expression info for arg 1 */
  set_workarea((char *)info_p); /* save info point in workarea */

  io_printf(""Expression info:\n"");
  switch (info_p->expr_type) {
    case TF_NULLPARAM:    io_printf("" type = TF_NULLPARAM\n""); break;
    case TF_STRING:       io_printf("" type = TF_STRING\n""); break;
    case TF_READONLY:     io_printf("" type = TF_READONLY\n""); break;
    case TF_READONLYREAL: io_printf("" type = TF_READONLYREAL\n""); break;
    case TF_READWRITE:    io_printf("" type = TF_READWRITE\n""); break;
    case TF_READWRITEREAL:io_printf("" type = TF_READWRITEREAL\n""); break;
    case TF_RWBITSELECT:  io_printf("" type = TF_RWBITSELECT\n""); break;
    case TF_RWPARTSELECT: io_printf("" type = TF_RWPARTSELECT\n""); break;
    case TF_RWMEMSELECT:  io_printf("" type = TF_RWMEMSELECT\n""); break;
    default:              io_printf("" type is unknown (%d)\n"", info_p->expr_type);
  }
}
","""Example of Verilog code using the tf_evaluatep() routine from The Verilog PLI Handbook demonstrating memory allocation and accessing task/function argument's value.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p196.jpg,True,"The image provides an excerpt from a book or document related to Verilog and SystemVerilog guidelines. It includes a section discussing how to avoid ""Gotchas"" (common mistakes or traps) when dealing with constraints in Verilog/SystemVerilog. Specifically, it recommends breaking down constraints with compound Boolean operations into separate statements. Here is the Verilog code from the image:

```verilog
constraint increasing {
  lo < med;      // lo is constrained to be less than med
  med < hi;      // med is constrained to be less than hi
}

constraint equal {
  a == b;         // a is constrained to be equal to b
  b == c;         // b is constrained to be equal to c
}
```","
constraint increasing {
  lo < med;      // lo is constrained to be less than med
  med < hi;      // med is constrained to be less than hi
}

constraint equal {
  a == b;         // a is constrained to be equal to b
  b == c;         // b is constrained to be equal to c
}
","Caption: ""Best Practices for Verilog Constraints to Avoid Simulation Gotchas.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p419.jpg,True,"The image contains an excerpt discussing recursive properties in Verilog or a similar hardware description language, including an example of problematic recursive code. Here is the code provided in the example:

```verilog
property illegal_arg(longint unsigned u, v, w);
    u == v*w and nexttime illegal_arg(u, v+w, v*w);
endproperty
```

And the comment in the image describes how this recursion can lead to an explosion of actual argument expressions, detailing how the comparison `u == v*w` unfolds across cycles.","
property illegal_arg(longint unsigned u, v, w);
    u == v*w and nexttime illegal_arg(u, v+w, v*w);
endproperty
","A page from a technical document discussing recursive properties in Verilog, specifically highlighting issues with recursive argument passing in property declaration.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p123.jpg,True,"The image contains an excerpt related to Verilog code which deals with properties and assertions in a hardware verification context. Here is the code present in the image:

```verilog
property IV(Sig, numClocks, enb, lastV);
    (lastV == $past(Sig, numClocks, enb) );
endproperty

assert property (@(posedge clk) done |-> IV(mySig, 2, enb, 'ha)) else
    $display($stime,,""FAIL Expected lastVa=%h\n"",lastVal);

cover property (@(posedge clk) done |-> IV(mySig, 2, enb, 'ha))
    $display($stime,,""PASS Expected lastVa=%h\n"",lastVal);

always @(posedge clk)
    $display($stime,,""clk=%b mySig=%h past=%h enb=%h done=%b"", clk, mySig, $past(mySig, 2, enb), enb, done);

$past(mySig, 2, enb), enb, done);
```

Additionally, there are example logs related to the use of `$past` function in simulations:

```
# run -all
# 10 clk=1 mySig=a past=0 enb=1 done=0
# 20 clk=1 mySig=5 past=0 enb=1 done=0
# 30 clk=1 mySig=5 past=a enb=1 done=1
# PASS Expected lastVa=a
...
# 40 clk=1 mySig=5 past=5 enb=1 done=0
# 50 clk=1 mySig=a past=5 enb=1 done=1
# FAIL Expected lastVa=a
...
# 60 clk=1 mySig=a past=5 enb=1 done=0
# 70 clk=1 mySig=5 past=5 enb=0 done=0
# 80 clk=1 mySig=5 past=5 enb=0 done=1
# FAIL Expected lastVa=a
...
```

The code showcases the use of SystemVerilog assertions (SVA) to automatically check if certain conditions hold true during the simulation of the hardware design. In particular, it illustrates using the `$past` function to reference previous signal values based on clock cycles.","
property IV(Sig, numClocks, enb, lastV);
    (lastV == $past(Sig, numClocks, enb) );
endproperty

assert property (@(posedge clk) done |-> IV(mySig, 2, enb, 'ha)) else
    $display($stime,,""FAIL Expected lastVa=%h\n"",lastVal);

cover property (@(posedge clk) done |-> IV(mySig, 2, enb, 'ha))
    $display($stime,,""PASS Expected lastVa=%h\n"",lastVal);

always @(posedge clk)
    $display($stime,,""clk=%b mySig=%h past=%h enb=%h done=%b"", clk, mySig, $past(mySig, 2, enb), enb, done);

$past(mySig, 2, enb), enb, done);

-all
# 10 clk=1 mySig=a past=0 enb=1 done=0
# 20 clk=1 mySig=5 past=0 enb=1 done=0
# 30 clk=1 mySig=5 past=a enb=1 done=1
# PASS Expected lastVa=a
...
# 40 clk=1 mySig=5 past=5 enb=1 done=0
# 50 clk=1 mySig=a past=5 enb=1 done=1
# FAIL Expected lastVa=a
...
# 60 clk=1 mySig=a past=5 enb=1 done=0
# 70 clk=1 mySig=5 past=5 enb=0 done=0
# 80 clk=1 mySig=5 past=5 enb=0 done=1
# FAIL Expected lastVa=a
...
","Caption: ""Example of Verilog SystemVerilog Assertion (SVA) using $past function and a simulation log demonstrating assertion checks in Verilog.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p415.jpg,True,"The image contains Verilog code samples from a document or book referring to parameterized counters and interfaces. Here is the code from the image:

Sample 10.26:
```verilog
// Simple N-bit counter with load and active-low reset
module counter #(BIT_WIDTH = 8) (x_if.DUT xi);
    logic [BIT_WIDTH-1:0] count;
...
```

Sample 10.27:
```verilog
interface x_if #(BIT_WIDTH=8) (input logic clk);
    logic [BIT_WIDTH-1:0] din, dout;
...
```

Sample 10.28:
```verilog
module top;
    parameter NUM_XI = 2;  // Number of design instances
    parameter BIT_WIDTH = 4; // Width of counter and bus
    
    // Clock generator
    bit clk;
    initial begin
        clk <= '0';
        forever #20 clk = ~clk;
    end
    
    // Instantiate N interfaces
    x_if #(.BIT_WIDTH(BIT_WIDTH)) xi[NUM_XI] (clk);
    
    // Testbench with the number of interfaces and bit width
    test #(.NUM_XI(NUM_XI), .BIT_WIDTH(BIT_WIDTH)) tb();
    
    // Generate N counter instances
    generate
    for (genvar i=0; i<NUM_XI; i++)
    begin : count_blk
        counter #(.BIT_WIDTH(BIT_WIDTH)) c (xi[i]);
    end
    endgenerate
    
endmodule : top
```

The code snippets are from examples related to parameterized models in Verilog, showing the syntax and structure for creating modular and scalable digital designs.","
// Simple N-bit counter with load and active-low reset
module counter #(BIT_WIDTH = 8) (x_if.DUT xi);
    logic [BIT_WIDTH-1:0] count;
...


interface x_if #(BIT_WIDTH=8) (input logic clk);
    logic [BIT_WIDTH-1:0] din, dout;
...


module top;
    parameter NUM_XI = 2;  // Number of design instances
    parameter BIT_WIDTH = 4; // Width of counter and bus
    
    // Clock generator
    bit clk;
    initial begin
        clk <= '0';
        forever #20 clk = ~clk;
    end
    
    // Instantiate N interfaces
    x_if #(.BIT_WIDTH(BIT_WIDTH)) xi[NUM_XI] (clk);
    
    // Testbench with the number of interfaces and bit width
    test #(.NUM_XI(NUM_XI), .BIT_WIDTH(BIT_WIDTH)) tb();
    
    // Generate N counter instances
    generate
    for (genvar i=0; i<NUM_XI; i++)
    begin : count_blk
        counter #(.BIT_WIDTH(BIT_WIDTH)) c (xi[i]);
    end
    endgenerate
    
endmodule : top
","""Examples of Parameterized Modules and Interfaces in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p436.jpg,True,"The image contains a code snippet written in C. Here is the code provided in the image:

```c
#include <math.h>
#include <errno.h>
void PLIbook_ScientificALU_C_model(
    double a,        /* input */
    double b,        /* input */
    int opcode,      /* input */
    double *result,  /* output from ALU */
    int *excep,      /* output; set if result is out of range */
    int *err)        /* output; set if input is out of range */
{
    switch (opcode) {
        case 0x0: *result = pow (a, b); break;
        case 0x1: *result = sqrt (a); break;
        case 0x2: *result = exp (a); break;
        case 0x3: *result = ldexp (a, (int)b); break;
        case 0x4: *result = fabs (a); break;
        case 0x5: *result = fmod (a, b); break;
        case 0x6: *result = ceil (a); break;
        case 0x7: *result = floor (a); break;
        case 0x8: *result = log (a); break;
        case 0x9: *result = log10 (a); break;
        case 0xA: *result = sin (a); break;
        case 0xB: *result = cos (a); break;
        case 0xC: *result = tan (a); break;
        case 0xD: *result = asin (a); break;
        case 0xE: *result = acos (a); break;
        case 0xF: *result = atan (a); break;
    }
    *err = (errno == EDOM);     /* arg to math func. out of range */
    *excep = (errno == ERANGE); /* result of math func. out of range */
    errno = 0;                  /* clear the error flag */
    if (*err) *result = 0.0;    /* set result to 0 if error occurred */
    return;
}
```

This function is a C model for a scientific arithmetic logic unit (ALU) that performs different operations based on the opcode received. It also checks for domain and range errors using the `errno` variable and sets the corresponding output pointers accordingly.","ude <math.h>
#include <errno.h>
void PLIbook_ScientificALU_C_model(
    double a,        /* input */
    double b,        /* input */
    int opcode,      /* input */
    double *result,  /* output from ALU */
    int *excep,      /* output; set if result is out of range */
    int *err)        /* output; set if input is out of range */
{
    switch (opcode) {
        case 0x0: *result = pow (a, b); break;
        case 0x1: *result = sqrt (a); break;
        case 0x2: *result = exp (a); break;
        case 0x3: *result = ldexp (a, (int)b); break;
        case 0x4: *result = fabs (a); break;
        case 0x5: *result = fmod (a, b); break;
        case 0x6: *result = ceil (a); break;
        case 0x7: *result = floor (a); break;
        case 0x8: *result = log (a); break;
        case 0x9: *result = log10 (a); break;
        case 0xA: *result = sin (a); break;
        case 0xB: *result = cos (a); break;
        case 0xC: *result = tan (a); break;
        case 0xD: *result = asin (a); break;
        case 0xE: *result = acos (a); break;
        case 0xF: *result = atan (a); break;
    }
    *err = (errno == EDOM);     /* arg to math func. out of range */
    *excep = (errno == ERANGE); /* result of math func. out of range */
    errno = 0;                  /* clear the error flag */
    if (*err) *result = 0.0;    /* set result to 0 if error occurred */
    return;
}
","""Excerpt from a technical document detailing an example of a C model for a scientific ALU (Arithmetic Logic Unit) and describing the use of a Verilog shell module to interface with C models.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p421.jpg,True,"The image contains Verilog code defining several properties. Here is the code transcribed from the image:

```verilog
property p1;
  a |-> p2;
endproperty

property p2;
  p4 and (b |-> p1);
endproperty

property p3;
  disable iff (reset)
  p4 and nexttime(a |-> p2);
endproperty

property p4;
  reject_on(bad)
  a |=> not p1;
endproperty
```","
property p1;
  a |-> p2;
endproperty

property p2;
  p4 and (b |-> p1);
endproperty

property p3;
  disable iff (reset)
  p4 and nexttime(a |-> p2);
endproperty

property p4;
  reject_on(bad)
  a |=> not p1;
endproperty
",Verilog code snippet depicting recursive and nonrecursive property declarations for system verification.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p347.jpg,True,"The image contains Verilog code. Here it is:

```verilog
checker check1(a, clk);
  always_ff @(posedge clk)
    a1: assert property(a);
endchecker : check1
```

```verilog
checker check2(a, event clk = $inferred_clock);
  always_ff @clk
    a2: assert property(a);
endchecker : check2
```

```verilog
module m(input logic clock, b, ...);
  // ...
  check2 c1(b, posedge clock);
  check2 c2(b, clock); // Illegal
  always @(edge clock) begin: B1
    check2 c3(b);
  end
  always @(edge clock or negedge b) begin: B2
    check2 c4(b, edge clock);
    check2 c5(b); // Illegal
  end
endmodule : m
```

This code is showing examples of using checkers in Verilog for procedural concurrent assertions, and illustrating legal and illegal checker instantiations related to clock inference.","
checker check1(a, clk);
  always_ff @(posedge clk)
    a1: assert property(a);
endchecker : check1


checker check2(a, event clk = $inferred_clock);
  always_ff @clk
    a2: assert property(a);
endchecker : check2


module m(input logic clock, b, ...);
  // ...
  check2 c1(b, posedge clock);
  check2 c2(b, clock); // Illegal
  always @(edge clock) begin: B1
    check2 c3(b);
  end
  always @(edge clock or negedge b) begin: B2
    check2 c4(b, edge clock);
    check2 c5(b); // Illegal
  end
endmodule : m
","""Excerpt from a textbook on Procedural Concurrent Assertions in Verilog showcasing examples of checker instantiations and their inferred clocks.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p350.jpg,True,"Here is the code that is visible in the image:

```c
#include “veriuser.h”                              /* IEEE 1364 PLI TF routine library */
/**************************************************************
 * Checktf application
 **************************************************************/
int PLIbook_realpow_checktf()
{
    int arg_type;

    if (tf_nump() != 2) {
        tf_error(“$pow must have 2 arguments.\n”);
        return(0);
    }
    arg_type = tf_typep(1);
    if (arg_type == TF_NULLPARAM) {
        tf_error(“$pow arg 1 cannot be null.\n”);
    }
    else
        if ( (arg_type != TF_READONLY) &&
             (arg_type != TF_READONLYREAL) &&
             (arg_type != TF_READWRITE) &&
             (arg_type != TF_READWRITEREAL) ) {
            tf_error(“$pow arg 1 must be number, variable or net.\n”);
    }
    arg_type = tf_typep(2);
    if (arg_type == TF_NULLPARAM) {
        tf_error(“$pow arg 2 cannot be null.\n”);
    }
    else
```

This is a fragment of C code intended for use with the Verilog Programming Language Interface (PLI), which allows users to write C functions to interact with simulations written in Verilog. The function `PLIbook_realpow_checktf` seems to be a checktf application that validates the arguments passed to a `$pow` system function. Please note that the code snippet is incomplete, and also contains special quotation marks that are not standard in C code; they should be normal double quotes ("") if the code were to compile.","ude “veriuser.h”                              /* IEEE 1364 PLI TF routine library */
/**************************************************************
 * Checktf application
 **************************************************************/
int PLIbook_realpow_checktf()
{
    int arg_type;

    if (tf_nump() != 2) {
        tf_error(“$pow must have 2 arguments.\n”);
        return(0);
    }
    arg_type = tf_typep(1);
    if (arg_type == TF_NULLPARAM) {
        tf_error(“$pow arg 1 cannot be null.\n”);
    }
    else
        if ( (arg_type != TF_READONLY) &&
             (arg_type != TF_READONLYREAL) &&
             (arg_type != TF_READWRITE) &&
             (arg_type != TF_READWRITEREAL) ) {
            tf_error(“$pow arg 1 must be number, variable or net.\n”);
    }
    arg_type = tf_typep(2);
    if (arg_type == TF_NULLPARAM) {
        tf_error(“$pow arg 2 cannot be null.\n”);
    }
    else
","Caption: ""Instruction on implementing PLI routines in Verilog to handle real numbers as inputs and outputs using System Tasks, with an example of error checking for $realpow function arguments.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p353.jpg,True,"The image contains Verilog code. Below is the code provided in the image:

Code from Fig. 15.1:
```verilog
dataType dataIn_D1, dataIn_D2, dataIn_D3;
always @(posedge clk) begin
    dataIn_D1 <= $sampled(dataIn);
    dataIn_D2 <= dataIn_D1;
    dataIn_D3 <= dataIn_D2;
end
```

Code from Fig. 15.2:
```verilog
property p_pipeline_data_check;
    dataType data;
    (start, data = dataIn)
    |-> ##LATENCY dataOut == data;
endproperty

a_pipeline_data_check: assert property (p_pipeline_data_check);
```

This code is representing examples of how to encode a fixed latency data pipeline data check with and without the use of local variables in Verilog. The first block of code shows a way of doing this without local variables by cascading the delay, and the second block uses a local variable within a property to perform the check.","
dataType dataIn_D1, dataIn_D2, dataIn_D3;
always @(posedge clk) begin
    dataIn_D1 <= $sampled(dataIn);
    dataIn_D2 <= dataIn_D1;
    dataIn_D3 <= dataIn_D2;
end


property p_pipeline_data_check;
    dataType data;
    (start, data = dataIn)
    |-> ##LATENCY dataOut == data;
endproperty

a_pipeline_data_check: assert property (p_pipeline_data_check);
","""Verilog code for fixed latency data pipeline and assertion properties without using local variables""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p344.jpg,True,"The image contains a text segment that includes a small piece of code. Here is the code snippet from the image:

```verilog
$read_vector_file(""vectors.pat"", in1);
```

Additionally, there's a reference to a call to a TF routine (not a complete line of code, rather a comment and part of the code) below this snippet:

```
tf_putp(2, c_value);
```

This represents a function call in C to place a 32-bit value into the second task/function argument in a Verilog simulation using the Programming Language Interface (PLI).","
$read_vector_file(""vectors.pat"", in1);

p(2, c_value);
","""Interfacing between C and Verilog using PLI to manipulate system task/function arguments""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p439.jpg,True,"The image contains sample Verilog code for a UNI_generator class and the beginning of a Driver class. Here's the code from the image:

```verilog
class UNI_generator;
  UNI_cell blueprint; // Blueprint for generator
  mailbox gen2drv;   // Mailbox to driver for cells
  event drv2gen;     // Event from driver when done with cell
  int nCells;        // Num cells for this generator to create
  int PortID;        // Which Rx port are we generating?

  function new(input mailbox gen2drv,
               input event drv2gen,
               input int nCells, PortID);
    this.gen2drv = gen2drv;
    this.drv2gen = drv2gen;
    this.nCells = nCells;
    this.PortID = PortID;
    blueprint = new();
  endfunction : new

  task run();
    UNI_cell c;
    repeat (nCells) begin
      `SV_RAND_CHECK(blueprint.randomize());
      $cast(c, blueprint.copy());
      c.display($sformatf(""@%0t: Gen%0d: "", $time, PortID));
      gen2drv.put(c);
      @drv2gen; // Wait for driver to finish with it
    end
  endtask : run

endclass : UNI_generator

Sample 11.19 driver class

typedef class Driver_cbs;

class Driver;
  mailbox gen2drv;      // For cells sent from generator
  event drv2gen;        // Tell generator when I am done with cell
  vUtopiaRx Rx;         // Virtual ifc for transmitting cells
```

Please note that there may be some text before and after the code blocks that are part of the book's narrative and not actual Verilog code. However, all the Verilog code present in the image has been provided above.","
class UNI_generator;
  UNI_cell blueprint; // Blueprint for generator
  mailbox gen2drv;   // Mailbox to driver for cells
  event drv2gen;     // Event from driver when done with cell
  int nCells;        // Num cells for this generator to create
  int PortID;        // Which Rx port are we generating?

  function new(input mailbox gen2drv,
               input event drv2gen,
               input int nCells, PortID);
    this.gen2drv = gen2drv;
    this.drv2gen = drv2gen;
    this.nCells = nCells;
    this.PortID = PortID;
    blueprint = new();
  endfunction : new

  task run();
    UNI_cell c;
    repeat (nCells) begin
      `SV_RAND_CHECK(blueprint.randomize());
      $cast(c, blueprint.copy());
      c.display($sformatf(""@%0t: Gen%0d: "", $time, PortID));
      gen2drv.put(c);
      @drv2gen; // Wait for driver to finish with it
    end
  endtask : run

endclass : UNI_generator

Sample 11.19 driver class

typedef class Driver_cbs;

class Driver;
  mailbox gen2drv;      // For cells sent from generator
  event drv2gen;        // Tell generator when I am done with cell
  vUtopiaRx Rx;         // Virtual ifc for transmitting cells
","Caption: ""Verilog code for a UNI cell generator class from a SystemVerilog testbench, showcasing object-oriented programming for simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p435.jpg,True,"This image displays a page with text and Verilog code. Here is the code written on this page:

```verilog
checker req_ack_window2(
    req, ack,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable
);
    default clocking @clk; endclocking
    default disable iff rst;
    int unsigned n = 0;

    always_ff @clk
        if (rst || ack) n <= 0;
        else if (req)   n <= 1;
        else if (n == 0) n <= 0;
        else             n <= n + 1;

    covergroup cg_win @(clk);
        coverpoint n iff (ack && !rst);
    endgroup : cg_win
    cg_win cg = new();
endchecker : req_ack_window2
```

The code snippet defines a checker module in SystemVerilog meant for coverage analysis and is part of a book or document discussing ""Coverage on Weak and Strong Properties"".","
checker req_ack_window2(
    req, ack,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable
);
    default clocking @clk; endclocking
    default disable iff rst;
    int unsigned n = 0;

    always_ff @clk
        if (rst || ack) n <= 0;
        else if (req)   n <= 1;
        else if (n == 0) n <= 0;
        else             n <= n + 1;

    covergroup cg_win @(clk);
        coverpoint n iff (ack && !rst);
    endgroup : cg_win
    cg_win cg = new();
endchecker : req_ack_window2
","""Verilog example of a checker module to cover the time interval distribution between request and acknowledgment signals""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p411.jpg,True,"Here is the Verilog code presented in the image:

```verilog
program automatic test #(NUM_XI=2);

  virtual x_if.TB vxi[NUM_XI]; // Virtual interface array
  Driver driver[];

  initial begin
    // Connect local virtual interface to top
    vxi = top.xi;

    // Create N drivers
    driver = new[NUM_XI];
    foreach (driver[i])
      driver[i] = new(vxi[i], i);

    foreach (driver[i]) begin
      automatic int j = i;
      fork
        begin
          driver[j].reset();
          driver[j].load_op();
        end
        join_none
    end

    repeat (10) @(vxi[0].cb);

  end

endprogram
```

This Verilog code snippet is part of a textbook or document discussing advanced interfaces in Verilog, specifically a counter testbench using virtual interfaces.","
program automatic test #(NUM_XI=2);

  virtual x_if.TB vxi[NUM_XI]; // Virtual interface array
  Driver driver[];

  initial begin
    // Connect local virtual interface to top
    vxi = top.xi;

    // Create N drivers
    driver = new[NUM_XI];
    foreach (driver[i])
      driver[i] = new(vxi[i], i);

    foreach (driver[i]) begin
      automatic int j = i;
      fork
        begin
          driver[j].reset();
          driver[j].load_op();
        end
        join_none
    end

    repeat (10) @(vxi[0].cb);

  end

endprogram
","""Example of a Verilog testbench utilizing virtual interfaces from a technical document""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p192.jpg,True,"```verilog
program automatic test;
  class Bad;
    rand bit [7:0] a, b;
    constraint ab {a < b; 
                   b < a;} // this constraint cannot be solved
  endclass

  initial begin
    Bad b = new;
    assert(b.randomize()) else $fatal; // OK, checking if
                                       // randomize fails
  end
endprogram
```","
program automatic test;
  class Bad;
    rand bit [7:0] a, b;
    constraint ab {a < b; 
                   b < a;} // this constraint cannot be solved
  endclass

  initial begin
    Bad b = new;
    assert(b.randomize()) else $fatal; // OK, checking if
                                       // randomize fails
  end
endprogram
","""An example of a Verilog program with a constraint that cannot be solved, highlighting a common gotcha in Verilog/SystemVerilog programming.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p377.jpg,True,"```verilog
covergroup CovDst12;
  coverpoint tr.dst
    { option.auto_bin_max = 2; } // Divide into 2 bins
endgroup
```","
covergroup CovDst12;
  coverpoint tr.dst
    { option.auto_bin_max = 2; } // Divide into 2 bins
endgroup
","Caption: ""An excerpt discussing automatic bin creation and limiting the number of bins in SystemVerilog covergroups, with a code example setting `auto_bin_max` to 2.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p284.jpg,True,"The image contains two Verilog code snippets.

Here's the first snippet:

```verilog
parameter NumAddr = 1024;
...
generate
    genvar i;
    for (i=0; i<NumAddr; i=i+1)
    begin : Decode
        assign #1 AdrEna[i] = (i==Address) ? 1'b1 : 1'b0;
    end
endgenerate
```

And the second snippet:

```verilog
parameter NumAddr = 1024;
integer i;
...
reg [NumAddr-1:0] AdrEna;
always @(Address)
begin : Decoder
    for (i=0; i<NumAddr; i=i+1)
        #1 AdrEna[i] = (i==Address) ? 1'b1 : 1'b0; // PROBLEM!
end
```

The text accompanying these snippets discusses Verilog code for creating a structure for an address decoder, and the issues with using delays in procedural code blocks.","
parameter NumAddr = 1024;
...
generate
    genvar i;
    for (i=0; i<NumAddr; i=i+1)
    begin : Decode
        assign #1 AdrEna[i] = (i==Address) ? 1'b1 : 1'b0;
    end
endgenerate


parameter NumAddr = 1024;
integer i;
...
reg [NumAddr-1:0] AdrEna;
always @(Address)
begin : Decoder
    for (i=0; i<NumAddr; i=i+1)
        #1 AdrEna[i] = (i==Address) ? 1'b1 : 1'b0; // PROBLEM!
end
",Example of a combinatorial decoder in Verilog using generate and procedural assignment.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p186.jpg,True,"```verilog
task start_test(int thread, int inst); // static task
begin : monitor // named block (not forked threads)
  $display(""@%0d: %m inst: %0d, thread: %0d, before disable"", $time, inst, thread);
  #10;
  if ((thread==2) && (inst==2))
    disable monitor; // OK, only affects this thread
  #1;
  $display(""@%0d: %m inst: %0d, thread: %0d, after disable"", $time, inst, thread);
end: monitor
endtask: start_test
endmodule: test

module top;
test t1 (.instance_id(1), .thread_id(1)); // nine instances of
test t2 (.instance_id(1), .thread_id(2)); // test module
test t3 (.instance_id(1), .thread_id(3));
test t4 (.instance_id(2), .thread_id(1));
test t5 (.instance_id(2), .thread_id(2));
test t6 (.instance_id(2), .thread_id(3));
test t7 (.instance_id(3), .thread_id(1));
test t8 (.instance_id(3), .thread_id(2));
test t9 (.instance_id(3), .thread_id(3));
endmodule: top
```

The above code is a Verilog code snippet found in the image.","
task start_test(int thread, int inst); // static task
begin : monitor // named block (not forked threads)
  $display(""@%0d: %m inst: %0d, thread: %0d, before disable"", $time, inst, thread);
  #10;
  if ((thread==2) && (inst==2))
    disable monitor; // OK, only affects this thread
  #1;
  $display(""@%0d: %m inst: %0d, thread: %0d, after disable"", $time, inst, thread);
end: monitor
endtask: start_test
endmodule: test

module top;
test t1 (.instance_id(1), .thread_id(1)); // nine instances of
test t2 (.instance_id(1), .thread_id(2)); // test module
test t3 (.instance_id(1), .thread_id(3));
test t4 (.instance_id(2), .thread_id(1));
test t5 (.instance_id(2), .thread_id(2));
test t6 (.instance_id(2), .thread_id(3));
test t7 (.instance_id(3), .thread_id(1));
test t8 (.instance_id(3), .thread_id(2));
test t9 (.instance_id(3), .thread_id(3));
endmodule: top
","Caption: ""Example of Verilog task and simulation showing the use of named blocks and thread management with 'disable' statement.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p409.jpg,True,"```verilog
property p_fifo_data_check;
  start |-> p_fifo_data_check_recur(dataIn, outstanding);
endproperty

property p_fifo_data_check_recur(
  local input dataType data,
  local input bit [0:$clog2(MAX_OUTSTANDING)] numAhead
);
  ##1 complete[-1]
    |->
      if (numAhead == 0)
        dataOut == data;
      else
        p_fifo_data_check_recur(data, numAhead--);
endproperty
```","
property p_fifo_data_check;
  start |-> p_fifo_data_check_recur(dataIn, outstanding);
endproperty

property p_fifo_data_check_recur(
  local input dataType data,
  local input bit [0:$clog2(MAX_OUTSTANDING)] numAhead
);
  ##1 complete[-1]
    |->
      if (numAhead == 0)
        dataOut == data;
      else
        p_fifo_data_check_recur(data, numAhead--);
endproperty
","""Verilog code example demonstrating a recursive property for FIFO protocol data checking.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p405.jpg,True,"The image contains Verilog code, which I will transcribe for you:

```verilog
Sample 10.7 Monitor class using virtual interfaces

typedef virtual Tx_if vTx_t;

class Monitor;
    int             stream_id;
    mailbox         rcv_mbx;
    vTx_t           Tx;

function new(input mailbox rcv_mbx,
             input int       stream_id,
             input vTx_t     Tx);
    this.rcv_mbx = rcv_mbx;
    this.stream_id = stream_id;
    this.Tx = Tx;
endfunction // new

task run();
    ATM_Cell ac;

    fork
    begin
        // Initialize output signals
        Tx.cb.clav <= 0;                        // Not ready to receive
        @Tx.cb;

        $display(""%0d: Monitor::run[%0d] starting"",
                 $time, stream_id);

        forever begin
            receive_cell(ac);
        end
    end
    join_none

endtask : run

task receive_cell(inout ATM_Cell ac);
    bit [7:0] bytes[];

    bytes = new[ATM_CELL_SIZE];
    ac = new();                               // Initialize the cell

    @Tx.cb;
    Tx.cb.clav <= 1;                          // Assert ready to receive
    while (Tx.cb.soc != 1'b1)                 // Wait for Start of Cell
        @Tx.cb;

    // ... (The code seems to continue but is not visible in the image)
```

The above code defines a `Monitor` class with properties and methods using virtual interfaces, tasks, and Verilog constructs such as event triggers (`@`) and `fork...join` for parallel processing. The `Monitor` class seems to be designed to work with a communication protocol, possibly ATM (Asynchronous Transfer Mode) going by the `ATM_Cell` type mentioned, though the full details are not evident from the provided snippet.","
Sample 10.7 Monitor class using virtual interfaces

typedef virtual Tx_if vTx_t;

class Monitor;
    int             stream_id;
    mailbox         rcv_mbx;
    vTx_t           Tx;

function new(input mailbox rcv_mbx,
             input int       stream_id,
             input vTx_t     Tx);
    this.rcv_mbx = rcv_mbx;
    this.stream_id = stream_id;
    this.Tx = Tx;
endfunction // new

task run();
    ATM_Cell ac;

    fork
    begin
        // Initialize output signals
        Tx.cb.clav <= 0;                        // Not ready to receive
        @Tx.cb;

        $display(""%0d: Monitor::run[%0d] starting"",
                 $time, stream_id);

        forever begin
            receive_cell(ac);
        end
    end
    join_none

endtask : run

task receive_cell(inout ATM_Cell ac);
    bit [7:0] bytes[];

    bytes = new[ATM_CELL_SIZE];
    ac = new();                               // Initialize the cell

    @Tx.cb;
    Tx.cb.clav <= 1;                          // Assert ready to receive
    while (Tx.cb.soc != 1'b1)                 // Wait for Start of Cell
        @Tx.cb;

    // ... (The code seems to continue but is not visible in the image)
","""Verilog Monitor Class Example with Virtual Interfaces and Synchronization Mechanism""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p133.jpg,True,"The image contains sections of Verilog code. Here's the code presented in the image:

```verilog
property rdyProtocol;
    @(posedge clk) rdy |-> ##[1:5] rdyAck;
endproperty
```

```verilog
module range_problem;
    logic clk, rdy, rdyAck;

    initial
    begin
        clk=1'b0; rdy=0; rdyAck=0;
        #500 $finish(2);
    end
end
```

This Verilog code defines a property called `rdyProtocol` which uses the clock delay range operator. Additionally, there is a module definition for `range_problem` with an initial block setting initial values and ending the simulation after a certain delay.","
property rdyProtocol;
    @(posedge clk) rdy |-> ##[1:5] rdyAck;
endproperty


module range_problem;
    logic clk, rdy, rdyAck;

    initial
    begin
        clk=1'b0; rdy=0; rdyAck=0;
        #500 $finish(2);
    end
end
","""Explanation of Verilog's clock delay range operator ##[m:n] with multiple threads and sample property checking code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p384.jpg,True,"```verilog
property p_ttype_vs_beats;
  transType l_ttype;
  int numBeats = 0;
  (start, l_ttype = ttype) ##1
  (
    (dataValid[*1], numBeats++) [*]
    ##1 !dataValid[*]
    intersect
    complete[*-1]
  )
  |-> numBeatsOK(l_ttype, numBeats);
endproperty
```","
property p_ttype_vs_beats;
  transType l_ttype;
  int numBeats = 0;
  (start, l_ttype = ttype) ##1
  (
    (dataValid[*1], numBeats++) [*]
    ##1 !dataValid[*]
    intersect
    complete[*-1]
  )
  |-> numBeatsOK(l_ttype, numBeats);
endproperty
","Caption: ""Verilog SystemVerilog Property Example with Local Variable Repetition Mechanism""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p388.jpg,True,"```verilog
covergroup CovDstKind32;
dst: coverpoint tr.dst
    {bins dst[] = {[0:$]};}
kind: coverpoint tr.kind
    {bins zero = {0};             // 1 bin for kind==0
     bins lo   = {[1:3]};         // 1 bin for values 1:3
     bins hi[] = {[8:$]};         // 8 separate bins
     bins misc = default;         // 1 bin for rest, does not count
    }
cross kind, dst;
endgroup
```","
covergroup CovDstKind32;
dst: coverpoint tr.dst
    {bins dst[] = {[0:$]};}
kind: coverpoint tr.kind
    {bins zero = {0};             // 1 bin for kind==0
     bins lo   = {[1:3]};         // 1 bin for values 1:3
     bins hi[] = {[8:$]};         // 8 separate bins
     bins misc = default;         // 1 bin for rest, does not count
    }
cross kind, dst;
endgroup
","Caption: ""Example of Verilog code for specifying cross coverage bins and a corresponding coverage report with labeled bins.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p387.jpg,True,"The image contains a snippet of Verilog code plus some descriptions regarding how to handle Verilog arrays using TF routines. Here is the code present in the image:

```verilog
reg [23:0] RAM [0:31]; //lsb is lowest bit, ascending addresses
```

It also has some C language function calls and structure access related to handling Verilog arrays:

```c
s_tfnodeinfo node_info;
tf_nodeinfo(1, &node_info); /* get info for tfarg 1 */

node_info.node_value.memoryval_p;
node_info.node_ngroups;
```

The comments and descriptive text in the image explain that the `s_tfnodeinfo` structure will contain information about the C character array which represents the Verilog array when the `tf_nodeinfo()` function is called. There are additional details in the image about the fields of the `s_tfnodeinfo` structure like `node_value.memoryval_p`, `node_mem_size`, `node_vec_size`, and `node_ngroups`, which provide different aspects of information about a Verilog array.","
reg [23:0] RAM [0:31]; //lsb is lowest bit, ascending addresses

odeinfo node_info;
tf_nodeinfo(1, &node_info); /* get info for tfarg 1 */

node_info.node_value.memoryval_p;
node_info.node_ngroups;
","""Understanding Verilog arrays and their manipulation using TF routines as described in a technical document.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p179.jpg,True,"```verilog
program automatic monitor;
program automatic sums;
```","
program automatic monitor;
program automatic sums;
","""Common pitfalls in object-oriented and multi-threaded programming with Verilog and how to use the 'automatic' storage class to avoid them.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p59.jpg,True,"The image contains Verilog code, which I will write out for you:

```verilog
module top;
    wire [3:0] data = 4'b1111;       // decimal 15
    wire [7:0] addr = 8'b11111111;   // decimal 255

    block1 b1 (.data(data),  // 4-bit net connected to 8-bit port
               .addr(addr)); // 8-bit net connected to 4-bit port
                              // third port left unconnected

endmodule: top

module block1 (input [7:0] data,
               input [3:0] addr,
               input [3:0] byte_en);

    initial
        #1 $display("" data = %b \n address = %b \n byte_en = %b\n"",
                   data, address, byte_en);

endmodule: block1
```

This example showcases the potential issues with mismatches in port connection sizes in Verilog, as mentioned in the accompanying text.","
module top;
    wire [3:0] data = 4'b1111;       // decimal 15
    wire [7:0] addr = 8'b11111111;   // decimal 255

    block1 b1 (.data(data),  // 4-bit net connected to 8-bit port
               .addr(addr)); // 8-bit net connected to 4-bit port
                              // third port left unconnected

endmodule: top

module block1 (input [7:0] data,
               input [3:0] addr,
               input [3:0] byte_en);

    initial
        #1 $display("" data = %b \n address = %b \n byte_en = %b\n"",
                   data, address, byte_en);

endmodule: block1
","""Verilog gotchas regarding signal bit width extension, unconnected input ports, and size mismatches, with example code illustrating incorrect port connections.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p71.jpg,True,"The image contains Verilog code examples. Here they are:

```verilog
always @ (mem_array[addr] ) // GOTCHA! not sensitive addr
data = mem_array[addr];

always @* // OK, infers @(addr, mem_array[addr])
data = mem_array[addr];

always_comb // OK, infers @(addr, mem_array[addr])
data = mem_array[addr];

always @(addr, mem_array[addr]) // OK, this works correctly
data = mem_array[addr];

assign data = mem_array[addr]; // This works correctly
```","
always @ (mem_array[addr] ) // GOTCHA! not sensitive addr
data = mem_array[addr];

always @* // OK, infers @(addr, mem_array[addr])
data = mem_array[addr];

always_comb // OK, infers @(addr, mem_array[addr])
data = mem_array[addr];

always @(addr, mem_array[addr]) // OK, this works correctly
data = mem_array[addr];

assign data = mem_array[addr]; // This works correctly
","""Explaining sensitivity list gotchas in Verilog and how to properly model them using always blocks and continuous assignments.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p175.jpg,True,"The image contains Verilog code related to functional coverage using Open Verification Library (OVL) assertions. Here's the code from the image:

```verilog
`ifdef `COVERAGE_ON
// FIFO full
assert_always #( `COVERAGE, 0, ""FIFO_FULL"") myFIFOFull (clk, reset_n, 
  !( {push, pop} == 2'b10 && cnt == FIFO_depth - 2));

// FIFO full - 1
assert_always #( `COVERAGE, 0, ""FIFO_FULL_M1"") myFIFOFullM1 (clk,
  reset_n, !( {push, pop} == 2'b10 && cnt == FIFO_depth - 3));

// FIFO full - 2
assert_always #( `COVERAGE, 0, ""FIFO_FULL_M2"") myFIFOFullM2 (clk,
  reset_n, !( {push, pop} == 2'b10 && cnt == FIFO_depth - 4));

// FIFO empty
assert_always #( `COVERAGE, 0, ""FIFO_EMPTY"") myFIFOEmpty (clk,
  reset_n, !( {push, pop} == 2'b01 && cnt == 1));

// unnecessary coverage point
assert_always #( `COVERAGE, 0, ""FIFO_EMPTY"") myFIFOPush (clk,
  reset_n, !( {push == 1'b1}));
`endif // COVERAGE_ON
```

Please note that there might be typos, and some special characters (like backticks) indicate macro definitions and might be used in a specific way in Verilog code.","
`ifdef `COVERAGE_ON
// FIFO full
assert_always #( `COVERAGE, 0, ""FIFO_FULL"") myFIFOFull (clk, reset_n, 
  !( {push, pop} == 2'b10 && cnt == FIFO_depth - 2));

// FIFO full - 1
assert_always #( `COVERAGE, 0, ""FIFO_FULL_M1"") myFIFOFullM1 (clk,
  reset_n, !( {push, pop} == 2'b10 && cnt == FIFO_depth - 3));

// FIFO full - 2
assert_always #( `COVERAGE, 0, ""FIFO_FULL_M2"") myFIFOFullM2 (clk,
  reset_n, !( {push, pop} == 2'b10 && cnt == FIFO_depth - 4));

// FIFO empty
assert_always #( `COVERAGE, 0, ""FIFO_EMPTY"") myFIFOEmpty (clk,
  reset_n, !( {push, pop} == 2'b01 && cnt == 1));

// unnecessary coverage point
assert_always #( `COVERAGE, 0, ""FIFO_EMPTY"") myFIFOPush (clk,
  reset_n, !( {push == 1'b1}));
`endif // COVERAGE_ON
","""Examples of Verilog Assertions for Functional Coverage in FIFO Models""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p151.jpg,True,"The image contains a snippet of Verilog code. Here is the code extracted from the image:

```verilog
module sema4_example ( ... );

semaphore s_test = new; // create a semaphore bucket

initial begin: Block1 // At simulation time zero...
  s_test.put(5); // bucket has 5 keys added to it
  s_test.get(3); // bucket has 2 keys left
  s_test.get(4); // get(4) cannot be serviced
                 // because the bucket only has 2
                 // keys; the request is put in
                 // the request FIFO

  $display(""Block1 completed at time %0d"", $time);
end: Block1

initial begin: Block2 #10 // At simulation time 10...
  s_test.get(2); // GOTCHA: Even though get(4)
                 // came first, and is waiting
                 // in the FIFO, get(2) will be
                 // serviced first because
  s_test.get(1); // this request will be put on
                 // the FIFO, because the bucket
                 // is empty; it will not be
                 // serviced until the get(4)
                 // is serviced

  $display(""Block2 completed at time %0d"", $time);
end: Block2

initial begin: Block3 #20 // At simulation time 20...
  s_test.put(3); // nothing is run from the FIFO,
                 // since get(4) is first in the
                 // FIFO
  #10
  s_test.put(2); // At simulation time 30...
                 // get(4) and get(1) can now be
                 // serviced, in the order in
                 // which they were placed in
                 // the FIFO

  $display(""Block3 completed at time %0d"", $time);
end: Block3

endmodule
```

This code sample is from a textbook or document explaining a common programming pitfall (""gotcha"") in semaphore handling within the context of a Verilog simulation environment.","
module sema4_example ( ... );

semaphore s_test = new; // create a semaphore bucket

initial begin: Block1 // At simulation time zero...
  s_test.put(5); // bucket has 5 keys added to it
  s_test.get(3); // bucket has 2 keys left
  s_test.get(4); // get(4) cannot be serviced
                 // because the bucket only has 2
                 // keys; the request is put in
                 // the request FIFO

  $display(""Block1 completed at time %0d"", $time);
end: Block1

initial begin: Block2 #10 // At simulation time 10...
  s_test.get(2); // GOTCHA: Even though get(4)
                 // came first, and is waiting
                 // in the FIFO, get(2) will be
                 // serviced first because
  s_test.get(1); // this request will be put on
                 // the FIFO, because the bucket
                 // is empty; it will not be
                 // serviced until the get(4)
                 // is serviced

  $display(""Block2 completed at time %0d"", $time);
end: Block2

initial begin: Block3 #20 // At simulation time 20...
  s_test.put(3); // nothing is run from the FIFO,
                 // since get(4) is first in the
                 // FIFO
  #10
  s_test.put(2); // At simulation time 30...
                 // get(4) and get(1) can now be
                 // serviced, in the order in
                 // which they were placed in
                 // the FIFO

  $display(""Block3 completed at time %0d"", $time);
end: Block3

endmodule
","""Verilog code illustrating a gotcha involving semaphore behavior and request servicing order in concurrent simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p145.jpg,True,"```verilog
always @(posedge test_clock)
    if (data != expected)  // GOTCHA!
        $display(""Error on data: saw %h, expected %h"", data, expected);
```
The code snippet is from a Verilog testbench, and it highlights a common pitfall when using the inequality operator (`!=`) with four-state logic, where the states can be 0, 1, X (unknown), or Z (high impedance).","
always @(posedge test_clock)
    if (data != expected)  // GOTCHA!
        $display(""Error on data: saw %h, expected %h"", data, expected);
","An excerpt on the pitfalls of equality checking in Verilog when handling 4-state values, highlighting a common verification gotcha.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p65.jpg,True,"Here is the code from the image:

```verilog
module real_out (output real ro, ...); // ERROR: output is real
    ...
endmodule

module real_in (input real ri, ...); // ERROR: input is real
    ...
endmodule

module top;
    real real1, real2;
    real_out r1 (.ro(real1_connect)); // ERROR: real connected to port
    real_in r2 (.ri(real1_connect));  // ERROR: real connected to port
endmodule
```

It discusses a gotcha related to passing real (floating point) numbers through ports in Verilog. The image then continues to explain the correct way to handle real numbers in Verilog using the `real` data type, the `realto_bits` and `bitstoreal` system functions, and how to convert real numbers to a vector format that can be passed through module ports. Here is the second part of the code addressing this:

```verilog
module real_out (output wire [63:0] net_real_out); // vector output
    real r;
    assign net_real_out = $realto_bits(r); // convert real to vector
    ...
endmodule

module real_in (input wire [63:0] net_real_in); // vector input
    real r;
    always @(net_real_in)
        r = $bitstoreal(net_real_in); // convert vector to real
    ...
endmodule
```","
module real_out (output real ro, ...); // ERROR: output is real
    ...
endmodule

module real_in (input real ri, ...); // ERROR: input is real
    ...
endmodule

module top;
    real real1, real2;
    real_out r1 (.ro(real1_connect)); // ERROR: real connected to port
    real_in r2 (.ri(real1_connect));  // ERROR: real connected to port
endmodule


module real_out (output wire [63:0] net_real_out); // vector output
    real r;
    assign net_real_out = $realto_bits(r); // convert real to vector
    ...
endmodule

module real_in (input wire [63:0] net_real_in); // vector input
    real r;
    always @(net_real_in)
        r = $bitstoreal(net_real_in); // convert vector to real
    ...
endmodule
","""Addressing the challenge of passing real (floating point) numbers through ports in Verilog and SystemVerilog by using conversion functions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p152.jpg,True,"There is a block of text in the image that represents the contents of a command file named `run.f` and a representation of an array `argv` in a C-like syntax. Here's the information represented as code:

Contents of `run.f`:
```
my_chip.v
my_test.v
+my_debug
```

Array `argv` representation:
```c
argv[0] -> ""verilog""
argv[1] -> ""-f""
argv[2] -> ""run.f"" [0] -> ""run.f""
              [1] -> ""my_chip.v""
              [2] -> ""my_test.v""
              [3] -> ""+my_debug""
argv[3] -> ""-s""
argv[5] -> NULL
```
Please note that the arrays within `argv[2]` are an interpretation of how the command file arguments would be structured rather than exact code syntax, as this is a conceptual representation.","p.v
my_test.v
+my_debug

0] -> ""verilog""
argv[1] -> ""-f""
argv[2] -> ""run.f"" [0] -> ""run.f""
              [1] -> ""my_chip.v""
              [2] -> ""my_test.v""
              [3] -> ""+my_debug""
argv[3] -> ""-s""
argv[5] -> NULL
","A page from ""The Verilog PLI Handbook"" explaining the parsing of command file invocation options and providing an example of how command line arguments are processed in a Verilog simulation environment.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p145.jpg,True,"The image contains two segments of Verilog code. The code is as follows:

```verilog
a1: assert property (@(posedge clk) a[*] |-> p);
```

```verilog
a2: assert property (@(posedge clk) a |-> p);
```","
a1: assert property (@(posedge clk) a[*] |-> p);


a2: assert property (@(posedge clk) a |-> p);
","Caption: ""Understanding efficiency and subtleties in Verilog assertions with sequential properties and sequences that admit an empty match.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p57.jpg,True,"```verilog
always @(posedge clock)
begin
    result <= $pow(x,y);
    ...
end
```","
always @(posedge clock)
begin
    result <= $pow(x,y);
    ...
end
","Example of a Verilog code snippet using a system task with argument checking logic in a flowchart, for use with VPI-based PLI applications in Verilog simulators.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p149.jpg,True,"The image contains Verilog code. Here are the snippets presented in the image:

```verilog
Sample 4.22 Interface signal drive

busif.cb.request <= 1;  // Synchronous drive
busif.cb.cmd <= cmd_buf; // Synchronous drive
```

```verilog
Sample 4.23 Driving a synchronous interface

program automatic test_with_cb(arb_if.TEST arbif);
    initial fork
        #7ns arbif.cb.request <= 3;
        #170ns arbif.cb.request <= 2;
        #250ns arbif.cb.request <= 1;
        #500ns finish;
    join
endprogram

module arb(arb_if.DUT arbif);
    initial
        $monitor(""@%0t: req=%h"", $time, arbif.request);
endmodule
```

This code appears to be demonstrating how to drive synchronous interface signals in Verilog and includes timing, interface signal driving, and monitor statements.","
Sample 4.22 Interface signal drive

busif.cb.request <= 1;  // Synchronous drive
busif.cb.cmd <= cmd_buf; // Synchronous drive


Sample 4.23 Driving a synchronous interface

program automatic test_with_cb(arb_if.TEST arbif);
    initial fork
        #7ns arbif.cb.request <= 3;
        #170ns arbif.cb.request <= 2;
        #250ns arbif.cb.request <= 1;
        #500ns finish;
    join
endprogram

module arb(arb_if.DUT arbif);
    initial
        $monitor(""@%0t: req=%h"", $time, arbif.request);
endmodule
","""Exploring Synchronous Signal Driving in Verilog Testbenches""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p319.jpg,True,"The image contains textual information and snippets of code related to Verilog assertions. Here's the code extracted:

```
assert property (rst[1:*] ##1 !rst |=> always !rst);

assert property (rst[1:*] ##1 !rst ##1 always !rst);
```"," property (rst[1:*] ##1 !rst |=> always !rst);

assert property (rst[1:*] ##1 !rst ##1 always !rst);
",Verilog assertion property examples demonstrating the difference between the 'followed by' operator and the implication operator.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p388.jpg,True,"The image shows a textbook or document page with information about Verilog, a hardware description language used to model electronic systems. There is Verilog code in this image, and here it is:

```verilog
property_declaration ::=
  property property_identifier [ property_formal_list ] ';'
  { assertion_variable_declaration }
  property_spec ';'
endproperty [ ':' property_identifier ]

assertion_variable_declaration ::=
  data_type list_of_variable_identifiers ';'

Examples include:

property addr_sent;
  reg [3:0] addr;
  // Find start and save address, then find the next
  // request and compare the address with the saved one
  (start, addr = new_addr |=>
   req[->1] ##0 req_addr == addr);
endproperty
```

This code presents an example of a SystemVerilog property declaration for dynamic data, which is useful when working with assertions in formal verification or simulation testbenches.","
property_declaration ::=
  property property_identifier [ property_formal_list ] ';'
  { assertion_variable_declaration }
  property_spec ';'
endproperty [ ':' property_identifier ]

assertion_variable_declaration ::=
  data_type list_of_variable_identifiers ';'

Examples include:

property addr_sent;
  reg [3:0] addr;
  // Find start and save address, then find the next
  // request and compare the address with the saved one
  (start, addr = new_addr |=>
   req[->1] ##0 req_addr == addr);
endproperty
","""Excerpt from documentation detailing SystemVerilog Assertions and System Functions with an example of dynamic data property declaration in Verilog.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p634.jpg,True,"Here's the code from the image:

```c
case 0x9: ALU_outputs->result = log10 (a); break;
case 0xA: ALU_outputs->result = sin (a); break;
case 0xB: ALU_outputs->result = cos (a); break;
case 0xC: ALU_outputs->result = tan (a); break;
case 0xD: ALU_outputs->result = asin (a); break;
case 0xE: ALU_outputs->result = acos (a); break;
case 0xF: ALU_outputs->result = atan (a); break;
}
ALU_outputs->err = (errno == EDOM); /* arg out of range */
ALU_outputs->excep = (errno == ERANGE); /* result out of range */
errno = 0; /* clear the error flag */
if (ALU_outputs->err) ALU_outputs->result = 0.0;
}

/* return the values stored in the C model */
*result = ALU_outputs->result;
*err = ALU_outputs->err;
*excep = ALU_outputs->excep;

return;
}

#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */

#define ALU_ENABLE 1 /* system task arg 1 is ALU enable input */
#define ALU_A 2 /* system task arg 2 is ALU A input */
#define ALU_B 3 /* system task arg 3 is ALU B input */
#define ALU_OP 4 /* system task arg 4 is ALU opcode input */
#define ALU_RESULT 5 /* system task arg 5 is ALU result output */
#define ALU_EXCEP 6 /* system task arg 6 is ALU exception output */
#define ALU_ERR 7 /* system task arg 7 is ALU error output */

/***********************************************************************
* VCL simulation callback routine: Serves as an interface between
* Verilog simulation and the C model. Called whenever the C model
* inputs change value, passes the values to the C model, and puts
* the C model outputs into simulation.
***********************************************************************/

int PLIbook_ScientificALU_interface (p_vc_record vc_record)
{
double a, b, result;
int opcode, excep, err, enable;
handle instance_h, result_h, excep_h, err_h, a_h, b_h, opcode_h, enable_h;
```

This code appears to be part of a textbook or handbook discussing the use of the Verilog PLI (Programming Language Interface) and is an example of interfacing Verilog with a C model for a simulated ALU (Arithmetic Logic Unit). The script defines how the ALU responds to different mathematical operation opcodes by performing corresponding C standard library functions and handling errors and exceptions. The PLI functions are used to connect the simulated Verilog hardware model with the C software model.","0x9: ALU_outputs->result = log10 (a); break;
case 0xA: ALU_outputs->result = sin (a); break;
case 0xB: ALU_outputs->result = cos (a); break;
case 0xC: ALU_outputs->result = tan (a); break;
case 0xD: ALU_outputs->result = asin (a); break;
case 0xE: ALU_outputs->result = acos (a); break;
case 0xF: ALU_outputs->result = atan (a); break;
}
ALU_outputs->err = (errno == EDOM); /* arg out of range */
ALU_outputs->excep = (errno == ERANGE); /* result out of range */
errno = 0; /* clear the error flag */
if (ALU_outputs->err) ALU_outputs->result = 0.0;
}

/* return the values stored in the C model */
*result = ALU_outputs->result;
*err = ALU_outputs->err;
*excep = ALU_outputs->excep;

return;
}

#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */

#define ALU_ENABLE 1 /* system task arg 1 is ALU enable input */
#define ALU_A 2 /* system task arg 2 is ALU A input */
#define ALU_B 3 /* system task arg 3 is ALU B input */
#define ALU_OP 4 /* system task arg 4 is ALU opcode input */
#define ALU_RESULT 5 /* system task arg 5 is ALU result output */
#define ALU_EXCEP 6 /* system task arg 6 is ALU exception output */
#define ALU_ERR 7 /* system task arg 7 is ALU error output */

/***********************************************************************
* VCL simulation callback routine: Serves as an interface between
* Verilog simulation and the C model. Called whenever the C model
* inputs change value, passes the values to the C model, and puts
* the C model outputs into simulation.
***********************************************************************/

int PLIbook_ScientificALU_interface (p_vc_record vc_record)
{
double a, b, result;
int opcode, excep, err, enable;
handle instance_h, result_h, excep_h, err_h, a_h, b_h, opcode_h, enable_h;
","""Excerpt from The Verilog PLI Handbook depicting Verilog code interfacing with a C model for an ALU.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p620.jpg,True,"The image contains a snippet of documentation or a book related to Verilog Programming Language Interface (PLI), but it does not contain any complete code examples. There is one line that appears to be part of a code, which is:

```verilog
initial
$scientific_alu(a, b, opcode, result, exception, error);
```

This line seems to be an example calling a system task named `$scientific_alu` with some arguments within an `initial` block in Verilog. The text around this snippet discusses the interaction between PLI tasks written in C and Verilog modules.","
initial
$scientific_alu(a, b, opcode, result, exception, error);
","A page from ""The Verilog PLI Handbook"" detailing the creation of a PLI application system task and the handling of VCL consumer routines in Verilog.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p43.jpg,True,"```c
int PLIbook_ShowVal_calltf(char *user_data)
{
    vpiHandle systf_handle, arg_iterator, arg_handle, net_handle;
    s_vpi_value current_value;

    /* obtain a handle to the system task instance */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handle to system task argument */
    /* complieft has already verified only 1 arg with correct type */
    arg_iterator = vpi_iterate(vpiArgument, systf_handle);
    net_handle = vpi_scan(arg_iterator);
    vpi_free_object(arg_iterator); /* free iterator memory */

    /* read current value */
    current_value.format = vpiBinStrVal; /* read value as a string */
    vpi_get_value(net_handle, &current_value);
    vpi_printf(""Signal %s has the value %s\n"",
               vpi_get_str(vpiFullName, net_handle),
               current_value.value.str);

    return(0);
}
```
This is the Verilog code present in the image provided. It defines a VPI callback routine for a PLI application.","LIbook_ShowVal_calltf(char *user_data)
{
    vpiHandle systf_handle, arg_iterator, arg_handle, net_handle;
    s_vpi_value current_value;

    /* obtain a handle to the system task instance */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handle to system task argument */
    /* complieft has already verified only 1 arg with correct type */
    arg_iterator = vpi_iterate(vpiArgument, systf_handle);
    net_handle = vpi_scan(arg_iterator);
    vpi_free_object(arg_iterator); /* free iterator memory */

    /* read current value */
    current_value.format = vpiBinStrVal; /* read value as a string */
    vpi_get_value(net_handle, &current_value);
    vpi_printf(""Signal %s has the value %s\n"",
               vpi_get_str(vpiFullName, net_handle),
               current_value.value.str);

    return(0);
}
","""Example of a Verilog VPI calltf routine for reading signal values in a PLI application""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p175.jpg,True,"The image contains two code samples written in Verilog. Here they are:

Sample 5.2 Class in a package
```verilog
// File abc.svh
package abc;
    class Transaction;
        // Class body
    endclass
endpackage
```

Sample 5.3 Importing a package in a program
```verilog
program automatic test;
    import abc::*;
    Transaction tr;

    // Test code

endprogram
```","
// File abc.svh
package abc;
    class Transaction;
        // Class body
    endclass
endpackage


program automatic test;
    import abc::*;
    Transaction tr;

    // Test code

endprogram
","Caption: ""Excerpt from a textbook including Verilog code samples for creating a class inside a package and importing that package into a program, with a brief introduction to Object-Oriented Programming (OOP) terminology in Verilog context.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p608.jpg,True,"There is no complete code example in the visible text of the image, but there is a mention of a struct definition in Verilog PLI. Here is the snippet of the code related to the struct definition from the image:

```c
typedef struct t_strengths
{
    unsigned char logic_value;
    unsigned char strength1;
    unsigned char strength2;
} s_strengths, *p_strengths;
```","ef struct t_strengths
{
    unsigned char logic_value;
    unsigned char strength1;
    unsigned char strength2;
} s_strengths, *p_strengths;
","""Excerpt from The Verilog PLI Handbook discussing use of acc_fetch_value() and Value Change Link routines in Verilog simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p325.jpg,True,"The image contains Verilog code. Here it is:

```verilog
property p4;
    s_eventually [2:$] $fell(frame_);
endproperty

property p5;
    eventually [2:$] $fell(frame_); // ILLEGAL. Weak property must be bound.
endproperty
property p6;
    s_eventually always a;
endproperty
```

```verilog
a1: assert property ( req |-> ##[1:10000] gnt); // Inefficient
```

Should be written as:

```verilog
a2: assert property (req |-> s_eventually gnt); // efficient
```","
property p4;
    s_eventually [2:$] $fell(frame_);
endproperty

property p5;
    eventually [2:$] $fell(frame_); // ILLEGAL. Weak property must be bound.
endproperty
property p6;
    s_eventually always a;
endproperty


a1: assert property ( req |-> ##[1:10000] gnt); // Inefficient


a2: assert property (req |-> s_eventually gnt); // efficient
","The image contains excerpts from a technical document discussing features of IEEE-1800-2009/2012 (SystemVerilog) related to temporal logic properties in verification. Specifically, it shows some example properties using `s_eventually` and compares efficient versus inefficient assertion practices for simulation performance. It also mentions four forms of the ""until"" property in SystemVerilog.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p331.jpg,True,"The image contains several examples of Verilog code in the context of properties defining certain conditions with respect to clock ticks. Here is the code from the image:

```verilog
property p1;
    @(posedge clk) nexttime always req;
endproperty

property p1;
    @(posedge clk) nexttime eventually req;
endproperty

property p1;
    @(posedge clk) nexttime[5] req;
endproperty

property p1;
    @(posedge clk) s_nexttime req;
endproperty

property p1;
    @(posedge clk) s_nexttime [5] req;
endproperty

property
    @(posedge clk) (seq1.matched nexttime seq_expr == 'hff);
endproperty
```

These code snippets define properties for use in formal verification or simulation to ensure certain conditions hold regarding a signal `req` relative to a clock edge (`posedge clk`). The `nexttime`, `nexttime always`, and `nexttime eventually` operators, along with `s_nexttime`, define different timing relationships with the `req` signal at the current clock cycle or specific future cycle counts. The last property also involves a match with a condition based on a sequence `seq1` and a comparison with a hexadecimal value `'hff`.","
property p1;
    @(posedge clk) nexttime always req;
endproperty

property p1;
    @(posedge clk) nexttime eventually req;
endproperty

property p1;
    @(posedge clk) nexttime[5] req;
endproperty

property p1;
    @(posedge clk) s_nexttime req;
endproperty

property p1;
    @(posedge clk) s_nexttime [5] req;
endproperty

property
    @(posedge clk) (seq1.matched nexttime seq_expr == 'hff);
endproperty
","Verilog Assertions: Using ""nexttime"" to Specify Timing Properties",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p242.jpg,True,"The image contains a snippet of Verilog code related to an assertion checking the write enable pulse width for SRAM. Here is the code provided in the image:

```verilog
property p_tWP;
    @(posedge clk)
    $fell(we_n) |-> ##tWP $rose(we_n);
endproperty

a_tWP: assert property(p_tWP);
c_tWP: cover property(p_tWP);
```

This code describes a temporal property `p_tWP`, which is intended to capture the timing requirement for the write enable pulse width `tWP`. It uses SystemVerilog Assertions (SVA) to specify the expected behavior that after a falling edge of `we_n` (`$fell(we_n)`), there should be a rising edge of `we_n` (`$rose(we_n)`) exactly `tWP` clock cycles later. The `assert` statement labeled `a_tWP` and the `cover` statement labeled `c_tWP` are then used for verification purposes, to check that this property holds during simulation and to collect coverage data respectively.","
property p_tWP;
    @(posedge clk)
    $fell(we_n) |-> ##tWP $rose(we_n);
endproperty

a_tWP: assert property(p_tWP);
c_tWP: cover property(p_tWP);
","""Verilog SVA (SystemVerilog Assertions) for checking SRAM write enable pulse width in terms of write cycle time.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p457.jpg,True,"The image contains an example of a code block written in SystemVerilog, which is a hardware description and verification language. Here is the code snippet visible in the image:

```verilog
bit[7:0] adr;
covergroup g1 @(posedge clk);
  ac: coverpoint adr iff (!reset)
  {
    bins adrb1n1 = {[0:3]};  
    bins adrb1n2 [1] = {[4:5]};
    bins adrb1n3 [2] = {[6:8]};
    bins adrb1n4 [3] = {[9:10]};
    bins adrb1n5 [1] = {[9:12],[11:16]};
    bins heretofend = {[31:$]};
    bins others = default;
  }
endgroup
g1 g1_inst = new;
``` 

The code defines a covergroup `g1` for the variable `adr`, which is an 8-bit signal. This covergroup consists of various coverage bins that specify how the `adr` variable should be sampled by a coverage tool during simulation. These bins are defined to capture various ranges of values that `adr` may take, and the `default` bin captures any values not specified by the other bins.","
bit[7:0] adr;
covergroup g1 @(posedge clk);
  ac: coverpoint adr iff (!reset)
  {
    bins adrb1n1 = {[0:3]};  
    bins adrb1n2 [1] = {[4:5]};
    bins adrb1n3 [2] = {[6:8]};
    bins adrb1n4 [3] = {[9:10]};
    bins adrb1n5 [1] = {[9:12],[11:16]};
    bins heretofend = {[31:$]};
    bins others = default;
  }
endgroup
g1 g1_inst = new;
","Caption: ""Overview of SystemVerilog coverage bins and their declaration syntax""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p94.jpg,True,"The image contains Verilog code. Here is the code as it appears in the image:

```verilog
`timescale 1ns / 1ns
module top;
reg [2:0] test;
tri [1:0] results;

addbit i1 (test[0], test[1], test[2], results[0], results[1]);

initial
begin
test = 3'b000;
#1 test = 3'b011;

#1 $show_all_nets(top);
#1 $show_all_nets(i1);

#1 $stop;
#1 $finish;
end
endmodule

/*** A gate level 1 bit adder model ***/
`timescale 1ns / 1ns
module addbit (a, b, ci, sum, co);
input a, b, ci;
output sum, co;

wire a, b, ci, sum, co,
n1, n2, n3;

xor
   (n1, a, b);
xor #2 (sum, n1, ci);
and
   (n2, a, b);
and
   (n3, n1, ci);
or #2 (co, n2, n3);

endmodule
```

Please note that for some commands like `$show_all_nets`, `$stop`, and `$finish`, these are typically specific to simulation tools or might require additional context or a specific environment to function correctly. The hashtags (`#`) indicate delays in nanoseconds.","
`timescale 1ns / 1ns
module top;
reg [2:0] test;
tri [1:0] results;

addbit i1 (test[0], test[1], test[2], results[0], results[1]);

initial
begin
test = 3'b000;
#1 test = 3'b011;

#1 $show_all_nets(top);
#1 $show_all_nets(i1);

#1 $stop;
#1 $finish;
end
endmodule

/*** A gate level 1 bit adder model ***/
`timescale 1ns / 1ns
module addbit (a, b, ci, sum, co);
input a, b, ci;
output sum, co;

wire a, b, ci, sum, co,
n1, n2, n3;

xor
   (n1, a, b);
xor #2 (sum, n1, ci);
and
   (n2, a, b);
and
   (n3, n1, ci);
or #2 (co, n2, n3);

endmodule
","""Example of Verilog test bench and 1-bit adder module from the Verilog PLI Handbook""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p186.jpg,True,"The image contains Verilog code, which I will transcribe below:

```verilog
module m;
    bit clk;
    integer a, b;
    a1: assert property (@(clk) (int'(a++)));
    a2: assert property (@(clk) ((((type bit [7:0])a)+a2) == 1));
    property p;
        @(clk) ((a = a + b));
    endproperty
    a3: assert property (p);
endmodule
```

This code is an example used in a discussion about let declarations in Verilog, and it features a module with assertions that have some issues as discussed in the text. Below this block, there is an incomplete fragment of a ""code as follows"" section without the complete code visible in the image.","
module m;
    bit clk;
    integer a, b;
    a1: assert property (@(clk) (int'(a++)));
    a2: assert property (@(clk) ((((type bit [7:0])a)+a2) == 1));
    property p;
        @(clk) ((a = a + b));
    endproperty
    a3: assert property (p);
endmodule
","A textbook page discussing illegal Verilog code forms in the context of SystemVerilog assertions, with an example module including assert property declarations.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p191.jpg,True,"The image contains Verilog code examples. Here's the code provided:

1. A tri-state buffer with no delays:
```verilog
bufif1 g1 (...);
```

2. A tri-state buffer with delay of 5 for rising, falling, and turn-off transitions:
```verilog
bufif1 #5 g2 (...);
```

3. A tri-state buffer with separate delays for rising, falling, and turn-off transitions:
```verilog
bufif1 #(3, 4, 5) g3 (...);
```

4. A tri-state buffer with separate minimum:typical:maximum delay sets for rising, falling and turn-off transitions:
```verilog
bufif1 #(2:3:4, 3:4:5, 5:6:7) g4 (...);
```

Additionally, the image contains the signature of a Verilog Programming Interface (VPI) routine:
```verilog
void vpi_get_delays(object, delay)
```
- `vpiHandle object` – handle for an object which has a delay property.
- `p_vpi_delay delay` – pointer to an application-allocated `s_vpi_delay` structure to receive delay information.","
bufif1 g1 (...);


bufif1 #5 g2 (...);


bufif1 #(3, 4, 5) g3 (...);


bufif1 #(2:3:4, 3:4:5, 5:6:7) g4 (...);


void vpi_get_delays(object, delay)
","""Understanding delay specifications and VPI routines in Verilog HDL.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p192.jpg,True,"The image contains code related to SystemVerilog properties and sequences. The code snippets in the image are:

```verilog
a: assert property(seq_impl_prop(!reset, (posedge clock), sf_after_a((posedge clock), w, s, 1), (x until y)));

disable iff ((!reset) @(posedge clock)
    sf_after_a((posedge clock), w, s, 1)) |-> (x until y)

@(posedge clock) w ##1 (w[*3])

disable iff ((!reset) @(posedge clock) (w ##1 (w[*3])) |-> (x until y))

disable iff ((!reset) @(posedge clock) w ##1 (w[*3])
```

These snippets show examples of assertions, clocking events, and sequence expressions in SystemVerilog. The text in the image is explaining how these snippets are constructed and used within the context of Verilog assertions and properties.","
a: assert property(seq_impl_prop(!reset, (posedge clock), sf_after_a((posedge clock), w, s, 1), (x until y)));

disable iff ((!reset) @(posedge clock)
    sf_after_a((posedge clock), w, s, 1)) |-> (x until y)

@(posedge clock) w ##1 (w[*3])

disable iff ((!reset) @(posedge clock) (w ##1 (w[*3])) |-> (x until y))

disable iff ((!reset) @(posedge clock) w ##1 (w[*3])
","The image shows an excerpt from a book or document detailing the process of substituting arguments into a Verilog property and sequence declaration, using assertions and the until operator.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p185.jpg,True,"The image contains an example of a C function that interfaces with Verilog through the Verilog Procedural Interface (VPI). Here is the code extracted from the image:

```c
#include <math.h> /* ANSI C standard input/output library */
int PLIbook_RealPow_calltf(char *user_data)
{
    s_vpi_value value_s;
    vpiHandle systf_handle, arg_itr, arg_handle;
    double base, exp, result;

    value_s.format = vpiRealVal;

    /* obtain handle to system task arguments;
       compiletf has already verified only 2 args with correct types */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);
    arg_itr = vpi_iterate(vpiArgument, systf_handle);

    /* read base value of system function arg 1 */
    arg_handle = vpi_scan(arg_itr);
    vpi_get_value(arg_handle, &value_s);
    base = value_s.value.real;

    /* read base value of system function arg 2 */
    arg_handle = vpi_scan(arg_itr);
    vpi_get_value(arg_handle, &value_s);
    exp = value_s.value.real;
    vpi_free_object(arg_itr); /* free iterator--did not scan till null */

    /* calculate result of base to power of exponent */
    result = pow(base, exp) ;

    /* write result to simulation as return value $realpow_func */
    value_s.value.real = result;
    vpi_put_value(systf_handle, &value_s, NULL, vpiNoDelay);
    return(0);
}
```

This function calculates the power of a base number raised to an exponent using the C standard library's `pow` function and returns the result to a Verilog simulation as a real value.","ude <math.h> /* ANSI C standard input/output library */
int PLIbook_RealPow_calltf(char *user_data)
{
    s_vpi_value value_s;
    vpiHandle systf_handle, arg_itr, arg_handle;
    double base, exp, result;

    value_s.format = vpiRealVal;

    /* obtain handle to system task arguments;
       compiletf has already verified only 2 args with correct types */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);
    arg_itr = vpi_iterate(vpiArgument, systf_handle);

    /* read base value of system function arg 1 */
    arg_handle = vpi_scan(arg_itr);
    vpi_get_value(arg_handle, &value_s);
    base = value_s.value.real;

    /* read base value of system function arg 2 */
    arg_handle = vpi_scan(arg_itr);
    vpi_get_value(arg_handle, &value_s);
    exp = value_s.value.real;
    vpi_free_object(arg_itr); /* free iterator--did not scan till null */

    /* calculate result of base to power of exponent */
    result = pow(base, exp) ;

    /* write result to simulation as return value $realpow_func */
    value_s.value.real = result;
    vpi_put_value(systf_handle, &value_s, NULL, vpiNoDelay);
    return(0);
}
","Caption: ""A section from a textbook showing the implementation of a Verilog VPI routine for a custom `$realpow` system function, returning the power of a base to an exponent.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p230.jpg,True,"The image contains Verilog code snippets which are part of a theoretical example or documentation. Here is the code from the image:

```verilog
// The following module is a simulation
// diagnostic aid, not real hardware */
// synthesis off
module a;
// The internals of this module will be supplied by
// the formal DV project
endmodule // a
// rtl_synthesis on

module b;
  b_c c1();
  b_c c2();
  b_d d0();
endmodule //b

module b_c;
endmodule //b_c

module b_d;
endmodule //b_d
```

The comments suggest that the module `a` is for simulation purposes and not meant for real hardware synthesis. The ""synthesis off"" pragma is used to tell synthesis tools to ignore the code for the purpose of hardware synthesis. Similarly, ""rtl_synthesis on"" is a pragma to resume considering code for synthesis.

The code defines module `b` with instances `c1` and `c2` of sub-module `b_c`, and an instance `d0` of sub-module `b_d`. There are also empty module definitions for `b_c` and `b_d`, which would be fleshed out with actual internal implementation in a complete design.","
// The following module is a simulation
// diagnostic aid, not real hardware */
// synthesis off
module a;
// The internals of this module will be supplied by
// the formal DV project
endmodule // a
// rtl_synthesis on

module b;
  b_c c1();
  b_c c2();
  b_d d0();
endmodule //b

module b_c;
endmodule //b_c

module b_d;
endmodule //b_d
","""Example of Verilog module instantiation and hierarchy illustration from a textbook on digital design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p80.jpg,True,"```plaintext
$show_all_nets(<module_instance_name>);
```

```c
vpiHandle vpi_handle(type, reference)
int type constant representing an object type.
vpiHandle reference handle for an object.
```","xt
$show_all_nets(<module_instance_name>);

ndle vpi_handle(type, reference)
int type constant representing an object type.
vpiHandle reference handle for an object.
","Caption: ""Excerpt from 'The Verilog PLI Handbook' detailing how to obtain object handles for one-to-one relationships in Verilog using VPI routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p480.jpg,True,"```verilog
enum {r, g, b } color;
bit [3:0] adr;
bit [1:0] offset;

covergroup cg1 @(posedge clk);
    ofst: coverpoint offset;
    ar: coverpoint adr;
        bins ar1 = {[0:7]};
        bins ar2 = {[8:15]};
    clr_adr: cross color, ar;
    adr_ofst: cross ar, ofst;
endgroup

cg1 cg1Inst = new;
```
The code shown is an example of SystemVerilog syntax used for defining a covergroup for functional coverage in verification processes. The specific example appears to demonstrate the cross coverage feature, which is used to measure how different variables interact with each other during simulation.","
enum {r, g, b } color;
bit [3:0] adr;
bit [1:0] offset;

covergroup cg1 @(posedge clk);
    ofst: coverpoint offset;
    ar: coverpoint adr;
        bins ar1 = {[0:7]};
        bins ar2 = {[8:15]};
    clr_adr: cross color, ar;
    adr_ofst: cross ar, ofst;
endgroup

cg1 cg1Inst = new;
",Annotated Verilog covergroup example with cross coverage and simulation log output.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p218.jpg,True,"The image contains excerpts from a book, and amongst the text, there is some Verilog code present. Here is the code from the image:

```verilog
always @(posedge s1)
    d1_ready <= (reset_L) ? 1'b1 : 1'b0;
always @(negedge clk)
    d1_ready <= ~d0_ready & d1_ready;
```","
always @(posedge s1)
    d1_ready <= (reset_L) ? 1'b1 : 1'b0;
always @(negedge clk)
    d1_ready <= ~d0_ready & d1_ready;
","Caption: ""Excerpt from a document discussing Verilog coding practices, with a focus on reducing complexity and improving simulation and physical implementation speed.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p377.jpg,True,"The image contains examples of Verilog code related to sequence intersection and sequence OR operations. Here is the code extracted from the image:

```verilog
sequence_expr ::= sequence_expr intersect sequence_expr

(1) intersect ()
##1 a intersect ##2 b      same as     ()
##2 a intersect ##2 b      match if    (##2 (a & b))
##[1:2] a intersect ##[2:3] b match if (##1 a&&b) or (##1 a&&##1 b)

##[1:3] a intersect ## [1:3] b match if (##1 a&b) or (##2 a&b) or (##3 a&b)
```

```verilog
sequence_expr ::= sequence_expr or sequence_expr

0 or 0                  same as     ()
##2 a or ## [1:2] b      match if    (b) or (##1 b) or (##2 a) or (##2 b)
```","
sequence_expr ::= sequence_expr intersect sequence_expr

(1) intersect ()
##1 a intersect ##2 b      same as     ()
##2 a intersect ##2 b      match if    (##2 (a & b))
##[1:2] a intersect ##[2:3] b match if (##1 a&&b) or (##1 a&&##1 b)

##[1:3] a intersect ## [1:3] b match if (##1 a&b) or (##2 a&b) or (##3 a&b)


sequence_expr ::= sequence_expr or sequence_expr

0 or 0                  same as     ()
##2 a or ## [1:2] b      match if    (b) or (##1 b) or (##2 a) or (##2 b)
","""Verilog sequence intersection and sequence OR examples from a textbook on Assertion-Based Design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p295.jpg,True,"The image contains Verilog code which seems to be related to SystemVerilog Assertions (SVA) for a protocol interface. Here is the code presented:

```verilog
sequence s_tchk12a;
    @(posedge clk)
    (`s_CONFIG_READ || `s_CONFIG_WRITE) &&
    ((ad[1:0] == 2'b00) || (ad[1:0] == 2'b01)) &&
    idsel;
endsequence

sequence s_tchk12b;
    @(posedge clk)
    !devseln && stopn;
endsequence

sequence s_tchk12;
    @(posedge clk)
    s_tchk12a ##[1:5] s_tchk12b;
endsequence

property p_tchk12;
    @(posedge clk)
    s_tchk12;
```

This code defines a series of sequences and properties, which are used to model and check the behavior of a digital system based on the clock signal's positive edge (`posedge clk`). The code sample includes the use of macros or defines (indicated by backticks `` ` ``), such as `s_CONFIG_READ` and `s_CONFIG_WRITE`, and it checks for certain conditions using bitwise operations and logical operators. The sequences and property are likely used within Assertion-Based Verification (ABV) to ensure the correct operation of a digital circuit or system component that communicates using a specific protocol.","
sequence s_tchk12a;
    @(posedge clk)
    (`s_CONFIG_READ || `s_CONFIG_WRITE) &&
    ((ad[1:0] == 2'b00) || (ad[1:0] == 2'b01)) &&
    idsel;
endsequence

sequence s_tchk12b;
    @(posedge clk)
    !devseln && stopn;
endsequence

sequence s_tchk12;
    @(posedge clk)
    s_tchk12a ##[1:5] s_tchk12b;
endsequence

property p_tchk12;
    @(posedge clk)
    s_tchk12;
","Caption: ""Verilog code snippet showcasing SystemVerilog Assertion (SVA) sequences and property for protocol interface checking in a hardware design context.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p363.jpg,True,"The image contains snippets of text defining the syntax for Verilog and PSL (Property Specification Language) constructs. However, this is not executable code, rather it's the grammar used for parsing or understanding the structure of PSL and HDL (Hardware Description Language) code. The described syntax looks like BNF (Backus-Naur Form) which is a way to express the grammar of a language in a formal way. Here's the text extracted from the image:

```
VHDL: range_attribute_name
Flavor Macro LEFT_SYM =
SystemVerilog: | / Verilog: | / VHDL: ( / GDL: (
Flavor Macro RIGHT_SYM =
SystemVerilog: | / Verilog: | / VHDL: ) / GDL: )

B.8.3 Syntax productions

The rest of this section defines the PSL syntax.

B.8.3.1 Verification units

PSL_Specification ::=
{ Verification_Item }
Verification_Item ::=
HDL_UNIT | Verification_Unit
Verification_Unit ::=
VUnitType Name [ ( Hierarchical_HDL_Name ) ] {
{ Inherit_Spec }
{ VUnit_Item }
}
VUnitType ::=
vunit | vprop | vmode
Name ::=
HDL_or_PSL_Identifier
Hierarchical_HDL_Name ::=
module_Name { Path_Separator instance_Name }
Path_Separator ::=
.| /
Inherit_Spec ::=
inherit vunit_Name { , vunit_Name } ;
VUnit_Item ::=
HDL_DECL
| HDL_STMT
| PSL_Declaration (see B.8.3.2)
| PSL_Directive (see B.8.3.3)

B.8.3.2 PSL declarations

PSL_Declaration ::=
Property_Declaration
| Sequence_Declaration
| Endpoint_Declaration
| Clock_Declaration
Property_Declaration ::=
```

This text shows the structure of PSL specifications, how a PSL document is structured into verification units, and how certain declarations within PSL are to be formed.","range_attribute_name
Flavor Macro LEFT_SYM =
SystemVerilog: | / Verilog: | / VHDL: ( / GDL: (
Flavor Macro RIGHT_SYM =
SystemVerilog: | / Verilog: | / VHDL: ) / GDL: )

B.8.3 Syntax productions

The rest of this section defines the PSL syntax.

B.8.3.1 Verification units

PSL_Specification ::=
{ Verification_Item }
Verification_Item ::=
HDL_UNIT | Verification_Unit
Verification_Unit ::=
VUnitType Name [ ( Hierarchical_HDL_Name ) ] {
{ Inherit_Spec }
{ VUnit_Item }
}
VUnitType ::=
vunit | vprop | vmode
Name ::=
HDL_or_PSL_Identifier
Hierarchical_HDL_Name ::=
module_Name { Path_Separator instance_Name }
Path_Separator ::=
.| /
Inherit_Spec ::=
inherit vunit_Name { , vunit_Name } ;
VUnit_Item ::=
HDL_DECL
| HDL_STMT
| PSL_Declaration (see B.8.3.2)
| PSL_Directive (see B.8.3.3)

B.8.3.2 PSL declarations

PSL_Declaration ::=
Property_Declaration
| Sequence_Declaration
| Endpoint_Declaration
| Clock_Declaration
Property_Declaration ::=
",Excerpt from a technical document showing the syntax of PSL (Property Specification Language) within Verilog and VHDL environments.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p281.jpg,True,"The image contains a snippet of Verilog code. Here is the code extracted from the image:

```verilog
property p_tchk1;
@(posedge clk)
($fell (stopn) && !framern) |-> 
!stopn [*1:$]
##0 $rose (framern) ##1 $rose(stopn);
endproperty

a_tchk1: assert property(p_tchk1);
c_tchk1: cover property(p_tchk1);
```

This code is defining a property in SystemVerilog Assertions (SVA) to check the behavior of a signal called `stopn`, in the context of a Positive-Edge Triggered clock signal (`posedge clk`). It uses SVA syntax to express the electronic design's temporal behavior and requirements.","
property p_tchk1;
@(posedge clk)
($fell (stopn) && !framern) |-> 
!stopn [*1:$]
##0 $rose (framern) ##1 $rose(stopn);
endproperty

a_tchk1: assert property(p_tchk1);
c_tchk1: cover property(p_tchk1);
","A textbook page discussing SystemVerilog Assertions (SVA) for verifying protocol interfaces, accompanied by an assertion example for a PCI target device.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p494.jpg,True,"The image contains Verilog code. Here it is transcribed:

Example 3:
```verilog
covergroup cg1 @(posedge clk);
  coverpoint a {
    bins b1[] = {0, 1, 2, 3};
    ignore_bins ignore_vals = {0, 3};
  }
endgroup
```

Example 4:
```verilog
A: coverpoint a {
  bins a1[3] = {0, 2, 3, [4:6], 8, 9};
  ignore_bins ig = {2, 3};
}
```

Example 5:
```verilog
A: coverpoint a {
  bins b1[] = {(2=>5=>1), (1=>4=>3)};
  ignore_bins ignore_trans = {(2=>5)};
}
```

The above code samples are Verilog examples demonstrating the use of covergroups and coverpoints for functional coverage in simulation, including declaring bins and specifying ignore_bins to exclude certain values from coverage consideration.","
covergroup cg1 @(posedge clk);
  coverpoint a {
    bins b1[] = {0, 1, 2, 3};
    ignore_bins ignore_vals = {0, 3};
  }
endgroup


A: coverpoint a {
  bins a1[3] = {0, 2, 3, [4:6], 8, 9};
  ignore_bins ig = {2, 3};
}


A: coverpoint a {
  bins b1[] = {(2=>5=>1), (1=>4=>3)};
  ignore_bins ignore_trans = {(2=>5)};
}
",Caption: Examples of Verilog functional coverage using covergroups and coverpoints with ignore_bins to exclude specific values and transitions from coverage metrics.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p740.jpg,True,"The image contains text, which describes two function prototypes from the Verilog PLI Handbook. Though it is related to Verilog code, there is no executable Verilog code provided on the page. Instead, it outlines the syntax and parameters for specific PLI (Programming Language Interface) functions in C that would interact with Verilog. Here are the function prototypes described:

```c
int tf_strlongdelputp(n, length, format, value, lowdelay, highdelay, mode)
int tf_strlongdelputp(n, length, format, value, lowdelay, highdelay, mode, tfinst)

int tf_strrealdelputp(n, length, format, value, delay, mode)
int tf_strrealdelputp(n, length, format, value, delay, mode, tfinst)
```

These functions are used for depositing values into the argument of a system task or function with different timing and format specifications.","f_strlongdelputp(n, length, format, value, lowdelay, highdelay, mode)
int tf_strlongdelputp(n, length, format, value, lowdelay, highdelay, mode, tfinst)

int tf_strrealdelputp(n, length, format, value, delay, mode)
int tf_strrealdelputp(n, length, format, value, delay, mode, tfinst)
","This image contains excerpts from ""The Verilog PLI Handbook,"" detailing the procedural interface functions for depositing values to Verilog simulation objects with timing control.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p322.jpg,True,"The image contains Verilog code which defines several properties using SystemVerilog Assertions (SVA). Here is the code text extracted from the image:

```verilog
7. CHECKING THE CHECKER

property p4_w_rr;
    @(posedge clk)
        $rose(a) ##[min_time : max_time] $rose(b);
endproperty

// on a given clock edge, the leading signal has
// a falling edge and within ""min_time"" to
// ""max_time"" cycles the trailing signal has a
// rising edge

property p4_w_fr;
    @(posedge clk)
        $fell(a) ##[min_time : max_time] $rose(b);
endproperty

// on a given clock edge, the leading signal has
// a rising edge and within ""min_time"" to
// ""max_time"" cycles the trailing signal has a
// falling edge

property p4_w_rf;
    @(posedge clk)
        $rose(a) ##[min_time : max_time] $fell(b);
endproperty

a4_w_rr: assert property(p4_w_rr);
a4_w_ff: assert property(p4_w_ff);
a4_w_rf: assert property(p4_w_rf);
a4_w_fr: assert property(p4_w_fr);

A list of possible properties for fixed timing relationship between two
edge sensitive signals with non-overlapping implication is shown below.

// on a given clock edge, if the leading signal
// has a falling edge, then after ""min_time""
// cycles the trailing signal must have a
// falling edge

property p6_f_ff;
    @(posedge clk)
        $fell(a) |-> ##min_time $fell(b);
endproperty
```

This code snippet is describing specific timing relationships that need to be checked between signals 'a' and 'b' after the rising edge of a clock signal 'clk'. The properties are then asserted, which means these conditions are enforced during simulation to ensure that the signals behave as expected within the specified timing constraints.","
7. CHECKING THE CHECKER

property p4_w_rr;
    @(posedge clk)
        $rose(a) ##[min_time : max_time] $rose(b);
endproperty

// on a given clock edge, the leading signal has
// a falling edge and within ""min_time"" to
// ""max_time"" cycles the trailing signal has a
// rising edge

property p4_w_fr;
    @(posedge clk)
        $fell(a) ##[min_time : max_time] $rose(b);
endproperty

// on a given clock edge, the leading signal has
// a rising edge and within ""min_time"" to
// ""max_time"" cycles the trailing signal has a
// falling edge

property p4_w_rf;
    @(posedge clk)
        $rose(a) ##[min_time : max_time] $fell(b);
endproperty

a4_w_rr: assert property(p4_w_rr);
a4_w_ff: assert property(p4_w_ff);
a4_w_rf: assert property(p4_w_rf);
a4_w_fr: assert property(p4_w_fr);

A list of possible properties for fixed timing relationship between two
edge sensitive signals with non-overlapping implication is shown below.

// on a given clock edge, if the leading signal
// has a falling edge, then after ""min_time""
// cycles the trailing signal must have a
// falling edge

property p6_f_ff;
    @(posedge clk)
        $fell(a) |-> ##min_time $fell(b);
endproperty
","Caption: ""Excerpt from a document showing Verilog code properties for checking fixed timing relationships between signals in a synchronous digital circuit.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p251.jpg,True,"```verilog
restrict property ( property_spec );
```

```verilog
restrict property (@(posedge clk) PCI_Cycle_Type == PCI_read);
```

```verilog
data dist {100 := 1; 500 := 3; 700 := 5}
```

```verilog
a1_assume: assume property (probe_assume) ({req dist {0: 40, 1:60}})
property probe_assume;
    @(posedge clk) req |=> ack;
endproperty
```","
restrict property ( property_spec );


restrict property (@(posedge clk) PCI_Cycle_Type == PCI_read);


data dist {100 := 1; 500 := 3; 700 := 5}


a1_assume: assume property (probe_assume) ({req dist {0: 40, 1:60}})
property probe_assume;
    @(posedge clk) req |=> ack;
endproperty
","Verilog ""restrict"" property usage and introduction to ""dist"" (distribution operator) and ""inside"" operator in SystemVerilog.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p245.jpg,True,"The image contains a snippet of Verilog code as follows:

```verilog
initial
begin
  $display($stime,,""Hello before expect"");
  expect (@(posedge clk) c |-> c ##2 d ##2 e)
    $display($stime,,""texpect pass"");
  else
    $display($stime,,""texpect fail"");
  $display($stime,,""Goodbye after expect"");
end
endmodule
``` 

This code snippet is related to the discussion of the ""expect"" statement in Verilog that the text is referring to.","
initial
begin
  $display($stime,,""Hello before expect"");
  expect (@(posedge clk) c |-> c ##2 d ##2 e)
    $display($stime,,""texpect pass"");
  else
    $display($stime,,""texpect fail"");
  $display($stime,,""Goodbye after expect"");
end
endmodule
","Caption: ""Overview of the Verilog 'expect' statement, illustrating its use in procedural blocks and the differences from 'assert property', alongside an example code snippet and simulation log output.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p336.jpg,True,"The image contains Verilog code used for assertions, which are part of formal verification in hardware design. Here is the text of the code:

```verilog
begin
if(timing_level == 2'b11)
    a5_f_hh: assert property(p5_f_hh);
if(timing_level == 2'b10)
    a5_f_hl: assert property(p5_f_hl);
if(timing_level == 2'b01)
    a5_f_lh: assert property(p5_f_lh);
if(timing_level == 2'b00)
    a5_f_ll: assert property(p5_f_ll);
end
if(min_time != max_time)
begin
if(timing_level == 2'b11)
    a5_w_hh: assert property(p5_w_hh);
if(timing_level == 2'b10)
    a5_w_hl: assert property(p5_w_hl);
if(timing_level == 2'b01)
    a5_w_lh: assert property(p5_w_lh);
if(timing_level == 2'b00)
    a5_w_ll: assert property(p5_w_ll);
end
end

// timing relation between 2 edge sensitive
// signals with non-overlapping implication

if(logic_op == 0 && timing == 1 && sig_edge == 1 && non_o_implication == 1)
begin
if(min_time == max_time)
begin
a6_f_rr: assert property(p6_f_rr);
a6_f_ff: assert property(p6_f_ff);
a6_f_rf: assert property(p6_f_rf);
a6_f_fr: assert property(p6_f_fr);
end
if(min_time != max_time)
begin
a6_w_rr: assert property(p6_w_rr);
a6_w_ff: assert property(p6_w_ff);
a6_w_rf: assert property(p6_w_rf);
a6_w_fr: assert property(p6_w_fr);
end
```

This code utilizes SystemVerilog assertion constructs to check the properties of a design based on certain timing levels and conditions. Assertions are powerful tools that help to validate the correctness of a design by specifying expected behavior in a declarative manner.","
begin
if(timing_level == 2'b11)
    a5_f_hh: assert property(p5_f_hh);
if(timing_level == 2'b10)
    a5_f_hl: assert property(p5_f_hl);
if(timing_level == 2'b01)
    a5_f_lh: assert property(p5_f_lh);
if(timing_level == 2'b00)
    a5_f_ll: assert property(p5_f_ll);
end
if(min_time != max_time)
begin
if(timing_level == 2'b11)
    a5_w_hh: assert property(p5_w_hh);
if(timing_level == 2'b10)
    a5_w_hl: assert property(p5_w_hl);
if(timing_level == 2'b01)
    a5_w_lh: assert property(p5_w_lh);
if(timing_level == 2'b00)
    a5_w_ll: assert property(p5_w_ll);
end
end

// timing relation between 2 edge sensitive
// signals with non-overlapping implication

if(logic_op == 0 && timing == 1 && sig_edge == 1 && non_o_implication == 1)
begin
if(min_time == max_time)
begin
a6_f_rr: assert property(p6_f_rr);
a6_f_ff: assert property(p6_f_ff);
a6_f_rf: assert property(p6_f_rf);
a6_f_fr: assert property(p6_f_fr);
end
if(min_time != max_time)
begin
a6_w_rr: assert property(p6_w_rr);
a6_w_ff: assert property(p6_w_ff);
a6_w_rf: assert property(p6_w_rf);
a6_w_fr: assert property(p6_w_fr);
end
","""Verilog Assertions for Timing Checks in a Digital Design Verification Context""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p768.jpg,True,"The image contains text-based information related to functions in Verilog Programming Language Interface (PLI), but there is no actual code like a Verilog source code or script. It lists several function prototypes for handling different aspects of Verilog PLI. Here's the transcribed text:

```plaintext
760                                                The Verilog PLI Handbook, Appendices

handle acc_handle_pathin(object)
handle  object                handle for a module path.
Returns a handle for the net connected to the first source in a module path.

handle acc_handle_pathout(object)
handle  object                handle for a module path.
Returns handle for the net connected to the first destination in module path.

handle acc_handle_port(object, index)
handle  object                handle for a module.
int     index                 port position index.
Returns a handle for a specific module port based on the port position in the module
definition. Ports are numbered from left to right starting with 0.

handle acc_handle_scope(object)
handle  object                handle for an object.
Returns the handle for the scope containing an object.

handle acc_handle_simulated_net(object)
handle  object                handle for a net.
Returns the handle for the net being simulated after equivalent nets have been
collapsed.
```","xt
760                                                The Verilog PLI Handbook, Appendices

handle acc_handle_pathin(object)
handle  object                handle for a module path.
Returns a handle for the net connected to the first source in a module path.

handle acc_handle_pathout(object)
handle  object                handle for a module path.
Returns handle for the net connected to the first destination in module path.

handle acc_handle_port(object, index)
handle  object                handle for a module.
int     index                 port position index.
Returns a handle for a specific module port based on the port position in the module
definition. Ports are numbered from left to right starting with 0.

handle acc_handle_scope(object)
handle  object                handle for an object.
Returns the handle for the scope containing an object.

handle acc_handle_simulated_net(object)
handle  object                handle for a net.
Returns the handle for the net being simulated after equivalent nets have been
collapsed.
","""Verilog PLI Handbook excerpt detailing API functions for module paths and ports.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p292.jpg,True,"The code from the image is as follows:

```
(empty ##0 seq) does not result in a match
(seq ##0 empty) does not result in a match

(empty ##n seq), where n is > 0, is equivalent to (##(n-1) seq)
(seq ##n empty), where n is > 0, is equivalent to (seq ##(n-1) 'true)

Examples:

b ##1 (a[*0] ##0 c) - will never produce a match
b ##1 a[*0:1] ##2 c is equivalent to
    (b ##2 c) or (b ##1 a ##2 c)
``` 

These are some rules and examples related to empty sequences within the context of SystemVerilog, from a document providing information about its language reference manual (LRM)."," ##0 seq) does not result in a match
(seq ##0 empty) does not result in a match

(empty ##n seq), where n is > 0, is equivalent to (##(n-1) seq)
(seq ##n empty), where n is > 0, is equivalent to (seq ##(n-1) 'true)

Examples:

b ##1 (a[*0] ##0 c) - will never produce a match
b ##1 a[*0:1] ##2 c is equivalent to
    (b ##2 c) or (b ##1 a ##2 c)
","""SystemVerilog Assertions: Rules and Examples for Using Empty Sequences.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p203.jpg,True,"The image contains the following code:

```verilog
// declarative assertion

// assert grant is recieved within 3 clocks after an initial req
assert always {rose(req)} |-> {{[*1:4]}:{grant}} @ (posedge clk);
```

This code is written in the context of a PSL (Property Specification Language) grant timeout check for hardware verification in Verilog.","
// declarative assertion

// assert grant is recieved within 3 clocks after an initial req
assert always {rose(req)} |-> {{[*1:4]}:{grant}} @ (posedge clk);
","""Use of PSL for Declarative Assertion in Verilog to Check Grant Timeout within 3 Clock Cycles after an Initial Request""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p217.jpg,True,"```verilog
// Property definitions.
// assert request 1 completes within 100 cycles.
property req2done;
  int rtag;
  @(posedge clk) (req, rtag=req_tag |-> ##[1:100] done && done_tag == rtag);
endproperty

property reqtag_once;
  int rtag;
  // Once a request (with a specific tag) is made,
  // there must be a done with that same tag, before
  // another request with the same tag is issued.
  @(posedge clk) not (req, rtag==req_tag
    ##[1:0] (done && done_tag == rtag)[*1:$]
    ##0 req && req tag == rtag) ;
endproperty

property donetag_once;
  int dtag ;
  // Once a done (with a specific tag) is issued,
  // there must be a request with that same tag, before
  // another done with the same tag is issued.
  @(posedge clk) not (done, dtag==done_tag
    ##[1:0] (req && req_tag == dtag)[*1:$]
    ##0 done && done_tag == dtag);
endproperty

// Concurrent assertion statements.
assert property (req2done)
  else $error(""Request tag didn't complete within 100 cycles."");

assert property (reqtag_once)
  else $error(""Request tag re-used before done received."");

assert property (donetag_once)
  else $error(""Two acknowledges received for request tag."");
```

This image contains SystemVerilog code with properties and assertions meant to define and check the behavior of a request/acknowledge protocol based on tagged transactions.","
// Property definitions.
// assert request 1 completes within 100 cycles.
property req2done;
  int rtag;
  @(posedge clk) (req, rtag=req_tag |-> ##[1:100] done && done_tag == rtag);
endproperty

property reqtag_once;
  int rtag;
  // Once a request (with a specific tag) is made,
  // there must be a done with that same tag, before
  // another request with the same tag is issued.
  @(posedge clk) not (req, rtag==req_tag
    ##[1:0] (done && done_tag == rtag)[*1:$]
    ##0 req && req tag == rtag) ;
endproperty

property donetag_once;
  int dtag ;
  // Once a done (with a specific tag) is issued,
  // there must be a request with that same tag, before
  // another done with the same tag is issued.
  @(posedge clk) not (done, dtag==done_tag
    ##[1:0] (req && req_tag == dtag)[*1:$]
    ##0 done && done_tag == dtag);
endproperty

// Concurrent assertion statements.
assert property (req2done)
  else $error(""Request tag didn't complete within 100 cycles."");

assert property (reqtag_once)
  else $error(""Request tag re-used before done received."");

assert property (donetag_once)
  else $error(""Two acknowledges received for request tag."");
",SystemVerilog Assertions for a Request/Acknowledge Protocol with Tagging,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p286.jpg,True,"The image shows a textbook page discussing the use of implication operators in Verilog assertions. The code is a Verilog property definition using implication. Here's the code from the image:

```verilog
property pr1;
  @(posedge clk) req |-> ##2 gnt;
endproperty

reqGnt: assert property (pr1) $display($stime,,,""\t\t %m PASS""); else $display($stime,,,""\t\t %m FAIL"");
```

The accompanying text explains that adding an implication operator prevents false failures in the assertion, but it also highlights an issue when `req` is `0` (low) and the assertion passes regardless. This is demonstrated through a simulation log shown in the image.","
property pr1;
  @(posedge clk) req |-> ##2 gnt;
endproperty

reqGnt: assert property (pr1) $display($stime,,,""\t\t %m PASS""); else $display($stime,,,""\t\t %m FAIL"");
","""Exploring the use of implication operators in Verilog property assertions and understanding vacuous passes.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p555.jpg,True,"```verilog
let LENGTH = $bits(packet_t);
typedef bit[$clog2(LENGTH):0] tx_ptr_t;

m_rst_vs_packet_start:
  assume_property (disable iff (1'b0) rst |-> ![packet_start]);
m_rst_vs_valid:
  assume_property (disable iff (1'b0) rst |-> !valid);
m_non_overlap_start: assume_property (
  packet_start |-> ![packet_start[*\LENGTH - 1] ]);

tx_ptr_t ptr;
function tx_ptr_t next_tx_ptr();
  if (rst) return 0;
  if (packet_start) return 1;
  if (ptr 0 && ptr < LENGTH - 1)
    return ptr + 1;
  return 0;
endfunction : next_tx_ptr
always_ff @clk ptr <= next_tx_ptr();

m_def_valid: assume_property (
  valid == (packet_start || ptr != 0));
m_def_data: assume property (
  valid |-| data == packet[LENGTH-1-ptr]);
m_new_only_if_start: assume property (
  new_packet |-> packet_start);

bit packet_seen = 1'b0;
always_ff @clk
  packet_seen <= !rst && (packet_start || packet_seen);

m_new_if_start_not_seen: assume_property (
  packet_start && !packet_seen |-> new_packet);
m_tx_packet_new: assume property (
  new_packet |-=> legal_txa(packet.txa));
m_tx_packet_stable: assume property (
  ##1 new_packet |-> $stable(packet));
if (QUIET)
  m_quiet_data: assume property (!tx_valid_i |-> !tx_data_i);
  sanity_valid_0: assert property (
    !packet_start && !packet_seen |-> !valid);
  sanity_valid_1: assert property (
    packet_start |-> valid[*\LENGTH]);
```

The image contains Verilog code pertaining to packet generation for a 1-bit serial interface, including assumptions and assertions for verifying the properties of the protocol.","
let LENGTH = $bits(packet_t);
typedef bit[$clog2(LENGTH):0] tx_ptr_t;

m_rst_vs_packet_start:
  assume_property (disable iff (1'b0) rst |-> ![packet_start]);
m_rst_vs_valid:
  assume_property (disable iff (1'b0) rst |-> !valid);
m_non_overlap_start: assume_property (
  packet_start |-> ![packet_start[*\LENGTH - 1] ]);

tx_ptr_t ptr;
function tx_ptr_t next_tx_ptr();
  if (rst) return 0;
  if (packet_start) return 1;
  if (ptr 0 && ptr < LENGTH - 1)
    return ptr + 1;
  return 0;
endfunction : next_tx_ptr
always_ff @clk ptr <= next_tx_ptr();

m_def_valid: assume_property (
  valid == (packet_start || ptr != 0));
m_def_data: assume property (
  valid |-| data == packet[LENGTH-1-ptr]);
m_new_only_if_start: assume property (
  new_packet |-> packet_start);

bit packet_seen = 1'b0;
always_ff @clk
  packet_seen <= !rst && (packet_start || packet_seen);

m_new_if_start_not_seen: assume_property (
  packet_start && !packet_seen |-> new_packet);
m_tx_packet_new: assume property (
  new_packet |-=> legal_txa(packet.txa));
m_tx_packet_stable: assume property (
  ##1 new_packet |-> $stable(packet));
if (QUIET)
  m_quiet_data: assume property (!tx_valid_i |-> !tx_data_i);
  sanity_valid_0: assert property (
    !packet_start && !packet_seen |-> !valid);
  sanity_valid_1: assert property (
    packet_start |-> valid[*\LENGTH]);
","Caption: ""Verilog code example illustrating packet generation for a 1-bit serial interface, demonstrating the use of typedefs, assumptions, and properties for formal verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p542.jpg,True,"There is code in the image, which is a snippet of C code defining a struct presumably for use with Verilog and the ACC (Application Control Center) library. The code is as follows:

```c
typedef struct t_location
{
    int line_no;
    char *filename;
} s_location, *p_location;
```

The accompanying text discusses the `acc_fetch_location()` routine and a table listing the types of Verilog objects supported by this routine.","ef struct t_location
{
    int line_no;
    char *filename;
} s_location, *p_location;
","The image shows a page from a reference book or document related to Verilog, discussing how to read and modify values using ACC (Access) routines with an illustration of the `acc_fetch_location()` function and a table listing Verilog object types that support source code location access via this function.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p35.jpg,True,"Here is the Verilog code mentioned in the image:

```verilog
assertion_name: assert property(property_name);
```

And below that, another piece of Verilog code:

```verilog
sequence s1;
    @(posedge clk) a;
endsequence
```","
assertion_name: assert property(property_name);


sequence s1;
    @(posedge clk) a;
endsequence
",The image depicts a textbook page discussing SystemVerilog Assertions (SVA) with an example of creating an assertion using a sequence to check a signal's state on the positive edge of a clock signal.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p224.jpg,True,"The image contains a small snippet of Verilog code. The code is provided below:

```verilog
always @(a or b)
    $my_strobe(sum);

always @(a or b)
    sum = a + b;
```

This example demonstrates parallel (concurrent) activity in Verilog, highlighting how a call to the `$my_strobe` routine is done anytime there is a change in either signal `a` or `b`.","
always @(a or b)
    $my_strobe(sum);

always @(a or b)
    sum = a + b;
","""Excerpt from 'The Verilog PLI Handbook' discussing simulation callbacks at the end of a time step in Verilog, with an example of concurrent activity in code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p233.jpg,True,"The image contains excerpts of code in Verilog. Here is the code present in the image:

```verilog
checker verify_consistency(state, astate, ...,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable);
    default clocking @clk; endclocking
    default disable iff rst;

    aidle: assert property (astate == AIDLE <-> state inside {IDLE1
    , IDLE2})
    else $error(""Idle states inconsistent"");
    ...
endchecker : verify_consistency

checker verify_abstract_fsm(astate, ...,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable);
    default clocking @clk; endclocking
    default disable iff rst;

    never_stuck: assert property (s_eventually astate != AIDLE)
    else $error(""FSM stuck"");
    unexpected: assert property (astate != AERR)
    else $error(""Unexpected behavior detected"");
    ...
endchecker : verify_abstract_fsm

checker verify_fsm(state, ...,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable);
    default clocking @clk; endclocking
    default disable iff rst;

    astate_t astate;

    abstract_fsm afsm(..., astate);
    verify_consistency vcons(state, astate, ...);
    verify_abstract_fsm vafsm(astate, ...);
endchecker : verify_fsm
```

This Verilog code defines three checkers which seem to be used for verifying the consistency and behavior of finite state machines (FSMs) within a verification environment.","
checker verify_consistency(state, astate, ...,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable);
    default clocking @clk; endclocking
    default disable iff rst;

    aidle: assert property (astate == AIDLE <-> state inside {IDLE1
    , IDLE2})
    else $error(""Idle states inconsistent"");
    ...
endchecker : verify_consistency

checker verify_abstract_fsm(astate, ...,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable);
    default clocking @clk; endclocking
    default disable iff rst;

    never_stuck: assert property (s_eventually astate != AIDLE)
    else $error(""FSM stuck"");
    unexpected: assert property (astate != AERR)
    else $error(""Unexpected behavior detected"");
    ...
endchecker : verify_abstract_fsm

checker verify_fsm(state, ...,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable);
    default clocking @clk; endclocking
    default disable iff rst;

    astate_t astate;

    abstract_fsm afsm(..., astate);
    verify_consistency vcons(state, astate, ...);
    verify_abstract_fsm vafsm(astate, ...);
endchecker : verify_fsm
","Caption: ""Verilog checkers for FSM consistency and behavior correctness, with system function inference for clock and reset.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p230.jpg,True,"There is some Verilog code in the image. Here it is:

```verilog
initial
    $read_stimulus_ba<base><delay_type>(""file"", verilog_reg);
```","
initial
    $read_stimulus_ba<base><delay_type>(""file"", verilog_reg);
","Caption: ""Example of scheduling simulation callbacks in Verilog using the PLI (Programming Language Interface) for reading stimulus vectors from a file and applying them at specific simulation times.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p227.jpg,True,"```verilog
checker check(logic a, b, c, clk, rst);
  logic x, y, z, v, t;
  assign x = a;                             // CV of a
  always_ff @(posedge clk or negedge rst)   // CV of clk and rst
  begin
    a1: assert final (b);                   // SV of b
    if (rst)                                // CV of rst
      z <= b;                               // SV of b
    else z <= !c;                           // SV of c
  end

  always_comb begin
    a2: assert final (b);                   // CV of b
    if (a)                                  // CV of a
      v = b;                                // CV of b
    else v = !b;                            // CV of b
  end

  always_latch begin
    a3: assert final (b);                   // CV of b
    if (clk)                                // CV of clk
      t <= b;                               // CV of b
  end
  ...
endchecker : check
```

This image features a snippet of Verilog code discussing ""Checker Modeling"" in Verilog. The comments on the right signify CV (Coverage Values) of specific variables or SV (SystemVerilog) that relate to specific constructs. The code is defining a checker named `check` with the relevant logic and procedural blocks (`always_ff`, `always_comb`, and `always_latch`). The `assert final` statements are used within these blocks to perform checks in the respective procedural contexts.","
checker check(logic a, b, c, clk, rst);
  logic x, y, z, v, t;
  assign x = a;                             // CV of a
  always_ff @(posedge clk or negedge rst)   // CV of clk and rst
  begin
    a1: assert final (b);                   // SV of b
    if (rst)                                // CV of rst
      z <= b;                               // SV of b
    else z <= !c;                           // SV of c
  end

  always_comb begin
    a2: assert final (b);                   // CV of b
    if (a)                                  // CV of a
      v = b;                                // CV of b
    else v = !b;                            // CV of b
  end

  always_latch begin
    a3: assert final (b);                   // CV of b
    if (clk)                                // CV of clk
      t <= b;                               // CV of b
  end
  ...
endchecker : check
","Caption: ""Example of Verilog checker modeling with assertions and procedural blocks, demonstrating the use of `always_ff`, `always_comb`, and `always_latch` to implement synchronous and combinatorial logic within a verification environment.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p541.jpg,True,"Here is the Verilog code from the image:

```verilog
checker check_latency(en, data_ready, max_latency,
                      event clk = $inferred_clock,
                      untyped rst = $inferred_disable);
  default clocking @clk; endclocking
  default disable iff rst;

  let ub(x) = $clog2(x + 1) - 1;
  let nstages = $bits(en) + 1;
  let stage_ub = ub(nstages);
  let big_latency = max_latency + 1;
  let latency_ub = ub(big_latency);

  rand bit start;
  bit [stage_ub:0] stage = '0;
  bit [latency_ub:0] latency = '0;

  bit go;
  assign go = data_ready && start;

  function type(stage) next_stage;
    if (rst) return 0;
    if (stage == 0 && go) return 1;
    if (stage != 0 && stage != nstages && en[stage])
      return stage + 1;
    return stage;
  endfunction : next_stage

  function type(latency) next_latency;
    if (rst || latency == 0 && !go) return 0;
    if (latency == big_latency) return big_latency;
    return latency + 1;
  endfunction : next_latency

  always @clk begin
    stage <= next_stage();
    latency <= next_latency();
  end

  a1: assert property (
    $rose(stage == nstages) -> latency != big_latency);
endchecker: check_latency
```

The code is an example of a checker in Verilog, which seems to be for checking pipeline latency within a certain design. The checks are built using methods that infer clock and reset signal behaviors, define helper functions to calculate upper bounds for different counters, and use assertions to ensure that certain properties hold true within the design.","
checker check_latency(en, data_ready, max_latency,
                      event clk = $inferred_clock,
                      untyped rst = $inferred_disable);
  default clocking @clk; endclocking
  default disable iff rst;

  let ub(x) = $clog2(x + 1) - 1;
  let nstages = $bits(en) + 1;
  let stage_ub = ub(nstages);
  let big_latency = max_latency + 1;
  let latency_ub = ub(big_latency);

  rand bit start;
  bit [stage_ub:0] stage = '0;
  bit [latency_ub:0] latency = '0;

  bit go;
  assign go = data_ready && start;

  function type(stage) next_stage;
    if (rst) return 0;
    if (stage == 0 && go) return 1;
    if (stage != 0 && stage != nstages && en[stage])
      return stage + 1;
    return stage;
  endfunction : next_stage

  function type(latency) next_latency;
    if (rst || latency == 0 && !go) return 0;
    if (latency == big_latency) return big_latency;
    return latency + 1;
  endfunction : next_latency

  always @clk begin
    stage <= next_stage();
    latency <= next_latency();
  end

  a1: assert property (
    $rose(stage == nstages) -> latency != big_latency);
endchecker: check_latency
","""Example of Verilog code for checking pipeline latency using SystemVerilog assertions with a checker block.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p108.jpg,True,"The image contains Verilog code. Here's the code presented in the image:

```verilog
input logic a, b, clk;

property p_mutex;
    @(posedge clk) not (a && b);
endproperty

a_mutex: assert property(p_mutex);

endmodule

bind <module_name or instance name>
      <checker name> <checker instance name>
      <design signals>;

bind inline mutex_chk i2 (a, b, clk);

module top (...);

    inline u1 (clk, a, b, in1, in2, out1);
    inline u2 (clk, c, d, in3, in4, out2);

endmodule

bind top.u1 mutex_chk i1(a, b, clk);
bind top.u2 mutex_chk i2(c, d, clk);
```

This text appears to be discussing SystemVerilog Assertions (SVA) and how to use the `bind` construct to bind checking modules or assertions to instances in a design.","
input logic a, b, clk;

property p_mutex;
    @(posedge clk) not (a && b);
endproperty

a_mutex: assert property(p_mutex);

endmodule

bind <module_name or instance name>
      <checker name> <checker instance name>
      <design signals>;

bind inline mutex_chk i2 (a, b, clk);

module top (...);

    inline u1 (clk, a, b, in1, in2, out1);
    inline u2 (clk, c, d, in3, in4, out2);

endmodule

bind top.u1 mutex_chk i1(a, b, clk);
bind top.u2 mutex_chk i2(c, d, clk);
","""Verilog code demonstrating the use of SystemVerilog Assertions (SVA) and the bind construct to attach checkers to design instances.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p569.jpg,True,"The image contains Verilog code. Here is the code presented in the image:

```verilog
default disable iff rst_n;
onehot0 A1 (x1); // check input
always_comb begin
    r2 = r1;
    onehot0 A2 (r1); // check output
end
endmodule

...

property time_interval_p
    (sequence trig, property cond,
     start_tick = 1, end_tick = 1,
     event clk = $inferred_clock,
     untyped rst_n = $inferred_disable);
    @clk disable iff (!bit'(rst_n))
    trig |-> 
    always [start_tick:end_tick] cond;
endproperty : time_interval_p
```

The code includes a simple checker (onehot0), the module containing it, and a property that defines a simple property-based temporal checker using the `property` keyword in Verilog. The property `time_interval_p` is defined below, which checks that when `trig` occurs, `cond` holds true in the interval from `start_tick` to `end_tick`, provided it is not disabled by `rst_n`.","
default disable iff rst_n;
onehot0 A1 (x1); // check input
always_comb begin
    r2 = r1;
    onehot0 A2 (r1); // check output
end
endmodule

...

property time_interval_p
    (sequence trig, property cond,
     start_tick = 1, end_tick = 1,
     event clk = $inferred_clock,
     untyped rst_n = $inferred_disable);
    @clk disable iff (!bit'(rst_n))
    trig |-> 
    always [start_tick:end_tick] cond;
endproperty : time_interval_p
","Caption: ""Example of Verilog code illustrating a simple property-based temporal checker with usage notes.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p120.jpg,True,"The image shows a snippet of Verilog code. Here is the code transcribed:

```verilog
module arbiter(....);

// port declarations

parameter arb_sva = 1'b1;
parameter arb_sva_severity = 1'b1;

// Arbiter design description
// SVA property description

// SVA Checks

always@(posedge clk)
begin
    if(arb_sva)
    begin
        a_arb_onehot0:
            assert property(p_arb_onehot0)
            else if(arb_sva_severity) $fatal;
        
        a_req_gnt:
            assert property(p_req_gnt)
            else if(arb_sva_severity) $fatal;
        
        a_gnt_frame :
            assert property(p_gnt_frame)
            else if(arb_sva_severity) $fatal;
        
        a_frame_gnt:
            assert property(p_frame_gnt)
            else if(arb_sva_severity) $fatal;
        
        c_arb_onehot0: cover property(p_arb_onehot0);
        c_req_gnt: cover property(p_req_gnt);
        c_gnt_frame: cover property(p_gnt_frame);
        c_frame_gnt: cover property(p_frame_gnt);
        
    end
end

endmodule
``` 

This code appears to be a part of a simulation methodology section concerning SystemVerilog Assertions (SVA) to ensure certain properties in an arbiter module design. The code has parameters for enabling the SVA checks and their severity. It includes `always @(posedge clk)` block which is a procedural block that triggers on every positive edge of the clock (`clk`). The `assert` statements are for checking the properties and the `cover` statements are for specifying coverage points.","
module arbiter(....);

// port declarations

parameter arb_sva = 1'b1;
parameter arb_sva_severity = 1'b1;

// Arbiter design description
// SVA property description

// SVA Checks

always@(posedge clk)
begin
    if(arb_sva)
    begin
        a_arb_onehot0:
            assert property(p_arb_onehot0)
            else if(arb_sva_severity) $fatal;
        
        a_req_gnt:
            assert property(p_req_gnt)
            else if(arb_sva_severity) $fatal;
        
        a_gnt_frame :
            assert property(p_gnt_frame)
            else if(arb_sva_severity) $fatal;
        
        a_frame_gnt:
            assert property(p_frame_gnt)
            else if(arb_sva_severity) $fatal;
        
        c_arb_onehot0: cover property(p_arb_onehot0);
        c_req_gnt: cover property(p_req_gnt);
        c_gnt_frame: cover property(p_gnt_frame);
        c_frame_gnt: cover property(p_frame_gnt);
        
    end
end

endmodule
","""A Verilog module demonstrating SystemVerilog Assertions (SVA) for simulation methodology in hardware verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p218.jpg,True,"The image includes a snippet of code which is part of a Verilog PLI (Programming Language Interface) example. Here is the code provided in the image:

```c
#include <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard input/output library */
#include <malloc.h> /* ANSI C standard memory allocation library */
#include <vpi_user.h> /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library 
                         (using TF routines for simulation control) */

/* include utility routines to work with tfargs */
#include ""vpi_utilities.c""
```

This code is used for interfacing C code with Verilog simulations through the VPI portion of the PLI. It includes headers for standard C libraries and PLI specific functionality provided by `vpi_user.h` and `veriuser.h`. The file `""vpi_utilities.c""` is presumably a file containing utility functions to help with handling task/function arguments in PLI applications.","ude <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard input/output library */
#include <malloc.h> /* ANSI C standard memory allocation library */
#include <vpi_user.h> /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library 
                         (using TF routines for simulation control) */

/* include utility routines to work with tfargs */
#include ""vpi_utilities.c""
","""An illustration of Verilog PLI application with simulation action callbacks to read test vectors from a file for simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p203.jpg,True,"```verilog
Transaction tr, tr2;
byte b[$]; // Queue of bytes

initial begin
  tr = new(),
  tr.addr = 32'ha0a0a0a0; // Fill object with values
  tr.csm = '1;
  foreach (tr.data[i])
    tr.data[i] = i;

  tr.pack(b); // Pack object into byte array
  $write(""Pack results: "");
  foreach (b[i])
    $write(""%h"", b[i]);
  $display;

  tr2 = new();
  tr2.unpack(b);
  tr2.display();
end
```","
Transaction tr, tr2;
byte b[$]; // Queue of bytes

initial begin
  tr = new(),
  tr.addr = 32'ha0a0a0a0; // Fill object with values
  tr.csm = '1;
  foreach (tr.data[i])
    tr.data[i] = i;

  tr.pack(b); // Pack object into byte array
  $write(""Pack results: "");
  foreach (b[i])
    $write(""%h"", b[i]);
  $display;

  tr2 = new();
  tr2.unpack(b);
  tr2.display();
end
","Caption: ""Example of Verilog code demonstrating object-oriented programming concepts with the use of pack and unpack functions to manipulate data within a transaction class.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p217.jpg,True,"Here is the Verilog code from the image:

```verilog
class Order_bad;
  rand bit [7:0] lo, med, hi;
  constraint bad {lo < med < hi;} // Gotcha!
endclass
```

```verilog
class Order_good;
  rand bit [7:0] lo, med, hi;
  constraint good {lo < med;   // Only use binary constraints
                   med < hi;}
endclass
```

The image shows examples of how to use constraints in Verilog to ensure variables are in a fixed order and highlights the importance of using binary constraints to avoid unexpected results.","
class Order_bad;
  rand bit [7:0] lo, med, hi;
  constraint bad {lo < med < hi;} // Gotcha!
endclass


class Order_good;
  rand bit [7:0] lo, med, hi;
  constraint good {lo < med;   // Only use binary constraints
                   med < hi;}
endclass
","""Examples of correct and incorrect use of ordering constraints in Verilog code, with explanations and consequences of bad constraint practices.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p134.jpg,True,"The image contains text and waveforms related to SystemVerilog Assertions (SVA) simulation methodology, and at the bottom, there is some Verilog code. I'll transcribe the code for you:

```verilog
Module top(..., ... );

// port declarations

master u1 (ask[2], clk, req1, gnt1, frame1, irdy1, trdy, data1, rsel1, datao);
master u2 (ask[1], clk, req2, gnt2, frame2, irdy2, trdy, data2, rsel2, datao);
master u3 (ask[0], clk, req3, gnt3, frame3, irdy3, trdy, data3, rsel3, datao);

arbiter u4 (clk, reset, frame, irdy, req1, req2, req3, gnt1, gnt2, gnt3);

glue u5 (clk, frame1, irdy1, frame2, irdy2, frame3, irdy3, trdy, rsel1, rsel2, rsel3, data1, datao, datain, dataout);
```

This Verilog code is illustrating module instantiation, where various ""master"", an ""arbiter"", and ""glue"" modules are declared with their corresponding port connections. The ellipsis (...) suggests that the module `top` has more ports which are not shown here. Please note that in actual Verilog code, the keyword `Module` should be lowercase: `module`.","
Module top(..., ... );

// port declarations

master u1 (ask[2], clk, req1, gnt1, frame1, irdy1, trdy, data1, rsel1, datao);
master u2 (ask[1], clk, req2, gnt2, frame2, irdy2, trdy, data2, rsel2, datao);
master u3 (ask[0], clk, req3, gnt3, frame3, irdy3, trdy, data3, rsel3, datao);

arbiter u4 (clk, reset, frame, irdy, req1, req2, req3, gnt1, gnt2, gnt3);

glue u5 (clk, frame1, irdy1, frame2, irdy2, frame3, irdy3, trdy, rsel1, rsel2, rsel3, data1, datao, datain, dataout);
","""Excerpt from a textbook on SystemVerilog showing signal waveform diagrams and module interface code for system level verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p581.jpg,True,"The image contains code snippets related to the Programming Language Interface (PLI) of Verilog. Here is the code extracted from the page:

```c
acc_configure(accPathDelayCount, ""1"");
acc_configure(accPathDelayCount, ""2"");
acc_configure(accPathDelayCount, ""3"");
acc_configure(accPathDelayCount, ""6"");
acc_configure(accPathDelayCount, ""12"");
```

Additionally, there is a function prototype as part of an example described on the page:

```c
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */
/**********************************************************/
/* calltf application */
/**********************************************************/
int PLIbook_PrimDelays_calltf()
{
    handle module_h, prim_h;
    double rise, fall, toz;
}
```

This code is associated with accessing and manipulating delay values in Verilog simulations using the PLI.","onfigure(accPathDelayCount, ""1"");
acc_configure(accPathDelayCount, ""2"");
acc_configure(accPathDelayCount, ""3"");
acc_configure(accPathDelayCount, ""6"");
acc_configure(accPathDelayCount, ""12"");

ude ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */
/**********************************************************/
/* calltf application */
/**********************************************************/
int PLIbook_PrimDelays_calltf()
{
    handle module_h, prim_h;
    double rise, fall, toz;
}
",Excerpt from a textbook explaining how to configure and fetch module path delays in Verilog using the PLI (Programming Language Interface) with an example code snippet.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p152.jpg,True,"The image contains an excerpt of Verilog code from a textbook or document. Here is the readable Verilog code from the image:

```verilog
`timescale 1 ns / 10 ps
//Define time to offset random initialization of registers.
`define TIMEINIT #0.05;
`define TIMEINITLATCH #0.06;
`define TIMEINITRESET #0.07;
`define TIMEINITTEST #0.1
...
initial
    Initialize the waveform viewer.
...
initial begin
    `TIMEINIT
    Randomly initialize flip-flops.
end
initial begin
    `TIMEINITLATCH
    Randomly initialize latches.
end
initial begin
    `TIMEINITRESET
    Randomly initialize reset flip-flops.
end
initial begin
    `TIMEINITTEST
    Start the clocks and the test.
end
```

The code defines macros with specified delays intended for the initialization of various components in a test bench scenario.","
`timescale 1 ns / 10 ps
//Define time to offset random initialization of registers.
`define TIMEINIT #0.05;
`define TIMEINITLATCH #0.06;
`define TIMEINITRESET #0.07;
`define TIMEINITTEST #0.1
...
initial
    Initialize the waveform viewer.
...
initial begin
    `TIMEINIT
    Randomly initialize flip-flops.
end
initial begin
    `TIMEINITLATCH
    Randomly initialize latches.
end
initial begin
    `TIMEINITRESET
    Randomly initialize reset flip-flops.
end
initial begin
    `TIMEINITTEST
    Start the clocks and the test.
end
","""Example of Verilog Time Scales and Initial Blocks in a Simulation to Prevent Logic Races.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p595.jpg,True,"The image contains information about Verilog, specifically, it discusses Verilog PLI (Programming Language Interface) routines for accessing attributes. Here is the code text from the image:

```verilog
specparam InputLoad$a = 0.2; //object-specific attribute
specparam InputLoad$b = 0.3; //object-specific attribute

double load_in;
handle port_h;

/* add code to obtain a handle for module input port b */

load_in = acc_fetch_attribute(port_h, ""InputLoad$b"", 1.0);
```

The comments in the code provide additional context about the purpose of the specparams and the call to `acc_fetch_attribute`. The incomplete comment (`/* add code to obtain a handle for module input port b */`) implies that there is additional code needed to obtain a handle to a module port, which is not provided in the image.","
specparam InputLoad$a = 0.2; //object-specific attribute
specparam InputLoad$b = 0.3; //object-specific attribute

double load_in;
handle port_h;

/* add code to obtain a handle for module input port b */

load_in = acc_fetch_attribute(port_h, ""InputLoad$b"", 1.0);
","Caption: ""Verilog PLI functions for attribute fetching with example code snippet.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p333.jpg,True,"The image contains examples of Verilog code. Here it is:

1. Declaration sets defaults:
```verilog
module ALU #(parameter DataHiBit=31, OutDelay=5, RegDelay=6)
             (output [DataHiBit:0] OutBus, ...);
...
// Instantiation:
ALU     #(.DataHiBit(63), .RegDelay(7)) // OutDelay gets the default.
        .OutBus(ResultWire), ...);
...
```

2. Traditional Header Declaration Format:
```verilog
module ModuleName (PortName1, PortName2, OutPortName1, ...);
parameter Name1 = value1; ...
direction[Name1:0] PortName1; // direction = output, input, inout.
direction[range] PortName2; ...
reg[range] OutPortName1; ... // output assigned procedurally.
...
```

The text surrounding the code provides further explanation on parameter types, module connections, and differences between ANSI and traditional header declaration formats in Verilog.","
module ALU #(parameter DataHiBit=31, OutDelay=5, RegDelay=6)
             (output [DataHiBit:0] OutBus, ...);
...
// Instantiation:
ALU     #(.DataHiBit(63), .RegDelay(7)) // OutDelay gets the default.
        .OutBus(ResultWire), ...);
...


module ModuleName (PortName1, PortName2, OutPortName1, ...);
parameter Name1 = value1; ...
direction[Name1:0] PortName1; // direction = output, input, inout.
direction[range] PortName2; ...
reg[range] OutPortName1; ... // output assigned procedurally.
...
","""Overview of Verilog Parameter Types and Module Declaration Formats""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p441.jpg,True,"The image contains Verilog code for a digital VLSI (Very Large Scale Integration) design. Here's the text of the code in the image:

```verilog
always@(posedge StateClock, posedge Reset)
begin : IncrWriteBlock
    if (Reset=='b1)
        WriteAr <= 'b0;
    else begin
        case (CurState)
            emptyS: WriteAr <= 'b0;    // Set equal to read addr.
            fullS: WriteAr <= ReadAr;  // Set equal to first valid addr.
        endcase
        if (CurState!=fullS && WriteCmdr=='b1)
            WriteAr <= WriteAr + 1;
    end
end

task incrWrite(input ActionW);
begin
    if (ActionW=='b1)
    begin
        if (CurState==fullS)
        begin
            WriteCmdr = 'b0;
            OldWriteAr = ReadAr;
        end
    else
        begin
            if (WriteAr==OldWriteAr) // Schedule an incr.
                WriteCmdr = 'b1;
            else begin // No incr; already changed:
                WriteCmdr = 'b0;
                OldWriteAr = WriteAr;
            end
        end
    end
    else begin // ActionW is a reset.
        WriteCmdr = 'b0;
        OldWriteAr = 'b0;
    end
end
endtask
```

The code is a part of a section discussing register-file write.

The `always` block named ""IncrWriteBlock"" is triggered on the positive edge of either `StateClock` or `Reset`. If `Reset` is high, the `WriteAr` variable is set to zero. Otherwise, the variable is set according to the current state (`CurState`), and if conditions are met, `WriteAr` is incremented.

The `task` called `incrWrite` takes an input `ActionW`. If `ActionW` is high (1), it checks the `CurState` and performs certain actions, potentially modifying `WriteCmdr` and `OldWriteAr`. If `ActionW` is not high (indicating a reset operation), it sets `WriteCmdr` and `OldWriteAr` to zero.

There is also a portion of text suggesting how to modify calls in a combinatorial block to pass appropriate values based on state and recommends removing certain old latch declarations and instances.","
always@(posedge StateClock, posedge Reset)
begin : IncrWriteBlock
    if (Reset=='b1)
        WriteAr <= 'b0;
    else begin
        case (CurState)
            emptyS: WriteAr <= 'b0;    // Set equal to read addr.
            fullS: WriteAr <= ReadAr;  // Set equal to first valid addr.
        endcase
        if (CurState!=fullS && WriteCmdr=='b1)
            WriteAr <= WriteAr + 1;
    end
end

task incrWrite(input ActionW);
begin
    if (ActionW=='b1)
    begin
        if (CurState==fullS)
        begin
            WriteCmdr = 'b0;
            OldWriteAr = ReadAr;
        end
    else
        begin
            if (WriteAr==OldWriteAr) // Schedule an incr.
                WriteCmdr = 'b1;
            else begin // No incr; already changed:
                WriteCmdr = 'b0;
                OldWriteAr = WriteAr;
            end
        end
    end
    else begin // ActionW is a reset.
        WriteCmdr = 'b0;
        OldWriteAr = 'b0;
    end
end
endtask
",Verilog Code Examples: Writing to a Register File and Using Tasks in Digital VLSI Design.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p440.jpg,True,"The image contains Verilog code. Here's the extract:

```verilog
task incrRead(input ActionR);
begin
    if (ActionR=='1'b1)
    begin
        if (CurState==emptyS)
        begin
            ReadCmdr = '1'b0;
            OldReadAr = '1'b0;
        end
        else begin
            if (ReadAr==OldReadAr) // Schedule an incr.
                ReadCmdr = '1'b1;
            else begin // No incr; already changed:
                ReadCmdr = '1'b0;
                OldReadAr = ReadAr;
            end
        end
    end
    else begin // ActionR is a reset:
        ReadCmdr = '1'b0;
        OldReadAr = '1'b0;
    end
end
endtask
```

This task seems to handle the read incrementation for a FIFO buffer in a hardware design, considering various states and input actions.","
task incrRead(input ActionR);
begin
    if (ActionR=='1'b1)
    begin
        if (CurState==emptyS)
        begin
            ReadCmdr = '1'b0;
            OldReadAr = '1'b0;
        end
        else begin
            if (ReadAr==OldReadAr) // Schedule an incr.
                ReadCmdr = '1'b1;
            else begin // No incr; already changed:
                ReadCmdr = '1'b0;
                OldReadAr = ReadAr;
            end
        end
    end
    else begin // ActionR is a reset:
        ReadCmdr = '1'b0;
        OldReadAr = '1'b0;
    end
end
endtask
","The image shows a textbook page with a description and Verilog code for a task named `incrRead`, which appears to be used for managing a register-file read operation based on certain conditions in a hardware description.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p147.jpg,True,"There is code in the image. Here is the Verilog code from Example 6-9:

```verilog
module dff_xc_4 ( q, d, scan_in, ck, scan_sel, reset_, phase_en);
output [3:0] q;
input [3:0] d, scan_in;
input ck, scan_sel, reset_, phase_en;
reg [3:0] q;
always @(posedge ck) begin // model checking model
  if (phase_en) // to support common clock abstraction
    q<=(reset_==0)?4'b0000:((scan_sel)?scan_in:d);
end
endmodule // dff_xc_4
```","
module dff_xc_4 ( q, d, scan_in, ck, scan_sel, reset_, phase_en);
output [3:0] q;
input [3:0] d, scan_in;
input ck, scan_sel, reset_, phase_en;
reg [3:0] q;
always @(posedge ck) begin // model checking model
  if (phase_en) // to support common clock abstraction
    q<=(reset_==0)?4'b0000:((scan_sel)?scan_in:d);
end
endmodule // dff_xc_4
","Caption: ""Example of a Verilog module for model checking with phase enable signal, highlighting multi-phase clock abstraction in verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p594.jpg,True,"Here's the Verilog code from the image:

```verilog
module AN2 (o, a, b); // 2-input AND gate standard cell
output o;
input a, b;

and (o, a, b);

specify
  specparam BaseDelay$ = 2.2; //general attribute
  specparam InputLoad$a = 0.2; //object-specific attribute
  specparam InputLoad$b = 0.3; //object-specific attribute
endspecify
endmodule
```

The code is an example of using ""specparam"" to define timing and load parameters for a simple 2-input AND gate module in Verilog, which can be used within the ACC (Application Control Code) library sections of a PLI (Programming Language Interface) application.","
module AN2 (o, a, b); // 2-input AND gate standard cell
output o;
input a, b;

and (o, a, b);

specify
  specparam BaseDelay$ = 2.2; //general attribute
  specparam InputLoad$a = 0.2; //object-specific attribute
  specparam InputLoad$b = 0.3; //object-specific attribute
endspecify
endmodule
","""Excerpt from a textbook on Verilog discussing 'specparam constants' as model attributes, with an example of Verilog code using general and object-specific attributes.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p580.jpg,True,"The image contains a snippet of text with some code. Here is the code:

```c
acc_configure(accMinTypMaxDelays, ""false"");
```","onfigure(accMinTypMaxDelays, ""false"");
","""Information on configuring and fetching delay values using ACC routines in Verilog from a technical document.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p153.jpg,True,"The image contains Verilog code fragments. Here they are:

Example 7-2:
```
always @(BCK)
    BCK_NBA <= BCK;
assign `TIMEASSIGN DATA = BCK ? QH : QL;
```
or add a defined delay value `TIMEASSIGN` in the data path following the multiplexer.

Example 7-3:
```
assign `TIMEASSIGN DATA = BCK ? QH : QL;
```

Example 7-4:
```
`define TIMENBA #0.01
...
always @ (posedge ck)
    Q <= `TIMENBA d;
```

Note: The code includes tick-defines (for example, `TIMEASSIGN` and `TIMENBA`), which are preprocessor directives in Verilog that define text macros. However, due to the format of the image, there might be more context needed for these macros that is not visible here."," @(BCK)
    BCK_NBA <= BCK;
assign `TIMEASSIGN DATA = BCK ? QH : QL;

 `TIMEASSIGN DATA = BCK ? QH : QL;

e TIMENBA #0.01
...
always @ (posedge ck)
    Q <= `TIMENBA d;
","Caption: ""Page from a textbook explaining Verilog non-blocking assignments and strategies to diagnose race conditions, with examples of Verilog code for implementing a time delay and addressing combinational feedback.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p216.jpg,True,"The image contains Verilog code which is part of a Sample 6.4 from a document discussing randomization in Verilog. The code is as follows:

```verilog
class Stim;
  const bit [31:0] CONGEST_ADDR = 42;
  typedef enum {READ, WRITE, CONTROL} stim_e;
  rand stim_e kind;  // Enumerated var
  rand bit [31:0] len, src, dst;
  rand bit congestion_test;

  constraint c_stim {
    len > 0;
    len < 1000;
    if (congestion_test) {
      dst inside {[CONGEST_ADDR-10:CONGEST_ADDR+10]};
      src == CONGEST_ADDR;
    }
    else {
      src inside {0, [2:10], [100:107]};
    }
  }
endclass
```

This code describes a class named `Stim` with randomized properties and a constraint block that defines how the randomization should behave. The constraints are applied to the `len`, `src`, and `dst` variables, depending on the value of `congestion_test`.","
class Stim;
  const bit [31:0] CONGEST_ADDR = 42;
  typedef enum {READ, WRITE, CONTROL} stim_e;
  rand stim_e kind;  // Enumerated var
  rand bit [31:0] len, src, dst;
  rand bit congestion_test;

  constraint c_stim {
    len > 0;
    len < 1000;
    if (congestion_test) {
      dst inside {[CONGEST_ADDR-10:CONGEST_ADDR+10]};
      src == CONGEST_ADDR;
    }
    else {
      src inside {0, [2:10], [100:107]};
    }
  }
endclass
","Caption: ""Example of a Verilog code snippet showing a class with constrained random variables and a constraint block demonstrating the use of conditional expressions within constraints for randomization.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p34.jpg,True,"The image contains Verilog code for a module named `shreg`. Here is the code transcribed from the image:

```verilog
module shreg (input logic clk, rst, set, logic [7:0] val,
              output logic [7:0] shift_reg);
  always @(posedge clk or posedge rst) begin
    if (rst) shift_reg <= 0;
    else begin
      if (set) shift_reg <= val;
      else begin
        shift_reg <= shift_reg << 1;
        shift_reg[0] <= shift_reg[7];
      end
    end
  end

  check_shift: assert property (@(posedge clk)disable iff (rst)
    set or
    nexttime shift_reg == $past({shift_reg[6:0], shift_reg[7]}));
  check_rst: assert final (rst -> shift_reg == '0);
endmodule : shreg
```

This code snippet defines a shift register with set and reset functionality, and includes assertions to check the functionality of the register. The `check_shift` assertion verifies the shift operation unless the reset signal is active, and the `check_rst` assertion ensures that the shift register is properly reset.","
module shreg (input logic clk, rst, set, logic [7:0] val,
              output logic [7:0] shift_reg);
  always @(posedge clk or posedge rst) begin
    if (rst) shift_reg <= 0;
    else begin
      if (set) shift_reg <= val;
      else begin
        shift_reg <= shift_reg << 1;
        shift_reg[0] <= shift_reg[7];
      end
    end
  end

  check_shift: assert property (@(posedge clk)disable iff (rst)
    set or
    nexttime shift_reg == $past({shift_reg[6:0], shift_reg[7]}));
  check_rst: assert final (rst -> shift_reg == '0);
endmodule : shreg
","Caption: ""Example of a Verilog code for an 8-bit shift register with associated assertions for white-box verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p135.jpg,True,"The image contains a snippet of Verilog code that seems to be part of a digital design document or book. The visible code reads as follows:

```verilog
data2, data3, sel, data, dataout1, dataout2, data0);

target u6 (clk, reset, sel[1], trdy[1], data, dataout1);

target u7 (clk, reset, sel[0], trdy[0], data, dataout2);

endmodule
```

This snippet appears to be part of a module instantiation where ""target"" might be a Verilog module and ""u6"" and ""u7"" are instances of this module being declared with various inputs and output ports connected to signals such as ""clk"" (clock), ""reset"", ""sel"" (select), ""trdy"" (ready), ""data"", ""dataout1"", and ""dataout2"". The details and purpose of the code would be clearer with more context.","
data2, data3, sel, data, dataout1, dataout2, data0);

target u6 (clk, reset, sel[1], trdy[1], data, dataout1);

target u7 (clk, reset, sel[0], trdy[0], data, dataout2);

endmodule
","""Excerpt from a textbook on SystemVerilog discussing tips for system level verification in Verilog and featuring an example of module instantiation code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p121.jpg,True,"```systemverilog
property p_master_start1;
@(posedge clk)
```
This is the only piece of code present in the image. The rest of the text describes Verilog/SystemVerilog parameters and properties, but does not show complete code.","erilog
property p_master_start1;
@(posedge clk)
","""Example of an Arbiter Simulation Waveform and SystemVerilog Assertions for Master Verification in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p568.jpg,True,"The image contains an example of Verilog code for a module instantiation. Here is the code provided in the image:

```verilog
`define ASSERT_ON
module m(input logic [3:0] r1,
          output logic [3:0] r2,
          input logic rst_n);
```

This is a snippet of a Verilog module definition that appears to be illustrating how to instantiate a combinational checker. The full functionality of the module `m` is not provided within the visible part of the image.","
`define ASSERT_ON
module m(input logic [3:0] r1,
          output logic [3:0] r2,
          input logic rst_n);
","""Features of a combinational checker in Verilog for coverage and verification with an example of checker instantiation.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p202.jpg,True,"The image contains a section from a document describing ""Packing Objects to and from Arrays Using Streaming Operators"" in Verilog. Here is the code snippet visible in the image:

```verilog
class Transaction;
  bit [31:0] addr, csm, data[8]; // Real data
  static int count = 0;          // Meta-data does not
  int id;                        // get packed

  function new();
    id = count++;
  endfunction

  function void display();
    $write(""Tr: id=%0d, addr=%x, csm=%x"", id, addr, csm);
    foreach(data[i]) $write("" %x"", data[i]);
    $display;
  endfunction

  function void pack(ref byte bytes[$]);
    bytes = { << {addr, csm, data}};
  endfunction

  function Transaction unpack(ref byte bytes[$]);
    { >> {addr, csm, data}} = bytes;
  endfunction
endclass : Transaction
```

This example demonstrates a Transaction class with pack and unpack functions that are used to pack the data into an array of bytes or to unpack it from such an array, respectively.","
class Transaction;
  bit [31:0] addr, csm, data[8]; // Real data
  static int count = 0;          // Meta-data does not
  int id;                        // get packed

  function new();
    id = count++;
  endfunction

  function void display();
    $write(""Tr: id=%0d, addr=%x, csm=%x"", id, addr, csm);
    foreach(data[i]) $write("" %x"", data[i]);
    $display;
  endfunction

  function void pack(ref byte bytes[$]);
    bytes = { << {addr, csm, data}};
  endfunction

  function Transaction unpack(ref byte bytes[$]);
    { >> {addr, csm, data}} = bytes;
  endfunction
endclass : Transaction
",Verilog code excerpt showing a Transaction class with methods for packing and unpacking data.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p219.jpg,True,"The image contains code written in C that is meant to interact with Verilog simulations through the VPI (Verilog Procedural Interface). Here is the text of the code from the image:

```c
/* prototypes of routines in this PLI application */
int PLIbook_ReadVector_calltf(), PLIbook_ReadVector_compiletf(),
    PLIbook_StartOfSim();

/**********************************************************************
 * Define storage structure for file pointer and vector handle.
 *********************************************************************/
typedef struct PLIbook_Data {
    FILE *file_ptr;        /* test vector file pointer */
    vpiHandle  obj_h;      /* pointer to store handle for a Verilog object */
} PLIbook_Data_s, *PLIbook_Data_p;

/**********************************************************************
 * VPI Registration Data
 *********************************************************************/
void PLIbook_ReadVector_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type         = vpiSysTask;
    tf_data.tfname       = ""$read_test_vector"";
    tf_data.calltf       = PLIbook_ReadVector_calltf;
    tf_data.compiletf    = PLIbook_ReadVector_compiletf;
    tf_data.sizetf       = NULL;
    tf_data.user_data    = NULL;
    vpi_register_systf(&tf_data);
}

/**********************************************************************
 * compiletf routine
 *********************************************************************/
int PLIbook_ReadVector_compiletf(char *user_data)
{
    s_cb_data    cb_data_s;
    s_vpi_systf_data  systf_h, arg_itr, arg_h;
    int          tfarg_type, err = 0;
    char         *file_name;

    systf_h = vpi_handle(vpiSysTfCall, NULL);
    arg_itr = vpi_iterate(vpiArgument, systf_h);
    if (arg_itr == NULL) {
        vpi_printf(""ERROR: $read_test_vector requires 2 arguments\n"");
        tf_dofinish();
        return(0);
    }

    arg_h = vpi_scan(arg_itr); /* get handle for first tfarg */
    if (vpi_get(vpiType, arg_h) != vpiConstant) {
        vpi_printf(""$read_test_vector arg 1 must be a quoted file name\n"");
        err = 1;
    } else if (vpi_get(vpiConstType, arg_h) != vpiStringConst) {
        vpi_printf(""$read_test_vector arg 1 must be a string\n"");
        err = 1;
    }
}
```

The code defines a data structure and functions for a custom system task in Verilog that reads test vectors. The `PLIbook_ReadVector_register` function is used to register the system task with the simulator, and the `PLIbook_ReadVector_compiletf` function checks that the system task is called with the correct arguments.","ototypes of routines in this PLI application */
int PLIbook_ReadVector_calltf(), PLIbook_ReadVector_compiletf(),
    PLIbook_StartOfSim();

/**********************************************************************
 * Define storage structure for file pointer and vector handle.
 *********************************************************************/
typedef struct PLIbook_Data {
    FILE *file_ptr;        /* test vector file pointer */
    vpiHandle  obj_h;      /* pointer to store handle for a Verilog object */
} PLIbook_Data_s, *PLIbook_Data_p;

/**********************************************************************
 * VPI Registration Data
 *********************************************************************/
void PLIbook_ReadVector_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type         = vpiSysTask;
    tf_data.tfname       = ""$read_test_vector"";
    tf_data.calltf       = PLIbook_ReadVector_calltf;
    tf_data.compiletf    = PLIbook_ReadVector_compiletf;
    tf_data.sizetf       = NULL;
    tf_data.user_data    = NULL;
    vpi_register_systf(&tf_data);
}

/**********************************************************************
 * compiletf routine
 *********************************************************************/
int PLIbook_ReadVector_compiletf(char *user_data)
{
    s_cb_data    cb_data_s;
    s_vpi_systf_data  systf_h, arg_itr, arg_h;
    int          tfarg_type, err = 0;
    char         *file_name;

    systf_h = vpi_handle(vpiSysTfCall, NULL);
    arg_itr = vpi_iterate(vpiArgument, systf_h);
    if (arg_itr == NULL) {
        vpi_printf(""ERROR: $read_test_vector requires 2 arguments\n"");
        tf_dofinish();
        return(0);
    }

    arg_h = vpi_scan(arg_itr); /* get handle for first tfarg */
    if (vpi_get(vpiType, arg_h) != vpiConstant) {
        vpi_printf(""$read_test_vector arg 1 must be a quoted file name\n"");
        err = 1;
    } else if (vpi_get(vpiConstType, arg_h) != vpiStringConst) {
        vpi_printf(""$read_test_vector arg 1 must be a string\n"");
        err = 1;
    }
}
","Chapter excerpt on synchronizing to Verilog simulations using VPI callbacks, featuring code for registering tasks and callback functions in Verilog using the VPI library.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p184.jpg,True,"The image contains a snippet of Verilog code. Here is the written version of the code present in the image:

```verilog
// Flip-flop with scan and inverted output
module dff_sn_32(q, q_, ck, d, sc_sel, scan_in);
  output [31:0] q;
  output [31:0] q_;
  input ck;
  input [31:0] d;
  input sc_sel;
  input [31:0] scan_in;
  tri0 [31:0] scan_in;
  reg [31:0] q;
  assign q_ = ~q;
  always @(posedge ck) begin
    q <= sc_sel ? scan_in : d;
  end
endmodule // dff_sn_32
```

Please note that the code is a Verilog module defining a 32-bit flip-flop with scan and inverted output capabilities.","
// Flip-flop with scan and inverted output
module dff_sn_32(q, q_, ck, d, sc_sel, scan_in);
  output [31:0] q;
  output [31:0] q_;
  input ck;
  input [31:0] d;
  input sc_sel;
  input [31:0] scan_in;
  tri0 [31:0] scan_in;
  reg [31:0] q;
  assign q_ = ~q;
  always @(posedge ck) begin
    q <= sc_sel ? scan_in : d;
  end
endmodule // dff_sn_32
","""Example of Verilog code showing a flip-flop with scan and inverted output.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p226.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
always_ff @(posedge clk) a <= b;
```

This line of code is used to illustrate the concept of expression sampling in always_ff procedures within the context of Verilog hardware description language.","
always_ff @(posedge clk) a <= b;
","""Exploring the rules for function usage and sampling within Verilog checkers, including an example of nonblocking assignments and the `always_ff` procedure.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p231.jpg,True,"The image contains a snippet of Verilog code. Here is the code:

```verilog
initial
    $read_stimulus_ba(""readstim.pat"", input_vector);
```

This is an example usage of the `$read_stimulus_ba` system task within an `initial` block in Verilog.","
initial
    $read_stimulus_ba(""readstim.pat"", input_vector);
",A page from a technical document describing the synchronization of Verilog simulations using VPI callbacks with an example of Verilog code.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p109.jpg,True,"The image contains Verilog SVA (SystemVerilog Assertions) code related to functional coverage. Here is the code snippet from the image:

```verilog
c_mutex: cover property(p_mutex);
```

And a sample coverage log:

```
c_mutex, 12 attempts, 12 match, 0 vacuous match
```","
c_mutex: cover property(p_mutex);

x, 12 attempts, 12 match, 0 vacuous match
","Caption: ""Overview of using the 'cover' statement in SVA (SystemVerilog Assertions) for functional coverage tracking in hardware verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p557.jpg,True,"Here is the code excerpt from the image:

```c
s_acc_value obj_value;
acc_fetch_value(obj_handle, ""%g"", &obj_value);

p_acc_value obj_value;
obj_value = (p_acc_value)malloc(sizeof(s_acc_value));
acc_fetch_value(obj_handle, ""%g"", obj_value);

static s_acc_value obj_value = {accBinStringVal};
```","_value obj_value;
acc_fetch_value(obj_handle, ""%g"", &obj_value);

p_acc_value obj_value;
obj_value = (p_acc_value)malloc(sizeof(s_acc_value));
acc_fetch_value(obj_handle, ""%g"", obj_value);

static s_acc_value obj_value = {accBinStringVal};
","""Understanding the usage of acc_fetch_value() in Verilog PLI for various data types and storage methods.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p34.jpg,True,"The image contains a description of certain constructs in Verilog's SystemVerilog Assertions (SVA), along with some code examples. Here is the code provided in the image:

```verilog
sequence name_of_sequence;
    < test expression>;
endsequence

property name_of_property;
    < test expression >; or
    < complex sequence expressions >;
endproperty
```

The image also mentions these constructs without providing the actual syntax:

- `assert` would be used to check a property, but the syntax is not visible in the image.","
sequence name_of_sequence;
    < test expression>;
endsequence

property name_of_property;
    < test expression >; or
    < complex sequence expressions >;
endproperty
","""Introduction to SystemVerilog Assertions (SVA) and their basic building blocks""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p543.jpg,True,"Here is the code from the image:

```c
handle obj_h;
s_location source_location;

/* get handle for some object */
acc_fetch_location(&source_location, obj_h);
io_printf(""%s is defined in file %s at line %d.\n"",
          acc_fetch_fullname(obj_h),
          source_location->filename,
          source_location->line_no);
}
```","e obj_h;
s_location source_location;

/* get handle for some object */
acc_fetch_location(&source_location, obj_h);
io_printf(""%s is defined in file %s at line %d.\n"",
          acc_fetch_fullname(obj_h),
          source_location->filename,
          source_location->line_no);
}
","""Example of Verilog PLI code for fetching the file name and location of an object, and reading simulation invocation commands.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p554.jpg,True,"The image contains Verilog code. Here is the code written in the image:

```verilog
checker tx(quiet = 1'b0,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable,
    output bit tx_valid, tx_data
);
    default clocking @clk; endclocking
    default disable iff rst;

    let legal_txa(txa) = txa != txa_forbid;

    rand bit valid;
    rand bit data;
    rand bit packet_start;
    rand bit new_packet;
    rand packet_t packet;

    assign tx_valid = valid;
    assign tx_data = data;
    ...
endchecker : tx
```","
checker tx(quiet = 1'b0,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable,
    output bit tx_valid, tx_data
);
    default clocking @clk; endclocking
    default disable iff rst;

    let legal_txa(txa) = txa != txa_forbid;

    rand bit valid;
    rand bit data;
    rand bit packet_start;
    rand bit new_packet;
    rand packet_t packet;

    assign tx_valid = valid;
    assign tx_data = data;
    ...
endchecker : tx
",Verilog code for a packet generation interface checker and accompanying text related to serialization protocols and transmissions.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p232.jpg,True,"The image contains Verilog code defining an abstract finite state machine (FSM) model. Here is the code:

```verilog
typedef enum {IDLE1 = ..., IDLE2 = ..., ...} state_t;
typedef enum {AIDLE, ..., AERR} astate_t;

checker abstract_fsm(...,
                     event clk = $inferred_clock,
                     untyped rst = $inferred_disable,
                     output astate_t astate); // abstract state
default clocking
    @clk;
endclocking
always_ff @(clk) begin
    if (rst) astate <= AIDLE;
    case (astate)
        AIDLE: astate <= ...;
        ...
        default: astate <= AERR;
    endcase
end
endchecker : abstract_fsm
```

This code snippet shows the use of a `checker` to implement an abstract FSM with states and transitions, along with the `default clocking` block for specifying the clock signal, reset behavior, and the state transition logic within an `always_ff` block.","
typedef enum {IDLE1 = ..., IDLE2 = ..., ...} state_t;
typedef enum {AIDLE, ..., AERR} astate_t;

checker abstract_fsm(...,
                     event clk = $inferred_clock,
                     untyped rst = $inferred_disable,
                     output astate_t astate); // abstract state
default clocking
    @clk;
endclocking
always_ff @(clk) begin
    if (rst) astate <= AIDLE;
    case (astate)
        AIDLE: astate <= ...;
        ...
        default: astate <= AERR;
    endcase
end
endchecker : abstract_fsm
","""Verilog code snippet demonstrating an abstract finite state machine (FSM) checker with enumerated states and a clocked process""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p287.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
property pr1;
  @(posedge clk) req |-> ##2 gnt;
endproperty

reqGnt: assert property (pr1) $display($stime,, ""\t\t %m PASS""); else $display($stime,, ""\t\t %m FAIL"");
```

This piece of code is an example of a property declaration using SystemVerilog assertions (SVA). The `property` defines a sequential property named `pr1` that captures a behavior where a signal `req` should be followed by a signal `gnt` after exactly two clock cycles on the positive edge of `clk`. The `assert` statement named `reqGnt` checks the property `pr1` and displays either ""PASS"" or ""FAIL"" accordingly based on whether the property is satisfied or not.","
property pr1;
  @(posedge clk) req |-> ##2 gnt;
endproperty

reqGnt: assert property (pr1) $display($stime,, ""\t\t %m PASS""); else $display($stime,, ""\t\t %m FAIL"");
","""Explanation of the 'Vacuous Pass' in Verilog properties with an example code snippet.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p124.jpg,True,"```verilog
reg[HiBit:0] CountReg
...
always@(posedge ClockIn, posedge Reset)
    if (Reset=='b1)
        CountReg <= 'b0;
    else
        CountReg <= CountReg + '1'b1;
```

Please note that there is a typographical error in the code provided in the image. In Verilog, the correct syntax to specify a binary literal is with `1'b1`, not `'1'b1`. The same applies to `'b0` which should be written as `1'b0`. However, I've reproduced the code as it is shown in the image. A correct version of the last line would be:

```verilog
    CountReg <= CountReg + 1'b1;
```","
reg[HiBit:0] CountReg
...
always@(posedge ClockIn, posedge Reset)
    if (Reset=='b1)
        CountReg <= 'b0;
    else
        CountReg <= CountReg + '1'b1;


    CountReg <= CountReg + 1'b1;
","Excerpt from a textbook on Digital VLSI Design with Verilog, discussing the implementation of a simple behavioral up-counter in Verilog and the nuances of incrementing operations within the language.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p202.jpg,True,"```
// declarative assertion
// A start can only occur after a grant for an active request
assert always ({req[*1:4]}: {grant}; req) |-> {start}) @ (posedge clk);
```","larative assertion
// A start can only occur after a grant for an active request
assert always ({req[*1:4]}: {grant}; req) |-> {start}) @ (posedge clk);
","Caption: ""Illegal Sequence and PSL Assertion in Verilog: The image illustrates the improper timing of signals and the corresponding PSL (Property Specification Language) assertion code that ensures a 'start' signal occurs only after a 'grant' for an active 'req' within four clock cycles.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p337.jpg,True,"The image contains Verilog code. Here is the transcription of the code:

```verilog
end
end

// repetition relationship
if(rpt_me == 1 && c_rpt == 1 && rpt_edge ==
2'b11)
begin
    a7_c_rpt_rh: assert property(p7_c_rpt_rh);
    a7_cu_rpt_rh: assert property(p7_cu_rpt_rh);
end

if(rpt_me == 1 && c_rpt == 1 && rpt_edge ==
2'b10)
begin
    a7_c_rpt_rl: assert property(p7_c_rpt_rl);
    a7_cu_rpt_rl: assert property(p7_cu_rpt_rl);
end

if(rpt_me == 1 && c_rpt == 1 && rpt_edge ==
2'b01)
begin
    a7_c_rpt_fh: assert property(p7_c_rpt_fh);
    a7_cu_rpt_fh: assert property(p7_cu_rpt_fh);
end

if(rpt_me == 1 && c_rpt == 1 && rpt_edge ==
2'b00)
begin
    a7_c_rpt_fl: assert property(p7_c_rpt_fl);
    a7_cu_rpt_fl: assert property(p7_cu_rpt_fl);
end

end

// Config Parameters illegal values. If
// logical_op is asserted then timing cannot be
// asserted

property config_check1;
@(posedge clk)
    (logic_op == 1) |-> 
        (timing == 0);
endproperty
```

Please note that the code seems to be part of a larger context, and it features assertions used in formal verification to ensure that certain properties hold true within a Verilog design.","
end
end

// repetition relationship
if(rpt_me == 1 && c_rpt == 1 && rpt_edge ==
2'b11)
begin
    a7_c_rpt_rh: assert property(p7_c_rpt_rh);
    a7_cu_rpt_rh: assert property(p7_cu_rpt_rh);
end

if(rpt_me == 1 && c_rpt == 1 && rpt_edge ==
2'b10)
begin
    a7_c_rpt_rl: assert property(p7_c_rpt_rl);
    a7_cu_rpt_rl: assert property(p7_cu_rpt_rl);
end

if(rpt_me == 1 && c_rpt == 1 && rpt_edge ==
2'b01)
begin
    a7_c_rpt_fh: assert property(p7_c_rpt_fh);
    a7_cu_rpt_fh: assert property(p7_cu_rpt_fh);
end

if(rpt_me == 1 && c_rpt == 1 && rpt_edge ==
2'b00)
begin
    a7_c_rpt_fl: assert property(p7_c_rpt_fl);
    a7_cu_rpt_fl: assert property(p7_cu_rpt_fl);
end

end

// Config Parameters illegal values. If
// logical_op is asserted then timing cannot be
// asserted

property config_check1;
@(posedge clk)
    (logic_op == 1) |-> 
        (timing == 0);
endproperty
",A snippet of Verilog code showing assertions for checking properties based on repetition relationships and a property check for configuration parameters.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p250.jpg,True,"The image contains Verilog code specifying properties, assumptions, and assertions. Here is the transcribed code from the image:

```verilog
property pr1;
    @(posedge clk) reset_n |-> !req;
endproperty

property pr2;
    @(posedge clk) ack |=> !req;
endproperty

a1: assume property (@(posedge clk) req dist {0:=40, 1:=60} );
assume_req1 : assume property (pr1);
assume_req2 : assume property (pr2);

property pa1;
    @(posedge clk) !reset_n || !req |-> !ack;
endproperty

property pa2;
    @(posedge clk) ack |=> !ack;
endproperty

assert_ack1 : assert property (pa1);
assert_ack2 : assert property (pa2);
```

The code includes the definition of two properties `pr1` and `pr2`, which are used in two `assume` statements labeled `a1`, `assume_req1`, and `assume_req2`. Additionally, there are another two properties defined `pa1` and `pa2`, which are then used in two `assert` statements labeled `assert_ack1` and `assert_ack2`.","
property pr1;
    @(posedge clk) reset_n |-> !req;
endproperty

property pr2;
    @(posedge clk) ack |=> !req;
endproperty

a1: assume property (@(posedge clk) req dist {0:=40, 1:=60} );
assume_req1 : assume property (pr1);
assume_req2 : assume property (pr2);

property pa1;
    @(posedge clk) !reset_n || !req |-> !ack;
endproperty

property pa2;
    @(posedge clk) ack |=> !ack;
endproperty

assert_ack1 : assert property (pa1);
assert_ack2 : assert property (pa2);
","""Explanation of Verilog properties, assumptions, and assertions with code examples.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p323.jpg,True,"Here's the code from the image:

```verilog
// on a given clock edge, if the leading signal
// has a rising edge, then after ""min_time""
// cycles the trailing signal must have a
// rising edge

property p6_f_rr;
    @(posedge clk)
        $rose(a) |-> ##min_time $rose(b);
endproperty

// on a given clock edge, if the leading signal
// has a falling edge, then after ""min_time""
// cycles the trailing signal must have a
// rising edge

property p6_f_fr;
    @(posedge clk)
        $fell(a) |-> ##min_time $rose(b);
endproperty

// on a given clock edge, if the leading signal
// has a rising edge, then after ""min_time""
// cycles the trailing signal must have a
// falling edge

property p6_f_rf;
    @(posedge clk)
        $rose(a) |-> ##min_time $fell(b);
endproperty

a6_f_rr: assert property(p6_f_rr);
a6_f_ff: assert property(p6_f_ff);
a6_f_rf: assert property(p6_f_rf);
a6_f_fr: assert property(p6_f_fr);

// List of possible properties for variable timing relationship between two
// edge sensitive signals with non-overlapping implication is shown below.

// on a given clock edge, if the leading signal
// has a falling edge, then within ""min_time"" to
// ""max_time"" cycles the trailing signal must
// have a falling edge

property p6_w_ff;
    @(posedge clk)
```

The rest of the final property `p6_w_ff` is cut off at the bottom and not visible in the image provided.","
// on a given clock edge, if the leading signal
// has a rising edge, then after ""min_time""
// cycles the trailing signal must have a
// rising edge

property p6_f_rr;
    @(posedge clk)
        $rose(a) |-> ##min_time $rose(b);
endproperty

// on a given clock edge, if the leading signal
// has a falling edge, then after ""min_time""
// cycles the trailing signal must have a
// rising edge

property p6_f_fr;
    @(posedge clk)
        $fell(a) |-> ##min_time $rose(b);
endproperty

// on a given clock edge, if the leading signal
// has a rising edge, then after ""min_time""
// cycles the trailing signal must have a
// falling edge

property p6_f_rf;
    @(posedge clk)
        $rose(a) |-> ##min_time $fell(b);
endproperty

a6_f_rr: assert property(p6_f_rr);
a6_f_ff: assert property(p6_f_ff);
a6_f_rf: assert property(p6_f_rf);
a6_f_fr: assert property(p6_f_fr);

// List of possible properties for variable timing relationship between two
// edge sensitive signals with non-overlapping implication is shown below.

// on a given clock edge, if the leading signal
// has a falling edge, then within ""min_time"" to
// ""max_time"" cycles the trailing signal must
// have a falling edge

property p6_w_ff;
    @(posedge clk)
","""Verilog code illustrating time-dependent signal assertions for rising and falling edges""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p278.jpg,True,"The image contains Verilog code, and here it is:

```verilog
property pr1;
    @(posedge clk) req |-> ##2 gnt ;
endproperty

reqGnt: assert property (pr1) else failtask;

task failtask;
    $display($stime,,,""FROM failtask - 0"");

    @(posedge clk) $display($stime,,,""FROM failtask - 1"");
    @(posedge clk) $display($stime,,,""FROM failtask - 2"");
    @(posedge clk) $display($stime,,,""FROM failtask - 3"");
    @(posedge clk) $display($stime,,,""FROM failtask - 4"");
endtask
```

Please note that the double commas in the `$display` functions seem to be a formatting issue. They should be single commas, indicating separate arguments in the `$display` function calls.","
property pr1;
    @(posedge clk) req |-> ##2 gnt ;
endproperty

reqGnt: assert property (pr1) else failtask;

task failtask;
    $display($stime,,,""FROM failtask - 0"");

    @(posedge clk) $display($stime,,,""FROM failtask - 1"");
    @(posedge clk) $display($stime,,,""FROM failtask - 2"");
    @(posedge clk) $display($stime,,,""FROM failtask - 3"");
    @(posedge clk) $display($stime,,,""FROM failtask - 4"");
endtask
",Blocking action block in SystemVerilog for handling failed assertions with task delays,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p741.jpg,True,"There is no complete verbatim code in the image, but there are function prototypes and descriptions that relate to coding in the context of Verilog and possibly C, as part of a TF routine library. The function prototypes with brief descriptions are as follows:

```
void tf_subtract_long(low1, high1, low2, high2)
```
Parameters:
- `int *low1`: pointer to lower 32 bits of first operand.
- `int *high1`: pointer to upper 32 bits of first operand.
- `int low2`: lower 32 bits of second operand
- `int high2`: upper 32 bits of second operand

Description: Subtracts two 64-bit values and deposits the result back into the first operand.

```
void tf_synchronize()
void tf_isynchronize(tfinst)
```
Parameters:
- `char *tfinst`: pointer to an instance of a system task/function.

Description: Schedules a callback to the miscft application for the calling or specific instance of a system task/function. The callback occurs at the end of the current simulation time step with `reason_synch`. The PLI is allowed to schedule any additional events at the same or a later time step.

```
int tf_testpvc_flag(n)
int tf_itestpvc_flag(n, tfinst)
```
Parameters:
- `int n`: index number of a system task/function argument, or -1.
- `char *tfinst`: pointer to an instance of a system task/function.

Description: Returns the value of the saved PVC flag of argument n of the calling or specific instance of a system task/function to the saved PVC flag. If n is -1, a logical OR of all saved PVC flags is returned.

```
void tf_text(format, arg1,...,arg5)
```
Parameters:
- `char *format`: quoted character string of formatted message.
- `arg1...arg5`: arguments to formatted message string.

Description: Queues a formatted message into an error buffer to be printed when `tf_message()` is called.

```
int tf_type(n)
int tf_itype(n, tfinst)
```
Parameters:
- `int n`: index number of a system task/function argument.
- `char *tfinst`: pointer to an instance of a system task/function.

Description: Returns a constant representing the type of argument n of the calling or specific instance of a system task/function. The type is one of: `tf_nullparam`, `tf_string`, `tf_readonly`, `tf_readwrite`, `tf_readonlyreal`, `tf_readwritereal`. A read/write argument is a Verilog data type that is legal on the left-hand side of a procedural assignment (a register data type).","f_subtract_long(low1, high1, low2, high2)

f_synchronize()
void tf_isynchronize(tfinst)

_testpvc_flag(n)
int tf_itestpvc_flag(n, tfinst)

f_text(format, arg1,...,arg5)

_type(n)
int tf_itype(n, tfinst)
","""Documentation of IEEE 1364-1995 Verilog TF Routine Library Functions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p280.jpg,True,"The image contains Verilog code which is specifying a set of properties, often used in formal verification or for specifying assertions. Here is the code from the image:

```verilog
endproperty

property p_mcov3;
@(posedge clk)
  $s_MEM_READ ##1 (devseln[*5]) |=> $rose (irdyn);
endproperty

property p_mcov4;
@(posedge clk)
  $s_MEM_WRITE ##1 (devseln[*5]) |=> $rose (irdyn);
endproperty

property p_mcov5;
@(posedge clk)
  $s_CONFIG_READ ##1 (devseln[*5]) |=> $rose (irdyn);
endproperty

property p_mcov6;
@(posedge clk)
  $s_CONFIG_WRITE ##1 (devseln[*5]) |=> $rose (irdyn);
endproperty

c_mcov1: cover property(p_mcov1);
c_mcov2: cover property(p_mcov2);
c_mcov3: cover property(p_mcov3);
c_mcov4: cover property(p_mcov4);
c_mcov5: cover property(p_mcov5);
c_mcov6: cover property(p_mcov6);
```

The properties define sequences of events to occur on the positive clock edge. They use Verilog SystemVerilog assertions syntax, where `$s_MEM_READ`, `$s_MEM_WRITE`, `$s_CONFIG_READ`, and `$s_CONFIG_WRITE` are likely macros or functions defined elsewhere that match certain conditions. `##1` represents a one clock cycle delay, `[*5]` is a repetition operator, and `|=>` is the suffix implication operator, indicating that when the left-hand side is true, the right-hand side must be true at some time in the future. `irdyn` is a signal being checked for a rising edge with `$rose` after the specified sequence occurs.

Following the properties, there are 'cover' statements that are likely used for coverage analysis to track which specified properties have been activated during simulation or formal verification.","
endproperty

property p_mcov3;
@(posedge clk)
  $s_MEM_READ ##1 (devseln[*5]) |=> $rose (irdyn);
endproperty

property p_mcov4;
@(posedge clk)
  $s_MEM_WRITE ##1 (devseln[*5]) |=> $rose (irdyn);
endproperty

property p_mcov5;
@(posedge clk)
  $s_CONFIG_READ ##1 (devseln[*5]) |=> $rose (irdyn);
endproperty

property p_mcov6;
@(posedge clk)
  $s_CONFIG_WRITE ##1 (devseln[*5]) |=> $rose (irdyn);
endproperty

c_mcov1: cover property(p_mcov1);
c_mcov2: cover property(p_mcov2);
c_mcov3: cover property(p_mcov3);
c_mcov4: cover property(p_mcov4);
c_mcov5: cover property(p_mcov5);
c_mcov6: cover property(p_mcov6);
","""Verilog code depicting SystemVerilog properties and cover statements for transaction verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p495.jpg,True,"The image contains Verilog code. Here it is:

```verilog
module top;
  reg[15:0] CC;
  covergroup cg@(posedge clk);
    withC : coverpoint CC {
      bins bin_b1[] = {[0:20]} with (item % 2 == 0)
      ignore_bins gCC = CC with (item % 3 == 0)
    }
  endgroup
  // ...
endmodule
```

The text below the code explains that the `coverpoint ""CC""` will create certain bins based on the conditions provided, and the `ignore_bins ""gCC""` will ignore specific bins according to its condition.

The document also contains another piece of code:

```verilog
int x, y;
covergroup xyCG;
  x_c : coverpoint x;
  y_c : coverpoint y;
```

This second snippet is part of Example 7, which describes how `ignore_bins` can be used to weed out certain bins from a cross of two variables, `x` and `y`, in a coverage report.","
module top;
  reg[15:0] CC;
  covergroup cg@(posedge clk);
    withC : coverpoint CC {
      bins bin_b1[] = {[0:20]} with (item % 2 == 0)
      ignore_bins gCC = CC with (item % 3 == 0)
    }
  endgroup
  // ...
endmodule


int x, y;
covergroup xyCG;
  x_c : coverpoint x;
  y_c : coverpoint y;
",Caption: Example of implementing and utilizing ignore_bins in a Verilog covergroup to selectively ignore certain coverage bins based on specified conditions.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p219.jpg,True,"The image contains text with a command line instruction that can be associated with viewing code or function entries in a library, but there is no actual block of Verilog code presented. The command line is as follows:

```
nm libcvc2.a | grep entry | grep -v static | more
```

Here `libcvc2.a` is a hypothetical project-specific PLI library being examined.

The text also displays some function names as examples of how functions in the library might be named following a naming convention, but these are not Verilog code snippets either. The function name examples shown are:

```
cvc2c_report_percentage$2576ExternEntry$CODES
cvc2c_run_thread$2208ExternEntry$CODES
cvc2c_run_time_check$2208ExternEntry$CODES
cvc2c_run_tq1$208ExternEntry$CODES
cvc2c_stopwatch$480ExternEntry$CODES
...
```","cvc2.a | grep entry | grep -v static | more

report_percentage$2576ExternEntry$CODES
cvc2c_run_thread$2208ExternEntry$CODES
cvc2c_run_time_check$2208ExternEntry$CODES
cvc2c_run_tq1$208ExternEntry$CODES
cvc2c_stopwatch$480ExternEntry$CODES
...
","Page from a book discussing best practices for tool library function naming in Verilog, highlighting the importance of using consistent prefix naming to avoid name clashes.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p481.jpg,True,"The image contains Verilog code within a text passage. Here is the code transcribed from the image:

```verilog
covergroup control_reg_cg() with function sample(bit[4:0] control_reg);
    option.name = ""control_reg_cg"";

    CR1: coverpoint control_reg[0];
    CR2: coverpoint control_reg[1];
    CR3: coverpoint control_reg[2];
    CR4: coverpoint control_reg[3];
    CR5: coverpoint control_reg[4];

    multiCross: cross CR1, CR2, CR3, CR4, CR5;
endgroup;

covergroup multiCrossCG() with function sample(bit[5:0] CR1, bit[1:0] CR2);

    CR1_10: coverpoint CR1[1:0] {
        bins bits_5 = {0};
        bins bits_6 = {1};
        bins bits_7 = {2};
        bins bits_8 = {3};
    }

    CR1_2: coverpoint CR1[2] {
        bins stop_1 = {0};
        bins stop_2 = {1};
    }

    CR1_53: coverpoint CR1[5:3] {
        bins bits0246 = {'b0000, 'b0010, 'b0100, 'b0110};
        bins bits3 = {'b0111};
        bins bits1 = {'b0001};
        bins bits5 = {'b0101};
        bins bits7 = {'b0111};
    }
endgroup;
```

This code defines a covergroup for performing a cross coverage analysis in a testbench for a system being verified using Verilog. It samples certain bits of a control register and crosses different coverpoints to ensure the coverage of various combinations of those bits.","
covergroup control_reg_cg() with function sample(bit[4:0] control_reg);
    option.name = ""control_reg_cg"";

    CR1: coverpoint control_reg[0];
    CR2: coverpoint control_reg[1];
    CR3: coverpoint control_reg[2];
    CR4: coverpoint control_reg[3];
    CR5: coverpoint control_reg[4];

    multiCross: cross CR1, CR2, CR3, CR4, CR5;
endgroup;

covergroup multiCrossCG() with function sample(bit[5:0] CR1, bit[1:0] CR2);

    CR1_10: coverpoint CR1[1:0] {
        bins bits_5 = {0};
        bins bits_6 = {1};
        bins bits_7 = {2};
        bins bits_8 = {3};
    }

    CR1_2: coverpoint CR1[2] {
        bins stop_1 = {0};
        bins stop_2 = {1};
    }

    CR1_53: coverpoint CR1[5:3] {
        bins bits0246 = {'b0000, 'b0010, 'b0100, 'b0110};
        bins bits3 = {'b0111};
        bins bits1 = {'b0001};
        bins bits5 = {'b0101};
        bins bits7 = {'b0111};
    }
endgroup;
","""Example of Verilog 'cross' coverage using covergroups and coverpoints to ensure multiple conditions are covered in tests.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p294.jpg,True,"```verilog
first_match($fell (devseln) ##[1:16] $fell (trdyn));
endsequence

sequence s_tchk1l;
@(posedge clk)
s_tchk1la.ended ##[1:5] s_tchk1lb;
endsequence

property p_tchk1l;
@(posedge clk)
s_tchk1l.ended |-> ($isunknown (par) && $past ($isunknown(ad[31:0])));
endproperty

a_tchk1l: assert property(p_tchk1l);
c_tchk1l: cover property(p_tchk1l);
```","
first_match($fell (devseln) ##[1:16] $fell (trdyn));
endsequence

sequence s_tchk1l;
@(posedge clk)
s_tchk1la.ended ##[1:5] s_tchk1lb;
endsequence

property p_tchk1l;
@(posedge clk)
s_tchk1l.ended |-> ($isunknown (par) && $past ($isunknown(ad[31:0])));
endproperty

a_tchk1l: assert property(p_tchk1l);
c_tchk1l: cover property(p_tchk1l);
","""Example of Verilog code for PCI target check with sequence and property definitions and timing diagram.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p376.jpg,True,"The image contains excerpts from a document related to SystemVerilog Assertions, specifically about Sequence and Property AND. Here is the code that is visible in the image:

1. Examples of equivalence using sequences:
```
a[=1] ##1 b   same as   (1a [*0:$] ##1 a ##1 !a [*0:$] ##1 b)

a[=2] ##1 b   same as   (1a [*0:$] ##1 a ##1 !a [*0:$] ##1 a ##1 !a [*0:$] ##1 b)
```

2. Example C-5 Sequence and (non-matching length):
```
sequence_expr ::= sequence_expr and sequence_expr

s and t ::= ( (s ##1 1 [*0:$] ) intersect t)
            or (s intersect (t ##1 1 [*0:$])).
```

3. Examples of `and`ing sequences:
```
(a ##1 b) and ()         same as   ()

(a ##1 b) and (c ##1 d)  same as   (a && c ##1 b && d)

(a ##[1:2] b) and (c ##3 d)same as (a && c ##1 b ##1 1 ##1 d)
                                       or (a && c ##1 1 ##1 b ##1 d)
```

Please note that these snippets use shorthand notation and keywords specific to SystemVerilog Assertions. The text also includes relevant notes and explanations beside the code excerpts.","##1 b   same as   (1a [*0:$] ##1 a ##1 !a [*0:$] ##1 b)

a[=2] ##1 b   same as   (1a [*0:$] ##1 a ##1 !a [*0:$] ##1 a ##1 !a [*0:$] ##1 b)

ce_expr ::= sequence_expr and sequence_expr

s and t ::= ( (s ##1 1 [*0:$] ) intersect t)
            or (s intersect (t ##1 1 [*0:$])).

 b) and ()         same as   ()

(a ##1 b) and (c ##1 d)  same as   (a && c ##1 b && d)

(a ##[1:2] b) and (c ##3 d)same as (a && c ##1 b ##1 1 ##1 d)
                                       or (a && c ##1 1 ##1 b ##1 d)
","Caption: ""SystemVerilog Assertions Guide explaining the use of the AND operator in sequences and properties, with examples of non-matching sequence lengths.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p81.jpg,True,"The image contains snippets of code. Here they are:

```c
vpiHandle module_handle, net_handle, net_handle;

/* assume a net_handle has already been obtained */
module_handle = vpi_handle(vpiModule, net_handle);
```

```c
vpiHandle systf_handle;
systf_handle = vpi_handle(vpiSysTfCall, NULL);
```

The code snippets are written in C and interface with the VPI (Verilog Procedural Interface) routines, which are used for the interaction between Verilog simulations and C code.","ndle module_handle, net_handle, net_handle;

/* assume a net_handle has already been obtained */
module_handle = vpi_handle(vpiModule, net_handle);

ndle systf_handle;
systf_handle = vpi_handle(vpiSysTfCall, NULL);
","""Understanding Verilog Procedural Interface (VPI) handle acquisition in Verilog code""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p231.jpg,True,"The image contains Verilog code. Here is the text as it appears in the image:

```verilog
module b (p, w, x, y, z);
    input w, x, y, z;
    output p;
    wire p, r, s, w, x, y, z;
    b_c c1(r,w,x); // line 5
    b_c c2(s,y,z);
    b_d d0(p,r,s);
endmodule //b

module b_c(i, o, j);
    input i, j;
    output o;
endmodule //b_c

module b_d(o, i, j);
    input i, j;
    output o;
endmodule //b/d
```","
module b (p, w, x, y, z);
    input w, x, y, z;
    output p;
    wire p, r, s, w, x, y, z;
    b_c c1(r,w,x); // line 5
    b_c c2(s,y,z);
    b_d d0(p,r,s);
endmodule //b

module b_c(i, o, j);
    input i, j;
    output o;
endmodule //b_c

module b_d(o, i, j);
    input i, j;
    output o;
endmodule //b/d
","Caption: ""Exploring Implicit and Explicit Interconnection of Module Instances in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p184.jpg,True,"```verilog
int rand64_sizetf(char *user_data)
{
    return(64); /* $rand64 returns 64-bit values */
}
```","
int rand64_sizetf(char *user_data)
{
    return(64); /* $rand64 returns 64-bit values */
}
","""Documentation excerpt on Verilog PLI indicating types of system functions and setting function return sizes.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p193.jpg,True,"The image contains text, including some Verilog code syntax for sequence declarations. Here is the code extracted from the image:

```verilog
sequence identifier(sequence_port_list)
  {local_variable_declarations}
  sequence_expression;
endsequence [ : identifier ]
```

Please note that the text in the image also lists the optional parts of the syntax in square brackets and provides details about `sequence_port_list`, its components, and specific rules related to the use of ports and types in sequence declarations.","
sequence identifier(sequence_port_list)
  {local_variable_declarations}
  sequence_expression;
endsequence [ : identifier ]
","""Excerpt from a document detailing the syntax and definition of sequences in Verilog HDL.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p187.jpg,True,"The image contains code written in Verilog. Here's the code:

```verilog
a1: assert property (@(clk) int'(a++));
a2: assert property (@(clk) (int'(a+=1) == 1));
property p;
@(clk) int'(a = a + b);
endproperty
a3: assert property (p);
endmodule
```

```verilog
typedef bit[1:0] bt_t;
module m;
logic [7:0] a;
logic [7:0] [2:0] b;
logic c, d, e, f;
let lt1(bt_t x) = x;
let lt2(x) = x[1:0];
let lt3(x) = x;
assign c = lt2(a)[0];
assign d = lt1(a[4:0])[0];
assign e = lt2(a[4:0]);
assign f = lt3(a)[0];

// After substitution of let arguments and bodies into the assignments, we get the
// following equivalent code:
typedef bit[1:0] bt_t;
module m;
logic [7:0] a;
logic [7:0] [2:0] b;
logic c, d, e, f;
assign c = (a[1:0])[0];
assign d = (bt_t'(a[4:0]))[0];
assign e = ((a[4:0])[1:0]);
assign f = (a)[0];
```

These code snippets are demonstrating the use of `property` and `assert` statements, type definitions with `typedef`, logic declarations, `let` constructs, and assignment operations in Verilog/SystemVerilog.","
a1: assert property (@(clk) int'(a++));
a2: assert property (@(clk) (int'(a+=1) == 1));
property p;
@(clk) int'(a = a + b);
endproperty
a3: assert property (p);
endmodule


typedef bit[1:0] bt_t;
module m;
logic [7:0] a;
logic [7:0] [2:0] b;
logic c, d, e, f;
let lt1(bt_t x) = x;
let lt2(x) = x[1:0];
let lt3(x) = x;
assign c = lt2(a)[0];
assign d = lt1(a[4:0])[0];
assign e = lt2(a[4:0]);
assign f = lt3(a)[0];

// After substitution of let arguments and bodies into the assignments, we get the
// following equivalent code:
typedef bit[1:0] bt_t;
module m;
logic [7:0] a;
logic [7:0] [2:0] b;
logic c, d, e, f;
assign c = (a[1:0])[0];
assign d = (bt_t'(a[4:0]))[0];
assign e = ((a[4:0])[1:0]);
assign f = (a)[0];
",The image shows a section from a book or a document discussing the proper use of 'let' substitutions in SystemVerilog and highlights potential issues with bit and part selects over let instances.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p95.jpg,True,"The image contains a snippet of Verilog code, which reads as follows:

```verilog
begin
test = 3'b000;
#1 test = 3'b011;
#1 $show_all_nets(top);
#1 $show_all_nets(l1);
#1 $stop;
#1 $finish;
end
```

This code appears to be an example to demonstrate the use of `$show_all_nets` system tasks in Verilog, which are presumably used for simulation purposes to display information about the nets within the specified module(s).","
begin
test = 3'b000;
#1 test = 3'b011;
#1 $show_all_nets(top);
#1 $show_all_nets(l1);
#1 $stop;
#1 $finish;
end
","Caption: ""Example of Verilog code and simulation results using the show_all_nets PLI application, as discussed in a textbook chapter on VPI routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p243.jpg,True,"The image contains Verilog code, which is part of a SystemVerilog Assertion (SVA) used for checking the read cycle time of an SRAM. Here is the code written out:

```verilog
property p_tRC;
  @(posedge clk)
    (!sel_n[2] && we_n && !oe_n) |=> ($stable(addr));
endproperty

a_tRC: assert property(p_tRC);
c_tRC: cover property(p_tRC);
```","
property p_tRC;
  @(posedge clk)
    (!sel_n[2] && we_n && !oe_n) |=> ($stable(addr));
endproperty

a_tRC: assert property(p_tRC);
c_tRC: cover property(p_tRC);
",Page from a textbook showing a timing diagram for SRAM write pulse width and adjacent Verilog SystemVerilog Assertions (SVA) code snippet for a read cycle time property.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p330.jpg,True,"The image contains text discussing the ""nexttime"" property in Verilog, as well as an example of Verilog code related to it. Here's the Verilog code present in the image:

```
nexttime nexttime nexttime req;

nexttime [3] req;

property p1;
  @(posedge clk) nexttime req;
endproperty
```","me nexttime nexttime req;

nexttime [3] req;

property p1;
  @(posedge clk) nexttime req;
endproperty
","""Excerpt from a document explaining 'nexttime' properties in Verilog with usage examples.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p456.jpg,True,"The image does contain Verilog code. Here is the transcribed code from the image:

```verilog
group
    CPUMode1CP: coverpoint CPUMode[7:4];
    CPUMode2CP: coverpoint CPUMode[3:0];
endgroup

coverg covergInst = new();

always #10 clk=~clk;

initial
begin
    clk = 1'b0;
    for (int j=0; j<5; j++)
    begin
        @(negedge clk);
        CycleType = $random;
        CPUMode = $random;
        $display($stime,, "" CycleType = 0x%0h CPUMode = 0x%0h"", CycleType, CPUMode);
    end
    -> stimulusDone;
end

initial
begin
    @(stimulusDone); @(posedge clk);
    coverPercent = covergInst.get_coverage(); // get coverage on covergroup 'coverg'
    $display(""\nCoverage for covergroup 'coverg' = %f "", coverPercent);
    $finish(2);
end
```

Additionally, there is text included in the image that provides context and results for the code.","
group
    CPUMode1CP: coverpoint CPUMode[7:4];
    CPUMode2CP: coverpoint CPUMode[3:0];
endgroup

coverg covergInst = new();

always #10 clk=~clk;

initial
begin
    clk = 1'b0;
    for (int j=0; j<5; j++)
    begin
        @(negedge clk);
        CycleType = $random;
        CPUMode = $random;
        $display($stime,, "" CycleType = 0x%0h CPUMode = 0x%0h"", CycleType, CPUMode);
    end
    -> stimulusDone;
end

initial
begin
    @(stimulusDone); @(posedge clk);
    coverPercent = covergInst.get_coverage(); // get coverage on covergroup 'coverg'
    $display(""\nCoverage for covergroup 'coverg' = %f "", coverPercent);
    $finish(2);
end
","Caption: ""Example of a Verilog testbench with functional coverage and the simulation log showing the results of running the coverage test.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p160.jpg,True,"The image contains Verilog code snippets. Here is the code presented:

For Sample 4.42:
```verilog
a42: assert (arbif.cb.grant == 2'b01)
    grants_received++; // Another succesful result!
else
    $error(""Grant not asserted"");
```

For Sample 4.43:
```verilog
interface arb_if(input bit clk);
    logic [1:0] grant, request;
    bit rst;
    
    property request_2state;
        @(posedge clk) disable iff (rst)
        $isunknown(request) == 0; // Make sure no Z or X found
    endproperty
    
    assert_request_2state: assert property (request_2state);
    
endinterface
```

These snippets are from a section discussing assertions in Verilog, specifically custom error messages and concurrent assertions.","
a42: assert (arbif.cb.grant == 2'b01)
    grants_received++; // Another succesful result!
else
    $error(""Grant not asserted"");


interface arb_if(input bit clk);
    logic [1:0] grant, request;
    bit rst;
    
    property request_2state;
        @(posedge clk) disable iff (rst)
        $isunknown(request) == 0; // Make sure no Z or X found
    endproperty
    
    assert_request_2state: assert property (request_2state);
    
endinterface
","Caption: ""Example snippets of SystemVerilog code demonstrating how to create a custom error message using assertions and how to implement concurrent assertions for signal validation.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p178.jpg,True,"The image contains a snippet of Verilog code within an assert statement. Here is the code presented in the image:

```verilog
assert property (@(s_global_clock) s_eventually $changing_gclk(clk));
```","
assert property (@(s_global_clock) s_eventually $changing_gclk(clk));
","""Understanding Verilog Assertions and Runtime Violations Control Tasks""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p174.jpg,True,"The image contains the following Verilog code which is a sample of a simple transaction class:

```verilog
class Transaction;
  bit [31:0] addr, csm, data[8];

  function void display();
    $display(""Transaction: %h"", addr);
  endfunction : display

  function void calc_csm();
    csm = addr ^ data.xor;
  endfunction : calc_csm

endclass : Transaction
```","
class Transaction;
  bit [31:0] addr, csm, data[8];

  function void display();
    $display(""Transaction: %h"", addr);
  endfunction : display

  function void calc_csm();
    csm = addr ^ data.xor;
  endfunction : calc_csm

endclass : Transaction
","Caption: ""An excerpt from a textbook on SystemVerilog showcasing a simple transaction class with functions for display and checksum calculation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p324.jpg,True,"The image displays a page with text descriptions and two Verilog property specifications. Here are the property specifications written out as they appear in the image:

```verilog
property p2;
  s_eventually [2:5] $fell(frame_);
endproperty

property p3;
  frame_ |-> ##[2:5] $fell(frame_);
endproperty
```","
property p2;
  s_eventually [2:5] $fell(frame_);
endproperty

property p3;
  frame_ |-> ##[2:5] $fell(frame_);
endproperty
","Caption: Verilog code snippet demonstrating the use of sequences and properties in temporal assertions with ""$eventually"" and ""#[range]"" constructs.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p609.jpg,True,"The image displays code from a book. It contains snippets of a Verilog PLI (Programming Language Interface) extension using C language. I'll provide the visible code as requested:

```c
#include ""veriuser.h""     /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""     /* IEEE 1364 PLI ACC routine library */

/* prototype of consumer routine */
int PLIbook_MyMonitor_consumer();

/****************************************************************
* checktf routine
****************************************************************/
int PLIbook_MyMonitor_checktf()
{
    int i;
    static int validTypes[5] = {accNet, accNetBit, accReg, accRegBit, 0};

    acc_initialize();
    for (i=0; i<tf_nump(); i++) { 
        if ( !acc_object_in_typelist(acc_handle_targ(i), validTypes) )
            tf_error(""$my_monitor argument %d must be a net or reg"", i);
        else if (tf_sizep(i) != 1)
            tf_error(""$my_monitor argument %d must be scalar"", i);
    }
    acc_close();
    return(0);
}

/****************************************************************
* calltf routine
****************************************************************/
typedef struct PLIbook_MyMon_t {
    char signalName[256];  /* signal names--up to 255 characters */
    char lastValue[2];     /* scalar logic value stored as a string */
    PLIbook_MyMon_s, *PLIbook_MyMon_p;
} PLIbook_MyMon_s, *PLIbook_MyMon_p;

PLIbook_MyMonitor_calltf()
{
    handle signal;
    int i, numargs = tf_nump();

    /* allocate memory for an array of p_monitor structures */
    PLIbook_MyMon_p monArray; /* starting address for the array */
    monArray=(PLIbook_MyMon_p)malloc(numargs*(sizeof(PLIbook_MyMon_s)));

    acc_initialize();
    /* save name and current logic value of each signal */
    for (i=0; i<numargs; i++) {
        signal = acc_handle_targ(i+1);
        strcpy(monArray[i].signalName, acc_fetch_fullname(signal));
        strcpy(monArray[i].lastValue, acc_fetch_value(signal, ""%b"", null));
    /* add a VCL flag to each net--user_data is a pointer to saved info */
    acc_vcl_add(signal,
                PLIbook_MyMonitor_consumer,
                (char*)&monArray[i],
```

The code includes a `checktf` routine, which is used to check that arguments passed to a system task or function are of valid types, and `calltf` routine, which is presumably used to perform the action of the system task or function every simulation time that the PLI application is scheduled to execute. Please note that the code is wrapped in a book page, and there may be additional information that is cut off or out of view.","ude ""veriuser.h""     /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""     /* IEEE 1364 PLI ACC routine library */

/* prototype of consumer routine */
int PLIbook_MyMonitor_consumer();

/****************************************************************
* checktf routine
****************************************************************/
int PLIbook_MyMonitor_checktf()
{
    int i;
    static int validTypes[5] = {accNet, accNetBit, accReg, accRegBit, 0};

    acc_initialize();
    for (i=0; i<tf_nump(); i++) { 
        if ( !acc_object_in_typelist(acc_handle_targ(i), validTypes) )
            tf_error(""$my_monitor argument %d must be a net or reg"", i);
        else if (tf_sizep(i) != 1)
            tf_error(""$my_monitor argument %d must be scalar"", i);
    }
    acc_close();
    return(0);
}

/****************************************************************
* calltf routine
****************************************************************/
typedef struct PLIbook_MyMon_t {
    char signalName[256];  /* signal names--up to 255 characters */
    char lastValue[2];     /* scalar logic value stored as a string */
    PLIbook_MyMon_s, *PLIbook_MyMon_p;
} PLIbook_MyMon_s, *PLIbook_MyMon_p;

PLIbook_MyMonitor_calltf()
{
    handle signal;
    int i, numargs = tf_nump();

    /* allocate memory for an array of p_monitor structures */
    PLIbook_MyMon_p monArray; /* starting address for the array */
    monArray=(PLIbook_MyMon_p)malloc(numargs*(sizeof(PLIbook_MyMon_s)));

    acc_initialize();
    /* save name and current logic value of each signal */
    for (i=0; i<numargs; i++) {
        signal = acc_handle_targ(i+1);
        strcpy(monArray[i].signalName, acc_fetch_fullname(signal));
        strcpy(monArray[i].lastValue, acc_fetch_value(signal, ""%b"", null));
    /* add a VCL flag to each net--user_data is a pointer to saved info */
    acc_vcl_add(signal,
                PLIbook_MyMonitor_consumer,
                (char*)&monArray[i],
",Verilog PLI consumer routine example for signal monitoring using acc_vcl_add().,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p621.jpg,True,"```c
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */

#define ALU_A        1 /* system task arg 1 is ALU A input */
#define ALU_B        2 /* system task arg 2 is ALU B input */
#define ALU_OP       3 /* system task arg 3 is ALU opcode input */
#define ALU_RESULT   4 /* system task arg 4 is ALU result output */
#define ALU_EXCEPT   5 /* system task arg 5 is ALU exception output */
#define ALU_ERROR    6 /* system task arg 6 is ALU error output */

/**********************************************************************
 * VPI book simulation callback routine: Serves as an interface between
 * Verilog simulation and the C model. Called whenever the C model
 * inputs change value, passes the values to the C model, and puts
 * the C model outputs into simulation.
 **********************************************************************/
int PLIbook_ScientificALU_interface(p_vc_record vc_record)
{
    double a, b, result;
    int opcode, excep, err;
    handle instance_h, result_h, excep_h, err_h,
           a_h, b_h, opcode_h;
    s_setval_value value_s;
    s_setval_delay delay_s;
    s_acc_time time_s;
```","ude ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */

#define ALU_A        1 /* system task arg 1 is ALU A input */
#define ALU_B        2 /* system task arg 2 is ALU B input */
#define ALU_OP       3 /* system task arg 3 is ALU opcode input */
#define ALU_RESULT   4 /* system task arg 4 is ALU result output */
#define ALU_EXCEPT   5 /* system task arg 5 is ALU exception output */
#define ALU_ERROR    6 /* system task arg 6 is ALU error output */

/**********************************************************************
 * VPI book simulation callback routine: Serves as an interface between
 * Verilog simulation and the C model. Called whenever the C model
 * inputs change value, passes the values to the C model, and puts
 * the C model outputs into simulation.
 **********************************************************************/
int PLIbook_ScientificALU_interface(p_vc_record vc_record)
{
    double a, b, result;
    int opcode, excep, err;
    handle instance_h, result_h, excep_h, err_h,
           a_h, b_h, opcode_h;
    s_setval_value value_s;
    s_setval_delay delay_s;
    s_acc_time time_s;
","""Example of Verilog code interfacing with a C model using ACC routines for a scientific ALU.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p150.jpg,True,"The image contains a fragment of a document with some Verilog code. Here is the code from the image:

```verilog
a4: assert property (@(posedge clk) req |=> s_eventually gnt);
```

```verilog
initial
  a_always: assert property (@(posedge clk) ##[1$] s |-> p);
```

```verilog
initial
  a_once: assert property (@(posedge clk) s |-> p);
```","
a4: assert property (@(posedge clk) req |=> s_eventually gnt);


initial
  a_always: assert property (@(posedge clk) ##[1$] s |-> p);


initial
  a_once: assert property (@(posedge clk) s |-> p);
","Caption: ""Exploration of unbounded sequences in Verilog and understanding the correct usage of assertions in sequential property checking.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p147.jpg,True,"The image contains example Verilog code snippets. Here are the code excerpts from the image:

```verilog
`timescale 1ns/10ps
module A;
    ...
    nand #5.3 n1 (y, a, b);
    ...
endmodule

`timescale 1us/100ns
module B;
    ...
    nand #3.581 n1 (y, a, b);
    ...
endmodule
```","
`timescale 1ns/10ps
module A;
    ...
    nand #5.3 n1 (y, a, b);
    ...
endmodule

`timescale 1us/100ns
module B;
    ...
    nand #3.581 n1 (y, a, b);
    ...
endmodule
","""Explanation of Verilog time units and timescale directive with examples of code""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p148.jpg,True,"The image contains a snippet of Verilog code. Here is the written version of the code provided in the image:

```verilog
program automatic test_with_cb (arb_if.TEST arbif);

initial begin
    @arbif.cb;
    arbif.cb.request <= 2'b01;
    $display(""%0t: Drove req=01"", $time);
    repeat (2) @arbif.cb;
    if (arbif.cb.grant == 2'b01)
        $display(""%0t: Success: grant == 2'b01"", $time);
    else
        $display(""%0t: Error: grant != 2'b01"", $time);
end

endprogram : test_with_cb
```

This code is part of an example on how to test interfacing with a clocking block in Verilog. Make sure to observe the proper syntax and context when using this snippet, as some details might be specific to the example's full context.","
program automatic test_with_cb (arb_if.TEST arbif);

initial begin
    @arbif.cb;
    arbif.cb.request <= 2'b01;
    $display(""%0t: Drove req=01"", $time);
    repeat (2) @arbif.cb;
    if (arbif.cb.grant == 2'b01)
        $display(""%0t: Success: grant == 2'b01"", $time);
    else
        $display(""%0t: Error: grant != 2'b01"", $time);
end

endprogram : test_with_cb
","Caption: ""Example of a Verilog testbench program using synchronous interface signals, demonstrating correct signal prefixing with interface and clocking block names.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p56.jpg,True,"```verilog
always @(posedge clock)
begin
    result <= $pow(x,y);
    ...
end
```","
always @(posedge clock)
begin
    result <= $pow(x,y);
    ...
end
","Caption: ""Example of Verilog code using a PLI calltf routine with the $pow system function, from The Verilog PLI Handbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p144.jpg,True,"The image contains several snippets of Verilog code. Here they are transcribed below:

First snippet:
```verilog
bot ##1 (!bot && !eot) [*] ##1 eot.
```

Second snippet:
```verilog
initial a1: assert property ((@posedge clk) rst && !rdy [*] ##1 !rst && rdy);
```

Third snippet:
```verilog
initial a2: assert property ((@posedge clk) rst && !rdy until !rst && rdy);
```

Fourth snippet:
```verilog
initial assert property ((@posedge clk) !ready[*] ##1 !rst);
```","
bot ##1 (!bot && !eot) [*] ##1 eot.


initial a1: assert property ((@posedge clk) rst && !rdy [*] ##1 !rst && rdy);


initial a2: assert property ((@posedge clk) rst && !rdy until !rst && rdy);


initial assert property ((@posedge clk) !ready[*] ##1 !rst);
","Caption: ""Discussion and examples of sequence and assertion properties in Verilog for transaction modeling and reset behavior verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p153.jpg,True,"The image contains code related to Verilog and specifically to the Verilog Procedural Interface (VPI). Here is the Verilog code and C code found in the image:

```c
#define PLIbook_verbose 1 /* uncomment to list all invoke options */

#include <stdlib.h> /* ANSI C standard library */
#include <stdio.h> /* ANSI C standard input/output library */
#include <vpi_user.h> /* IEEE 1364 PLI VPI routine library */

/* prototypes of routines in this PLI application */
PLIbook_TestInvokeOptions_calltf(),
PLIbook_TestInvokeOptions_compiletf(),
PLIbook_GetOptions();
void PLIbook_ScanCommandFile();

/**********************************************************************
 * sizeof application
 *********************************************************************/
int PLIbook_TestInvokeOptions_sizetf(char *user_data)
{
    return(1); /* $test_invoke_options returns 1-bit value */
}

/**********************************************************************
 * calltf application
 *********************************************************************/
int PLIbook_TestInvokeOptions_calltf(char *user_data)
{
    vpiHandle systf_h, arg_itr, arg_h;
    char *option_name;
    s_vpi_value value_s;
    s_vpi_vlog_info sim_info;
    int found;
```

The code snippet is incomplete, but it provides declarations, includes, prototypes for VPI callback functions, and the beginning of the definition of two functions `PLIbook_TestInvokeOptions_sizetf` and `PLIbook_TestInvokeOptions_calltf`. The snippet also shows preprocessor directives, include statements for standard libraries and the VPI header, and structure definitions. It's meant to illustrate an example of using VPI in Verilog.","ne PLIbook_verbose 1 /* uncomment to list all invoke options */

#include <stdlib.h> /* ANSI C standard library */
#include <stdio.h> /* ANSI C standard input/output library */
#include <vpi_user.h> /* IEEE 1364 PLI VPI routine library */

/* prototypes of routines in this PLI application */
PLIbook_TestInvokeOptions_calltf(),
PLIbook_TestInvokeOptions_compiletf(),
PLIbook_GetOptions();
void PLIbook_ScanCommandFile();

/**********************************************************************
 * sizeof application
 *********************************************************************/
int PLIbook_TestInvokeOptions_sizetf(char *user_data)
{
    return(1); /* $test_invoke_options returns 1-bit value */
}

/**********************************************************************
 * calltf application
 *********************************************************************/
int PLIbook_TestInvokeOptions_calltf(char *user_data)
{
    vpiHandle systf_h, arg_itr, arg_h;
    char *option_name;
    s_vpi_value value_s;
    s_vpi_vlog_info sim_info;
    int found;
","Caption: ""Example of Verilog Procedural Interface (VPI) code from a technical document detailing how to test for user-defined invocation options.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p635.jpg,True,"The image contains a snippet of Verilog code along with comments, which are integrated into a discussion of interfacing to C models using ACC (Application Cooperative Control) routines. Here is the code from the image:

```verilog
s_setval_value value_s;
s_setval_delay delay_s;
s_acc_time     time_s;

acc_initialize();

/* Retrieve instance handle from VCL user_data field */
instance_h = (handle)vc_record->user_data;

/* Obtain handles to all task arguments */
enable_h = acc_handle_itfarg(ALU_ENABLE, instance_h);
a_h      = acc_handle_itfarg(ALU_A, instance_h);
b_h      = acc_handle_itfarg(ALU_B, instance_h);
opcode_h = acc_handle_itfarg(ALU_OP, instance_h);
result_h = acc_handle_itfarg(ALU_RESULT, instance_h);
excep_h = acc_handle_itfarg(ALU_EXCEPT, instance_h);
err_h    = acc_handle_itfarg(ALU_ERROR, instance_h);

/* Read current values of C model inputs from Verilog simulation */
value_s.format = accRealVal;
acc_fetch_value(a_h, ""%g"", &value_s);
a = value_s.value.real;

acc_fetch_value(b_h, ""%g"", &value_s);
b = value_s.value.real;

value_s.format = accIntVal;
acc_fetch_value(opcode_h, ""%g"", &value_s);
opcode = value_s.value.integer;

acc_fetch_value(enable_h, ""%g"", &value_s);
enable = value_s.value.integer;

/****** Call C model ******/
PLIbook_ScientificALU_C_model(enable, a, b, opcode,
                              &result, &excep, &err,
                              (char *)instance_h);

/* Write the C model outputs onto the Verilog signals */
delay_s.model     = accNoDelay;
delay_s.time      = time_s;
delay_s.time.type = accRealTime;
delay_s.time.real = 0.0;

value_s.format = accRealVal;
value_s.value.real = result;
acc_set_value(result_h, &value_s, &delay_s);

value_s.format = accIntVal;
value_s.value.integer = excep;
acc_set_value(excep_h, &value_s, &delay_s);

value_s.value.integer = err;
acc_set_value(err_h, &value_s, &delay_s);
```

This code is likely taken from a textbook or a technical manual that explains how to interface hardware description languages, like Verilog, with software models written in C using the ACC library functions.","
s_setval_value value_s;
s_setval_delay delay_s;
s_acc_time     time_s;

acc_initialize();

/* Retrieve instance handle from VCL user_data field */
instance_h = (handle)vc_record->user_data;

/* Obtain handles to all task arguments */
enable_h = acc_handle_itfarg(ALU_ENABLE, instance_h);
a_h      = acc_handle_itfarg(ALU_A, instance_h);
b_h      = acc_handle_itfarg(ALU_B, instance_h);
opcode_h = acc_handle_itfarg(ALU_OP, instance_h);
result_h = acc_handle_itfarg(ALU_RESULT, instance_h);
excep_h = acc_handle_itfarg(ALU_EXCEPT, instance_h);
err_h    = acc_handle_itfarg(ALU_ERROR, instance_h);

/* Read current values of C model inputs from Verilog simulation */
value_s.format = accRealVal;
acc_fetch_value(a_h, ""%g"", &value_s);
a = value_s.value.real;

acc_fetch_value(b_h, ""%g"", &value_s);
b = value_s.value.real;

value_s.format = accIntVal;
acc_fetch_value(opcode_h, ""%g"", &value_s);
opcode = value_s.value.integer;

acc_fetch_value(enable_h, ""%g"", &value_s);
enable = value_s.value.integer;

/****** Call C model ******/
PLIbook_ScientificALU_C_model(enable, a, b, opcode,
                              &result, &excep, &err,
                              (char *)instance_h);

/* Write the C model outputs onto the Verilog signals */
delay_s.model     = accNoDelay;
delay_s.time      = time_s;
delay_s.time.type = accRealTime;
delay_s.time.real = 0.0;

value_s.format = accRealVal;
value_s.value.real = result;
acc_set_value(result_h, &value_s, &delay_s);

value_s.format = accIntVal;
value_s.value.integer = excep;
acc_set_value(excep_h, &value_s, &delay_s);

value_s.value.integer = err;
acc_set_value(err_h, &value_s, &delay_s);
","""Example of Verilog code interfacing with a C model using ACC routines from a textbook on hardware description and verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p389.jpg,True,"The image contains a snippet of Verilog code example. Here it is:

```verilog
assign old_data = 
  $past(data, 2, !d_done, posedge clk);

always @ (posedge clk)
  if (!d_done)
    {old_data, prev_data} <= {prev_data, data};
```

This code is demonstrating the use of the `$past` system function in Verilog for assertion-based design purposes.","
assign old_data = 
  $past(data, 2, !d_done, posedge clk);

always @ (posedge clk)
  if (!d_done)
    {old_data, prev_data} <= {prev_data, data};
","Caption: ""Explanation of the $past system function in Verilog with an example of equivalent RTL code, and additional SystemVerilog operators for enhanced expression clarity.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p318.jpg,True,"Here is the Verilog code extracted from the image:

```verilog
property p(a, b, c)
    @(posedge clk) c |-> a ##1 b;
endproperty
assert property (p(req[*5], gnt, c));
```

The text also contains an example of a simulation log:

```
run 200
#     0 clk=0 c=0 req=0 gnt=0
#     5 clk=1 c=0 req=0 gnt=0
#    10 clk=0 c=1 req=1 gnt=0
```

This example is given in the context of explaining ""followed by"" properties in Verilog, with the ""#"" and ""##"" operators denoting overlapped and non-overlapped properties, respectively.","
property p(a, b, c)
    @(posedge clk) c |-> a ##1 b;
endproperty
assert property (p(req[*5], gnt, c));

0
#     0 clk=0 c=0 req=0 gnt=0
#     5 clk=1 c=0 req=0 gnt=0
#    10 clk=0 c=1 req=1 gnt=0
","""Explanation and example of Verilog 'followed by' properties #= and #- in system-level verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p144.jpg,True,"The image contains text and examples of Verilog code. Here are the Verilog code snippets present in the image:

Incorrectly indented code snippet:
```verilog
if (a > 5)
    if (a <= 10)
        $display (""'a' is between 5 and 10"");
else
    $display (""'a' is less than 5""); // GOTCHA! pairs with wrong if
```

Correctly associated by language rules but with wrong indentation:
```verilog
if (a > 5)
    if (a <= 10)
        $display (""'a' is between 5 and 10"");
    else
        $display (""'a' is greater than 10""); // CORRECT!
```

How to explicitly show association with `begin...end`:
```verilog
if (a > 5) begin
    if (a <= 10)
        $display (""'a' is between 5 and 10"");
end
else
    $display (""'a' is less than 5""); // CORRECT!
```

These code examples demonstrate the importance of properly associating `if...else` statements in Verilog and how to avoid the ""gotcha"" with correct indentation or using `begin...end` blocks.","
if (a > 5)
    if (a <= 10)
        $display (""'a' is between 5 and 10"");
else
    $display (""'a' is less than 5""); // GOTCHA! pairs with wrong if


if (a > 5)
    if (a <= 10)
        $display (""'a' is between 5 and 10"");
    else
        $display (""'a' is greater than 10""); // CORRECT!


if (a > 5) begin
    if (a <= 10)
        $display (""'a' is between 5 and 10"");
end
else
    $display (""'a' is less than 5""); // CORRECT!
","Caption: ""Understanding nested if...else blocks in Verilog and avoiding common pitfalls with proper code structuring and indentation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p520.jpg,True,"```verilog
// Wire delays are ""INTERCONNECT"":
(CELL
    (CELLTYPE ""Intro_Top"")
    (INSTANCE)
    (DELAY
        (ABSOLUTE
            (INTERCONNECT SRlatch01/U2/ZN U2/I (0.000:0.000:0.000) )...
            )
    )

// Instance internal delays are ""IOPATH"":
(CELL
    (CELLTYPE ""XOR2D1"")
    (INSTANCE OutputCombo01/U3)
    (DELAY
        (ABSOLUTE
            (COND A2 == 1'b0 (IOPATH A1 Z (0.073:0.076:0.076) (0.079:0.082:0.082)))
            )
    )
```","
// Wire delays are ""INTERCONNECT"":
(CELL
    (CELLTYPE ""Intro_Top"")
    (INSTANCE)
    (DELAY
        (ABSOLUTE
            (INTERCONNECT SRlatch01/U2/ZN U2/I (0.000:0.000:0.000) )...
            )
    )

// Instance internal delays are ""IOPATH"":
(CELL
    (CELLTYPE ""XOR2D1"")
    (INSTANCE OutputCombo01/U3)
    (DELAY
        (ABSOLUTE
            (COND A2 == 1'b0 (IOPATH A1 Z (0.073:0.076:0.076) (0.079:0.082:0.082)))
            )
    )
","Caption: ""Instructions for editing SDF (Standard Delay Format) files and understanding the impact of timing changes in Verilog simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p174.jpg,True,"Here is the Verilog code present in the image:

```verilog
// check to ensure reset & init is done
if ( !TOP.dv_coverage_enable) begin
  always @(posedge clk) begin
    if (reset_n == 1'b1 && q_full) begin
      $display(""COV_q_FULL @ %0t:%3m"", $time);
    end // end if (...q_full...)
  end // end always (...)
end // end if (!TOP...)
```

This code snippet is provided as part of an example in the context of using global enable to control functional coverage in Verilog design.","
// check to ensure reset & init is done
if ( !TOP.dv_coverage_enable) begin
  always @(posedge clk) begin
    if (reset_n == 1'b1 && q_full) begin
      $display(""COV_q_FULL @ %0t:%3m"", $time);
    end // end if (...q_full...)
  end // end always (...)
end // end if (!TOP...)
","This image shows a textbook excerpt discussing methods of simulation control and enabling functional coverage in Verilog, including a code example for controlling functional coverage using a global enable signal.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p70.jpg,True,"The image contains examples of Verilog code. Here's the code extracted from the image:

```verilog
logic [31:0] mem_array [0:1023]; // array of vectors
always @ ( /* WHAT GOES HERE? */ ) // want combinational logic
data = mem_array[addr];
```

```verilog
always @ (addr or mem_array ) // ERROR! illegal reference to array
data = mem_array[addr];
```

```verilog
always @ ( addr, mem_array[0], mem_array[1], mem_array[2], ... )
data = mem_array[addr];
```","
logic [31:0] mem_array [0:1023]; // array of vectors
always @ ( /* WHAT GOES HERE? */ ) // want combinational logic
data = mem_array[addr];


always @ (addr or mem_array ) // ERROR! illegal reference to array
data = mem_array[addr];


always @ ( addr, mem_array[0], mem_array[1], mem_array[2], ... )
data = mem_array[addr];
","Caption: ""Understanding the limitations of Verilog sensitivity lists when dealing with arrays in combinational logic circuits.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p303.jpg,True,"The image contains two segments of code that seem to be related to the pseudocode representation of threads in a concurrent program rather than actual Verilog code. Here are the transcriptions of both segments:

(a)
```
1a: a = 0; 
2a: lock(1k); 
3a: x = 1; 
4a: unlock(1k); 
5a: a = 4;
```

(b)
```
1b: z = 5; 
2b: lock(1k); 
3b: x = 2; 
4b: unlock(1k); 
5b: x = 6;
```

This pseudocode is used to demonstrate a situation where the threads T1(a) and T2(b) have unprotected and protected access to a shared variable `x`.","= 0; 
2a: lock(1k); 
3a: x = 1; 
4a: unlock(1k); 
5a: a = 4;

= 5; 
2b: lock(1k); 
3b: x = 2; 
4b: unlock(1k); 
5b: x = 6;
","""Figure 1: Example threads T1(a) and T2(b) demonstrating unprotected and protected access to a shared variable x in a concurrent program.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p178.jpg,True,"```verilog
interface bus_ifc;
...
logic [31:0] address;
...
endinterface

program monitor(bus_ifc.MONITOR bus);
initial begin
    @(posedge bus.cb.grant);
    if (bus.cb.command == READ) begin
        logic [31:0] addr = bus.cb.address; // GOTCHA! addr will be X
        $display(""Bus addr = %h"", addr);
        ...
    end
    end
endprogram

program sums;
    function void maxx(ref int a[]);
        int max = a[0];                            // local variable
        foreach (a[i])
            if (a[i] > max) max = a[i];
        $display(""Max value is %0d"", max);  // GOTCHA!
    endfunction
...
endprogram
```","
interface bus_ifc;
...
logic [31:0] address;
...
endinterface

program monitor(bus_ifc.MONITOR bus);
initial begin
    @(posedge bus.cb.grant);
    if (bus.cb.command == READ) begin
        logic [31:0] addr = bus.cb.address; // GOTCHA! addr will be X
        $display(""Bus addr = %h"", addr);
        ...
    end
    end
endprogram

program sums;
    function void maxx(ref int a[]);
        int max = a[0];                            // local variable
        foreach (a[i])
            if (a[i] > max) max = a[i];
        $display(""Max value is %0d"", max);  // GOTCHA!
    endfunction
...
endprogram
","""Understanding Static versus Automatic Variable Initialization in Verilog/SystemVerilog with Example Code""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p391.jpg,True,"```verilog
property p_flow_analysis;
  byte 1_v;
  (
    (a[-1], 1_v = e)
    within
    b[-1]
  )
  #=#
  (
    (c == 1_v)
    until
    (
      (d == 1_v)
      and
      nexttime(c != 1_v)
    )
  );
endproperty
```","
property p_flow_analysis;
  byte 1_v;
  (
    (a[-1], 1_v = e)
    within
    b[-1]
  )
  #=#
  (
    (c == 1_v)
    until
    (
      (d == 1_v)
      and
      nexttime(c != 1_v)
    )
  );
endproperty
",An example of a SystemVerilog property illustrating local variable flow.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p386.jpg,True,"The image contains text and a table that discusses the mapping of 4-state values in Verilog into `aval/bval` pairs, but right at the bottom there is a snippet of code. Here is the code excerpt:

```verilog
reg [23:0] RAM [0:31]; //lsb is lowest bit, ascending addresses
```

This line of code declares a memory array in Verilog with 32 rows each containing a 24-bit register. The comment indicates that the least significant bit (lsb) is considered the lowest bit, and the addressing of the memory is in ascending order.","
reg [23:0] RAM [0:31]; //lsb is lowest bit, ascending addresses
","""Excerpt from The Verilog PLI Handbook explaining the mapping of 4-state logic values in Verilog into aval/bval pairs and illustrating the memory structure of Verilog arrays in both Verilog and PLI contexts.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p389.jpg,True,"```verilog
covergroup CovDst34;
  dst: coverpoint tr.dst {
    bins dst[] = {[0:9]};
  }
  kind: coverpoint tr.kind {
    bins zero = {0};              // 1 bin for kind=0
    bins lo   = {[1:3]};          // 1 bin for values 1:3
    bins hi[] = {[8:3]};          // 8 separate bins
    bins misc = default;          // 1 bin for rest, does not count
  }
  cross kind, dst {
    ignore_bins hi = binsof(dst) intersect {7};
    ignore_bins md = binsof(dst) intersect {0} &&
                     binsof(kind) intersect {[9:11]};
    ignore_bins lo = binsof(kind.lo);
  }
endgroup
```

The code above is a snippet of Verilog, which is used for hardware description and verification. This particular example shows a `covergroup` for cross coverage in verification environments, detailing how certain coverage bins can be excluded to reduce the number of bins being considered for coverage analysis.","
covergroup CovDst34;
  dst: coverpoint tr.dst {
    bins dst[] = {[0:9]};
  }
  kind: coverpoint tr.kind {
    bins zero = {0};              // 1 bin for kind=0
    bins lo   = {[1:3]};          // 1 bin for values 1:3
    bins hi[] = {[8:3]};          // 8 separate bins
    bins misc = default;          // 1 bin for rest, does not count
  }
  cross kind, dst {
    ignore_bins hi = binsof(dst) intersect {7};
    ignore_bins md = binsof(dst) intersect {0} &&
                     binsof(kind) intersect {[9:11]};
    ignore_bins lo = binsof(kind.lo);
  }
endgroup
","""Excerpt from a document on Cross Coverage in Verilog showing how to use 'ignore_bins' to exclude specific bins from coverage metrics.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p385.jpg,True,"```verilog
property p_data_and_parity_v2;
  dataType l_data;
  parityType l_parity;
  start ##1
  (
    (
      dataValid,
      l_data = data, l_parity = parity,
      $display(""time=%0d data=%h parity=%h"",
               $time,l_data,l_parity)
    )
    within complete[->1]
  )
  |-> parityOK(l_data, l_parity);
endproperty
```","
property p_data_and_parity_v2;
  dataType l_data;
  parityType l_parity;
  start ##1
  (
    (
      dataValid,
      l_data = data, l_parity = parity,
      $display(""time=%0d data=%h parity=%h"",
               $time,l_data,l_parity)
    )
    within complete[->1]
  )
  |-> parityOK(l_data, l_parity);
endproperty
","""Example of a Verilog property with local variable assignments and subroutine call within a sequence.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p392.jpg,True,"The image contains both text and code written in Verilog. Here is the code present in the image:

```verilog
/* print groups in word in reverse order so will match Verilog:
   the highest group number represents the left-most byte of a 
   Verilog word, the lowest group represents the right-most byte */
for (group_num = node_info->node_ngroups - 1; 
     group_num >= 0; 
     group_num--) {
  io_printf(""%c"", aval_ptr[group_num]);
}
io_printf(""\n\n"");
return;
```

```verilog
reg [23:0] RAM [0:3]; //Verilog memory array

assign vector = RAM[1]; //continuously read address 1

always @(posedge clock)
  vector = RAM[1]; //read address 1 each posedge of clock
```

The first snippet appears to be C code that interacts with a Verilog simulation (probably through the Verilog Programming Language Interface, PLI). The second snippet includes Verilog code snippets that show different ways of accessing elements of a memory array declared as `RAM`.","
/* print groups in word in reverse order so will match Verilog:
   the highest group number represents the left-most byte of a 
   Verilog word, the lowest group represents the right-most byte */
for (group_num = node_info->node_ngroups - 1; 
     group_num >= 0; 
     group_num--) {
  io_printf(""%c"", aval_ptr[group_num]);
}
io_printf(""\n\n"");
return;


reg [23:0] RAM [0:3]; //Verilog memory array

assign vector = RAM[1]; //continuously read address 1

always @(posedge clock)
  vector = RAM[1]; //read address 1 each posedge of clock
","""Details about modifying Verilog memory and variable arrays using PLI, with an example Verilog code snippet.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p379.jpg,True,"The image contains a page from a book or document, written in English, titled ""CHAPTER 11: Reading and Writing Values Using TF Routines."" It includes a code snippet for Verilog-PLI (Programming Language Interface) using C language, which interacts with the hardware description language Verilog.

Here is the code as it appears in the image:

```c
#include ""veriusert.h""          /* IEEE 1364 PLI TF routine library */
/******************************************************************/
/* checktf application                                           */
/******************************************************************/
int PLIbook_nodeinfoTest_checktf()
{
    if (tf_nump() != 1)
        tf_error(""Usage error: $nodeinfo_test(<signal>);"");
    return(0);
}

/******************************************************************/
/* calltf application                                            */
/******************************************************************/
int PLIbook_nodeinfoTest_calltf()
{
    s_tfnodeinfo node_info;
    int i;

    /* Get the nodeinfo structure for tfarg 1 */
    io_printf(""Reading Node Information\n"");
    if (!tf_nodeinfo(1, &node_info)) {
        tf_error(""Error getting tf_nodeinfo for tfarg 1"");
        return(0);
    }
    io_printf("" node_symbol is %s\n"",
              node_info.node_symbol ? node_info.node_symbol : ""No Symbol"");
    switch (node_info.node_type) {
        case TF_NULL_NODE:
            io_printf("" node_type = TF_NULL_NODE\n""); break;
        case TF_REG_NODE:
            io_printf("" node_type = TF_REG_NODE\n""); break;
        case TF_INTEGER_NODE:
            io_printf("" node_type = TF_INTEGER_NODE\n""); break;
        case TF_TIME_NODE:
            io_printf("" node_type = TF_TIME_NODE\n""); break;
        case TF_REAL_NODE:
            io_printf("" node_type = TF_REAL_NODE\n""); break;
        case TF_NETSCALAR_NODE:
            io_printf("" node_type = TF_NETSCALAR_NODE\n""); break;
        case TF_NETVECTOR_NODE:
            io_printf("" node_type = TF_NETVECTOR_NODE\n""); break;
        case TF_MEMORY_NODE:
            io_printf("" node_type = TF_MEMORY_NODE\n""); break;
        default:
            io_printf("" node_type = unknown (%d)\n\n"", node_info.node_type);
    }
    io_printf("" node_ngroups = %d\n"", node_info.node_ngroups);
    io_printf("" node_vec_size = %d\n"", node_info.node_vec_size);
    io_printf("" node_sign = %d\n"", node_info.node_sign);
    io_printf("" node_ms_index = %d\n"", node_info.node_ms_index);
}
```
The code demonstrates how to retrieve and display node information for a given argument in Verilog using the PLI TF routines. It includes functions to check the correctness of the arguments (`checktf`) and to implement the functionality (`calltf`).","ude ""veriusert.h""          /* IEEE 1364 PLI TF routine library */
/******************************************************************/
/* checktf application                                           */
/******************************************************************/
int PLIbook_nodeinfoTest_checktf()
{
    if (tf_nump() != 1)
        tf_error(""Usage error: $nodeinfo_test(<signal>);"");
    return(0);
}

/******************************************************************/
/* calltf application                                            */
/******************************************************************/
int PLIbook_nodeinfoTest_calltf()
{
    s_tfnodeinfo node_info;
    int i;

    /* Get the nodeinfo structure for tfarg 1 */
    io_printf(""Reading Node Information\n"");
    if (!tf_nodeinfo(1, &node_info)) {
        tf_error(""Error getting tf_nodeinfo for tfarg 1"");
        return(0);
    }
    io_printf("" node_symbol is %s\n"",
              node_info.node_symbol ? node_info.node_symbol : ""No Symbol"");
    switch (node_info.node_type) {
        case TF_NULL_NODE:
            io_printf("" node_type = TF_NULL_NODE\n""); break;
        case TF_REG_NODE:
            io_printf("" node_type = TF_REG_NODE\n""); break;
        case TF_INTEGER_NODE:
            io_printf("" node_type = TF_INTEGER_NODE\n""); break;
        case TF_TIME_NODE:
            io_printf("" node_type = TF_TIME_NODE\n""); break;
        case TF_REAL_NODE:
            io_printf("" node_type = TF_REAL_NODE\n""); break;
        case TF_NETSCALAR_NODE:
            io_printf("" node_type = TF_NETSCALAR_NODE\n""); break;
        case TF_NETVECTOR_NODE:
            io_printf("" node_type = TF_NETVECTOR_NODE\n""); break;
        case TF_MEMORY_NODE:
            io_printf("" node_type = TF_MEMORY_NODE\n""); break;
        default:
            io_printf("" node_type = unknown (%d)\n\n"", node_info.node_type);
    }
    io_printf("" node_ngroups = %d\n"", node_info.node_ngroups);
    io_printf("" node_vec_size = %d\n"", node_info.node_vec_size);
    io_printf("" node_sign = %d\n"", node_info.node_sign);
    io_printf("" node_ms_index = %d\n"", node_info.node_ms_index);
}
","""Verilog Task Function Example for Reading Node Information Using tf_nodeinfo() Routine""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p187.jpg,True,"The image contains the following Verilog code:

```verilog
program automatic test // verification program
(output logic [63:0] test_data,
 output logic reset_n,
 input logic [63:0] results,
 input logic test_clk
);
initial begin
 reset_n <= 0;
 @(posedge test_clk) reset_n <= 1;
 fork
  test1_task(...);
  test2_task(...);
 join
end
// NOTE: not necessary to call $finish
endprogram
``` 

The text also discusses the behavior and use of `program...endprogram` blocks in SystemVerilog, and how they interact with calling `$finish` for ending the simulation.","
program automatic test // verification program
(output logic [63:0] test_data,
 output logic reset_n,
 input logic [63:0] results,
 input logic test_clk
);
initial begin
 reset_n <= 0;
 @(posedge test_clk) reset_n <= 1;
 fork
  test1_task(...);
  test2_task(...);
 join
end
// NOTE: not necessary to call $finish
endprogram
","""Understanding SystemVerilog's program block and simulation end behavior""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p404.jpg,True,"The image contains Verilog code from two sample programs. Below is the code transcribed from the image:

Sample 10.5 Testbench using virtual interfaces

```verilog
program automatic test (Rx_if.TB Rx0, Rx1, Rx2, Rx3,
                        Tx_if.TB Tx0, Tx1, Tx2, Tx3,
                        output logic rst);

Driver drv[4];
Monitor mon[4];
Scoreboard scb[4];

virtual Rx_if.TB vRx[4] = '{Rx0, Rx1, Rx2, Rx3};
virtual Tx_if.TB vTx[4] = '{Tx0, Tx1, Tx2, Tx3};

initial begin
    foreach (scb[i]) begin
        scb[i] = new(i);
        drv[i] = new(scb[i].exp_mbx, i, vRx[i]);
        mon[i] = new(scb[i].rcv_mbx, i, vTx[i]);
    end
    ...
end
endprogram
```

Sample 10.6 Testbench using virtual interfaces

```verilog
program automatic test(Rx_if.TB Rx[4], Tx_if.TB Tx[4],
                       output logic rst);

...

initial begin
    foreach (scb[i]) begin
        scb[i] = new(i);
        drv[i] = new(scb[i].exp_mbx, i, Rx[i]);
        mon[i] = new(scb[i].rcv_mbx, i, Tx[i]);
    end
    ...
end
endprogram
```
The text in the image also discusses the use of virtual interfaces in Verilog testbenches and refers to other sample programs that are not included in the code samples provided.","
program automatic test (Rx_if.TB Rx0, Rx1, Rx2, Rx3,
                        Tx_if.TB Tx0, Tx1, Tx2, Tx3,
                        output logic rst);

Driver drv[4];
Monitor mon[4];
Scoreboard scb[4];

virtual Rx_if.TB vRx[4] = '{Rx0, Rx1, Rx2, Rx3};
virtual Tx_if.TB vTx[4] = '{Tx0, Tx1, Tx2, Tx3};

initial begin
    foreach (scb[i]) begin
        scb[i] = new(i);
        drv[i] = new(scb[i].exp_mbx, i, vRx[i]);
        mon[i] = new(scb[i].rcv_mbx, i, vTx[i]);
    end
    ...
end
endprogram


program automatic test(Rx_if.TB Rx[4], Tx_if.TB Tx[4],
                       output logic rst);

...

initial begin
    foreach (scb[i]) begin
        scb[i] = new(i);
        drv[i] = new(scb[i].exp_mbx, i, Rx[i]);
        mon[i] = new(scb[i].rcv_mbx, i, Tx[i]);
    end
    ...
end
endprogram
","""Verilog Code Samples Using Virtual Interfaces in a Testbench Context""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p408.jpg,True,"The image contains Verilog code regarding properties for checking recursive conditions. Here is the code from the image:

```verilog
property even_odd (property p, q);
  (nexttime[0] p) and nexttime even_odd(q, p);
endproperty
```

```verilog
property even_odd_stall(property p, q);
  if (stall) nexttime even_odd_stall(p, q)
  else
    p and nexttime even_odd_stall(q, p);
endproperty
```

```verilog
property p_fifo_data_check;
  dataType data;
  bit [0:`$clog2(MAX_OUTSTANDING)] numAhead;
  (start, data = dataIn, numAhead = outstanding) |-> 
  ##1 (numAhead > 0 ##0 complete[-1], numAhead--) [*]
  ##1 (numAhead == 0 ##0 complete[-1])
  |->
  dataOut == data;
endproperty
```

These properties are used to perform various checks in a recursive style in Verilog assertions.","
property even_odd (property p, q);
  (nexttime[0] p) and nexttime even_odd(q, p);
endproperty


property even_odd_stall(property p, q);
  if (stall) nexttime even_odd_stall(p, q)
  else
    p and nexttime even_odd_stall(q, p);
endproperty


property p_fifo_data_check;
  dataType data;
  bit [0:`$clog2(MAX_OUTSTANDING)] numAhead;
  (start, data = dataIn, numAhead = outstanding) |-> 
  ##1 (numAhead > 0 ##0 complete[-1], numAhead--) [*]
  ##1 (numAhead == 0 ##0 complete[-1])
  |->
  dataOut == data;
endproperty
","""Examples of Verilog properties for recursive even-odd cycle checks and FIFO data protocol validation with stalls.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p126.jpg,True,"The image contains code written in Verilog. Here is the code extracted from the image:

```verilog
logic [31:0] dBus;

property dAck2dBus;
  dAck |-> $fell(dBus);
endproperty
```

The text alongside this code describes a problem where `$fell`, a system function in Verilog, returns a boolean pass/fail based only on the sampled change of the least significant bit (LSB) of the signal. It states that this will yield incorrect pass results when looking for transitions of the entire `dBus` to `0`, as `$fell` detects a change only on the LSB of `dBus`.

The solution provided in the image uses another Verilog system function, `$past`, to compare the value of the entire `dBus`:

```verilog
logic [31:0] dBus;

property dAck2dBus;
  dAck |-> ($past(dBus) != 32'b0) && (dBus == 32'b0);
endproperty
```

Additional examples of `$past` in procedural blocks are shown:

```verilog
always @(posedge clk)
  iACK <= req & $past(gnt);
```

```verilog
always @(posedge clk)
  for (int i = 0; i < 4; i++)
    if (cond[i])
      reg1[i] <= $past(b[i]);
```

In the last example, `$past()` returns at each loop iteration the past value of the i-th bit of `b`.
","
logic [31:0] dBus;

property dAck2dBus;
  dAck |-> $fell(dBus);
endproperty


logic [31:0] dBus;

property dAck2dBus;
  dAck |-> ($past(dBus) != 32'b0) && (dBus == 32'b0);
endproperty


always @(posedge clk)
  iACK <= req & $past(gnt);


always @(posedge clk)
  for (int i = 0; i < 4; i++)
    if (cond[i])
      reg1[i] <= $past(b[i]);
","Caption: ""Use of $past in Verilog to ensure accurate detection of signal changes, overcoming the limitations of $fell function.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p410.jpg,True,"The image contains code from a technical document pertaining to Verilog hardware description language. Here is the code that is visible in the image:

```verilog
// Simple 8-bit counter with load and active-low reset
module counter(X_if.DUT xi);
  logic [7:0] count;
  assign xi.dout = count;

  always @(posedge xi.clk or negedge xi.reset_l)
  begin
    if (!xi.reset_l) count <= '0;
    else if (xi.load) count <= xi.din;
    else count <= count+1;
  end
endmodule

module top;
  parameter NUM_XI = 2; // Number of design instances

  // Clock generator
  bit clk;
  initial begin
    clk <= '0';
    forever #20 clk = ~clk;
  end

  // Instantiate NUM_XI interfaces
  X_if xi[NUM_XI] (clk);

  // Instantiate the testbench, passing the number of interfaces
  test #(.NUM_XI(NUM_XI)) tb();

  // Generate NUM_XI counter instances
  generate
  for (genvar i=0; i<NUM_XI; i++)
    begin : count_blk
      counter c (xi[i]);
    end
  endgenerate

endmodule : top
```

This code represents two Verilog module definitions, `counter` which configures a simple counter behavior and `top` which functions as a top-level module including a clock generator, instantiations of the `counter` modules, and handling of an array of interfaces. Some text underneath the code likely provides additional context or explanations related to the code, but that portion is not completely visible in the image.","
// Simple 8-bit counter with load and active-low reset
module counter(X_if.DUT xi);
  logic [7:0] count;
  assign xi.dout = count;

  always @(posedge xi.clk or negedge xi.reset_l)
  begin
    if (!xi.reset_l) count <= '0;
    else if (xi.load) count <= xi.din;
    else count <= count+1;
  end
endmodule

module top;
  parameter NUM_XI = 2; // Number of design instances

  // Clock generator
  bit clk;
  initial begin
    clk <= '0';
    forever #20 clk = ~clk;
  end

  // Instantiate NUM_XI interfaces
  X_if xi[NUM_XI] (clk);

  // Instantiate the testbench, passing the number of interfaces
  test #(.NUM_XI(NUM_XI)) tb();

  // Generate NUM_XI counter instances
  generate
  for (genvar i=0; i<NUM_XI; i++)
    begin : count_blk
      counter c (xi[i]);
    end
  endgenerate

endmodule : top
","""Verilog code examples showing a simple 8-bit counter with an interface and a top-level module instantiating multiple counters using generate statements.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p285.jpg,True,"Here is the Verilog code presented in the image:

```verilog
parameter NumInputs = 10;
parameter NumOutputs = 1<<NumInputs;
input[NumInputs-1:0] Address;
reg[NumOutputs-1:0] AdrEna;
//
always@(Address)
begin : Decode
    AdrEna = 'b0;
    #1 AdrEna[Address] = '1'b1;
end
```","
parameter NumInputs = 10;
parameter NumOutputs = 1<<NumInputs;
input[NumInputs-1:0] Address;
reg[NumOutputs-1:0] AdrEna;
//
always@(Address)
begin : Decode
    AdrEna = 'b0;
    #1 AdrEna[Address] = '1'b1;
end
","Caption: ""Exploring procedural implementation of a large decoder in Verilog and the concept of a fanout tree using 4-to-16 decoders for a 10-to-1024 decoding scheme.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p376.jpg,True,"The image contains two samples of Verilog code.

Here is the first sample:

```verilog
module mem(simple_bus sb) ;
    bit [7:0] data, addr;
    event write_event;

    cover property
        (@(posedge sb.clk) sb.write_ena==1)
        -> write_event;
endmodule
```

And here is the second sample:

```verilog
program automatic test(simple_bus sb) ;

    covergroup Write_cg @(root.top.m1.write_event);
        coverpoint $root.top.m1.data;
        coverpoint $root.top.m1.addr;
    endgroup

    Write_cg wcg;
    
    initial begin
        wcg = new();
        sb.write_ena <= 1;  // Apply stimulus here
        #10000ns $finish;
    end
endprogram
```","
module mem(simple_bus sb) ;
    bit [7:0] data, addr;
    event write_event;

    cover property
        (@(posedge sb.clk) sb.write_ena==1)
        -> write_event;
endmodule


program automatic test(simple_bus sb) ;

    covergroup Write_cg @(root.top.m1.write_event);
        coverpoint $root.top.m1.data;
        coverpoint $root.top.m1.addr;
    endgroup

    Write_cg wcg;
    
    initial begin
        wcg = new();
        sb.write_ena <= 1;  // Apply stimulus here
        #10000ns $finish;
    end
endprogram
","""Examples of SystemVerilog Assertions and Functional Coverage Code in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p193.jpg,True,"```
program test;
  ...
  Bustrans tr;

  initial begin
    tr = new;
    $assertoff();   // GOTCHA! disable all assertions during reset
    rst_n <= 0;

    assert (tr.randomize) else $display(""randomization failed"");

    #10 rst_n <= 0;
    $asserton();
    ...
  end
endprogram
```","m test;
  ...
  Bustrans tr;

  initial begin
    tr = new;
    $assertoff();   // GOTCHA! disable all assertions during reset
    rst_n <= 0;

    assert (tr.randomize) else $display(""randomization failed"");

    #10 rst_n <= 0;
    $asserton();
    ...
  end
endprogram
","""Gotcha in Verilog assertions: Using $assertoff during reset may disable randomization.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p345.jpg,True,"Here is the Verilog code from the image:

```verilog
if (tf_typep(2) != TF_READWRITE)
    tf_error(""$read_test_vector arg 2 must be a variable\n"");

reg [31:0] result;

always @(posedge clock)
    result = $pow(a, b);

tf_putp(0, c_value);
```

These snippets are part of an explanation on how to use TF routines for reading and writing values in Verilog PLI (Programming Language Interface) tasks or functions.","
if (tf_typep(2) != TF_READWRITE)
    tf_error(""$read_test_vector arg 2 must be a variable\n"");

reg [31:0] result;

always @(posedge clock)
    result = $pow(a, b);

tf_putp(0, c_value);
","""Understanding TF Routines for Reading and Writing in Verilog HDL""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p434.jpg,True,"The image contains the following Verilog code:

```verilog
typedef enum {
    INIT,
    IDLE,
    SEND,
    WAIT,
    RECEIVE,
    TO
} state_t;

checker cover_fsm(
    state_t state,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable
);
    covergroup cg_state @clk;
        coverpoint state iff (!rst);
            option.per_instance = 1;
    endgroup : cg_state
    cg_state cg = new();
endchecker : cover_fsm
```

This excerpt is discussing the concept of coverage groups in checkers for Verilog hardware description language. It provides an example Verilog checker that collects coverage information about finite state machine (FSM) states.","
typedef enum {
    INIT,
    IDLE,
    SEND,
    WAIT,
    RECEIVE,
    TO
} state_t;

checker cover_fsm(
    state_t state,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable
);
    covergroup cg_state @clk;
        coverpoint state iff (!rst);
            option.per_instance = 1;
    endgroup : cg_state
    cg_state cg = new();
endchecker : cover_fsm
","""Excerpt from a textbook on Verilog discussing the use of covergroups in checkers for FSM state coverage.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p438.jpg,True,"The image contains code. Here's the text of the Verilog code from the image:

```verilog
// Generate the syndrome array, which is used to compute HEC
function void UNI_cell::generate_syndrome();
bit [7:0] sndrm;
for (int i = 0; i < 256; i = i + 1 ) begin
    sndrm = i;
    repeat (8) begin
        if (sndrm[7] === 1'b1)
            sndrm = (sndrm << 1) ^ 8'h07;
        else
            sndrm = sndrm << 1;
    end
    syndrome[i] = sndrm;
end
syndrome_not_generated = 0;
endfunction : generate_syndrome

// Compute the HEC value for this object
function bit [7:0] UNI_cell::hec (input bit [31:0] hdr);
    hec = 8'h00;
    repeat (4) begin
        hec = syndrome[hec ^ hdr[31:24]];
        hdr = hdr << 8;
    end
    hec = hec ^ 8'h55;
endfunction : hec
```

This code appears to relate to functions for generating a syndrome array and computing the Header Error Control (HEC) value for an object of the class `UNI_cell` in a networking context.","
// Generate the syndrome array, which is used to compute HEC
function void UNI_cell::generate_syndrome();
bit [7:0] sndrm;
for (int i = 0; i < 256; i = i + 1 ) begin
    sndrm = i;
    repeat (8) begin
        if (sndrm[7] === 1'b1)
            sndrm = (sndrm << 1) ^ 8'h07;
        else
            sndrm = sndrm << 1;
    end
    syndrome[i] = sndrm;
end
syndrome_not_generated = 0;
endfunction : generate_syndrome

// Compute the HEC value for this object
function bit [7:0] UNI_cell::hec (input bit [31:0] hdr);
    hec = 8'h00;
    repeat (4) begin
        hec = syndrome[hec ^ hdr[31:24]];
        hdr = hdr << 8;
    end
    hec = hec ^ 8'h55;
endfunction : hec
",Verilog functions for generating syndrome array and computing HEC value as part of a digital communication system testbench.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p420.jpg,True,"The image contains Verilog code for a property used in formal verification. Here is the code:

```verilog
property ranged_always(int unsigned low, high, property p);
    ranged_always_recur(low, high, 0, p);
endproperty

property ranged_always_recur(
    int unsigned low, high,
    local input int unsigned cnt,
    property p
);
    if (cnt <= high)
    (
        (if (cnt >= low) p)
        and
        nexttime ranged_always_recur(low, high, cnt+1, p)
    );
endproperty
```

The text asks a question regarding the use of arguments in the recursive property: ""In this encoding, the arguments low and high of the recursive property are not local variables. How does this difference affect the meaning of the property?""","
property ranged_always(int unsigned low, high, property p);
    ranged_always_recur(low, high, 0, p);
endproperty

property ranged_always_recur(
    int unsigned low, high,
    local input int unsigned cnt,
    property p
);
    if (cnt <= high)
    (
        (if (cnt >= low) p)
        and
        nexttime ranged_always_recur(low, high, cnt+1, p)
    );
endproperty
","Excerpt from a text on recursive properties in system design, featuring an exercise with a Verilog property example for enforcing a ranged always clause.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p437.jpg,True,"```verilog
`timescale 1ns / 1ns
module scientific_alu(a_in, b_in, opcode, result_out, exception, error);

input [63:0] a_in, b_in;
input [3:0] opcode;
output [63:0] result_out;
output exception, error;

real a, b, result; // real variables used in this module
reg exception, error;

// convert real numbers to/from 64-bit vector port connections
assign result_out = $realtobits(result);
always @(a_in) a = $bitstoreal(a_in);
always @(b_in) b = $bitstoreal(b_in);

//call the PLI application which interfaces to the C model 
//using combinational logic input sensitivity
always @(a or b or opcode)
    $scientific_alu(a, b, opcode, result, exception, error);

endmodule
```","
`timescale 1ns / 1ns
module scientific_alu(a_in, b_in, opcode, result_out, exception, error);

input [63:0] a_in, b_in;
input [3:0] opcode;
output [63:0] result_out;
output exception, error;

real a, b, result; // real variables used in this module
reg exception, error;

// convert real numbers to/from 64-bit vector port connections
assign result_out = $realtobits(result);
always @(a_in) a = $bitstoreal(a_in);
always @(b_in) b = $bitstoreal(b_in);

//call the PLI application which interfaces to the C model 
//using combinational logic input sensitivity
always @(a or b or opcode)
    $scientific_alu(a, b, opcode, result, exception, error);

endmodule
","Caption: ""Verilog shell module for a scientific ALU, demonstrating the use of real number conversion and PLI interfacing in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p351.jpg,True,"The image contains Verilog code snippets. Here is the code transcribed from the image:

```verilog
if ( (arg_type != TF_READONLY)
    && (arg_type != TF_READONLYREAL)
    && (arg_type != TF_READWRITE)
    && (arg_type != TF_READWRITEREAL) ) {
    tf_error(""$pow arg 2 must be number, variable or net.\n"");
}
return(0);
}

/*****************************************************************
* Calltf application
*****************************************************************/
#include <math.h>
int PLIbook_realpow_calltf()
{
    double base, exp, result;
    int arg_type;

    arg_type = tf_typep(1);
    if ( (arg_type == TF_READONLYREAL)
        || (arg_type == TF_READWRITEREAL) )
        base = tf_getrealp(1);  /* read double value from tfarg 1 */
    else
        base = (double)tf_getp(1);  /* read int value from tfarg 1 */
    
    arg_type = tf_typep(2);
    if ( (arg_type == TF_READONLYREAL)
        || (arg_type == TF_READWRITEREAL) )
        exp = tf_getrealp(2);  /* read double value from tfarg 2 */
    else
        exp = (double)tf_getp(2);  /* read int value from tfarg 2 */

    result = pow(base, exp);
    
    tf_putrealp(0,result);  /* return result */

    return(0);
}
```

This code appears to be related to the use of TF routines for reading and writing values in Verilog simulations, likely using PLI (Programming Language Interface) to interface C functions with the simulator.","
if ( (arg_type != TF_READONLY)
    && (arg_type != TF_READONLYREAL)
    && (arg_type != TF_READWRITE)
    && (arg_type != TF_READWRITEREAL) ) {
    tf_error(""$pow arg 2 must be number, variable or net.\n"");
}
return(0);
}

/*****************************************************************
* Calltf application
*****************************************************************/
#include <math.h>
int PLIbook_realpow_calltf()
{
    double base, exp, result;
    int arg_type;

    arg_type = tf_typep(1);
    if ( (arg_type == TF_READONLYREAL)
        || (arg_type == TF_READWRITEREAL) )
        base = tf_getrealp(1);  /* read double value from tfarg 1 */
    else
        base = (double)tf_getp(1);  /* read int value from tfarg 1 */
    
    arg_type = tf_typep(2);
    if ( (arg_type == TF_READONLYREAL)
        || (arg_type == TF_READWRITEREAL) )
        exp = tf_getrealp(2);  /* read double value from tfarg 2 */
    else
        exp = (double)tf_getp(2);  /* read int value from tfarg 2 */

    result = pow(base, exp);
    
    tf_putrealp(0,result);  /* return result */

    return(0);
}
","The image shows an excerpt from a technical manual or book about Verilog, focusing on ""Chapter 11: Reading and Writing Values Using TF Routines"". The provided code includes examples of using these routines to manipulate and retrieve data in a Verilog simulation environment.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p346.jpg,True,"The image contains Verilog code snippets. The first code snippet is:

```verilog
// ...
always @(posedge clock) begin
  for (int i = 0; i < 7; i++) begin
    if (en[i] && cond) begin
      driver[i] <= ...;
      a1: assert property ({toggle |->
                            $stable(driver[i])});
    end
  end
end
always @(posedge clock)
  toggle <= reset ? 1'b0 : !toggle;
endmodule
```

The second code snippet is:

```verilog
checker mycheck(a, event clk);
  always_ff @clk begin
    a1: assert property (a);
  end
endchecker : mycheck
```

These code snippets are demonstrating assertions and clocking inference in procedural checker instances within Verilog HDL.","
// ...
always @(posedge clock) begin
  for (int i = 0; i < 7; i++) begin
    if (en[i] && cond) begin
      driver[i] <= ...;
      a1: assert property ({toggle |->
                            $stable(driver[i])});
    end
  end
end
always @(posedge clock)
  toggle <= reset ? 1'b0 : !toggle;
endmodule


checker mycheck(a, event clk);
  always_ff @clk begin
    a1: assert property (a);
  end
endchecker : mycheck
","Excerpt from a text discussing procedural instantiation of checkers in Verilog, with an emphasis on the independence of checker variable dependencies from loop control variables for legality and clock inference.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p421.jpg,True,"```verilog
/***********************************************************************
 * miscftf routine
 ***********************************************************************/
int PLIbook_MyMonitor2_miscftf(int user_data, int reason, int paramvc)
{
    int arg_num;
    
    if (reason == REASON_PARAMVC) {
        /* io_printf(""At %s: change detected on tfarg %d\n"",
           tf_strgettime(), paramvc); */
        tf_copyparamvc_flag(paramvc);
        tf_rosynchronize(); /* schedule a callback at end of time step */
    }
    
    if (reason == REASON_ROSYNCH) {
        io_printf(""Reached end of time step %s:\n"", tf_strgettime());
        if (tf_movepvc_flag(-1)) { /* only print if something changed */
            arg_num = 0;
            while (arg_num = tf_getpchange(arg_num)) {
                io_printf("" tfarg %d changed to %s\n"",
                          arg_num, tf_strgetp(arg_num, 'b'));
            }
        }
        io_printf(""\n"");
    }
    
    return(0);
}
/***********************************************************************
 * tf_write_save(blockptr, blocklength)
 * char *blockptr                  pointer to a block of memory.
 * int blocklength                 length of the block of memory in bytes.
 ***********************************************************************/
```

This snippet consists of an example Verilog PLI (Programming Language Interface) routine and the signature for another routine related to simulation save and restart callbacks in a Verilog simulation environment.","
/***********************************************************************
 * miscftf routine
 ***********************************************************************/
int PLIbook_MyMonitor2_miscftf(int user_data, int reason, int paramvc)
{
    int arg_num;
    
    if (reason == REASON_PARAMVC) {
        /* io_printf(""At %s: change detected on tfarg %d\n"",
           tf_strgettime(), paramvc); */
        tf_copyparamvc_flag(paramvc);
        tf_rosynchronize(); /* schedule a callback at end of time step */
    }
    
    if (reason == REASON_ROSYNCH) {
        io_printf(""Reached end of time step %s:\n"", tf_strgettime());
        if (tf_movepvc_flag(-1)) { /* only print if something changed */
            arg_num = 0;
            while (arg_num = tf_getpchange(arg_num)) {
                io_printf("" tfarg %d changed to %s\n"",
                          arg_num, tf_strgetp(arg_num, 'b'));
            }
        }
        io_printf(""\n"");
    }
    
    return(0);
}
/***********************************************************************
 * tf_write_save(blockptr, blocklength)
 * char *blockptr                  pointer to a block of memory.
 * int blocklength                 length of the block of memory in bytes.
 ***********************************************************************/
","This image shows a textbook page with a chapter titled ""Synchronizing to Verilog Simulations Using Miscft Routines"", alongside examples of Verilog PLI (Programming Language Interface) callback routines for simulation synchronization and save-restart mechanisms.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p436.jpg,True,"Here is the Verilog code from the image:

```verilog
always @(posedge clk) begin
    if (!en) ... some code...;
    else begin
        c: cover property(a ##1 b);
        ... some other code ...
    end
end
``` 

The ellipses (...) in the code represent portions of the code that are not shown or specified in the image.","
always @(posedge clk) begin
    if (!en) ... some code...;
    else begin
        c: cover property(a ##1 b);
        ... some other code ...
    end
end
","""Understanding Verilog's 'cover property' in the Context of Always Blocks and Sequential Logic""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p350.jpg,True,"This image presents several snippets of Verilog code. Here they are transcribed from the image:

```verilog
always @(posedge clk) begin
    if (load) begin
        sh[0] <= d_in;
        for(int i=1; i<D; i++)
            sh[i] <= sh[i-1];
        d_out <= sh[D-1];
    end
end
```

The rest of the image contains numbered items that appear to be exercises or questions relating to Verilog and its constructs, but there are no other code blocks to transcribe.","
always @(posedge clk) begin
    if (load) begin
        sh[0] <= d_in;
        for(int i=1; i<D; i++)
            sh[i] <= sh[i-1];
        d_out <= sh[D-1];
    end
end
",Verilog code snippet with procedural assertion examples and checker declaration.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p347.jpg,True,"There is code on the page. Here it is:

```c
int high_order_bits, low_order_bits;
low_order_bits = tf_getlongp(&high_order_bits, 4);
```

```c
double tf_getrealp(n)
int n
```

```c
double c_value;
c_value = tf_getrealp(3); /* read task/function arg #3 */
```

```c
if (tf_sizep(1) > 64)
    tf_warning(""%smy_app does not support vectors greater than 64 bits; some data may be lost\n"");
```","igh_order_bits, low_order_bits;
low_order_bits = tf_getlongp(&high_order_bits, 4);

e tf_getrealp(n)
int n

e c_value;
c_value = tf_getrealp(3); /* read task/function arg #3 */

f_sizep(1) > 64)
    tf_warning(""%smy_app does not support vectors greater than 64 bits; some data may be lost\n"");
",Chapter excerpt on interfacing Verilog with C using TF routines with code examples for reading logic and real values.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p348.jpg,True,"The image contains code examples from a text discussing Verilog and concepts related to Singleton and Static classes within the context of configuration databases and parameterized classes. Here are the code snippets as shown in the image:

Sample 8.41 Configuration database with global methods:
```verilog
int db_int[string];
function void db_int_set(input string name, input int value);
    db_int[name] = value;
endfunction

function void db_int_get(input string name, ref int value);
    value = db_int[name];
endfunction

function void db_int_print();
    foreach (db_int[i])
        $display(""db_int[%s] = %0d"", i, db_int[i]);
    endfunction
```

Sample 8.42 Configuration database with parameterized class:
```verilog
class config_db #(type T=int);
    T db[string];
    function void set(input string name, input T value);
        db[name] = value;
    endfunction

    function void get(input string name, ref T value);
        value = db[name];
    endfunction

    function void print();
        $display(""Configuration database %s"", $typename(T));
        foreach (db[i])
            $display(""db[%s] = %p"", i, db[i]);
        endfunction
endclass
```

The given code snippets show how to implement a simple configuration database in Verilog, which includes methods for setting and retrieving values as well as printing the contents of the database. The second example is a parameterized class that allows for different types of databases (e.g., integer, real) to be created by specifying a type parameter.","
int db_int[string];
function void db_int_set(input string name, input int value);
    db_int[name] = value;
endfunction

function void db_int_get(input string name, ref int value);
    value = db_int[name];
endfunction

function void db_int_print();
    foreach (db_int[i])
        $display(""db_int[%s] = %0d"", i, db_int[i]);
    endfunction


class config_db #(type T=int);
    T db[string];
    function void set(input string name, input T value);
        db[name] = value;
    endfunction

    function void get(input string name, ref T value);
        value = db[name];
    endfunction

    function void print();
        $display(""Configuration database %s"", $typename(T));
        foreach (db[i])
            $display(""db[%s] = %p"", i, db[i]);
        endfunction
endclass
","Caption: ""Verilog code excerpt showing a configuration database implemented with global methods and the introduction of a parametrized class version.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p344.jpg,True,"The image contains Verilog code. Here is the code written in the image:

```verilog
module m(input logic clock, logic [7:0] req, ack);
// ...
always @(posedge clock) begin
  for (int i = 0; i < 8; i++)
    if (i != 3) begin
      // ...
      a1: assert property(req[i] |=> ack[i]);
    end
end
endmodule : m
```

```verilog
always @(posedge clock) begin
  int i; //Static lifetime
  for (i = 0; i < 8; i++)
    // ...
  // resulting assertion
  assert property(req[$sampled(i)] |=> ack[$sampled(i)]);
```

```verilog
check mycheck(req['const'(i)], ack['const'(i)]);
```

```verilog
checker check(a, b, c, event clk = $inferred_clock);
default clocking @clk; endclocking
always_ff @clk begin
  a1: assert property(a);
  a2: assert property(b |=> c);
end
endchecker : check
```

```verilog
module m(input logic clock, ok, logic [7:0] req, ack);
// ...
always @(posedge clock) begin
  for (int i = 0; i < 8; i++)
    if (i != 3) begin
      // ...
      check mycheck(ok, req[i], ack[i]);
    end
end
endmodule : m
```

Please note that some of the code snippets are illustrative examples and may be partial. They demonstrate creating modules, looping structures, conditional logic, assertions, and checker instances in Verilog.","
module m(input logic clock, logic [7:0] req, ack);
// ...
always @(posedge clock) begin
  for (int i = 0; i < 8; i++)
    if (i != 3) begin
      // ...
      a1: assert property(req[i] |=> ack[i]);
    end
end
endmodule : m


always @(posedge clock) begin
  int i; //Static lifetime
  for (i = 0; i < 8; i++)
    // ...
  // resulting assertion
  assert property(req[$sampled(i)] |=> ack[$sampled(i)]);


check mycheck(req['const'(i)], ack['const'(i)]);


checker check(a, b, c, event clk = $inferred_clock);
default clocking @clk; endclocking
always_ff @clk begin
  a1: assert property(a);
  a2: assert property(b |=> c);
end
endchecker : check


module m(input logic clock, ok, logic [7:0] req, ack);
// ...
always @(posedge clock) begin
  for (int i = 0; i < 8; i++)
    if (i != 3) begin
      // ...
      check mycheck(ok, req[i], ack[i]);
    end
end
endmodule : m
","Caption: ""Excerpt from a document explaining the usage of procedural assertions in Verilog to create checker instances with attention to the lifetime of loop variables.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p353.jpg,True,"```c
char *i_str;
i_str = tf_strgetp(2, 'h'); /* read arg 2 as 4-state string */
io_printf(""Value of arg2 in PLI is %s\n"", i_str);
```

```c
int tf_strdelputp(n, length, format, value, delay, mode)
int n;
int length;
char *value;
int delay;
int mode;
```","*i_str;
i_str = tf_strgetp(2, 'h'); /* read arg 2 as 4-state string */
io_printf(""Value of arg2 in PLI is %s\n"", i_str);

f_strdelputp(n, length, format, value, delay, mode)
int n;
int length;
char *value;
int delay;
int mode;
","Caption: ""An excerpt discussing the use of TF routines in Verilog for reading and writing values, with a code example for the function tf_strgetp().""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p189.jpg,True,"```verilog
module dmux4 (o, sel, i0, i1, i2, i3);
parameter WIDTH = 1;
input [WIDTH-1:0] i0, i1, i2, i3; // input data
input [3:0] sel;                  // select signal
output [WIDTH-1:0] o;             // output

always @ (i0 or i1 or i2 or i3 or sel) begin
  casez (1'b1) // synopsys parallel_case
    sel[0] : o = i0;
    sel[1] : o = i1;
    sel[2] : o = i2;
    sel[3] : o = i3;
    default: $display (""No active select line on dmux4 %m"");
  endcase
end
endmodule
```","
module dmux4 (o, sel, i0, i1, i2, i3);
parameter WIDTH = 1;
input [WIDTH-1:0] i0, i1, i2, i3; // input data
input [3:0] sel;                  // select signal
output [WIDTH-1:0] o;             // output

always @ (i0 or i1 or i2 or i3 or sel) begin
  casez (1'b1) // synopsys parallel_case
    sel[0] : o = i0;
    sel[1] : o = i1;
    sel[2] : o = i2;
    sel[3] : o = i3;
    default: $display (""No active select line on dmux4 %m"");
  endcase
end
endmodule
",Verilog code example of a one-hot multiplexer and its motivation for use in RTL designs.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p422.jpg,True,"There is Verilog code present on the image. Here is the code written out for you:

```verilog
property p1(sequence s, property p);
    s |=> p;
endproperty

property p2(property q);
    q or p1(a, q or p1(b, p2(q)));
endproperty

property p3(sequence s);
    s |=> p2(weak(s)) and p3(s ##1 s);
endproperty
```

```verilog
property fib(int unsigned a, b, n, sig);
    if (n > 0)
        sig == a and nexttime fib(b, a+b, n-1, sig);
endproperty
```

And the questions related to this code are:

- Which properties are recursive and which are nonrecursive?
- Explain why the following code is illegal:
- How can the declaration be modified to make it legal, while preserving the intent of the original code?","
property p1(sequence s, property p);
    s |=> p;
endproperty

property p2(property q);
    q or p1(a, q or p1(b, p2(q)));
endproperty

property p3(sequence s);
    s |=> p2(weak(s)) and p3(s ##1 s);
endproperty


property fib(int unsigned a, b, n, sig);
    if (n > 0)
        sig == a and nexttime fib(b, a+b, n-1, sig);
endproperty
",Discussion on recursive properties in Verilog and an example of an illegal recursive property declaration that resembles the Fibonacci sequence.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p118.jpg,True,"The image contains multiple snippets of Verilog code. Here they are:

Snippet 1:
```
sequence sfell (a);
  $fell(a);
endsequence

property srose;
  @(posedge clk) sfell(req) |=> sfell(gnt);
endproperty
```

Snippet 2:
```
property checkWrData;
  @(posedge clk) (sfell(we_)) |-> not ($isunknown(wData));
endproperty
```

Snippet 3:
```
always @(posedge clk)
  CoreDone <= Cend & srose(iStreamDone);
```

Snippet 4:
```
always @(posedge clk)
  sysexp <= srose(intr1) & srose(intr2);
```

Snippet 5:
```
assign clearIntr = $fell(intr, @(posedge clk));
assign setIntr = $rose(intr, @(posedge clk));
```

These chunks of code appear to be illustrating various usages of event detection in signal transitions, particularly for detecting falling ($fell) and rising ($rose) edges of signals in digital systems using Verilog.","ce sfell (a);
  $fell(a);
endsequence

property srose;
  @(posedge clk) sfell(req) |=> sfell(gnt);
endproperty

ty checkWrData;
  @(posedge clk) (sfell(we_)) |-> not ($isunknown(wData));
endproperty

 @(posedge clk)
  CoreDone <= Cend & srose(iStreamDone);

 @(posedge clk)
  sysexp <= srose(intr1) & srose(intr2);

 clearIntr = $fell(intr, @(posedge clk));
assign setIntr = $rose(intr, @(posedge clk));
","""Verilog code examples illustrating the usage of s_event and $fell constructs for edge detection in digital signal processing.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p406.jpg,True,"```verilog
foreach (bytes[i]) begin
    while (Tx.cb.en != 0) // Wait if enable goes away
        @Tx.cb;
    bytes[i] = Tx.cb.data;
    @Tx.cb;
    Tx.cb.clav <= 0; // Deassert flow control
end

ac.byte_unpack(bytes);
$display(""%0d: Monitor::run(%0d) received cell vci=%h"",
         $time, stream_id, ac.vci);

// Send cell to scoreboard
rcv_mbx.put(ac);
endtask : receive_cell

endclass : Monitor

module top;
    bus_ifc bus();         // Instantiate the interface
    test t1(bus);          // Pass to test through port list
    dut d1(bus);           // Pass to DUT through port list
    ...
endmodule
```","
foreach (bytes[i]) begin
    while (Tx.cb.en != 0) // Wait if enable goes away
        @Tx.cb;
    bytes[i] = Tx.cb.data;
    @Tx.cb;
    Tx.cb.clav <= 0; // Deassert flow control
end

ac.byte_unpack(bytes);
$display(""%0d: Monitor::run(%0d) received cell vci=%h"",
         $time, stream_id, ac.vci);

// Send cell to scoreboard
rcv_mbx.put(ac);
endtask : receive_cell

endclass : Monitor

module top;
    bus_ifc bus();         // Instantiate the interface
    test t1(bus);          // Pass to test through port list
    dut d1(bus);           // Pass to DUT through port list
    ...
endmodule
","Caption: ""Excerpt from a technical document discussing the use of virtual interfaces in Verilog testbench environments, including example code for a monitoring class and advice for connecting the testbench to an interface in the port list.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p130.jpg,True,"The image contains Verilog code. Here is the text of the code present in the image:

```verilog
sequence Sab;
    a ##0 b;
endsequence

property ab;
    @(posedge clk) a |-> Sab;
endproperty
```

The code snippet defines a sequence `Sab` where signals `a` and `b` must be true at the same clock edge due to the `##0` delay operator. It also defines a property `ab` that checks the sequence `Sab` at the positive edge of the `clk` clock signal.","
sequence Sab;
    a ##0 b;
endsequence

property ab;
    @(posedge clk) a |-> Sab;
endproperty
","""Explanation and example of Verilog Clock Delay Operator ##0 for synchronous signal assertions in a sequence.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p360.jpg,True,"The image contains text and snippets of code related to Verilog, specifically class declarations and function definitions. Here is the code from the image:

Snippet from exercise 5:
```verilog
Binary b;
ExtBinary mc, mc2;

a. mc = new(15, 8);
   b = mc;

b. b = new(15, 8);
   mc = b;

c. mc = new(15, 8);
   b = mc;
   mc2 = b;

d. mc = new(15, 8);
   b = mc;
   if($cast(mc2, b))
      $display(""Success"");
   else
      $display(""Error: cannot assign"");
```

Snippet from exercise 6:
```verilog
virtual function Binary Binary::copy();
    copy = new(15,8);
    copy.val1 = val1;
    copy.val2 = val2;
endfunction
```

There are no complete Verilog classes or modules shown, just small snippets and fragments of Verilog code. The text around the code is discussing exercises related to class handling and method copying in Verilog.","
Binary b;
ExtBinary mc, mc2;

a. mc = new(15, 8);
   b = mc;

b. b = new(15, 8);
   mc = b;

c. mc = new(15, 8);
   b = mc;
   mc2 = b;

d. mc = new(15, 8);
   b = mc;
   if($cast(mc2, b))
      $display(""Success"");
   else
      $display(""Error: cannot assign"");


virtual function Binary Binary::copy();
    copy = new(15,8);
    copy.val1 = val1;
    copy.val2 = val2;
endfunction
","Caption: Verilog exercises related to class inheritance, object copying, and creating a data type comparator for simulation testbenches.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p185.jpg,True,"```verilog
module test (input int instance_id, input int thread_id);
initial begin
    #1;
    start_test(thread_id, instance_id); // one call to task
end
```
","
module test (input int instance_id, input int thread_id);
initial begin
    #1;
    start_test(thread_id, instance_id); // one call to task
end
","""Understanding Multi-threading Gotchas in Verilog: Issues with the `disable` Statement and a Solution with Static Tasks""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p378.jpg,True,"```verilog
sequence s2_v3(logic start, local input logic l_b[4]);
    logic l_a = 1'b0;
    dataType l_data;
    @(posedge clk)
    start ##1 ...
endsequence

property p1_v2(local input byte l_byte);
    byte l_byteMasked = l_byte & mask;
    ...
endproperty
```","
sequence s2_v3(logic start, local input logic l_b[4]);
    logic l_a = 1'b0;
    dataType l_data;
    @(posedge clk)
    start ##1 ...
endsequence

property p1_v2(local input byte l_byte);
    byte l_byteMasked = l_byte & mask;
    ...
endproperty
","""Explaining argument local variables and declaration assignments in Verilog with code examples""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p191.jpg,True,"The image contains an excerpt from a book or document discussing a topic related to Verilog, specifically about undetected randomization failures in SystemVerilog. There is indeed code on the page. The Verilog code presented as an example reads as follows:

```verilog
program automatic test;
    class Bad;
        const bit [7:0] a, b;
        constraint ab {a < b;
                       b < a;} // this constraint cannot be solved
    endclass

    initial begin
        Bad b = new;
        void'(b.randomize()); // GOTCHA! return from method ignored
    end
endprogram
```

This code mentions a common pitfall where the constraint cannot be solved due to contradicting conditions, and the return flag from randomize method is not checked, leading to potential undetected failures.","
program automatic test;
    class Bad;
        const bit [7:0] a, b;
        constraint ab {a < b;
                       b < a;} // this constraint cannot be solved
    endclass

    initial begin
        Bad b = new;
        void'(b.randomize()); // GOTCHA! return from method ignored
    end
endprogram
","Caption: Explanation of undetected randomization failures in Verilog, illustrating a common pitfall with the `.randomize` method and the importance of checking the success flag to prevent unnoticed errors in constraint solving.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p374.jpg,True,"The image contains two code snippets related to Verilog/SystemVerilog and UVM (Universal Verification Methodology). Here is the code:

**Sample 9.6 Test using functional coverage callback**
```verilog
program automatic test;
    Environment env;

    initial begin
        Driver_cbs_coverage dcc;

        env = new();
        env.gen_cfg();
        env.build();

        // Create and register the coverage callback
        dcc = new();
        env.drv.cbs.push_back(dcc); // Put into driver's Q

        env.run();
        env.wrap_up();
    end
endprogram
```

**Sample 9.7 Callback for functional coverage**
```verilog
class Driver_cbs_coverage extends Driver_cbs;
    covergroup CovDst7;
        ...
    endgroup

    virtual task post_tx(ref Transaction tr);
        CovDst7.sample(); // Sample coverage values
    endtask
endclass
``` 

This code is exemplifying a UVM test scenario with functional coverage callback techniques in a verification environment.","
program automatic test;
    Environment env;

    initial begin
        Driver_cbs_coverage dcc;

        env = new();
        env.gen_cfg();
        env.build();

        // Create and register the coverage callback
        dcc = new();
        env.drv.cbs.push_back(dcc); // Put into driver's Q

        env.run();
        env.wrap_up();
    end
endprogram


class Driver_cbs_coverage extends Driver_cbs;
    covergroup CovDst7;
        ...
    endgroup

    virtual task post_tx(ref Transaction tr);
        CovDst7.sample(); // Sample coverage values
    endtask
endclass
",Verilog Code Snippets Demonstrating Functional Coverage Callbacks and Covergroups in UVM.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p287.jpg,True,"```verilog
// Level 1 decode is trivial:
wire[3:0] DecodedL1;
wire[1:0] inL1;
wire[15:4] DecodedUnused; // Stub to suppress warnings.
//
// Get Address LSB's:
assign inL1 = Address[1:0];
// The level 1 decode, using verilog concatenation:
//              output[15:0]       input[3:0]
Dec_4_16 U1({DecodedUnused, DecodedL1}, {2'b0, inL1}); // Done!
...
```","
// Level 1 decode is trivial:
wire[3:0] DecodedL1;
wire[1:0] inL1;
wire[15:4] DecodedUnused; // Stub to suppress warnings.
//
// Get Address LSB's:
assign inL1 = Address[1:0];
// The level 1 decode, using verilog concatenation:
//              output[15:0]       input[3:0]
Dec_4_16 U1({DecodedUnused, DecodedL1}, {2'b0, inL1}); // Done!
...
","""Exploring Verilog code for a simple decoder with hints on using a generate construct for creating more complex decoders.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p412.jpg,True,"The image contains Verilog code. Here is the code from the image:

```verilog
Sample 10.20 Driver class using virtual interfaces

class Driver;
    virtual X_if.TB xi;
    int id;
    
    function new(input virtual X_if.TB xi, input int id);
        this.xi = xi;
        this.id = id;
    endfunction
    
    task reset();
        $display(""@%0t: Driver[%0d]: Start reset"", $time, id);
        // Reset the device
        xi.reset_l <= 1;
        xi.cb.load <= 0;
        xi.cb.din <= '0';
        @(xi.cb) xi.reset_l <= 0;
        @(xi.cb) xi.reset_l <= 1;
        $display(""@%0t:Driver[%0d]: End reset"", $time, id);
    endtask : reset
    
    task load_op();
        $display(""@%0t: Driver[%0d]: Start load"", $time, id);
        ##1 xi.cb.load <= 1;
        xi.cb.din <= id + 10;
        
        ##1 xi.cb.load <= 0;
        repeat (5) @(xi.cb);
        $display(""@%0t: Driver[%0d]: End load"", $time, id);
    endtask : load_op
endclass : Driver
```

```verilog
10.2.2 Using Typedefs with Virtual Interfaces

You can reduce the amount of typing, and ensure you always use the correct mod-
port by replacing “virtual X_if.TB” with a typedef, as shown in Sample 10.21
through 10.23, of the interface, testbench, and driver.

Sample 10.21 Interface with a typedef

interface X_if (input logic clk);
    //...
endinterface
typedef virtual X_if.TB vx_if;
```","
Sample 10.20 Driver class using virtual interfaces

class Driver;
    virtual X_if.TB xi;
    int id;
    
    function new(input virtual X_if.TB xi, input int id);
        this.xi = xi;
        this.id = id;
    endfunction
    
    task reset();
        $display(""@%0t: Driver[%0d]: Start reset"", $time, id);
        // Reset the device
        xi.reset_l <= 1;
        xi.cb.load <= 0;
        xi.cb.din <= '0';
        @(xi.cb) xi.reset_l <= 0;
        @(xi.cb) xi.reset_l <= 1;
        $display(""@%0t:Driver[%0d]: End reset"", $time, id);
    endtask : reset
    
    task load_op();
        $display(""@%0t: Driver[%0d]: Start load"", $time, id);
        ##1 xi.cb.load <= 1;
        xi.cb.din <= id + 10;
        
        ##1 xi.cb.load <= 0;
        repeat (5) @(xi.cb);
        $display(""@%0t: Driver[%0d]: End load"", $time, id);
    endtask : load_op
endclass : Driver


10.2.2 Using Typedefs with Virtual Interfaces

You can reduce the amount of typing, and ensure you always use the correct mod-
port by replacing “virtual X_if.TB” with a typedef, as shown in Sample 10.21
through 10.23, of the interface, testbench, and driver.

Sample 10.21 Interface with a typedef

interface X_if (input logic clk);
    //...
endinterface
typedef virtual X_if.TB vx_if;
","Caption: ""Example of a Verilog Driver class using virtual interfaces for connecting to multiple design configurations, showcasing tasks for resetting and loading operations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p124.jpg,True,"The image includes several snippets of Verilog code. Here they are transcribed:

Inefficient code example:
```verilog
a1: assert property (@(posedge clk) #1 check |-> $past(c) == $past(a) + $past(b));
```

Efficient code example:
```verilog
a2: assert property (@(posedge clk) #1 check |-> $past(c) == $past (a + b));
```

First `$past` application example:
```verilog
property rdPtrIncr;
    @(posedge clk) (state == cacheRead) |-> ($past(state) != cacheInv);
endproperty
```

Second `$past` application example:
```verilog
property dHoldCheck;
    @(posedge clk) (pipeStall && $past(State,2)==dataSend) |-> (State == dataHold);
endproperty
```

These code blocks are examples of SystemVerilog assertion properties incorporating the `$past` function, used to refer to past signal values in temporal assertions.","
a1: assert property (@(posedge clk) #1 check |-> $past(c) == $past(a) + $past(b));


a2: assert property (@(posedge clk) #1 check |-> $past(c) == $past (a + b));


property rdPtrIncr;
    @(posedge clk) (state == cacheRead) |-> ($past(state) != cacheInv);
endproperty


property dHoldCheck;
    @(posedge clk) (pipeStall && $past(State,2)==dataSend) |-> (State == dataHold);
endproperty
","""Examples of efficient Verilog assertions using the $past function""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p409.jpg,True,"```verilog
case REASON_FINISH:  /* miscft called at end of simulation */
  /* add code to close files and fee any allocated memory */
  break;

case REASON_SAVE:   /* miscft called end of simulation */
  /* add code to save PLI application data */
  break;

case REASON_RESTART: /* miscft called end of simulation */
  /* add code to retrieve saved PLI application data */
  break;

}
return(0);
}
```","
case REASON_FINISH:  /* miscft called at end of simulation */
  /* add code to close files and fee any allocated memory */
  break;

case REASON_SAVE:   /* miscft called end of simulation */
  /* add code to save PLI application data */
  break;

case REASON_RESTART: /* miscft called end of simulation */
  /* add code to retrieve saved PLI application data */
  break;

}
return(0);
}
","""Verilog MISCTF callback routines for simulation synchronization explained in a textbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p384.jpg,True,"The image contains Verilog code. Here is the text from the code parts of the image:

```verilog
reg [0:23] RAM [3:0]; //lsb is highest bit, descending addresses

reg [23:0] RAM [0:3]; //array with ascending address order

reg [23:0] RAM [3:0]; //array with descending address order
```","
reg [0:23] RAM [3:0]; //lsb is highest bit, descending addresses

reg [23:0] RAM [0:3]; //array with ascending address order

reg [23:0] RAM [3:0]; //array with descending address order
","""Understanding the Mapping of Verilog Array Addresses to C Array Addresses in Verilog Programming""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p393.jpg,True,"The image contains two blocks of Verilog code. Here they are transcribed:

First block (Fig. 16.15):
```verilog
sequence s_or_unambiguous;
  bit l_v = 1'b0;
  (
    (a[-:1], l_v = e)
    or
    b[-:1]
  )
  ##1 c = l_v;
endsequence
```

Second block (Fig. 16.16):
```verilog
sequence s_nested_ambiguity;
  bit l_v = 1'b0;
  (
    (a[-:1], l_v = e)
    or
    (
      (b1[-:1], l_v = f1)
      and
      (b2[-:1], l_v = f2)
    ) // SF5: l_v does not flow out
      // SF4: l_v does not flow out, becomes unassigned
  )
  ##1 c = l_v; // illegal reference to l_v
endsequence
```

These blocks of code are examples used in the context of the book or document to which the page belongs, discussing the referencing of local variables and the flow rules in Verilog SystemVerilog sequences.","
sequence s_or_unambiguous;
  bit l_v = 1'b0;
  (
    (a[-:1], l_v = e)
    or
    b[-:1]
  )
  ##1 c = l_v;
endsequence


sequence s_nested_ambiguity;
  bit l_v = 1'b0;
  (
    (a[-:1], l_v = e)
    or
    (
      (b1[-:1], l_v = f1)
      and
      (b2[-:1], l_v = f2)
    ) // SF5: l_v does not flow out
      // SF4: l_v does not flow out, becomes unassigned
  )
  ##1 c = l_v; // illegal reference to l_v
endsequence
","Caption: Examples of Verilog sequence constructions, illustrating the correct and incorrect assignment of local variables within nested structures to avoid unassigned references.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p390.jpg,True,"The image contains C code that is related to the Verilog Programming Language Interface (PLI). Here is the code that is visible in the image:

```c
if (reason != REASON_ENDOFCOMPILE)
return(0); /* exit now if this is not the start of simulation */

/* allocate memory for an s_tfexprinfo structure */
node_info = (p_tfnodeinfo)malloc(sizeof(s_tfnodeinfo));

/* Get the nodeinfo structure for tfarg 1 */
if (!tf_nodeinfo(1, node_info)) {
    tf_error(""Err: $dump_mem_?? could not get tf_nodeinfo for tfarg 1"");
    tf_dofinish(); /* about simulation */
    return(0);
}
else if (node_info->node_type != TF_MEMORY_NODE) {
    tf_error(""Err: $dump_mem_?? arg is not a memory word -- aborting"");
    tf_dofinish(); /* about simulation */
    return(0);
}
else
    tf_setworkarea((char *)node_info); /*put info pointer in workarea*/

return(0);

}

/********************************************************************/
/* calltf application */
/********************************************************************/
/* prototypes of functions invoked by the calltf routine */
void PLIbook_DumpMemHex();
void PLIbook_DumpMemAscii();

int PLIbook_DumpMem_calltf(int user_data)
{
    p_tfnodeinfo node_info;

    node_info = (p_tfnodeinfo)tf_getworkarea();

    io_printf(""\nwithin PLI:\n"");
    io_printf("" Memory array width=%d depth=%d ngroups=%d\n"",
              node_info->node_vec_size,
              node_info->node_mem_size,
              node_info->node_ngrups);

    if (user_data == HEX)    /* application called by $dump_mem_hex */
        PLIbook_DumpMemHex(node_info);
    else                      /* application called by $dump_mem_ascii */
        PLIbook_DumpMemAscii(node_info);

    return(0);
}
```

Please note that this code is provided as-is from the image, which may contain possible errors or typos due to recognition or transcription inaccuracies.","eason != REASON_ENDOFCOMPILE)
return(0); /* exit now if this is not the start of simulation */

/* allocate memory for an s_tfexprinfo structure */
node_info = (p_tfnodeinfo)malloc(sizeof(s_tfnodeinfo));

/* Get the nodeinfo structure for tfarg 1 */
if (!tf_nodeinfo(1, node_info)) {
    tf_error(""Err: $dump_mem_?? could not get tf_nodeinfo for tfarg 1"");
    tf_dofinish(); /* about simulation */
    return(0);
}
else if (node_info->node_type != TF_MEMORY_NODE) {
    tf_error(""Err: $dump_mem_?? arg is not a memory word -- aborting"");
    tf_dofinish(); /* about simulation */
    return(0);
}
else
    tf_setworkarea((char *)node_info); /*put info pointer in workarea*/

return(0);

}

/********************************************************************/
/* calltf application */
/********************************************************************/
/* prototypes of functions invoked by the calltf routine */
void PLIbook_DumpMemHex();
void PLIbook_DumpMemAscii();

int PLIbook_DumpMem_calltf(int user_data)
{
    p_tfnodeinfo node_info;

    node_info = (p_tfnodeinfo)tf_getworkarea();

    io_printf(""\nwithin PLI:\n"");
    io_printf("" Memory array width=%d depth=%d ngroups=%d\n"",
              node_info->node_vec_size,
              node_info->node_mem_size,
              node_info->node_ngrups);

    if (user_data == HEX)    /* application called by $dump_mem_hex */
        PLIbook_DumpMemHex(node_info);
    else                      /* application called by $dump_mem_ascii */
        PLIbook_DumpMemAscii(node_info);

    return(0);
}
","""Excerpt from The Verilog PLI Handbook covering memory allocation and function calls in Verilog Procedural Interface (PLI) code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p387.jpg,True,"The image contains Verilog code within the text. Here is the code provided:

```verilog
property p_ttype_check;
  ttype l_ttype;
  @(start && ({ttype == INV || ttype == PRG}, l_ttype = ttype))
    |=> start[->1:2]
    |-> ttype != l_ttype;
endproperty
```","
property p_ttype_check;
  ttype l_ttype;
  @(start && ({ttype == INV || ttype == PRG}, l_ttype = ttype))
    |=> start[->1:2]
    |-> ttype != l_ttype;
endproperty
","""Transaction type checking in SystemVerilog with waveform illustration and property example code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p536.jpg,True,"```verilog
logic [15:0] Xin, Yin, Zin;
...
always @(posedge clk)
    Xreg = {Xin, Yin};
```","
logic [15:0] Xin, Yin, Zin;
...
always @(posedge clk)
    Xreg = {Xin, Yin};
","""Overview of SystemVerilog features and an example of logic variable declaration.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p66.jpg,True,"The image contains Verilog code examples. Below is the code presented in the image:

```verilog
module top;
  wire [63:0] net_real; // net types used in netlist
  real_out ro (.net_real_out(net_real));
  real_in ri (.net_real_in(net_real));
endmodule

// How to avoid this Gotcha using SystemVerilog

module real_out (output real r); // output is real variable type
  ...
endmodule

module real_in (input var real r); // input is real variable type
  ...
endmodule

module top;
  real r; // variable types can be used in netlist
  real_out ro (.r);
  real_in ri (.r);
endmodule
```

The text in the image discusses a gotcha related to Verilog and SystemVerilog, where it mentions the use of floating point values in Verilog and the syntax for declaring ports of type `real` or `shortreal` in SystemVerilog. It also references a closely related gotcha covered in ""Gotcha 101"" on page 208 of the source text, which is not shown in the image.","
module top;
  wire [63:0] net_real; // net types used in netlist
  real_out ro (.net_real_out(net_real));
  real_in ri (.net_real_in(net_real));
endmodule

// How to avoid this Gotcha using SystemVerilog

module real_out (output real r); // output is real variable type
  ...
endmodule

module real_in (input var real r); // input is real variable type
  ...
endmodule

module top;
  real r; // variable types can be used in netlist
  real_out ro (.r);
  real_in ri (.r);
endmodule
","""Exploring gotchas in Verilog code declarations and addressing them using SystemVerilog for real number handling.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p146.jpg,True,"The image contains a snippet of Verilog code as follows:

```verilog
always @(posedge test_clock)
  if (data !== expected)  // OK, will detect bits with x or z
    $display(""Error on data: saw %h, expected %h"", data, expected);
```

This code snippet illustrates the use of Verilog identity operators (`!==` and `===`) for comparison in hardware description to take into account the four-state logic of Verilog, which include the values 0, 1, x (unknown), and z (high-impedance).","
always @(posedge test_clock)
  if (data !== expected)  // OK, will detect bits with x or z
    $display(""Error on data: saw %h, expected %h"", data, expected);
","Caption: ""Understanding 4-state logic in Verilog comparisons with identity operators.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p152.jpg,True,"The text includes a snippet of code written in a style that resembles Verilog or SystemVerilog. The code is:

```verilog
repeat(3) s_test.get(1); // request 3 keys, one at a time
```

This line is an example of how to request keys one at a time inside a `repeat` loop.","
repeat(3) s_test.get(1); // request 3 keys, one at a time
","""Discussion on semaphore key request handling in Verilog and a solution to avoid potential gotchas by requesting keys one at a time.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p72.jpg,True,"```verilog
logic [15:0] address, data;

always @(address, data) // OK: trigger on change to 
                        // any bit of vectors

...

always @(posedge address) // GOTCHA! triggering on 
                          // specific edge of vector

...

always @(posedge clock or negedge reset_n)

...

logic [3:0] data; // 4-bit vector

initial begin
    #1 data = 5; // data changed from 4'bxxxx to 4'b0101
    #1 data = 3; // data changed from 4'b0101 to 4'b0011
end
```","
logic [15:0] address, data;

always @(address, data) // OK: trigger on change to 
                        // any bit of vectors

...

always @(posedge address) // GOTCHA! triggering on 
                          // specific edge of vector

...

always @(posedge clock or negedge reset_n)

...

logic [3:0] data; // 4-bit vector

initial begin
    #1 data = 5; // data changed from 4'bxxxx to 4'b0101
    #1 data = 3; // data changed from 4'b0101 to 4'b0011
end
","""Common Pitfalls in Verilog Sensitivity Lists for Sequential Logic""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p176.jpg,True,"The image contains examples of PSL (Property Specification Language) and SystemVerilog code for defining functional coverage of a FIFO (First-In, First-Out) data structure. I will write down the code visible in the image:

PSL:
```verilog
default clock = (posedge clk);

sequence COVER_FIFO_FULL = {reset_n && rose(cnt==(FIFO_depth-1))};
cover COVER_FIFO_FULL;

sequence COVER_FIFO_FULL_M1 = {reset_n && rose(cnt==(FIFO_depth-2))};
cover COVER_FIFO_FULL_M1;

sequence COVER_FIFO_FULL_M2 = {reset_n && rose(cnt==(FIFO_depth-3))};
cover COVER_FIFO_FULL_M2;

sequence COVER_FIFO_EMPTY = {reset_n && rose(cnt == 0)};
cover COVER_FIFO_EMPTY;
```

SystemVerilog:
```verilog
`ifdef `COVERAGE_ON
always @(posedge clk) begin
    if (reset_n) begin
        // FIFO full
        myQfull: cover property ($rose(cnt == (FIFO_depth-1)));
        
        // FIFO full-1
        myQfullm1: cover property ($rose(cnt == (FIFO_depth-2)));
        
        // FIFO full-2
        myQfullm2: cover property ($rose(cnt == (FIFO_depth-3)));
        
        // FIFO empty
        myQempty: cover property ($rose(cnt == 0));
    end
end
`endif // COVERAGE_ON
```

The code provides examples of PSL and SystemVerilog constructs for capturing functional coverage situations in hardware design, such as when the FIFO is full, almost full, or empty. The use of `rose` in the conditions refers to capturing the rising edge event when the expression within it becomes true.","
default clock = (posedge clk);

sequence COVER_FIFO_FULL = {reset_n && rose(cnt==(FIFO_depth-1))};
cover COVER_FIFO_FULL;

sequence COVER_FIFO_FULL_M1 = {reset_n && rose(cnt==(FIFO_depth-2))};
cover COVER_FIFO_FULL_M1;

sequence COVER_FIFO_FULL_M2 = {reset_n && rose(cnt==(FIFO_depth-3))};
cover COVER_FIFO_FULL_M2;

sequence COVER_FIFO_EMPTY = {reset_n && rose(cnt == 0)};
cover COVER_FIFO_EMPTY;


`ifdef `COVERAGE_ON
always @(posedge clk) begin
    if (reset_n) begin
        // FIFO full
        myQfull: cover property ($rose(cnt == (FIFO_depth-1)));
        
        // FIFO full-1
        myQfullm1: cover property ($rose(cnt == (FIFO_depth-2)));
        
        // FIFO full-2
        myQfullm2: cover property ($rose(cnt == (FIFO_depth-3)));
        
        // FIFO empty
        myQempty: cover property ($rose(cnt == 0));
    end
end
`endif // COVERAGE_ON
","""Examples of PSL and SystemVerilog code for FIFO coverage models in functional coverage verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p40.jpg,True,"```verilog
module test;
  reg  a, b, ci;
  wire sum, co;
  ...
  initial
  begin
    ...
    $show_value(sum);
  end
endmodule
```","
module test;
  reg  a, b, ci;
  wire sum, co;
  ...
  initial
  begin
    ...
    $show_value(sum);
  end
endmodule
","Caption: ""An excerpt from The Verilog PLI Handbook showing an example of a Verilog module that integrates with C routines through PLI/VPI for verification and debugging purposes.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p468.jpg,True,"```verilog
class myC;
    int address;

    covergroup myCov (int high, int low) @(posedge clk);
        ac: coverpoint address {
            bins addrbin[ ] = {[high:low]};
        }
    endgroup

    function new (int ha, int hb);
        myCov = new (ha,hb);
    endfunction

endclass

initial begin
    myC myCInst = new(7,0);
end
```

```verilog
class multi;
    bit [3:0] m_1;
    int m_2;
    bit m_z, m_a;

    covergroup m_xCover @(m_z) coverpoint m_1; endgroup
    covergroup m_yCover @(m_a) coverpoint m_2; endgroup

    function new ( );
        m_xCover m_xCovInst = new;
        m_yCover m_yCovInst = new;
    endfunction

endclass : multi
```","
class myC;
    int address;

    covergroup myCov (int high, int low) @(posedge clk);
        ac: coverpoint address {
            bins addrbin[ ] = {[high:low]};
        }
    endgroup

    function new (int ha, int hb);
        myCov = new (ha,hb);
    endfunction

endclass

initial begin
    myC myCInst = new(7,0);
end


class multi;
    bit [3:0] m_1;
    int m_2;
    bit m_z, m_a;

    covergroup m_xCover @(m_z) coverpoint m_1; endgroup
    covergroup m_yCover @(m_a) coverpoint m_2; endgroup

    function new ( );
        m_xCover m_xCovInst = new;
        m_yCover m_yCovInst = new;
    endfunction

endclass : multi
","The image shows an excerpt from a textbook or document discussing functional coverage language features in Verilog, with examples of Verilog code for defining a class with a covergroup and utilizing constructor arguments to instantiate coverage bins.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p145.jpg,True,"```c
/**********************************************************************
 * Function to count primitives in local scope.
 **********************************************************************/
int PLIbook_count_local_prims(vpiHandle module_h)
{
    vpiHandle prim_itr, prim_h;
    int prims_in_mod = 0;

    prim_itr = vpi_iterate(vpiPrimitive, module_h);
    if (prim_itr != NULL)
    {
        while (prim_h = vpi_scan(prim_itr))
            prims_in_mod++;
    }
    return (prims_in_mod);
}
```","******************************************************************
 * Function to count primitives in local scope.
 **********************************************************************/
int PLIbook_count_local_prims(vpiHandle module_h)
{
    vpiHandle prim_itr, prim_h;
    int prims_in_mod = 0;

    prim_itr = vpi_iterate(vpiPrimitive, module_h);
    if (prim_itr != NULL)
    {
        while (prim_h = vpi_scan(prim_itr))
            prims_in_mod++;
    }
    return (prims_in_mod);
}
","""Verilog VPI Routine Library details: A function to count primitives in a local scope and information on writing messages to files.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p623.jpg,True,"This image contains two snippets of code written in C, which are part of a larger text discussing ""Interfacing to C Models Using ACC Routines."" Here are the code excerpts from the image:

First snippet:
```c
/***********************************************************************
 * calltf routine: Registers a callback to the C model interface
 * whenever any input to the C model changes value
 ***********************************************************************/
int PLIbook_ScientificALU_calltf()
{
    handle instance_h, a_h, b_h, opcode_h;
    
    acc_initialize();
    
    /* get handles for signals in task args which are C model inputs */
    a_h     = acc_handle_tfarg(ALU_A);
    b_h     = acc_handle_tfarg(ALU_B);
    opcode_h= acc_handle_tfarg(ALU_OP);
    
    /* get handles for this system task instance to pass to VCL app. */
    instance_h = acc_handle_tfinst();
    
    /* add VCL flags to all signals which are inputs to the C model */
    /* pass handle for task instance as the user_data value          */
    acc_vcl_add(a_h, PLIbook_ScientificALU_interface,
                (char*)instance_h, vcl_verilog_logic);
    acc_vcl_add(b_h, PLIbook_ScientificALU_interface,
                (char*)instance_h, vcl_verilog_logic);
    acc_vcl_add(opcode_h, PLIbook_ScientificALU_interface,
                (char*)instance_h, vcl_verilog_logic);

    acc_close();
    return(0);
}
```

Second snippet:
```c
/***********************************************************************
 * checktf routine: Verifies that scientific_alu() is used correctly.
 * Note: For simplicity, only limited data types are allowed for
 * task arguments. Could add checks to allow other data types.
 ***********************************************************************/
int PLIbook_ScientificALU_checktf()
{
    acc_initialize();
    
    if (tf_nump() != 6)
        tf_error(""%s:scientific_alu requires 6 arguments"");
    else
    {
        if (!acc_object_of_type(acc_handle_tfarg(ALU_A), accRealVal))
            tf_error(""%scientific_alu arg 4 must be a real variable\n"");
        if (!acc_object_of_type(acc_handle_tfarg(ALU_B), accRealVal))
            tf_error(""%scientific_alu arg 5 must be a real variable\n"");
        if (!acc_object_of_type(acc_handle_tfarg(ALU_OP), accWire))
            tf_error(""%scientific_alu arg 6 must be a net\n"");
        else if (acc_fetch_size(acc_handle_tfarg(ALU_OP)) != 4)
            tf_error(""%scientific_alu arg 6 must be a 4-bit vector\n"");
    }
}
```

These pieces of code appear to be part of a Verilog PLI (Programming Language Interface) example, where ""calltf"" and ""checktf"" routines are used to connect Verilog simulation with C functions.","*******************************************************************
 * calltf routine: Registers a callback to the C model interface
 * whenever any input to the C model changes value
 ***********************************************************************/
int PLIbook_ScientificALU_calltf()
{
    handle instance_h, a_h, b_h, opcode_h;
    
    acc_initialize();
    
    /* get handles for signals in task args which are C model inputs */
    a_h     = acc_handle_tfarg(ALU_A);
    b_h     = acc_handle_tfarg(ALU_B);
    opcode_h= acc_handle_tfarg(ALU_OP);
    
    /* get handles for this system task instance to pass to VCL app. */
    instance_h = acc_handle_tfinst();
    
    /* add VCL flags to all signals which are inputs to the C model */
    /* pass handle for task instance as the user_data value          */
    acc_vcl_add(a_h, PLIbook_ScientificALU_interface,
                (char*)instance_h, vcl_verilog_logic);
    acc_vcl_add(b_h, PLIbook_ScientificALU_interface,
                (char*)instance_h, vcl_verilog_logic);
    acc_vcl_add(opcode_h, PLIbook_ScientificALU_interface,
                (char*)instance_h, vcl_verilog_logic);

    acc_close();
    return(0);
}

*******************************************************************
 * checktf routine: Verifies that scientific_alu() is used correctly.
 * Note: For simplicity, only limited data types are allowed for
 * task arguments. Could add checks to allow other data types.
 ***********************************************************************/
int PLIbook_ScientificALU_checktf()
{
    acc_initialize();
    
    if (tf_nump() != 6)
        tf_error(""%s:scientific_alu requires 6 arguments"");
    else
    {
        if (!acc_object_of_type(acc_handle_tfarg(ALU_A), accRealVal))
            tf_error(""%scientific_alu arg 4 must be a real variable\n"");
        if (!acc_object_of_type(acc_handle_tfarg(ALU_B), accRealVal))
            tf_error(""%scientific_alu arg 5 must be a real variable\n"");
        if (!acc_object_of_type(acc_handle_tfarg(ALU_OP), accWire))
            tf_error(""%scientific_alu arg 6 must be a net\n"");
        else if (acc_fetch_size(acc_handle_tfarg(ALU_OP)) != 4)
            tf_error(""%scientific_alu arg 6 must be a 4-bit vector\n"");
    }
}
",Verilog ACC (Application Component Interface) routines for interfacing with C models.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p151.jpg,True,"Here is the code from the image:

```c
typedef struct t_vpi_vlog_info
{
    int argc;
    char **argv;
    char *product;
    char *version;
} s_vpi_vlog_info, *p_vpi_vlog_info;
```","ef struct t_vpi_vlog_info
{
    int argc;
    char **argv;
    char *product;
    char *version;
} s_vpi_vlog_info, *p_vpi_vlog_info;
","""Information on using the VPI routine library in Verilog for user-defined invocation options and the code structure for vpi_vlog_info.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p146.jpg,True,"The image contains Verilog code snippets used as examples in a document discussing sequences admitting empty matches. Here is the code:

```verilog
assert property(@(posedge clk) a[*1]);
```

```verilog
sequence a ##1 b[*0:2] ##1 c matches traces ac, abc, and abbc.
```

```verilog
Sequence a[*] ##0 b[*] is equivalent to a[*] ##0 b[+], since the sequence fusion does not admit an empty match.
```

```verilog
a[*] ##1 b[*] is not equivalent to a[+] ##1 b[+].
```

```verilog
a[*0] or a[+] ##1 1 |-> p, which is equivalent to (a[*0] ##1 1) or (a[+] ##1 1) |-> p
```","
assert property(@(posedge clk) a[*1]);


sequence a ##1 b[*0:2] ##1 c matches traces ac, abc, and abbc.


Sequence a[*] ##0 b[*] is equivalent to a[*] ##0 b[+], since the sequence fusion does not admit an empty match.


a[*] ##1 b[*] is not equivalent to a[+] ##1 b[+].


a[*0] or a[+] ##1 1 |-> p, which is equivalent to (a[*0] ##1 1) or (a[+] ##1 1) |-> p
",Understanding Sequences with Empty Matches in Verilog Assertions,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p54.jpg,True,"```verilog
always @(posedge clock)
    result <= $pow(x,y); // User-defined PLI routine
```
This is the Verilog code snippet from the image. It demonstrates the use of a user-defined PLI (Programming Language Interface) routine named `$pow`, which is presumably used to calculate `x` raised to the power of `y` and assign it to `result` on every positive edge of the `clock` signal.","
always @(posedge clock)
    result <= $pow(x,y); // User-defined PLI routine
","""Understanding PLI Routines in Verilog: Integration of Verilog and C for Custom Functionality""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p179.jpg,True,"The document in the image contains information about a function used in the Verilog Programming Interface (VPI). Here is the portion of the text representing the function signature and description of its parameters:

```c
vpiHandle vpi_put_value(object, value, time, flag)

vpiHandle     object      handle for an object which has a value property.
p_vpi_value   value       pointer to an application-allocated s_vpi_value structure containing value information.
p_vpi_time    time        pointer to an application-allocated s_vpi_time structure containing the propagation delay information.
int           flag        constant representing the delay mode.
```

The `s_vpi_value` structure that is pointed to in the `value` field must be allocated by the PLI application, and the fields within the structure set to the value to be written to the object.","ndle vpi_put_value(object, value, time, flag)

vpiHandle     object      handle for an object which has a value property.
p_vpi_value   value       pointer to an application-allocated s_vpi_value structure containing value information.
p_vpi_time    time        pointer to an application-allocated s_vpi_time structure containing the propagation delay information.
int           flag        constant representing the delay mode.
","""Explanation of how to write values to Verilog objects using VPI routines in C.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p162.jpg,True,"```verilog
module atm_router_ports(
// 4 x Level 1 Utopia ATM layer Rx Interfaces
Rx_clk_0, Rx_clk_1, Rx_clk_2, Rx_clk_3,
Rx_data_0, Rx_data_1, Rx_data_2, Rx_data_3,
Rx_soc_0, Rx_soc_1, Rx_soc_2, Rx_soc_3,
Rx_en_0, Rx_en_1, Rx_en_2, Rx_en_3,
Rx_clav_0, Rx_clav_1, Rx_clav_2, Rx_clav_3,

// 4 x Level 1 Utopia ATM layer Tx Interfaces
Tx_clk_0, Tx_clk_1, Tx_clk_2, Tx_clk_3,
Tx_data_0, Tx_data_1, Tx_data_2, Tx_data_3,
Tx_soc_0, Tx_soc_1, Tx_soc_2, Tx_soc_3,
Tx_en_0, Tx_en_1, Tx_en_2, Tx_en_3,
Tx_clav_0, Tx_clav_1, Tx_clav_2, Tx_clav_3,

// Miscellaneous control interfaces
rst, clk);

// 4 x Level 1 Utopia Rx Interfaces
output   Rx_clk_0, Rx_clk_1, Rx_clk_2, Rx_clk_3;
input [7:0] Rx_data_0, Rx_data_1, Rx_data_2, Rx_data_3;
input   Rx_soc_0, Rx_soc_1, Rx_soc_2, Rx_soc_3;
output  Rx_en_0, Rx_en_1, Rx_en_2, Rx_en_3;
input   Rx_clav_0, Rx_clav_1, Rx_clav_2, Rx_clav_3;

// 4 x Level 1 Utopia Tx Interfaces
output   Tx_clk_0, Tx_clk_1, Tx_clk_2, Tx_clk_3;
output [7:0] Tx_data_0, Tx_data_1, Tx_data_2, Tx_data_3;
output  Tx_soc_0, Tx_soc_1, Tx_soc_2, Tx_soc_3;
output  Tx_en_0, Tx_en_1, Tx_en_2, Tx_en_3;
input   Tx_clav_0, Tx_clav_1, Tx_clav_2, Tx_clav_3;

// Miscellaneous control interfaces
input rst, clk;

...
endmodule
```

This is the Verilog code extracted from the image, which appears to be the declaration of a Verilog module called `atm_router_ports` with various input and output ports defined. The code sample does not include the inner implementation of the module, as indicated by the ellipsis (`...`).","
module atm_router_ports(
// 4 x Level 1 Utopia ATM layer Rx Interfaces
Rx_clk_0, Rx_clk_1, Rx_clk_2, Rx_clk_3,
Rx_data_0, Rx_data_1, Rx_data_2, Rx_data_3,
Rx_soc_0, Rx_soc_1, Rx_soc_2, Rx_soc_3,
Rx_en_0, Rx_en_1, Rx_en_2, Rx_en_3,
Rx_clav_0, Rx_clav_1, Rx_clav_2, Rx_clav_3,

// 4 x Level 1 Utopia ATM layer Tx Interfaces
Tx_clk_0, Tx_clk_1, Tx_clk_2, Tx_clk_3,
Tx_data_0, Tx_data_1, Tx_data_2, Tx_data_3,
Tx_soc_0, Tx_soc_1, Tx_soc_2, Tx_soc_3,
Tx_en_0, Tx_en_1, Tx_en_2, Tx_en_3,
Tx_clav_0, Tx_clav_1, Tx_clav_2, Tx_clav_3,

// Miscellaneous control interfaces
rst, clk);

// 4 x Level 1 Utopia Rx Interfaces
output   Rx_clk_0, Rx_clk_1, Rx_clk_2, Rx_clk_3;
input [7:0] Rx_data_0, Rx_data_1, Rx_data_2, Rx_data_3;
input   Rx_soc_0, Rx_soc_1, Rx_soc_2, Rx_soc_3;
output  Rx_en_0, Rx_en_1, Rx_en_2, Rx_en_3;
input   Rx_clav_0, Rx_clav_1, Rx_clav_2, Rx_clav_3;

// 4 x Level 1 Utopia Tx Interfaces
output   Tx_clk_0, Tx_clk_1, Tx_clk_2, Tx_clk_3;
output [7:0] Tx_data_0, Tx_data_1, Tx_data_2, Tx_data_3;
output  Tx_soc_0, Tx_soc_1, Tx_soc_2, Tx_soc_3;
output  Tx_en_0, Tx_en_1, Tx_en_2, Tx_en_3;
input   Tx_clav_0, Tx_clav_1, Tx_clav_2, Tx_clav_3;

// Miscellaneous control interfaces
input rst, clk;

...
endmodule
","""Example of an ATM Router Model Header with Utopia Interface Ports in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p454.jpg,True,"The image contains several examples of Verilog code. Here they are:

1.
```verilog
bit cp_parity: coverpoint $countones(serial_word);
```

2.
```verilog
cExample: coverpoint (my_variable+your_variable) % 4;
```

3.
```verilog
cExample: coverpoint(address[31:16]);
```

4.
```verilog
covergroup (ref int ref_addr) cGroup;
    cPoint: coverpoint ref_addr;
endgroup
```

5.
```verilog
covergroup cGroup;
    cPoint: coverpoint cp_addr iff (!reset);
endgroup
```","
bit cp_parity: coverpoint $countones(serial_word);


cExample: coverpoint (my_variable+your_variable) % 4;


cExample: coverpoint(address[31:16]);


covergroup (ref int ref_addr) cGroup;
    cPoint: coverpoint ref_addr;
endgroup


covergroup cGroup;
    cPoint: coverpoint cp_addr iff (!reset);
endgroup
","""Exploring Functional Coverage in Verilog with Examples of Coverpoint Use Cases""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p332.jpg,True,"The image contains excerpts of Verilog code within a text discussing the use of `$past` and `nexttime` in properties. Below are the code snippets:

1.
```verilog
property
  @(posedge clk)
  $onehot (fifo_cntr ^ $past (fifo_cntr));
endproperty
```

2.
```verilog
property
  @(posedge clk)
  nexttime $onehot (fifo_cntr ^ $past (fifo_cntr));
endproperty
```

3.
```verilog
property
  @(posedge clk)
  $stable (bstrap);
endproperty
```

4.
```verilog
property
  @(posedge clk)
  nexttime $stable (bstrap);
endproperty
```","
property
  @(posedge clk)
  $onehot (fifo_cntr ^ $past (fifo_cntr));
endproperty


property
  @(posedge clk)
  nexttime $onehot (fifo_cntr ^ $past (fifo_cntr));
endproperty


property
  @(posedge clk)
  $stable (bstrap);
endproperty


property
  @(posedge clk)
  nexttime $stable (bstrap);
endproperty
",Exploring the use of the `nexttime` operator in SystemVerilog assertions for accurate signal comparison across clock cycles.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p241.jpg,True,"The image contains a snippet of code written in the context of a SystemVerilog Assertion (SVA) which is used for formal verification of hardware designs written in Verilog or SystemVerilog. Here is the code written in the image:

```verilog
property p_tWC;
@(posedge clk)
  ($fell(we_n) && !sel_n[2]) |=> $stable(addr[22:0]);
endproperty
a_tWC: assert property(p_tWC);
c_tWC: cover property(p_tWC);
```

This SVA is checking the write cycle time (`tWC`) property on a positive edge of the clock signal (`clk`). It asserts that when `we_n` (write enable, active low) falls and the `sel_n[2]` is not asserted (which is likely a chip-select signal), the address (`addr[22:0]`) should remain stable - that is, it should not change in the next cycle. The `assert` line (`a_tWC`) is used to assert that the property must always hold, while the `cover` line (`c_tWC`) is used to specify coverage for this property in the verification process.","
property p_tWC;
@(posedge clk)
  ($fell(we_n) && !sel_n[2]) |=> $stable(addr[22:0]);
endproperty
a_tWC: assert property(p_tWC);
c_tWC: cover property(p_tWC);
","Image of a textbook page discussing SystemVerilog Assertions (SVA) for memory timing constraints, with examples of timing parameters for SRAM and Flash memory, and a code snippet for an SRAM write cycle time assertion.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p326.jpg,True,"There is code in the image. Here is the Verilog code that is visible:

```verilog
property p1;
    req until gnt;
endproperty

module untilP ( );
    bit clk, req, gnt, antecedent;

    property checkAB;
        @(posedge clk)
        antecedent |-> req until gnt;
    endproperty

    delayD1: assert property (checkAB) else
        $display(""At %0tns until FAIL \n"", $stime);

    delayD1c: cover property (checkAB)
        $display(""At %0tns until PASS \n"", $stime);

    always begin #5ns clk=!clk; end

    initial
    begin
        clk=0; c=0;

        @(posedge clk); req=1; gnt=0;
        @(negedge clk); antecedent=1; //fire thread
        @(posedge clk); req=1; gnt=0;
        @(negedge clk); antecedent=0; //turn off thread
        @(posedge clk); req=0; gnt=1;
```

Please note that the code is an excerpt from a larger codebase, and some parts may be incomplete as presented in the image.","
property p1;
    req until gnt;
endproperty

module untilP ( );
    bit clk, req, gnt, antecedent;

    property checkAB;
        @(posedge clk)
        antecedent |-> req until gnt;
    endproperty

    delayD1: assert property (checkAB) else
        $display(""At %0tns until FAIL \n"", $stime);

    delayD1c: cover property (checkAB)
        $display(""At %0tns until PASS \n"", $stime);

    always begin #5ns clk=!clk; end

    initial
    begin
        clk=0; c=0;

        @(posedge clk); req=1; gnt=0;
        @(negedge clk); antecedent=1; //fire thread
        @(posedge clk); req=1; gnt=0;
        @(negedge clk); antecedent=0; //turn off thread
        @(posedge clk); req=0; gnt=1;
","""Exploring the 'until' operator in Verilog assertions within a test-bench module.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p68.jpg,True,"There is code in the image. Here it is:

```c
/* prototypes of PLI application routine names */
int PLIbook_PowSizetf(), PLIbook_PowCalltf(), PLIbook_PowCompiletf(), PLIbook_PowStartOfSim();
```","ototypes of PLI application routine names */
int PLIbook_PowSizetf(), PLIbook_PowCalltf(), PLIbook_PowCompiletf(), PLIbook_PowStartOfSim();
",Excerpt from The Verilog PLI Handbook discussing steps to register a PLI application along with an example of a VPI register function for a system function.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p191.jpg,True,"The image contains a section of a book or article discussing Verilog code related to let, sequence, and property declarations. It includes an example of Verilog code which I can transcribe:

```verilog
logic reset, clock, v, w, x, y;
default disable iff !reset;
default clocking ck @(posedge clock);
endclocking

sequence s;
    v[*3];
endsequence

a_until: assert property(
    seq_impl_prop(, s, sf_after_a(w, s, 1), (x until y));
c_seq: cover property(disable iff (!reset)
    sf_after_a(_, w, s, 1));
```

This code snippet demonstrates the definition of logic signals, default clocking and disable conditions, and the use of `sequence` and `property` constructs in Verilog. The `assert` and `cover` properties are also used for functional verification purposes.","
logic reset, clock, v, w, x, y;
default disable iff !reset;
default clocking ck @(posedge clock);
endclocking

sequence s;
    v[*3];
endsequence

a_until: assert property(
    seq_impl_prop(, s, sf_after_a(w, s, 1), (x until y));
c_seq: cover property(disable iff (!reset)
    sf_after_a(_, w, s, 1));
","""Page section on Verilog sequence and property declarations along with interpretation rules for assertions and coverage statements.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p186.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
module AN2 (o, a, b); // 2-input AND gate standard cell
  output o;
  input  a, b;
  
  and (o, a, b);

specify
  specparam BaseDelay$ = 2.2; //general attribute
  specparam InputLoad$a = 0.2; //object-specific attribute
  specparam InputLoad$b = 0.3; //object-specific attribute
endspecify
endmodule
```","
module AN2 (o, a, b); // 2-input AND gate standard cell
  output o;
  input  a, b;
  
  and (o, a, b);

specify
  specparam BaseDelay$ = 2.2; //general attribute
  specparam InputLoad$a = 0.2; //object-specific attribute
  specparam InputLoad$b = 0.3; //object-specific attribute
endspecify
endmodule
","""Understanding specparam constants as attributes in Verilog PLI applications illustrated with code examples.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p233.jpg,True,"The image contains two code examples written in the Verilog hardware description language:

Example 9-5 a) Module b_c

```verilog
module b_c(o, i, j);
  input i, j;
  output o;
  wire o;
  assign o = i | j;
endmodule // b_c
```

Example 9-5 b) Module b_d

```verilog
module b_d(o, i, j);
  input i, j;
  output o;
  wire o;
  assign o = i & j;
endmodule // b_d
```

The code defines two Verilog modules (b_c and b_d) with different logic operations for their output 'o': the `|` operator for an OR operation, and the `&` operator for an AND operation, on inputs 'i' and 'j'.","
module b_c(o, i, j);
  input i, j;
  output o;
  wire o;
  assign o = i | j;
endmodule // b_c


module b_d(o, i, j);
  input i, j;
  output o;
  wire o;
  assign o = i & j;
endmodule // b_d
","A page from a tutorial on Verilog RTL showing guidelines for using implicit connection specification, along with examples of Verilog code that demonstrate adding behavior to modules using the `assign` keyword with bit-wise logic operations.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p83.jpg,True,"The image contains code related to the Verilog Programming Language Interface (VPI). Here is the code present in the image:

```c
vpiHandle module_handle, net_iterator, net_handle;

/* assume a module handle has already been obtained */
net_iterator = vpi_iterate(vpiNet, module_handle);
if (net_iterator == NULL)
    vpi_printf("" No nets found in this module\n"");
else {
    while ( (net_handle = vpi_scan(net_iterator)) != NULL ) {
        /* access information about the net object */
    }
}

/* For $show_all_nets, the PLI application will need to access the first argument of the system task. This first argument will be a module instance name. For example: */

$show_all_nets(top.i1);

/* Accessing the arguments of a system task/function */

/* The $show_all_nets application can obtain a handle for the module instance that is named in the first system task argument using vpi_iterate() and vpi_scan(), as shown in the following C code fragment: */

vpiHandle systf_handle, module_handle, net_iterator, net_handle;

systf_handle = vpi_handle(vpiSysTfCall, NULL);
arg_iterator = vpi_iterate(vpiArgument, systf_handle);
module_handle = vpi_scan(arg_iterator);
vpi_free_object(arg_iterator); /* free iterator memory */
```

This code shows how to iterate over Verilog nets within a module and how to access system task/function arguments using the VPI routines.","ndle module_handle, net_iterator, net_handle;

/* assume a module handle has already been obtained */
net_iterator = vpi_iterate(vpiNet, module_handle);
if (net_iterator == NULL)
    vpi_printf("" No nets found in this module\n"");
else {
    while ( (net_handle = vpi_scan(net_iterator)) != NULL ) {
        /* access information about the net object */
    }
}

/* For $show_all_nets, the PLI application will need to access the first argument of the system task. This first argument will be a module instance name. For example: */

$show_all_nets(top.i1);

/* Accessing the arguments of a system task/function */

/* The $show_all_nets application can obtain a handle for the module instance that is named in the first system task argument using vpi_iterate() and vpi_scan(), as shown in the following C code fragment: */

vpiHandle systf_handle, module_handle, net_iterator, net_handle;

systf_handle = vpi_handle(vpiSysTfCall, NULL);
arg_iterator = vpi_iterate(vpiArgument, systf_handle);
module_handle = vpi_scan(arg_iterator);
vpi_free_object(arg_iterator); /* free iterator memory */
","""Documentation excerpt on using VPI routines with Verilog code examples for module and net iteration.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p348.jpg,True,"```
FL_Property ::= 
  FL_Property until! FL_Property 
| FL_Property until FL_Property 
| FL_Property until_! FL_Property 
| FL_Property until_FL_Property

SERE ::= 
  SERE within SERE
```","perty ::= 
  FL_Property until! FL_Property 
| FL_Property until FL_Property 
| FL_Property until_! FL_Property 
| FL_Property until_FL_Property

SERE ::= 
  SERE within SERE
","""Documentation excerpt on Verilog sequence operators: until*, within, and next, with syntax descriptions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p97.jpg,True,"The image contains a snippet of C code which interacts with Verilog via the VPI (Verilog Procedural Interface). Here is the code from the image:

```c
vpiHandle signal_handle;
s_vpi_value current_value;

current_value.format = vpiTimeVal;
vpi_get_value(signal_handle, &current_value);
vpi_printf(""time %-10s value is %x%x\n"",
           vpi_get_str(vpiName, signal_handle),
           current_value.value.time->high,
           current_value.value.time->low);
```

This code is used to read the value of a Verilog time variable and print the value in hexadecimal format. The `vpi_printf` function is used to output the name of the signal and its associated time value. The `vpi_get_value` and `vpi_get_str` functions are part of the VPI routines used to interact with Verilog simulation from C code.","ndle signal_handle;
s_vpi_value current_value;

current_value.format = vpiTimeVal;
vpi_get_value(signal_handle, &current_value);
vpi_printf(""time %-10s value is %x%x\n"",
           vpi_get_str(vpiName, signal_handle),
           current_value.value.time->high,
           current_value.value.time->low);
","The image contains a page from a technical manual or book explaining the ""How to Use the VPI Routines"" in the context of Verilog hardware description language, with focus on interfacing Verilog with C for 64-bit time value handling, ending with an example code snippet in C.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p189.jpg,True,"The image contains multiple snippets of Verilog/SystemVerilog code. Here they are:

First code snippet:
```verilog
program automatic test;
int i; // Program-level variable

class Bad;
    logic [31:0] data[];

    // Calling this function changes the program variable i
    function void display();
        // Forgot to declare i in next statement
        for (i=0; i<data.size(); i++)
            $display(""data[%0d]=%x"", i, data[i]);
    endfunction
endclass
endprogram
```

Second code snippet:
```verilog
package Better;
class Bad;
    logic [31:0] data[];

    // ** Will not compile because of undeclared i
    function void display();
        for (i = 0; i<data.size(); i++)
            $display(""data[%0d]=%x"", i, data[i]);
    endfunction
endclass
endpackage
```

Third code snippet:
```verilog
program automatic test;
int i; // Program-level variable
import Better::*;
//...
endprogram
```","
program automatic test;
int i; // Program-level variable

class Bad;
    logic [31:0] data[];

    // Calling this function changes the program variable i
    function void display();
        // Forgot to declare i in next statement
        for (i=0; i<data.size(); i++)
            $display(""data[%0d]=%x"", i, data[i]);
    endfunction
endclass
endprogram


package Better;
class Bad;
    logic [31:0] data[];

    // ** Will not compile because of undeclared i
    function void display();
        for (i = 0; i<data.size(); i++)
            $display(""data[%0d]=%x"", i, data[i]);
    endfunction
endclass
endpackage


program automatic test;
int i; // Program-level variable
import Better::*;
//...
endprogram
",Verilog code example demonstrating a variable scope issue and its resolution by moving the class into a package.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p185.jpg,True,"The image contains several snippets of Verilog code. Here is the code contained in the image:

Example 8.5:
```verilog
module m;
  bit clk;
  logic a, b;
  let x = $past(a && b);
  let y = $past(a && b , ,@(posedge clk));
  always_comb begin
    a1: assert #0 (x);
    a2: assert #0 (y);
  end
  a3: assert property(@(posedge clk) a |-> x);
endmodule
```

Example 8.6:
```verilog
let inc1(int x) = x++;
let inc2(bit [7:0] y) = y+=2;
let combinetwo(integer v, w) = (v = v + w);
module m;
  bit clk;
  integer a, b;
  a1: assert property (@(clk) inc1(a));
  a2: assert property (@(clk) inc2(a) == 1);
  property p;
    @(clk) combinetwo(a, b);
  endproperty
  a3: assert property (p);
endmodule
```

These code examples are demonstrating the use of `let` constructs, property assertions, and clocking events in Verilog/SystemVerilog code.","
module m;
  bit clk;
  logic a, b;
  let x = $past(a && b);
  let y = $past(a && b , ,@(posedge clk));
  always_comb begin
    a1: assert #0 (x);
    a2: assert #0 (y);
  end
  a3: assert property(@(posedge clk) a |-> x);
endmodule


let inc1(int x) = x++;
let inc2(bit [7:0] y) = y+=2;
let combinetwo(integer v, w) = (v = v + w);
module m;
  bit clk;
  integer a, b;
  a1: assert property (@(clk) inc1(a));
  a2: assert property (@(clk) inc2(a) == 1);
  property p;
    @(clk) combinetwo(a, b);
  endproperty
  a3: assert property (p);
endmodule
","Caption: ""Discussion and example of proper and problematic uses of the 'let' construct in assertions in Verilog code, demonstrating legality and inference of clocking events.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p192.jpg,True,"```c
typedef struct t_vpi_delay
{
    struct t_vpi_time *da;
    int no_of_delays;
    int time_type;
    int mtm_flag;
    int append_flag;
    int pulserre_flag;
} s_vpi_delay, *p_vpi_delay;
```","ef struct t_vpi_delay
{
    struct t_vpi_time *da;
    int no_of_delays;
    int time_type;
    int mtm_flag;
    int append_flag;
    int pulserre_flag;
} s_vpi_delay, *p_vpi_delay;
","Caption: ""Documentation and code snippet defining the s_vpi_delay structure used in Verilog PLI (Programming Language Interface) applications to retrieve delay values.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p497.jpg,True,"The image contains Verilog code associated with the SystemVerilog coverage feature. Here is the code present in the image:

```verilog
covergroup cg1 @(posedge clk);
  coverpoint a {
    bins b1[] = {0, 1, 2, 3};
    illegal_bins il1 = {1, 2};
    ignore_bins ign = {2,3}
  }
endgroup
```

In this instance, `b1[]` declares legal bins, `il1` declares illegal bins, and `ign` declares bins to ignore for coverage. The text discusses the precedence of illegal bins over ignore bins.

The image also includes some text explaining how to use `binsof` and `intersect` operators in SystemVerilog coverage. However, no concrete syntax for these operators is provided.","
covergroup cg1 @(posedge clk);
  coverpoint a {
    bins b1[] = {0, 1, 2, 3};
    illegal_bins il1 = {1, 2};
    ignore_bins ign = {2,3}
  }
endgroup
","Caption: Verilog coverage group example demonstrating the use of illegal and ignore bins, along with an explanation of ""binsof"" and ""intersect"" operators for functional coverage in system-level verification.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p282.jpg,True,"The image contains a section of text discussing a Verilog property check related to a PCI Target check, and it includes Verilog code that declares a property and asserts and covers that property in a formal verification context. Here is the Verilog code from the image:

```verilog
property p_tchk2;
  @(posedge clk)
    $fell (trdyn) |-> 
      (!trdyn && !devseln) [*0:16] ##0 !irdyn;
endproperty

a_tchk2: assert property(p_tchk2);
c_tchk2: cover property(p_tchk2);
```

The given property `p_tchk2` is defined to become active on the falling edge of the signal `trdyn`. According to the subsequent text, the consequent of the property ensures that the signals `trdyn` and `devseln` stay asserted until the signal `irdyn` is asserted and the latency on the `trdyn` signal is 16 cycles.","
property p_tchk2;
  @(posedge clk)
    $fell (trdyn) |-> 
      (!trdyn && !devseln) [*0:16] ##0 !irdyn;
endproperty

a_tchk2: assert property(p_tchk2);
c_tchk2: cover property(p_tchk2);
","Caption: ""Illustration of PCI target check showing signal timing diagram and associated Verilog assertion properties for signal behavior validation.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p374.jpg,True,"The image contains snippets of text that describe the syntax for consecutive repetition in SystemVerilog assertions. However, there is no block of Verilog code presented as you might find in a code editor. Instead, there are definitions and examples in a more formal grammar representation and textual description. Here is the content that represents syntax and example code-like expressions:

```plaintext
sequence_expr ::= sequence_expr '{' const_range_expression '}'
                 | expression_or_dist '{' const_range_expression '}'

const_range_expression ::=
              constant_range_expression
              | constant_range_expression ':' constant_range_expression
              | constant_range_expression ':=' '$'
```

The image also includes some examples explaining the consecutive repetition concept:

- `a[*0] ##1 b`  same as  `(b)`
- `a[*2] ##1 b`  same as  `(a ##1 a ##1 b)`
- `a[*1:2] ##1 b`  same as  `(a ##1 b) or (a ##1 a ##1 b)`
- `(a ##1 b) [*0]` same as  `(a ##1 b ##1 a ##1 b)`
  
And there's a note related to the equivalent representation of the first example:

```plaintext
a[*0] ##N b === ##(N-1) b
```

Please note that these aren't executable code snippets, but rather a representation of grammar used in SystemVerilog for assertions.","xt
sequence_expr ::= sequence_expr '{' const_range_expression '}'
                 | expression_or_dist '{' const_range_expression '}'

const_range_expression ::=
              constant_range_expression
              | constant_range_expression ':' constant_range_expression
              | constant_range_expression ':=' '$'

xt
a[*0] ##N b === ##(N-1) b
","""Verilog Consecutive Repetition Syntax and Examples""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p296.jpg,True,"```verilog
first_match(s_tchk12) |-> ##[0:5] $fell (trdyn);
endproperty

a_tchk12: assert property(p_tchk12);
c_tchk12: cover property(p_tchk12);

sequence s_tchk13a;
@(posedge clk)
(`s_CONFIG_READ || `s_CONFIG_WRITE)
&& ((ad[1:0] == 2'b10) || (ad[1:0] == 2'b11))
&& idsel;
endsequence
```","
first_match(s_tchk12) |-> ##[0:5] $fell (trdyn);
endproperty

a_tchk12: assert property(p_tchk12);
c_tchk12: cover property(p_tchk12);

sequence s_tchk13a;
@(posedge clk)
(`s_CONFIG_READ || `s_CONFIG_WRITE)
&& ((ad[1:0] == 2'b10) || (ad[1:0] == 2'b11))
&& idsel;
endsequence
","""Example of Verilog Assertions and Waveform for PCI Target Check""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p27.jpg,True,"The image includes a snippet of Verilog code, which is provided below:

```verilog
always (a or b) begin
    if (a ^ b) begin // not equal
        $display(""error: A&B must be equal: %m"");
        $finish;
    end
end
```","
always (a or b) begin
    if (a ^ b) begin // not equal
        $display(""error: A&B must be equal: %m"");
        $finish;
    end
end
","""Comparing VHDL and Verilog for assertion checks in HDL with examples of VHDL ASSERT and Verilog always block for signal checks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p483.jpg,True,"```verilog
A: coverpoint a {
    bins b1[] = {2, [4:5]};
    bins b2[] = {6, 7};
    bins b3[] = default;
}
B: coverpoint b {
    bins b1[] = {3, [7:9]};
}
C: coverpoint c {
    bins b1[] = {1,4};
}

cross A, B {
    bins cb1 = binsof (A); // correct use
    bins cb2 = binsof (A.b1); // correct use
    bins cb3 = binsof (B.b2); // incorrect use as b2 is not a bin of B (duh!)
    bins cb4 = binsof (C); // incorrect use as cross does not include C
}

// The expression within the binsof construct should not be a default bin.
bins cb1 = binsof(A.b3); // incorrect use because b3 is a default bin

//You cannot declare a vector bin inside a cross.
cross A, B {
    bins cb1[] = binsof (A); // incorrect use as cb1 is declared as vector
    bins cb2 = binsof (A.b1); // correct use
}

//You cannot declare default bins inside a cross.
cross A, B {
    bins cb1 = default; // incorrect use
}

//You cannot declare bins with the same name inside a cross.
cross A, B {
    bins cb1 = binsof (A);
    bins cb1 = binsof (A.b2);
}
```","
A: coverpoint a {
    bins b1[] = {2, [4:5]};
    bins b2[] = {6, 7};
    bins b3[] = default;
}
B: coverpoint b {
    bins b1[] = {3, [7:9]};
}
C: coverpoint c {
    bins b1[] = {1,4};
}

cross A, B {
    bins cb1 = binsof (A); // correct use
    bins cb2 = binsof (A.b1); // correct use
    bins cb3 = binsof (B.b2); // incorrect use as b2 is not a bin of B (duh!)
    bins cb4 = binsof (C); // incorrect use as cross does not include C
}

// The expression within the binsof construct should not be a default bin.
bins cb1 = binsof(A.b3); // incorrect use because b3 is a default bin

//You cannot declare a vector bin inside a cross.
cross A, B {
    bins cb1[] = binsof (A); // incorrect use as cb1 is declared as vector
    bins cb2 = binsof (A.b1); // correct use
}

//You cannot declare default bins inside a cross.
cross A, B {
    bins cb1 = default; // incorrect use
}

//You cannot declare bins with the same name inside a cross.
cross A, B {
    bins cb1 = binsof (A);
    bins cb1 = binsof (A.b2);
}
","An excerpt from a technical document showcasing examples of correct and incorrect ways to use ""cross"" coverage in Verilog code.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p103.jpg,True,"The image contains two snippets of pseudocode related to assertion procedures in a document titled ""A Fast Linear-Arithmetic Solver for DPLL(T)."" Here is the code:

```plaintext
procedure AssertUpper(xi <= ci)
    if ci >= ui then return satisfiable
    if ci < li then return unsatisfiable
    ui := ci
    if xi is a nonbasic variable and β(xi) > ci then update(xi, ci)
    return ok

procedure AssertLower(xi >= ci)
    if ci <= li then return satisfiable
    if ci > ui then return unsatisfiable
    li := ci
    if xi is a nonbasic variable and β(xi) < ci then update(xi, ci)
    return ok
```

The procedures are labeled as ""Fig. 4. Assertion procedures."" The text also discusses the context and application of these procedures in solving linear arithmetic constraints within the DPLL(T) framework.","xt
procedure AssertUpper(xi <= ci)
    if ci >= ui then return satisfiable
    if ci < li then return unsatisfiable
    ui := ci
    if xi is a nonbasic variable and β(xi) > ci then update(xi, ci)
    return ok

procedure AssertLower(xi >= ci)
    if ci <= li then return satisfiable
    if ci > ui then return unsatisfiable
    li := ci
    if xi is a nonbasic variable and β(xi) < ci then update(xi, ci)
    return ok
","Caption: ""Pseudocode for assertion procedures in a linear-arithmetic solver algorithm, showing the methods AssertUpper and AssertLower.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p309.jpg,True,"The image contains text and Verilog code examples that describe stimulus generation for logical relationships in level-sensitive signals with respect to a clock edge. Here is the code presented in the image:

```verilog
// On a given clock edge, both leading signal and
// trailing signal are high

property p_l_hh;
    @(posedge clk) a && b;
endproperty

// On a given clock edge, the leading signal is
// high and the trailing signal is low

property p_l_hl;
    @(posedge clk) a && !b;
endproperty

// On a given clock edge, the leading signal is
// low and the trailing signal is high

property p_l_lh;
    @(posedge clk) !a && b;
endproperty

// On a given clock edge, both leading signal and
// trailing signal are low

property p_l_ll;
    @(posedge clk) !a && !b;
endproperty

a_l_hh : assert property(p_l_hh);
a_l_hl : assert property(p_l_hl);
```

The code is about defining properties to check signal states at the positive edge of a clock signal and then asserting those properties.","
// On a given clock edge, both leading signal and
// trailing signal are high

property p_l_hh;
    @(posedge clk) a && b;
endproperty

// On a given clock edge, the leading signal is
// high and the trailing signal is low

property p_l_hl;
    @(posedge clk) a && !b;
endproperty

// On a given clock edge, the leading signal is
// low and the trailing signal is high

property p_l_lh;
    @(posedge clk) !a && b;
endproperty

// On a given clock edge, both leading signal and
// trailing signal are low

property p_l_ll;
    @(posedge clk) !a && !b;
endproperty

a_l_hh : assert property(p_l_hh);
a_l_hl : assert property(p_l_hl);
","Caption: ""Verilog code demonstrating properties for logical relationships between level-sensitive signals on a clock edge.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p508.jpg,True,"The image contains examples of Verilog code related to coverage groups. Here's the code from the image:

```verilog
cov = rg_inst.Cpoint.Cbins1.get_coverage ( ); //ILLEGAL:
// get_coverage ( ) on `bins' not allowed.

// Example with ""bins""
bit[7:0] adr1;
covergroup gc @(posedge clk);
    ac: coverpoint adr1
    {
        bins adrb2 = (1=>2=>3);
        bins adrb3[ ] = (1,2 => 3,4);
        bins adrb5 = ('hf[3*]);
    }
endgroup

// Converted bins into coverpoints
bit[7:0] adr1;
covergroup gc @(posedge clk);
    CpointadrB2: coverpoint adr1 { bins adrb2 = (1=>2=>3); }
    CpointadrB3: coverpoint adr1 { bins adrb3[ ] = (1,2 => 3,4); }
    CpointadrB5: coverpoint adr1 { bins adrb5 = ('hf[3*]); }
endgroup
```

The text discusses the concept of converting bins into coverpoints for the purpose of collecting coverage information in Verilog verification environments.","
cov = rg_inst.Cpoint.Cbins1.get_coverage ( ); //ILLEGAL:
// get_coverage ( ) on `bins' not allowed.

// Example with ""bins""
bit[7:0] adr1;
covergroup gc @(posedge clk);
    ac: coverpoint adr1
    {
        bins adrb2 = (1=>2=>3);
        bins adrb3[ ] = (1,2 => 3,4);
        bins adrb5 = ('hf[3*]);
    }
endgroup

// Converted bins into coverpoints
bit[7:0] adr1;
covergroup gc @(posedge clk);
    CpointadrB2: coverpoint adr1 { bins adrb2 = (1=>2=>3); }
    CpointadrB3: coverpoint adr1 { bins adrb3[ ] = (1,2 => 3,4); }
    CpointadrB5: coverpoint adr1 { bins adrb5 = ('hf[3*]); }
endgroup
","Caption: ""Converting bins to individual coverpoints in Verilog for coverage collection.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p246.jpg,True,"The image contains Verilog code. Here is the text of the code from the image:

```verilog
sequence abc;
  a ##2 b ##2 c;
endsequence

property dP;
  @(posedge clk) d |=> abc;
endproperty

initial
begin
  expect (@(posedge clk) abc);
  expect dP;
  @(posedge clk) expect (abc); // ERROR
end
 
sequence abc;
  a ##2 b ##2 c;
endsequence

always @(posedge clk)
begin
  expect (abc); // ERROR
end
```

The code consists of definitions of sequences and properties, along with an initial block and an always block. There are also comments indicating where there are errors due to incorrect usage of the `expect` construct according to the semantics described in the associated text.","
sequence abc;
  a ##2 b ##2 c;
endsequence

property dP;
  @(posedge clk) d |=> abc;
endproperty

initial
begin
  expect (@(posedge clk) abc);
  expect dP;
  @(posedge clk) expect (abc); // ERROR
end
 
sequence abc;
  a ##2 b ##2 c;
endsequence

always @(posedge clk)
begin
  expect (abc); // ERROR
end
","Caption: ""Error conditions associated with the use of 'expect' in Verilog for clocked sequences and properties""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p335.jpg,True,"```verilog
if ((logic_op == 1 || o_e_implication == 1) && timing == 0 && sig_edge == 1 && sig1_edge == 0)
begin
    a4_oei_l1: assert property(p4_oei_l1);
    a4_oei_lh: assert property(p4_oei_lh);
end

// logical relationship between 2 edge sensitive
// signals with overlapping implication RF, RR

if ((logic_op == 1 || o_e_implication == 1) && timing == 0 && sig_edge == 1 && sig1_edge == 1)
begin
    a4_oei_hl: assert property(p4_oei_hl);
    a4_oei_hh: assert property(p4_oei_hh);
end

if (logic_op == 0 && timing == 1 && sig_edge == 1 && non_o_implication == 0)
begin
    if (min_time == max_time)
    begin
        a4_f_rr: assert property(p4_f_rr);
        a4_f_ff: assert property(p4_f_ff);
        a4_f_rf: assert property(p4_f_rf);
        a4_f_fr: assert property(p4_f_fr);
    end
    if (min_time != max_time)
    begin
        a4_w_rr: assert property(p4_w_rr);
        a4_w_ff: assert property(p4_w_ff);
        a4_w_rf: assert property(p4_w_rf);
        a4_w_fr: assert property(p4_w_fr);
    end
end

// timing relation between 2 level sensitive
// signals with non-overlapping implication

if (logic_op == 0 && timing == 1 && sig_edge == 0 && non_o_implication == 1)
begin
    if (min_time == max_time)
```

The image shows a page with code that seems to be written in Verilog, a hardware description language. The text on the page also includes comments that provide context or describe the logic behind the code segments.","
if ((logic_op == 1 || o_e_implication == 1) && timing == 0 && sig_edge == 1 && sig1_edge == 0)
begin
    a4_oei_l1: assert property(p4_oei_l1);
    a4_oei_lh: assert property(p4_oei_lh);
end

// logical relationship between 2 edge sensitive
// signals with overlapping implication RF, RR

if ((logic_op == 1 || o_e_implication == 1) && timing == 0 && sig_edge == 1 && sig1_edge == 1)
begin
    a4_oei_hl: assert property(p4_oei_hl);
    a4_oei_hh: assert property(p4_oei_hh);
end

if (logic_op == 0 && timing == 1 && sig_edge == 1 && non_o_implication == 0)
begin
    if (min_time == max_time)
    begin
        a4_f_rr: assert property(p4_f_rr);
        a4_f_ff: assert property(p4_f_ff);
        a4_f_rf: assert property(p4_f_rf);
        a4_f_fr: assert property(p4_f_fr);
    end
    if (min_time != max_time)
    begin
        a4_w_rr: assert property(p4_w_rr);
        a4_w_ff: assert property(p4_w_ff);
        a4_w_rf: assert property(p4_w_rf);
        a4_w_fr: assert property(p4_w_fr);
    end
end

// timing relation between 2 level sensitive
// signals with non-overlapping implication

if (logic_op == 0 && timing == 1 && sig_edge == 0 && non_o_implication == 1)
begin
    if (min_time == max_time)
",Excerpt from a textbook showing Verilog code with assertions for timing and logical relationships between signals.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p321.jpg,True,"The image contains Verilog code that defines several properties for checking signal changes in relation to clock edges. Here is the code from the image:

```verilog
property p4_f_rr;
    @(posedge clk) $rose(a) ##min_time $rose(b);
endproperty

// on a given clock edge, the leading signal has
// a falling edge and after ""min_time"" cycle the
// trailing signal has a rising edge

property p4_f_fr;
    @(posedge clk) $fell(a) ##min_time $rose(b);
endproperty

// on a given clock edge, the leading signal has
// a rising edge and after ""min_time"" cycles the
// trailing signal has a falling edge

property p4_f_rf;
    @(posedge clk) $rose(a) ##min_time $fell(b);
endproperty

a4_f_rr: assert property(p4_f_rr);
a4_f_ff: assert property(p4_f_ff);
a4_f_rf: assert property(p4_f_rf);
a4_f_fr: assert property(p4_f_fr);

A list of possible properties for variable timing relationship between two
edge sensitive signals is shown below.

// on a given clock edge, the leading signal has
// a falling edge and within ""min_time"" to
// ""max_time"" cycles the trailing signal has a
// falling edge

property p4_w_ff;
    @(posedge clk)
    $fell(a) ##[min_time : max_time] $fell(b);
endproperty

// on a given clock edge, the leading signal has
// a rising edge and within ""min_time"" to
// ""max_time"" cycles the trailing signal has a
// rising edge
```

The properties are using SystemVerilog assertion constructs to verify the timing relationships between signals `a` and `b` with respect to the positive edge of the clock signal `clk`. The `$rose` and `$fell` functions are used to check for rising and falling edges of signals, respectively. The `##` operator specifies a delay or a range of clock cycles after which the second event should occur. The `assert property` statements are used to assert that the defined properties hold during simulation.","
property p4_f_rr;
    @(posedge clk) $rose(a) ##min_time $rose(b);
endproperty

// on a given clock edge, the leading signal has
// a falling edge and after ""min_time"" cycle the
// trailing signal has a rising edge

property p4_f_fr;
    @(posedge clk) $fell(a) ##min_time $rose(b);
endproperty

// on a given clock edge, the leading signal has
// a rising edge and after ""min_time"" cycles the
// trailing signal has a falling edge

property p4_f_rf;
    @(posedge clk) $rose(a) ##min_time $fell(b);
endproperty

a4_f_rr: assert property(p4_f_rr);
a4_f_ff: assert property(p4_f_ff);
a4_f_rf: assert property(p4_f_rf);
a4_f_fr: assert property(p4_f_fr);

A list of possible properties for variable timing relationship between two
edge sensitive signals is shown below.

// on a given clock edge, the leading signal has
// a falling edge and within ""min_time"" to
// ""max_time"" cycles the trailing signal has a
// falling edge

property p4_w_ff;
    @(posedge clk)
    $fell(a) ##[min_time : max_time] $fell(b);
endproperty

// on a given clock edge, the leading signal has
// a rising edge and within ""min_time"" to
// ""max_time"" cycles the trailing signal has a
// rising edge
","""Verilog Assertions for Signal Timing Relations""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p252.jpg,True,"```verilog
a1_assert: assert property (probe_assert) ( req inside {0, 1} )
property probe_assert;
    @(posedge clk) req |=> ack;
endproperty
```","
a1_assert: assert property (probe_assert) ( req inside {0, 1} )
property probe_assert;
    @(posedge clk) req |=> ack;
endproperty
","""Discussion on the use of the 'dist' (Distribution Operator) and 'inside' operator in Verilog assertions and assumptions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p228.jpg,True,"The image contains examples of Verilog code, which are assertion patterns for hardware description and verification. Here are the snippets of SystemVerilog code visible:

Example 6-63:
```verilog
// pipelined-protocol pattern

// See pipelined_reqack module definition in Example 6-44

pipelined_reqack
  .sendWriteReq({SMQueNew & !SMQueWrEn}),
  .req_datain({SlaveWrData, SMQueAddr}),
  .ack(EngMemWr),
  .dataout({EngMemData, EngMemAddr}),
  .clk(clk), .latency(100), .pipedepth(6));
```

Example 6-64:
```verilog
// conditional pattern

assert property (@(posedge clk) disable iff (rst_n)
  (SMQueNew & !SMQueWrEn |-> ReadExistsInQue)) else
$error(""ReadExistsInQue not asserted for valid read."");
```

Example 6-65:
```verilog
// conditional pattern

assert property (@(posedge clk) disable iff (rst_n)
  (Flush | SMQueStop) |-> SMQueNew)) else
$error(""Illegal SMQueNew while asserting Stop or Flush."");
```

Example 6-66:
```verilog
// valid signal combination pattern

assert property (@(posedge clk) disable iff (rst_n)
  not (SMQueNew & SMQueWrEn & ReadExistsInQue)) else
$error(""$s%u$n%s"", ""A write is being enqueued while there is a valid read in the queue."",
  ""This must be avoided so that the read can be invalidated by the write."");
```

Example 6-67:
```verilog
// valid signal combination pattern

assert property (@(posedge clk) disable iff (rst_n)
  (QueueAlmostFull & !MemBgnDone & SMQueNew |-> QueFull)) else
$error(""Queue did not fill when one more request entered."");
```

These pieces of code use assertions in SystemVerilog to check specific conditions in the design and will trigger errors if the conditions are not met, which is useful for verification purposes.","
// pipelined-protocol pattern

// See pipelined_reqack module definition in Example 6-44

pipelined_reqack
  .sendWriteReq({SMQueNew & !SMQueWrEn}),
  .req_datain({SlaveWrData, SMQueAddr}),
  .ack(EngMemWr),
  .dataout({EngMemData, EngMemAddr}),
  .clk(clk), .latency(100), .pipedepth(6));


// conditional pattern

assert property (@(posedge clk) disable iff (rst_n)
  (SMQueNew & !SMQueWrEn |-> ReadExistsInQue)) else
$error(""ReadExistsInQue not asserted for valid read."");


// conditional pattern

assert property (@(posedge clk) disable iff (rst_n)
  (Flush | SMQueStop) |-> SMQueNew)) else
$error(""Illegal SMQueNew while asserting Stop or Flush."");


// valid signal combination pattern

assert property (@(posedge clk) disable iff (rst_n)
  not (SMQueNew & SMQueWrEn & ReadExistsInQue)) else
$error(""$s%u$n%s"", ""A write is being enqueued while there is a valid read in the queue."",
  ""This must be avoided so that the read can be invalidated by the write."");


// valid signal combination pattern

assert property (@(posedge clk) disable iff (rst_n)
  (QueueAlmostFull & !MemBgnDone & SMQueNew |-> QueFull)) else
$error(""Queue did not fill when one more request entered."");
",Verilog Assertion Examples: Ensuring Protocol Adherence and Error Checking in SRAM Interface and Queue Operations.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p218.jpg,True,"The image includes Verilog code. Here is the code extracted from the image:

```verilog
module RAM
(
input wire [63:0] data,
input logic [7:0] address,
input logic write_enable, read_enable
);

logic [63:0] mem [0:255];

always_latch // asynchronous write (latch behavior)
    if (write_enable) mem[address] <= data; // write to RAM

assign data = read_enable? mem[address] : 64'bz;
endmodule

module test;
    wire [63:0] data;
    logic [7:0] address;
    logic write_enable, read_enable;

    RAM ram1(.*);
    // instance or RAM model

initial begin
    $readmemh(""ram_data.dat"", ram1.mem); // GOTCHA!
    ...
```

Please note that the code snippet seems incomplete due to the ellipsis (...). Additionally, the code might be part of a larger tutorial or example that explains certain concepts in Verilog or SystemVerilog, particularly regarding the loading of memories modeled with always_latch and always_ff procedural blocks.","
module RAM
(
input wire [63:0] data,
input logic [7:0] address,
input logic write_enable, read_enable
);

logic [63:0] mem [0:255];

always_latch // asynchronous write (latch behavior)
    if (write_enable) mem[address] <= data; // write to RAM

assign data = read_enable? mem[address] : 64'bz;
endmodule

module test;
    wire [63:0] data;
    logic [7:0] address;
    logic write_enable, read_enable;

    RAM ram1(.*);
    // instance or RAM model

initial begin
    $readmemh(""ram_data.dat"", ram1.mem); // GOTCHA!
    ...
","""Exploring a gotcha in Verilog/SystemVerilog related to loading memories with always_latch or always_ff procedural blocks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p214.jpg,True,"The image contains a segment of text that includes Verilog code within. Here is the code provided in the image:

```verilog
// declarative assertion
// Once an invalidate occurs, neither hit or invalidate may be
// asserted for the next 4 cycles.

assert never ({invalidate; {invalidate || hit}[*1:4] })
  @ (posedge clk);
```

This code snippet shows an assert statement used in hardware verification language to ensure certain conditions never occur. Specifically, it asserts that once an 'invalidate' signal occurs, neither 'hit' nor 'invalidate' should be asserted for the next 4 clock cycles.","
// declarative assertion
// Once an invalidate occurs, neither hit or invalidate may be
// asserted for the next 4 cycles.

assert never ({invalidate; {invalidate || hit}[*1:4] })
  @ (posedge clk);
","""Example of a PSL forbidden sequence check in Verilog for ensuring certain conditions do not occur in a sequence of cycles""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p285.jpg,True,"The image contains two snippets of Verilog code. Here are the transcriptions of the code shown in the image:

First snippet:
```verilog
property pr1;
  @(posedge clk) req ##2 gnt;
endproperty

reqGnt: assert property (pr1) $display($stime,,,""\t %m PASS"");
else $display($stime,,,""\t %m FAIL"");
```

Second snippet (Test Cases Log):
```
#10 clk=1 req=0 gnt=0
#10 test_basic_property.reqGnt FAIL

#30 clk=1 req=0 gnt=0
#30 test_basic_property.reqGnt FAIL

# 50 clk=1 req=1 gnt=0

# 70 clk=1 req=0 gnt=0
# 70 test_basic_property.reqGnt FAIL

#90 clk=1 req=0 gnt=1
#90 test_basic_property.reqGnt PASS

#110 clk=1 req=0 gnt=0
#110 test_basic_property.reqGnt FAIL
```

This code is used to explain a concept in Verilog without using an implication operator. It is accompanied by annotations and graphical elements to illustrate the idea being described.","
property pr1;
  @(posedge clk) req ##2 gnt;
endproperty

reqGnt: assert property (pr1) $display($stime,,,""\t %m PASS"");
else $display($stime,,,""\t %m FAIL"");

k=1 req=0 gnt=0
#10 test_basic_property.reqGnt FAIL

#30 clk=1 req=0 gnt=0
#30 test_basic_property.reqGnt FAIL

# 50 clk=1 req=1 gnt=0

# 70 clk=1 req=0 gnt=0
# 70 test_basic_property.reqGnt FAIL

#90 clk=1 req=0 gnt=1
#90 test_basic_property.reqGnt PASS

#110 clk=1 req=0 gnt=0
#110 test_basic_property.reqGnt FAIL
","""Explanation of a Verilog property and assertion without using an implication operator, highlighting the importance of the implication operator in assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p291.jpg,True,"The image contains a snippet of Verilog code embedded within a text that discusses important topics related to Verilog assertions. The code in the image is as follows:

```verilog
property ab;
    @(posedge clk) a |=> b[=0];
endproperty
```

The text describes how to use temporal logic in Verilog for verifying certain conditions or properties in a design, particularly using the implication operator (`|=>`) and the non-consecutive repetition operator (`[=0]`). It provides an example property named `ab` that uses these operators to assert that when signal `a` is true, the signal `b` should never be true (i.e., it should be negated or zero) from the next clock cycle onwards.","
property ab;
    @(posedge clk) a |=> b[=0];
endproperty
","""Verilog Property Example Illustrating How to Ensure a Signal Remains Zero After a Condition is Met""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p200.jpg,True,"The image contains Verilog code, which is as follows:

Example 6-21 SystemVerilog check for valid transaction
```verilog
// declarative assertion

assert property ( @(posedge clk) disable iff (reset_n)
  trans_start |-> (read, write, burst, size, wt) inside
    {6'b1_?_00_?_?, // cache (burst) read.
     6'b1_0_0_00_?,  // single byte read
     6'b1_0_0_01_?,  // halfword read
     6'b1_0_0_11_?,  // word read
     6'b0_1_1_00_0,  // cache (burst) write
     6'b0_1_0_00_0,  // single byte write
     6'b0_1_0_01_0,  // halfword write
     6'b0_1_0_11_0,  // word write
     6'b0_1_0_00_1,  // single byte writethru
     6'b0_1_0_01_1,  // halfword writethru
     6'b0_1_0_11_1,  // word writethru
     6'b0_0_0_00_0}  // nothing.
else $error(""Illegal request {read, write, burst, size, wt}=%0h"", {read, write, burst, size, wt});
```

Example 6-22 SystemVerilog check for undriven data when valid
```verilog
// declarative assertion

assert property ( @(posedge clk) disable iff (reset_n)
  (data_valid != 1'sb1) || !$isunknown(data[31:0]) )
else $error(""Undriven data bus (%h) during data return"", data[31:0]);
```

This code includes two examples of SystemVerilog assertions used for checking valid transactions and checking for undriven data when valid.","
// declarative assertion

assert property ( @(posedge clk) disable iff (reset_n)
  trans_start |-> (read, write, burst, size, wt) inside
    {6'b1_?_00_?_?, // cache (burst) read.
     6'b1_0_0_00_?,  // single byte read
     6'b1_0_0_01_?,  // halfword read
     6'b1_0_0_11_?,  // word read
     6'b0_1_1_00_0,  // cache (burst) write
     6'b0_1_0_00_0,  // single byte write
     6'b0_1_0_01_0,  // halfword write
     6'b0_1_0_11_0,  // word write
     6'b0_1_0_00_1,  // single byte writethru
     6'b0_1_0_01_1,  // halfword writethru
     6'b0_1_0_11_1,  // word writethru
     6'b0_0_0_00_0}  // nothing.
else $error(""Illegal request {read, write, burst, size, wt}=%0h"", {read, write, burst, size, wt});


// declarative assertion

assert property ( @(posedge clk) disable iff (reset_n)
  (data_valid != 1'sb1) || !$isunknown(data[31:0]) )
else $error(""Undriven data bus (%h) during data return"", data[31:0]);
","This image shows a page from a technical document detailing SystemVerilog assertion patterns. Specifically, it shows examples of assertions to check for valid transaction and for undriven data when valid.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p224.jpg,True,"Here is the Verilog code from the image:

```verilog
module fp_adder (output real result,
                 input var real a, b
                 );
...
endmodule
```","
module fp_adder (output real result,
                 input var real a, b
                 );
...
endmodule
","""Discussion on the use of real and shortreal types for floating point values in SystemVerilog module ports.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p132.jpg,True,"The image contains text discussing Verilog, its constructs, and memory arrays. It references a small snippet of Verilog code, which is as follows:

```verilog
reg[15:0] WideMemory[1023:0];
```

This line of code in Verilog declares a memory array named `WideMemory` consisting of 1024 locations (from `1023:0`), each location capable of storing a 16-bit vector (as indicated by `[15:0]`).","
reg[15:0] WideMemory[1023:0];
","The image contains text explaining the concepts of memory size definitions and Verilog arrays, with specific focus on how to model and calculate memory chip capacity and addressing, as well as how Verilog constructs are used to declare vectors and arrays for memory representation in digital design.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p542.jpg,True,"There is no Verilog code included in the image, rather there are lines in the text that discuss pieces of SystemVerilog properties. Here are the properties mentioned:

```systemverilog
m1: assume property (start |=> always !start);

m2: assume property (s_eventually(start && data_ready));
``` 

These are not complete Verilog code examples, but constraints written in SystemVerilog Assertion (SVA) which is used for formal verification in hardware description.","erilog
m1: assume property (start |=> always !start);

m2: assume property (s_eventually(start && data_ready));
","""Discussion of properties and assumptions in Verilog for formal verification""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p555.jpg,True,"```c
typedef struct t_setval_value
{
    int format;
    union
    {
        char *str;
        int scalar;
        int integer;
        double real;
        p_acc_vecval vector;
    } value;
} s_setval_value, *p_setval_value, s_acc_value, *p_acc_value;
```","ef struct t_setval_value
{
    int format;
    union
    {
        char *str;
        int scalar;
        int integer;
        double real;
        p_acc_vecval vector;
    } value;
} s_setval_value, *p_setval_value, s_acc_value, *p_acc_value;
",Verilog PLI Handbook excerpt showing the s_acc_value structure and its format constants for retrieving Verilog logic values into C data types.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p233.jpg,True,"The image includes code that seems to be part of a textbook or a technical document discussing Verilog simulations and VPI callbacks. Below is the transcribed code from the image:

```c
/* prototypes of routines in this PLI application */
int PLIbook_ReadSim_calltf(), PLIbook_ReadSim_compiletf();
int PLIbook_StartOfSim(), PLIbook_ReadNextStim(), PLIbook_ReadStimEnd();

/**********************************************************************
* Define storage structure for file pointer and vector handle.
**********************************************************************/
typedef struct ReadStimData {
    FILE *file_ptr;     /* test vector file pointer */
    vpiHandle obj_h;    /* pointer to store handle for a Verilog object */
    int mode;           /* 0 & 1 = binary values, 2 & 3 = hex values */
                        /* 0 & 2 = absolute time, 1 & 3 = relative time */
    int debug;          /* print debug messages if true */
} s_ReadStimData, *p_ReadStimData;

/**********************************************************************
* VPI Registration Data
**********************************************************************/
void PLIbook_ReadStim_register()
{
    s_vpi_systf_data tf_data;
    tf_data.type        = vpiSysTask;
    tf_data.calltf      = PLIbook_ReadSim_calltf;
    tf_data.compiletf   = PLIbook_ReadSim_compiletf;
    tf_data.sizetf      = NULL;

    tf_data.tfname      = ""$read_stimulus_ba""; /* binary, absolute time */
    tf_data.user_data   = ""ba"";
    vpi_register_systf(&tf_data);

    tf_data.tfname      = ""$read_stimulus_br""; /* binary, relative time */
    tf_data.user_data   = ""br"";
    vpi_register_systf(&tf_data);

    tf_data.tfname      = ""$read_stimulus_ha""; /* hex, absolute time */
    tf_data.user_data   = ""ha"";
    vpi_register_systf(&tf_data);

    tf_data.tfname      = ""$read_stimulus_hr""; /* hex, relative time */
    tf_data.user_data   = ""hr"";
    vpi_register_systf(&tf_data);
}

/**********************************************************************
* compiletf routine
**********************************************************************/
int PLIbook_ReadStim_compiletf(char *user_data)
{
    s_cb_data cb_data_s;
    vpiHandle systf_h, arg_itr, arg_h;
}
```

This is a sample C code in the context of a Verilog Procedural Interface (VPI), which is an interface to interact with Verilog simulations. The code shows the declaration of functions, a data structure, registration of system tasks, and the beginning of a function definition.","ototypes of routines in this PLI application */
int PLIbook_ReadSim_calltf(), PLIbook_ReadSim_compiletf();
int PLIbook_StartOfSim(), PLIbook_ReadNextStim(), PLIbook_ReadStimEnd();

/**********************************************************************
* Define storage structure for file pointer and vector handle.
**********************************************************************/
typedef struct ReadStimData {
    FILE *file_ptr;     /* test vector file pointer */
    vpiHandle obj_h;    /* pointer to store handle for a Verilog object */
    int mode;           /* 0 & 1 = binary values, 2 & 3 = hex values */
                        /* 0 & 2 = absolute time, 1 & 3 = relative time */
    int debug;          /* print debug messages if true */
} s_ReadStimData, *p_ReadStimData;

/**********************************************************************
* VPI Registration Data
**********************************************************************/
void PLIbook_ReadStim_register()
{
    s_vpi_systf_data tf_data;
    tf_data.type        = vpiSysTask;
    tf_data.calltf      = PLIbook_ReadSim_calltf;
    tf_data.compiletf   = PLIbook_ReadSim_compiletf;
    tf_data.sizetf      = NULL;

    tf_data.tfname      = ""$read_stimulus_ba""; /* binary, absolute time */
    tf_data.user_data   = ""ba"";
    vpi_register_systf(&tf_data);

    tf_data.tfname      = ""$read_stimulus_br""; /* binary, relative time */
    tf_data.user_data   = ""br"";
    vpi_register_systf(&tf_data);

    tf_data.tfname      = ""$read_stimulus_ha""; /* hex, absolute time */
    tf_data.user_data   = ""ha"";
    vpi_register_systf(&tf_data);

    tf_data.tfname      = ""$read_stimulus_hr""; /* hex, relative time */
    tf_data.user_data   = ""hr"";
    vpi_register_systf(&tf_data);
}

/**********************************************************************
* compiletf routine
**********************************************************************/
int PLIbook_ReadStim_compiletf(char *user_data)
{
    s_cb_data cb_data_s;
    vpiHandle systf_h, arg_itr, arg_h;
}
",Caption: Example of Verilog code showing VPI callback registration and implementation for synchronizing to Verilog simulations.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p224.jpg,True,"```verilog
checker stable_for_two_ticks(sig,
event clk = $inferred_clock, untyped rst = $inferred_disable);
default clocking @clk; endclocking
default disable iff rst;

bit toggle = 1'b0;
always_ff @clk
    toggle <= rst ? 1'b0 : !toggle;
    a1: assert property (!toggle |-> $stable(sig));
endchecker : stable_for_two_ticks
```","
checker stable_for_two_ticks(sig,
event clk = $inferred_clock, untyped rst = $inferred_disable);
default clocking @clk; endclocking
default disable iff rst;

bit toggle = 1'b0;
always_ff @clk
    toggle <= rst ? 1'b0 : !toggle;
    a1: assert property (!toggle |-> $stable(sig));
endchecker : stable_for_two_ticks
","Caption: ""Verilog code example showing a checker called 'stable_for_two_ticks' designed to ensure a signal remains stable for two clock cycles.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p228.jpg,True,"```verilog
class Impl;
  rand bit x;             // 0 or 1
  rand bit [1:0] y;       // 0, 1, 2, or 3
  constraint c_xy {
    (x==0) -> (y==0);
  }
endclass
```","
class Impl;
  rand bit x;             // 0 or 1
  rand bit [1:0] y;       // 0, 1, 2, or 3
  constraint c_xy {
    (x==0) -> (y==0);
  }
endclass
","""Example of a Verilog class with an implication constraint and its corresponding solution probabilities.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p227.jpg,True,"The image contains two snippets of Verilog code. Here they are:

Snippet 1:
```verilog
always @(a or b)
  $my_strobe(sum);
```

Snippet 2:
```verilog
always @(a or b)
  sum = a + b;
```

These code snippets are accompanied by text explaining the usage of a Verilog PLI callback function `$my_strobe`.","
always @(a or b)
  $my_strobe(sum);


always @(a or b)
  sum = a + b;
","""Understanding VPI Callbacks in Verilog Simulations"" - The image explains how to use VPI callbacks for synchronizing Verilog simulations and includes an example of Verilog code implementing a simulation callback.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p230.jpg,True,"The image contains Verilog code snippets. Here they are:

```verilog
checker out_inferred (in,
    output var type(in) out = '0,
    input event clk);
always_ff @clk
    out <= in;
```

```verilog
logic x, y, clock;
...
out_inferred good(x, y, posedge clock);
out_inferred bad(x, !y, posedge clock);
```

```verilog
wire dest;
logic src1, src2, clock;
...
out_inferred inst1(src1, dest, posedge clock);
out_inferred inst2(src2, dest, posedge clock);
```

These snippets are examples contained within a text discussing Verilog constructs, particularly with reference to the semantics of checker output arguments.","
checker out_inferred (in,
    output var type(in) out = '0,
    input event clk);
always_ff @clk
    out <= in;


logic x, y, clock;
...
out_inferred good(x, y, posedge clock);
out_inferred bad(x, !y, posedge clock);


wire dest;
logic src1, src2, clock;
...
out_inferred inst1(src1, dest, posedge clock);
out_inferred inst2(src2, dest, posedge clock);
","Caption: ""Excerpt from a technical document discussing Verilog semantics of checker output arguments and providing code examples of correct and incorrect usage of checker instances.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p541.jpg,True,"The image contains snippets of code along with some explanatory text. Here is the Verilog code extracted from the image:

```verilog
handle net_handle;

/* add code to get a net handle */

if (acc_object_of_type(net_handle, accScalar))
    /* process scalar nets */
else if (acc_object_of_type(net_handle, accVector))
    /* process vector nets */
```

And the function signature below the code snippet:

```c
void acc_fetch_location(location, object)
p_location location  /* pointer to an application-allocated s_location structure to receive the location. */
handle object        /* handle for an object */
```

The image also contains descriptions and examples of how these code snippets are used in the context of Verilog and the associated ACC (Application Call Interface) library functions.","
handle net_handle;

/* add code to get a net handle */

if (acc_object_of_type(net_handle, accScalar))
    /* process scalar nets */
else if (acc_object_of_type(net_handle, accVector))
    /* process vector nets */

acc_fetch_location(location, object)
p_location location  /* pointer to an application-allocated s_location structure to receive the location. */
handle object        /* handle for an object */
",The image discusses net collapsing in Verilog simulation and shows example code using the acc_object_of_type() function from the Verilog Programming Language Interface (PLI).,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p569.jpg,True,"The image contains sample Verilog HDL (Hardware Description Language) code. Here is the code from the image:

```verilog
module test;
    reg [7:0] reg1, reg2;
    initial
    begin
        reg1 = 0; reg2 = 0;
        $put_value(reg1, reg2);
        $display(""reg1=%d reg2=%d"", reg1, reg2);
        $strobe (""reg1=%d reg2=%d"", reg1, reg2);
        #1 $finish;
    end
endmodule
```

The text in the image explains the difference between no delay and zero delay in the context of Verilog PLI (Programming Language Interface) and illustrates the potential problem of putting a value into simulation using a delay of zero with this code snippet.","
module test;
    reg [7:0] reg1, reg2;
    initial
    begin
        reg1 = 0; reg2 = 0;
        $put_value(reg1, reg2);
        $display(""reg1=%d reg2=%d"", reg1, reg2);
        $strobe (""reg1=%d reg2=%d"", reg1, reg2);
        #1 $finish;
    end
endmodule
","""Explaining the distinction between no delay and zero delay in Verilog PLI with an example code snippet.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p137.jpg,True,"The image contains Verilog code. Here is the code from the image:

```verilog
((rw3==1'b1 || rw3==1'b0) && $isunknown (rw2) && $isunknown(rw2));
endproperty

Ss_chk5: Only one “rsel” signal shall be active at any given clock cycle, the other “rsel” signals should be tri-stated.

property p_rsel;
@(posedge clk)
$isunknown(rsel1) && $isunknown(rsel2) && $isunknown(rsel3) ) ||
((rsel1==1'b1 || rsel1==1'b0) && $isunknown (rsel2) && $isunknown(rsel3)) ||
((rsel2==1'b1 || rsel2==1'b0) && $isunknown(rsel1) && $isunknown(rsel3)) ||
((rsel3==1'b1 || rsel3==1'b0) && $isunknown(rsel2) && $isunknown(rsel1));
endproperty

Ss_chk6: Upon a valid request by a master, a valid “gnt” should arrive within 2 to 5 clock cycles.

assign req = !req1 || !req2 || !req3;
assign gnt = !gnt1 || !gnt2 || !gnt3;

property p_req_gnt_w;
@(posedge clk)
$rose (req) |-> ##[2:5] $rose(gnt);
endproperty

Ss_chk7: At any given clock, if the “frame” and “irdy” signal of a master are asserted, then the relevant “trdy” signal should be asserted after 3 clock cycles.

assign frame_ = !frame1 || !frame2 || !frame3;
assign irdy_ = !irdy1 || !irdy2 || !irdy3;

property p_start_frame;
@(posedge clk)
$rose (frame_ && irdy_) |->##3 $rose(trdy_);
endproperty
```

Note that the code samples are properties and assignments which are part of SystemVerilog assertions used primarily in verification to define certain conditions or behaviors that must be met in the design being verified.","
((rw3==1'b1 || rw3==1'b0) && $isunknown (rw2) && $isunknown(rw2));
endproperty

Ss_chk5: Only one “rsel” signal shall be active at any given clock cycle, the other “rsel” signals should be tri-stated.

property p_rsel;
@(posedge clk)
$isunknown(rsel1) && $isunknown(rsel2) && $isunknown(rsel3) ) ||
((rsel1==1'b1 || rsel1==1'b0) && $isunknown (rsel2) && $isunknown(rsel3)) ||
((rsel2==1'b1 || rsel2==1'b0) && $isunknown(rsel1) && $isunknown(rsel3)) ||
((rsel3==1'b1 || rsel3==1'b0) && $isunknown(rsel2) && $isunknown(rsel1));
endproperty

Ss_chk6: Upon a valid request by a master, a valid “gnt” should arrive within 2 to 5 clock cycles.

assign req = !req1 || !req2 || !req3;
assign gnt = !gnt1 || !gnt2 || !gnt3;

property p_req_gnt_w;
@(posedge clk)
$rose (req) |-> ##[2:5] $rose(gnt);
endproperty

Ss_chk7: At any given clock, if the “frame” and “irdy” signal of a master are asserted, then the relevant “trdy” signal should be asserted after 3 clock cycles.

assign frame_ = !frame1 || !frame2 || !frame3;
assign irdy_ = !irdy1 || !irdy2 || !irdy3;

property p_start_frame;
@(posedge clk)
$rose (frame_ && irdy_) |->##3 $rose(trdy_);
endproperty
","""Verilog code snippets showcasing properties for signal behaviors in synchronous digital circuits.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p214.jpg,True,"```verilog
`define SV_RAND_CHECK(r) \
  begin \
    if (!(r)) begin \
      $display(""%s:%0d: Randomization failed \""%s\"""", \
               `__FILE__, `__LINE__, ""<r>""); \
      $finish; \
    end \
  end while (0)

initial begin
  Packet p = new();                // Create a packet
  `SV_RAND_CHECK(p.randomize());   // Randomize it
end
```","
`define SV_RAND_CHECK(r) \
  begin \
    if (!(r)) begin \
      $display(""%s:%0d: Randomization failed \""%s\"""", \
               `__FILE__, `__LINE__, ""<r>""); \
      $finish; \
    end \
  end while (0)

initial begin
  Packet p = new();                // Create a packet
  `SV_RAND_CHECK(p.randomize());   // Randomize it
end
","""Verilog Randomization Check: Book segment on best practices for randomizing objects in tests and verifying randomization results using a macro.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p36.jpg,True,"There is a snippet of code in the image, as follows:

```verilog
assume final (go ^ ngo);
```","
assume final (go ^ ngo);
","""Using Assertions in Verilog for Equivalence Verification and Timing Analysis""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p218.jpg,True,"The image contains Verilog code. Here are the sections of code present in the image:

1. Positional Association example in module m1:
```verilog
module m1(input logic clk, rst, send, ack, ...);
    default clocking @(posedge clk); endclocking
    ...
    request_granted check(send, ack,,, rst);
endmodule : m1
```

2. Explicit Named Association example in module m2:
```verilog
module m2(input logic clk, rst, send, ack, ...);
    default clocking @(posedge clk); endclocking
    ...
    request_granted check(.rst(rst), .req(send), .gnt(ack));
endmodule : m2
```

3. Implicit Named Association example in module m3:
```verilog
module m3(input logic clk, rst, send, ack, ...);
    default clocking @(posedge clk); endclocking
    ...
    request_granted check(.rst, .req(send), .gnt(ack));
endmodule : m3
```","
module m1(input logic clk, rst, send, ack, ...);
    default clocking @(posedge clk); endclocking
    ...
    request_granted check(send, ack,,, rst);
endmodule : m1


module m2(input logic clk, rst, send, ack, ...);
    default clocking @(posedge clk); endclocking
    ...
    request_granted check(.rst(rst), .req(send), .gnt(ack));
endmodule : m2


module m3(input logic clk, rst, send, ack, ...);
    default clocking @(posedge clk); endclocking
    ...
    request_granted check(.rst, .req(send), .gnt(ack));
endmodule : m3
","Verilog code examples showing positional, explicit named, and implicit named association of module arguments.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p200.jpg,True,"The image contains examples of Verilog code specifically related to copying objects in Verilog, including using a copy function and writing a deep copy function. Here is the code available in the image:

Sample 5.34:
```
Transaction src, dst;
initial begin
  src = new(); // Create first object
  dst = src.copy(); // Make a copy of the object
end
```

Sample 5.35:
```
class Transaction;
  bit [31:0] addr, csm, data[8];
  Statistics stats; // Handle points to Statistics object
  static int count = 0;
  int id;

  function new();
    stats = new();
    id = count++;
  endfunction

  function Transaction copy();
    copy = new(); // Construct destination object
    copy.addr = addr; // Fill in data values
    copy.csm = csm;
    copy.data = data;
    copy.stats = stats.copy(); // Call Statistics::copy
  endfunction
endclass
```

Please note that ""Statistics::copy"" is mentioned in the comments, but the implementation for that is not provided in the image. It indicates that there is another class named `Statistics` that should also have a `copy` method to handle a deep copy for that type of object.","ction src, dst;
initial begin
  src = new(); // Create first object
  dst = src.copy(); // Make a copy of the object
end

Transaction;
  bit [31:0] addr, csm, data[8];
  Statistics stats; // Handle points to Statistics object
  static int count = 0;
  int id;

  function new();
    stats = new();
    id = count++;
  endfunction

  function Transaction copy();
    copy = new(); // Construct destination object
    copy.addr = addr; // Fill in data values
    copy.csm = csm;
    copy.data = data;
    copy.stats = stats.copy(); // Call Statistics::copy
  endfunction
endclass
","Caption: ""Implementing and using a deep copy function in Verilog for object-oriented design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p123.jpg,True,"The image contains Verilog code related to properties for SystemVerilog Assertions (SVA). Here are the code snippets shown in the image:

```verilog
property p_master_data2;
    @(posedge clk)
        ({$fell(trdy[0]) ##2 rw}) |-> 
        ($isunknown(data) == 0) [*7];
endproperty

property p_master_datao1;
    @(posedge clk)
        ({$fell(trdy[1]) ##3 !rw}) |->
        ($isunknown(data_o) == 0) [*7];
endproperty

property p_master_datao2;
    @(posedge clk)
        ({$fell(trdy[0]) ##3 !rw}) |->
        ($isunknown(data_o) == 0) [*7];
endproperty
```

Additionally, there is a Verilog module declaration with parameter declarations:

```verilog
module master(...);

// port declarations

parameter master_sva = 1'b1;
parameter master_sva_severity = 1'b1;
```

This code snippet is likely part of a discussion in the book about writing properties for checking the validity of data during read and write transactions within a SystemVerilog testbench.","
property p_master_data2;
    @(posedge clk)
        ({$fell(trdy[0]) ##2 rw}) |-> 
        ($isunknown(data) == 0) [*7];
endproperty

property p_master_datao1;
    @(posedge clk)
        ({$fell(trdy[1]) ##3 !rw}) |->
        ($isunknown(data_o) == 0) [*7];
endproperty

property p_master_datao2;
    @(posedge clk)
        ({$fell(trdy[0]) ##3 !rw}) |->
        ($isunknown(data_o) == 0) [*7];
endproperty


module master(...);

// port declarations

parameter master_sva = 1'b1;
parameter master_sva_severity = 1'b1;
","Caption: ""Excerpt from a document detailing Verilog SystemVerilog Assertions (SVA) for data validity checks in a master module during read and write transactions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p582.jpg,True,"```verilog
static int three_state[7] = {accBuff01Gate, accBuff11Gate,
                             accNotif0Gate, accNotif1Gate,
                             accTranif0Gate, accTranif1Gate, 0};

acc_initialize();
acc_configure(accDisplayWarnings, ""true"");

acc_configure(accMinTypMaxDelays, ""false"");

module_h = acc_handle_tfarg(1);
io_printf(""\nPrimitives in module %s:\n"", acc_fetch_fullname(module_h));

prim_h = null;  /* start with known value for target handle */
while (prim_h = acc_next_primitive(module_h, prim_h)) {
    io_printf(""    %-8s instance %-4s: "", acc_fetch_defname(prim_h),
              acc_fetch_name(prim_h));

    if (acc_object_in_typelist(prim_h, three_state)) {
        acc_fetch_delays(prim_h, &rise, &fall, &toz);
        io_printf(""rise=%2.2f, fall=%2.2f, toz=%2.2f\n"", rise, fall, toz);
    }
    else {
        acc_fetch_delays(prim_h, &rise, &fall);
        io_printf(""rise=%2.2f, fall=%2.2f\n"", rise, fall);
    }
}

acc_close();
return(0);
```

The code in the image is written in Verilog and seems to be related to accessing and modifying values in a simulation of a Verilog model using ACC (Access) routines. It discusses some functionality to read delays and configure objects, which is typically done in testbenches or simulation environments.","
static int three_state[7] = {accBuff01Gate, accBuff11Gate,
                             accNotif0Gate, accNotif1Gate,
                             accTranif0Gate, accTranif1Gate, 0};

acc_initialize();
acc_configure(accDisplayWarnings, ""true"");

acc_configure(accMinTypMaxDelays, ""false"");

module_h = acc_handle_tfarg(1);
io_printf(""\nPrimitives in module %s:\n"", acc_fetch_fullname(module_h));

prim_h = null;  /* start with known value for target handle */
while (prim_h = acc_next_primitive(module_h, prim_h)) {
    io_printf(""    %-8s instance %-4s: "", acc_fetch_defname(prim_h),
              acc_fetch_name(prim_h));

    if (acc_object_in_typelist(prim_h, three_state)) {
        acc_fetch_delays(prim_h, &rise, &fall, &toz);
        io_printf(""rise=%2.2f, fall=%2.2f, toz=%2.2f\n"", rise, fall, toz);
    }
    else {
        acc_fetch_delays(prim_h, &rise, &fall);
        io_printf(""rise=%2.2f, fall=%2.2f\n"", rise, fall);
    }
}

acc_close();
return(0);
","""Example of Verilog ACC (Application Component Interface) routine usage for reading and modifying delay values.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p442.jpg,True,"Here is the Verilog code from the image:

```verilog
...
case ({ReadReq, WriteReq})
  2'b01: begin
    incrWrite('1'b1); // On a write.
    ReadCmdr = '1'b0;
  end
  2'b10: begin
    incrRead('1'b1); // On a read.
    WriteCmdr = '1'b0;
  end
  2'b11: // On a read and write:
  begin
    incrRead('1'b1);
    incrWrite('1'b1);
  end
  default: begin // No request pending, so deassert both:
    ReadCmdr = '1'b0;
    WriteCmdr = '1'b0;
  end
endcase
...
```

The code involves a case statement evaluating the conditions of read and write requests and acting accordingly.","
...
case ({ReadReq, WriteReq})
  2'b01: begin
    incrWrite('1'b1); // On a write.
    ReadCmdr = '1'b0;
  end
  2'b10: begin
    incrRead('1'b1); // On a read.
    WriteCmdr = '1'b0;
  end
  2'b11: // On a read and write:
  begin
    incrRead('1'b1);
    incrWrite('1'b1);
  end
  default: begin // No request pending, so deassert both:
    ReadCmdr = '1'b0;
    WriteCmdr = '1'b0;
  end
endcase
...
","Caption: ""Sample Verilog code demonstrating the use of a case statement to handle read and write requests in a digital design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p457.jpg,True,"```verilog
// SerDesFormats.inc:
localparam[0:0] YES = 1'b1; // Readability experiment.
localparam[0:0] NO = 1'b0; // """"
localparam[7:0] PAD3 = 8'b000_11_000;
localparam[7:0] PAD2 = 8'b000_10_000;
localparam[7:0] PAD1 = 8'b000_01_000;
localparam[7:0] PAD0 = 8'b000_00_000;
```

This is the Verilog code snippet visible in the image, contained within a commented section meant to indicate inclusion of a file or code meant for configuration of certain parameters in a Verilog file.","
// SerDesFormats.inc:
localparam[0:0] YES = 1'b1; // Readability experiment.
localparam[0:0] NO = 1'b0; // """"
localparam[7:0] PAD3 = 8'b000_11_000;
localparam[7:0] PAD2 = 8'b000_10_000;
localparam[7:0] PAD1 = 8'b000_01_000;
localparam[7:0] PAD0 = 8'b000_00_000;
",Schematic and Verilog code snippet for a Serializer circuit used in Digital VLSI Design.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p506.jpg,True,"The image contains two blocks of code which I will transcribe for you.

The left block represents the `initialize` and `enqueue` functions:

```verilog
structure node_t {
    value: value_t;
    next: ptr to node_t
}

initialize(Q: ptr to queue_t)
    // Make dummy node
    node = new_node()
    node->next = NULL
    Q->headlock = node
    Q->headlock->taillock = FREE
    Q->taillock = FREE

enqueue (Q: ptr to queue_t,
         value: value_t)
    node = new_node()
    node->value = value
    node->next = NULL
    lock(&(Q->taillock))
    Q->tail->next = node
    Q->tail = node
    unlock(&(Q->taillock))
```

The right block represents the `structure` declaration for `queue_t` and the `dequeue` function:

```verilog
structure queue_t {
    head: ptr to node_t;
    tail: ptr to node_t;
    headlock: lock_t;
    taillock: lock_t;
}

dequeue (Q: ptr to queue_t,
         pvalue: ptr to value_t)
    lock(&(Q->headlock))
    node = Q->head
    new_head = node->next
    if new_head == NULL
        // queue empty
        unlock(&(Q->headlock))
        return false
    endif
    *pvalue = new_head->value
    Q->head = new_head
    unlock(&(Q->headlock))
    free(node)
    return true
```

These blocks of code are part of a discussion on the two-lock queue implementation by Michael and Scott, specifically tailored for use with Verilog-like pseudocode used to illustrate a concurrent data structure.","
structure node_t {
    value: value_t;
    next: ptr to node_t
}

initialize(Q: ptr to queue_t)
    // Make dummy node
    node = new_node()
    node->next = NULL
    Q->headlock = node
    Q->headlock->taillock = FREE
    Q->taillock = FREE

enqueue (Q: ptr to queue_t,
         value: value_t)
    node = new_node()
    node->value = value
    node->next = NULL
    lock(&(Q->taillock))
    Q->tail->next = node
    Q->tail = node
    unlock(&(Q->taillock))


structure queue_t {
    head: ptr to node_t;
    tail: ptr to node_t;
    headlock: lock_t;
    taillock: lock_t;
}

dequeue (Q: ptr to queue_t,
         pvalue: ptr to value_t)
    lock(&(Q->headlock))
    node = Q->head
    new_head = node->next
    if new_head == NULL
        // queue empty
        unlock(&(Q->headlock))
        return false
    endif
    *pvalue = new_head->value
    Q->head = new_head
    unlock(&(Q->headlock))
    free(node)
    return true
",An excerpt from a document showcasing implementations of enqueue and dequeue operations for a concurrent two-lock queue in Verilog.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p443.jpg,True,"The image contains Verilog code. Here is the code that is visible in the image:

```verilog
...
always@(negedge StateClock, posedge Reset)
begin
    if (Reset==1'b1)
        begin // Reset conditions:
            NextState = emptyS;
            incrRead(1'b0); // 0 -> reset counter.
            incrWrite(1'b0); // 0 -> reset counter.
        end
    else
        case (CurState)
            emptyS: // (The other previously combinational logic goes here)
            ...
        endcase
...
```

This Verilog code snippet is likely part of a larger design and involves conditional logic for a state machine used in a FIFO (First-In-First-Out) buffer. It specifies behavior for the negative edge of a clock signal `StateClock` and for the positive edge of a reset signal `Reset`.","
...
always@(negedge StateClock, posedge Reset)
begin
    if (Reset==1'b1)
        begin // Reset conditions:
            NextState = emptyS;
            incrRead(1'b0); // 0 -> reset counter.
            incrWrite(1'b0); // 0 -> reset counter.
        end
    else
        case (CurState)
            emptyS: // (The other previously combinational logic goes here)
            ...
        endcase
...
","""Verilog example of a clocked combinatorial block for a FIFO state machine design""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p325.jpg,True,"```verilog
tranif0 UpperTran(Out, In1, Sel);
tranif1 LowerTran(Out, In2, Sel);
```

These are the Verilog code lines found in the image.","
tranif0 UpperTran(Out, In1, Sel);
tranif1 LowerTran(Out, In2, Sel);
","""Verilog simulation of a CMOS 2-input multiplexer using pass transistor logic.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p597.jpg,True,"```verilog
module and3 (out, in1, in2, in3);
    output out;
    input in1, in2, in3;
    ...
    specify
        (in1 => out) = (4, 6);
        (in2 => out) = (4, 5);
        (in3 => out) = (3, 4);

        specparam PATHPULSE$in1$out = 2, 3;
        specparam PATHPULSE$ = 0, 4;
    endspecify
endmodule
```

The image contains a snippet of Verilog code which defines a module named `and3` with an `output` named `out` and `input` pins named `in1`, `in2`, and `in3`. It includes a `specify` block which is used for specifying timing constraints. In the `specify` block, there are timing constraints for the paths from inputs `in1`, `in2`, and `in3` to the output `out`, along with two `specparam` (specific parameters) definitions that include path pulse limitations for the module.","
module and3 (out, in1, in2, in3);
    output out;
    input in1, in2, in3;
    ...
    specify
        (in1 => out) = (4, 6);
        (in2 => out) = (4, 5);
        (in3 => out) = (3, 4);

        specparam PATHPULSE$in1$out = 2, 3;
        specparam PATHPULSE$ = 0, 4;
    endspecify
endmodule
","Caption: ""Extract from 'The Verilog PLI Handbook' showing a Verilog module with path pulse specifications and an explanation of `specparam` attributes and ACC routine usage.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p201.jpg,True,"```verilog
class Statistics;
    time startT;  // Transaction times
    ...
    // See Sample 5-22 for rest of class
    function Statistics copy();
        copy = new();
        copy.startT = startT;
    endfunction
endclass

Transaction src, dst;
initial begin
    src = new();                        // Create first object
    src.stats.startT = 42;              // Set start time
    dst = src.copy();                   // Deep copy src to dst
    dst.stats.startT = 96;              // Changes stats for dst only
    $display(src.stats.startT);         // ""42"", See Figure 5-8
end
```","
class Statistics;
    time startT;  // Transaction times
    ...
    // See Sample 5-22 for rest of class
    function Statistics copy();
        copy = new();
        copy.startT = startT;
    endfunction
endclass

Transaction src, dst;
initial begin
    src = new();                        // Create first object
    src.stats.startT = 42;              // Set start time
    dst = src.copy();                   // Deep copy src to dst
    dst.stats.startT = 96;              // Changes stats for dst only
    $display(src.stats.startT);         // ""42"", See Figure 5-8
end
","""Verilog Object-Oriented Programming Example Demonstrating Deep Copy of Objects""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p122.jpg,True,"The image contains Verilog code which is written in the SystemVerilog Assertions (SVA) format. Here is the code:

```verilog
endproperty

Master_chk2: Upon a valid request from a master, the grant shall come within 2 to 5 clock cycles. If so and if the signal “r_sel” is low, then on the same clock cycle, the master should assert the signals “frame” and “irdy.” Three cycles later the target device zero should acknowledge its selection by asserting the signal “trdy.”

property p_master_start2;
    @(posedge clk)
    $fell (req) ##[2:5] ($fell(gnt) && !r_sel)) |-> (!frame && !irdy) ##3 !trdy[1];
endproperty

Master_chk3: Once the target acknowledges its selection, the master should complete its transaction within 10 clock cycles. It should indicate the transaction completion by de-asserting the signals “frame” and “irdy.” One cycle later the signal “gnt” should be de-asserted.

property p_master_stop1;
    @(posedge clk)
    $fell (trdy[1]) |-> ##10 (frame && irdy) ##1 gnt;
endproperty

property p_master_stop2;
    @(posedge clk)
    $fell (trdy[0]) |-> ##10 (frame && irdy) ##1 gnt;
endproperty

Note that two separate properties are written to check the transaction completion, one for each target device.

Master_chk4: If the master is in a write transaction, then the bus data (data_c) should not be tri-stated and should have valid data.

property p_master_data1;
    @(posedge clk)
    $fell (trdy[1]) ##2 rw) |-> ($isunknown(data) == 0) [*7];
endproperty
```

This code is used for checking various conditions (properties) in a digital design using assertions which are part of formal verification methods. The text surrounding the code explains how the bus communication protocol should work related to the assertions that are formulated in the given properties.","
endproperty

Master_chk2: Upon a valid request from a master, the grant shall come within 2 to 5 clock cycles. If so and if the signal “r_sel” is low, then on the same clock cycle, the master should assert the signals “frame” and “irdy.” Three cycles later the target device zero should acknowledge its selection by asserting the signal “trdy.”

property p_master_start2;
    @(posedge clk)
    $fell (req) ##[2:5] ($fell(gnt) && !r_sel)) |-> (!frame && !irdy) ##3 !trdy[1];
endproperty

Master_chk3: Once the target acknowledges its selection, the master should complete its transaction within 10 clock cycles. It should indicate the transaction completion by de-asserting the signals “frame” and “irdy.” One cycle later the signal “gnt” should be de-asserted.

property p_master_stop1;
    @(posedge clk)
    $fell (trdy[1]) |-> ##10 (frame && irdy) ##1 gnt;
endproperty

property p_master_stop2;
    @(posedge clk)
    $fell (trdy[0]) |-> ##10 (frame && irdy) ##1 gnt;
endproperty

Note that two separate properties are written to check the transaction completion, one for each target device.

Master_chk4: If the master is in a write transaction, then the bus data (data_c) should not be tri-stated and should have valid data.

property p_master_data1;
    @(posedge clk)
    $fell (trdy[1]) ##2 rw) |-> ($isunknown(data) == 0) [*7];
endproperty
","Caption: ""Excerpt from a technical document detailing SystemVerilog Assertions (SVA) for simulation methodology and verification properties related to bus transaction protocols.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p494.jpg,True,"```
...
reg AllDone;  // Flag completion of testing for internal BIST use.
reg Testing;  // Sets test mode for the BIST.
//
assign Testing = Testingr;  // Testing is a BIST output port.
//
always@(posedge Clk, posedge Reset)
begin : TestSequencer
    if (Reset=='b1)
        begin
            Testingr <= 'b0;
            AllDone <= 'b0;  // Normal level (noncommittal).
            ...
        end
        else
        // Must be a clock:
        begin : TestClocked
            if (DoSelfTest=='b0)
                begin  // Init, but leave TestOK alone:
                    Testingr <= 'b0;
                    AllDone <= 'b0;
                    ...
                end
                else
                    Testingr <= 'b1';  // Entering test mode for this clock.
                    ...
                    ...
```

Please note that there is some ellipsis (`...`) included in the code as in the original image, which indicates that the code snippet is not complete and parts of the source code are omitted.","g AllDone;  // Flag completion of testing for internal BIST use.
reg Testing;  // Sets test mode for the BIST.
//
assign Testing = Testingr;  // Testing is a BIST output port.
//
always@(posedge Clk, posedge Reset)
begin : TestSequencer
    if (Reset=='b1)
        begin
            Testingr <= 'b0;
            AllDone <= 'b0;  // Normal level (noncommittal).
            ...
        end
        else
        // Must be a clock:
        begin : TestClocked
            if (DoSelfTest=='b0)
                begin  // Init, but leave TestOK alone:
                    Testingr <= 'b0;
                    AllDone <= 'b0;
                    ...
                end
                else
                    Testingr <= 'b1';  // Entering test mode for this clock.
                    ...
                    ...
","Caption: Excerpt from a digital VLSI design textbook showing an example of Verilog code for a BIST (Built-In Self Test) implementation, along with instructional commentary on optional project work.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p136.jpg,True,"The image contains Verilog code in the form of SystemVerilog assertions. Here is the code:

```verilog
property p_target;
    @(posedge clk) not (|trdy[0] && |trdy[1]);
endproperty

property p_frame;
    @(posedge clk)
        $countones({frame1, frame2, frame3}) >1;
endproperty

property p_irdy;
    @(posedge clk)
        $countones({irdy1, irdy2, irdy3}) >1;
endproperty

property p_gnt;
    @(posedge clk)
        $countones({gnt1, gnt2, gnt3}) > 1;
endproperty

property p_rw;
    @(posedge clk)
        ($isunknown(rw1) && $isunknown(rw2) && $isunknown(rw3) ) ||
        ((rw1=='b1 || rw1=='b0) && $isunknown (rw2) && $isunknown (rw3)) ||
        ((rw2=='b1 || rw2=='b0) && $isunknown (rw1) && $isunknown (rw3)) ||
        ((rw3=='b1 || rw3=='b0) && $isunknown (rw1) && $isunknown (rw2));
endproperty
```

These properties are defined to enforce certain conditions in the simulation of a hardware design. Each property uses a `@(posedge clk)` event to specify that the property should be evaluated at the rising edge of the clock signal `clk`. The SystemVerilog `$countones` function counts the number of '1' bits in the argument and then these properties check that there is no more than one '1' being asserted at a time for certain signals, ensuring mutual exclusivity. The `$isunknown` function is used to check if the values of certain signals are unknown (x or z in Verilog).","
property p_target;
    @(posedge clk) not (|trdy[0] && |trdy[1]);
endproperty

property p_frame;
    @(posedge clk)
        $countones({frame1, frame2, frame3}) >1;
endproperty

property p_irdy;
    @(posedge clk)
        $countones({irdy1, irdy2, irdy3}) >1;
endproperty

property p_gnt;
    @(posedge clk)
        $countones({gnt1, gnt2, gnt3}) > 1;
endproperty

property p_rw;
    @(posedge clk)
        ($isunknown(rw1) && $isunknown(rw2) && $isunknown(rw3) ) ||
        ((rw1=='b1 || rw1=='b0) && $isunknown (rw2) && $isunknown (rw3)) ||
        ((rw2=='b1 || rw2=='b0) && $isunknown (rw1) && $isunknown (rw3)) ||
        ((rw3=='b1 || rw3=='b0) && $isunknown (rw1) && $isunknown (rw2));
endproperty
","""Excerpt from a document outlining SVA (SystemVerilog Assertions) simulation methodology with properties for checking signal assertions in a digital system.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p568.jpg,True,"The image contains two code snippets, one written in Verilog and the other in C for interacting with Verilog code. Here is the Verilog code:

```verilog
reg [22:0] input_vector;

always @(posedge clock)
    $read_test_vector(""vector_file.pat"", input_vector);
```

And here is the C code snippet:

```c
handle tfarg_h;
char test_vector[1024];
double delay;
s_acc_value value_s;
s_setval_delay delay_s;

/* read test value and delay from file */

tfarg_h = acc_handle_tfarg(2);
value_s.format = accStrBinVal;
value_s.value.str = test_vector;
delay_s.model = accTransportDelay;
delay_s.time.type = accRealTime;
delay_s.time.real = delay;

acc_set_value(tfarg_h, &value_s, &delay_s);
```

These code snippets are demonstrating how to read and modify values using ACC routines in a Verilog simulation environment. The Verilog code describes a register and a procedural block that reads a test vector from a file. The C code is used to set these test vectors in the context of the simulation using the Verilog PLI (Programming Language Interface).","
reg [22:0] input_vector;

always @(posedge clock)
    $read_test_vector(""vector_file.pat"", input_vector);

e tfarg_h;
char test_vector[1024];
double delay;
s_acc_value value_s;
s_setval_delay delay_s;

/* read test value and delay from file */

tfarg_h = acc_handle_tfarg(2);
value_s.format = accStrBinVal;
value_s.value.str = test_vector;
delay_s.model = accTransportDelay;
delay_s.time.type = accRealTime;
delay_s.time.real = delay;

acc_set_value(tfarg_h, &value_s, &delay_s);
","The image depicts a page from a technical document explaining ACC (Application Component Controller) routines for reading and modifying values in Verilog, including a snippet of Verilog code and its corresponding C code to interface with system tasks.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p219.jpg,True,"Here is the Verilog code from the image:

First snippet:
```verilog
module m4(input logic clk, rst, req, gnt, ...);
    default clocking @(posedge clk); endclocking
    ...
    request_granted check(.*, .clk());
endmodule : m4
```

Second snippet:
```verilog
checker check(a, b, event clk);
    a1: assert property (@clk a |=> b);
endchecker : check

module m1(input logic clock, req, ack);
    ...
    check mycheck(req, ack, posedge clock);
endmodule : m1
```","
module m4(input logic clk, rst, req, gnt, ...);
    default clocking @(posedge clk); endclocking
    ...
    request_granted check(.*, .clk());
endmodule : m4


checker check(a, b, event clk);
    a1: assert property (@clk a |=> b);
endchecker : check

module m1(input logic clock, req, ack);
    ...
    check mycheck(req, ack, posedge clock);
endmodule : m1
","Excerpt on Checker Instantiation and Wildcard Named Association in Verilog, with example code for module definition and checker instantiation.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p215.jpg,True,"```verilog
class Child;
  bit [7:0] age; // Error – should be rand or randc
  constraint c_teenager {age > 12;
                         age < 20;}
endclass
```","
class Child;
  bit [7:0] age; // Error – should be rand or randc
  constraint c_teenager {age > 12;
                         age < 20;}
endclass
","Caption: ""Excerpt from a textbook detailing how the constraint solver works in SystemVerilog, with an example of a class with a constraint block that fails to randomize due to a missing 'rand' or 'randc' keyword.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p231.jpg,True,"Yes, there is code in this image. Here is the Verilog code present:

```verilog
checker mutex (
    sig,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable,
    output bit failure = 1'b0);
    
    default clocking @clk; endclocking
    default disable iff rst;
    a1: assert property ($onehot0(sig))
        failure = 1'b0; else failure = 1'b1;
endchecker : mutex

module m(input wire bus, logic clock, reset);
    logic res, scan;
    ...
    check_bus(bus, posedge clock, reset, res);
    always @(posedge clock) scan <= res;
endmodule : m
```

This excerpt looks like it's from a textbook or academic paper discussing Verilog checkers with output arguments and providing an example of how to instantiate a checker.","
checker mutex (
    sig,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable,
    output bit failure = 1'b0);
    
    default clocking @clk; endclocking
    default disable iff rst;
    a1: assert property ($onehot0(sig))
        failure = 1'b0; else failure = 1'b1;
endchecker : mutex

module m(input wire bus, logic clock, reset);
    logic res, scan;
    ...
    check_bus(bus, posedge clock, reset, res);
    always @(posedge clock) scan <= res;
endmodule : m
","A textbook page containing a section on ""Returning Assertion Status from Checkers"" in Verilog, along with an example of a checker module named `mutex` that verifies mutual exclusiveness and returns an assertion status.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p193.jpg,True,"The image contains Verilog code. Here it is:

```verilog
always @(posedge ck250)
begin
    r_cs <= rst_ ? c_cs : 0;
    r_del <= c_del;
    r_avail <= c_avail;
    r_n1 <= rst_ ? c_n1 : 0;
    r_n2 <= rst_ ? c_n2 : 0;
    r_n3 <= rst_ ? c_n3 : 0;
    r_n4 <= rst_ ? c_n4 : 0;
    r_n5 <= rst_ ? c_n5 : 0;
    r_n6 <= rst_ ? c_n6 : 0;
end
```

And also:

```verilog
dff_r_reg_cs (r_cs, ck250, rst_, c_cs);
dff_r5_reg_del (r_del, ck250, c_del);
dff_r5_reg_avail (r_avail, ck250, c_avail);
dff_r5_reg_n1 (r_n1, ck250, rst_, c_n1);
dff_r5_reg_n2 (r_n2, ck250, rst_, c_n2);
dff_r5_reg_n3 (r_n3, ck250, rst_, c_n3);
dff_r5_reg_n4 (r_n4, ck250, rst_, c_n4);
dff_r5_reg_n5 (r_n5, ck250, rst_, c_n5);
dff_r5_reg_n6 (r_n6, ck250, rst_, c_n6);
```

These code snippets show two styles of implementing flip-flops in Verilog within a module. The left side shows them in-line, while the right side shows them instantiated in a module.","
always @(posedge ck250)
begin
    r_cs <= rst_ ? c_cs : 0;
    r_del <= c_del;
    r_avail <= c_avail;
    r_n1 <= rst_ ? c_n1 : 0;
    r_n2 <= rst_ ? c_n2 : 0;
    r_n3 <= rst_ ? c_n3 : 0;
    r_n4 <= rst_ ? c_n4 : 0;
    r_n5 <= rst_ ? c_n5 : 0;
    r_n6 <= rst_ ? c_n6 : 0;
end


dff_r_reg_cs (r_cs, ck250, rst_, c_cs);
dff_r5_reg_del (r_del, ck250, c_del);
dff_r5_reg_avail (r_avail, ck250, c_avail);
dff_r5_reg_n1 (r_n1, ck250, rst_, c_n1);
dff_r5_reg_n2 (r_n2, ck250, rst_, c_n2);
dff_r5_reg_n3 (r_n3, ck250, rst_, c_n3);
dff_r5_reg_n4 (r_n4, ck250, rst_, c_n4);
dff_r5_reg_n5 (r_n5, ck250, rst_, c_n5);
dff_r5_reg_n6 (r_n6, ck250, rst_, c_n6);
","Caption: ""Comparison of in-lined flip-flops vs. instantiated flip-flops in Verilog code, alongside a discussion on RTL X State in digital design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p37.jpg,True,"```verilog
sequence s2;
    @(posedge clk) $rose(a);
endsequence
```","
sequence s2;
    @(posedge clk) $rose(a);
endsequence
","Caption: ""Details and example of edge-sensitive sequence definitions in Verilog, featuring built-in functions $rose, $fell, and $stable with a sample sequence for detecting a rising edge on signal 'a'.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p75.jpg,True,"The image contains Verilog code snippets. Here are the extracted code sections:

```verilog
module ControlUnit:
var s: [0..3] // 0=waiting, 1=alarm raised, 2=fd called, 3=disabled
input fire: { local: s = 0 || s = 1 ==> s' := 1
             else s = 2
           }
input disable: { local: true ==> s' := 3 }
output call_fd: { s = 1 ==> s' = 2 }
endmodule

module FireDetector1:
var s: [0..2] // 0=idle, 1=smoke detected, 2=inactive
input smoke1: { local: s = 0 || s = 1 ==> s' := 1
              else s = 2
            } // do nothing if inactive
output fire: { s = 1 ==> s' = 2 }
input fire: { } // accepts (and ignores) fire inputs
input disable: { local: true ==> s' := 2 }
endmodule

module Faulty_FireDetector2:
var s: [0..2] // 0=idle, 1=smoke detected, 2=inactive
input smoke2: { local: s = 0 || s = 1 ==> s' := 1
              else s = 2
            } // do nothing if inactive
output fire: { s = 1 ==> s' = 2 }
input fire: { } // accepts (and ignores) fire inputs
// does not listen to disable action
endmodule
```

These code snippets appear to be describing modules for a fire detection and control system in Verilog, with representations of different states and transitions within each module.","
module ControlUnit:
var s: [0..3] // 0=waiting, 1=alarm raised, 2=fd called, 3=disabled
input fire: { local: s = 0 || s = 1 ==> s' := 1
             else s = 2
           }
input disable: { local: true ==> s' := 3 }
output call_fd: { s = 1 ==> s' = 2 }
endmodule

module FireDetector1:
var s: [0..2] // 0=idle, 1=smoke detected, 2=inactive
input smoke1: { local: s = 0 || s = 1 ==> s' := 1
              else s = 2
            } // do nothing if inactive
output fire: { s = 1 ==> s' = 2 }
input fire: { } // accepts (and ignores) fire inputs
input disable: { local: true ==> s' := 2 }
endmodule

module Faulty_FireDetector2:
var s: [0..2] // 0=idle, 1=smoke detected, 2=inactive
input smoke2: { local: s = 0 || s = 1 ==> s' := 1
              else s = 2
            } // do nothing if inactive
output fire: { s = 1 ==> s' = 2 }
input fire: { } // accepts (and ignores) fire inputs
// does not listen to disable action
endmodule
","""An excerpt from a document discussing the interface compatibility and composition for a fire detection control system using Verilog code modules.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p540.jpg,True,"The image contains excerpts from a document, with information about Verilog ACC (access) routines and special-type properties relevant to Verilog nets. There is Verilog code included within the document. Here's the code present in the image:

```verilog
wire scalared [63:0] data_bus;

wire vectored [31:0] address_bus;
```","
wire scalared [63:0] data_bus;

wire vectored [31:0] address_bus;
","A textbook page discussing special-type properties in Verilog for nets and vectors, with an emphasis on handling objects in simulation using ACC routines.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p554.jpg,True,"The image contains C code that interfaces with Verilog simulations through the ACC (access) routines provided in Verilog PLI (Programming Language Interface). The code is used for listing net values in a module, using the function `acc_fetch_value()` to read the values as strings. Here is the code snippet from the image:

```c
#include ""veriuser.h""                /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""                /* IEEE 1364 PLI ACC routine library */
/**********************************************************************/
/* calltf application                                                 */
/**********************************************************************/
PLIbook_ListNets_calltf()                                        
{                                                                   
    handle module_h, net_h;                                        
    acc_initialize();                                              
    module_h = acc_handle_targ(1);                                 
    io_printf(""\nNet values in module %s:\n"",                       
              acc_fetch_fullname(module_h));                         
    net_h = null;              /* start with known value for target handle */
    while (net_h = acc_next_net(module_h, net_h)) {                
        io_printf("" %-10s: %s\n"",                                   
                  acc_fetch_name(net_h),                             
                  acc_fetch_value(net_h, ""%b"", null));            
    }                                                               
    acc_close();                                                    
    return(0);                                                      
}
```

The note indicates that the value retrieved from `acc_fetch_value()` for any C string representations will be stored in the ACC string buffer, and that the ACC string buffer storage is temporary, so the value should be used immediately or copied into application-allocated memory.","ude ""veriuser.h""                /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""                /* IEEE 1364 PLI ACC routine library */
/**********************************************************************/
/* calltf application                                                 */
/**********************************************************************/
PLIbook_ListNets_calltf()                                        
{                                                                   
    handle module_h, net_h;                                        
    acc_initialize();                                              
    module_h = acc_handle_targ(1);                                 
    io_printf(""\nNet values in module %s:\n"",                       
              acc_fetch_fullname(module_h));                         
    net_h = null;              /* start with known value for target handle */
    while (net_h = acc_next_net(module_h, net_h)) {                
        io_printf("" %-10s: %s\n"",                                   
                  acc_fetch_name(net_h),                             
                  acc_fetch_value(net_h, ""%b"", null));            
    }                                                               
    acc_close();                                                    
    return(0);                                                      
}
","""Verilog ACC Routine Example for Reading Net Values as Strings""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p187.jpg,True,"The image includes an excerpt from a document that discusses RTL (Register Transfer Level) style in Verilog programming. Verilog code is presented, with an illustration of end identification comments in Verilog designs. Here is the code excerpt from the image:

```verilog
module respsend (
    ...
function [6:0] start_pointer;
    ...
endfunction // start_pointer
    
...
always @(r_pop_cnt ...
begin
    ...
end // always @(r_pop_cnt
...
endmodule // respsend
```

In Verilog, comments used for end identification help to clarify which block, function, or module an end statement is closing, which is especially useful in large Verilog codebases.","
module respsend (
    ...
function [6:0] start_pointer;
    ...
endfunction // start_pointer
    
...
always @(r_pop_cnt ...
begin
    ...
end // always @(r_pop_cnt
...
endmodule // respsend
",Verilog Code Example: Demonstrating end identification comments for readability in large modules.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p229.jpg,True,"The image includes two samples of Verilog code. Here is the transcription of both:

Sample 6.30:
```verilog
class Imp2;
  rand bit x;           // 0 or 1
  rand bit [1:0] y;     // 0, 1, 2, or 3
  constraint c_xy {
    y > 0;              // Force y = 1, 2, or 3
    (x==0) -> (y==0);
  }
endclass
```

Sample 6.31:
```verilog
class SolveXBeforeY;
  rand bit x;           // 0 or 1
  rand bit [1:0] y;     // 0, 1, 2, or 3
  constraint c_xy {
    (x==0) -> y==0;
    solve x before y;
  }
endclass
```","
class Imp2;
  rand bit x;           // 0 or 1
  rand bit [1:0] y;     // 0, 1, 2, or 3
  constraint c_xy {
    y > 0;              // Force y = 1, 2, or 3
    (x==0) -> (y==0);
  }
endclass


class SolveXBeforeY;
  rand bit x;           // 0 or 1
  rand bit [1:0] y;     // 0, 1, 2, or 3
  constraint c_xy {
    (x==0) -> y==0;
    solve x before y;
  }
endclass
","Caption: ""The image shows excerpts from a document explaining SystemVerilog constraints with examples of Verilog code, including classes with implication constraints and solve...before directives.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p225.jpg,True,"The image contains two Verilog code examples. Here is the code:

Example 9.21:
```verilog
checker check(...);
  bit a;
  ...
endchecker : check

module m_illegal(...);
  ...
  check mycheck(...);
  ...
  wire b;
  assign b = mycheck.a;
endmodule : m
```

Example 9.22:
```verilog
checker stable_for_n_ticks(sig, n,
  event clk = $inferred_clock,
  untyped rst = $inferred_disable);

  default clocking @clk; endclocking
  default disable iff rst;
  bit [$clog2(n)-1:0] ctr = '0;

  always_ff @clk begin
    if (rst) ctr <= 1;
    else if (ctr == n - 1) ctr <= 0;
    else ctr <= ctr + 1;
  end

  a1: assert property (($changed(sig) |-> ctr == 0);
endchecker : stable_for_n_ticks
```

The text also includes discussions about checker modeling in Verilog, specifically stating the illegality of referencing checker variables using hierarchical names outside of the checker and the importance of using the smallest variable size necessary for formal verification efficiency.","
checker check(...);
  bit a;
  ...
endchecker : check

module m_illegal(...);
  ...
  check mycheck(...);
  ...
  wire b;
  assign b = mycheck.a;
endmodule : m


checker stable_for_n_ticks(sig, n,
  event clk = $inferred_clock,
  untyped rst = $inferred_disable);

  default clocking @clk; endclocking
  default disable iff rst;
  bit [$clog2(n)-1:0] ctr = '0;

  always_ff @clk begin
    if (rst) ctr <= 1;
    else if (ctr == n - 1) ctr <= 0;
    else ctr <= ctr + 1;
  end

  a1: assert property (($changed(sig) |-> ctr == 0);
endchecker : stable_for_n_ticks
","Caption: An excerpt from a document discussing Verilog checker modeling, showing an example of illegal code where a checker variable is referenced outside its scope and an example of a Verilog checker to monitor signal stability for a specified number of clock ticks.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p232.jpg,True,"The image contains text and partial code related to Verilog PLI (Programming Language Interface). Here is the code visible in the image:

```c
#include <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard input/output library */
#include <malloc.h> /* ANSI C standard memory allocation library */
#include ""vpi_user.h"" /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library
                        (using TF routines for simulation control) */

/* include utility routines to work with tfargs */
#include ""vpi_utilities.c""
```

This code is part of an example from ""The Verilog PLI Handbook,"" and is meant to be compiled as part of a PLI application that interfaces with a Verilog simulation. The example demonstrates how to work with callbacks in a Verilog testbench simulation, but only a part of the code is displayed in the image.","ude <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard input/output library */
#include <malloc.h> /* ANSI C standard memory allocation library */
#include ""vpi_user.h"" /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library
                        (using TF routines for simulation control) */

/* include utility routines to work with tfargs */
#include ""vpi_utilities.c""
","Caption: ""Example from 'The Verilog PLI Handbook' demonstrating the use of VPI library for scheduling callbacks in a Verilog simulation with user-data options to customize PLI application behavior.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p290.jpg,True,"The image contains both text and Verilog code examples related to the ""Empty Sequence"" in Verilog. Here's the Verilog code visible in the image:

```verilog
sequence Sc1;
  a ##1[*0:$] ##1 c;
endsequence

property ab;
  @(posedge clk) z |-> Sc1;
endproperty
```

This snippet defines a sequence named `Sc1` that describes a pattern where the signal `a` is followed by zero or more clock cycles (`[*0:$]`) and then followed by the signal `c`. The property `ab` is specified for the positive edge of the clock `clk` where if `z` is true, then the sequence `Sc1` should be satisfied.","
sequence Sc1;
  a ##1[*0:$] ##1 c;
endsequence

property ab;
  @(posedge clk) z |-> Sc1;
endproperty
",Verilog sequence property example with empty match conditions and simulation log results.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p133.jpg,True,"The image contains the following Verilog code snippets:

```verilog
reg [vector log indices] Memory_Name[array location indices];

reg[7:0] Memory[HiAddr:0]; // HiAddr is a parameter >= 22.
reg[7:0] ByteRegister;
reg[15:0] WordRegister; // This vector is 16 bits wide.
...
ByteRegister <= Memory[12]; // Entire memory word = 1 byte.
WordRegister <= Memory[20]; // Low-order byte from the memory word.
WordRegister[15:8] <= Memory[22]; // High-order byte from the memory word.
...

reg[63:0] Memory[HiAddr:0]; // Assume HiAddr is a parameter > 56.
reg[7:0] ByteRegister;
reg[31:0] WordRegister; // This vector is 32 bits wide.
...
ByteRegister <= Memory[57]; // Entire memory word (truncated).
ByteRegister <= Memory[50][15:8]; // 2nd byte from a memory word.
Memory[56][63:32] <= WordRegister; // To the high half of memory word 56.
...

reg[7:0] MemByByte[3:0][1023:0];
```

These code snippets show examples of memory declarations and assignments in Verilog.","
reg [vector log indices] Memory_Name[array location indices];

reg[7:0] Memory[HiAddr:0]; // HiAddr is a parameter >= 22.
reg[7:0] ByteRegister;
reg[15:0] WordRegister; // This vector is 16 bits wide.
...
ByteRegister <= Memory[12]; // Entire memory word = 1 byte.
WordRegister <= Memory[20]; // Low-order byte from the memory word.
WordRegister[15:8] <= Memory[22]; // High-order byte from the memory word.
...

reg[63:0] Memory[HiAddr:0]; // Assume HiAddr is a parameter > 56.
reg[7:0] ByteRegister;
reg[31:0] WordRegister; // This vector is 32 bits wide.
...
ByteRegister <= Memory[57]; // Entire memory word (truncated).
ByteRegister <= Memory[50][15:8]; // 2nd byte from a memory word.
Memory[56][63:32] <= WordRegister; // To the high half of memory word 56.
...

reg[7:0] MemByByte[3:0][1023:0];
","""Excerpt from a text on Digital VLSI Design discussing Verilog memory arrays and code snippets for memory addressing in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p127.jpg,True,"The image contains Verilog code. Here it is:

```verilog
module ParToSerial (output SerOut, ServValidFlag
                    , input SerClock, ParValid, input[31:0] BusIn);
  integer ix;
  reg SerValid, Done, SerBit;
  assign #1 SerValidFlag = SerValid;
  assign #2 SerOut        = SerBit;
  always@(posedge SerClock)
  begin // Reset everything unless ParValid:
    if (ParValid=='b1)
      if (SerValid=='b1)
      begin
        SerBit <= BusIn[ix]; // Current serial bit.
        if (ix==0)
        begin
          SerValid <= 'b0;
          Done     <= 'b1;
        end
        else ix <= ix - 1;
      end // SerValid was asserted.
      else begin // No start yet:
        if (Done=='b0)
        begin
          SerValid <= 'b1; // Flag start on next SerClock.
          ix       <= 31;  // Ready to start on next SerClock.
          end
          SerBit   <= 'b0; // Serial bit default.
        end
      else // ParValid not 1; reset everything:
      begin
        SerValid <= 'b0;
        Done     <= 'b0;
        SerBit   <= 'b0; // Serial bit default.
      end // if ParValid else
  end // always
endmodule // ParToSerial.
```

The text below the code provides instructions for modifying the Verilog module, specifically by introducing a parameter to set the parallel-bus width and by writing a testbench.","
module ParToSerial (output SerOut, ServValidFlag
                    , input SerClock, ParValid, input[31:0] BusIn);
  integer ix;
  reg SerValid, Done, SerBit;
  assign #1 SerValidFlag = SerValid;
  assign #2 SerOut        = SerBit;
  always@(posedge SerClock)
  begin // Reset everything unless ParValid:
    if (ParValid=='b1)
      if (SerValid=='b1)
      begin
        SerBit <= BusIn[ix]; // Current serial bit.
        if (ix==0)
        begin
          SerValid <= 'b0;
          Done     <= 'b1;
        end
        else ix <= ix - 1;
      end // SerValid was asserted.
      else begin // No start yet:
        if (Done=='b0)
        begin
          SerValid <= 'b1; // Flag start on next SerClock.
          ix       <= 31;  // Ready to start on next SerClock.
          end
          SerBit   <= 'b0; // Serial bit default.
        end
      else // ParValid not 1; reset everything:
      begin
        SerValid <= 'b0;
        Done     <= 'b0;
        SerBit   <= 'b0; // Serial bit default.
      end // if ParValid else
  end // always
endmodule // ParToSerial.
",This image shows Verilog code for a Parallel-to-Serial converter module alongside instructions for modifying the code to include a parameter for setting the parallel bus width and updating the module's index variable to a register type with the correct width.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p284.jpg,True,"The image contains Verilog code snippets related to SystemVerilog assertions and sequences. Here are the excerpts of Verilog code from the image:

```verilog
sequence abc;
  @(posedge clk) a ##1 b ##1 c;
endsequence
```

```verilog
a ##1 a & b ##1 a & b & c;
```

```verilog
a ##1 (a & b) ##1 (a & b & c);
```

```verilog
a ##1 !a & b ##1 !a & !b & c;
```

```verilog
a ##1 (!a & b) ##1 (!a & !b & c);
```

```verilog
property rdyProtocol;
  @(posedge clk) rdy |-> ##[1:$] rdyAck;
endproperty
assert property(rdyProtocol);
```

```verilog
property rdyProtocol;
  @(posedge clk) rdy |-> rdyAck [- > 1];
endproperty
assert property(rdyProtocol);
```","
sequence abc;
  @(posedge clk) a ##1 b ##1 c;
endsequence


a ##1 a & b ##1 a & b & c;


a ##1 (a & b) ##1 (a & b & c);


a ##1 !a & b ##1 !a & !b & c;


a ##1 (!a & b) ##1 (!a & !b & c);


property rdyProtocol;
  @(posedge clk) rdy |-> ##[1:$] rdyAck;
endproperty
assert property(rdyProtocol);


property rdyProtocol;
  @(posedge clk) rdy |-> rdyAck [- > 1];
endproperty
assert property(rdyProtocol);
",Caption: Enhancing simulation performance in Verilog by refining Boolean expressions and properties for efficient modeling and verification.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p215.jpg,True,"```verilog
// declarative assertion
// Capture data (into tdata) and compare it when you see the new
// transaction (new_trans).

property capture_check;
  reg [31:0] tdata;
  @(posedge clk) (new_req, tdata=data |-> ##[1:100] new_trans
  ##0 tdata == trans_cmd);
endproperty

assert property (capture_check)
  else $error (""Transaction (%0d)not started within 100 cycles, or trans_cmd (%0d) wrong."", 
               new_trans, trans_cmd);
```","
// declarative assertion
// Capture data (into tdata) and compare it when you see the new
// transaction (new_trans).

property capture_check;
  reg [31:0] tdata;
  @(posedge clk) (new_req, tdata=data |-> ##[1:100] new_trans
  ##0 tdata == trans_cmd);
endproperty

assert property (capture_check)
  else $error (""Transaction (%0d)not started within 100 cycles, or trans_cmd (%0d) wrong."", 
               new_trans, trans_cmd);
","Caption: ""SystemVerilog assertion example for captured data check within a transactional protocol context.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p219.jpg,True,"The image includes a snippet of Verilog code. Here is the text of the code:

```verilog
module RAM
...
always @*  // asynchronous write (latch behavior)
    if (write_enable) mem[address] <= data;  // write to RAM
...
```

This code is an example given in the context of a discussion about an error that arises from tool compatibility issues in Verilog, specifically an invalid combination of procedural drivers. This particular code is presented as a correct way to avoid such an issue, using an asynchronous write (mimicking latch behavior) to model a RAM memory write operation.","
module RAM
...
always @*  // asynchronous write (latch behavior)
    if (write_enable) mem[address] <= data;  // write to RAM
...
",Correcting Verilog procedural blocks to avoid tool compatibility issues with abstract RAM models.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p229.jpg,True,"```verilog
// valid signal combination pattern
assert property (@ (posedge clk) disable iff ( rst_n )
    not (SmQueNew & QueFull)) else
    $error(""Overflow of SMQue block."");
```","
// valid signal combination pattern
assert property (@ (posedge clk) disable iff ( rst_n )
    not (SmQueNew & QueFull)) else
    $error(""Overflow of SMQue block."");
","Caption: ""Example of a SystemVerilog assertion to ensure that two signals, SmQueNew and QueFull, are mutually exclusive within a digital design context.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p320.jpg,True,"The image contains several code snippets related to Verilog properties. Here is the code reproduced from the image:

```verilog
a |-> ##[min_time : max_time] lb;
endproperty

// On a given clock edge, if the leading signal
// is low, then between ""min_time"" and
// ""max_time"" clock cycles the trailing signal
// must be high

property p5_w_lh;
@(posedge clk)
  !a |-> ##[min_time : max_time] b;
endproperty

// On a given clock edge, if the leading signal
// is low, then between ""min_time"" and
// ""max_time"" clock cycles the trailing signal
// must be low

property p5_w_ll;
@(posedge clk)
  !a |-> ##[min_time : max_time] !b;
endproperty

a5_w_hh: assert property(p5_w_hh);
a5_w_hl: assert property(p5_w_hl);
a5_w_lh: assert property(p5_w_lh);
a5_w_ll: assert property(p5_w_ll);

// on a given clock edge, the leading signal has
// a falling edge and after ""min_time"" cycle the
// trailing signal has a falling edge

property p4_f_ff;
@(posedge clk) $fell(a) ##min_time $fell(b);
endproperty

// on a given clock edge, the leading signal has
// a rising edge and after ""min_time"" cycle the
// trailing signal has a rising edge
```

Note: Some parts of the code include placeholders such as `min_time` and `max_time`, which typically would be defined with actual values within a Verilog coding context. Additionally, there is a possible typo in the first assertion macro of `property p4_f_ff;`, as it should probably use a range (`##[min_time]` or `##[min_time : some_other_time]`) instead of `##min_time`. Since this is taken directly from the image, it's reproduced as shown.","
a |-> ##[min_time : max_time] lb;
endproperty

// On a given clock edge, if the leading signal
// is low, then between ""min_time"" and
// ""max_time"" clock cycles the trailing signal
// must be high

property p5_w_lh;
@(posedge clk)
  !a |-> ##[min_time : max_time] b;
endproperty

// On a given clock edge, if the leading signal
// is low, then between ""min_time"" and
// ""max_time"" clock cycles the trailing signal
// must be low

property p5_w_ll;
@(posedge clk)
  !a |-> ##[min_time : max_time] !b;
endproperty

a5_w_hh: assert property(p5_w_hh);
a5_w_hl: assert property(p5_w_hl);
a5_w_lh: assert property(p5_w_lh);
a5_w_ll: assert property(p5_w_ll);

// on a given clock edge, the leading signal has
// a falling edge and after ""min_time"" cycle the
// trailing signal has a falling edge

property p4_f_ff;
@(posedge clk) $fell(a) ##min_time $fell(b);
endproperty

// on a given clock edge, the leading signal has
// a rising edge and after ""min_time"" cycle the
// trailing signal has a rising edge
","""Verilog code demonstrating signal timing checks with assertions in SystemVerilog""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p334.jpg,True,"The image contains Verilog code which is a part of a text, here's the transcribed code:

```verilog
// signals
if(logic_op == 0 && timing == 1 && sig_edge == 0 && non_o_implication == 0)
begin
    if(min_time == max_time)
    begin
        if(timing_level == 2'b11)
            a3_hh: assert property(p3_hh);
        if(timing_level == 2'b10)
            a3_hl: assert property(p3_hl);
        if(timing_level == 2'b01)
            a3_lh: assert property(p3_lh);
        if(timing_level == 2'b00)
            a3_ll: assert property(p3_ll);
    end
    if(min_time != max_time)
    begin
        if(timing_level == 2'b11)
            a3_w1_hh: assert property(p3_w1_hh);
        if(timing_level == 2'b10)
            a3_w2_hl: assert property(p3_w2_hl);
        if(timing_level == 2'b01)
            a3_w3_lh: assert property(p3_w3_lh);
        if(timing_level == 2'b00)
            a3_w4_ll: assert property(p3_w4_ll);
    end
end

// logical relationship between 2 level sensitive
// signals with overlapping implication
if((logic_op == 1 || o_l_implication == 1) && timing == 0 && sig_edge == 0)
begin
    a4_oli_hh: assert property(p4_oli_hh);
    a4_oli_hl: assert property(p4_oli_hl);
    a4_oli_lh: assert property(p4_oli_lh);
    a4_oli_ll: assert property(p4_oli_ll);
end

// logical relationship between 2 edge sensitive
// signals with overlapping implication FF, FR
```

Please note, the rest of the last comment appears to be cut from the image, so it is incomplete. The Verilog code includes conditional statements and assertions, which are likely part of a hardware description or verification code.","
// signals
if(logic_op == 0 && timing == 1 && sig_edge == 0 && non_o_implication == 0)
begin
    if(min_time == max_time)
    begin
        if(timing_level == 2'b11)
            a3_hh: assert property(p3_hh);
        if(timing_level == 2'b10)
            a3_hl: assert property(p3_hl);
        if(timing_level == 2'b01)
            a3_lh: assert property(p3_lh);
        if(timing_level == 2'b00)
            a3_ll: assert property(p3_ll);
    end
    if(min_time != max_time)
    begin
        if(timing_level == 2'b11)
            a3_w1_hh: assert property(p3_w1_hh);
        if(timing_level == 2'b10)
            a3_w2_hl: assert property(p3_w2_hl);
        if(timing_level == 2'b01)
            a3_w3_lh: assert property(p3_w3_lh);
        if(timing_level == 2'b00)
            a3_w4_ll: assert property(p3_w4_ll);
    end
end

// logical relationship between 2 level sensitive
// signals with overlapping implication
if((logic_op == 1 || o_l_implication == 1) && timing == 0 && sig_edge == 0)
begin
    a4_oli_hh: assert property(p4_oli_hh);
    a4_oli_hl: assert property(p4_oli_hl);
    a4_oli_lh: assert property(p4_oli_lh);
    a4_oli_ll: assert property(p4_oli_ll);
end

// logical relationship between 2 edge sensitive
// signals with overlapping implication FF, FR
",Excerpt from a text related to checking system assertions in Verilog code.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p247.jpg,True,"```verilog
integer data;
...
task automatic wait_for (integer value, output bit success);
    expect (@(posedge clk) #1[1:10] data == value) success = 1;
    else success = 0;
endtask

initial begin
    bit ok;
    wait_for (23, ok);
    ...
end
```","
integer data;
...
task automatic wait_for (integer value, output bit success);
    expect (@(posedge clk) #1[1:10] data == value) success = 1;
    else success = 0;
endtask

initial begin
    bit ok;
    wait_for (23, ok);
    ...
end
","""Example of a Verilog task with an expect statement for synchronous data checking""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p742.jpg,True,"The image includes descriptions of functions related to the Verilog Programming Language Interface (PLI), but it does not contain actual code that can be executed. The functions are as follows:

```
void tf_unscale_longdelay(tfint, low1, high1, low2, high2)
char    *tfint     pointer to an instance of a system task/function.
int     low1       lower 32 bits of first operand.
int     high1      upper 32 bits of first operand.
int     *low2      pointer to lower 32 bits of second operand.
int     *high2     pointer to upper 32 bits of second operand.

void tf_unscale_realdelay(tfint, real1, rea2)
char    *tfint     pointer to an instance of a system task/function.
double  real1      real number value of first operand.
double  *real2     pointer to real number value of second operand.
int     *high2     pointer to upper 32 bits of second operand.

void tf_warning(format, arg1...arg5)
char    *format    quoted character string of formatted message.
arg1...arg5        arguments to formatted message string.

int tf_write_save(blockptr, blocklength)
char    *blockptr      pointer to a block of memory.
int     blocklength    length of the block of memory in bytes.
```","f_unscale_longdelay(tfint, low1, high1, low2, high2)
char    *tfint     pointer to an instance of a system task/function.
int     low1       lower 32 bits of first operand.
int     high1      upper 32 bits of first operand.
int     *low2      pointer to lower 32 bits of second operand.
int     *high2     pointer to upper 32 bits of second operand.

void tf_unscale_realdelay(tfint, real1, rea2)
char    *tfint     pointer to an instance of a system task/function.
double  real1      real number value of first operand.
double  *real2     pointer to real number value of second operand.
int     *high2     pointer to upper 32 bits of second operand.

void tf_warning(format, arg1...arg5)
char    *format    quoted character string of formatted message.
arg1...arg5        arguments to formatted message string.

int tf_write_save(blockptr, blocklength)
char    *blockptr      pointer to a block of memory.
int     blocklength    length of the block of memory in bytes.
","""Verilog PLI Handbook: Reference for Verilog programming language interface functions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p509.jpg,True,"The image contains Verilog code. Here's the code as written in the image:

```verilog
logic [7:0] FrameLength = 0;
event measureFrameLength;

covergroup length_cg @(measureFrameLength );
    coverpoint FrameLength;
endgroup

task store_Frame_Length;
input [7:0] x;
    FrameLength = x;
    -> measureFrameLength;
endtask

sequence frmLength;
    int cnt;
    ##1 (TX_EN, cnt=1) ##1 ((TX_EN, cnt++)[*0:$])
    ##1 (!TX_EN, store_Frame_Length(cnt))
endsequence

property frameLength;
    @(posedge TX_CLK) $rose(TX_EN) |-> frmLength;
endproperty

fLength: assert property (frameLength);
```

This code is an example of SystemVerilog assertions, tasks, and covergroups. It defines a task to store frame length, a sequence to track frame length, and a property to assert the frame length upon the rising edge of a transmit enable signal (`TX_EN`) with regard to a transmit clock (`TX_CLK`).","
logic [7:0] FrameLength = 0;
event measureFrameLength;

covergroup length_cg @(measureFrameLength );
    coverpoint FrameLength;
endgroup

task store_Frame_Length;
input [7:0] x;
    FrameLength = x;
    -> measureFrameLength;
endtask

sequence frmLength;
    int cnt;
    ##1 (TX_EN, cnt=1) ##1 ((TX_EN, cnt++)[*0:$])
    ##1 (!TX_EN, store_Frame_Length(cnt))
endsequence

property frameLength;
    @(posedge TX_CLK) $rose(TX_EN) |-> frmLength;
endproperty

fLength: assert property (frameLength);
",Example of Verilog code using assertions and covergroups to check frame transmission lengths.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p297.jpg,True,"The image contains Verilog code. Here is the code extracted from it:

```verilog
sequence s_tchk13b;
    @(posedge clk)
    (devseln && stopn && trdyn) throughout
    (##[1:5] $rose (framen));
endsequence

property p_tchk13;
    @(posedge clk)
    s_tchk13a |-> s_tchk13b;
endproperty

a_tchk13: assert property(p_tchk13);
c_tchk13: cover property(p_tchk13);
```

This Verilog code snippet defines a sequence `s_tchk13b`, a property `p_tchk13`, and uses them in assertions `a_tchk13` and coverage `c_tchk13`. The `sequence` is looking for a particular pattern of signals on the rising edge of the clock (`posedge clk`). The code suggests usage within the context of SystemVerilog Assertions (SVA) for protocol interface checking.","
sequence s_tchk13b;
    @(posedge clk)
    (devseln && stopn && trdyn) throughout
    (##[1:5] $rose (framen));
endsequence

property p_tchk13;
    @(posedge clk)
    s_tchk13a |-> s_tchk13b;
endproperty

a_tchk13: assert property(p_tchk13);
c_tchk13: cover property(p_tchk13);
",Verilog SVA code snippet for protocol interface checking with associated waveform illustration.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p375.jpg,True,"Here is the code extracted from the image:

Goto repetition of a sequence:
```verilog
sequence_expr ::= expression_or_dist '[' '->' const_range_expression ']'

const_range_expression ::=constant_expression
                         | constant_expression ':' constant_expression
                         | constant_expression ':' '$'

Goto repetition is defined in terms of the other operators as:
s [-> min:max] ::= (![s[*0:$] ##1 s) [* min:max]
Examples are:
• a[->0] ##1 b same as (b)
• a[->1] ##1 b same as (!a [*0:$] ##1 a ##1 b)
• a[->2] ##1 b same as (!a [*0:$] ##1 a ##1 !a [*0:$] ##1 a ##1 b)
```

Nonconsecutive repetition of a sequence:
```verilog
sequence_expr ::= expression_or_dist '[' '=' const_range_expression ']'

const_range_expression ::= constant_range_expression
                         | constant_range_expression ',' constant_range_expression
                         | constant_range_expression ':' constant_range_expression
                         | constant_range_expression ':' '$'

Nonconsecutive repetition is defined in terms of the other operators as:
s [= min:max] ::= (![s[*0:$] ##1 s ) [* min:max ]] ##1 !s [*0:$]
Examples are:
• a [=0] ##1 b same as (b)
```
This code includes the syntax for goto repetition and nonconsecutive repetition within Verilog sequences, and provides examples of how to use these constructs.","
sequence_expr ::= expression_or_dist '[' '->' const_range_expression ']'

const_range_expression ::=constant_expression
                         | constant_expression ':' constant_expression
                         | constant_expression ':' '$'

Goto repetition is defined in terms of the other operators as:
s [-> min:max] ::= (![s[*0:$] ##1 s) [* min:max]
Examples are:
• a[->0] ##1 b same as (b)
• a[->1] ##1 b same as (!a [*0:$] ##1 a ##1 b)
• a[->2] ##1 b same as (!a [*0:$] ##1 a ##1 !a [*0:$] ##1 a ##1 b)


sequence_expr ::= expression_or_dist '[' '=' const_range_expression ']'

const_range_expression ::= constant_range_expression
                         | constant_range_expression ',' constant_range_expression
                         | constant_range_expression ':' constant_range_expression
                         | constant_range_expression ':' '$'

Nonconsecutive repetition is defined in terms of the other operators as:
s [= min:max] ::= (![s[*0:$] ##1 s ) [* min:max ]] ##1 !s [*0:$]
Examples are:
• a [=0] ##1 b same as (b)
","Caption: ""Verilog Syntax for Goto and Nonconsecutive Repetitions in Sequences, as described in 'Assertion-Based Design'.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p482.jpg,True,"The image contains Verilog code related to functional coverage using coverpoints and cross coverage. Here's the code contained in the image:

```verilog
CR2_10: coverpoint CR2 {
    bins one = {0};
    bins four = {1};
    bins eight = {2};
    bins fourteen = {3};
}

MultiCross: cross CR1_10, CR1_2, CR1_53, CR2_10;

endgroup
```

There's an exercise mentioned in the image as well, though it's not actual code, it's a question related to the code. Following the exercise, there are further examples of ""cross"" coverage:

```verilog
Example 1:
bit [7:0] b1, b2, b3;
covergroup cov @(posedge clk);
    b2b3: coverpoint b2+b3;;
    b1Crossb2b3 : cross b1, b2b3;
endgroup

Example 2:
bit [3:0] bNibble;
covergroup myCov @(posedge clk);
    A: coverpoint a_var { bins yy[] = { [0:9] }; }
    CC: cross bNibble, A;
endgroup
```

It explains that the coverpoint `b2b3` is an expression and it is possible to ""cross"" between a coverpoint (which is an expression) and a variable. In `Example 2`, it details how the cross of `bNibble` and `A` produces 160 cross bins (16 auto-generated bins of `bNibble` x 10 bins of `a_var`).

Below `Example 2`, the auto-generated bin pairs are listed as:

```
<auto[0], yy[0]>
<auto[0], yy[1]>
...
<auto[0], yy[9]>

<auto[1], yy[0]>
...
<auto[15], yy[9]>
```

These represent the combinations of bins created as a result of crossing `bNibble` with `A`.","
CR2_10: coverpoint CR2 {
    bins one = {0};
    bins four = {1};
    bins eight = {2};
    bins fourteen = {3};
}

MultiCross: cross CR1_10, CR1_2, CR1_53, CR2_10;

endgroup


Example 1:
bit [7:0] b1, b2, b3;
covergroup cov @(posedge clk);
    b2b3: coverpoint b2+b3;;
    b1Crossb2b3 : cross b1, b2b3;
endgroup

Example 2:
bit [3:0] bNibble;
covergroup myCov @(posedge clk);
    A: coverpoint a_var { bins yy[] = { [0:9] }; }
    CC: cross bNibble, A;
endgroup

0], yy[0]>
<auto[0], yy[1]>
...
<auto[0], yy[9]>

<auto[1], yy[0]>
...
<auto[15], yy[9]>
","""Exploring Functional Coverage and Cross Coverage in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p26.jpg,True,"This image includes an excerpt about RTL assertions and a piece of VHDL code demonstrating the assertion syntax in VHDL. Here's the VHDL code from the image:

```vhdl
[label] assert VHDL_expression
[report message]
[severity level]
```

Explanation in the text indicates that when the `VHDL_expression` evaluates to FALSE, an error is reported with an optional report message and severity level. If no report clause is specified, the default message string is ""Assertion violation"".","abel] assert VHDL_expression
[report message]
[severity level]
","""Excerpt from a document discussing RTL assertions in hardware interfaces and illustrating the VHDL assertion syntax.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p496.jpg,True,"This page contains Verilog code. Here it is:

```verilog
x_y_cross: cross x_c, y_c {
  ignore_bins ignore_x_GT_y = x_y_cross with { (x_c > y_c); }
}

endgroup
```

and

```verilog
bit[3:0] adr1;

covergroup cg @(posedge clk);
  ac: coverpoint adr1
  {
    illegal_bins ilvalue0 = {0};
  }
endgroup

gc_clst = new();
```

The text also explains the concept of ""illegal_bins"" in the context of functional coverage with Verilog.","
x_y_cross: cross x_c, y_c {
  ignore_bins ignore_x_GT_y = x_y_cross with { (x_c > y_c); }
}

endgroup


bit[3:0] adr1;

covergroup cg @(posedge clk);
  ac: coverpoint adr1
  {
    illegal_bins ilvalue0 = {0};
  }
endgroup

gc_clst = new();
","Caption: ""Understanding illegal bins in Verilog functional coverage, showcasing a code snippet and corresponding error message when an illegal bin is covered in a simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p283.jpg,True,"The image contains Verilog code related to SystemVerilog Assertions (SVA) for protocol interfaces. Here are the code segments visible in the image:

```verilog
property p_tchk3;
  @(posedge clk)
    $fell (trdyn) |-> !devseln;
endproperty

a_tchk3: assert property(p_tchk3);
c_tchk3: cover property(p_tchk3);

property p_tchk5b;
  @(posedge clk)
    ($fell (stopn) && !framen && trdyn && !irdyn)
    |=>
      (framen && trdyn)
      ##1 (stopn && devseln && !irdyn);
endproperty

a_tchk5b: assert property(p_tchk5b);
c_tchk5b: cover property(p_tchk5b);
```

These code snippets define properties `p_tchk3` and `p_tchk5b` using SystemVerilog assertion syntax, and then use `assert` and `cover` directives to verify that the properties hold in the described scenarios. The properties are related to the behavior of signals in a hardware design, where certain conditions must be met at the positive edge of a clock signal (denoted by `posedge clk`).","
property p_tchk3;
  @(posedge clk)
    $fell (trdyn) |-> !devseln;
endproperty

a_tchk3: assert property(p_tchk3);
c_tchk3: cover property(p_tchk3);

property p_tchk5b;
  @(posedge clk)
    ($fell (stopn) && !framen && trdyn && !irdyn)
    |=>
      (framen && trdyn)
      ##1 (stopn && devseln && !irdyn);
endproperty

a_tchk5b: assert property(p_tchk5b);
c_tchk5b: cover property(p_tchk5b);
","""Verilog Assertions for Protocol Interface Checking""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p349.jpg,True,"The image includes the definitions of some operators that appear to be from the ""PSL (Property Specification Language)"" which is used for specifying properties in hardware verification. Here are the code snippets from the image:

```
Syntax B-15  next* operators

FL_Property ::=
    next FL_Property
    | next! FL_Property
    | next [ Number ] ( FL_Property )
    | next! [ Number ] ( FL_Property )
```

```
Syntax B-16  eventually! operators

FL_Property ::=
    eventually! FL_Property
    | eventually! Sequence
```

```
Syntax B-17  before operator

FL_Property ::=
    FL_Property before! FL_Property
    | FL_Property before FL_Property
    | FL_Property before!_ FL_Property
    | FL_Property before_ FL_Property
``` 

Additionally, there's some descriptive text about the `eventually!` operator and the `before*` operators that explains the semantic usage of these operators in the PSL language."," B-15  next* operators

FL_Property ::=
    next FL_Property
    | next! FL_Property
    | next [ Number ] ( FL_Property )
    | next! [ Number ] ( FL_Property )

 B-16  eventually! operators

FL_Property ::=
    eventually! FL_Property
    | eventually! Sequence

 B-17  before operator

FL_Property ::=
    FL_Property before! FL_Property
    | FL_Property before FL_Property
    | FL_Property before!_ FL_Property
    | FL_Property before_ FL_Property
","Caption: ""Excerpt from a reference document detailing the syntax for 'next*', 'eventually!', and 'before*' operators in the PSL Property Specification Language, used in Verilog HDL verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p184.jpg,True,"The image contains snippets of Verilog code. Here they are:

First snippet:
```verilog
assign w = b || orReduct(data);
//...
endmodule
```

Second snippet, which includes an example and the resulting code after substitution:
```verilog
// Example code
typedef bit [1:0] my_t;
let orReduct(my_t x) = |x;
module m;
  logic [2:0] sel;
  logic [7:0] [1:0] data;
  logic a, b, v, w;
  assign v = a && orReduct(sel);
  assign w = orReduct(data);
  //...
endmodule

// Resulting code after substitution
typedef bit [1:0] my_t;
module m;
  logic [2:0] sel;
  logic [7:0] [1:0] data;
  logic a, b, v, w;
  assign v = a && |(my_t'(sel));
  assign w = |(my_t'(data));
  //...
endmodule
```

Please note that the comments (`//...`) indicate that there may be more code or comments in the original source that are not included in the images provided.","
assign w = b || orReduct(data);
//...
endmodule


// Example code
typedef bit [1:0] my_t;
let orReduct(my_t x) = |x;
module m;
  logic [2:0] sel;
  logic [7:0] [1:0] data;
  logic a, b, v, w;
  assign v = a && orReduct(sel);
  assign w = orReduct(data);
  //...
endmodule

// Resulting code after substitution
typedef bit [1:0] my_t;
module m;
  logic [2:0] sel;
  logic [7:0] [1:0] data;
  logic a, b, v, w;
  assign v = a && |(my_t'(sel));
  assign w = |(my_t'(data));
  //...
endmodule
","Caption: ""Understanding Type Checking and Type Casting in Verilog Code with `let` Declarations and `orReduce` Operations""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p188.jpg,True,"The image contains a sample of Verilog code, which I will transcribe below:

```verilog
program automatic top;
  int limit;               // $root.top.limit

  class Foo;
    int limit, array[];    // $root.top.Foo.limit
    // $root.top.Foo.print.limit
    function void print (input int limit);
      for (int i=0; i<limit; i++)
        $display(""%m: array[%0d]=%0d"", i, array[i]);
    endfunction
  endclass

  initial begin
    int limit = 3;
    Foo bar;

    bar = new();
    bar.array = new[limit];
    bar.print(limit);
  end
endprogram
```

This code snippet is intended to illustrate the scoping rules within SystemVerilog, specifically regarding classes and program blocks. It demonstrates how to access variables using scopes and the potential issues of variable shadowing.","
program automatic top;
  int limit;               // $root.top.limit

  class Foo;
    int limit, array[];    // $root.top.Foo.limit
    // $root.top.Foo.print.limit
    function void print (input int limit);
      for (int i=0; i<limit; i++)
        $display(""%m: array[%0d]=%0d"", i, array[i]);
    endfunction
  endclass

  initial begin
    int limit = 3;
    Foo bar;

    bar = new();
    bar.array = new[limit];
    bar.print(limit);
  end
endprogram
","Caption: ""Example of Verilog code demonstrating scoping rules in a program block, with a class definition and method to print array elements.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p96.jpg,True,"The image includes a snippet of code in C language. Here is the code extract:

```c
typedef struct t_vpi_time {
    int type;
    unsigned int high;
    unsigned int low;
    double real;
} s_vpi_time, *p_vpi_time;
```","ef struct t_vpi_time {
    int type;
    unsigned int high;
    unsigned int low;
    double real;
} s_vpi_time, *p_vpi_time;
","This image contains a page from ""The Verilog PLI Handbook, Part One"" discussing the use of `vpi_get_value()` for reading Verilog data types and mapping these to C data types. It also includes a code snippet of a structure `t_vpi_time` for representing Verilog time data types in C.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p232.jpg,True,"The image contains Verilog code. Here's the code extracted from the image:

```verilog
module b (p, w, x, y, z);
  input w, x, y, z;
  output p;
  wire p, r, s, w, x, y, z;
  b_c c1((i), (w), (j), (x), .o (r)); // line 5
  b_c c2((y), (i), (z), .o (s));
  b_d d0((i), (r), (j), (s), .o (p));
endmodule // b

module b_c(i, o, j);
  input i, j;
  output o;
endmodule // b_c

module b_d(i, o, j);
  input i, j;
  output o;
endmodule // b_d
```

Note: Comments such as `// line 5` are included as they appear next to the code in the image. There may be an error in the code within the `b_c c1` instantiation, as the convention is not followed accurately based on standard Verilog syntax; typically, the pin connections should be either all positional or all named. Here it seems to be mixed which might be a transcription error or intentional for explanatory purposes.","
module b (p, w, x, y, z);
  input w, x, y, z;
  output p;
  wire p, r, s, w, x, y, z;
  b_c c1((i), (w), (j), (x), .o (r)); // line 5
  b_c c2((y), (i), (z), .o (s));
  b_d d0((i), (r), (j), (s), .o (p));
endmodule // b

module b_c(i, o, j);
  input i, j;
  output o;
endmodule // b_c

module b_d(i, o, j);
  input i, j;
  output o;
endmodule // b_d
","Caption: ""Comparison of Implicit and Explicit Interconnections in Verilog Module Instances""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p187.jpg,True,"The image contains Verilog code within a text document. Here is the code that is visible in the image:

```c
int PLIbook_ReadAttribute_calltf(char *user_data)
{
    vpiHandle systf_h, mod_h, arg_itr, arg2_h, port_itr, port_h;
    double attribute_value;
    char *attribute_name;
    s_vpi_value attribute_name_s;

    /* obtain handle to system task arguments;
       compiletf has already verified only 2 args with correct types */
    systf_h = vpi_handle(vpiSysTfCall, NULL);
    arg_itr = vpi_iterate(vpiArgument, systf_h);
    mod_h = vpi_scan(arg_itr);

    /* read base value of system function arg 2 */
    arg2_h = vpi_scan(arg_itr);
    vpi_free_object(arg_itr); /* free iterator--did not scan till null */
    attribute_name_s.format = vpiStringVal;
    vpi_get_value(arg2_h, &attribute_name_s);
    attribute_name = attribute_name_s.value.str;

    vpi_printf(""\nModule %s:\n"", vpi_get_str(vpiDefName, mod_h));
    port_itr = vpi_iterate(vpiPort, mod_h);
    while ((port_h = vpi_scan(port_itr)) != NULL) {
        attribute_value = PLIbook_GetAttribute(port_h, attribute_name, 9.9);
        vpi_printf("" Port name = %s, attribute %s for this port = %2.1f\n"",
                   vpi_get_str(vpiName, port_h), attribute_name, attribute_value);
    }
```

This code snippet appears to be a function written in C to be used within the Verilog PLI (Programming Language Interface), specifically VPI (Verilog Procedural Interface). The function `PLIbook_ReadAttribute_calltf` is obtaining and processing attributes of elements in a Verilog HDL simulation. Functions and system task invocations are part of the VPI library used for Verilog hardware simulation interfacing. The purpose of the code is to read attributes from simulation objects and print them.

Please note that the code snippet is not complete and would be part of a larger PLI application.","LIbook_ReadAttribute_calltf(char *user_data)
{
    vpiHandle systf_h, mod_h, arg_itr, arg2_h, port_itr, port_h;
    double attribute_value;
    char *attribute_name;
    s_vpi_value attribute_name_s;

    /* obtain handle to system task arguments;
       compiletf has already verified only 2 args with correct types */
    systf_h = vpi_handle(vpiSysTfCall, NULL);
    arg_itr = vpi_iterate(vpiArgument, systf_h);
    mod_h = vpi_scan(arg_itr);

    /* read base value of system function arg 2 */
    arg2_h = vpi_scan(arg_itr);
    vpi_free_object(arg_itr); /* free iterator--did not scan till null */
    attribute_name_s.format = vpiStringVal;
    vpi_get_value(arg2_h, &attribute_name_s);
    attribute_name = attribute_name_s.value.str;

    vpi_printf(""\nModule %s:\n"", vpi_get_str(vpiDefName, mod_h));
    port_itr = vpi_iterate(vpiPort, mod_h);
    while ((port_h = vpi_scan(port_itr)) != NULL) {
        attribute_value = PLIbook_GetAttribute(port_h, attribute_name, 9.9);
        vpi_printf("" Port name = %s, attribute %s for this port = %2.1f\n"",
                   vpi_get_str(vpiName, port_h), attribute_name, attribute_value);
    }
","""Example of using VPI routines to read attribute values in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p190.jpg,True,"The image contains Verilog code, which I'll transcribe below:

```verilog
always_comb w = a & b;
assert #0 (w == 1);

sequence sf_after_a(
    event clk = $inferred_clk, logic a, sequence sf, int n = 1);
    @(posedge clk) a ##n sf;
endsequence

property seq_impl_prop(logic rst = $inferred_disable,
    event clk = $inferred_clk, sequence sf, property pf);
    disable iff(rst) @clk sf |-> pf;
endproperty
```

This snippet of Verilog code demonstrates the use of `always_comb`, `assert`, `sequence`, and `property` constructs in SystemVerilog for defining assertions, sequences, and properties as part of formal verification or for use in simulation testbenches.","
always_comb w = a & b;
assert #0 (w == 1);

sequence sf_after_a(
    event clk = $inferred_clk, logic a, sequence sf, int n = 1);
    @(posedge clk) a ##n sf;
endsequence

property seq_impl_prop(logic rst = $inferred_disable,
    event clk = $inferred_clk, sequence sf, property pf);
    disable iff(rst) @clk sf |-> pf;
endproperty
","""Exploring Verilog Sequence and Property Declarations for Temporal Assertions in Hardware Description""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p327.jpg,True,"```verilog
@(posedge clk); req=1; gnt=0;
@(negedge clk); antecedent=1;
@(posedge clk); req=1; gnt=0; //fire thread
@(negedge clk); antecedent=0;
@(posedge clk); req=0; gnt=0; //turn off thread
@(posedge clk); req=0; gnt=0;

@(posedge clk); $finish;

initial $monitor($stime,,""clk=%b req=%b gnt=%b antecedent=%b"",clk,req,gnt,antecedent);
endmodule
```

The image contains some Verilog code, which appears to be a part of a simulation testbench. This code seems to be controlling the values of signals based on clock edges (`posedge` for rising edge and `negedge` for falling edge) and monitors the signal values, with the simulation finishing with a call to `$finish;`. The use of comments indicates the purpose of each action and when certain events in the simulation should be triggered or turned off. Also provided in the image is a snippet of a simulation log where the signal values are outlined at specific simulation times.","
@(posedge clk); req=1; gnt=0;
@(negedge clk); antecedent=1;
@(posedge clk); req=1; gnt=0; //fire thread
@(negedge clk); antecedent=0;
@(posedge clk); req=0; gnt=0; //turn off thread
@(posedge clk); req=0; gnt=0;

@(posedge clk); $finish;

initial $monitor($stime,,""clk=%b req=%b gnt=%b antecedent=%b"",clk,req,gnt,antecedent);
endmodule
",Verilog code snippet demonstrating the use of temporal assertions with accompanying simulation log and explanation.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p177.jpg,True,"The image contains code written in Verilog within a textbook or a document explaining basic Object-Oriented Programming concepts. Here's the code from the image:

```verilog
Transaction tr; // Declare a handle
tr = new();     // Allocate a Transaction object
```

The document also provides an example of a simple user-defined `new()` function:

```verilog
class Transaction;
  logic [31:0] addr, csm, data[8];

  function new();
    addr = 3;
    data = '{default:5};
  endfunction

endclass
```

This snippet shows how to declare a class `Transaction` with some logic vectors and an array, and how to define a constructor (`new()` function) that initializes the `addr` variable and `data` array with default values.","
Transaction tr; // Declare a handle
tr = new();     // Allocate a Transaction object


class Transaction;
  logic [31:0] addr, csm, data[8];

  function new();
    addr = 3;
    data = '{default:5};
  endfunction

endclass
","Sample Verilog code demonstrating the declaration, allocation, and initialization of a Transaction object with a custom constructor.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p69.jpg,True,"The image contains a snippet of Verilog code that relates to interfacing VPI based PLI Applications to Verilog Simulators. Here is the code from the image:

First snippet:
```c
void PLIbook_pow_register()
{
    s_vpi_systf_data tf_data;
    s_cb_data        cb_data_s;
    s_vpi_time       time_s;

    tf_data.type        = vpiSysFunc;
    tf_data.sysfunctype = vpiSysFuncSized;
    tf_data.tfname      = ""$pow"";
    tf_data.calltf      = PLIbook_PowCalltf;
    tf_data.compiletf   = PLIbook_PowCompiletf;
    tf_data.sizetf      = PLIbook_PowSizetf;
    vpi_register_systf(&tf_data);
}
```

Second snippet:
```c
/* prototypes of the PLI application routines */
extern void PLIbook_pow_register(), PLIbook_ShowVal_register();

void (*vlog_startup_routines[])() =
{
    /*** add user entries here ***/
    PLIbook_pow_register,
    PLIbook_ShowVal_register,
    0 /*** final entry must be 0 ***/
};
```

These code snippets are likely part of an example or tutorial demonstrating how to implement and register system tasks and functions using the Verilog Procedural Interface (VPI).","PLIbook_pow_register()
{
    s_vpi_systf_data tf_data;
    s_cb_data        cb_data_s;
    s_vpi_time       time_s;

    tf_data.type        = vpiSysFunc;
    tf_data.sysfunctype = vpiSysFuncSized;
    tf_data.tfname      = ""$pow"";
    tf_data.calltf      = PLIbook_PowCalltf;
    tf_data.compiletf   = PLIbook_PowCompiletf;
    tf_data.sizetf      = PLIbook_PowSizetf;
    vpi_register_systf(&tf_data);
}

ototypes of the PLI application routines */
extern void PLIbook_pow_register(), PLIbook_ShowVal_register();

void (*vlog_startup_routines[])() =
{
    /*** add user entries here ***/
    PLIbook_pow_register,
    PLIbook_ShowVal_register,
    0 /*** final entry must be 0 ***/
};
","""Excerpt from a text on interfacing VPI based PLI applications with Verilog simulators, showing code examples for registering PLI functions and defining the `vlog_startup_routines` array.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p455.jpg,True,"The image contains Verilog code examples. Here are the code snippets present in the image:

For the covergroup/coverpoint example regarding PCI cycle types, the code is:

```verilog
// PCI C/BE Commands
enum {iack, SpecialC, IORead, IOWrite, MemRead, MemWrite, ConfRead, ConfWrite, MemRMWt, DualAddr, MemReadLine, MemWrIn} pciCommands;

covergroup pciCommands_cover @(negedge FRAME);
    pciCmdCover : coverpoint pciCommands;
endgroup
```

For the testbench example, the code provided is:

```verilog
module testCover;

    bit [3:0] CycleType;
    bit[7:0] CPUMode;

    bit clk;
    real coverPercent;
    event stimulusDone;

    covergroup coverg @(posedge clk);
        CycleTypeCP: coverpoint CycleType;
```

Please note that the code for the `covergroup` in the testbench example is not complete; the image shows only the beginning of the `covergroup` definition.","
// PCI C/BE Commands
enum {iack, SpecialC, IORead, IOWrite, MemRead, MemWrite, ConfRead, ConfWrite, MemRMWt, DualAddr, MemReadLine, MemWrIn} pciCommands;

covergroup pciCommands_cover @(negedge FRAME);
    pciCmdCover : coverpoint pciCommands;
endgroup


module testCover;

    bit [3:0] CycleType;
    bit[7:0] CPUMode;

    bit clk;
    real coverPercent;
    event stimulusDone;

    covergroup coverg @(posedge clk);
        CycleTypeCP: coverpoint CycleType;
","""Example of a Verilog covergroup and coverpoint used for functional coverage of PCI Cycle Types in a simulation environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p163.jpg,True,"The image contains Verilog code. Here is the code:

```verilog
module top;
    bit clk, rst;
    always #5 clk = !clk;
    wire Rx_clk_0, Rx_clk_1, Rx_clk_2, Rx_clk_3,
         Rx_soc_0, Rx_soc_1, Rx_soc_2, Rx_soc_3,
         Rx_en_0, Rx_en_1, Rx_en_2, Rx_en_3,
         Rx_clav_0, Rx_clav_1, Rx_clav_2, Rx_clav_3,
         Tx_clk_0, Tx_clk_1, Tx_clk_2, Tx_clk_3,
         Tx_soc_0, Tx_soc_1, Tx_soc_2, Tx_soc_3,
         Tx_en_0, Tx_en_1, Tx_en_2, Tx_en_3,
         Tx_clav_0, Tx_clav_1, Tx_clav_2, Tx_clav_3;
    wire [7:0] Rx_data_0, Rx_data_1, Rx_data_2, Rx_data_3,
               Tx_data_0, Tx_data_1, Tx_data_2, Tx_data_3;

    atm_router_ports
    a1 (Rx_clk_0, Rx_clk_1, Rx_clk_2, Rx_clk_3,
        Rx_data_0, Rx_data_1, Rx_data_2, Rx_data_3,
        Rx_soc_0, Rx_soc_1, Rx_soc_2, Rx_soc_3,
        Rx_en_0, Rx_en_1, Rx_en_2, Rx_en_3,
        Rx_clav_0, Rx_clav_1, Rx_clav_2, Rx_clav_3,
        Tx_clk_0, Tx_clk_1, Tx_clk_2, Tx_clk_3,
        Tx_data_0, Tx_data_1, Tx_data_2, Tx_data_3,
        Tx_soc_0, Tx_soc_1, Tx_soc_2, Tx_soc_3,
        Tx_en_0, Tx_en_1, Tx_en_2, Tx_en_3,
        Tx_clav_0, Tx_clav_1, Tx_clav_2, Tx_clav_3,
        rst, clk);

    test_ports t1 (Rx_clk_0, Rx_clk_1, Rx_clk_2, Rx_clk_3,
                   Rx_data_0, Rx_data_1, Rx_data_2, Rx_data_3,
                   Rx_soc_0, Rx_soc_1, Rx_soc_2, Rx_soc_3,
                   Rx_en_0, Rx_en_1, Rx_en_2, Rx_en_3,
                   Rx_clav_0, Rx_clav_1, Rx_clav_2, Rx_clav_3,
                   Tx_clk_0, Tx_clk_1, Tx_clk_2, Tx_clk_3,
                   Tx_data_0, Tx_data_1, Tx_data_2, Tx_data_3,
                   Tx_soc_0, Tx_soc_1, Tx_soc_2, Tx_soc_3,
                   Tx_en_0, Tx_en_1, Tx_en_2, Tx_en_3,
                   Tx_clav_0, Tx_clav_1, Tx_clav_2, Tx_clav_3,
                   rst, clk);

endmodule
```

This Verilog code snippet defines a module named `top` without outlines for submodules `atm_router_ports` and `test_ports`. It includes clock generation, wire definitions, and instances of two submodules with wiring for their ports.","
module top;
    bit clk, rst;
    always #5 clk = !clk;
    wire Rx_clk_0, Rx_clk_1, Rx_clk_2, Rx_clk_3,
         Rx_soc_0, Rx_soc_1, Rx_soc_2, Rx_soc_3,
         Rx_en_0, Rx_en_1, Rx_en_2, Rx_en_3,
         Rx_clav_0, Rx_clav_1, Rx_clav_2, Rx_clav_3,
         Tx_clk_0, Tx_clk_1, Tx_clk_2, Tx_clk_3,
         Tx_soc_0, Tx_soc_1, Tx_soc_2, Tx_soc_3,
         Tx_en_0, Tx_en_1, Tx_en_2, Tx_en_3,
         Tx_clav_0, Tx_clav_1, Tx_clav_2, Tx_clav_3;
    wire [7:0] Rx_data_0, Rx_data_1, Rx_data_2, Rx_data_3,
               Tx_data_0, Tx_data_1, Tx_data_2, Tx_data_3;

    atm_router_ports
    a1 (Rx_clk_0, Rx_clk_1, Rx_clk_2, Rx_clk_3,
        Rx_data_0, Rx_data_1, Rx_data_2, Rx_data_3,
        Rx_soc_0, Rx_soc_1, Rx_soc_2, Rx_soc_3,
        Rx_en_0, Rx_en_1, Rx_en_2, Rx_en_3,
        Rx_clav_0, Rx_clav_1, Rx_clav_2, Rx_clav_3,
        Tx_clk_0, Tx_clk_1, Tx_clk_2, Tx_clk_3,
        Tx_data_0, Tx_data_1, Tx_data_2, Tx_data_3,
        Tx_soc_0, Tx_soc_1, Tx_soc_2, Tx_soc_3,
        Tx_en_0, Tx_en_1, Tx_en_2, Tx_en_3,
        Tx_clav_0, Tx_clav_1, Tx_clav_2, Tx_clav_3,
        rst, clk);

    test_ports t1 (Rx_clk_0, Rx_clk_1, Rx_clk_2, Rx_clk_3,
                   Rx_data_0, Rx_data_1, Rx_data_2, Rx_data_3,
                   Rx_soc_0, Rx_soc_1, Rx_soc_2, Rx_soc_3,
                   Rx_en_0, Rx_en_1, Rx_en_2, Rx_en_3,
                   Rx_clav_0, Rx_clav_1, Rx_clav_2, Rx_clav_3,
                   Tx_clk_0, Tx_clk_1, Tx_clk_2, Tx_clk_3,
                   Tx_data_0, Tx_data_1, Tx_data_2, Tx_data_3,
                   Tx_soc_0, Tx_soc_1, Tx_soc_2, Tx_soc_3,
                   Tx_en_0, Tx_en_1, Tx_en_2, Tx_en_3,
                   Tx_clav_0, Tx_clav_1, Tx_clav_2, Tx_clav_3,
                   rst, clk);

endmodule
","""Verilog code snippet showing the instantiation of an ATM router with multiple ports and clock signals in a top-level module.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p333.jpg,True,"The image contains several snippets of Verilog code related to properties and case statements within SystemVerilog assertions. Here are the code excerpts:

```verilog
N1: assert property
    @(posedge clk1) x |-> nexttime @(posedge clk2) z;
```

Important Note explanation and an exercise question are provided but not requested.

Below is the continuation of the code for the case statement example:

```verilog
property CycleCase (logic [1:0] CycleType);
    case (CycleType)
        2'b00: $fell(frame_) #1 (cmd==READ);
        2'b01: $fell(frame_) #1 (cmd==WRITE);
        2'b10: $fell(frame_) #1 (cmd==TABORT);
        2'b11: $fell(frame_) #1 (cmd==MABORT);
        default: $fell(frame_) #1 (cmd==ILLEGAL); //default is optional
    endcase
endproperty
```

Additional explanation is provided about the behavior when no `default` statement is present and no case branch matches.","
N1: assert property
    @(posedge clk1) x |-> nexttime @(posedge clk2) z;


property CycleCase (logic [1:0] CycleType);
    case (CycleType)
        2'b00: $fell(frame_) #1 (cmd==READ);
        2'b01: $fell(frame_) #1 (cmd==WRITE);
        2'b10: $fell(frame_) #1 (cmd==TABORT);
        2'b11: $fell(frame_) #1 (cmd==MABORT);
        default: $fell(frame_) #1 (cmd==ILLEGAL); //default is optional
    endcase
endproperty
","Caption: ""Excerpt explaining the use of 'assert property' with sequential implications in SystemVerilog and an illustration of the 'case' statement within properties.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p268.jpg,True,"The image contains Verilog code. Here it is:

```verilog
sequence s_mchk8a(temp1);
    @(posedge clk)
    ((( !gntn || $rose (gntn))
    && $fell (framen)),temp1=cxben[3:0])
    ##[1:2] $fell (irdyn) ##[0:5] $fell (stopn)
    && $fell (deveseln) && !rdyn;
endsequence

sequence s_mchk8b(temp2);
    @(posedge clk)
    $fell (reqn) ##[0:100] !gntn
    ##[0:5] $fell (framen)
    ##0 ((cxben[3:0] == temp2));
endsequence

property p_mchk8;
    int temp;
    @(posedge clk)
    s_mchk8a(temp) |-> ##[2:20] s_mchk8b(temp);
endproperty

a_mchk8: assert property(p_mchk8);
c_mchk8: cover property(p_mchk8);
```

This Verilog code defines two sequences `s_mchk8a` and `s_mchk8b`, a property `p_mchk8`, and uses this property in an assert and a cover statement with labels `a_mchk8` and `c_mchk8` respectively. The code is likely used for formal verification or testing of a hardware design.","
sequence s_mchk8a(temp1);
    @(posedge clk)
    ((( !gntn || $rose (gntn))
    && $fell (framen)),temp1=cxben[3:0])
    ##[1:2] $fell (irdyn) ##[0:5] $fell (stopn)
    && $fell (deveseln) && !rdyn;
endsequence

sequence s_mchk8b(temp2);
    @(posedge clk)
    $fell (reqn) ##[0:100] !gntn
    ##[0:5] $fell (framen)
    ##0 ((cxben[3:0] == temp2));
endsequence

property p_mchk8;
    int temp;
    @(posedge clk)
    s_mchk8a(temp) |-> ##[2:20] s_mchk8b(temp);
endproperty

a_mchk8: assert property(p_mchk8);
c_mchk8: cover property(p_mchk8);
","Verilog code for transaction retry logic, with sequences and properties for assertion-based verification.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p636.jpg,True,"```c
acc_close();
return(0);
}

/***********************************************************************
* calltf routine: Registers a callback to the C model interface 
* whenever any input to the C model changes value 
***********************************************************************/
int PLIbook_ScientificALU_calltf()
{
    handle instance_h, enable_h, a_h, b_h, opcode_h;

    acc_initialize();

    /* get handles for signals in task args which are C model inputs */
    enable_h = acc_handle_tfarg(ALU_ENABLE);
    a_h      = acc_handle_tfarg(ALU_A);
    b_h      = acc_handle_tfarg(ALU_B);
    opcode_h = acc_handle_tfarg(ALU_OP);

    /* get handles for this system task instance to pass to VCL app. */
    instance_h = acc_handle_tfinst();

    /* add VCL flags to all signals which are inputs to the C model */
    /* pass handle for task instance as the user_data value        */
    acc_vcl_add(enable_h, PLIbook_ScientificALU_interface,
                (char*)instance_h, vcl_verilog_logic);
    acc_vcl_add(a_h, PLIbook_ScientificALU_interface,
                (char*)instance_h, vcl_verilog_logic);
    acc_vcl_add(b_h, PLIbook_ScientificALU_interface,
                (char*)instance_h, vcl_verilog_logic);
    acc_vcl_add(opcode_h, PLIbook_ScientificALU_interface,
                (char*)instance_h, vcl_verilog_logic);

    acc_close();
    return(0);
}
```","lose();
return(0);
}

/***********************************************************************
* calltf routine: Registers a callback to the C model interface 
* whenever any input to the C model changes value 
***********************************************************************/
int PLIbook_ScientificALU_calltf()
{
    handle instance_h, enable_h, a_h, b_h, opcode_h;

    acc_initialize();

    /* get handles for signals in task args which are C model inputs */
    enable_h = acc_handle_tfarg(ALU_ENABLE);
    a_h      = acc_handle_tfarg(ALU_A);
    b_h      = acc_handle_tfarg(ALU_B);
    opcode_h = acc_handle_tfarg(ALU_OP);

    /* get handles for this system task instance to pass to VCL app. */
    instance_h = acc_handle_tfinst();

    /* add VCL flags to all signals which are inputs to the C model */
    /* pass handle for task instance as the user_data value        */
    acc_vcl_add(enable_h, PLIbook_ScientificALU_interface,
                (char*)instance_h, vcl_verilog_logic);
    acc_vcl_add(a_h, PLIbook_ScientificALU_interface,
                (char*)instance_h, vcl_verilog_logic);
    acc_vcl_add(b_h, PLIbook_ScientificALU_interface,
                (char*)instance_h, vcl_verilog_logic);
    acc_vcl_add(opcode_h, PLIbook_ScientificALU_interface,
                (char*)instance_h, vcl_verilog_logic);

    acc_close();
    return(0);
}
","""Example of Verilog PLI code for handling callback registrations and representing propagation delays in a C model.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p147.jpg,True,"There is no executable code presented in this image, but there are formal expressions and notations related to sequence operations in Verilog. Verilog is a hardware description language used to model electronic systems. The text describes rules for sequence concatenation and initial delay operators which are part of temporal property specification in the context of SystemVerilog Assertions (SVA). Here are the listed expressions from the image:

```verilog
r ##0 s is a sequence fusion.
r ##1 s is a sequence concatenation.
r ##n s, where n > 1 is defined in terms of repetition:

r ##n s = r ##1 1[x*n-1] ##1 s.

##n s = 1[x*n] ##1 s.

r ##[0:0] s = r ##0 s.
r ##[m:n] s = (r ##1 1[x*m-1:n-1] ##1 s), where n ≥ m > 0.
r ##[0:n] s = (r ##0 s) or (r ##[1:n] s), where n > 0.
r ##[m:$] s = (r ##1 1[x*m-1:$] ##1 s), where m > 0.
r ##[0:$] s = (r ##0 s) or (r ##[1:$] s), where m > 0.

##[m:n] s = 1 ##[m:n] s, where n ≥ m ≥ 0.
##[m:$] s = 1 ##[m:$] s, where m ≥ 0.
```

These expressions pertain to how sequences can be concatenated with delays in SystemVerilog Assertions, where `##` is the delay operator, `[]` represents ranges of delay, and `$` signifies an infinite range. This is not executable code but rather a part of the specification language for assertions in digital circuit design verification.","
r ##0 s is a sequence fusion.
r ##1 s is a sequence concatenation.
r ##n s, where n > 1 is defined in terms of repetition:

r ##n s = r ##1 1[x*n-1] ##1 s.

##n s = 1[x*n] ##1 s.

r ##[0:0] s = r ##0 s.
r ##[m:n] s = (r ##1 1[x*m-1:n-1] ##1 s), where n ≥ m > 0.
r ##[0:n] s = (r ##0 s) or (r ##[1:n] s), where n > 0.
r ##[m:$] s = (r ##1 1[x*m-1:$] ##1 s), where m > 0.
r ##[0:$] s = (r ##0 s) or (r ##[1:$] s), where m > 0.

##[m:n] s = 1 ##[m:n] s, where n ≥ m ≥ 0.
##[m:$] s = 1 ##[m:$] s, where m ≥ 0.
","""Exploring Sequence Concatenation and Delay Ranges in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p153.jpg,True,"The image contains a segment of a document that discusses Verilog bit vector functions and how to use them in assertions. The actual code snippet from this image is as follows:

```verilog
dr_t: assert final (en -> (`countbits(bus_in, 1’bz) == 0));
```

This piece of code is demonstrating the use of the `countbits` function in Verilog, which is used in an assertion to ensure that when the enable signal `en` is high, the bus `bus_in` does not have any bits in a high impedance state ('bz).","
dr_t: assert final (en -> (`countbits(bus_in, 1’bz) == 0));
","""Overview of Verilog Bit Vector Functions and Usage Example""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p144.jpg,True,"The image contains Verilog PLI code. Here's the code as written in the image:

```c
/* Calltf application */
int PLIbook_CountPrims_calltf(char *user_data)
{
    vpiHandle top_mod_itr, top_mod_h;
    int total_prims = 0;
    top_mod_itr = vpi_iterate(vpiModule, NULL); /*get top modules*/
    while (top_mod_h = vpi_scan(top_mod_itr)) {
        total_prims += PLIbook_find_child_mod(top_mod_h);
    }
    vpi_printf(""Total number of primitives is %d\n\n"", total_prims);
    return(0);
}

/* Function to look for module instances in local scope.
 * THIS FUNCTION CALLS ITSELF RECURSIVELY.
 */
int PLIbook_find_child_mod(vpiHandle this_mod_h)
{
    vpiHandle child_mod_itr, child_mod_h;
    int prims_in_child;

    prims_in_child = PLIbook_count_local_prims(this_mod_h);
    child_mod_itr = vpi_iterate(vpiModule, this_mod_h);
    if (child_mod_itr != NULL)
        while (child_mod_h = vpi_scan(child_mod_itr))
            prims_in_child += PLIbook_find_child_mod(child_mod_h);
    return(prims_in_child);
}
```

Please note that the actual function `PLIbook_count_local_prims` is not provided in the image, but it is likely a part of the same PLI application and is used here within `PLIbook_find_child_mod` to count primitives in a module.","lltf application */
int PLIbook_CountPrims_calltf(char *user_data)
{
    vpiHandle top_mod_itr, top_mod_h;
    int total_prims = 0;
    top_mod_itr = vpi_iterate(vpiModule, NULL); /*get top modules*/
    while (top_mod_h = vpi_scan(top_mod_itr)) {
        total_prims += PLIbook_find_child_mod(top_mod_h);
    }
    vpi_printf(""Total number of primitives is %d\n\n"", total_prims);
    return(0);
}

/* Function to look for module instances in local scope.
 * THIS FUNCTION CALLS ITSELF RECURSIVELY.
 */
int PLIbook_find_child_mod(vpiHandle this_mod_h)
{
    vpiHandle child_mod_itr, child_mod_h;
    int prims_in_child;

    prims_in_child = PLIbook_count_local_prims(this_mod_h);
    child_mod_itr = vpi_iterate(vpiModule, this_mod_h);
    if (child_mod_itr != NULL)
        while (child_mod_h = vpi_scan(child_mod_itr))
            prims_in_child += PLIbook_find_child_mod(child_mod_h);
    return(prims_in_child);
}
","""Verilog PLI code example for counting primitive modules in a Verilog design hierarchy.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p469.jpg,True,"Here is the Verilog code contained in the image:

```verilog
class parent;
  rand byte pByte;

  covergroup pCov;
    coverpoint pByte
      { bins parentBins [ ] = {[0:255]}; } //256 bins for 256 values of pByte.
  endgroup

  function new ( );
    pCov = new;
  endfunction

endclass

class child extends parent;

  covergroup pCov; // 'class child' overrides 'covergroup pCov' of 'class parent'
    coverpoint pByte
      { bins childBinsAllinOne = {[0:255]}; } //ONE bin for all values
  endgroup

  function new ( );
    super.new ( );
    pCov = new;
  endfunction

endclass
```","
class parent;
  rand byte pByte;

  covergroup pCov;
    coverpoint pByte
      { bins parentBins [ ] = {[0:255]}; } //256 bins for 256 values of pByte.
  endgroup

  function new ( );
    pCov = new;
  endfunction

endclass

class child extends parent;

  covergroup pCov; // 'class child' overrides 'covergroup pCov' of 'class parent'
    coverpoint pByte
      { bins childBinsAllinOne = {[0:255]}; } //ONE bin for all values
  endgroup

  function new ( );
    super.new ( );
    pCov = new;
  endfunction

endclass
","Caption: ""Verilog code demonstrating how to override covergroups in a child class, with examples of defining coverpoints and bins.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p41.jpg,True,"The image includes an example of Verilog code from a book or document. Here is the code from the image:

```verilog
int PLIbook_ShowVal_compiletf(char *user_data)
{
  vpiHandle systf_handle, arg_iterator, arg_handle;
  int arg_type;

  /* obtain a handle to the system task instance */
  systf_handle = vpi_handle(vpiSysTfCall, NULL);
  if (systf_handle == NULL) {
    vpi_printf(""ERROR: $show_value failed to obtain systf handle\n"");
    tf_dofinish(); /* abort simulation */
    return(0);
  }

  /* obtain handles to system task arguments */
  arg_iterator = vpi_iterate(vpiArgument, systf_handle);
  if (arg_iterator == NULL) {
    vpi_printf(""ERROR: $show_value requires 1 argument\n"");
    tf_dofinish(); /* abort simulation */
    return(0);
  }

  /* check the type of object in system task arguments */
  arg_handle = vpi_scan(arg_iterator);
  arg_type = vpi_get(vpiType, arg_handle);
  if (arg_type != vpiNet && arg_type != vpiReg) {
    vpi_printf(""ERROR: $show_value arg must be a net or reg\n"");
    vpi_free_object(arg_iterator); /* free iterator memory */
    tf_dofinish(); /* abort simulation */
    return(0);
  }

  /* check that there are no more system task arguments */
  arg_handle = vpi_scan(arg_iterator);
  if (arg_handle != NULL) {
    vpi_printf(""ERROR: $show_value can only have 1 argument\n"");
    vpi_free_object(arg_iterator); /* free iterator memory */
    tf_dofinish(); /* abort simulation */
    return(0);
  }

  return(0);
}
```

The code is part of a section titled ""CHAPTER 1: Creating PLI Applications Using VPI Routines"", and it provides a Verilog PLI (Programming Language Interface) example for a compiletf routine, which is used for checking the correctness of system task arguments during compilation in a Verilog simulation environment.","
int PLIbook_ShowVal_compiletf(char *user_data)
{
  vpiHandle systf_handle, arg_iterator, arg_handle;
  int arg_type;

  /* obtain a handle to the system task instance */
  systf_handle = vpi_handle(vpiSysTfCall, NULL);
  if (systf_handle == NULL) {
    vpi_printf(""ERROR: $show_value failed to obtain systf handle\n"");
    tf_dofinish(); /* abort simulation */
    return(0);
  }

  /* obtain handles to system task arguments */
  arg_iterator = vpi_iterate(vpiArgument, systf_handle);
  if (arg_iterator == NULL) {
    vpi_printf(""ERROR: $show_value requires 1 argument\n"");
    tf_dofinish(); /* abort simulation */
    return(0);
  }

  /* check the type of object in system task arguments */
  arg_handle = vpi_scan(arg_iterator);
  arg_type = vpi_get(vpiType, arg_handle);
  if (arg_type != vpiNet && arg_type != vpiReg) {
    vpi_printf(""ERROR: $show_value arg must be a net or reg\n"");
    vpi_free_object(arg_iterator); /* free iterator memory */
    tf_dofinish(); /* abort simulation */
    return(0);
  }

  /* check that there are no more system task arguments */
  arg_handle = vpi_scan(arg_iterator);
  if (arg_handle != NULL) {
    vpi_printf(""ERROR: $show_value can only have 1 argument\n"");
    vpi_free_object(arg_iterator); /* free iterator memory */
    tf_dofinish(); /* abort simulation */
    return(0);
  }

  return(0);
}
","""Example of a VPI complibtf routine for a PLI application in Verilog, demonstrating error handling and argument iteration.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p622.jpg,True,"The image contains a snippet of Verilog PLI (Programming Language Interface) code. Here's the code transcribed from the image:

```c
acc_initialize();

/* Retrieve instance handle from VCL user_data field */
instance_h = (handle)vc_record->user_data;

/* Obtain handles to all task arguments */
result_h = acc_handle_itfarg(ALU_RESULT, instance_h);
excep_h = acc_handle_itfarg(ALU_EXCEPT, instance_h);
err_h = acc_handle_itfarg(ALU_ERROR, instance_h);
a_h = acc_handle_itfarg(ALU_A, instance_h);
b_h = acc_handle_itfarg(ALU_B, instance_h);
opcode_h = acc_handle_itfarg(ALU_OP, instance_h);

/* Read current values of C model inputs from Verilog simulation */
value_s.format = accRealVal;
acc_fetch_value(a_h, ""%f"", &value_s);
a = value_s.value.real;

acc_fetch_value(b_h, ""%f"", &value_s);
b = value_s.value.real;

value_s.format = accIntVal;
acc_fetch_value(opcode_h, ""%d"", &value_s);
opcode = value_s.value.integer;

/****** Call C model ******/
PLIbook_ScientificALU_C_model(a, b, opcode, &result, &excep, &err);

/* Write the C model outputs onto the Verilog signals */
delay_s.model = accNoDelay;
delay_s.time = time_s;
delay_s.time.type = accRealTime;
delay_s.time.real = 0.0;

value_s.format = accRealVal;
value_s.value.real = result;
acc_set_value(result_h, &value_s, &delay_s);

value_s.format = accIntVal;
value_s.value.integer = excep;
acc_set_value(excep_h, &value_s, &delay_s);

value_s.value.integer = err;
acc_set_value(err_h, &value_s, &delay_s);

acc_close();
return(0);
}
```

This code demonstrates how to interface a C model with Verilog code using the Verilog PLI, allowing simulation of Verilog modules to incorporate behavior defined in C functions. It shows the initialization, accessing task arguments, reading simulation data, calling a C function, and writing back results to the simulation.","nitialize();

/* Retrieve instance handle from VCL user_data field */
instance_h = (handle)vc_record->user_data;

/* Obtain handles to all task arguments */
result_h = acc_handle_itfarg(ALU_RESULT, instance_h);
excep_h = acc_handle_itfarg(ALU_EXCEPT, instance_h);
err_h = acc_handle_itfarg(ALU_ERROR, instance_h);
a_h = acc_handle_itfarg(ALU_A, instance_h);
b_h = acc_handle_itfarg(ALU_B, instance_h);
opcode_h = acc_handle_itfarg(ALU_OP, instance_h);

/* Read current values of C model inputs from Verilog simulation */
value_s.format = accRealVal;
acc_fetch_value(a_h, ""%f"", &value_s);
a = value_s.value.real;

acc_fetch_value(b_h, ""%f"", &value_s);
b = value_s.value.real;

value_s.format = accIntVal;
acc_fetch_value(opcode_h, ""%d"", &value_s);
opcode = value_s.value.integer;

/****** Call C model ******/
PLIbook_ScientificALU_C_model(a, b, opcode, &result, &excep, &err);

/* Write the C model outputs onto the Verilog signals */
delay_s.model = accNoDelay;
delay_s.time = time_s;
delay_s.time.type = accRealTime;
delay_s.time.real = 0.0;

value_s.format = accRealVal;
value_s.value.real = result;
acc_set_value(result_h, &value_s, &delay_s);

value_s.format = accIntVal;
value_s.value.integer = excep;
acc_set_value(excep_h, &value_s, &delay_s);

value_s.value.integer = err;
acc_set_value(err_h, &value_s, &delay_s);

acc_close();
return(0);
}
","""Example of Programming Language Interface (PLI) code in Verilog for interfacing with a C model""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p153.jpg,True,"```verilog
module mbox_example1 ( ... );
  logic [15:0] a, b;
  int i, j = 5;
  struct packed {int u, v, w;} d_in, d_out;

  mailbox mbox1 = new; // typeless mailbox

  initial begin
    mbox1.put(a);      // OK: can put message of any data type
    mbox1.put(i);      // OK: can put message of any data type
    mbox1.put(d_in);   // OK: can put message of any data type

    mbox1.get(b);      // OK: data type of b matches data type of
                       // first message in mbox1
    mbox1.get(b);      // ERROR: b is wrong type for next message
                       // in mbox1
  end
endmodule
```","
module mbox_example1 ( ... );
  logic [15:0] a, b;
  int i, j = 5;
  struct packed {int u, v, w;} d_in, d_out;

  mailbox mbox1 = new; // typeless mailbox

  initial begin
    mbox1.put(a);      // OK: can put message of any data type
    mbox1.put(i);      // OK: can put message of any data type
    mbox1.put(d_in);   // OK: can put message of any data type

    mbox1.get(b);      // OK: data type of b matches data type of
                       // first message in mbox1
    mbox1.get(b);      // ERROR: b is wrong type for next message
                       // in mbox1
  end
endmodule
","""Verilog Gotcha: Potential Pitfall with Typeless Mailboxes for Synchronization""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p245.jpg,True,"The image contains two snippets of Verilog code. Here they are:

1.
```verilog
module NoNets (output Xout, input Ain, Bin);
    and And01 (Xout, Ain, Bin);
endmodule
```

2.
```verilog
module NoThing (output Xout, input Ain);
    assign Xout = Ain;
endmodule
```","
module NoNets (output Xout, input Ain, Bin);
    and And01 (Xout, Ain, Bin);
endmodule


module NoThing (output Xout, input Ain);
    assign Xout = Ain;
endmodule
","""Overview of built-in gate types in Verilog and an example of module declaration for a unidirectional buffer.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p177.jpg,True,"The image contains Verilog code. Here is the code written out for you:

```verilog
`ifdef `COVERAGE_ON
assert_always #(`COVERAGE, 0, ""`CMD_READ"") read (clk, reset_n,
    !(pop=='b1 && data_out=='READ));

assert_always #(`COVERAGE, 0, ""`CMD_IO_READ"") io_read (clk, reset_n,
    !(pop=='b1 && data_out=='IO_READ));

assert_always #(`COVERAGE, 0, ""`CMD_WRITE"") write (clk, reset_n,
    !(pop=='b1 && data_out=='WRITE));

assert_always #(`COVERAGE, 0, ""`CMD_IO_WRITE"") io_write (clk, reset_n,
    !(pop=='b1 && data_out=='IO_WRITE));
`endif // COVERAGE_ON
```

The second code block on the image shows the following:

```verilog
assert always ({hreadƴ} |=> 
    { SƦE_AHB_BURST_MODE_READ
    | SƦE_AHB_BURST_MODE_WRITE
    | SƦE_AHB_SINGLE_READ
    | SƦE_AHB_SINGLE_WRITE
    | SƦE_AHB_INACTIVE
    | SƦE_AHB_RESET
    });
```

Note that in the code above, certain characters might not be correctly represented due to the limitations of the font or OCR issues. For example, `hreadƴ` should probably be `hready` (if `y` is the actual signal name), and `SƦE` is likely meant to be a placeholder for a signal name or a define directive, but it's been captured incorrectly. Please make sure to adjust the code accordin to the actual intended signals or names from your source.","
`ifdef `COVERAGE_ON
assert_always #(`COVERAGE, 0, ""`CMD_READ"") read (clk, reset_n,
    !(pop=='b1 && data_out=='READ));

assert_always #(`COVERAGE, 0, ""`CMD_IO_READ"") io_read (clk, reset_n,
    !(pop=='b1 && data_out=='IO_READ));

assert_always #(`COVERAGE, 0, ""`CMD_WRITE"") write (clk, reset_n,
    !(pop=='b1 && data_out=='WRITE));

assert_always #(`COVERAGE, 0, ""`CMD_IO_WRITE"") io_write (clk, reset_n,
    !(pop=='b1 && data_out=='IO_WRITE));
`endif // COVERAGE_ON


assert always ({hreadƴ} |=> 
    { SƦE_AHB_BURST_MODE_READ
    | SƦE_AHB_BURST_MODE_WRITE
    | SƦE_AHB_SINGLE_READ
    | SƦE_AHB_SINGLE_WRITE
    | SƦE_AHB_INACTIVE
    | SƦE_AHB_RESET
    });
","""Examples of Verilog Assertions for Command Packet Coverage and AHB Protocol Valid Transactions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p73.jpg,True,"```verilog
always @(posedge data[0],  // rising edge of each bit
         posedge data[1],
         posedge data[2],
         posedge data[3])

always @(posedge data[3])  // rising edge of specific bit only

always @(posedge |data)  // rising edge of unary OR of all bits

always @(negedge |data)  // falling edge of unary OR of all bits
```","
always @(posedge data[0],  // rising edge of each bit
         posedge data[1],
         posedge data[2],
         posedge data[3])

always @(posedge data[3])  // rising edge of specific bit only

always @(posedge |data)  // rising edge of unary OR of all bits

always @(negedge |data)  // falling edge of unary OR of all bits
","""Understanding edge detection in Verilog vectors to avoid RTL modeling gotchas.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p67.jpg,True,"The image contains Verilog code snippets related to a discussion about combinational logic sensitivity lists with function calls in RTL modeling. Here is the code transcribed from the image:

```verilog
always @(a, b) begin    // OK, sensitivity list complete
    sum = a + b;
end

always @(a, b) begin    // OK, sensitivity list complete
    prod = mult(a, b);  // call function that reads a, b
end

always @(a, b) begin    // GOTCHA! sensitivity list not complete
    out = sel? sum: prod ;  // missing sel
end

function [15:0] mult (input [7:0] m, n);
    mult = m * n;
endfunction
```

Please note the special comments within the code that signify if the sensitivity list is complete or not, and point out the ""GOTCHA"" where the list is not complete because 'sel' is missing.","
always @(a, b) begin    // OK, sensitivity list complete
    sum = a + b;
end

always @(a, b) begin    // OK, sensitivity list complete
    prod = mult(a, b);  // call function that reads a, b
end

always @(a, b) begin    // GOTCHA! sensitivity list not complete
    out = sel? sum: prod ;  // missing sel
end

function [15:0] mult (input [7:0] m, n);
    mult = m * n;
endfunction
","""Verilog Gotcha: Ensuring sensitivity lists in combinational logic are complete, including function calls.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p537.jpg,True,"The image contains Verilog code examples. Here they are transcribed:

```verilog
fork
  #2 Xin = Ain && Bin;
  #3 Yin = Bin ^ Clevel;
join
```

```verilog
bit[7:0] StartBit = 8'b0111_1010;
```

```verilog
logic [7:0] a, b, c, d;
a = '0; // Same as a = 8'b0000_0000.
b = '1; // Same as b = 8'b1111_1111.
c = 'x; // Same as c = 8'bxxxx_xxxx.
d = 'z; // Same as d = 8'bzzzz_zzzz.
```

```verilog
always @(ClockIn iff Ena=='1'b1) . . .;
```","
fork
  #2 Xin = Ain && Bin;
  #3 Yin = Bin ^ Clevel;
join


bit[7:0] StartBit = 8'b0111_1010;


logic [7:0] a, b, c, d;
a = '0; // Same as a = 8'b0000_0000.
b = '1; // Same as b = 8'b1111_1111.
c = 'x; // Same as c = 8'bxxxx_xxxx.
d = 'z; // Same as d = 8'bzzzz_zzzz.


always @(ClockIn iff Ena=='1'b1) . . .;
","Caption: ""Excerpt from a textbook on Digital VLSI Design with Verilog showcasing examples of Verilog code for concurrent logic instances, new bit type usage, unsized literals, and gated event control with 'iff' in always blocks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p147.jpg,True,"The image contains Verilog code, which I will transcribe below:

```verilog
module event_example1;

event get_data, send_data; // handshaking flags

initial -> get_data;       // GOTCHA! trigger at time zero

always @(get_data) begin   // wait for a get_data event
  ... // code to get data
  ... // when done, trigger send_data
  -> send_data;            // sync with send_data process
end

always @(send_data) begin  // wait for a send_data event
  ... // code to send data
  ... // when done, trigger get_data
  -> get_data;             // sync with get_data process
end

endmodule
```

The commentary in the image explains that this code is part of a discussion on event trigger race conditions in Verilog programming.","
module event_example1;

event get_data, send_data; // handshaking flags

initial -> get_data;       // GOTCHA! trigger at time zero

always @(get_data) begin   // wait for a get_data event
  ... // code to get data
  ... // when done, trigger send_data
  -> send_data;            // sync with send_data process
end

always @(send_data) begin  // wait for a send_data event
  ... // code to send data
  ... // when done, trigger get_data
  -> get_data;             // sync with get_data process
end

endmodule
","Caption: ""Exploration of race conditions with event triggers in Verilog code""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p279.jpg,True,"The image contains Verilog code. Here are the sections from the image:

1.
```verilog
parameter Latch = 1;
...
generate
if (Latch==1)
  Mux32BitI Mux01(OutBus, ArgA, ArgB, Sel, Ena);
else Mux32Bit Mux01(OutBus, ArgA, ArgB, Sel, Ena/*unused internally*/);
endgenerate
```

2.
```verilog
Mux32BitI Mux01(.OutBus(), .I1(ArgA), .I2(ArgB), .Sel(Sel), .Ena(Ena));
```

3.
```verilog
`define Latch 1 // Macro name, but no macro; used as flag for `ifdef.
...
`ifdef Latch  // NOT `ifdef `Latch; that substitutes a '1'!
  Mux32BitI Mux01(OutBus, ArgA, ArgB, Sel, Ena);
`else
  // If no `define Latch
  Mux32Bit Mux01(OutBus, ArgA, ArgB, Sel, Ena/*unused internally*/);
`endif
```

These snippets show different ways of configuring a Verilog module based on a parameter or a macro definition. The first uses a generate statement, the second demonstrates an instance port connection by name using dot notation, and the third uses `ifdef` compiler directives to conditionally compile code based on the presence of a macro.","
parameter Latch = 1;
...
generate
if (Latch==1)
  Mux32BitI Mux01(OutBus, ArgA, ArgB, Sel, Ena);
else Mux32Bit Mux01(OutBus, ArgA, ArgB, Sel, Ena/*unused internally*/);
endgenerate


Mux32BitI Mux01(.OutBus(), .I1(ArgA), .I2(ArgB), .Sel(Sel), .Ena(Ena));


`define Latch 1 // Macro name, but no macro; used as flag for `ifdef.
...
`ifdef Latch  // NOT `ifdef `Latch; that substitutes a '1'!
  Mux32BitI Mux01(OutBus, ArgA, ArgB, Sel, Ena);
`else
  // If no `define Latch
  Mux32Bit Mux01(OutBus, ArgA, ArgB, Sel, Ena/*unused internally*/);
`endif
","""Verilog conditional generate constructs and conditional compilation directives.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p386.jpg,True,"```verilog
covergroup cg_SEC_type
  with function sample(startType startCode, endType endCode);
    SC: coverpoint startCode;
    EC: coverpoint endCode;
    sec_cross: cross SC, EC;
  endgroup

cg_SEC_type cg_SEC = new();

sequence s_SEC;
  startType l_startCode;
  (start, l_startCode = startCode)
  ##1
  (
    complete[-1],
    cg_SEC.sample(l_startCode, endCode)
  );
endsequence

c_SEC: cover property(s_SEC);
```
","
covergroup cg_SEC_type
  with function sample(startType startCode, endType endCode);
    SC: coverpoint startCode;
    EC: coverpoint endCode;
    sec_cross: cross SC, EC;
  endgroup

cg_SEC_type cg_SEC = new();

sequence s_SEC;
  startType l_startCode;
  (start, l_startCode = startCode)
  ##1
  (
    complete[-1],
    cg_SEC.sample(l_startCode, endCode)
  );
endsequence

c_SEC: cover property(s_SEC);
","""Example of a Verilog covergroup and cover property for collecting coverage with local variables and a function call.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p391.jpg,True,"The image contains code written in C language. Below is the transcription of the code from the image:

```c
/************************************************************************
 * Function to dump each word of a Verilog array in hexadecimal
 ************************************************************************/
void PLLbook_DumpMemHex(p_tfnodeinfo node_info)
{
    char *aval_ptr, *bval_ptr;
    int word_increment, mem_address, group_num;

    io_printf("" Current memory contents of aval/bval groups in hex:\n"");
    word_increment = node_info->node_ngroups * 2;
    for (mem_address = 0;
         mem_address < node_info->node_mem_size;
         mem_address++) {
        io_printf("" C array address %d:"", mem_address);

        /* set pointers to aval and bval words for the address */
        aval_ptr = node_info->node_value.memoryval_p
                   + (mem_address * word_increment);
        bval_ptr = aval_ptr + node_info->node_ngroups;

        /* print groups in word in reverse order so will match Verilog:
           the highest group number represents the left-most byte of a
           Verilog word, the lowest group represents the right-most byte */
        for (group_num = node_info->node_ngroups - 1;
             group_num >= 0;
             group_num--) {
            io_printf("" group %d: %x/%x"",
                      group_num, aval_ptr[group_num], bval_ptr[group_num]);
        }
        io_printf(""\n"");
    }
    io_printf(""\n\n"");
    return;
}

/************************************************************************
 * Function to dump each word of a Verilog array in ASCII
 ************************************************************************/
void PLLbook_DumpMemAscii(p_tfnodeinfo node_info)
{
    char *aval_ptr;
    int word_increment, mem_address, group_num;

    /* Read current memory values as a string using only aval bits */
    io_printf("" Current memory contents in ASCII are:\n"");
    io_printf("" "");

    word_increment = node_info->node_ngroups * 2;
    for (mem_address = 0;
         mem_address < node_info->node_mem_size;
         mem_address++) {
        /* set pointer to aval word for the address */
        aval_ptr = node_info->node_value.memoryval_p
                   + (mem_address * word_increment);

        /* Rest of the code is not fully visible in the image */
    }
}
```

This code is provided as part of documentation for demonstrating how to read and dump memory contents from a Verilog simulation using C programming, typically in the context of Verilog PLI (Programming Language Interface). The functions are designed to print the memory contents of a Verilog array either in hexadecimal (DumpMemHex) or ASCII (DumpMemAscii) representation.","********************************************************************
 * Function to dump each word of a Verilog array in hexadecimal
 ************************************************************************/
void PLLbook_DumpMemHex(p_tfnodeinfo node_info)
{
    char *aval_ptr, *bval_ptr;
    int word_increment, mem_address, group_num;

    io_printf("" Current memory contents of aval/bval groups in hex:\n"");
    word_increment = node_info->node_ngroups * 2;
    for (mem_address = 0;
         mem_address < node_info->node_mem_size;
         mem_address++) {
        io_printf("" C array address %d:"", mem_address);

        /* set pointers to aval and bval words for the address */
        aval_ptr = node_info->node_value.memoryval_p
                   + (mem_address * word_increment);
        bval_ptr = aval_ptr + node_info->node_ngroups;

        /* print groups in word in reverse order so will match Verilog:
           the highest group number represents the left-most byte of a
           Verilog word, the lowest group represents the right-most byte */
        for (group_num = node_info->node_ngroups - 1;
             group_num >= 0;
             group_num--) {
            io_printf("" group %d: %x/%x"",
                      group_num, aval_ptr[group_num], bval_ptr[group_num]);
        }
        io_printf(""\n"");
    }
    io_printf(""\n\n"");
    return;
}

/************************************************************************
 * Function to dump each word of a Verilog array in ASCII
 ************************************************************************/
void PLLbook_DumpMemAscii(p_tfnodeinfo node_info)
{
    char *aval_ptr;
    int word_increment, mem_address, group_num;

    /* Read current memory values as a string using only aval bits */
    io_printf("" Current memory contents in ASCII are:\n"");
    io_printf("" "");

    word_increment = node_info->node_ngroups * 2;
    for (mem_address = 0;
         mem_address < node_info->node_mem_size;
         mem_address++) {
        /* set pointer to aval word for the address */
        aval_ptr = node_info->node_value.memoryval_p
                   + (mem_address * word_increment);

        /* Rest of the code is not fully visible in the image */
    }
}
",Excerpt from a textbook showing Verilog code to dump memory contents in hexadecimal and ASCII formats using TF routines.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p392.jpg,True,"The image contains Verilog code within three figures. I will provide the code from each of the figures:

Figure 16.12:
```verilog
sequence s_and_ambiguous;
  bit l_v;
  (
    (a[-:1], l_v = e)
    and
    (b[-:1], l_v = f)
  ) // SF5: l_v does not flow out, becomes unassigned
  ##1 c == l_v; // illegal
  reference to l_v
endsequence
```

Figure 16.13:
```verilog
sequence s_and_unambiguous;
  bit l_va, l_vb;
  (
    (a[-:1], l_va = e)
    and
    (b[-:1], l_vb = f)
  )
  ##1 c == l_va || c == l_vb;
endsequence
```

Figure 16.14:
```verilog
sequence s_or_ambiguous;
  bit l_v;
  ( // DF: l_v does not flow in
    (a[-:1], l_v = e)
    or
    b[-:1] // SF1: l_v does not flow out
    // SF4: l_v does not flow out, becomes unassigned
  ) ##1 c == l_v; // illegal reference to l_v
endsequence
``` 

Each block of code represents a system Verilog sequence that generates certain issues with local variable usage due to the rules of value flow and assignment within conditional expressions and sequences.","
sequence s_and_ambiguous;
  bit l_v;
  (
    (a[-:1], l_v = e)
    and
    (b[-:1], l_v = f)
  ) // SF5: l_v does not flow out, becomes unassigned
  ##1 c == l_v; // illegal
  reference to l_v
endsequence


sequence s_and_unambiguous;
  bit l_va, l_vb;
  (
    (a[-:1], l_va = e)
    and
    (b[-:1], l_vb = f)
  )
  ##1 c == l_va || c == l_vb;
endsequence


sequence s_or_ambiguous;
  bit l_v;
  ( // DF: l_v does not flow in
    (a[-:1], l_v = e)
    or
    b[-:1] // SF1: l_v does not flow out
    // SF4: l_v does not flow out, becomes unassigned
  ) ##1 c == l_v; // illegal reference to l_v
endsequence
",Caption: Examples of ambiguous and unambiguous assignments to local variables within Verilog sequences and potential issues with legality in assignment references.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p385.jpg,True,"The image contains two snippets of Verilog code. Here they are:

1. 
```verilog
reg [23:0] RAM [0:3]; //array with LSB the lowest bit number
```

2.
```verilog
reg [0:23] RAM [0:3]; //array with LSB the highest bit number
```","
reg [23:0] RAM [0:3]; //array with LSB the lowest bit number


reg [0:23] RAM [0:3]; //array with LSB the highest bit number
","""Excerpt from a textbook explaining the mapping of Verilog array words into C byte groups with reversed ordering in HDL to PLI conversion, including example Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p375.jpg,True,"The image contains two segments of code written in Verilog. Here are the two code segments:

Sample 9.8:
```verilog
covergroup CovDst8 with function sample(bit [2:0] dst, bit hs);
    coverpoint dst;
    coverpoint hs; // High speed mode
endgroup

class Transactor;
    CovDst8 covdst;
    task run();
        forever begin
            mbc.get(tr); // Get next transaction
            ifc.cb.dst <= tr.dst; // Send into DUT
            ifc.cb.data <= tr.data;
            covdst.sample(tr.dst, high_speed); // Gather coverage
        end
    endtask
endclass
```

Sample 9.9:
```verilog
event trans_ready;
covergroup CovDst9 @(trans_ready);
    coverpoint ifc.cb.dst; // Measure coverage
endgroup
```

The code segments show examples of defining a covergroup with a function sample (Sample 9.8) and a covergroup with an event trigger (Sample 9.9) in the context of hardware verification using SystemVerilog.","
covergroup CovDst8 with function sample(bit [2:0] dst, bit hs);
    coverpoint dst;
    coverpoint hs; // High speed mode
endgroup

class Transactor;
    CovDst8 covdst;
    task run();
        forever begin
            mbc.get(tr); // Get next transaction
            ifc.cb.dst <= tr.dst; // Send into DUT
            ifc.cb.data <= tr.data;
            covdst.sample(tr.dst, high_speed); // Gather coverage
        end
    endtask
endclass


event trans_ready;
covergroup CovDst9 @(trans_ready);
    coverpoint ifc.cb.dst; // Measure coverage
endgroup
",Verilog Code Examples: Triggers for Coverage Groups and Event-Driven Sampling in SystemVerilog.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p190.jpg,True,"The image contains Verilog/SystemVerilog code examples. Here is the code transcribed from the image:

```verilog
program automatic test;
  class Payload;
    rand int data[8]; // data is tagged to be randomized
  endclass

  class Header;
    rand int addr;           // addr is tagged to be randomized
    Payload p;               // handle to Payload object -- GOTCHA!
  
    function new;
      this.p = new;
    endfunction
  endclass

  initial begin
    Header h = new;
    assert(h.randomize());  // randomize address and payload data
    $display(h.addr);       // addr shows random value
    foreach (h.p.data[i])
      $display(h.p.data[i]); // GOTCHA! data was not randomized
  end
endprogram
```

And the correct code at the bottom to avoid the ""gotcha"" is:

```verilog
class Header;
  rand int addr;               // addr is tagged to be randomized
  rand Payload p;              // OK, Payload is tagged to be randomized
  ...
endclass
```","
program automatic test;
  class Payload;
    rand int data[8]; // data is tagged to be randomized
  endclass

  class Header;
    rand int addr;           // addr is tagged to be randomized
    Payload p;               // handle to Payload object -- GOTCHA!
  
    function new;
      this.p = new;
    endfunction
  endclass

  initial begin
    Header h = new;
    assert(h.randomize());  // randomize address and payload data
    $display(h.addr);       // addr shows random value
    foreach (h.p.data[i])
      $display(h.p.data[i]); // GOTCHA! data was not randomized
  end
endprogram


class Header;
  rand int addr;               // addr is tagged to be randomized
  rand Payload p;              // OK, Payload is tagged to be randomized
  ...
endclass
","Caption: ""A Verilog coding example highlighting a common gotcha in randomization where an inner object's variable is not being randomized due to a missing `rand` modifier.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p379.jpg,True,"```verilog
sequence s_arg_dirs (
  local input  byte l_s_i,
  local inout  byte l_s_io,
  local output byte l_s_o
);
  ... // l_s_o must be assigned in the body
endsequence

property p_arg_dirs;
  byte l_p_io, l_p_o;
  (start, l_p_io = e_io)
    |-> s_arg_dirs(e_i, l_p_io, l_p_o)
    |-> results_ok(l_p_io, l_p_o);
endproperty

sequence s_arg_dirs_v2 (
  local        byte l_s_i,
  local inout  byte l_s_io,
  local output byte l_s_o
);
  ...
endsequence
```","
sequence s_arg_dirs (
  local input  byte l_s_i,
  local inout  byte l_s_io,
  local output byte l_s_o
);
  ... // l_s_o must be assigned in the body
endsequence

property p_arg_dirs;
  byte l_p_io, l_p_o;
  (start, l_p_io = e_io)
    |-> s_arg_dirs(e_i, l_p_io, l_p_o)
    |-> results_ok(l_p_io, l_p_o);
endproperty

sequence s_arg_dirs_v2 (
  local        byte l_s_i,
  local inout  byte l_s_io,
  local output byte l_s_o
);
  ...
endsequence
","""Example of Verilog Sequence and Property Declaration with Local Variables""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p408.jpg,True,"The image contains a snippet of pseudo-code related to the use of automatic PLI callback functions in Verilog. Here is the text of the code from the image:

```c
int PLIbook_ReadVector_miscft(int user_data, int reason)
{
    switch(reason) {
        case REASON_ENDOFCOMPILE: /* miscft called at start of simulation */
            /* allocate a memory block for data storage */
            data_p = (p_stim_data)malloc(sizeof(s_stim_data));
            /* store a pointer to the application data in the work area */
            tf_setworkarea((char *)data_p);
            /* add code to open stimulus file and save pointer to file */
            break;

        case REASON_REACTIVATE: /* miscft called by tf_setdelay */
            /* get the pointer to the data structure from the work area */
            data_p = (p_stim_data)tf_getworkarea();
            /* add code to read next line from file and apply to simulation */
            break;
    }
}
```

This pseudo-code is a truncated example, illustrating how to use different reasons for invoking a callback routine tied to the simulation state within Verilog. It's worth noting that not all of the code necessary for a complete function implementation is provided in this excerpt.","LIbook_ReadVector_miscft(int user_data, int reason)
{
    switch(reason) {
        case REASON_ENDOFCOMPILE: /* miscft called at start of simulation */
            /* allocate a memory block for data storage */
            data_p = (p_stim_data)malloc(sizeof(s_stim_data));
            /* store a pointer to the application data in the work area */
            tf_setworkarea((char *)data_p);
            /* add code to open stimulus file and save pointer to file */
            break;

        case REASON_REACTIVATE: /* miscft called by tf_setdelay */
            /* get the pointer to the data structure from the work area */
            data_p = (p_stim_data)tf_getworkarea();
            /* add code to read next line from file and apply to simulation */
            break;
    }
}
","Excerpt from ""The Verilog PLI Handbook"" detailing misctf callback routine usage in a Verilog simulation environment.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p125.jpg,True,"The image contains Verilog code within a textual explanation of a concept. Here's the code extracted from the image:

```verilog
sequence check_rd_adr;
    ((rd_addr == $past (rd_addr+1)) && read) [*0:$] ##1 $fell(read);
endsequence

sequence read_cycle;
    ($rose(read) && reset_);
endsequence

property burst_check;
    @(posedge clk) read_cycle |-> check_rd_adr;
endproperty
```

This code is related to hardware verification and involves sequences and properties for checking signal behavior in a simulation environment.","
sequence check_rd_adr;
    ((rd_addr == $past (rd_addr+1)) && read) [*0:$] ##1 $fell(read);
endsequence

sequence read_cycle;
    ($rose(read) && reset_);
endsequence

property burst_check;
    @(posedge clk) read_cycle |-> check_rd_adr;
endproperty
",Explaining the use of `$past` in SystemVerilog Assertions (SVA) to verify incremental read address behavior during burst cycles.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p413.jpg,True,"Here is the Verilog code from the image:

For Sample 10.22 (Testbench using a typedef for virtual interfaces):
```verilog
program automatic test #(NUM_XI=2);
  vx_if vxI[NUM_XI]; // Virtual interface array
  Driver driver[ ];
  // ...
endprogram
```

For Sample 10.23 (Driver using a typedef for virtual interfaces):
```verilog
class Driver;
  vx_if xi;
  int id;

  function new(input vx_if xi, input int id);
    this.xi = xi;
    this.id = id;
  endfunction
  // ...
endclass : Driver
```

For Sample 10.24 (Testbench using an array of virtual interfaces):
```verilog
parameter NUM_XI = 2; // Number of instances

module top;
  // Instantiate N interfaces
  X_if xi [NUM_XI] (clk);
  ...
  // Instantiate the testbench
  test tb(xi);

endmodule : top
```","
program automatic test #(NUM_XI=2);
  vx_if vxI[NUM_XI]; // Virtual interface array
  Driver driver[ ];
  // ...
endprogram


class Driver;
  vx_if xi;
  int id;

  function new(input vx_if xi, input int id);
    this.xi = xi;
    this.id = id;
  endfunction
  // ...
endclass : Driver


parameter NUM_XI = 2; // Number of instances

module top;
  // Instantiate N interfaces
  X_if xi [NUM_XI] (clk);
  ...
  // Instantiate the testbench
  test tb(xi);

endmodule : top
","""Exploring Verilog testbenches with typed virtual interfaces and arrays of interfaces.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p131.jpg,True,"The image contains snippets of Verilog code, specifically within the context of SystemVerilog assertions (SVA). Here are the blocks of code visible in the image:

1.
```verilog
@(posedge clk) $rose(tagError) |-> $rose(tErrorBit) ##0 $rose(mCheck);
```

2.
```verilog
sequence Sab;
  a ##[1:3] b;
endsequence

property ab;
  @(posedge clk) a |-> Sab;
endproperty
```

3.
```verilog
property readPerf;
  @(posedge clk) ReadReq |-> ##[1:5] (dataReady || dataAbort);
endproperty
```

These code examples demonstrate the usage of temporal logic in SystemVerilog for the specification of timing constraints and behavior of digital systems. Please note that due to the image quality, there might be slight inaccuracies in the transcription.","
@(posedge clk) $rose(tagError) |-> $rose(tErrorBit) ##0 $rose(mCheck);


sequence Sab;
  a ##[1:3] b;
endsequence

property ab;
  @(posedge clk) a |-> Sab;
endproperty


property readPerf;
  @(posedge clk) ReadReq |-> ##[1:5] (dataReady || dataAbort);
endproperty
","""Examples of Verilog delay operators and timing constraints for clock event sequence specification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p407.jpg,True,"The image contains Verilog code snippets. Here they are:

Sample 10.9
```verilog
program automatic test(bus_ifc bus);
    initial $display(bus.data); // Use an interface signal
endprogram
```

Sample 10.10
```verilog
module top;
    bus_ifc bus(); // Instantiate the interface
    new_ifc newb(); // and a new one
    test t1(bus, newb); // Test with two interfaces
    dut d1(bus, newb); // DUT with two interfaces
    ...
endmodule
```

Sample 10.11
```verilog
program automatic test(bus_ifc bus, new_ifc newb);
    initial $display(bus.data); // Use an interface signal
endprogram
```

Sample 10.12
```verilog
program automatic test();
    virtual bus_ifc bus = top.bus; // Cross module reference
    initial $display(bus.data); // Use an interface signal
endprogram
```","
program automatic test(bus_ifc bus);
    initial $display(bus.data); // Use an interface signal
endprogram


module top;
    bus_ifc bus(); // Instantiate the interface
    new_ifc newb(); // and a new one
    test t1(bus, newb); // Test with two interfaces
    dut d1(bus, newb); // DUT with two interfaces
    ...
endmodule


program automatic test(bus_ifc bus, new_ifc newb);
    initial $display(bus.data); // Use an interface signal
endprogram


program automatic test();
    virtual bus_ifc bus = top.bus; // Cross module reference
    initial $display(bus.data); // Use an interface signal
endprogram
","Caption: ""Verilog code examples demonstrating the use of interfaces in testbenches and the incorporation of additional interfaces to existing module test cases.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p184.jpg,True,"Here is the code from the image:

```verilog
module test (input int instance_id);
    initial begin
        #1;
        start_test(1, instance_id); // three calls to task, with
        start_test(2, instance_id); // different thread numbers
        start_test(3, instance_id);
    end

    task automatic start_test (int thread, int inst);
        fork : monitor
        begin
            $display(""%0d: %m inst: %0d, thread: %0d, before disable"", $time, inst, thread);
            #10;
            if ((thread==2) && (inst==2))
                disable monitor; // GOTCHA! affects multiple threads
            #1;
            $display(""%0d: %m inst: %0d, thread: %0d, after disable"", $time, inst, thread);
        end
        join_none // don't wait for thread to complete
    endtask: start_test
endmodule: test

module top;
    test t1 (.instance_id(1)); // three instances of test module
    test t2 (.instance_id(2));
    test t3 (.instance_id(3));
endmodule: top
```

This is a code example from a book discussing common pitfalls in Verilog/SystemVerilog, specifically related to the behavior of `disable` statements within concurrent code blocks.","
module test (input int instance_id);
    initial begin
        #1;
        start_test(1, instance_id); // three calls to task, with
        start_test(2, instance_id); // different thread numbers
        start_test(3, instance_id);
    end

    task automatic start_test (int thread, int inst);
        fork : monitor
        begin
            $display(""%0d: %m inst: %0d, thread: %0d, before disable"", $time, inst, thread);
            #10;
            if ((thread==2) && (inst==2))
                disable monitor; // GOTCHA! affects multiple threads
            #1;
            $display(""%0d: %m inst: %0d, thread: %0d, after disable"", $time, inst, thread);
        end
        join_none // don't wait for thread to complete
    endtask: start_test
endmodule: test

module top;
    test t1 (.instance_id(1)); // three instances of test module
    test t2 (.instance_id(2));
    test t3 (.instance_id(3));
endmodule: top
",Verilog code demonstrating a gotcha where disabling a named block affects all threads with that block name.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p292.jpg,True,"The image contains snippets of Verilog parameter declarations. Here is the code extracted from the image:

```verilog
localparam DWidth = DHiBit+1;
```

```verilog
genvar j; ... for (j=0; j<DWidth; ...
```

```verilog
localparam AWidth = AHiBit+1;
```

```verilog
localparam NumAddrs = 1<<AWidth; // Same as 2**AWidth.
```

```verilog
genvar i; ... for (i=0; i<NumAddrs; ...
```

Note that some of the code snippets are incomplete, as indicated by the ellipses (...), implying there is more to the code not shown in the text.","
localparam DWidth = DHiBit+1;


genvar j; ... for (j=0; j<DWidth; ...


localparam AWidth = AHiBit+1;


localparam NumAddrs = 1<<AWidth; // Same as 2**AWidth.


genvar i; ... for (i=0; i<NumAddrs; ...
","""Understanding Data and Address Bus Width Calculations in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p352.jpg,True,"The image contains text describing the use of the Verilog Programming Language Interface (PLI) function `tf_strgetp`. There is no executable Verilog code displayed in the image, just a function signature and textual explanations. Here is the function signature that is visible:

```c
char *tf_strgetp(n, format_char)
int n
int format_char
```

This is a declaration of the `tf_strgetp` function, which is used in Verilog PLI to read values as strings following a given format.","*tf_strgetp(n, format_char)
int n
int format_char
","""Explanation of how to read values as strings in Verilog using the PLI, with details on interpreting Verilog 4-state logic values in C.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p345.jpg,True,"The image contains multiple snippets of Verilog code. Here are the code excerpts from the image:

```verilog
// ...
end
always_ff @(posedge clock) begin
  a1: assert property(@(posedge clock) ok); // Legal
  a2: assert property(@(posedge clock) req[i] |=> ack[i]); // Illegal
end
endmodule : m
```

```verilog
module m(input logic clock, reset, logic [7:0] en, ...);
default disable iff reset;

logic cond;
logic [7:0] driver;
// ...
always @(posedge clock) begin
  for (int i = 0; i < 7; i++) begin
    if (en[i] && cond) begin
      driver[i] <= ...;
      stable_for_two_ticks check_driver(driver[i]);
    end
  end
end
endmodule : m
```

```verilog
module m(input logic clock, reset, logic [7:0] en, ...);
default disable iff reset;

logic cond;
logic [7:0] driver;
bit toggle = 1'b0;
```

The text also provides context for the code, offering explanations about procedural checker assertions, checker variables, and gives an example of how procedural checkers with checker variables should behave.","
// ...
end
always_ff @(posedge clock) begin
  a1: assert property(@(posedge clock) ok); // Legal
  a2: assert property(@(posedge clock) req[i] |=> ack[i]); // Illegal
end
endmodule : m


module m(input logic clock, reset, logic [7:0] en, ...);
default disable iff reset;

logic cond;
logic [7:0] driver;
// ...
always @(posedge clock) begin
  for (int i = 0; i < 7; i++) begin
    if (en[i] && cond) begin
      driver[i] <= ...;
      stable_for_two_ticks check_driver(driver[i]);
    end
  end
end
endmodule : m


module m(input logic clock, reset, logic [7:0] en, ...);
default disable iff reset;

logic cond;
logic [7:0] driver;
bit toggle = 1'b0;
","Caption: ""Excerpt from a textbook or technical document showcasing proper and improper usage of procedural assertions and loop controls in Verilog code.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p349.jpg,True,"The image contains Verilog/SystemVerilog code. Here it is:

```verilog
class config_db #(type T=int);
  static T db[string];
  static function void set(input string name, input T value);
    db[name] = value;
  endfunction

  static function void get(input string name, ref T value);
    value = db[name];
  endfunction

  static function void print();
    $display(""\nConfiguration database %s"", $typename(T));
    foreach (db[i])
      $display(""db[%s] = %0p"", i, db[i]);
  endfunction
endclass

// Sample 8.44 Testbench for configuration database

class Tiny;
  int i;
endclass // Tiny

int i = 42, j = 43, k;             // Integers for database
real pi = 22.0/7.0, r;             // Reals for database
Tiny t;                             // Handle for database

initial begin
  config_db#(int)::set(""i"", i);     // Save an int in db
  config_db#(int)::set(""j"", j);     // Save another
  config_db#(real)::set(""pi"", pi);  // Save a real in db
  
  t = new();
  t.i = 8;
  config_db#(Tiny)::set(""t"", t);    // Save a handle in db
  config_db#(Tiny)::set(""null"", null); // Test null handles
  
  config_db#(int)::get(""i"", k);     // Fetch an int
  $display(""Fetched value (%0d) of i (%0d) "", i, k);
  
  config_db#(int)::print();         // Print int db
  config_db#(real)::print();        // Print real db
  config_db#(Tiny)::print();        // Print Tiny db
end
```

This code snippet demonstrates how to create a static configuration database in SystemVerilog using parameterized classes.","
class config_db #(type T=int);
  static T db[string];
  static function void set(input string name, input T value);
    db[name] = value;
  endfunction

  static function void get(input string name, ref T value);
    value = db[name];
  endfunction

  static function void print();
    $display(""\nConfiguration database %s"", $typename(T));
    foreach (db[i])
      $display(""db[%s] = %0p"", i, db[i]);
  endfunction
endclass

// Sample 8.44 Testbench for configuration database

class Tiny;
  int i;
endclass // Tiny

int i = 42, j = 43, k;             // Integers for database
real pi = 22.0/7.0, r;             // Reals for database
Tiny t;                             // Handle for database

initial begin
  config_db#(int)::set(""i"", i);     // Save an int in db
  config_db#(int)::set(""j"", j);     // Save another
  config_db#(real)::set(""pi"", pi);  // Save a real in db
  
  t = new();
  t.i = 8;
  config_db#(Tiny)::set(""t"", t);    // Save a handle in db
  config_db#(Tiny)::set(""null"", null); // Test null handles
  
  config_db#(int)::get(""i"", k);     // Fetch an int
  $display(""Fetched value (%0d) of i (%0d) "", i, k);
  
  config_db#(int)::print();         // Print int db
  config_db#(real)::print();        // Print real db
  config_db#(Tiny)::print();        // Print Tiny db
end
","""Example of a Verilog parameterized static class and testbench for a configuration database.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p119.jpg,True,"```verilog
property noChangeSig (pclk, refSig, StableSig);
    @(posedge pclk) refSig |-> $stable(StableSig);
endproperty

assert noChangeSig (sysClk, ConfigRd, ConfigRdParm); else failmsg;
```

```verilog
assign stableVal = ($stable(ConfigSig), @(posedge clk)) ? sigVal : errorVal;
```

These snippets are examples of Verilog/SystemVerilog code. The first one defines a property for checking if a signal remains stable, and the second one is a continuous assignment that assigns a value based on the stability of a signal.","
property noChangeSig (pclk, refSig, StableSig);
    @(posedge pclk) refSig |-> $stable(StableSig);
endproperty

assert noChangeSig (sysClk, ConfigRd, ConfigRdParm); else failmsg;


assign stableVal = ($stable(ConfigSig), @(posedge clk)) ? sigVal : errorVal;
","""Understanding the use of $stable in Verilog code for checking signal stability across clock cycles.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p499.jpg,True,"The image contains a snippet of formal mathematical-style pseudocode, which is part of a discussion on formal verification in a document about a concurrent list-based set algorithm. Here is the pseudocode:

```plaintext
leadsfromsteps(c, n, m, w): INDUCTIVE bool =
    n /= Tail AND ((w=1 AND c`next(n) = m) OR
                   (w>1 AND c`next(n) /= m AND
                    leadsfromsteps(c,c`next(n),m,w-1)))

leadsfrom(c, n, m): bool =
    EXISTS(w: leadsfromsteps(c, n, m, w))
```

This is a formal representation using logical conditions and recursion, rather than executable Verilog code. It appears to be defining predicates `leadsfromsteps` and `leadsfrom` within the context of verifying certain properties of an algorithm, possibly within a theorem prover or formal verification tool like PVS.","xt
leadsfromsteps(c, n, m, w): INDUCTIVE bool =
    n /= Tail AND ((w=1 AND c`next(n) = m) OR
                   (w>1 AND c`next(n) /= m AND
                    leadsfromsteps(c,c`next(n),m,w-1)))

leadsfrom(c, n, m): bool =
    EXISTS(w: leadsfromsteps(c, n, m, w))
","Caption: A research paper excerpt discussing the formal verification of a lazy concurrent list-based set algorithm, including a Verilog code snippet used to define a property in the verification process.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p188.jpg,True,"The image contains some written explanations and Verilog/SystemVerilog code snippets. The code in the image is as follows:

```verilog
// procedural assertion
always @(posedge clk) begin
    if (reset_n)
        full: assert property (fifo_depth < 7) else
            $error(""fifo_com Fifo64 Internal Failure, send mail to support@fifo.com"");
end
```

This piece of SystemVerilog code is an example of a procedural assertion that checks if the `fifo_depth` is less than 7 and reports an error if the assertion fails.","
// procedural assertion
always @(posedge clk) begin
    if (reset_n)
        full: assert property (fifo_depth < 7) else
            $error(""fifo_com Fifo64 Internal Failure, send mail to support@fifo.com"");
end
",Verilog Assertion Patterns: Example of an assert_range check in OVL and a valid range check in SystemVerilog.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p420.jpg,True,"The image contains a snippet of Verilog PLI (Programming Language Interface) code. Here's the code from the image:

```c
#include ""veriuser.h""                /* IEEE 1364 PLI TF routine library */
/**************************************************************
 * calltf routine
 **************************************************************/
int PLIbook_MyMonitor2_calltf() {
    tf_asynchon(); /* enable asynchronous misctf callbacks */
    return(0);
}
```

This piece of code seems to be designed for use with the Verilog PLI, which allows C routines to interact with Verilog simulators. The function `PLIbook_MyMonitor2_calltf` appears to enable asynchronous callbacks.","ude ""veriuser.h""                /* IEEE 1364 PLI TF routine library */
/**************************************************************
 * calltf routine
 **************************************************************/
int PLIbook_MyMonitor2_calltf() {
    tf_asynchon(); /* enable asynchronous misctf callbacks */
    return(0);
}
","Caption: ""Verilog PLI Handbook excerpt detailing tf_getpchange function and Example 12-6 $my_monitor2 for synchronized value change analysis in Verilog simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p98.jpg,True,"The image contains Verilog code related to an address decoder module. Here is the code excerpt from the image:

```verilog
module address_decode (input logic [1:0] address,
                       output logic rdata);

    always_comb begin
        rdata = 1'b0;                   // default value for rdata
        case (address)
            2'b00 : rdata = 1'b1;       // decodes exception to default
        endcase
    end
endmodule
```

This code represents a simple address decoder where the default value of `rdata` is `0`, and if the `address` is `00`, `rdata` is set to `1`.","
module address_decode (input logic [1:0] address,
                       output logic rdata);

    always_comb begin
        rdata = 1'b0;                   // default value for rdata
        case (address)
            2'b00 : rdata = 1'b1;       // decodes exception to default
        endcase
    end
endmodule
","""Verilog Gotcha: Misuse of unique case construct and its implications during synthesis.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p346.jpg,True,"```c
int tf_getp(n)
int     n               /* index number of a system task/function argument. */

int c_value;
c_value = tf_getp(1);   /* read task/function argument 1 */
```

```c
int tf_getlongp(highvalue, n)
int     *highvalue      /* pointer to the upper 32-bits of the value. */
int     n               /* index number of a system task/function argument. */
```

These are the pieces of C code related to Verilog PLI routines presented in the image.","f_getp(n)
int     n               /* index number of a system task/function argument. */

int c_value;
c_value = tf_getp(1);   /* read task/function argument 1 */

f_getlongp(highvalue, n)
int     *highvalue      /* pointer to the upper 32-bits of the value. */
int     n               /* index number of a system task/function argument. */
","Excerpt from ""The Verilog PLI Handbook"" discussing how to read and write 2-state values in Verilog using PLI functions.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p351.jpg,True,"The image contains Verilog code, which is related to procedural concurrent assertions. Below is the code extracted from the image:

```verilog
1. always @(posedge clk) begin
   B <= B_in;
   chk_chk_1(A, B);
end

2. always @(posedge clk) begin
   for (int i=0; i<8; i++) begin
      A[i] <= A_in[i];
      chk_chk_2(A[i], B);
   end
   B <= B_in;
end

3. always @(posedge clk) begin
   automatic logic T <= B_in;
   A <= A_in;
   chk_chk_3(A, T);
end

4. always @(posedge clk or negedge B_in) begin
   A <= A_in;
   B <= B_in;
   chk_chk_4(A, B);
end

5. always @(posedge clk or negedge B_in) begin
   A <= A_in;
   B <= B_in;
   chk_chk_5(A, B, posedge clk or negedge B_in);
end

6. always @(posedge clk or negedge rst_n) begin
   A <= A_in;
   B <= B_in;
   chk_chk_6(A, B);
end
```

The text in the image also hints at chapter or section number ""14 Procedural Concurrent Assertions"" and seems to be a part of a textbook or documentation page numbered 344. The code represents different examples of procedural blocks (always blocks) that are sensitive to clock edges and, in some cases, other signal edges, following which certain checks are performed.","
1. always @(posedge clk) begin
   B <= B_in;
   chk_chk_1(A, B);
end

2. always @(posedge clk) begin
   for (int i=0; i<8; i++) begin
      A[i] <= A_in[i];
      chk_chk_2(A[i], B);
   end
   B <= B_in;
end

3. always @(posedge clk) begin
   automatic logic T <= B_in;
   A <= A_in;
   chk_chk_3(A, T);
end

4. always @(posedge clk or negedge B_in) begin
   A <= A_in;
   B <= B_in;
   chk_chk_4(A, B);
end

5. always @(posedge clk or negedge B_in) begin
   A <= A_in;
   B <= B_in;
   chk_chk_5(A, B, posedge clk or negedge B_in);
end

6. always @(posedge clk or negedge rst_n) begin
   A <= A_in;
   B <= B_in;
   chk_chk_6(A, B);
end
","""Examples of Procedural Concurrent Assertions in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p348.jpg,True,"The image contains Verilog code. Here is the transcribed code:

```verilog
module m #(W=8, D=32) (
  input logic clk,
  input logic [W-1:0] d_in,
  output logic [W-1:0] d_out
);
logic [D*W-1:0] sh;
assign d_out = sh[D*W-1:(D-1)*W];
always @(posedge clk) begin
  sh <= {sh[(D-1)*W-1:0], d_in};
end
endmodule : m

typedef logic[31:0] natT;
module m (
  input logic clk, rst_n, load, incr,
  input natT a_in, b_in,
  output natT d_out
);
natT a, b;
assign d_out = a;
always @(posedge clk or negedge rst_n) begin
  if (!rst_n) begin
    a <= 0;
    b <= 0;
  end else if (load) begin
    a <= a_in;
    b <= b_in;
  end else if (incr) begin
    a <= a + b;
    b <= a;
  end
end
endmodule : m

logic clk, en, rst_n;
logic [7:0] a, b, d_in;
event ev;
clocking CLK @(posedge clk); endclocking

always @(edge clk) begin
  a <= d_in;
  A_STABLE: assert (a !== d_in)
end
```

Please note that the indentation and spacing of the original code in the image have been maintained for accuracy, but code formatting can vary depending on style guides or individual preferences.","
module m #(W=8, D=32) (
  input logic clk,
  input logic [W-1:0] d_in,
  output logic [W-1:0] d_out
);
logic [D*W-1:0] sh;
assign d_out = sh[D*W-1:(D-1)*W];
always @(posedge clk) begin
  sh <= {sh[(D-1)*W-1:0], d_in};
end
endmodule : m

typedef logic[31:0] natT;
module m (
  input logic clk, rst_n, load, incr,
  input natT a_in, b_in,
  output natT d_out
);
natT a, b;
assign d_out = a;
always @(posedge clk or negedge rst_n) begin
  if (!rst_n) begin
    a <= 0;
    b <= 0;
  end else if (load) begin
    a <= a_in;
    b <= b_in;
  end else if (incr) begin
    a <= a + b;
    b <= a;
  end
end
endmodule : m

logic clk, en, rst_n;
logic [7:0] a, b, d_in;
event ev;
clocking CLK @(posedge clk); endclocking

always @(edge clk) begin
  a <= d_in;
  A_STABLE: assert (a !== d_in)
end
","Caption: ""Exercises on adding procedural assertions in Verilog code and analyzing clock inference within code segments.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p344.jpg,True,"```verilog
class GenBase;
endclass

class Generator #(type T=BaseTr) extends GenBase;
    // See Generator class in Sample 8-34
endclass

GenBase gen_queue[$];
Generator #(Transaction) gen_good;
Generator #(BadTr) gen_bad;

initial begin
    gen_good = new();                  // Construct good generator
    gen_queue.push_back(gen_good);     // Save it in the queue
    gen_bad = new();                   // Construct bad generator
    gen_queue.push_back(gen_bad);      // Save it in the same queue
end
```","
class GenBase;
endclass

class Generator #(type T=BaseTr) extends GenBase;
    // See Generator class in Sample 8-34
endclass

GenBase gen_queue[$];
Generator #(Transaction) gen_good;
Generator #(BadTr) gen_bad;

initial begin
    gen_good = new();                  // Construct good generator
    gen_queue.push_back(gen_good);     // Save it in the queue
    gen_bad = new();                   // Construct bad generator
    gen_queue.push_back(gen_bad);      // Save it in the same queue
end
","""Excerpt from a technical document discussing sharing parameterized classes in Verilog, including a snippet of Verilog code demonstrating a base class and a parameterized generator class.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p114.jpg,True,"```
$srose(expression [, clocking event]);
$sfell(expression [, clocking event]);
```

These are the Verilog code snippets that are visible in the image. They appear to be function prototypes or definitions for the `$srose` and `$sfell` sampled value functions within Verilog, a hardware description language used in the design and modeling of digital systems.","(expression [, clocking event]);
$sfell(expression [, clocking event]);
","""Overview of the sampled value functions $rose and $fell in Verilog, used to detect changes in the least significant bit of an expression relative to the previous clock edge.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p439.jpg,True,"```verilog
always @(a or b or opcode)
    $scientific_alu(a, b, opcode, result, exception, error);

initial
    $scientific_alu(a, b, opcode, result, exception, error);
```
These are the two code snippets shown in the image, demonstrating how to use the Verilog HDL to interface with a C model via Verilog PLI (Programming Language Interface).","
always @(a or b or opcode)
    $scientific_alu(a, b, opcode, result, exception, error);

initial
    $scientific_alu(a, b, opcode, result, exception, error);
","Caption: ""Integrating C models with Verilog HDL using PLI calltf and misctf routines for a combinational logic interface.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p185.jpg,True,"The image contains Verilog code from two separate examples:

Example 6-2: OVL X detection with customized message
```verilog
assert_never # (1,0,""X detected"")
invalid (clk, reset_n, `expr[3:0] === 1'bx);
```
The customized message in Example 6-2 is:
```
OVL_ERROR:ASSERT_NEVER:X detected::severity 1:time 150:top.my_mod.invalid
```

Example 6-3: SystemVerilog undriven signal detection
```verilog
always @ (posedge clk) begin
    if (reset_n)
        invalid: assert property (!($isunknown(expr)));
end
```","
assert_never # (1,0,""X detected"")
invalid (clk, reset_n, `expr[3:0] === 1'bx);

ROR:ASSERT_NEVER:X detected::severity 1:time 150:top.my_mod.invalid


always @ (posedge clk) begin
    if (reset_n)
        invalid: assert property (!($isunknown(expr)));
end
","""Verilog code demonstrating how to customize error messages for assertions and detect undriven signals using SystemVerilog's $isunknown system task.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p81.jpg,True,"```verilog
always @(posedge clock) begin // NOT a shift register
  q1 <= d;  // OK, load d into q1 with clock-to-Q delay
  q2 <= q1; // OK, load previous q1 into q2
end
```","
always @(posedge clock) begin // NOT a shift register
  q1 <= d;  // OK, load d into q1 with clock-to-Q delay
  q2 <= q1; // OK, load previous q1 into q2
end
",Verilog Coding Practice: Using Nonblocking Assignments in Sequential Blocks,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p191.jpg,True,"```verilog
assert_zero_one_hot #(0,3) mutex_wr_state (clk, reset_n,
    {FSM_1==WR_STATE, FSM_2==WR_STATE, FSM_3==WR_STATE});
```
","
assert_zero_one_hot #(0,3) mutex_wr_state (clk, reset_n,
    {FSM_1==WR_STATE, FSM_2==WR_STATE, FSM_3==WR_STATE});
","""Verilog code excerpt showcasing a SystemVerilog assertion for validating mutual exclusivity of one-hot signals.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p95.jpg,True,"The image contains Verilog code. Here are the code snippets from the image:

```verilog
always @* begin
  if (sel == 2'b00) y = a;
  else if (sel == 2'b01) y = b;
  else if (sel == 2'b01) y = c; // GOTCHA! same sel value
  else if (sel == 2'b11) y = d;
end
```

```verilog
always @* begin
  case (sel)
    2'b00: y = a;
    2'b01: y = b;
    2'b01: y = c; // GOTCHA! same sel value as previous line
    2'b11: y = d;
  endcase
end
```

These snippets are examples of coding errors in Verilog related to overlapping decision statements that can lead to only the first branch being executed if multiple conditions are met due to the mistake in coding.","
always @* begin
  if (sel == 2'b00) y = a;
  else if (sel == 2'b01) y = b;
  else if (sel == 2'b01) y = c; // GOTCHA! same sel value
  else if (sel == 2'b11) y = d;
end


always @* begin
  case (sel)
    2'b00: y = a;
    2'b01: y = b;
    2'b01: y = c; // GOTCHA! same sel value as previous line
    2'b11: y = d;
  endcase
end
","""Common Verilog Gotchas: Overlapping Decision Statements in Conditional Branching""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p436.jpg,True,"The image contains Verilog code. Here is the transcription:

```verilog
Sample 11.17 shows the methods for the UNI cell.

Sample 11.17  UNI_cell methods

function UNI_cell::new();
    if (syndrome_not_generated)
        generate_syndrome();
endfunction : new

// Compute the HEC value after all other data has been chosen
function void UNI_cell::post_randomize();
    HEC = hec({GFC, VPI, VCI, CLP, PT});
endfunction : post_randomize

// Compare this cell with another
// This could be improved by telling what field mismatched
function bit UNI_cell::compare(input BaseTr to);
    UNI_cell c;
    $cast(c, to);
    if (this.GFC != c.GFC)     return 0;
    if (this.VPI != c.VPI)     return 0;
    if (this.VCI != c.VCI)     return 0;
    if (this.CLP != c.CLP)     return 0;
    if (this.PT != c.PT)       return 0;
    if (this.HEC != c.HEC)     return 0;
    if (this.Payload != c.Payload) return 0;
    return 1;
endfunction : compare

// Print a ""pretty"" version of this object
function void UNI_cell::display(input string prefix);
    ATMCellType p;
    $display(""%sUNI id:%0d GFC=%x, VPI=%x, VCI=%x, CLP=%b, PT=%x, HEC=%x, Payload[0]=%x"",
             prefix, id, GFC, VPI, VCI, CLP, PT, HEC, Payload[0]);
    this.pack(p);
    $write(""%s"", prefix);
    foreach (p.Mem[i]) $write(""@x "", p.Mem[i]);
    $display;
endfunction : display

// Make a copy of this object
function BaseTr UNI_cell::copy(input BaseTr to);
    if (to == null) copy = new();
    else
        $cast(copy, to);
endfunction
```","
Sample 11.17 shows the methods for the UNI cell.

Sample 11.17  UNI_cell methods

function UNI_cell::new();
    if (syndrome_not_generated)
        generate_syndrome();
endfunction : new

// Compute the HEC value after all other data has been chosen
function void UNI_cell::post_randomize();
    HEC = hec({GFC, VPI, VCI, CLP, PT});
endfunction : post_randomize

// Compare this cell with another
// This could be improved by telling what field mismatched
function bit UNI_cell::compare(input BaseTr to);
    UNI_cell c;
    $cast(c, to);
    if (this.GFC != c.GFC)     return 0;
    if (this.VPI != c.VPI)     return 0;
    if (this.VCI != c.VCI)     return 0;
    if (this.CLP != c.CLP)     return 0;
    if (this.PT != c.PT)       return 0;
    if (this.HEC != c.HEC)     return 0;
    if (this.Payload != c.Payload) return 0;
    return 1;
endfunction : compare

// Print a ""pretty"" version of this object
function void UNI_cell::display(input string prefix);
    ATMCellType p;
    $display(""%sUNI id:%0d GFC=%x, VPI=%x, VCI=%x, CLP=%b, PT=%x, HEC=%x, Payload[0]=%x"",
             prefix, id, GFC, VPI, VCI, CLP, PT, HEC, Payload[0]);
    this.pack(p);
    $write(""%s"", prefix);
    foreach (p.Mem[i]) $write(""@x "", p.Mem[i]);
    $display;
endfunction : display

// Make a copy of this object
function BaseTr UNI_cell::copy(input BaseTr to);
    if (to == null) copy = new();
    else
        $cast(copy, to);
endfunction
","""Verilog methods for a UNI cell, including object copying, comparison, and display functionalities.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p100.jpg,True,"The image contains Verilog code snippets that explain the concepts of formal and actual arguments in the context of sequences and properties. Here is the code from the image:

Code snippet 1:
```verilog
logic req, gnt;

sequence sr1(a, b);
    a ##2 b;
endsequence

property pr1(logic pa, logic pb);
    @(posedge clk) start |-> sr1(pa, pb);
endproperty

reqGnt: assert property ( pr1(req,gnt) ) $display($stime,,""\t\t%m PASS""); else $display($stime,,""\t\t%m FAIL"");
```

Code snippet 2:
```verilog
property noChangeSig(pclk, refSig, StableSig);
    @(posedge pclk) !refSig |-> $stable(StableSig);
endproperty

CheckRd: assert property (noChangeSig(clk,OE, _RdData)) $display($stime,""...PASS"");
CheckWr: assert property (noChangeSig(sysCLK, WE, _WrData)) $display($stime,""...PASS"");
```

Code snippet 3:
```verilog
logic req, gnt;

property pr1(enb='b1, logic pa, logic pb);
    @(posedge clk) enb |-> pa ##2 pb;
endproperty

reqGnt: assert property ( pr1(cStart, req, gnt) );
```

Code snippet 4:
```verilog
reqGnt: assert property ( pr1 ( .enb(cStart), .pa(req), .pb(gnt)) );
```

These snippets are demonstrating the use of formal and actual arguments in Verilog assertions and properties. Some concepts illustrated include passing arguments during instantiation, setting default values for formals, and the differences between position-based and name-based connections.","
logic req, gnt;

sequence sr1(a, b);
    a ##2 b;
endsequence

property pr1(logic pa, logic pb);
    @(posedge clk) start |-> sr1(pa, pb);
endproperty

reqGnt: assert property ( pr1(req,gnt) ) $display($stime,,""\t\t%m PASS""); else $display($stime,,""\t\t%m FAIL"");


property noChangeSig(pclk, refSig, StableSig);
    @(posedge pclk) !refSig |-> $stable(StableSig);
endproperty

CheckRd: assert property (noChangeSig(clk,OE, _RdData)) $display($stime,""...PASS"");
CheckWr: assert property (noChangeSig(sysCLK, WE, _WrData)) $display($stime,""...PASS"");


logic req, gnt;

property pr1(enb='b1, logic pa, logic pb);
    @(posedge clk) enb |-> pa ##2 pb;
endproperty

reqGnt: assert property ( pr1(cStart, req, gnt) );


reqGnt: assert property ( pr1 ( .enb(cStart), .pa(req), .pb(gnt)) );
","""Explanation of formal and actual arguments in Verilog code with examples of default values and connections""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p350.jpg,True,"The image contains a snippet of Verilog code in a text sample. Here is the code as it appears in the image:

```verilog
virtual class TestBase;
  Environment env;
  pure virtual task run_test();
  function new();
    env = new();
  endfunction
endclass
```","
virtual class TestBase;
  Environment env;
  pure virtual task run_test();
  function new();
    env = new();
  endfunction
endclass
","Caption: ""Excerpt from a text discussing the concept of creating a test registry in Verilog, highlighting the benefits of using static methods for efficient test execution.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p378.jpg,True,"The image contains a snippet of Verilog code as part of an example on functional coverage. Here is the code from the image:

```verilog
covergroup CovDst14;
  option.auto_bin_max = 2; // Affects dst & data
  coverpoint tr.dst;       // autobin[0:3], autobin[4:7]
  coverpoint tr.data;      // autobin[0:7], autobin[8:15]
endgroup

class Packet;
  rand bit [2:0] hdr_len;     // range: 0:7
  rand bit [3:0] payload_len; // range: 0:15
  rand bit [3:0] kind;
endclass

Packet p;

covergroup CovLen15;
  len16: coverpoint (p.hdr_len + p.payload_len);
  len32: coverpoint (p.hdr_len + p.payload_len + 5'b0);
endgroup
```

This code is demonstrating the use of `covergroup` in Verilog for functional coverage analysis, where `auto_bin_max` option is set, and coverpoints are defined for tracking the coverage of certain signals or expressions. Additionally, a `class` is defined representing a packet with randomizable fields for length and type. A second `covergroup` is then shown where expressions are used as coverpoints.","
covergroup CovDst14;
  option.auto_bin_max = 2; // Affects dst & data
  coverpoint tr.dst;       // autobin[0:3], autobin[4:7]
  coverpoint tr.data;      // autobin[0:7], autobin[8:15]
endgroup

class Packet;
  rand bit [2:0] hdr_len;     // range: 0:7
  rand bit [3:0] payload_len; // range: 0:15
  rand bit [3:0] kind;
endclass

Packet p;

covergroup CovLen15;
  len16: coverpoint (p.hdr_len + p.payload_len);
  len32: coverpoint (p.hdr_len + p.payload_len + 5'b0);
endgroup
","Caption: ""Verilog functional coverage example using covergroups and coverpoints with auto_bin_max option.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p374.jpg,True,"The image contains Verilog code embedded in the text. Here are the code excerpts:

```verilog
sequence s1;
  logic l_a, l_b[4];
  dataType l_data;
  @(posedge clk)
  ...
endsequence
```

```verilog
property p_illegal_loc_var_decl;
  logic l_a, [3:0] l_b; // packed dimension not in data type
  l_c;                  // no explicit data type
  bit l_d [];           // dynamic array type not allowed
  ...
endproperty
```

These excerpts are from a document discussing the declaration of body local variables in the context of SystemVerilog.","
sequence s1;
  logic l_a, l_b[4];
  dataType l_data;
  @(posedge clk)
  ...
endsequence


property p_illegal_loc_var_decl;
  logic l_a, [3:0] l_b; // packed dimension not in data type
  l_c;                  // no explicit data type
  bit l_d [];           // dynamic array type not allowed
  ...
endproperty
","This image shows an excerpt from a technical document discussing the mechanics of local variables in SystemVerilog, with an emphasis on declaring body local variables in sequences and properties, and includes an example of valid and illegal local variable declarations.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p406.jpg,True,"The image contains Verilog code for two different properties. Here are the code snippets present in the image:

```verilog
property ranged_always(int unsigned low, high, property p);
    ranged_always_recur(low, high, 0, p);
endproperty

property ranged_always_recur(
    local input int unsigned low, high, cnt,
    property p
);
    if (cnt <= high)
    (
        (if (cnt >= low) p)
        and
        nexttime ranged_always_recur(low, high, cnt+1, p)
    );
endproperty
```

This code defines a recursive property `ranged_always` which ensures that the property `p` holds within a specified range from `low` to `high`.

```verilog
property my_until(property p, q);
    (nexttime[0] q)
    or
    ((nexttime[0] p) and nexttime my_until(p, q));
endproperty
```

The second snippet of code defines a property `my_until` which implements a recursive version of the until operator typically used in hardware property specification.","
property ranged_always(int unsigned low, high, property p);
    ranged_always_recur(low, high, 0, p);
endproperty

property ranged_always_recur(
    local input int unsigned low, high, cnt,
    property p
);
    if (cnt <= high)
    (
        (if (cnt >= low) p)
        and
        nexttime ranged_always_recur(low, high, cnt+1, p)
    );
endproperty


property my_until(property p, q);
    (nexttime[0] q)
    or
    ((nexttime[0] p) and nexttime my_until(p, q));
endproperty
","""Examples of recursive properties in Verilog for temporal verification, depicting ranged always and custom until constructs.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p377.jpg,True,"The image contains a snippet of a document discussing Verilog, but it does not contain code in the sense of an executable code block. There are references to code-related structures and keywords. Here is the type definition that appears in the image:

```c
typedef struct t_strengthval
{
    int strength0;
    int strength1;
} s_strengthval, *p_strengthval;
```

Furthermore, the image contains a table that lists Verilog HDL strength levels and keywords:

```
Strength Level        Strength Name      Specification Keyword
7                     Supply Drive       supply0      supply1
6                     Strong Drive       strong0      strong1
5                     Pull Drive         pull0        pull1
4                     Large Capacitance  large
3                     Weak Drive         weak0        weak1
2                     Medium Capacitance medium
1                     Small Capacitance  small
0                     High Impedance     highz0       highz1
```

These strength levels and keywords are used in Verilog for specifying different signal strengths.","ef struct t_strengthval
{
    int strength0;
    int strength1;
} s_strengthval, *p_strengthval;

th Level        Strength Name      Specification Keyword
7                     Supply Drive       supply0      supply1
6                     Strong Drive       strong0      strong1
5                     Pull Drive         pull0        pull1
4                     Large Capacitance  large
3                     Weak Drive         weak0        weak1
2                     Medium Capacitance medium
1                     Small Capacitance  small
0                     High Impedance     highz0       highz1
","""Verilog HDL: Understanding TF Routines and Signal Strength Levels""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p162.jpg,True,"```verilog
initial begin
    fork
        begin: add_test
            for (int i = 0; i < 10; i++) begin // i is local variable
                ...
            end
        end

        begin: dif_test
            for (int i = 8; i > 2; i--) begin // i is local variable
                ...
            end
        end
    join
```
The image contains an excerpt from a text about Verilog and SystemVerilog pitfalls, including an example of how to avoid a common issue by using local variables in for loops within concurrent code blocks established by the `fork` ... `join` construct.","
initial begin
    fork
        begin: add_test
            for (int i = 0; i < 10; i++) begin // i is local variable
                ...
            end
        end

        begin: dif_test
            for (int i = 8; i > 2; i--) begin // i is local variable
                ...
            end
        end
    join
","""Verilog Gotchas: Using local variables to avoid control variable conflicts in parallel loops.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p42.jpg,True,"The image contains Verilog code. Here is the code present in the image:

```verilog
module top;
   ...
   test          t1 (.*);  // connect testbench to design
   math_static   m1 (.*);
   math_auto     m2 (.*);
endmodule

program automatic test;
   ...
   initial begin
      ... // apply stimulus
      $display (""math_static s1 = %h"", top.m1.math.s1  // OK
      $display (""math_auto   s1 = %h"", top.m2.math.s1  // GOTCHA!
   end
endprogram
```

Please note that the second `$display` line in the `initial begin` block is commented with the word ""GOTCHA!"", which suggests an issue with that code, as discussed in the accompanying text.","
module top;
   ...
   test          t1 (.*);  // connect testbench to design
   math_static   m1 (.*);
   math_auto     m2 (.*);
endmodule

program automatic test;
   ...
   initial begin
      ... // apply stimulus
      $display (""math_static s1 = %h"", top.m1.math.s1  // OK
      $display (""math_auto   s1 = %h"", top.m2.math.s1  // GOTCHA!
   end
endprogram
","""Exploring Verilog Testbench Hierarchical Reference Limitations and Gotchas""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p56.jpg,True,"The image contains text discussing Verilog programming concepts and provides examples of how to fill vectors with all ones using both Verilog and SystemVerilog. Here is the code provided in the image:

Verilog example:
```verilog
parameter WIDTH = 64;
reg [WIDTH-1:0] data;

data = 'b0; // fills with 64'h0000000000000000
data = 'bz; // fills with 64'hzzzzzzzzzzzzzzzz
data = 'bx; // fills with 64'hxxxxxxxxxxxxxxxx
data = 'b1; // fills with 64'h0000000000000001 GOTCHA!
```

SystemVerilog example:
```systemverilog
parameter WIDTH = 64;
logic [WIDTH-1:0] data;

data = '1; // fills with 64'hffffffffffffffff
data = '0; // fills with 64'h0000000000000000
data = 'z; // fills with 64'hzzzzzzzzzzzzzzzz
data = 'x; // fills with 64'hxxxxxxxxxxxxxxxx
```
The image discusses a ""gotcha"" where using the syntax for filling a vector with ones in Verilog does not work as expected and offers the proper approach in SystemVerilog as well as workarounds in Verilog.","
parameter WIDTH = 64;
reg [WIDTH-1:0] data;

data = 'b0; // fills with 64'h0000000000000000
data = 'bz; // fills with 64'hzzzzzzzzzzzzzzzz
data = 'bx; // fills with 64'hxxxxxxxxxxxxxxxx
data = 'b1; // fills with 64'h0000000000000001 GOTCHA!

erilog
parameter WIDTH = 64;
logic [WIDTH-1:0] data;

data = '1; // fills with 64'hffffffffffffffff
data = '0; // fills with 64'h0000000000000000
data = 'z; // fills with 64'hzzzzzzzzzzzzzzzz
data = 'x; // fills with 64'hxxxxxxxxxxxxxxxx
","Caption: ""Verilog Gotchas: Filling a vector with all ones requires specific syntax in Verilog versus SystemVerilog, as explained in this guide on declaration and literal number pitfalls.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p388.jpg,True,"```c
int word_increment;
word_increment = node_info.node_ngroups * 2;

char *aval_ptr, *bval_ptr;
aval_ptr = node_info.node_value.memoryval_p
           + (word_increment * memory_address);
bval_ptr = aval_ptr + node_info.node_ngroups;

reg [23:0] RAM [0:31]; //lsb is lowest bit, ascending addresses

s_tfnodeinfo node_info;
tf_nodeinfo(1, &node_info);

mem_ptr = node_info.node_value.memoryval_p
ngroups = node_info.node_ngroups
word_increment = ngroups * 2
aval_ptr = mem_ptr + (word_increment * 1)
bval_ptr = aval_ptr + ngroups
```","ord_increment;
word_increment = node_info.node_ngroups * 2;

char *aval_ptr, *bval_ptr;
aval_ptr = node_info.node_value.memoryval_p
           + (word_increment * memory_address);
bval_ptr = aval_ptr + node_info.node_ngroups;

reg [23:0] RAM [0:31]; //lsb is lowest bit, ascending addresses

s_tfnodeinfo node_info;
tf_nodeinfo(1, &node_info);

mem_ptr = node_info.node_value.memoryval_p
ngroups = node_info.node_ngroups
word_increment = ngroups * 2
aval_ptr = mem_ptr + (word_increment * 1)
bval_ptr = aval_ptr + ngroups
","Caption: ""Extract from The Verilog PLI Handbook demonstrating how to access Verilog array words in a C character array and providing an example of working with a 24-bit wide RAM memory in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p176.jpg,True,"```verilog
program test (input logic clock,
               input logic [1:0] ack,
               output logic [1:0] irq);

    initial begin: irs_test
        $display(""Forking off two interrupt requests..."");
        fork
            watchdog (0, 20); // must receive ack[0] within 20 cycles
            watchdog (1, 50); // must receive ack[1] within 50 cycles
        begin
            irq[0] = 1'b1;
            irq[1] = 1'b1;
            wait (ack)
            $display(""Received ack at %0d, disabling watchdog"", $time);
            disable watchdog; // got ack; kill both watchdog tasks
        end
        join_any
        $display(""\At %0d, test completed or timed out"", $time);
        $finish; // abort simulation
    end: irs_test
endprogram
```","
program test (input logic clock,
               input logic [1:0] ack,
               output logic [1:0] irq);

    initial begin: irs_test
        $display(""Forking off two interrupt requests..."");
        fork
            watchdog (0, 20); // must receive ack[0] within 20 cycles
            watchdog (1, 50); // must receive ack[1] within 50 cycles
        begin
            irq[0] = 1'b1;
            irq[1] = 1'b1;
            wait (ack)
            $display(""Received ack at %0d, disabling watchdog"", $time);
            disable watchdog; // got ack; kill both watchdog tasks
        end
        join_any
        $display(""\At %0d, test completed or timed out"", $time);
        $finish; // abort simulation
    end: irs_test
endprogram
","Caption: ""Understanding re-entrancy issues with static tasks and functions in Verilog programming, with an example of a Verilog test program showcasing the use of tasks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p393.jpg,True,"The image contains Verilog code about using pass-by-reference with a cover group. Here is the code from the image:

```verilog
bit [2:0] dst_a, dst_b;

covergroup CovDst40 (ref bit [2:0] dst, input int mid);
  coverpoint dst {
    bins lo = {[0:mid-1]};
    bins hi = {[mid:$]};
  }
endgroup

CovDst40 cpa, cpb;
initial
begin
  cpa = new(dst_a, 4); // dst_a, lo=0:3, hi=4:7
  cpb = new(dst_b, 2); // dst_b, lo=0:1, hi=2:7
end
```

This block of code is an example of how to pass arguments by reference to a cover group in SystemVerilog, allowing the cover group to sample values during the entire simulation.","
bit [2:0] dst_a, dst_b;

covergroup CovDst40 (ref bit [2:0] dst, input int mid);
  coverpoint dst {
    bins lo = {[0:mid-1]};
    bins hi = {[mid:$]};
  }
endgroup

CovDst40 cpa, cpb;
initial
begin
  cpa = new(dst_a, 4); // dst_a, lo=0:3, hi=4:7
  cpb = new(dst_b, 2); // dst_b, lo=0:1, hi=2:7
end
","""Example of passing cover group arguments by reference in Verilog for functional coverage""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p248.jpg,True,"```verilog
module DeviceM
#(parameter BusWidth=8, Delay=1) // No resemblance to a delay time.
(output [BusWidth-1:0] OutBus,
 input [BusWidth-1:1] InA, InB, input Clk, Rst);
...
```

```verilog
DeviceM #(.BusWidth(16), .Delay(5)) // Default overrides, not delays.
 DevM_01 (.OutBus(Dbus), .InA(ArgA), .InB(ArgB)
 , .Clk(ClockIn), .Rst(Reset)
 );
```

```verilog
DeviceM #(16, 5) // Default overrides may resemble delays.
 DevM_01 (.OutBus(Dbus), .InA(ArgA), .InB(ArgB)
 , .Clk(ClockIn), .Rst(Reset)
 );
```

```verilog
xnor #(16, 5) Adder_U12 ( z, A, B, C );
```","
module DeviceM
#(parameter BusWidth=8, Delay=1) // No resemblance to a delay time.
(output [BusWidth-1:0] OutBus,
 input [BusWidth-1:1] InA, InB, input Clk, Rst);
...


DeviceM #(.BusWidth(16), .Delay(5)) // Default overrides, not delays.
 DevM_01 (.OutBus(Dbus), .InA(ArgA), .InB(ArgB)
 , .Clk(ClockIn), .Rst(Reset)
 );


DeviceM #(16, 5) // Default overrides may resemble delays.
 DevM_01 (.OutBus(Dbus), .InA(ArgA), .InB(ArgB)
 , .Clk(ClockIn), .Rst(Reset)
 );


xnor #(16, 5) Adder_U12 ( z, A, B, C );
","Caption: ""Explanations and examples of parameter declaration and instantiation syntax in Verilog code, highlighting potential confusion between parameter overrides and delay assignments.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p265.jpg,True,"```verilog
(##[1:8] ($rose (irdyn && trdyn && devselyn)));

endproperty

a_mchk5: assert property(p_mchk5);
c_mchk5: cover property(p_mchk5);

sequence s_mchk6;
@(posedge clk)
$fell (framen) ##1 (devseln)[*5] ##0 framen;
endsequence

property p_mchk6;
@(posedge clk)
s_mchk6.ended |-> ##1 $rose (irdyn);
endproperty

a_mchk6: assert property(p_mchk6);
c_mchk6: cover property(p_mchk6);
```","
(##[1:8] ($rose (irdyn && trdyn && devselyn)));

endproperty

a_mchk5: assert property(p_mchk5);
c_mchk5: cover property(p_mchk5);

sequence s_mchk6;
@(posedge clk)
$fell (framen) ##1 (devseln)[*5] ##0 framen;
endsequence

property p_mchk6;
@(posedge clk)
s_mchk6.ended |-> ##1 $rose (irdyn);
endproperty

a_mchk6: assert property(p_mchk6);
c_mchk6: cover property(p_mchk6);
","Excerpt from a textbook or documentation showing examples of SystemVerilog Assertions (SVA) for protocol interface verification, including properties and sequences.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p387.jpg,True,"The image contains Verilog code snippets. Here they are:

1.
```verilog
assert property (illegal_op)
else $error(""Illegal operation occurred on bus B."");
```

2.
```verilog
assume property (legal_bus_cmds);
```

3.
```verilog
cover property (req_t1_start)
begin
    $display(""Starting Request t1."");
end
```

4.
```verilog
sequence track_it;
    (req[->1], $display(""Found the request at cycle %0d\n"", `cycle))
    ##1 (sent[->1], $display(""Sent occurred at cycle %0d\n"", `cycle))
    ##3 end;
endsequence

assert property (start |=> track_it);
```

The code examples provided are related to the SystemVerilog assertions (SVA) for verifying digital designs.","
assert property (illegal_op)
else $error(""Illegal operation occurred on bus B."");


assume property (legal_bus_cmds);


cover property (req_t1_start)
begin
    $display(""Starting Request t1."");
end


sequence track_it;
    (req[->1], $display(""Found the request at cycle %0d\n"", `cycle))
    ##1 (sent[->1], $display(""Sent occurred at cycle %0d\n"", `cycle))
    ##3 end;
endsequence

assert property (start |=> track_it);
","Caption: ""SystemVerilog sequence and property example with dynamic data, error handling, and usage of $display system task.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p316.jpg,True,"The image contains excerpts from a document which discuss legal and illegal uses of certain Verilog constructs, focusing on global clocking sampled value functions. Here are the code snippets found in the image:

```verilog
always @(posedge_clk) a <= {$future_gclk(b)} && c;
// ILLEGAL - cannot use in procedural assignment

a1_illegal: assert final (a -> {$future_gclk(b)});
// ILLEGAL - can’t use in immediate assertion

a2_illegal: assert property (@(posedge clk) disable iff (rst || $rising_gclk(interrupt)) req |=> gnt);
// ILLEGAL - can’t use in disable iff

a3_illegal: assert property (@(posedge clk) req |=> {$future_gclk(ack && $rising_gclk(gnt))});
// ILLEGAL - can’t have nested sampled value functions
```

These examples highlight certain Verilog syntax, primarily related to assertions and sampled value functions, indicating how they should not be used.","
always @(posedge_clk) a <= {$future_gclk(b)} && c;
// ILLEGAL - cannot use in procedural assignment

a1_illegal: assert final (a -> {$future_gclk(b)});
// ILLEGAL - can’t use in immediate assertion

a2_illegal: assert property (@(posedge clk) disable iff (rst || $rising_gclk(interrupt)) req |=> gnt);
// ILLEGAL - can’t use in disable iff

a3_illegal: assert property (@(posedge clk) req |=> {$future_gclk(ack && $rising_gclk(gnt))});
// ILLEGAL - can’t have nested sampled value functions
","Caption: ""Examples of illegal uses of global clocking future sampled value functions in Verilog, highlighting situations where their use is not permitted in procedural assignments and assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p470.jpg,True,"```verilog
module testOverride;
parent p1;
child c1;

initial begin
p1 = new ( ) ;
c1 = new ( ) ;

for (int i=0; i < 10; i++) begin
p1.randomize ( ) ;
c1.randomize ( ) ;

p1.pCov.sample ( ) ;
c1.pCov.sample ( ) ;
#1;
end

$display(""p1.pCov Instance Coverage = %0.2f %%"", p1.pCov.get_inst_coverage ( ) ) ;
$display(""c1.pCov Instance Coverage = %0.2f %%"", c1.pCov.get_inst_coverage ( ) ) ;

end
```
This is the Verilog code present in the image, which appears to be part of a textbook segment discussing functional coverage features in Verilog.","
module testOverride;
parent p1;
child c1;

initial begin
p1 = new ( ) ;
c1 = new ( ) ;

for (int i=0; i < 10; i++) begin
p1.randomize ( ) ;
c1.randomize ( ) ;

p1.pCov.sample ( ) ;
c1.pCov.sample ( ) ;
#1;
end

$display(""p1.pCov Instance Coverage = %0.2f %%"", p1.pCov.get_inst_coverage ( ) ) ;
$display(""c1.pCov Instance Coverage = %0.2f %%"", c1.pCov.get_inst_coverage ( ) ) ;

end
","""Verilog code example demonstrating functional coverage with testbench and overridden coverage bins.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p149.jpg,True,"The image contains a fragment of code related to Verilog and the Verilog Procedural Interface (VPI). Here is the code excerpt from the image:

```verilog
vpiHandle module_handle;
s_vpi_time current_time;

/* get handle for the module (or any object in the module */

current_time.type = vpiScaledRealTime;
vpi_get_time(module_handle, &current_time);

vpi_printf(""Current time is %f\n"", current_time.real);
```","
vpiHandle module_handle;
s_vpi_time current_time;

/* get handle for the module (or any object in the module */

current_time.type = vpiScaledRealTime;
vpi_get_time(module_handle, &current_time);

vpi_printf(""Current time is %f\n"", current_time.real);
","""Verilog VPI routine for retrieving simulation time and using 64-bit time representation in a C struct.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p152.jpg,True,"The image contains several pieces of Verilog code. Here are the two code samples:

Sample 4.27:
```verilog
clocking cb @(posedge clk);
    output #10ns request;
    input  #15ns grant;
endclocking
```

Sample 4.28:
```verilog
program automatic test;
    int errors, warnings;

    initial begin
        ... // Main program activity
    end

    final
        $display(""Test completed with %0d errors and %0d warnings"", errors, warnings);
endprogram
```

These code samples illustrate the use of clocking blocks with delays and a final block for clean-up after a simulation in Verilog, respectively.","
clocking cb @(posedge clk);
    output #10ns request;
    input  #15ns grant;
endclocking


program automatic test;
    int errors, warnings;

    initial begin
        ... // Main program activity
    end

    final
        $display(""Test completed with %0d errors and %0d warnings"", errors, warnings);
endprogram
","This image depicts a page from a book detailing certain aspects of Verilog and SystemVerilog, including code samples that demonstrate how to handle clocking blocks with signal delays and program termination considerations.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p464.jpg,True,"The image contains a segment of Verilog code which defines a covergroup with formal and actual arguments and outlines how to instantiate the covergroup with actual arguments. Here is the code excerpt:

```verilog
bit[7:0] adr1, adr2;

covergroup cg (int low, int high, ref bit [7:0] address)
    @(posedge clk);
    ac: coverpoint address {
        bins addrbin[] = {[low:high]};
    }
endgroup

gc gcadr1 = new (0,127,adr1);
gc gcadr2 = new (128,255,adr2);
```

Note: This code snippet demonstrates how to use parameterized covergroups in Verilog to allow for code reusability.","
bit[7:0] adr1, adr2;

covergroup cg (int low, int high, ref bit [7:0] address)
    @(posedge clk);
    ac: coverpoint address {
        bins addrbin[] = {[low:high]};
    }
endgroup

gc gcadr1 = new (0,127,adr1);
gc gcadr2 = new (128,255,adr2);
","Caption: ""Understanding the use of formal and actual arguments in Verilog covergroups for functional coverage parametrization.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p271.jpg,True,"```verilog
property p_mchk10;
@(posedge clk)
(lirdyn && ltrdyn) ##1
(par ^ $past(^ad[31:0]^cben[3:0])) == 1) |-> ##[1:5] !perrn;
endproperty

a_mchk10: assert property(p_mchk10);
c_mchk10: cover property(p_mchk10);
```","
property p_mchk10;
@(posedge clk)
(lirdyn && ltrdyn) ##1
(par ^ $past(^ad[31:0]^cben[3:0])) == 1) |-> ##[1:5] !perrn;
endproperty

a_mchk10: assert property(p_mchk10);
c_mchk10: cover property(p_mchk10);
","Caption: ""Excerpt from a technical document discussing SystemVerilog Assertions (SVA) for protocol interface with a sample property for detecting parity error in data phase using Verilog code.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p393.jpg,True,"The image contains text describing the syntax for property and sequence declarations in Verilog. Here is the text related to code:

```
property_declaration ::=
   property property_identifier [ property_formal_list ] ‘;’
   { assertion_variable_declaration }
   property_spec ‘;’
endproperty [ ‘:’ property_identifier ]

property_formal_list ::=
   ‘(‘ [ formal_list_item { ‘,’ formal_list_item } ] ‘)’
formal_list_item ::= formal_identifier [ ‘=’ actual_arg_expr]
actual_arg_expr ::= expression | identifier | event_control

property_decl_item ::= sequence_declaration
   | list_of_variable_identifiers_or_assignments

sequence_declaration ::=
   sequence sequence_identifier [sequence_formal_list] ‘;’
   {assertion_variable_declaration }
   sequence_expr’;’
endsequence [‘:’ sequence_identifier ]

sequence_formal_list ::=
   ‘(‘ [ formal_list_item { ‘,’ formal_list_item } ] ‘)’
assertion_variable_declaration ::=
   data_type list_of_variable_identifiers.
```

This provides a formalized structure on how properties and sequences are to be declared in Verilog for assertion-based design.","ty_declaration ::=
   property property_identifier [ property_formal_list ] ‘;’
   { assertion_variable_declaration }
   property_spec ‘;’
endproperty [ ‘:’ property_identifier ]

property_formal_list ::=
   ‘(‘ [ formal_list_item { ‘,’ formal_list_item } ] ‘)’
formal_list_item ::= formal_identifier [ ‘=’ actual_arg_expr]
actual_arg_expr ::= expression | identifier | event_control

property_decl_item ::= sequence_declaration
   | list_of_variable_identifiers_or_assignments

sequence_declaration ::=
   sequence sequence_identifier [sequence_formal_list] ‘;’
   {assertion_variable_declaration }
   sequence_expr’;’
endsequence [‘:’ sequence_identifier ]

sequence_formal_list ::=
   ‘(‘ [ formal_list_item { ‘,’ formal_list_item } ] ‘)’
assertion_variable_declaration ::=
   data_type list_of_variable_identifiers.
","Caption: ""Excerpt from a technical document illustrating the syntax for property and sequence declarations in Verilog for assertion-based design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p607.jpg,True,"The image contains a section of a document rather than actual code. However, there are some code-like elements mentioned. The text describes representations and types in the context of Verilog simulations, particularly related to synchronization using the Value Change Link (VCL).

Here is the text that appears to be code-related from the image:

```plaintext
unsigned int vc_hightime, vc_lowtime;

vc_hightime                     vc_lowtime
msb = most significant bit      msb = most significant bit
lsb = least significant bit     lsb = least significant bit
```

The text talks about mapping Verilog simulation time to a pair of C `int` variables (`vc_hightime` for the most significant bits and `vc_lowtime` for the least significant bits).

There is also a table that presents different types of `out_value` fields with their new value representations:

```plaintext
vc_reason                 out_value Field With New Value    The New Logic Value Representation

logic_value_change        logic_value                      one of the constants: vc0 vc1 vcX vcZ
strength_value_change     strengths_s                      a structure with the logic and strength
vector_value_change       vector_handle                    a handle for a vector net or part-select of a vector net
sregister_value_change    logic_value                      one of the constants: vc0 vc1 vcX vcZ
vregister_value_change    vector_handle                    a handle for a vector reg or part-select of a vector reg
integer_value_change      vector_handle                    a handle for an integer variable
real_value_change         real_value                       the value of a real variable
time_value_change         vector_handle                    a handle for a time variable
event_value_change        none                             (event types have no logic value)
```

The table titled ""Table 17-2: s_vc_record out_value member fields"" outlines several types of value changes and how they are represented in a simulation context.

Remember that these are descriptions of data structures and constants, not executable code.","xt
unsigned int vc_hightime, vc_lowtime;

vc_hightime                     vc_lowtime
msb = most significant bit      msb = most significant bit
lsb = least significant bit     lsb = least significant bit

xt
vc_reason                 out_value Field With New Value    The New Logic Value Representation

logic_value_change        logic_value                      one of the constants: vc0 vc1 vcX vcZ
strength_value_change     strengths_s                      a structure with the logic and strength
vector_value_change       vector_handle                    a handle for a vector net or part-select of a vector net
sregister_value_change    logic_value                      one of the constants: vc0 vc1 vcX vcZ
vregister_value_change    vector_handle                    a handle for a vector reg or part-select of a vector reg
integer_value_change      vector_handle                    a handle for an integer variable
real_value_change         real_value                       the value of a real variable
time_value_change         vector_handle                    a handle for a time variable
event_value_change        none                             (event types have no logic value)
","""Explanation of Verilog simulation time representation and details on the value change link (VCL) structure in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p64.jpg,True,"The image contains a Verilog PLI (Programming Language Interface) code example. Here is the code written in the image:

```c
#include <math.h>
int PLIbook_PowCalltf(char *user_data)
{
    s_vpi_value value_s;
    vpiHandle systf_handle, arg_itr, arg_handle;
    int base, exp, result;

    systf_handle = vpi_handle(vpiSysTfCall, NULL);
    arg_itr = vpi_iterate(vpiArgument, systf_handle);
    if (arg_itr == NULL) {
        vpi_printf(""ERROR: $pow failed to obtain sysft arg handles\n"");
        return(0);
    }

    /* read base from sysft arg 1 (compiletf has already verified) */
    arg_handle = vpi_scan(arg_itr);
    value_s.format = vpiIntVal;
    vpi_get_value(arg_handle, &value_s);
    base = value_s.value.integer;

    /* read exponent from sysft arg 2 (compiletf has already verified) */
    arg_handle = vpi_scan(arg_itr);
    vpi_free_object(arg_itr); /* not calling scan until returns null */
    vpi_get_value(arg_handle, &value_s);
    exp = value_s.value.integer;

    /* calculate result of base to power of exponent */
    result = (int)pow((double)base, (double)exp);

    /* write result to simulation as return value $pow */
    value_s.value.integer = result;
    vpi_put_value(sysft_handle, &value_s, NULL, vpiNoDelay);
    return(0);
}

/**********************************************************************/

int PLIbook_PowsStartOfSim()
{
    vpi_printf(""\n$pow PLI application is being used.\n\n"");
    return(0);
}
```

This code snippet is designed to be used with the Verilog PLI, which allows custom C functions to be called from within a Verilog simulation. The function `PLIbook_PowCalltf` appears to take the base and exponent as inputs from Verilog, compute the power using the `pow` function from `math.h`, and return the result back to the Verilog simulation. The `PLIbook_PowsStartOfSim` function simply prints a message indicating that the `$pow` PLI application is being used.","ude <math.h>
int PLIbook_PowCalltf(char *user_data)
{
    s_vpi_value value_s;
    vpiHandle systf_handle, arg_itr, arg_handle;
    int base, exp, result;

    systf_handle = vpi_handle(vpiSysTfCall, NULL);
    arg_itr = vpi_iterate(vpiArgument, systf_handle);
    if (arg_itr == NULL) {
        vpi_printf(""ERROR: $pow failed to obtain sysft arg handles\n"");
        return(0);
    }

    /* read base from sysft arg 1 (compiletf has already verified) */
    arg_handle = vpi_scan(arg_itr);
    value_s.format = vpiIntVal;
    vpi_get_value(arg_handle, &value_s);
    base = value_s.value.integer;

    /* read exponent from sysft arg 2 (compiletf has already verified) */
    arg_handle = vpi_scan(arg_itr);
    vpi_free_object(arg_itr); /* not calling scan until returns null */
    vpi_get_value(arg_handle, &value_s);
    exp = value_s.value.integer;

    /* calculate result of base to power of exponent */
    result = (int)pow((double)base, (double)exp);

    /* write result to simulation as return value $pow */
    value_s.value.integer = result;
    vpi_put_value(sysft_handle, &value_s, NULL, vpiNoDelay);
    return(0);
}

/**********************************************************************/

int PLIbook_PowsStartOfSim()
{
    vpi_printf(""\n$pow PLI application is being used.\n\n"");
    return(0);
}
","""Excerpt from 'The Verilog PLI Handbook' showing implementation of a power function using the Verilog Procedural Interface (VPI)""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p458.jpg,True,"The image contains text about Verilog functional coverage and explains how ""bins"" are declared and used within a coverage point. The only piece of code is an example of a bins declaration in Verilog syntax, which is provided below:

```verilog
bins adrb[4] = { [1:10], 11,12,14 };
```

This line of code declares a coverage model with a bins construct named ""adrb"" that can store up to four bins. The bins are supposed to cover the ranges and values between 1 and 14, excluding the number 13.","
bins adrb[4] = { [1:10], 11,12,14 };
","""Understanding Verilog Functional Coverage: Explanation of Bins Creation for Coverage Collection in a Verification Environment""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p175.jpg,True,"The image shows a page from a book detailing how to read the 4-state logic value and strength value of scalar nets in Verilog using VPI routines. The page includes a section of code which is part of an example illustrating the concept. Here is the code from the image:

```c
int PLIbook_ReadStrengthVal_calltf(char *user_data)
{
    vpiHandle systf_h, arg_itr, arg_h, net_h;
    s_vpi_value net_val;                        /* structure to receive net value */

    /* obtain a handle to the system task instance */
    systf_h = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handle to system task argument
       compiletf has already verified only 1 arg with correct type */
    arg_itr = vpi_iterate(vpiArgument, systf_h);
    net_h = vpi_scan(arg_itr);
    vpi_free_object(arg_itr);    /* free iterator memory */
    
    net_val.format = vpiStrengthVal;           /* set value format field */
    
    vpi_get_value(net_h, &net_val);            /* read net's strength value */

    vpi_printf(""\nNet %s: "", vpi_get_str(vpiName, net_h));
    vpi_printf(""value=%c strength0=%2x(hex) strength1=%2x(hex)\n\n"",
        PLIbook_Decode8BitValue(net_val.value.strength->logic),
        net_val.value.strength->s0,
        net_val.value.strength->s1);
        
    return(0);
}
```

This code is meant to be used inside a Verilog PLI/VPI application, and it shows how to read the value and strength of a Verilog net from within C code by using the VPI layer. The `PLIbook_Decode8BitValue` function called within `vpi_printf` is not defined in this excerpt.","LIbook_ReadStrengthVal_calltf(char *user_data)
{
    vpiHandle systf_h, arg_itr, arg_h, net_h;
    s_vpi_value net_val;                        /* structure to receive net value */

    /* obtain a handle to the system task instance */
    systf_h = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handle to system task argument
       compiletf has already verified only 1 arg with correct type */
    arg_itr = vpi_iterate(vpiArgument, systf_h);
    net_h = vpi_scan(arg_itr);
    vpi_free_object(arg_itr);    /* free iterator memory */
    
    net_val.format = vpiStrengthVal;           /* set value format field */
    
    vpi_get_value(net_h, &net_val);            /* read net's strength value */

    vpi_printf(""\nNet %s: "", vpi_get_str(vpiName, net_h));
    vpi_printf(""value=%c strength0=%2x(hex) strength1=%2x(hex)\n\n"",
        PLIbook_Decode8BitValue(net_val.value.strength->logic),
        net_val.value.strength->s0,
        net_val.value.strength->s1);
        
    return(0);
}
","""Example of Verilog code using VPI routines to read signal strength values""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p162.jpg,True,"The image contains several snippets of Verilog code. Here they are transcribed:

Example 7.16 code snippet:
```verilog
always @(posedge clk)
    if (en) q <= d;
```

Solution to Example 7.16:
```verilog
a_ff: assert property (@(posedge clk)
    nexttime q == $past(d, , en));
```

Example 7.17 code snippet:
```verilog
logic check;
logic [31:0] a, b, c;

assertion
a1: assert property (@(posedge clk) ##1 check |->
    $past(c) == $past(a) + $past(b));
```

Better rewrite for Example 7.17:
```verilog
a2: assert property (@(posedge clk) ##1 check |->
    $past(c == a + b));
```

Example 7.18 code snippet:
```verilog
logic a, b;
always @(posedge clk)
    a <= $past(b);
```","
always @(posedge clk)
    if (en) q <= d;


a_ff: assert property (@(posedge clk)
    nexttime q == $past(d, , en));


logic check;
logic [31:0] a, b, c;

assertion
a1: assert property (@(posedge clk) ##1 check |->
    $past(c) == $past(a) + $past(b));


a2: assert property (@(posedge clk) ##1 check |->
    $past(c == a + b));


logic a, b;
always @(posedge clk)
    a <= $past(b);
","Caption: ""Verilog code examples discussing the use of sampled value functions and tips for efficient assertions in hardware verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p613.jpg,True,"The image contains a diagram with snippets of code in Verilog and C. Below are the code snippets:

Verilog Shell Module (Step 1):
```c
void
C_model(...)
{
    
}
```

PLI Interface to C Model (Step 3):
```c
int
C_mod_calltf()
{
    
}
```

C Model (Step 2):
```verilog
module
C_model(...)
endmodule
```

Please note that these code snippets are incomplete and serve as placeholders within the context of the diagram to represent the interfacing steps between C models and Verilog using ACC routines, as explained in the text.","C_model(...)
{
    
}

_mod_calltf()
{
    
}


module
C_model(...)
endmodule
","""Interfacing Verilog with C Models using ACC Routines and PLI Application - Overview and Code Blocks Diagram""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p344.jpg,True,"The image contains text which specifies the syntax for Sequential Extended Regular Expression (SERE) consecutive repetition in the context of assertion-based design, possibly for hardware description languages Verilog and VHDL. The text presents the syntax but not actual code examples. Here is the text:

```
Syntax B-5 SERE consecutive repetition

SERE ::= 
    SERE [ * [ Count ] ]
    | [* [ Count ]]
    | SERE [ + ]
    | [+]

Count ::=
    Number | Range

Range ::=
    LowBound RANGE_SYM HighBound

LowBound ::=
    Number | MIN_VAL

HighBound ::=
    Number | MAX_VAL
```

The text below this syntax describes how the SERE consecutive repetition operates and what certain unspecified values default to, as well as the significance of the notation `[+]`."," B-5 SERE consecutive repetition

SERE ::= 
    SERE [ * [ Count ] ]
    | [* [ Count ]]
    | SERE [ + ]
    | [+]

Count ::=
    Number | Range

Range ::=
    LowBound RANGE_SYM HighBound

LowBound ::=
    Number | MIN_VAL

HighBound ::=
    Number | MAX_VAL
","""Excerpt from a technical document explaining the syntax for Sequence of Events for Regular Expressions (SERE) consecutive repetition in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p189.jpg,True,"```verilog
let onehot0(exp, bit reset = 1'b0) = reset || $onehot0(exp);
let noUnknown(exp, bit reset = 1'b0) = reset || $isunknown(exp);

module check(input
             logic rst,
             logic [15:0] decoded,
             logic [3:0] sel
            );
    a1: assert #0 (noUnknown({decoded, sel}));
    a2: assert #0 (onehot0(sel, rst));
endmodule : check
```","
let onehot0(exp, bit reset = 1'b0) = reset || $onehot0(exp);
let noUnknown(exp, bit reset = 1'b0) = reset || $isunknown(exp);

module check(input
             logic rst,
             logic [15:0] decoded,
             logic [3:0] sel
            );
    a1: assert #0 (noUnknown({decoded, sel}));
    a2: assert #0 (onehot0(sel, rst));
endmodule : check
","Caption: ""Example of Verilog code using 'let' declarations for creating abstract expressions and configuring templates, as used in checker libraries.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p185.jpg,True,"The image contains two snippets of Verilog code. The first code snippet is:

```verilog
class Transaction;
  static int count = 0; // Number of objects created
  int id;               // Unique instance ID
  function new();
    id = count++; // Set ID, bump count
  endfunction
endclass

Transaction t1, t2;
initial begin
  t1 = new(); // 1st instance, id=0, count=1
  $display(""First id=%0d, count=%0d"", t1.id, t1.count);
  t2 = new(); // 2nd instance, id=1, count=2
  $display(""Second id=%0d, count=%0d"", t2.id, t2.count);
end
```

The second code snippet is shown as a part of a diagram in Fig. 5.2 and represents a class definition:

```verilog
class Transaction;
  static int count = 0;
  int id;
endclass
```

These snippets demonstrate how to work with static variables in a class within SystemVerilog, which is used for hardware design and verification.","
class Transaction;
  static int count = 0; // Number of objects created
  int id;               // Unique instance ID
  function new();
    id = count++; // Set ID, bump count
  endfunction
endclass

Transaction t1, t2;
initial begin
  t1 = new(); // 1st instance, id=0, count=1
  $display(""First id=%0d, count=%0d"", t1.id, t1.count);
  t2 = new(); // 2nd instance, id=1, count=2
  $display(""Second id=%0d, count=%0d"", t2.id, t2.count);
end


class Transaction;
  static int count = 0;
  int id;
endclass
","""Example of using a static variable in a Verilog class to track object instances and their unique IDs.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p191.jpg,True,"The image contains two samples of code written in Verilog, which is often used in the design and development of digital systems. Here's the code from the image:

```verilog
// Sample 5.22 Statistics class declaration
class Statistics;
    time startT;                          // Transaction start time
    static int ntrans = 0;                // Transaction count
    static time total_elapsed_time = 0;

    function void start();
        startT = $time;
    endfunction

    function void stop();
        time how_long = $time - startT;
        ntrans++;                         // Another trans completed
        total_elapsed_time += how_long;
    endfunction
endclass

// Sample 5.23 Encapsulating the Statistics class
class Transaction;
    bit [31:0] addr, csm, data[8];
    Statistics stats;                     // Statistics handle

    function new();
        stats = new();                    // Make instance of Statistics
    endfunction

    task transmit_me();
        // Fill packet with data
        stats.start();
        // Transmit packet
        #100;
        stats.stop();
    endtask
endclass
```

These two code samples demonstrate object-oriented programming (OOP) concepts in Verilog, such as class declaration, instantiation, and handling. Sample 5.22 declares a `Statistics` class with methods for starting and stopping a timer, and Sample 5.23 shows the encapsulation of the `Statistics` class within a `Transaction` class, which uses the `Statistics` class to time how long it takes to transmit a packet.","
// Sample 5.22 Statistics class declaration
class Statistics;
    time startT;                          // Transaction start time
    static int ntrans = 0;                // Transaction count
    static time total_elapsed_time = 0;

    function void start();
        startT = $time;
    endfunction

    function void stop();
        time how_long = $time - startT;
        ntrans++;                         // Another trans completed
        total_elapsed_time += how_long;
    endfunction
endclass

// Sample 5.23 Encapsulating the Statistics class
class Transaction;
    bit [31:0] addr, csm, data[8];
    Statistics stats;                     // Statistics handle

    function new();
        stats = new();                    // Make instance of Statistics
    endfunction

    task transmit_me();
        // Fill packet with data
        stats.start();
        // Transmit packet
        #100;
        stats.stop();
    endtask
endclass
",Verilog Object-Oriented Programming: Illustrating the use of a Statistics class within a Transaction class.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p378.jpg,True,"The image contains an excerpt about SystemVerilog assertions, specifically focusing on the ""Boolean until (throughout)"" operator. There is a snippet of code related to this operator.

Here is the code provided in the example:

```verilog
sequence_expr ::= expression_or_dist throughout sequence_expr

(b throughout s) ::= ( b [*0:$] intersect s )
```

Additionally, several examples for usage of the operator are listed:

- `0 throughout (1)` same as `0`
- `1 throughout ##1 a` same as `##1 a`
- `a throughout ##2 b` same as `(a ##1 a & b)`
- `a throughout b (##[1:3] c)` same as `(a&b ##1 a##1 a &c)` or `(a&b ##1 a##1 a##1 a &c)` or `(a&b ##1 a##1 a##1 a##1 a &c)`","
sequence_expr ::= expression_or_dist throughout sequence_expr

(b throughout s) ::= ( b [*0:$] intersect s )
","""Excerpt from a technical document describing the 'throughout' sequence operator in SystemVerilog with examples and syntax definition.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p217.jpg,True,"The image contains two segments of Verilog code. The first segment is:

```verilog
always @(a_r or b_c) begin
    if (a_r==1'b1)
        d_c <= d_c + b_c;
    else
        d_c <= d_c - b_c;
end
```

The second segment is:

```verilog
always @(posedge clk or reset_)
    pad_ff <= reset_ ? pad_o : 32'h0;
```

These are examples provided in the context of discussing Simulation and Problematic RTL Verilog as well as Formal Verification and Problematic Verilog.","
always @(a_r or b_c) begin
    if (a_r==1'b1)
        d_c <= d_c + b_c;
    else
        d_c <= d_c - b_c;
end


always @(posedge clk or reset_)
    pad_ff <= reset_ ? pad_o : 32'h0;
","""Discussion about simulation pitfalls and formal verification in Verilog code""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p311.jpg,True,"The image contains Verilog code snippets. Here is the code from the image:

```verilog
a4_oli_hi: assert property(p4_oli_hi);
a4_oli_ih: assert property(p4_oli_ih);
a4_oli_il: assert property(p4_oli_il);
a4_oli_li: assert property(p4_oli_li);
```

Below is another section of Verilog code from the image:

```verilog
// sample test code for logical relationship
// between level sensitive signals

logic [1:0] logical_op_reg;
logical_op_reg = 2'b00;

for(i=0; i<4; i++)
```

Unfortunately, part of the `for` loop is cut off at the edge of the image, and the rest of the code is not visible. It seems to be an example related to testing logical relationships between level-sensitive signals in Verilog.","
a4_oli_hi: assert property(p4_oli_hi);
a4_oli_ih: assert property(p4_oli_ih);
a4_oli_il: assert property(p4_oli_il);
a4_oli_li: assert property(p4_oli_li);


// sample test code for logical relationship
// between level sensitive signals

logic [1:0] logical_op_reg;
logical_op_reg = 2'b00;

for(i=0; i<4; i++)
","""Waveform and Verilog code snippet demonstrating assertions for logical relations between two level-sensitive signals.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p262.jpg,True,"The image contains a fragment of a book or document that discusses the topic of embedding concurrent assertions in procedural code, specifically in the Verilog Hardware Description Language (HDL). The text describes the difference between immediate assertions and concurrent assertions within procedural blocks. Below is the code displayed in the image:

```verilog
property prg(req, gnt);
  req ##1 gnt;
endproperty

CP: cover property (@(posedge clk) (bState == CycleStart) |-> prg(req, gnt))
  $display($stime,,""PASS"");

`ifdef P
  AP: assert property (@(posedge clk) (bState == CycleStart) |-> prg(req, gnt))
    else $display($stime,,""FAIL"");
`else

always @(posedge clk)
begin
  if (bState == CycleStart)
    AP: assert property (prg(req, gnt)) else $display ($stime,,""FAIL"");
end

`endif
```

This code snippet includes a SystemVerilog property named `prg`, assertions using this property marked with labels `CP` and `AP`, conditional compilation with `ifdef`, and an `always` block with a sensitivity list triggered by the positive edge of a clock signal. The code is accompanied by annotations that emphasize the functionality and flexibility provided by embedding assertions within procedural blocks.","
property prg(req, gnt);
  req ##1 gnt;
endproperty

CP: cover property (@(posedge clk) (bState == CycleStart) |-> prg(req, gnt))
  $display($stime,,""PASS"");

`ifdef P
  AP: assert property (@(posedge clk) (bState == CycleStart) |-> prg(req, gnt))
    else $display($stime,,""FAIL"");
`else

always @(posedge clk)
begin
  if (bState == CycleStart)
    AP: assert property (prg(req, gnt)) else $display ($stime,,""FAIL"");
end

`endif
","""Explaining the concept of embedding concurrent assertions within procedural blocks in Verilog code.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p504.jpg,True,"The image contains a Verilog code snippet. Here it is:

```verilog
covergroup coverSample with function sample (int X);
    coverpoint X;
endgroup : coverSample

coverSample cs = new ( );

property propertySample;
    int pX; //local variable

    //iSig1, iSig2, iSig3 are some internal signals of your design
    @(posedge clk) (iSig1, pX = iSig2) |=> (iSig3, cs.sample(pX));

endproperty : propertySample
```

This code snippet is a part of an explanation about using a user-defined sample method in a coverage group in Verilog.","
covergroup coverSample with function sample (int X);
    coverpoint X;
endgroup : coverSample

coverSample cs = new ( );

property propertySample;
    int pX; //local variable

    //iSig1, iSig2, iSig3 are some internal signals of your design
    @(posedge clk) (iSig1, pX = iSig2) |=> (iSig3, cs.sample(pX));

endproperty : propertySample
","""Excerpt from a text on Verilog discussing the implementation of a custom sample method in a coverage group for performance implications in coverage methodology.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p339.jpg,True,"Here is the Verilog code present in the image:

```verilog
logic [1:0] logical_op_reg;

initial
begin
    clk = 1'b0; a=1'b0; b=1'b0;
    logical_op_reg = 2'b00;

    //*************************************
    // case 1
    // logical operation, overlapping implication
    // level sensitive signals
    //*************************************

    if((logic_op == 1 || o_l_implication == 1) &&
       timing == 0 && sig_edge == 0)
    begin
        for(i=0; i<4; i++)
        begin
            a <= logical_op_reg[0];
            b <= logical_op_reg[1];
            repeat(1) @(posedge clk);
            logical_op_reg++;
        end
    end

    //*************************************
    // case 2
    // logical operation, overlapping implication
    // edge sensitive signals
    //*************************************

    if((logic_op == 1 || o_e_implication == 1) &&
       timing == 0 && sig_edge == 1)
    begin
        if(sig1_edge == 0) // ff, fr
        begin
            for(i=0; i<8; i++)
            begin
                a <= logical_op_reg[0];
                b <= logical_op_reg[1];
                repeat(1) @(posedge clk);
                logical_op_reg++;
            end
        end
```

Please note that the code presented in the picture might be part of a larger codebase and does not represent a complete Verilog program. Additionally, there may be variables or modules referenced in this snippet that are defined elsewhere in the code that is not shown in the image.","
logic [1:0] logical_op_reg;

initial
begin
    clk = 1'b0; a=1'b0; b=1'b0;
    logical_op_reg = 2'b00;

    //*************************************
    // case 1
    // logical operation, overlapping implication
    // level sensitive signals
    //*************************************

    if((logic_op == 1 || o_l_implication == 1) &&
       timing == 0 && sig_edge == 0)
    begin
        for(i=0; i<4; i++)
        begin
            a <= logical_op_reg[0];
            b <= logical_op_reg[1];
            repeat(1) @(posedge clk);
            logical_op_reg++;
        end
    end

    //*************************************
    // case 2
    // logical operation, overlapping implication
    // edge sensitive signals
    //*************************************

    if((logic_op == 1 || o_e_implication == 1) &&
       timing == 0 && sig_edge == 1)
    begin
        if(sig1_edge == 0) // ff, fr
        begin
            for(i=0; i<8; i++)
            begin
                a <= logical_op_reg[0];
                b <= logical_op_reg[1];
                repeat(1) @(posedge clk);
                logical_op_reg++;
            end
        end
","Caption: ""Verilog code showcasing logical operations and signal edge sensitivity in a register-based design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p214.jpg,True,"The image contains Verilog code. Here is the code extracted from the image:

```verilog
package foo;
  typedef int unsigned uint_t;
  function int func_a (int a);
    return ~a;
  endfunction
endpackage

package baz;
  import foo::*; // wildcard import package foo
  function int func_b (uint_t b);
    return ~func_a(b);
  endfunction
endpackage

module test;
  import bar::*; // wildcard import bar
  uint_t c; // GOTCHA! reference definition
            // that is in package foo
  ...
endmodule
```

This Verilog example demonstrates an issue with package chaining where a module imports a package that has imported another package. The example explains that this might not work on some simulators due to ambiguities in the SystemVerilog-2005 standard regarding package chaining.","
package foo;
  typedef int unsigned uint_t;
  function int func_a (int a);
    return ~a;
  endfunction
endpackage

package baz;
  import foo::*; // wildcard import package foo
  function int func_b (uint_t b);
    return ~func_a(b);
  endfunction
endpackage

module test;
  import bar::*; // wildcard import bar
  uint_t c; // GOTCHA! reference definition
            // that is in package foo
  ...
endmodule
","""Exploring the concept of package chaining in Verilog and potential simulation inconsistencies.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p200.jpg,True,"The image shows some SystemVerilog code related to coverage groups. Here is the code presented in the image:

```verilog
program automatic test;
event cg_sample;

covergroup cg_xyz @(cg_sample); // covergroup definition
    coverpoint x;
    coverpoint y;
    coverpoint z;
endgroup

class Abc;
rand bit [7:0] a, b, c;
covergroup cg_abc @(cg_sample); // covergroup definition
    coverpoint a;
    coverpoint b;
    coverpoint c;
endgroup
endclass

initial begin
    Abc a1 = new;                    // instance of Abc object
    ... // generate stimulus
    $get_coverage();                  // GOTCHA! reports 0 coverage
end
endprogram
```

The text below the code explains why 0% coverage is reported. It suggests that while covergroups are defined, the covergroup object must be constructed using the covergroup's `new` method before coverage information is collected. This step was not shown in the provided example, leading to 0% coverage reports.","
program automatic test;
event cg_sample;

covergroup cg_xyz @(cg_sample); // covergroup definition
    coverpoint x;
    coverpoint y;
    coverpoint z;
endgroup

class Abc;
rand bit [7:0] a, b, c;
covergroup cg_abc @(cg_sample); // covergroup definition
    coverpoint a;
    coverpoint b;
    coverpoint c;
endgroup
endclass

initial begin
    Abc a1 = new;                    // instance of Abc object
    ... // generate stimulus
    $get_coverage();                  // GOTCHA! reports 0 coverage
end
endprogram
","""Common pitfall in Verilog coverage reporting due to misuse of covergroups, resulting in 0% coverage.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p224.jpg,True,"The image contains several pieces of Verilog code. Here's the text for each code snippet shown in the image:

Example 6-48 SystemVerilog Only certain enable patterns; allowed during write request
```verilog
// conditional pattern

assert property (@(posedge clk) disable iff ( rst_n )
    (SMQeWrEn -> 
        SMQeWrEn[3:0] inside {4'b0000, 4'b0011, 4'b1100, 4'b1111}))
    else $error (""%mSMQeWrEn has illegal write enable pattern %b."", 
    SMQeWrEn);
```

Example 6-49 SystemVerilog Unknown signals not allowed during a valid EngMemRd or EngMemWr request
```verilog
// X detection pattern

assert property (@(posedge clk) disable iff ( rst_n )
    (EngMemWr |-> !$isunknown(EngMemAddr, EngMemData, EngMemWrEn)))
    else $error (""%mSram interface contains unknown values."");
```

Example 6-50 SystemVerilog EngMemRd and EngMemWr are mutually exclusive
```verilog
// valid signal combination pattern

assert property (@(posedge clk) disable iff ( rst_n )
    not (EngMemRd & EngMemWr)) else
    $error(""%mSram interface asserts illegally read and write together."");
```

Example 6-51 SystemVerilog For a valid write, the EngMemWrEn may only have one of seven legal values
```verilog
// valid combination of signals pattern

assert property (@(posedge clk) disable iff ( rst_n )
    (EngMemWr |-> EngMemWrEn inside {0,1,2,3,4,8,12})) else
    $error(""%mSram interface asserts illegal write en %0b"", EngMemWrEn);
```","
// conditional pattern

assert property (@(posedge clk) disable iff ( rst_n )
    (SMQeWrEn -> 
        SMQeWrEn[3:0] inside {4'b0000, 4'b0011, 4'b1100, 4'b1111}))
    else $error (""%mSMQeWrEn has illegal write enable pattern %b."", 
    SMQeWrEn);


// X detection pattern

assert property (@(posedge clk) disable iff ( rst_n )
    (EngMemWr |-> !$isunknown(EngMemAddr, EngMemData, EngMemWrEn)))
    else $error (""%mSram interface contains unknown values."");


// valid signal combination pattern

assert property (@(posedge clk) disable iff ( rst_n )
    not (EngMemRd & EngMemWr)) else
    $error(""%mSram interface asserts illegally read and write together."");


// valid combination of signals pattern

assert property (@(posedge clk) disable iff ( rst_n )
    (EngMemWr |-> EngMemWrEn inside {0,1,2,3,4,8,12})) else
    $error(""%mSram interface asserts illegal write en %0b"", EngMemWrEn);
",Page from a document showing SystemVerilog examples for assertions related to SRAM interface.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p289.jpg,True,"```verilog
$assertcontrol (VACUOUSOFF, CONCURRENT | EXPECT);

$assertvacuousoff
```

The text in the image describes the use of certain system tasks in Verilog to control assertion behavior, specifically for handling vacuous passes. There's also a brief snippet on a concept called ""Empty Sequence"" in the context of Verilog assertions, shown by a diagram and not in code format.","
$assertcontrol (VACUOUSOFF, CONCURRENT | EXPECT);

$assertvacuousoff
","""Explanation of the 'empty sequence' in Verilog HDL using an example with assert control system task and waveform timing diagram.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p218.jpg,True,"```verilog
// declarative assertion
// assert any request 'n' completes (receives its done) within 100 cycles.

assert
  forall n in {0:7} :
    always (req && tag==n -> next [ {*1:99}; done && done_tag==n])
    @ (posedge clk) ;
    
// Note this assertion does not ensure that there is only 1 done
// corresponding to the original request.
```","
// declarative assertion
// assert any request 'n' completes (receives its done) within 100 cycles.

assert
  forall n in {0:7} :
    always (req && tag==n -> next [ {*1:99}; done && done_tag==n])
    @ (posedge clk) ;
    
// Note this assertion does not ensure that there is only 1 done
// corresponding to the original request.
","Caption: ""Figure and example of a PSL assertion for validating a multiple tagged request/acknowledge protocol in Verilog.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p107.jpg,True,"The image contains two snippets of Verilog code. Below are the transcriptions of both:

**First snippet:**
```verilog
module inline(clk, a, b, d1, d2, d);

input logic clk, a, b;
input logic [7:0] d1, d2;
output logic [7:0] d;

always@(posedge clk)
begin
    if(a)
        d <= d1;
    if(b)
        d <= d2;
end

property p_mutex;
    @(posedge clk) not (a && b);
endproperty

a_mutex: assert property(p_mutex);

endmodule
```

**Second snippet:**
```verilog
module mutex_chk(a, b, clk);
```

The text describes how to connect SystemVerilog Assertions (SVA) to the design either by embedding the checkers in the module definition or by binding them externally. It then gives an example of an `inline` module, including the logic and the assertion `p_mutex` to verify mutually exclusive conditions of signals `a` and `b`. The second snippet references creating a separate checker module but does not provide the full code, only the module declaration line is shown for `mutex_chk`.","
module inline(clk, a, b, d1, d2, d);

input logic clk, a, b;
input logic [7:0] d1, d2;
output logic [7:0] d;

always@(posedge clk)
begin
    if(a)
        d <= d1;
    if(b)
        d <= d2;
end

property p_mutex;
    @(posedge clk) not (a && b);
endproperty

a_mutex: assert property(p_mutex);

endmodule


module mutex_chk(a, b, clk);
","The image shows a textbook page discussing how to connect SystemVerilog Assertions (SVA) to a design module, with examples of inline SVA code and the concept of modularizing SVA checkers.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p224.jpg,True,"```verilog
class BusOp;
  rand bit [31:0] addr;
  rand bit io_space_mode;
  constraint c_io {
    io_space_mode -> addr[31] == 1'b1;
  }
}
```","
class BusOp;
  rand bit [31:0] addr;
  rand bit io_space_mode;
  constraint c_io {
    io_space_mode -> addr[31] == 1'b1;
  }
}
","""Exploring SystemVerilog Implication Constraints and Their Syntax""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p228.jpg,True,"The image contains Verilog code, which is written as follows:

```verilog
checker request_granted(
    req, gnt, n = 1,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable
);
    default clocking @clk; endclocking
    default disable iff rst;
    bit intrans = 1'b0;

    always_ff @clk begin
        if (rst || gnt) intrans <= 1'b0;
        else if (req) intrans <= 1'b1;
    end

    a1: assert property (req |-> nexttime[n] gnt);

    final begin
        a2: assert (!rst -> gnt || !req || intrans)
        else $error(""Outstanding request at the end of simulation"");
    end
endchecker : request_granted
```","
checker request_granted(
    req, gnt, n = 1,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable
);
    default clocking @clk; endclocking
    default disable iff rst;
    bit intrans = 1'b0;

    always_ff @clk begin
        if (rst || gnt) intrans <= 1'b0;
        else if (req) intrans <= 1'b1;
    end

    a1: assert property (req |-> nexttime[n] gnt);

    final begin
        a2: assert (!rst -> gnt || !req || intrans)
        else $error(""Outstanding request at the end of simulation"");
    end
endchecker : request_granted
","Caption: ""Verilog code example for a request-granted checker with property assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p200.jpg,True,"```verilog
property match(x, y);
    x |=> !x until_with y;
endproperty : match

a_no_start: assert property (match(start, complete));
a_no_complete: assert property (match(complete, start));
a_initial_no_complete:
    assert property ({$fell(reset) |-> !complete until_with start});
```

This is the Verilog code excerpt present in the image. It defines a property called `match` and contains assertions related to a sequential protocol.","
property match(x, y);
    x |=> !x until_with y;
endproperty : match

a_no_start: assert property (match(start, complete));
a_no_complete: assert property (match(complete, start));
a_initial_no_complete:
    assert property ({$fell(reset) |-> !complete until_with start});
","Caption: Description and Verilog code for the control part of a sequential protocol, detailing the properties to ensure non-overlapping transactions and the correct sequence of events.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p566.jpg,True,"The image contains Verilog code excerpts. Here is the code from the image:

```verilog
else $error(""a1 failed""); //check input
always_comb begin
  r2 = r1;
  a2: assert final (onehot0(.sig(r2)))
  else $error(""a2 failed""); //check output
end
endmodule
```

And further down the page:

```verilog
typedef enum {ASSERT, ASSUME, NONE} assert_type;
typedef bit [15:0] cover_type;

checker onehot0
  (sig,
   assert_type_usage_kind = ASSERT,
   cover_type_cover_level = 1,
   reset = $inferred_disable,
   string msg = """", synthesis = `$SYNTHESIS);
   
if (cover_level<16'b0 || cover_level>16'b1)
  // check valid coverage selection
  $error(""Coverage level is invalid %d"",
         cover_level,
```

The text is discussing different types of checkers in Verilog and how to define and use assertions and checkers within the language. The code shows examples of custom checker definitions and usage in Verilog RTL (Register Transfer Level) design.","
else $error(""a1 failed""); //check input
always_comb begin
  r2 = r1;
  a2: assert final (onehot0(.sig(r2)))
  else $error(""a2 failed""); //check output
end
endmodule


typedef enum {ASSERT, ASSUME, NONE} assert_type;
typedef bit [15:0] cover_type;

checker onehot0
  (sig,
   assert_type_usage_kind = ASSERT,
   cover_type_cover_level = 1,
   reset = $inferred_disable,
   string msg = """", synthesis = `$SYNTHESIS);
   
if (cover_level<16'b0 || cover_level>16'b1)
  // check valid coverage selection
  $error(""Coverage level is invalid %d"",
         cover_level,
","A textbook excerpt discussing and demonstrating typical Verilog checkers, including assertion-based verification methods and combinational checkers in Verilog code.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p571.jpg,True,"The image contains Verilog code examples related to a Verilog Programming Language Interface (PLI) handbook. Here is the code from the image:

```verilog
#include ""vpi_user.h""  /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""  /* IEEE 1364 PLI ACC routine library */
/****************************************************************
 *  Sizeof application
 ****************************************************************/
int PLIbook_Func72bit_sizeof()
{
    return(72);  /* $pow returns 32-bit values */
}

/****************************************************************
 *  Calltf application
 ****************************************************************/
int PLIbook_Func72bit_calltf()
{
    handle systf_handle;
    s_setval_value value;
    s_setval_delay delay;
    p_acc_vecval  val_array;
    int array_size, i;
    
    /* declare an array of aval/bval pairs for the vector size */
    #define VEC_SIZE 72  /* hard coded 72-bit vector for this example */
    array_size = (VEC_SIZE-1)/32+1;
    val_array = (p_acc_vecval)malloc(sizeof(s_acc_vecval) * array_size);
    
    /* set value of vector aval/bval pairs */
    for (i=0; i<array_size; i++) {
        val_array[i].aval = 0xAAAAAAAA;  /* aval bits encode logic 0 & 1 */
        val_array[i].bval = 0x00000000;  /* bval bits encode logic Z & X */
    }
    
    systf_handle = acc_handle_tfinst();
    value.format = accVectorVal;
    value.value.vector = val_array;
    delay.model = accNoDelay;
    
    acc_set_value(systf_handle, &value, &delay);  /* set sysfunc return */
    
    return(0);
}
```

This code includes two functions that interface with the Verilog PLI. The first function ""PLIbook_Func72bit_sizeof"" simply returns the value 72. The second function ""PLIbook_Func72bit_calltf"" sets up a calltf (call task/function) application. It initializes a vector of values intended to represent a 72-bit value and makes use of the PLI ACC (access) routines to work with this vector within a Verilog simulation environment.","
#include ""vpi_user.h""  /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""  /* IEEE 1364 PLI ACC routine library */
/****************************************************************
 *  Sizeof application
 ****************************************************************/
int PLIbook_Func72bit_sizeof()
{
    return(72);  /* $pow returns 32-bit values */
}

/****************************************************************
 *  Calltf application
 ****************************************************************/
int PLIbook_Func72bit_calltf()
{
    handle systf_handle;
    s_setval_value value;
    s_setval_delay delay;
    p_acc_vecval  val_array;
    int array_size, i;
    
    /* declare an array of aval/bval pairs for the vector size */
    #define VEC_SIZE 72  /* hard coded 72-bit vector for this example */
    array_size = (VEC_SIZE-1)/32+1;
    val_array = (p_acc_vecval)malloc(sizeof(s_acc_vecval) * array_size);
    
    /* set value of vector aval/bval pairs */
    for (i=0; i<array_size; i++) {
        val_array[i].aval = 0xAAAAAAAA;  /* aval bits encode logic 0 & 1 */
        val_array[i].bval = 0x00000000;  /* bval bits encode logic Z & X */
    }
    
    systf_handle = acc_handle_tfinst();
    value.format = accVectorVal;
    value.value.vector = val_array;
    delay.model = accNoDelay;
    
    acc_set_value(systf_handle, &value, &delay);  /* set sysfunc return */
    
    return(0);
}
","""Verilog PLI Handbook Example: Using System Functions to Return 4-State Vector Values""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p572.jpg,True,"The image contains code from a Verilog (or SystemVerilog) file related to an `assert_handshake` checker. Here is the code present in the image:

```verilog
`ifdef ASSERT_ON
bit first_req = 1'b0;

function logic setFirstReq();
  if (!reset_n) return 1'b0;
  if ((first_req ^ first_req) == 1'b0)
    return s_req.triggered;
  return 1'b0;
endfunction : setFirstReq

always @ (clk) first_req <= setFirstReq();

// Variable first_req is used in a property in the following code fragment:

property ASSERT_HANDSHAKE_ACK_MIN_CYCLE_P;
  req |-> not s_eventually [0:min_ack_cycle] ack;
endproperty

property
  ASSERT_HANDSHAKE_ACK_WITHOUT_REQ_FIRST_REQ_P;
  (##1 ack) implies
  (first_req or req.triggered);
endproperty

// other properties ...

// this remains as before
case (property_type)
```

The code provided is a partial example and is missing parts that are referred to by comments such as ""other properties"" and a `case` statement that does not have its body content.","
`ifdef ASSERT_ON
bit first_req = 1'b0;

function logic setFirstReq();
  if (!reset_n) return 1'b0;
  if ((first_req ^ first_req) == 1'b0)
    return s_req.triggered;
  return 1'b0;
endfunction : setFirstReq

always @ (clk) first_req <= setFirstReq();

// Variable first_req is used in a property in the following code fragment:

property ASSERT_HANDSHAKE_ACK_MIN_CYCLE_P;
  req |-> not s_eventually [0:min_ack_cycle] ack;
endproperty

property
  ASSERT_HANDSHAKE_ACK_WITHOUT_REQ_FIRST_REQ_P;
  (##1 ack) implies
  (first_req or req.triggered);
endproperty

// other properties ...

// this remains as before
case (property_type)
","""Excerpt from a textbook discussing Verilog checkers and showing an example of the body of assert_handshake checker code.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p565.jpg,True,"```verilog
typedef struct t_setval_delay
{
    s_acc_time time;
    int model;
} s_setval_delay, *p_setval_delay;
```
The image contains a portion of text from ""The Verilog PLI Handbook, Part Two"" with a code snippet that defines a structure in C typically used with the Verilog Programming Language Interface (PLI).","
typedef struct t_setval_delay
{
    s_acc_time time;
    int model;
} s_setval_delay, *p_setval_delay;
","Caption: Detailed explanation of the `acc_set_value` function inputs and the `s_setval_delay` structure in Verilog PLI, including propagation delay models.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p203.jpg,True,"```
always @(posedge clock)
  $read_test_vector(""A.dat"", data_bus);

always @(negedge clock)
  $read_test_vector(""B.dat"", data_bus);
```"," @(posedge clock)
  $read_test_vector(""A.dat"", data_bus);

always @(negedge clock)
  $read_test_vector(""B.dat"", data_bus);
","""Discussion on challenges with using C programming techniques in PLI applications for Verilog code synchronization with VPI callbacks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p214.jpg,True,"Here is the Verilog code present in the image:

```verilog
checker request_granted(req, gnt, n = 1,
                        event clk = $inferred_clock,
                        untyped rst = $inferred_disable);
  default clocking @clk; endclocking
  default disable iff rst;

  a1: assert property (req |-> nexttime[n] gnt);

  final begin
    a2: assert (!rst -> gnt || !req) else
      $warning(""Outstanding request at the end of simulation"");
  end
endchecker : request_granted
```","
checker request_granted(req, gnt, n = 1,
                        event clk = $inferred_clock,
                        untyped rst = $inferred_disable);
  default clocking @clk; endclocking
  default disable iff rst;

  a1: assert property (req |-> nexttime[n] gnt);

  final begin
    a2: assert (!rst -> gnt || !req) else
      $warning(""Outstanding request at the end of simulation"");
  end
endchecker : request_granted
","""Verilog code example demonstrating the use of `final` procedures within a checker to validate simulation end conditions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p218.jpg,True,"The image contains Verilog code as part of an explanation of weighted random distribution with the `dist` operator. Here's the code from the image:

```verilog
class Transaction;
  rand bit [1:0] src, dst;
  constraint c_dist {
    src dist {0:=40, [1:3]:=60};
    // src = 0, weight = 40/220
    // src = 1, weight = 60/220
    // src = 2, weight = 60/220
    // src = 3, weight = 60/220

    dst dist {0:/40, [1:3]:/60};
    // dst = 0, weight = 40/100
    // dst = 1, weight = 20/100
    // dst = 2, weight = 20/100
    // dst = 3, weight = 20/100
  }
endclass
```","
class Transaction;
  rand bit [1:0] src, dst;
  constraint c_dist {
    src dist {0:=40, [1:3]:=60};
    // src = 0, weight = 40/220
    // src = 1, weight = 60/220
    // src = 2, weight = 60/220
    // src = 3, weight = 60/220

    dst dist {0:/40, [1:3]:/60};
    // dst = 0, weight = 40/100
    // dst = 1, weight = 20/100
    // dst = 2, weight = 20/100
    // dst = 3, weight = 20/100
  }
endclass
","""Verilog example demonstrating the use of the dist operator for creating weighted random distributions in class constraints.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p300.jpg,True,"The image contains Verilog code. Here is the code that is visible:

```verilog
parameter ParHi = 31;
...
reg ParValidFlagr;
reg[ParHi:0] ParSR, ParBusReg;
//           rise, fall
assign  # ( 1, 0 ) ParValidFlagr = ParValidFlagr;
...
task Unload32; // Copies the parallel SR to the output bus.
  begin           // Also clears the SR for the next word.
    ParValidFlagr = 'b0; // Lower the parallel-valid flag.
    ParBusReg     = ParSR; // Transfer the data.
    #5 ParSR       = 'b0; // Clear the SR.
    ParValidFlagr = 'b1; // Raise the flag.
  end
endtask
```

There is also a function definition:

```verilog
function[ParHi:0] Shift1(input[ParHi:0] OldSR, input NewBit);
  begin
    OldSR = OldSR<<1;
    Shift1 = (OldSR[ParHi:1],NewBit);
  end
endfunction
```

This code snippet includes a parameter declaration, register declarations, an assign statement, a task called `Unload32`, and a function called `Shift1` within Verilog code, which is a hardware description language used for designing and modeling electronic systems.","
parameter ParHi = 31;
...
reg ParValidFlagr;
reg[ParHi:0] ParSR, ParBusReg;
//           rise, fall
assign  # ( 1, 0 ) ParValidFlagr = ParValidFlagr;
...
task Unload32; // Copies the parallel SR to the output bus.
  begin           // Also clears the SR for the next word.
    ParValidFlagr = 'b0; // Lower the parallel-valid flag.
    ParBusReg     = ParSR; // Transfer the data.
    #5 ParSR       = 'b0; // Clear the SR.
    ParValidFlagr = 'b1; // Raise the flag.
  end
endtask


function[ParHi:0] Shift1(input[ParHi:0] OldSR, input NewBit);
  begin
    OldSR = OldSR<<1;
    Shift1 = (OldSR[ParHi:1],NewBit);
  end
endfunction
","A textbook page explaining the process of converting a shift register to a parallel bus in Verilog, including Verilog code for a task and a function.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p161.jpg,True,"The image contains a snippet of Verilog code. Here is the code transcribed from the image:

```verilog
...
case (c_hot)
    8'b00000001,
    8'b00000010,
    8'b00000100,
    8'b00001000,
    8'b00010000,
    8'b00100000,
    8'b01000000,
    8'b10000000: c_hot_error = 1'b0;
    default: c_hot_error = 1'b1;
endcase
end //always (c_hot)

assert_one_hot_c_hot_check #(0, 8)
    (ck, reset_n, c_hot);
endmodule // one_hot
```

This code describes a case statement checking a one-hot encoded signal, `c_hot`, and an assertion to check that 'c_hot' maintains a one-hot condition. The code is meant to be used as part of a digital circuit design in hardware description language Verilog.","
...
case (c_hot)
    8'b00000001,
    8'b00000010,
    8'b00000100,
    8'b00001000,
    8'b00010000,
    8'b00100000,
    8'b01000000,
    8'b10000000: c_hot_error = 1'b0;
    default: c_hot_error = 1'b1;
endcase
end //always (c_hot)

assert_one_hot_c_hot_check #(0, 8)
    (ck, reset_n, c_hot);
endmodule // one_hot
",Verilog example demonstrating a one-hot encoding case statement and an assertion for error checking.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p175.jpg,True,"The image contains a snippet of text which includes a single line of code. Here it is:

```verilog
force st0.core.csr.csr_regs.rc_ng = {2'h1, 1'h0, 1'h1};
```

This line of Verilog code is using the `force` command to set the value of a hierarchical register `rc_ng` within `csr_regs` inside `csr` inside `core` in the module instance named `st0`. The value assigned is a concatenation of bit fields: 2 bits with a hexadecimal value of 1, 1 bit set to 0, and 1 bit set to 1.","
force st0.core.csr.csr_regs.rc_ng = {2'h1, 1'h0, 1'h1};
","""Excerpt on Hierarchical Name References and Scan Stitching in Verilog Design Practices""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p160.jpg,True,"The image contains Verilog code within a module definition. Here is the code:

```verilog
module one_hot(c_hot, c_code);
    input [7:0] c_hot;
    output [2:0] c_code;
    reg [2:0] c_code;
    reg [2:0] c_code0, c_code1, c_code2, c_code3;
    reg [2:0] c_code4, c_code5, c_code6;

    always @ (c_hot) begin
        c_code6 = (c_hot [6]) ? 3'b001 : 3'b000;
        c_code5 = (c_hot [5]) ? 3'b010 : 3'b000;
        c_code4 = (c_hot [4]) ? 3'b011 : 3'b000;
        c_code3 = (c_hot [3]) ? 3'b100 : 3'b000;
        c_code2 = (c_hot [2]) ? 3'b101 : 3'b000;
        c_code1 = (c_hot [1]) ? 3'b110 : 3'b000;
        c_code0 = (c_hot [0]) ? 3'b111 : 3'b000;
        c_code = c_code0 | c_code1 | c_code2 | c_code3 | 
                 c_code4 | c_code5 | c_code6;
    end // always (c_hot)
endmodule // one_hot
``` 

The code above is an example of a one-hot decoder written in Verilog.","
module one_hot(c_hot, c_code);
    input [7:0] c_hot;
    output [2:0] c_code;
    reg [2:0] c_code;
    reg [2:0] c_code0, c_code1, c_code2, c_code3;
    reg [2:0] c_code4, c_code5, c_code6;

    always @ (c_hot) begin
        c_code6 = (c_hot [6]) ? 3'b001 : 3'b000;
        c_code5 = (c_hot [5]) ? 3'b010 : 3'b000;
        c_code4 = (c_hot [4]) ? 3'b011 : 3'b000;
        c_code3 = (c_hot [3]) ? 3'b100 : 3'b000;
        c_code2 = (c_hot [2]) ? 3'b101 : 3'b000;
        c_code1 = (c_hot [1]) ? 3'b110 : 3'b000;
        c_code0 = (c_hot [0]) ? 3'b111 : 3'b000;
        c_code = c_code0 | c_code1 | c_code2 | c_code3 | 
                 c_code4 | c_code5 | c_code6;
    end // always (c_hot)
endmodule // one_hot
","""Example of Verilog code for a one-hot encoder module with error detection capabilities""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p473.jpg,True,"The image contains a list of file paths, not the actual content of code. The text directs to create a file with the following contents which are paths to other files:

```
./SerDesTst.v
./SerDes.v
./Serializer/Serializer.v
./Serializer/SerEncoder/SerEncoderNetlistSDF.v
./Serializer/SerialTx/SerialTx.v
./Deserializer/Deserializer.v
./Deserializer/DesDecoder/DesDecoderNetlistSDF.v
./Deserializer/SerialRx/SerialRx.v
./FIFO/FIFOTopNetlistSDF.v
./PLL/PLLTopNetlistSDF.v
//vcs_tchbn9oph9_v2001.v
```

The text also makes a reference to `sdf_annotate()` function which is used in the context of SDF (Standard Delay Format) annotation during simulation. The image shows part of a book or documentation about Digital VLSI Design with Verilog. There is no executable Verilog code in the provided image.","esTst.v
./SerDes.v
./Serializer/Serializer.v
./Serializer/SerEncoder/SerEncoderNetlistSDF.v
./Serializer/SerialTx/SerialTx.v
./Deserializer/Deserializer.v
./Deserializer/DesDecoder/DesDecoderNetlistSDF.v
./Deserializer/SerialRx/SerialRx.v
./FIFO/FIFOTopNetlistSDF.v
./PLL/PLLTopNetlistSDF.v
//vcs_tchbn9oph9_v2001.v
","Caption: ""Creating a file list for Verilog simulation and viewing SDF annotation reports in a VCS simulation environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p315.jpg,True,"The image shows a text about digital VLSI design with Verilog, focusing on delay pessimism and gate-level timing triplets. There is a bit of Verilog code in this image. Here is the code:

```verilog
or (strong0, weak1) or_01(out_or, in1, in2, in3, in4);

or #(2, 1) or_01(out_or, in1, in2, in3, in4);
```

The text provides examples of how to assign strength and delay values to gate outputs in Verilog.","
or (strong0, weak1) or_01(out_or, in1, in2, in3, in4);

or #(2, 1) or_01(out_or, in1, in2, in3, in4);
","""Exploring Delay Pessimism and Gate-Level Timing Triplets in Verilog Simulations""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p301.jpg,True,"```verilog
always@(posedge ParClk, posedge ParRst)
begin : Shifter
    if (ParRst=='b1)
    begin
        N       <= 0;          // N counts the bits shifted.
        ParSR   <= 'b0;        // The shift register.
        ParBusReg <= 'bz;      // The parallel out bus.
        ParValidReg <= 'b0;    // ParValid.
    end
    else if (SerValid=='b1)     // Ignore the serial line if 0.
    begin
        ParSR <= Shift1(ParSR, SerIn); // function called.
        N <= N + 1;
        if (N>ParHi) // If 32 bits shifted.
        begin
            Unload32; // task called.
            N <= 0;
        end
    end // Shifter.
end
```
This block of Verilog code defines an `always` block that triggers on the positive edge of `ParClk` or on the positive edge of `ParRst`. The block encapsulates a shifter functionality, which includes initializing shift register and other signals on reset, shifting data on the positive edge of `ParClk`, and invoking a task called `Unload32` when 32 bits have been shifted.","
always@(posedge ParClk, posedge ParRst)
begin : Shifter
    if (ParRst=='b1)
    begin
        N       <= 0;          // N counts the bits shifted.
        ParSR   <= 'b0;        // The shift register.
        ParBusReg <= 'bz;      // The parallel out bus.
        ParValidReg <= 'b0;    // ParValid.
    end
    else if (SerValid=='b1)     // Ignore the serial line if 0.
    begin
        ParSR <= Shift1(ParSR, SerIn); // function called.
        N <= N + 1;
        if (N>ParHi) // If 32 bits shifted.
        begin
            Unload32; // task called.
            N <= 0;
        end
    end // Shifter.
end
","Caption: ""Excerpt from a Digital VLSI Design textbook discussing an always block in Verilog code used for data deserialization, accompanied by explanatory text regarding the implementation details.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p564.jpg,True,"The image contains two snippets of code written in C for use with Verilog through ACC routines. Here are the code snippets from the image:

```c
/************************************************************************
 * Function to determine if a specific bit is set in a 32-bit word.
 * Sets the least-significant bit of a mask value to 1 and shifts the
 * mask left to the desired bit number.
 ************************************************************************/
int PLIbook_getbit(int word, int bit_num)
{
    int mask;
    mask = 0x00000001 << bit_num;
    return (word & mask) ? TRUE : FALSE;
}

/************************************************************************
 * Function to convert aval/bval encoding to 4-state logic represented
 * as a C character.
 ************************************************************************/
char PLIbook_get_4state_val(int aval, int bval)
{
    if      (!bval && !aval) return('0');
    else if (!bval &&  aval) return('1');
    else if ( bval && !aval) return('z');
    else                     return('x');
}
```

The first function `PLIbook_getbit` checks if a specific bit is set in a 32-bit word. The second function `PLIbook_get_4state_val` converts the aval/bval encoding to a character representing a 4-state logic value.","********************************************************************
 * Function to determine if a specific bit is set in a 32-bit word.
 * Sets the least-significant bit of a mask value to 1 and shifts the
 * mask left to the desired bit number.
 ************************************************************************/
int PLIbook_getbit(int word, int bit_num)
{
    int mask;
    mask = 0x00000001 << bit_num;
    return (word & mask) ? TRUE : FALSE;
}

/************************************************************************
 * Function to convert aval/bval encoding to 4-state logic represented
 * as a C character.
 ************************************************************************/
char PLIbook_get_4state_val(int aval, int bval)
{
    if      (!bval && !aval) return('0');
    else if (!bval &&  aval) return('1');
    else if ( bval && !aval) return('z');
    else                     return('x');
}
","""Excerpt from a book on Verilog demonstrating ACC routines for reading and modifying values in Verilog objects, including example code and function descriptions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p573.jpg,True,"Here is the Verilog code present in the image:

```verilog
OVL_ASSERT_2STATE, // defined as enum types
OVL_ASSERT: begin : ovl_assert
if (min_ack_cycle > 0)
begin : a_assert_handshake_ack_min_cycle
A_ASSERT_HANDSHAKE_ACK_MIN_CYCLE_P:
assert property (ASSERT_HANDSHAKE_ACK_MIN_CYCLE_P)
else ovl_error_t(""...as before..."");
end
// other assert and assume statements
endcase
`endif //ASSERT_ON

`ifdef COVER_ON
generate
if (coverage_level != OVL_COVER_NONE) begin : ovl_cover
if (OVL_COVER_BASIC_ON)
begin : ovl_cover_basic
cover_req_asserted:
cover property
(reset throughout req))
ovl_cover_t(""req_asserted covered"");
end
//... other cover statement ...
end
endgenerate
`endif // COVER_ON
```

The code snippet is related to assertions and coverage in a Verilog or SystemVerilog design. It includes an example of an assertion check and a coverage check, using macros (like `OVL_ASSERT_2STATE`, `OVL_ASSERT`, `COVER_ON`) and specific coverage constructs. The text also outlines certain differences that appear to relate to updates or improvements on handling assertions and coverage in this context.","
OVL_ASSERT_2STATE, // defined as enum types
OVL_ASSERT: begin : ovl_assert
if (min_ack_cycle > 0)
begin : a_assert_handshake_ack_min_cycle
A_ASSERT_HANDSHAKE_ACK_MIN_CYCLE_P:
assert property (ASSERT_HANDSHAKE_ACK_MIN_CYCLE_P)
else ovl_error_t(""...as before..."");
end
// other assert and assume statements
endcase
`endif //ASSERT_ON

`ifdef COVER_ON
generate
if (coverage_level != OVL_COVER_NONE) begin : ovl_cover
if (OVL_COVER_BASIC_ON)
begin : ovl_cover_basic
cover_req_asserted:
cover property
(reset throughout req))
ovl_cover_t(""req_asserted covered"");
end
//... other cover statement ...
end
endgenerate
`endif // COVER_ON
","""Sample of Verilog code demonstrating assertions and coverage in SystemVerilog with explanatory notes on differences in syntax and functions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p219.jpg,True,"The image contains two code samples written in Verilog. Here they are:

Sample 6.9:
```verilog
// Bus operation, byte, word, or longword
class BusOp;
    // Operand length
    typedef enum {BYTE, WORD, LWRD } length_e;
    rand length_e len;

    // Weights for dist constraint
    bit [31:0] w_byte=1, w_word=3, w_lwrd=5;

    constraint c_len {
        len dist {BYTE := w_byte,  // Choose a random
                  WORD := w_word,  // length using
                  LWRD := w_lwrd}; // variable weights
    }
endclass
```

Sample 6.10:
```verilog
class Ranges;
    rand bit [31:0] c;      // Random variable
    bit [31:0] lo, hi;      // Non-random variables used as limits

    constraint c_range {
        c inside {[lo:hi]};  // lo <= c && c <= hi
    }
endclass
```

These two samples illustrate the use of dynamic constraints and the `inside` operator in the SystemVerilog language.","
// Bus operation, byte, word, or longword
class BusOp;
    // Operand length
    typedef enum {BYTE, WORD, LWRD } length_e;
    rand length_e len;

    // Weights for dist constraint
    bit [31:0] w_byte=1, w_word=3, w_lwrd=5;

    constraint c_len {
        len dist {BYTE := w_byte,  // Choose a random
                  WORD := w_word,  // length using
                  LWRD := w_lwrd}; // variable weights
    }
endclass


class Ranges;
    rand bit [31:0] c;      // Random variable
    bit [31:0] lo, hi;      // Non-random variables used as limits

    constraint c_range {
        c inside {[lo:hi]};  // lo <= c && c <= hi
    }
endclass
","""Verilog Code Snippets Demonstrating Dynamically Changing Distribution Weights and Set Membership with Inside Operator""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p215.jpg,True,"The image contains Verilog code regarding checker declarations. Here is the code extracted from the image:

```verilog
checker check1(a, b, c, d,
  event clk = $inferred_clock,untyped rst = $inferred_disable);
  default clocking @clk; endclocking
  default disable iff rst;
  
  property p1(x, y);
    x[2] |-> y;
  endproperty : p1
  
  property p2(x, y);
    x |-> y[x+2];
  endproperty : p2
  ...
checker check2();
  property p1(x, y);
    x[2] |-> y[x+2];
  endproperty : p1
    a1: assert property (p1(a, b));
    a2: assert property (p2(c, d));
endchecker : check2

endchecker : check1
```

This code demonstrates the syntax for declaring checkers in Verilog, setting up properties, default clocking, and assertions within a checker. The text in the image also discusses the visibility of checker arguments and properties, and how they are referenced within nested checker contexts.","
checker check1(a, b, c, d,
  event clk = $inferred_clock,untyped rst = $inferred_disable);
  default clocking @clk; endclocking
  default disable iff rst;
  
  property p1(x, y);
    x[2] |-> y;
  endproperty : p1
  
  property p2(x, y);
    x |-> y[x+2];
  endproperty : p2
  ...
checker check2();
  property p1(x, y);
    x[2] |-> y[x+2];
  endproperty : p1
    a1: assert property (p1(a, b));
    a2: assert property (p2(c, d));
endchecker : check2

endchecker : check1
",Example of Nested Verilog Checkers with Default Clocking and Reset Properties.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p202.jpg,True,"Here is the code from the image:

```verilog
always @(posedge clock)
  $read_test_vector(""A.dat"", data_bus);
```

This Verilog code snippet sets up a process that is triggered on every positive edge of the `clock` signal. When triggered, it calls a user-defined system task (PLI application) `$read_test_vector` with two arguments: the string `""A.dat""` indicating a file name and `data_bus` likely representing a register or bus where data is being stored.","
always @(posedge clock)
  $read_test_vector(""A.dat"", data_bus);
","Caption: ""Excerpt from 'The Verilog PLI Handbook' discussing simulation callback routines, instance-specific work areas, and providing an example Verilog code snippet for a test vector reader function.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p201.jpg,True,"```verilog
var type(dataIn) last_dataIn;
always @(posedge clk)
  if ($sampled(start))
    last_dataIn <= $sampled(dataIn);
a_seq_data_check: assert property (
  complete |-> dataOut == last_dataIn);
```","
var type(dataIn) last_dataIn;
always @(posedge clk)
  if ($sampled(start))
    last_dataIn <= $sampled(dataIn);
a_seq_data_check: assert property (
  complete |-> dataOut == last_dataIn);
","""Example of Verilog code implementing a sequential protocol data check with an assertion statement.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p567.jpg,True,"The image contains Verilog code. Here is the code text:

```verilog
`""only 1 (level 0), 2(level 2), 3(both)"", ""or 0 (disabled) are allowed""`);
if (usage_kind != ASSERT || usage_kind != ASSUME)
$warning(""No assert or assume selected"");

if (synthesis) begin : SYNTH
  let check_onehot0 (sig, reset) = 
    ((!reset_n) || $onehot0(sig));
  let cover_onehot0 (sig, reset) = 
    ((reset) && $onehot0(sig));
end : SYNTH
else begin : NO_SYNTH
  let check_onehot0 (sig, reset) = 
    ((reset === 0) || $onehot0(sig) && !:$isunknown(reset));
  let cover_onehot0 (sig, reset) = 
    ((reset === 1) && $onehot0(sig));
end : NO_SYNTH

`ifdef ASSERT_ON
if (usage_kind == ASSERT) begin : ASSERT
  Assert_onehot0:
    assert final (check_onehot0(sig, reset))
      else $error(msg);
end : ASSERT
else if (usage_kind == ASSUME) begin : ASSUME
  Assume_onehot0:
    assume final (check_onehot0(sig, reset))
      else $error(msg);
end : ASSUME
`endif

`ifdef COVER_ON
if (cover_level & 1) begin : COVER_L1
  Cover_onehot0_1:
    cover final (cover_onehot0(sig, reset));
end : COVER_L1

if (!synthesis && (cover_level & 2))
begin : COVER_L2
  function init position(logic $bits(sig) arg);
    for (int i = 0; i < $bits(sig); i++)
      if (sig[i] === 1) return i;
    return 0;
  endfunction // position

  covergroup cg_onehot0_2 with
    function sample(int index);
  coverpoint index;
  endgroup
  cg_onehot0_2 onehot0_2_index = new();
  Cover_onehot0_2:
    cover #0 (cover_onehot0(sig, reset))
    onehot0_2_index.sample(position(sig));
`endif
```

This code appears to be part of a verification library for hardware design in Verilog, using constructs like assertions, assumptions, and coverage points for formal verification or testbench creation in the context of ASIC or FPGA development.","
`""only 1 (level 0), 2(level 2), 3(both)"", ""or 0 (disabled) are allowed""`);
if (usage_kind != ASSERT || usage_kind != ASSUME)
$warning(""No assert or assume selected"");

if (synthesis) begin : SYNTH
  let check_onehot0 (sig, reset) = 
    ((!reset_n) || $onehot0(sig));
  let cover_onehot0 (sig, reset) = 
    ((reset) && $onehot0(sig));
end : SYNTH
else begin : NO_SYNTH
  let check_onehot0 (sig, reset) = 
    ((reset === 0) || $onehot0(sig) && !:$isunknown(reset));
  let cover_onehot0 (sig, reset) = 
    ((reset === 1) && $onehot0(sig));
end : NO_SYNTH

`ifdef ASSERT_ON
if (usage_kind == ASSERT) begin : ASSERT
  Assert_onehot0:
    assert final (check_onehot0(sig, reset))
      else $error(msg);
end : ASSERT
else if (usage_kind == ASSUME) begin : ASSUME
  Assume_onehot0:
    assume final (check_onehot0(sig, reset))
      else $error(msg);
end : ASSUME
`endif

`ifdef COVER_ON
if (cover_level & 1) begin : COVER_L1
  Cover_onehot0_1:
    cover final (cover_onehot0(sig, reset));
end : COVER_L1

if (!synthesis && (cover_level & 2))
begin : COVER_L2
  function init position(logic $bits(sig) arg);
    for (int i = 0; i < $bits(sig); i++)
      if (sig[i] === 1) return i;
    return 0;
  endfunction // position

  covergroup cg_onehot0_2 with
    function sample(int index);
  coverpoint index;
  endgroup
  cg_onehot0_2 onehot0_2_index = new();
  Cover_onehot0_2:
    cover #0 (cover_onehot0(sig, reset))
    onehot0_2_index.sample(position(sig));
`endif
","Verilog code for implementing various checkers using onehot encoding with support for assertions, assumptions, and coverage.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p32.jpg,True,"The image contains Verilog code. Here is the code written out for you:

```verilog
// ============================================================
// Intro_Top: Top level of a simple design using verilog
// continuous assignment statements.
//
// This module contains the top structure of the design, which
// is made up of three lower-level modules and one inverter gate.
// The structure is represented by module instances.
//
// All ports are wire types, because this is the default; also,
// there is no storage of state in combinational statements.
//
// ANSI module header.
// ------------------------------------------------------------
// 2004-11-25 jmw: v. 1.0 implemented.
// ============================================================
module Intro_Top (output X, Y, Z, input A, B, C, D);
//
wire ab, bc, q, qn; // Wires for internal connectivity.
//
// Implied wires may be assumed in this combinational
// design, when connecting declared ports to instance ports.
// The #1 is a delay time, in `timescale units:
//
assign #1 Z = ~qn; // Inverter by continuous assignment statement.
//
AndOr InputCombo01 (.X(ab), .Y(bc), .A(A), .B(B), .C(C));
SR SRLatch01 (.Q(q), .Qn(qn), .S(bc), .R(D));
XorNor OutputCombo01 (.X(X), .Y(Y), .A(ab), .B(q), .C(qn));
//
endmodule // Intro_Top.
```","
// ============================================================
// Intro_Top: Top level of a simple design using verilog
// continuous assignment statements.
//
// This module contains the top structure of the design, which
// is made up of three lower-level modules and one inverter gate.
// The structure is represented by module instances.
//
// All ports are wire types, because this is the default; also,
// there is no storage of state in combinational statements.
//
// ANSI module header.
// ------------------------------------------------------------
// 2004-11-25 jmw: v. 1.0 implemented.
// ============================================================
module Intro_Top (output X, Y, Z, input A, B, C, D);
//
wire ab, bc, q, qn; // Wires for internal connectivity.
//
// Implied wires may be assumed in this combinational
// design, when connecting declared ports to instance ports.
// The #1 is a delay time, in `timescale units:
//
assign #1 Z = ~qn; // Inverter by continuous assignment statement.
//
AndOr InputCombo01 (.X(ab), .Y(bc), .A(A), .B(B), .C(C));
SR SRLatch01 (.Q(q), .Qn(qn), .S(bc), .R(D));
XorNor OutputCombo01 (.X(X), .Y(Y), .A(ab), .B(q), .C(qn));
//
endmodule // Intro_Top.
","""Example of Verilog code for a top-level digital design module with comments and schematic representation""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p558.jpg,True,"Here is the code from the image:

```c
handle tfarg_h;
s_acc_value val_s;

tfarg_h = acc_handle_tfarg(1);

val_s.format = accIntVal;

acc_fetch_value(tfarg_h, ""%&"", &val_s);

io_printf(""%s = %d\n"",
          acc_fetch_name(tfarg_h),
          val_s.value.integer);
```","e tfarg_h;
s_acc_value val_s;

tfarg_h = acc_handle_tfarg(1);

val_s.format = accIntVal;

acc_fetch_value(tfarg_h, ""%&"", &val_s);

io_printf(""%s = %d\n"",
          acc_fetch_name(tfarg_h),
          val_s.value.integer);
","Caption: ""Example of using ACC routines in C to read Verilog integer and real values into C data types.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p229.jpg,True,"The image contains Verilog code snippets. Here are the code samples provided in the image:

First code example:
```verilog
checker out_illegal (in, output out, input event clk);
always_ff @clk
    out <= in;
endchecker : out_illegal
```

Second code example:
```verilog
checker out_concrete (in,
                      output logic [7] out,
                      input event clk);
always_ff @clk
    out <= in;
endchecker : out_concrete
```

Third code example:
```verilog
checker out_inferred (in,
                      output var type(in) out,
                      input event clk);
always_ff @clk
    out <= in;
endchecker : out_inferred
```","
checker out_illegal (in, output out, input event clk);
always_ff @clk
    out <= in;
endchecker : out_illegal


checker out_concrete (in,
                      output logic [7] out,
                      input event clk);
always_ff @clk
    out <= in;
endchecker : out_concrete


checker out_inferred (in,
                      output var type(in) out,
                      input event clk);
always_ff @clk
    out <= in;
endchecker : out_inferred
","Caption: ""Examples illustrating the correct usage of output arguments in Verilog checkers, demonstrating illegal, concrete, and inferred type declarations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p225.jpg,True,"The image contains Verilog code. Here it is transcribed:

Sample 6.23 Implication operator
```verilog
class LogImp;
  rand bit d, e;
  constraint c {
    (d==1) -> (e==1);
  }
endclass
```

Sample 6.24 Constraint block with if implication operator
```verilog
class BusOp;
  rand bit [31:0] addr;
  rand bit io_space_mode;
  constraint c_io {
    if (io_space_mode)
      addr[31] == 1'b1;
  }
}
```

Sample 6.25 Constraint block with if-else operator
```verilog
class BusOp;
  rand operand_e op;
  rand length_e len;
  
  constraint c_len_rw {
    if (op == READ) {
      len inside { [BYTE:LWRD] };
    } else {
      len == LWRD;
    }
  }
}
```","
class LogImp;
  rand bit d, e;
  constraint c {
    (d==1) -> (e==1);
  }
endclass


class BusOp;
  rand bit [31:0] addr;
  rand bit io_space_mode;
  constraint c_io {
    if (io_space_mode)
      addr[31] == 1'b1;
  }
}


class BusOp;
  rand operand_e op;
  rand length_e len;
  
  constraint c_len_rw {
    if (op == READ) {
      len inside { [BYTE:LWRD] };
    } else {
      len == LWRD;
    }
  }
}
","Caption: Examples of Verilog code demonstrating the use of implication and if-else operators in constraints for randomization.
",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p231.jpg,True,"The image includes content on controlling multiple constraint blocks in Verilog with an example code snippet. Here's the code transcribed from the image:

```verilog
class Packet;
    rand bit [31:0] length;
    constraint c_short {length inside {[1:32]}; }
    constraint c_long {length inside {[1000:1023]}; }
endclass

Packet p;
initial begin
    p = new();

    // Create a long packet by disabling short constraint
    p.c_short.constraint_mode(0);
    `SV_RAND_CHECK(p.randomize());

    transmit(p);

    // Create a short packet by disabling all constraints
    // then enabling only the short constraint
    p.constraint_mode(0);
    p.c_short.constraint_mode(1);
    `SV_RAND_CHECK(p.randomize());

    transmit(p);
end
```

This code sample is intended to show how to use the `constraint_mode` method to toggle constraints on and off in a Verilog class for test packet generation.","
class Packet;
    rand bit [31:0] length;
    constraint c_short {length inside {[1:32]}; }
    constraint c_long {length inside {[1000:1023]}; }
endclass

Packet p;
initial begin
    p = new();

    // Create a long packet by disabling short constraint
    p.c_short.constraint_mode(0);
    `SV_RAND_CHECK(p.randomize());

    transmit(p);

    // Create a short packet by disabling all constraints
    // then enabling only the short constraint
    p.constraint_mode(0);
    p.c_short.constraint_mode(1);
    `SV_RAND_CHECK(p.randomize());

    transmit(p);
end
","The image contains text explaining how to control multiple constraint blocks in Verilog, along with a sample code demonstrating the use of the `constraint_mode` function to enable and disable constraints in a Verilog class representing a packet.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p219.jpg,True,"The image contains the following Verilog code:

```verilog
// Setup two counters to tag the req's and ack's.
reg [3:0] req_cnt, ack_cnt;
initial {req_cnt, ack_cnt} = 8'b0;

always @ (posedge clk) begin
    // Increment counter each time event is seen.
    if (req) req_cnt <= req_cnt + 1;
    if (ack) ack_cnt <= ack_cnt + 1;
end

// declarative PSL assertion
// assert tagged req/ack sequence completes in 100 cycles

// For each tag.
assert
    forall c in {0:15}:
    always {req && req_cnt == c} |=> {[*0:99]; ack && ack_cnt == c})
    @ (posedge clk);
```","
// Setup two counters to tag the req's and ack's.
reg [3:0] req_cnt, ack_cnt;
initial {req_cnt, ack_cnt} = 8'b0;

always @ (posedge clk) begin
    // Increment counter each time event is seen.
    if (req) req_cnt <= req_cnt + 1;
    if (ack) ack_cnt <= ack_cnt + 1;
end

// declarative PSL assertion
// assert tagged req/ack sequence completes in 100 cycles

// For each tag.
assert
    forall c in {0:15}:
    always {req && req_cnt == c} |=> {[*0:99]; ack && ack_cnt == c})
    @ (posedge clk);
","Caption: ""Example of Verilog and PSL code for a pipelined request/acknowledge handshake protocol with FIFO in-order semantics.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p288.jpg,True,"```verilog
property pr1;
  @(posedge clk) req |-> ##2 gnt;
endproperty

A_reqGnt: assert property (pr1) else $display($stime,,,""\t %m FAIL"");

C_reqGnt: cover property (pr1) $display($stime,,,""\t %m PASS"");
```
These lines of Verilog code represent a property definition and two system tasks, `assert` and `cover`, which are used for assertion-based verification in hardware design.","
property pr1;
  @(posedge clk) req |-> ##2 gnt;
endproperty

A_reqGnt: assert property (pr1) else $display($stime,,,""\t %m FAIL"");

C_reqGnt: cover property (pr1) $display($stime,,,""\t %m PASS"");
","""Verilog Assertion with 'cover' to Handle Vacuous Pass Behavior""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p201.jpg,True,"```verilog
program automatic test;
    event cg_sample;

    covergroup CG_xyz @(cg_sample); // covergroup definition
        coverpoint x;
        coverpoint y;
        coverpoint z;
    endgroup

    class Abc;
        rand bit [7:0] a, b, c;

        covergroup CG_abc @(cg_sample); // covergroup definition
            coverpoint a;
            coverpoint b;
            coverpoint c;
        endgroup

        function new;
            CG_abc = new;                  // instance of covergroup
        endfunction
    endclass

    initial begin
        Abc a1 = new;                     // instance of Abc object
        CG_xyz = new;                     // instance of covergroup
        ... // generate stimulus
        $get_coverage();                  // OK, reports coverage
    end
endprogram
```","
program automatic test;
    event cg_sample;

    covergroup CG_xyz @(cg_sample); // covergroup definition
        coverpoint x;
        coverpoint y;
        coverpoint z;
    endgroup

    class Abc;
        rand bit [7:0] a, b, c;

        covergroup CG_abc @(cg_sample); // covergroup definition
            coverpoint a;
            coverpoint b;
            coverpoint c;
        endgroup

        function new;
            CG_abc = new;                  // instance of covergroup
        endfunction
    endclass

    initial begin
        Abc a1 = new;                     // instance of Abc object
        CG_xyz = new;                     // instance of covergroup
        ... // generate stimulus
        $get_coverage();                  // OK, reports coverage
    end
endprogram
","Textbook excerpt on using Verilog covergroups for functional coverage, including code examples.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p117.jpg,True,"The image contains a snippet of Verilog code, which describes a simple resettable 5-bit up-counter. Here is the code as it appears in the image:

```verilog
reg[4:0] Count;
always@(posedge Clock, posedge Reset)
  begin
    if (Reset=='b1)
      Count <= 5'h0;
    else
      Count <= Count + 5'h1;
  end
```","
reg[4:0] Count;
always@(posedge Clock, posedge Reset)
  begin
    if (Reset=='b1)
      Count <= 5'h0;
    else
      Count <= Count + 5'h1;
  end
","The image displays educational material that includes a block diagram and code snippet for a 32x Digital PLL (Phase-Locked Loop) implemented in Verilog. A detailed explanation of a simple, resettable 5-bit up-counter in Verilog is also provided.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p225.jpg,True,"The image contains code written in SystemVerilog, which is a hardware description and verification language. Here is the code from the examples shown in the image:

Example 6-52:
```verilog
// pipeline protocol pattern
// See pipelined_reqack templete definition in Example 6-44

// Make sure queued read is completed by memory (with MemEngDone).
// Atmost 6 requests (pipedepth) may be queued.
// Limit latency for return to 100 cycles.

pipelined_reqack
    sendReadReq(.req(EngMemRd) , .reg_datain(),
    .ack(MemEngDone),
    .dataout(),
    .clk(clk),.latency(100),.pipedept(6));
```

Example 6-53:
```verilog
// valid signal combination pattern

assert property (@ (posedge clk) disable iff ( rst_n )
    not (QueFull & QueAlmostFull))
    else $error(""Queue interface illegal state Quefull and QueAlmostFull."");
```

Example 6-54:
```verilog
// X detection pattern

assert property (@ (posedge clk) disable iff ( rst_n )
    $isunknown(QueFull, QueAlmostFull, ReadExistsInQue))
    else $error(""Queue status interface has unknown values."");
```

These examples illustrate the use of assertions in SystemVerilog to ensure correct operation and signal handling within hardware designs.","
// pipeline protocol pattern
// See pipelined_reqack templete definition in Example 6-44

// Make sure queued read is completed by memory (with MemEngDone).
// Atmost 6 requests (pipedepth) may be queued.
// Limit latency for return to 100 cycles.

pipelined_reqack
    sendReadReq(.req(EngMemRd) , .reg_datain(),
    .ack(MemEngDone),
    .dataout(),
    .clk(clk),.latency(100),.pipedept(6));


// valid signal combination pattern

assert property (@ (posedge clk) disable iff ( rst_n )
    not (QueFull & QueAlmostFull))
    else $error(""Queue interface illegal state Quefull and QueAlmostFull."");


// X detection pattern

assert property (@ (posedge clk) disable iff ( rst_n )
    $isunknown(QueFull, QueAlmostFull, ReadExistsInQue))
    else $error(""Queue status interface has unknown values."");
",Verilog code examples demonstrating assertions to ensure proper queue operation and signal protocols.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p231.jpg,True,"```verilog
default clock = (posedge clk);

assert always (a'b) @(posedge clk) abort rst_n;

assert property (@(posedge clk) disable iff (rst_n) (a'b));
```","
default clock = (posedge clk);

assert always (a'b) @(posedge clk) abort rst_n;

assert property (@(posedge clk) disable iff (rst_n) (a'b));
","Caption: ""Excerpt from a book on Assertion-Based Design discussing the use of user-defined error messages in assertions and the inclusion of clock and reset conditions in Property Specification Language (PSL) and SystemVerilog code examples.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p215.jpg,True,"The image contains the following Verilog code snippet:

```verilog
module test;
import foo::*;   // wildcard import foo
import bar::*;   // wildcard import bar

uint_t c;        // OK, reference definition
                 // that is in package foo
...
endmodule
``` 

This code sample demonstrates the use of wildcard imports in a Verilog module.","
module test;
import foo::*;   // wildcard import foo
import bar::*;   // wildcard import bar

uint_t c;        // OK, reference definition
                 // that is in package foo
...
endmodule
","""Best practices for Verilog code compatibility and handling package imports to avoid 'gotchas' in design and verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p338.jpg,True,"The image contains Verilog code. Here's the transcription of the code visible in the image:

```verilog
// only one of the implication operators can be
// asserted at any time
property config_check2;
    @(posedge clk)
        $onehot0({o_l_implication,
                  o_e_implication, non_o_implication});
endproperty

// min_time should be at least 1
property config_check3;
    @(posedge clk)
        (timing == 1) |-> (min_time >= 1);
endproperty

// repetition should be greater that one
property config_check4;
    @(posedge clk)
        ((c_rpt == 1) && (rpt_me == 1)) |-> 
        (repetition > 1);
endproperty

a_check1: assert property(config_check1);
a_check2: assert property(config_check2);
a_check3: assert property(config_check3);
a_check4: assert property(config_check4);

endmodule

The ATB gets executed based on the parameter configuration. A sample ATB used for the verification of SVA involving two signals is shown below.

module sig_sva_tb;

logic a, b;
logic clk;
logic [1:0] rpt_wait;
logic [1:0] stop_wait;

`include ""config.v""

integer i, j;

endmodule
``` 

Please note that the code snippet may depend on the context that isn't fully included in the image, such as definitions in ""config.v"" or other parts of the document not shown.","
// only one of the implication operators can be
// asserted at any time
property config_check2;
    @(posedge clk)
        $onehot0({o_l_implication,
                  o_e_implication, non_o_implication});
endproperty

// min_time should be at least 1
property config_check3;
    @(posedge clk)
        (timing == 1) |-> (min_time >= 1);
endproperty

// repetition should be greater that one
property config_check4;
    @(posedge clk)
        ((c_rpt == 1) && (rpt_me == 1)) |-> 
        (repetition > 1);
endproperty

a_check1: assert property(config_check1);
a_check2: assert property(config_check2);
a_check3: assert property(config_check3);
a_check4: assert property(config_check4);

endmodule

The ATB gets executed based on the parameter configuration. A sample ATB used for the verification of SVA involving two signals is shown below.

module sig_sva_tb;

logic a, b;
logic clk;
logic [1:0] rpt_wait;
logic [1:0] stop_wait;

`include ""config.v""

integer i, j;

endmodule
","""Excerpt from a book on Verilog showing SystemVerilog Assertions (SVAs) for checking parameter configurations and a snippet of a testbench module.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p277.jpg,True,"The image contains Verilog code in it. Here's the code listed:

Pseudo-code (not actual Verilog code; intended as an example of what not to do):

```verilog
property read_latency_check;
    @(posedge clk) disable iff (!rst_n) ($fell(rd_) |-> ##[readLatency] (read_data == expected_data));
endproperty

assert property (read_latency_check);
```

Actual Verilog code for a possible solution:

```verilog
property read_latency_check;
    int Ldelay;
    @(posedge clk) disable iff (!rst_n)
    (
        ($fell(rd_), Ldelay=readLatency) ##1
        (1, Ldelay = Ldelay-1)[*0:$] ##1 (Ldelay==0) |-> (read_data == expected_data)
    );
endproperty

assert property (read_latency_check);
```

The image also provides an explanation of how the property `read_latency_check` operates, specifically mentioning the decrement of `Ldelay` at every `posedge clk` until it reaches 0.","
property read_latency_check;
    @(posedge clk) disable iff (!rst_n) ($fell(rd_) |-> ##[readLatency] (read_data == expected_data));
endproperty

assert property (read_latency_check);


property read_latency_check;
    int Ldelay;
    @(posedge clk) disable iff (!rst_n)
    (
        ($fell(rd_), Ldelay=readLatency) ##1
        (1, Ldelay = Ldelay-1)[*0:$] ##1 (Ldelay==0) |-> (read_data == expected_data)
    );
endproperty

assert property (read_latency_check);
","""Understanding and Implementing Verilog Code for Variable Delay Check Using SystemVerilog Assertions (SVA)""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p263.jpg,True,"```verilog
property pr1(req, gnt);
    cstart |=> req ##2 gnt;
endproperty

property pr2;
    $fell(aStrobe) |=> $fell(wenb) || $fell(renb);
endproperty

p: cover property (@(posedge clk) pr1(req,gnt))
cA: cover property (@(posedge clk) pr2')
    $display($stime,"""",PASSpr2"");
```","
property pr1(req, gnt);
    cstart |=> req ##2 gnt;
endproperty

property pr2;
    $fell(aStrobe) |=> $fell(wenb) || $fell(renb);
endproperty

p: cover property (@(posedge clk) pr1(req,gnt))
cA: cover property (@(posedge clk) pr2')
    $display($stime,"""",PASSpr2"");
",Concurrent assertion in Verilog embedded in procedural code demonstrating non-blocking behavior.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p310.jpg,True,"Here is the Verilog code from the image:

```verilog
a_1_lh : assert property(p_1_lh);
a_1_ll : assert property(p_1_ll);

// on a given clock edge, if the leading signal
// is high, check that the trailing signal is
// also high
property p4_oli_hh;
    @(posedge clk) a |-> b;
endproperty

// on a given clock edge, if the leading signal
// is high, check that the trailing signal is
// low
property p4_oli_hl;
    @(posedge clk) a |-> !b;
endproperty

// on a given clock edge, if the leading signal
// is low, check that the trailing signal is
// high
property p4_oli_lh;
    @(posedge clk) !a |-> b;
endproperty

// on a given clock edge, if the leading signal
// is low, check that the trailing signal is
// low
property p4_oli_ll;
    @(posedge clk) !a |-> !b;
endproperty

a4_oli_hh: assert property(p4_oli_hh);
```

This code defines a series of properties and assertions for checking the relationship between two signals on the positive edge of a clock signal. It also includes comments explaining what each property is intended to validate.","
a_1_lh : assert property(p_1_lh);
a_1_ll : assert property(p_1_ll);

// on a given clock edge, if the leading signal
// is high, check that the trailing signal is
// also high
property p4_oli_hh;
    @(posedge clk) a |-> b;
endproperty

// on a given clock edge, if the leading signal
// is high, check that the trailing signal is
// low
property p4_oli_hl;
    @(posedge clk) a |-> !b;
endproperty

// on a given clock edge, if the leading signal
// is low, check that the trailing signal is
// high
property p4_oli_lh;
    @(posedge clk) !a |-> b;
endproperty

// on a given clock edge, if the leading signal
// is low, check that the trailing signal is
// low
property p4_oli_ll;
    @(posedge clk) !a |-> !b;
endproperty

a4_oli_hh: assert property(p4_oli_hh);
","Caption: ""Verilog code snippet showing assertions and property definitions for checking signal implications on different clock edges.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p505.jpg,True,"The image contains several snippets of Verilog/SystemVerilog code. Here are the code excerpts from the image:

```verilog
function fSample;
int f5;
...
cs.sample (f5);
endfunction
```

```verilog
covergroup x1 (int cV) with function sample (int cV);
    coverpoint cV; //Compile ERROR
endgroup
```

```verilog
class coverage;
  covergroup cg_abc (data_obj obj);
    coverpoint obj.mode {
      bins range = {[3:'hB]};
    }
  endgroup

  function new ( );
    data_obj obj;
    cg_abc = new (obj);
  endfunction
endclass
```

```verilog
module tb;
  initial begin
    coverage m_cov = new ( );
    for (int i = 0; i < 10; i++) begin
      data_obj obj = new ( );
      obj.randomize ( ); // How do I assign obj to covergroup inst ?
    end
  end
```

The text in the image explains issues with naming and assignment in SystemVerilog, and also mentions a compile error due to naming conflicts within a covergroup.","
function fSample;
int f5;
...
cs.sample (f5);
endfunction


covergroup x1 (int cV) with function sample (int cV);
    coverpoint cV; //Compile ERROR
endgroup


class coverage;
  covergroup cg_abc (data_obj obj);
    coverpoint obj.mode {
      bins range = {[3:'hB]};
    }
  endgroup

  function new ( );
    data_obj obj;
    cg_abc = new (obj);
  endfunction
endclass


module tb;
  initial begin
    coverage m_cov = new ( );
    for (int i = 0; i < 10; i++) begin
      data_obj obj = new ( );
      obj.randomize ( ); // How do I assign obj to covergroup inst ?
    end
  end
","""Verilog code depicting the use of sample() method in SystemVerilog and a discussion on compile-time errors related to improper argument usage in covergroup definitions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p202.jpg,True,"The image contains two Verilog code examples. Here is the code for both:

a) Memory model with poor simulation performance
```verilog
for(i = 0; i < fifo_depth; i = i+1)
begin
    case({reset_L, wr, w_addr_ff == i})
        2'b00,
        2'b01: entry_ff[i] <= 0;
        2'b11: entry_ff[i] <= write_data;
        2'b10: entry_ff[i] <= entry_ff[i];
    endcase
end
```

b) Memory model with improved simulation performance
```verilog
if (reset_L_ff)
    for(i = 0; i < fifo_depth; i = i+1) entry_ff[i] <= 0;
else
    entry_ff[w_addr_ff] <= write_data;
```","
for(i = 0; i < fifo_depth; i = i+1)
begin
    case({reset_L, wr, w_addr_ff == i})
        2'b00,
        2'b01: entry_ff[i] <= 0;
        2'b11: entry_ff[i] <= write_data;
        2'b10: entry_ff[i] <= entry_ff[i];
    endcase
end


if (reset_L_ff)
    for(i = 0; i < fifo_depth; i = i+1) entry_ff[i] <= 0;
else
    entry_ff[w_addr_ff] <= write_data;
","""Comparative Examples of Verilog Memory Models with Different Simulation Performances and Discussion on Simulation vs. Synthesis Differences in Verilog RTL Coding""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p379.jpg,True,"The image contains examples of Verilog code. Here is the code in the image:

Example C-9 Within sequence
```
sequence_expr ::= sequence_expr within sequence_expr
```
The within operator is defined in terms of the intersect sequence operators. Its definition is:
```
s1 within s2 ::= ( ( [ *0:$ ] ##1 s1 ##1 [ *0:$ ] ) intersect s2 )
```

Example C-10 Ended sequence
```
expression ::= sequence_identifier.ended

sequence_identifier ::= (identifier of type sequence)
```
Examples include:
```
sequence a1;
@(posedge clk) (c ##1 b ##1 d);
```","ce_expr ::= sequence_expr within sequence_expr

hin s2 ::= ( ( [ *0:$ ] ##1 s1 ##1 [ *0:$ ] ) intersect s2 )

sion ::= sequence_identifier.ended

sequence_identifier ::= (identifier of type sequence)

ce a1;
@(posedge clk) (c ##1 b ##1 d);
","""Understanding Verilog's 'within' sequence operator and the 'ended' method for sequence completion checking.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p216.jpg,True,"```verilog
assign done = &(count_ff[4:0] + 1);

assign done = &((count_ff[4:0] + 5'd1));
```","
assign done = &(count_ff[4:0] + 1);

assign done = &((count_ff[4:0] + 5'd1));
","Caption: ""Discussion on problematic RTL Verilog code and the importance of linting for identifying issues in code expressions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p190.jpg,True,"The image contains Verilog code. Here it is:

```verilog
class Scoping;
  string name;

  function new(input string name);
    this.name = name; // class name = local name
  endfunction
endclass

class Transaction;
  bit [31:0] addr, crc, data[8];
  Statistics stats;
endclass

class Statistics;
  time startT, stopT;
  static int ntrans= 0;
  static time total_elapsed_time;
endclass
```

This code shows examples of class definitions and instantiation in Verilog, showcasing how one class can reference another.","
class Scoping;
  string name;

  function new(input string name);
    this.name = name; // class name = local name
  endfunction
endclass

class Transaction;
  bit [31:0] addr, crc, data[8];
  Statistics stats;
endclass

class Statistics;
  time startT, stopT;
  static int ntrans= 0;
  static time total_elapsed_time;
endclass
","""Verilog code excerpts illustrating the use of 'this' keyword for class variable referencing and class containment through an instance of one class inside another.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p351.jpg,True,"The image contains syntax definitions for a Property Specification Language (PSL) used in formal verification, which can be used with hardware description languages like Verilog and VHDL. Here's the text from the image:

```
Syntax B-20 Suffix implication

FL_Property ::= 
    Sequence ( FL_Property )
    | Sequence |=> Sequence [ ! ]
    | Sequence |=> Sequence 

weak versus
strong 
operators    The strong implication operators specify that the rightmost 
             sequence must complete, whereas the weak implication operators 
             do not. The suffix implication specifies that the rightmost 
             sequence begins on the cycle in which the leftmost sequence ends. 
             The suffix next implication specifies that the rightmost sequence 
             begins on the cycle after the leftmost sequence ends.

B.4.20 Logical implication operator

             The logical if implication operator specifies that if the leftmost 
             property holds, then the rightmost property must hold.

Syntax B-21 Logical implication

FL_Property ::=
    FL_Property -> FL_Property

B.4.21 always temporal operator

             The always operator specifies one of the simplest temporal 
             properties, which states that some Boolean expression must hold 
             at all times.

Syntax B-22 always

FL_Property ::=
    always FL_Property
```

Please note that ""!"" seems to denote a strong implication (necessity), while without ""!"" it's a weak implication (possibility) in the context of Suffix Implication (`Syntax B-20`). For `Syntax B-21`, an arrow ""→"" denotes logical implication, and for `Syntax B-22`, the keyword ""always"" signifies that a property must hold at all times."," B-20 Suffix implication

FL_Property ::= 
    Sequence ( FL_Property )
    | Sequence |=> Sequence [ ! ]
    | Sequence |=> Sequence 

weak versus
strong 
operators    The strong implication operators specify that the rightmost 
             sequence must complete, whereas the weak implication operators 
             do not. The suffix implication specifies that the rightmost 
             sequence begins on the cycle in which the leftmost sequence ends. 
             The suffix next implication specifies that the rightmost sequence 
             begins on the cycle after the leftmost sequence ends.

B.4.20 Logical implication operator

             The logical if implication operator specifies that if the leftmost 
             property holds, then the rightmost property must hold.

Syntax B-21 Logical implication

FL_Property ::=
    FL_Property -> FL_Property

B.4.21 always temporal operator

             The always operator specifies one of the simplest temporal 
             properties, which states that some Boolean expression must hold 
             at all times.

Syntax B-22 always

FL_Property ::=
    always FL_Property
","""Excerpt from a PSL (Property Specification Language) reference discussing suffix implication, logical implication, and the always temporal operator in the context of formal verification for Verilog designs.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p345.jpg,True,"The image contains textual information about Sequence Expression Repetition (SERE) syntax in the context of Verilog or similar hardware description languages. The following are the code-like expressions depicted:

```verilog
SERE_A [ Number_n ]                  // SERE_A repeats exactly Number_n times

SERE_A [ Number_n : Number_m ]       // SERE_A repeats at least Number_n times
                                    // no more than Number_m times

SERE_A [ 0 : Number_m ]              // SERE_A is either empty or repeats no
                                    // more than Number_m times

SERE_A [ Number_n : inf]             // SERE_A repeats at least Number_n
                                    // times

SERE_A [ 0 : inf]                    // SERE_A is either empty or repeats some
                                    // undefined number of times

SERE_A [+]                           // SERE_A evaluates one or more times

[* Number_n]                         // the sequence is of length Number_n

[* Number_n : Number_m]              // the length of the sequence is a number
                                    // between Number_n and Number_m

[* 0 : Number_m]                     // an empty sequence or a sequence of
                                    // length Number_m at most

[* Number_n : inf]                   // a sequence is of length Number_n at
                                    // least

[* 0 : inf]                          // any sequence of events

[*]                                  // any sequence of events (including the
                                    // empty sequence)

[+]                                  // any sequence of events of length one
                                    // at least
```

Nonconsecutive repetition is mentioned to allow for space between the repetition terms and is indicated to be similar to consecutive repetition except the '*' operator is replaced with the '=: operator. Note that the symbol for ""range"" is given to be `:` for Verilog and `to` for VHDL.","
SERE_A [ Number_n ]                  // SERE_A repeats exactly Number_n times

SERE_A [ Number_n : Number_m ]       // SERE_A repeats at least Number_n times
                                    // no more than Number_m times

SERE_A [ 0 : Number_m ]              // SERE_A is either empty or repeats no
                                    // more than Number_m times

SERE_A [ Number_n : inf]             // SERE_A repeats at least Number_n
                                    // times

SERE_A [ 0 : inf]                    // SERE_A is either empty or repeats some
                                    // undefined number of times

SERE_A [+]                           // SERE_A evaluates one or more times

[* Number_n]                         // the sequence is of length Number_n

[* Number_n : Number_m]              // the length of the sequence is a number
                                    // between Number_n and Number_m

[* 0 : Number_m]                     // an empty sequence or a sequence of
                                    // length Number_m at most

[* Number_n : inf]                   // a sequence is of length Number_n at
                                    // least

[* 0 : inf]                          // any sequence of events

[*]                                  // any sequence of events (including the
                                    // empty sequence)

[+]                                  // any sequence of events of length one
                                    // at least
",Verilog SEQUENCE Repetition Operators and Nonconsecutive Repetition Syntax from PSL Specification,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p184.jpg,True,"```verilog
class Bad_OOB;
  bit [31:0] addr, csm, data[8]; // Class-level variable
  extern function void display();
endclass

function void display();           // Missing ""Bad_OOB::""
  $display(""addr=%0d"", addr);   // Error, addr not found
endfunction
```","
class Bad_OOB;
  bit [31:0] addr, csm, data[8]; // Class-level variable
  extern function void display();
endclass

function void display();           // Missing ""Bad_OOB::""
  $display(""addr=%0d"", addr);   // Error, addr not found
endfunction
","Caption: ""Example of a Verilog class with a method incorrectly declared outside the class scope, illustrating a common error related to static versus global variables in SystemVerilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p188.jpg,True,"The following Verilog code is present in the image:

```verilog
let my_let (x, bit y, z) = y ? x : z;
```

This line of code demonstrates the syntax for declaring a `let` construct in Verilog, specifying formal arguments where `x` is untyped, and `y` and `z` are of type `bit`. The body of the `let` expression uses a conditional operator to select between `x` and `z` based on the value of `y`.","
let my_let (x, bit y, z) = y ? x : z;
","A page from a document detailing Verilog's 'let' declarations, explaining syntax rules, and providing an example of its usage.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p163.jpg,True,"There is Verilog code in the image. Here's the code excerpt:

```verilog
logic a, b, temp;
always @(posedge clk) begin
    temp <= $sampled(b); a <= temp;
end
```

Additionally, there are expressions and assertions which resemble code, but they are actually specifying the usage of Verilog functions `$rose` and `$fell` within the text:

```verilog
$rose(e, @clk) == $past(LSB(e),,,@clk) == 1 && $sampled(LSB(e)) === 1.

$fell(e, @clk) == $past(LSB(e),,,@clk) == 0 && $sampled(LSB(e)) === 0.
```

Examples using Verilog assertions:

```verilog
a1: assert property (@(posedge clk) ##1 $rose(sig) |=> sig[4]);

a2: assert property (@(posedge clk) $rose(sig) |=> sig[4]);
```","
logic a, b, temp;
always @(posedge clk) begin
    temp <= $sampled(b); a <= temp;
end


$rose(e, @clk) == $past(LSB(e),,,@clk) == 1 && $sampled(LSB(e)) === 1.

$fell(e, @clk) == $past(LSB(e),,,@clk) == 0 && $sampled(LSB(e)) === 0.


a1: assert property (@(posedge clk) ##1 $rose(sig) |=> sig[4]);

a2: assert property (@(posedge clk) $rose(sig) |=> sig[4]);
","""Understanding Verilog's Sampled Value Functions $rose and $fell with Examples and Assertions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p459.jpg,True,"The image contains a segment of text including Verilog code. Here is the Verilog code as shown in the image:

```verilog
bit [2:0] p1; //values 0 to 7
bit signed [2:0] p2; //values -4 to 3

covergroup g1 @(posedge clk);
  coverpoint p1 {
    bins b1 = { [2:5], [6:10] };
    bins b2 = { -1, [1:10], 15 };
  }
  coverpoint p2 {
    bins b3 = { [2:5], [6:10] };
    bins b4 = { -1, [1:10], 15 };
  }
endgroup
```

This excerpt discusses bins with expressions in the context of SystemVerilog covergroups, accompanied by a discussion of potential warnings that simulators might issue based on this code.","
bit [2:0] p1; //values 0 to 7
bit signed [2:0] p2; //values -4 to 3

covergroup g1 @(posedge clk);
  coverpoint p1 {
    bins b1 = { [2:5], [6:10] };
    bins b2 = { -1, [1:10], 15 };
  }
  coverpoint p2 {
    bins b3 = { [2:5], [6:10] };
    bins b4 = { -1, [1:10], 15 };
  }
endgroup
","""Understanding 'bins' with Expressions in SystemVerilog for Functional Coverage""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p71.jpg,True,"The image contains code related to Verilog PLI (Programming Language Interface) applications. Here is the code:

```c
void ReadVector_register()
{
    s_vpi_systf_data tf_data_bin, tf_data_hex;

    tf_data_bin.type        = vpiSysTask;
    tf_data_bin.tfname      = ""$read_test_vector_bin"";
    tf_data_bin.calltf      = ReadVectorCalltf;
    tf_data_bin.compiletf   = NULL;
    tf_data_bin.sizetf      = NULL;
    tf_data_bin.user_data   = ""1"";
    vpi_register_systf(&tf_data_bin);

    tf_data_hex.type        = vpiSysTask;
    tf_data_hex.tfname      = ""$read_test_vector_hex"";
    tf_data_hex.calltf      = ReadVectorCalltf;
    tf_data_hex.compiletf   = NULL;
    tf_data_hex.sizetf      = NULL;
    tf_data_hex.user_data   = ""2"";
    vpi_register_systf(&tf_data_hex);
}
```

Below this code block, there is another code block which demonstrates how to use the `user_data` in a callback function:

```c
void ReadVectorCalltf(char *user_data)
{
    if (strcmp(user_data, ""1"") == 0)
        /* read test vectors as binary values */
    else if (strcmp(user_data, ""2"") == 0)
        /* read test vectors as hex values */
}
```","ReadVector_register()
{
    s_vpi_systf_data tf_data_bin, tf_data_hex;

    tf_data_bin.type        = vpiSysTask;
    tf_data_bin.tfname      = ""$read_test_vector_bin"";
    tf_data_bin.calltf      = ReadVectorCalltf;
    tf_data_bin.compiletf   = NULL;
    tf_data_bin.sizetf      = NULL;
    tf_data_bin.user_data   = ""1"";
    vpi_register_systf(&tf_data_bin);

    tf_data_hex.type        = vpiSysTask;
    tf_data_hex.tfname      = ""$read_test_vector_hex"";
    tf_data_hex.calltf      = ReadVectorCalltf;
    tf_data_hex.compiletf   = NULL;
    tf_data_hex.sizetf      = NULL;
    tf_data_hex.user_data   = ""2"";
    vpi_register_systf(&tf_data_hex);
}

ReadVectorCalltf(char *user_data)
{
    if (strcmp(user_data, ""1"") == 0)
        /* read test vectors as binary values */
    else if (strcmp(user_data, ""2"") == 0)
        /* read test vectors as hex values */
}
","Caption: ""Example of Verilog VPI routines for reading binary and hexadecimal vectors with associated user data.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p606.jpg,True,"```verilog
typedef struct t_vc_record
{
    int vc_reason;
    int vc_hightime;
    int vc_lowtime;
    char *user_data;
    union
    {
        unsigned char logic_value;
        double real_value;
        handle vector_handle;
        s_strengths strengths_s;
    } out_value;
} s_vc_record, *p_vc_record;
```","
typedef struct t_vc_record
{
    int vc_reason;
    int vc_hightime;
    int vc_lowtime;
    char *user_data;
    union
    {
        unsigned char logic_value;
        double real_value;
        handle vector_handle;
        s_strengths strengths_s;
    } out_value;
} s_vc_record, *p_vc_record;
","Page from ""The Verilog PLI Handbook"" detailing the structure of a value change record used in Verilog simulation.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p65.jpg,True,"The image contains a snippet of Verilog code. Here is the text from the image:

```verilog
30 // Test $pow with valid values */
31 #1 $display(""$pow(2,3) returns %d"", $pow(2,3));
32 #1 result = $pow(a,b);
33 #1 $display(""$pow(a,b) returns %d (a=%d b=%d)"", result, a, b);
34 #1 $stop;
35 $finish;
36 end
37 
38 endmodule
```","
30 // Test $pow with valid values */
31 #1 $display(""$pow(2,3) returns %d"", $pow(2,3));
32 #1 result = $pow(a,b);
33 #1 $display(""$pow(a,b) returns %d (a=%d b=%d)"", result, a, b);
34 #1 $stop;
35 $finish;
36 end
37 
38 endmodule
","Caption: ""Example of Verilog simulation output using the Cadence Verilog-XL simulator demonstrating the use of the `$pow` PLI application.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p177.jpg,True,"The image contains text and a table related to Verilog assertion control tasks. Here is the Verilog code that is visible in the image:

```verilog
$assertcontrol(4,8,1,0,top.inst1.s1);
```

This line of Verilog code is part of a discussion about assertion system functions and tasks, specifically related to controlling the behavior of assertions in a design. The discussion provides information on how the `$assertcontrol` task can be used to enable or disable assertions at different levels of hierarchy or for specific lists of assertions.","
$assertcontrol(4,8,1,0,top.inst1.s1);
","Table showing Verilog assertion control tasks and their equivalent `$assertcontrol` representation, with accompanying explanation and exercises related to Verilog assertions.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p160.jpg,True,"The image contains a snippet of code related to Verilog PLI (Programming Language Interface), specifically handling the `s_vpi_value` data structure. Here is the code from the image:

**Code snippet 1:**
```c
s_vpi_value arg_info;
vpi_get_value(tfarg_handle, &arg_info);
```

**Code snippet 2:**
```c
p_vpi_value arg_info;
arg_info = (p_vpi_value)malloc(sizeof(s_vpi_value));
vpi_get_value(tfarg_handle, arg_info);
```

**Code structure definition:**
```c
typedef struct t_vpi_value {
    int format;
    union {
        char *str;                   /* string value */
        int scalar;                  /* scalar value */
        double real;                 /* real value */
        struct t_vpi_time *time;     /* time value */
        struct t_vpi_vecval *vector; /* vector value */
        struct t_vpi_strengthval *strength; /* strength val */
        char *misc;                  /* reserved */
    } value;
} s_vpi_value, *p_vpi_value;
```

These code excerpts explain how to allocate an `s_vpi_value` structure for automatic or persistent storage when working with Verilog PLI, and define the `t_vpi_value` struct along with its associated types.","_value arg_info;
vpi_get_value(tfarg_handle, &arg_info);

_value arg_info;
arg_info = (p_vpi_value)malloc(sizeof(s_vpi_value));
vpi_get_value(tfarg_handle, arg_info);

ef struct t_vpi_value {
    int format;
    union {
        char *str;                   /* string value */
        int scalar;                  /* scalar value */
        double real;                 /* real value */
        struct t_vpi_time *time;     /* time value */
        struct t_vpi_vecval *vector; /* vector value */
        struct t_vpi_strengthval *strength; /* strength val */
        char *misc;                  /* reserved */
    } value;
} s_vpi_value, *p_vpi_value;
","""Excerpt from 'The Verilog PLI Handbook' discussing the allocation of s_vpi_value structures and their usage in Verilog simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p465.jpg,True,"The image contains examples of Verilog code, specifically related to covergroups and coverpoints used in verification. Below are the excerpts of code from the image:

First example:
```verilog
covergroup cg @(posedge clk);
  coverpoint top.test.count;
  coverpoint top.adrGen.address;
endgroup
```

Second example:
```verilog
covergroup gc (ref logic [7:0] address, ref int data);
  coverpoint a;
  coverpoint b;
endgroup

gc gc_inst = new(testbench.a, testbench.data); //Hierarchical references
```

Third example (showing an illegal reference, denoted with ""ILLEGAL""):
```verilog
covergroup gc @(posedge clk);
  coverpoint top.test.covergroup_inst.cpA; // ILLEGAL
  //CANNOT reference `coverpoint cpA` in the hierarchical
  // covergroup instance
  // `covergroup_inst`.
endgroup
```

Please note that the third example is marked as illegal in the text, meaning that this kind of hierarchical reference is not allowed in Verilog. The other blocks of code are legal examples of how to use covergroups and coverpoints.","
covergroup cg @(posedge clk);
  coverpoint top.test.count;
  coverpoint top.adrGen.address;
endgroup


covergroup gc (ref logic [7:0] address, ref int data);
  coverpoint a;
  coverpoint b;
endgroup

gc gc_inst = new(testbench.a, testbench.data); //Hierarchical references


covergroup gc @(posedge clk);
  coverpoint top.test.covergroup_inst.cpA; // ILLEGAL
  //CANNOT reference `coverpoint cpA` in the hierarchical
  // covergroup instance
  // `covergroup_inst`.
endgroup
","""Understanding Hierarchical References in Verilog Coverpoint Groups""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p153.jpg,True,"The image contains a sample of Verilog code as follows:

```verilog
program automatic bad_generator (output bit clk, data);
    initial
        forever #5 clk <= ~clk ;
    
    initial
        forever @(posedge clk)
            data <= ~data;
endprogram
```","
program automatic bad_generator (output bit clk, data);
    initial
        forever #5 clk <= ~clk ;
    
    initial
        forever @(posedge clk)
            data <= ~data;
endprogram
","""Discussion on why `always` blocks are not allowed in SystemVerilog programs and an example of a bad clock generator in a program block.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p148.jpg,True,"```c
typedef struct t_vpi_time
{
    int type;
    unsigned int high, low;
    double real;
} s_vpi_time, *p_vpi_time;
```","ef struct t_vpi_time
{
    int type;
    unsigned int high, low;
    double real;
} s_vpi_time, *p_vpi_time;
","""Verilog Procedural Interface (VPI) for time retrieval functions and `s_vpi_time` structure definition from The Verilog PLI Handbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p392.jpg,True,"The image contains text describing the Backus-Naur Form (BNF) for assertions in Verilog. The code excerpt provided is a formal representation of how assertions should be written in SystemVerilog. Here it is:

```
C.9.1 Use of Assertions BNF:

concurrent_assertion_item::=
    | concurrent_assert_statement
    | concurrent_assume_statement
    | concurrent_cover_statement
procedural_assertion_item::=
    immediate_assert_statement
    | concurrent_assert_statement
    | concurrent_cover_statement

C.9.2 Assertion statements

immediate_assert_statement ::=
    assert ( expression ) action_block
concurrent_assert_statement ::=
    assert property (`property_spec`) action_block
concurrent_assume_statement ::=
    assume property (`property_spec`)
concurrent_cover_statement ::=
    cover property (`property_spec`) statement_or_null
action_block ::=
    statement [ else statement_or_null ]
    | [statement_or_null] else statement_or_null
statement_or_null ::=
    statement | `;
```","Use of Assertions BNF:

concurrent_assertion_item::=
    | concurrent_assert_statement
    | concurrent_assume_statement
    | concurrent_cover_statement
procedural_assertion_item::=
    immediate_assert_statement
    | concurrent_assert_statement
    | concurrent_cover_statement

C.9.2 Assertion statements

immediate_assert_statement ::=
    assert ( expression ) action_block
concurrent_assert_statement ::=
    assert property (`property_spec`) action_block
concurrent_assume_statement ::=
    assume property (`property_spec`)
concurrent_cover_statement ::=
    cover property (`property_spec`) statement_or_null
action_block ::=
    statement [ else statement_or_null ]
    | [statement_or_null] else statement_or_null
statement_or_null ::=
    statement | `;
","""SystemVerilog Assertions BNF and Syntax for Assertion Statements""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p270.jpg,True,"The image contains Verilog code. Here is the text of the code:

```verilog
property p_mchk9;
  @(posedge clk)
    $fell (framen) ##1
      (par ^ $past (^(ad[31:0] ^ cxben[3:0]))) == 1) |-> ##[1:5] $fell (serrn);
endproperty

a_mchk9: assert property(p_mchk9);
c_mchk9: cover property(p_mchk9);
```","
property p_mchk9;
  @(posedge clk)
    $fell (framen) ##1
      (par ^ $past (^(ad[31:0] ^ cxben[3:0]))) == 1) |-> ##[1:5] $fell (serrn);
endproperty

a_mchk9: assert property(p_mchk9);
c_mchk9: cover property(p_mchk9);
","Caption: ""Example of a SystemVerilog property definition used for checking bus parity errors during the address phase of PCI transactions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p303.jpg,True,"The image contains a snippet of Verilog code regarding the writing of an asynchronous assertion property. Here's the code presented in the image:

```verilog
property CheckData;
    @(L2TxData) (L2TxData == L2ErrorData) |-> (L2Abort == 1);
endproperty
```","
property CheckData;
    @(L2TxData) (L2TxData == L2ErrorData) |-> (L2Abort == 1);
endproperty
","""Exploring the challenges of writing asynchronous assertions in Verilog with an example of potential pitfalls in the coding approach""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p317.jpg,True,"Here is the Verilog code from the image:

```verilog
Illegal_assert: assert property (@clk $future_gclk(a || $rising_gclk(b)); //ILLEGAL nesting

a2: assert property (@clk1 |=> $future_gclk(req)); //ILLEGAL
```

There is also an example of legal usage in the image:

```verilog
F1: assert property (@$ global_clock $rising_gclk(sig1) |->
$falling_gclk(sig2)); //LEGAL
```

This text is part of a document discussing illegal uses of global clocking functions in Verilog assertions and explains certain cases where these functions are not allowed to be used.","
Illegal_assert: assert property (@clk $future_gclk(a || $rising_gclk(b)); //ILLEGAL nesting

a2: assert property (@clk1 |=> $future_gclk(req)); //ILLEGAL


F1: assert property (@$ global_clock $rising_gclk(sig1) |->
$falling_gclk(sig2)); //LEGAL
","""Examples of illegal global clocking function uses in Verilog assertions, with explanations and rules.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p386.jpg,True,"The image includes Verilog code snippets related to property directives, which are part of SystemVerilog assertions. Here's the text of the code from the image:

```verilog
immediate_assert_statement ::=
    assert ( expression ) action_block

concurrent_assert_statement ::=
    assert property ( ' property_spec ' ) action_block

concurrent_assume_statement ::=
    assume property ( ' property_spec ' ) ;

concurrent_cover_statement ::=
    cover property ( ' property_spec ' ) statement_or_null

action_block ::=
    statement [ else statement_or_null ]
    [ statement_or_null ] else statement_or_null

statement_or_null ::=
    statement
    | ;
```

Below are two examples provided in the text:

```verilog
assert property (illegal_op) else $error;

assert property (req -> done[-1] ##1 fill[-1])
else $warning(""Fill did not occur for completed mem read. Why?"");
```

These examples illustrate the usage of `assert property` constructs in SystemVerilog for specifying properties that must be satisfied in the design being verified.","
immediate_assert_statement ::=
    assert ( expression ) action_block

concurrent_assert_statement ::=
    assert property ( ' property_spec ' ) action_block

concurrent_assume_statement ::=
    assume property ( ' property_spec ' ) ;

concurrent_cover_statement ::=
    cover property ( ' property_spec ' ) statement_or_null

action_block ::=
    statement [ else statement_or_null ]
    [ statement_or_null ] else statement_or_null

statement_or_null ::=
    statement
    | ;


assert property (illegal_op) else $error;

assert property (req -> done[-1] ##1 fill[-1])
else $warning(""Fill did not occur for completed mem read. Why?"");
","""Excerpt from documentation detailing Verilog Assert, Assume, and Cover statements with syntax and examples.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p264.jpg,True,"The image contains Verilog/SystemVerilog code. Here it is:

```verilog
property p_mchk4;
  @(posedge clk)
    $fell(framen) |-> 
      1[*1:8] intersect
      ($fell(framen) ##[1:$] $fell(irdyn));
endproperty

a_mchk4: assert property(p_mchk4);
c_mchk4: cover property(p_mchk4);
```

There's also the beginning of another property named `p_mchk5` below it, but it is not complete in the image.","
property p_mchk4;
  @(posedge clk)
    $fell(framen) |-> 
      1[*1:8] intersect
      ($fell(framen) ##[1:$] $fell(irdyn));
endproperty

a_mchk4: assert property(p_mchk4);
c_mchk4: cover property(p_mchk4);
","Caption: ""Verilog Assertions for PCI Protocol Timing Checks""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p471.jpg,True,"The image contains Verilog code, which I will transcribe for you:

```verilog
class configurable_cGroup_class;
  int x;
  covergroup construct_bins_cg(input int min, max, num_bins);
    coverpoint x {
      bins lowest = {min};
      bins highest = {max};
      bins middle[num_bins] = {[min+1:max-1]};
    }
  endgroup

  function new(int min, int width);
    int max = min + width - 1;
    int n_bins = (width - 2)/4; // create 2 bins
    construct_bins_cg = new(min, max, n_bins);
  endfunction
endclass

configurable_cGroup_class cFInst = new(4,10);

class useParams #(parameter int LBound=-1, HBound=16);
  bit [15:0] addr;
  bit [7:0] data;
  covergroup cGroup;
    caddr: coverpoint addr {
      bins b1 [ ] = {LBound : HBound};
      illegal_bins il1 = {[LBound-1:HBound-8]};
    }
    cdata: coverpoint data;
  endgroup
endclass
```
This code snippet describes a way to parameterize coverage groups in Verilog for hardware verification. It includes the definition of a configurable coverage group class and another class that uses parameters to define the bounds of coverage bins.","
class configurable_cGroup_class;
  int x;
  covergroup construct_bins_cg(input int min, max, num_bins);
    coverpoint x {
      bins lowest = {min};
      bins highest = {max};
      bins middle[num_bins] = {[min+1:max-1]};
    }
  endgroup

  function new(int min, int width);
    int max = min + width - 1;
    int n_bins = (width - 2)/4; // create 2 bins
    construct_bins_cg = new(min, max, n_bins);
  endfunction
endclass

configurable_cGroup_class cFInst = new(4,10);

class useParams #(parameter int LBound=-1, HBound=16);
  bit [15:0] addr;
  bit [7:0] data;
  covergroup cGroup;
    caddr: coverpoint addr {
      bins b1 [ ] = {LBound : HBound};
      illegal_bins il1 = {[LBound-1:HBound-8]};
    }
    cdata: coverpoint data;
  endgroup
endclass
","""Verilog code examples demonstrating the parameterization of coverpoints for functional coverage in verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p59.jpg,True,"```verilog
always @(posedge clock)
begin
    result <= $pow(x,y);
    ...
end
```","
always @(posedge clock)
begin
    result <= $pow(x,y);
    ...
end
","""Excerpt from a document on interfacing VPI based PLI Applications to Verilog Simulators with a note on the one-time call nature of $sizetf routine and an example Verilog code snippet using $pow.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p147.jpg,True,"The image contains Verilog code. Here are the two code snippets from the image:

```verilog
program automatic test(bus_if.TB bus);
    initial begin
        @bus.cb;                // Continue on active edge
                                // in clocking block
        repeat (3) @bus.cb;     // Wait for 3 active edges
        @bus.cb.grant;          // Continue on any edge
        @(posedge bus.cb.grant); // Continue on posedge
        @(negedge bus.cb.grant); // Continue on negedge
        wait (bus.cb.grant==1);  // Wait for expression
                                // No delay if already true
        @(posedge bus.cb.grant or
          negedge bus.rst);     // Wait for several signals
    end
endprogram
```

And the second snippet:

```verilog
program automatic test(arb_if.TEST arbif);
    initial begin
        $monitor(""@%0t: grant=%h"", $time, arbif.cb.grant);
        #500ns $display(""End of test"");
    end
endprogram

module arb_dummy(arb_if.DUT arbif);
    initial
        fork
            #70ns arbif.grant = 1;
            #170ns arbif.grant = 2;
            #250ns arbif.grant = 3;
        join
endmodule
```

The image also indicates that this code is for illustration only and is not real, synthesizable RTL (register-transfer level).","
program automatic test(bus_if.TB bus);
    initial begin
        @bus.cb;                // Continue on active edge
                                // in clocking block
        repeat (3) @bus.cb;     // Wait for 3 active edges
        @bus.cb.grant;          // Continue on any edge
        @(posedge bus.cb.grant); // Continue on posedge
        @(negedge bus.cb.grant); // Continue on negedge
        wait (bus.cb.grant==1);  // Wait for expression
                                // No delay if already true
        @(posedge bus.cb.grant or
          negedge bus.rst);     // Wait for several signals
    end
endprogram


program automatic test(arb_if.TEST arbif);
    initial begin
        $monitor(""@%0t: grant=%h"", $time, arbif.cb.grant);
        #500ns $display(""End of test"");
    end
endprogram

module arb_dummy(arb_if.DUT arbif);
    initial
        fork
            #70ns arbif.grant = 1;
            #170ns arbif.grant = 2;
            #250ns arbif.grant = 3;
        join
endmodule
","""Examples of Verilog code demonstrating signal synchronization and interface signal sampling in testbench environments.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p318.jpg,True,"The image contains content relevant to Verilog, but the specific section shown includes an example of SPL (a simple programming language) and its syntax. Here is the excerpt of code and syntax definitions present in the image:

```
P ::= defn* (new T).md(c*)
defn ::= class C { field* meth1* } | thread T { field* meth2* }
field ::= type fd
meth1 ::= (type | void) md(arg*){local* stmt*}
meth2 ::= void md(arg*){local* stmt*}
stmt ::= l: S;
S ::= x = e | x.f = y | x.md(y*) | if x goto l' | return x
e ::= new type | null | this | c | x | x.f | x.md(y*) | f(x*)
arg ::= type x
local ::= type y
type ::= C | T | primitive types such as int, float, boolean, etc.
l ::= label
x, y ::= variable name
C ::= class name
T ::= thread name
fd ::= a field name
md ::= a method name
f ::= pre-defined functions such as +, -, *, /, etc.
c ::= constants such as 1, 2, true, etc.
```

This is an overview of a programming language's syntax, possibly for demonstration or teaching purposes in a context describing concurrent object-oriented programming.","defn* (new T).md(c*)
defn ::= class C { field* meth1* } | thread T { field* meth2* }
field ::= type fd
meth1 ::= (type | void) md(arg*){local* stmt*}
meth2 ::= void md(arg*){local* stmt*}
stmt ::= l: S;
S ::= x = e | x.f = y | x.md(y*) | if x goto l' | return x
e ::= new type | null | this | c | x | x.f | x.md(y*) | f(x*)
arg ::= type x
local ::= type y
type ::= C | T | primitive types such as int, float, boolean, etc.
l ::= label
x, y ::= variable name
C ::= class name
T ::= thread name
fd ::= a field name
md ::= a method name
f ::= pre-defined functions such as +, -, *, /, etc.
c ::= constants such as 1, 2, true, etc.
","The image presents a scholarly excerpt discussing a concurrent programming model, highlighting the semantics of method invocation in a thread-based system, along with the formal syntax of the SPL (Simple Programming Language) as shown in Fig. 1.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p57.jpg,True,"Here is the code from the image:

```verilog
logic [1:0] [31:0] A; // two-dimensional packed array
A = {'1'b1, '1'b1};   // GOTCHA? assign concatenation to A
A = {'1'b1, 1'b1};    // GOTCHA? assign list of values to A

A[1] = 1'b1; // decimal 1
A[0] = 1'b1; // decimal 1

A[1] = 1'b0   // decimal 0
A[0] = 2'b11; // decimal 3

logic [1:0] [31:0] A;  // two-dimensional packed array
A = {1, 1};           // ERROR, illegal concatenation
A = '{1, 1};          // OK, assign list of values to A
```

The comments explain the issues related to array literals versus concatenations in Verilog/SystemVerilog and demonstrate the correct and incorrect ways to assign values.","
logic [1:0] [31:0] A; // two-dimensional packed array
A = {'1'b1, '1'b1};   // GOTCHA? assign concatenation to A
A = {'1'b1, 1'b1};    // GOTCHA? assign list of values to A

A[1] = 1'b1; // decimal 1
A[0] = 1'b1; // decimal 1

A[1] = 1'b0   // decimal 0
A[0] = 2'b11; // decimal 3

logic [1:0] [31:0] A;  // two-dimensional packed array
A = {1, 1};           // ERROR, illegal concatenation
A = '{1, 1};          // OK, assign list of values to A
","""Common pitfalls in Verilog: Differences between array literals and concatenations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p153.jpg,True,"```verilog
assert always (A -> B);
```

```verilog
cover {A};
```","
assert always (A -> B);


cover {A};
","Caption: ""Discussing Assertions and Functional Coverage in Verilog for RTL Design Verification""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p392.jpg,True,"The image contains Verilog code. Here are the code excerpts from the image:

```verilog
covergroup CrossManual;
ab: coverpoint {sam.a, sam.b}
    { bins a0b0 = {'2'b00};
      bins a1b0 = {'2'b10};
      wildcard bins b1 = {'2'b?1};
    }
endgroup
```

```verilog
class Transaction;
bit [2:0] dst; // Values: 0:7
endclass
Transaction tr;

covergroup CovDst39 (int mid);
coverpoint tr.dst
    {bins lo = {[0:mid-1]};
     bins hi = {[mid:$]};
    }
endgroup

CovDst39 cp;
initial
    cp = new(5); // lo=0:4, hi=5:7
```","
covergroup CrossManual;
ab: coverpoint {sam.a, sam.b}
    { bins a0b0 = {'2'b00};
      bins a1b0 = {'2'b10};
      wildcard bins b1 = {'2'b?1};
    }
endgroup


class Transaction;
bit [2:0] dst; // Values: 0:7
endclass
Transaction tr;

covergroup CovDst39 (int mid);
coverpoint tr.dst
    {bins lo = {[0:mid-1]};
     bins hi = {[mid:$]};
    }
endgroup

CovDst39 cp;
initial
    cp = new(5); // lo=0:4, hi=5:7
","""Defining Functional Coverage and Creating Generic Cover Groups in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p177.jpg,True,"The image shows a fragment of text that discusses Verilog code, specifically addressing object-oriented and multi-threaded programming gotchas. There is also some Verilog code snippet in the image. Here is the code provided:

```verilog
task watchdog (input int irq_num,         // GOTCHA! static storage
               input int max_cycles       // GOTCHA! static storage
              );
  $display(""At %0d: Watchdog started for IRQ[%0d] for %0d cycles"",
           $time, irq_num, max_cycles);
  repeat(max_cycles) @(posedge clock); // delay until max_cycles
                                       // reached
  $display(""Error at %0d: IRQ[%0d] no after %0d cycles"",
           $time, irq_num, max_cycles);
endtask: watchdog
endprogram: test
```

This code demonstrates a gotcha with static storage in Verilog code and how it might lead to incorrect behavior if not handled properly. The text also discusses how to make tasks and functions automatic to avoid this gotcha:

```verilog
task automatic watchdog ( ... // automatic storage
```

Additionally, the text mentions how SystemVerilog allows the `automatic` keyword to be specified as part of the declaration of a module, interface, or program to fix such issues:

```verilog
program automatic test ( ... );
...
task watchdog ( ... // OK, automatic storage
```","
task watchdog (input int irq_num,         // GOTCHA! static storage
               input int max_cycles       // GOTCHA! static storage
              );
  $display(""At %0d: Watchdog started for IRQ[%0d] for %0d cycles"",
           $time, irq_num, max_cycles);
  repeat(max_cycles) @(posedge clock); // delay until max_cycles
                                       // reached
  $display(""Error at %0d: IRQ[%0d] no after %0d cycles"",
           $time, irq_num, max_cycles);
endtask: watchdog
endprogram: test


task automatic watchdog ( ... // automatic storage


program automatic test ( ... );
...
task watchdog ( ... // OK, automatic storage
","""Understanding static storage gotchas in task declarations and the use of the automatic keyword in Verilog and SystemVerilog for re-entrant processes.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p389.jpg,True,"The image contains snippets of code written in C related to Verilog PLI (Programming Language Interface). Here's the code that's visible in the image:

```c
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */

#define HEX 0 /* values of user_data for system task names */
#define ASCII 2

/***********************************************************************
 * checktf routine
 ***********************************************************************/
int PLIbook_DumpMem_checktf(int user_data)
{
    if (tf_nump() != 1)
        if (user_data == HEX)
            tf_error(""Usage error: $dump_mem_hex(<memory_word_select>);"");
        else
            tf_error(""Usage error: $dump_mem_ascii(<memory_word_select>);"");
    return(0);
}

/***********************************************************************
 * misctf routine
 *
 * The misctf application is used to call tf_nodeinfo() at the
 * beginning of simulation, so that the memory allocated by
 * tf_nodeinfo() is only allocated one time for each instance of
 * $dump_mem_??.
 ***********************************************************************/
int PLIbook_DumpMem_misctf(int user_data, int reason)
{
    p_tfnodeinfo node_info; /* pointer to structure for tf_nodeinfo() */
```

This code appears to be part of a tutorial or example related to using TF routines for reading and writing values from a Verilog memory array.","ude ""veriuser.h"" /* IEEE 1364 PLI TF routine library */

#define HEX 0 /* values of user_data for system task names */
#define ASCII 2

/***********************************************************************
 * checktf routine
 ***********************************************************************/
int PLIbook_DumpMem_checktf(int user_data)
{
    if (tf_nump() != 1)
        if (user_data == HEX)
            tf_error(""Usage error: $dump_mem_hex(<memory_word_select>);"");
        else
            tf_error(""Usage error: $dump_mem_ascii(<memory_word_select>);"");
    return(0);
}

/***********************************************************************
 * misctf routine
 *
 * The misctf application is used to call tf_nodeinfo() at the
 * beginning of simulation, so that the memory allocated by
 * tf_nodeinfo() is only allocated one time for each instance of
 * $dump_mem_??.
 ***********************************************************************/
int PLIbook_DumpMem_misctf(int user_data, int reason)
{
    p_tfnodeinfo node_info; /* pointer to structure for tf_nodeinfo() */
","Caption: ""Verilog PLI routine examples for reading memory array values, including checktf and misctf functions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p163.jpg,True,"The image contains Verilog code. Here it is:

First code snippet:
```verilog
reg [31:0] a, b, c;
integer a[0:31], b[0:31], c[0:31]; // arrays of 32 elements
integer i;                          // static loop control variable
initial begin
  for(i=0; i<31; i=i+1) begin
    c[i] = a[i] + b[i];            // OK to reference i inside of loop
  end
  $display(""i is %0d"", i);          // OK to reference i outside of loop
end
```

Second code snippet:
```verilog
reg [31:0] a, b, c;
initial begin
  for (int i=0; i<=31; i=i+1) begin // i is automatic variable
    c[i] = a[i] + b[i];             // OK, i is used inside the loop
  end
  $display(""i is %0d"", i);          // GOTCHA! i is used outside of loop
end
```","
reg [31:0] a, b, c;
integer a[0:31], b[0:31], c[0:31]; // arrays of 32 elements
integer i;                          // static loop control variable
initial begin
  for(i=0; i<31; i=i+1) begin
    c[i] = a[i] + b[i];            // OK to reference i inside of loop
  end
  $display(""i is %0d"", i);          // OK to reference i outside of loop
end


reg [31:0] a, b, c;
initial begin
  for (int i=0; i<=31; i=i+1) begin // i is automatic variable
    c[i] = a[i] + b[i];             // OK, i is used inside the loop
  end
  $display(""i is %0d"", i);          // GOTCHA! i is used outside of loop
end
","""Explanation of loop control variable scope in Verilog and SystemVerilog with code examples that illustrate correct usage within a for loop and a common mistake leading to a syntax error.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p386.jpg,True,"The image contains a code example written in Verilog, which is related to a transaction class and a coverage group for functional coverage analysis in SystemVerilog. Here is the code snippet present in the image:

```verilog
class Transaction;
    rand bit [3:0] kind;
    rand bit [2:0] dst;
endclass

Transaction tr;

covergroup CovDst30;
    kind: coverpoint tr.kind;  // Create cover point kind
    dst: coverpoint tr.dst;    // Create cover point dst
    cross kind, dst;           // Cross kind and dst
endgroup
```","
class Transaction;
    rand bit [3:0] kind;
    rand bit [2:0] dst;
endclass

Transaction tr;

covergroup CovDst30;
    kind: coverpoint tr.kind;  // Create cover point kind
    dst: coverpoint tr.dst;    // Create cover point dst
    cross kind, dst;           // Cross kind and dst
endgroup
",A textbook page explaining Cross Coverage in SystemVerilog with an example code snippet for basic cross coverage using a covergroup.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p43.jpg,True,"This image contains Verilog code examples. One example illustrates a typical program declaration, and its equivalent using the `automatic` storage class. The second example describes how packages should be declared. Here is the code from the image:

Example 1 (Left side):
```
program test;
  int a;       //a is static
  task t (int b);  //b is static
    int c;           //c is static
    ...
  endtask
  initial begin
    logic d;     //d is static
    ...
  end
endprogram
```

Example 1 (Right side):
```
program automatic test;
  int a;       //a is static
  task t (int b);  //b is automatic
    int c;           //c is automatic
    ...
  endtask
  initial begin
    logic d;     //d is automatic
    ...
  end
endprogram
```

Example 2:
```
Packages should be declared as package automatic. Task and function
definitions in a package are often shared between several programs, modules and
interfaces, and therefore should be automatic to avoid problems of sharing
storage between multiple callers. Gotcha 43 on page 96 describes RTL design
problems that can occur when static storage in a package is shared with multiple callers.
```

The text does not provide a specific code example for how `package automatic` is used, possibly because this is part of an explanation about coding guidelines. 

Additionally, there is guidance about what should not be declared as automatic:
```
Modules should not be declared as automatic. Tasks, functions and local variables
in a module that are automatic will not be accessible hierarchically, which limits
the ability to debug design problems. If automatic storage is needed in a module,
such as for a recursively called function, the local variable, task or function
should be explicitly declared as automatic. This both documents the exception,
and permits debug access to the rest of the module.
```

Please note that I cannot provide more context since it appears there is some cutoff text on the right-hand side of the image.","m test;
  int a;       //a is static
  task t (int b);  //b is static
    int c;           //c is static
    ...
  endtask
  initial begin
    logic d;     //d is static
    ...
  end
endprogram

m automatic test;
  int a;       //a is static
  task t (int b);  //b is automatic
    int c;           //c is automatic
    ...
  endtask
  initial begin
    logic d;     //d is automatic
    ...
  end
endprogram

es should be declared as package automatic. Task and function
definitions in a package are often shared between several programs, modules and
interfaces, and therefore should be automatic to avoid problems of sharing
storage between multiple callers. Gotcha 43 on page 96 describes RTL design
problems that can occur when static storage in a package is shared with multiple callers.

s should not be declared as automatic. Tasks, functions and local variables
in a module that are automatic will not be accessible hierarchically, which limits
the ability to debug design problems. If automatic storage is needed in a module,
such as for a recursively called function, the local variable, task or function
should be explicitly declared as automatic. This both documents the exception,
and permits debug access to the rest of the module.
",Verilog guidelines on using automatic storage to avoid static vs automatic variable gotchas.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p407.jpg,True,"The image contains Verilog code. Here it is:

```verilog
property ranged_until(int unsigned low, high, property p, q) ;
  if (low > high) 1'b0 // required k does not exist
  else
    ranged_until_recur(low, high, 0, p, q);
endproperty

property ranged_until_recur(
  local input int unsigned low, high, cnt,
  property p, q
);
  if (cnt == high) q // last chance to satisfy q
  else
    (
      (q and (cnt >= low))
      or
      (p and nexttime ranged_until_recur(low,high,cnt+1,p,q))
    );
endproperty
```

```verilog
property even;
  (nexttime[0] p) and nexttime odd;
endproperty

property odd;
  q and nexttime even;
endproperty
```","
property ranged_until(int unsigned low, high, property p, q) ;
  if (low > high) 1'b0 // required k does not exist
  else
    ranged_until_recur(low, high, 0, p, q);
endproperty

property ranged_until_recur(
  local input int unsigned low, high, cnt,
  property p, q
);
  if (cnt == high) q // last chance to satisfy q
  else
    (
      (q and (cnt >= low))
      or
      (p and nexttime ranged_until_recur(low,high,cnt+1,p,q))
    );
endproperty


property even;
  (nexttime[0] p) and nexttime odd;
endproperty

property odd;
  q and nexttime even;
endproperty
","""Examples of recursive and mutually recursive properties in Verilog for formal verification""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p410.jpg,True,"The image contains two snippets of Verilog HDL (Hardware Description Language) code. Here they are:

Snippet 1:
```verilog
always @(a or b)
    $my_strobe(sum);
```

Snippet 2:
```verilog
always @(a or b)
    sum = a + b;
```

The text describes the behavior and synchronization of PLI applications with Verilog events, focusing on ""read-write synchronization"" and ""read-only synchronization"" in the context of simulation time steps. The code snippets illustrate Verilog's parallel (concurrent) activity using the `always` construct to specify that the provided block of code should be executed whenever there is a change in the signals `a` or `b`.","
always @(a or b)
    $my_strobe(sum);


always @(a or b)
    sum = a + b;
",Verilog Programming Language Interface (PLI) synchronization mechanisms and race conditions with example code snippet.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p361.jpg,True,"Here is the code present in the image:

```verilog
1 bit active[tagType];
2 always @(posedge clk)
3     if ($sampled(start)) begin
4         a_no_tag_reuse: assert final (
5             !active.exists($sampled(tagIn))
6         );
7         active[$sampled(tagIn)] <= 1'b1;
8     end
9     else if ($sampled(complete)) begin
10         a_comp_tag_ok: assert final (
11             active.exists($sampled(tagOut))
12         );
13         active.delete($sampled(tagOut));
14     end
```

This is a snippet of Verilog code that seems to be handling tag protocol control checks, managing the active status of tags based upon sampled signals of `start` and `complete`. The code includes the use of assertions to ensure that tags are not reused and that tags are correctly managed when a process is complete.","
1 bit active[tagType];
2 always @(posedge clk)
3     if ($sampled(start)) begin
4         a_no_tag_reuse: assert final (
5             !active.exists($sampled(tagIn))
6         );
7         active[$sampled(tagIn)] <= 1'b1;
8     end
9     else if ($sampled(complete)) begin
10         a_comp_tag_ok: assert final (
11             active.exists($sampled(tagOut))
12         );
13         active.delete($sampled(tagOut));
14     end
",Verilog code implementing a tag protocol control check using associative arrays and assertions.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p188.jpg,True,"The image contains examples of Verilog code. Here are the code snippets:

First example:
```verilog
program automatic test (...);
    initial begin
        fork
            test1_task(...);
            test2_task(...);
        join_none
    end // GOTCHA! simulation might exit before tasks finish
endprogram
```

Second example:
```verilog
program automatic test (...);
    initial begin
        fork
            test1_task(...);
            test2_task(...);
        join_none
        wait fork; // waits for all spawned processes to complete
    end // OK, can't get here until tasks finish
endprogram
```","
program automatic test (...);
    initial begin
        fork
            test1_task(...);
            test2_task(...);
        join_none
    end // GOTCHA! simulation might exit before tasks finish
endprogram


program automatic test (...);
    initial begin
        fork
            test1_task(...);
            test2_task(...);
        join_none
        wait fork; // waits for all spawned processes to complete
    end // OK, can't get here until tasks finish
endprogram
","""Verilog Gotchas: Avoiding premature simulation exit with proper task synchronization in parallel threads.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p375.jpg,True,"The image contains Verilog code. Here is the code transcribed from the image:

1.
```verilog
sequence s2(logic start, b[4]);
  logic l_a = 1’b0, l_b[4] = b;
  dataType l_data;
  @(posedge clk)
    start ##1 ...
endsequence
```

2.
```verilog
sequence s2_v2(logic start, b[4]);
  logic l_a, l_b[4];
  dataType l_data;
  @(posedge clk)
    (start, l_a = 1’b0, l_b[4] = b) ##1 ...
endsequence
```

3.
```verilog
sequence s2_v2(logic start, b[4]);
  logic l_a, l_b[4];
  dataType l_data;
```

Note: The image contains some descriptive text around the code that explains declaration assignments and their use in sequences in SystemVerilog. Some of the code lines seem to be incomplete, possibly due to the context being provided by the surrounding text. Additionally, there's a small footnote at the bottom, but it doesn't contain any code.","
sequence s2(logic start, b[4]);
  logic l_a = 1’b0, l_b[4] = b;
  dataType l_data;
  @(posedge clk)
    start ##1 ...
endsequence


sequence s2_v2(logic start, b[4]);
  logic l_a, l_b[4];
  dataType l_data;
  @(posedge clk)
    (start, l_a = 1’b0, l_b[4] = b) ##1 ...
endsequence


sequence s2_v2(logic start, b[4]);
  logic l_a, l_b[4];
  dataType l_data;
","The image shows a textbook page discussing the declaration of body local variables in SystemVerilog, including examples of declaration assignments in sequence blocks.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p379.jpg,True,"```verilog
covergroup CovLen16;
  len: coverpoint (p.hdr_len + p.payload_len + 5'b0)
    {
      bins len[] = {[0:23]}; // Bug?? See below
    }
endgroup
```","
covergroup CovLen16;
  len: coverpoint (p.hdr_len + p.payload_len + 5'b0)
    {
      bins len[] = {[0:23]}; // Bug?? See below
    }
endgroup
","Caption: ""Discussion on the use of user-defined bins in Verilog for accurate and efficient data sampling coverage, illustrating how custom bin definitions can detect bugs in verification tests.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p129.jpg,True,"Here is the Verilog code present in the image:

```verilog
sequence $ab;
    a ##2 b;
endsequence

property ab;
    @(posedge clk) z |-> $ab;
endproperty

base: assert property (ab) else abFail;
      cover property (ab) else abPass;

task abFail;
    $display($stime,"" \t property ab FAIL"");
endtask

task abPass;
    $display($stime,"" \t property ab PASS"");
endtask
```

The other text in the image is commentary on the usage of the clock delay operator in Verilog.","
sequence $ab;
    a ##2 b;
endsequence

property ab;
    @(posedge clk) z |-> $ab;
endproperty

base: assert property (ab) else abFail;
      cover property (ab) else abPass;

task abFail;
    $display($stime,"" \t property ab FAIL"");
endtask

task abPass;
    $display($stime,"" \t property ab PASS"");
endtask
","""Exploring the Verilog Clock Delay Operator ##m with a focus on the case where m = 0""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p101.jpg,True,"The image contains multiple snippets of Verilog code. Here they are:

```verilog
logic req, gnt;

property pr1 (enb=1'b1, logic pa, logic pb);
    @(posedge clk) enb |-> pa ##2 pb;
endproperty

reqGnt: assert property (pr1(cStart,req,gnt));
```

```verilog
reqGnt: assert property ( pr1 ( .pa(req), .pb(gnt) ));
```

```verilog
reqGnt: assert property ( pr1 ( , .req,gnt));
```

```verilog
property pr1 (int dSize, csig, enb=1'b1, logic pa, logic pb);

logic [dSize:0] Ldata;

@(csig, Ldata=data) enb |-> pa ##2 pb;

endproperty

reqGnt: assert property (pr1('d31,posedge clk,cStart, req, gnt));
```","
logic req, gnt;

property pr1 (enb=1'b1, logic pa, logic pb);
    @(posedge clk) enb |-> pa ##2 pb;
endproperty

reqGnt: assert property (pr1(cStart,req,gnt));


reqGnt: assert property ( pr1 ( .pa(req), .pb(gnt) ));


reqGnt: assert property ( pr1 ( , .req,gnt));


property pr1 (int dSize, csig, enb=1'b1, logic pa, logic pb);

logic [dSize:0] Ldata;

@(csig, Ldata=data) enb |-> pa ##2 pb;

endproperty

reqGnt: assert property (pr1('d31,posedge clk,cStart, req, gnt));
","Caption: ""Examples of formal and actual argument specification in Verilog, demonstrating default value assignment and position-based connections.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p437.jpg,True,"The image contains code snippets. Here is the code written in SystemVerilog (which is an extension of Verilog) as shown on the image:

```verilog
copy.GFC       = this.GFC;
copy.VPI       = this.VPI;
copy.VCI       = this.VCI;
copy.CLP       = this.CLP;
copy.PT        = this.PT;
copy.HEC       = this.HEC;
return copy;
endfunction : copy

// Pack this object's properties into a byte array
function void UNI_cell::pack(output ATMCellType to);
to.uni.GFC     = this.GFC;
to.uni.VPI     = this.VPI;
to.uni.VCI     = this.VCI;
to.uni.CLP     = this.CLP;
to.uni.PT      = this.PT;
to.uni.HEC     = this.HEC;
to.uni.Payload = this.Payload;
endfunction : pack

// Unpack a byte array into this object
function void UNI_cell::unpack(input ATMCellType from);
this.GFC       = from.uni.GFC;
this.VPI       = from.uni.VPI;
this.VCI       = from.uni.VCI;
this.CLP       = from.uni.CLP;
this.PT        = from.uni.PT;
this.HEC       = from.uni.HEC;
this.Payload   = from.uni.Payload;
endfunction : unpack

// Generate a NNI cell from an UNI cell - used in scoreboard
function NNI_cell UNI_cell::to_NNI();
NNI_cell copy;
copy    = new();
copy.VPI       = this.VPI;   // NNI has wider VPI
copy.VCI       = this.VCI;
copy.CLP       = this.CLP;
copy.PT        = this.PT;
copy.HEC       = this.HEC;
copy.Payload   = this.Payload;
return copy;
endfunction : to_NNI
```

These code snippets seem to be related to operations performed on telecommunication data structures representing ATM (Asynchronous Transfer Mode) cells for a network interface, where `UNI` seems to stand for User-Network Interface and `NNI` stands for Network-Network Interface. They involve copying properties, packing into a byte array, unpacking from a byte array, and converting between UNI and NNI cell types.","
copy.GFC       = this.GFC;
copy.VPI       = this.VPI;
copy.VCI       = this.VCI;
copy.CLP       = this.CLP;
copy.PT        = this.PT;
copy.HEC       = this.HEC;
return copy;
endfunction : copy

// Pack this object's properties into a byte array
function void UNI_cell::pack(output ATMCellType to);
to.uni.GFC     = this.GFC;
to.uni.VPI     = this.VPI;
to.uni.VCI     = this.VCI;
to.uni.CLP     = this.CLP;
to.uni.PT      = this.PT;
to.uni.HEC     = this.HEC;
to.uni.Payload = this.Payload;
endfunction : pack

// Unpack a byte array into this object
function void UNI_cell::unpack(input ATMCellType from);
this.GFC       = from.uni.GFC;
this.VPI       = from.uni.VPI;
this.VCI       = from.uni.VCI;
this.CLP       = from.uni.CLP;
this.PT        = from.uni.PT;
this.HEC       = from.uni.HEC;
this.Payload   = from.uni.Payload;
endfunction : unpack

// Generate a NNI cell from an UNI cell - used in scoreboard
function NNI_cell UNI_cell::to_NNI();
NNI_cell copy;
copy    = new();
copy.VPI       = this.VPI;   // NNI has wider VPI
copy.VCI       = this.VCI;
copy.CLP       = this.CLP;
copy.PT        = this.PT;
copy.HEC       = this.HEC;
copy.Payload   = this.Payload;
return copy;
endfunction : to_NNI
","Caption: ""Verilog code demonstrating functions for copying, packing, and unpacking data structures in a SystemVerilog testbench environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p94.jpg,True,"The image contains some Verilog code. Here it is:

```verilog
always @(state) begin  // next state decoder
  unique case (state)
    3'b001: nstate = 3'b010;
    3'b010: nstate = 3'b100;
    3'b100: nstate = 3'b001;
  endcase
end
```","
always @(state) begin  // next state decoder
  unique case (state)
    3'b001: nstate = 3'b010;
    3'b010: nstate = 3'b100;
    3'b100: nstate = 3'b001;
  endcase
end
","""Exploring unique and priority case constructs in SystemVerilog for synthesis and simulation with an example of unique case usage.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p190.jpg,True,"The image contains Verilog code associated with hardware design and assertion checks. Here is the code from the image:

```verilog
module dmux4 (o, sel, i0, i1, i2, i3);
    parameter WIDTH = 1;
    input [WIDTH-1:0] i0, i1, i2, i3; // input data
    input [3:0] sel;                   // select signal
    output [WIDTH-1:0] o;              // output

    always @(i0 or i1 or i2 or i3 or sel) begin
    
    // procedural clocked assertion
    if (`TOP.reset_n) 
        assert property (@(posedge `TOP.clk) ($countones(sel) == 1))
        else $error (""dmux4 select line one-hot violation at %m"");
    
    casez (1'b1) // synopsys parallel_case
        sel [0] : o = i0;
        sel [1] : o = i1;
        sel [2] : o = i2;
        sel [3] : o = i3;
    endcase
end
endmodule
```

This module is a multiplexer that selects one of the four input signals (i0, i1, i2, i3) based on the select signal (`sel`). Additionally, it includes a procedural assertion to check that only one select line is active at any given time (one-hot encoding). If this condition is not met, an error is reported. The `parameter WIDTH` allows definition of the bit-width of the inputs and the output.","
module dmux4 (o, sel, i0, i1, i2, i3);
    parameter WIDTH = 1;
    input [WIDTH-1:0] i0, i1, i2, i3; // input data
    input [3:0] sel;                   // select signal
    output [WIDTH-1:0] o;              // output

    always @(i0 or i1 or i2 or i3 or sel) begin
    
    // procedural clocked assertion
    if (`TOP.reset_n) 
        assert property (@(posedge `TOP.clk) ($countones(sel) == 1))
        else $error (""dmux4 select line one-hot violation at %m"");
    
    casez (1'b1) // synopsys parallel_case
        sel [0] : o = i0;
        sel [1] : o = i1;
        sel [2] : o = i2;
        sel [3] : o = i3;
    endcase
end
endmodule
",Verilog code for one-hot multiplexer check using assertions and a diagram indicating a one-hot violation condition.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p351.jpg,True,"The image contains Verilog code, which I will write out for you:

```verilog
class TestRegistry;
  static TestBase registry[string];

  static function void register(string name, TestBase t);
    registry[name] = t;
  endfunction // register

  static function TestBase get_test();
    string name;
    if (!$value$plusargs(""TESTNAME=%s"", name))
      $display(""ERROR: No +TESTNAME switch found"");
    return registry[name];
  endfunction
endclass // TestRegistry

// Repeat for each test
class TestSimple extends TestBase;

  function new();
    env = new();
    TestRegistry::register(""TestSimple"", this);
  endfunction

  virtual task run_test();
    $display(""%m"");
    env.gen_config();
    env.build();
    env.run();
    env.wrap_up();
  endtask
endclass

TestSimple TestSimple_handle = new(); // Needed for each class
```

This code is from a section discussing ""Advanced OOP and Testbench Guidelines."" It shows a sample Verilog test registry class and a simple test class that extends a base class for use in a testbench environment.","
class TestRegistry;
  static TestBase registry[string];

  static function void register(string name, TestBase t);
    registry[name] = t;
  endfunction // register

  static function TestBase get_test();
    string name;
    if (!$value$plusargs(""TESTNAME=%s"", name))
      $display(""ERROR: No +TESTNAME switch found"");
    return registry[name];
  endfunction
endclass // TestRegistry

// Repeat for each test
class TestSimple extends TestBase;

  function new();
    env = new();
    TestRegistry::register(""TestSimple"", this);
  endfunction

  virtual task run_test();
    $display(""%m"");
    env.gen_config();
    env.build();
    env.run();
    env.wrap_up();
  endtask
endclass

TestSimple TestSimple_handle = new(); // Needed for each class
",Verilog code samples for a test registry class and extending a test base class for verification.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p345.jpg,True,"The image contains text related to object-oriented programming concepts and a sample code in Verilog. Here is the code snippet from the image:

```verilog
class Print;
  static bit [31:0] error_count = 0, error_limit = -1;
  string class_name, instance_name;

  function new(input string class_name, instance_name);
    this.class_name    = class_name;
    this.instance_name = instance_name;
  endfunction

  function void error(input string ID, input string message);
    $display(""%0t %m [%s-%s] [%s] %s"",
              $realtime, class_name, instance_name, ID, message);
    if (++error_count >= error_limit) begin
      $display(""FATAL: Maximum error limit reached"");
      $finish;
    end
  endfunction
endclass
```

This Verilog code defines a `Print` class with static variables `error_count` and `error_limit`, and instance variables `class_name` and `instance_name`. It includes a constructor `new` and an `error` function to display messages and check if the maximum error limit is reached, in which case it will terminate the simulation with a `FATAL` message.","
class Print;
  static bit [31:0] error_count = 0, error_limit = -1;
  string class_name, instance_name;

  function new(input string class_name, instance_name);
    this.class_name    = class_name;
    this.instance_name = instance_name;
  endfunction

  function void error(input string ID, input string message);
    $display(""%0t %m [%s-%s] [%s] %s"",
              $realtime, class_name, instance_name, ID, message);
    if (++error_count >= error_limit) begin
      $display(""FATAL: Maximum error limit reached"");
      $finish;
    end
  endfunction
endclass
","""Sample Verilog code of a Print class with functions for error handling and message printing""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p349.jpg,True,"Below is the Verilog code extracted from the image:

```verilog
always @(edge clk) begin
  if (clk)
    a <= a_in;
  else
    b <= a_in;
end

always @(posedge clk iff en) or negedge rst_n) begin
  if (!rst_n)
    a <= 0;
  else if (!en) $error(""en expected"");
  else
    a <= d_in;
end

always @(posedge clk iff en) or negedge rst_n) begin
  if (!en) $error(""en expected"");
  else
    a <= d_in;
end

always @(posedge clk) begin
  a <= d_in;
  @(negedge clk) b <= d_in;
end

always @(ev iff en) begin
  a <= d_in;
end

always @(CLK or negedge rst_n) begin
  if (!rst_n)
    a <= 0;
  else
    a <= a_in;
end

always @(CLK or (ev iff en)) begin
  a <= a_in;
end

logic clk, load;
logic [w] d_in, d_out;
logic [D][w] sh;
```

There are some typographical issues within the code from the image which may lead to syntax errors such as missing parenthesis. Also, it appears to be a snapshot from a book or document covering Procedural Concurrent Assertions in Verilog. Please ensure to verify and correct the code using appropriate resources or contexts when using it for any practical applications.","
always @(edge clk) begin
  if (clk)
    a <= a_in;
  else
    b <= a_in;
end

always @(posedge clk iff en) or negedge rst_n) begin
  if (!rst_n)
    a <= 0;
  else if (!en) $error(""en expected"");
  else
    a <= d_in;
end

always @(posedge clk iff en) or negedge rst_n) begin
  if (!en) $error(""en expected"");
  else
    a <= d_in;
end

always @(posedge clk) begin
  a <= d_in;
  @(negedge clk) b <= d_in;
end

always @(ev iff en) begin
  a <= d_in;
end

always @(CLK or negedge rst_n) begin
  if (!rst_n)
    a <= 0;
  else
    a <= a_in;
end

always @(CLK or (ev iff en)) begin
  a <= a_in;
end

logic clk, load;
logic [w] d_in, d_out;
logic [D][w] sh;
","Caption: ""Examples of Verilog procedural concurrent assertions and a snippet describing a shift register implementation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p80.jpg,True,"The image contains Verilog code. Below is the code snippet from the image:

```verilog
always @(posedge clock) begin // NOT a shift register
    q1 = d; // GOTCHA! load d into q1 without clock-to-Q delay
    q2 = q1; // load q1 into q2
end
```

This code is an example used to illustrate a common 'gotcha' in Verilog coding, particularly the incorrect use of blocking assignments in sequential procedural blocks.","
always @(posedge clock) begin // NOT a shift register
    q1 = d; // GOTCHA! load d into q1 without clock-to-Q delay
    q2 = q1; // load q1 into q2
end
","""Common Verilog Gotcha: Misuse of Blocking Assignments in Sequential Procedural Blocks""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p184.jpg,True,"The code snippet provided in the image is Verilog code, and it is as follows:

```verilog
assert_never invalid (clk, reset_n, ^expr[3:0] === 1'bX);
```","
assert_never invalid (clk, reset_n, ^expr[3:0] === 1'bX);
","Caption: ""Verilog Assertion Pattern for Detecting Unconnected or Undriven Signals in RTL Designs""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p438.jpg,True,"```verilog
module chip (...)
    ...
    scientific_alu u1 (a, b, opcode, result, excep, err);
    ...
endmodule
```","
module chip (...)
    ...
    scientific_alu u1 (a, b, opcode, result, excep, err);
    ...
endmodule
","Caption: ""Excerpt from a technical document discussing the interfacing of C models with Verilog using TF (task functions) routines, showcasing an example Verilog module for a scientific ALU.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p115.jpg,True,"```verilog
property checkiack;
  @(posedge clk) $rose(intr) |=> $rose(iack);
endproperty
```","
property checkiack;
  @(posedge clk) $rose(intr) |=> $rose(iack);
endproperty
","Caption: ""Understanding the $rose construct in Verilog for edge detection in property/sequence and its application in signal change detection with timing diagrams illustrating pass and fail cases.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p353.jpg,True,"```verilog
virtual class svm_object;
  // Empty class
endclass
```","
virtual class svm_object;
  // Empty class
endclass
","Caption: ""Explanation of a class factory concept in SystemVerilog for efficient testbench design, including an example of a common SVM (SystemVerilog Methodology) base class.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p348.jpg,True,"The image contains text that explains how to write 2-state values using the TF library in Verilog PLI (Programming Language Interface). The TF library contains routines to write C data types as 2-state values onto system task/function arguments. The text also includes some Verilog code examples. Here is the code from the image:

```c
void tf_putp(n, value)
int n;      /* index number of a system task/function arg, or 0. */
int value;  /* a 32-bit integer value. */

int result;
tf_putp(0, result);
```

```c
void tf_putlongp(n, lowvalue, highvalue)
int n;          /* index number of a system task/function argument, or 0. */
int lowvalue;   /* lower (right-most) 32-bits of a 64-bit integer. */
int highvalue;  /* upper (left-most) 32-bits of a 64-bit integer. */

int high_bits, low_bits;
tf_putlongp(2, low_bits, high_bits);
```

```c
void tf_putrealp(n, value)
int n;            /* index number of a system task/function argument, or 0. */
double value;     /* a double precision real number. */

double c_value;
tf_putrealp(3, c_value);
```","tf_putp(n, value)
int n;      /* index number of a system task/function arg, or 0. */
int value;  /* a 32-bit integer value. */

int result;
tf_putp(0, result);

tf_putlongp(n, lowvalue, highvalue)
int n;          /* index number of a system task/function argument, or 0. */
int lowvalue;   /* lower (right-most) 32-bits of a 64-bit integer. */
int highvalue;  /* upper (left-most) 32-bits of a 64-bit integer. */

int high_bits, low_bits;
tf_putlongp(2, low_bits, high_bits);

tf_putrealp(n, value)
int n;            /* index number of a system task/function argument, or 0. */
double value;     /* a double precision real number. */

double c_value;
tf_putrealp(3, c_value);
","""Verilog PLI Handbook excerpt showing functions for writing 2-state values in Verilog simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p192.jpg,True,"```verilog
property legal_graycode (code);
    @(posedge clk) ($countones($past(code) ^ code)<=1);
endproperty
assert legal_graycode(async_ptr);
```","
property legal_graycode (code);
    @(posedge clk) ($countones($past(code) ^ code)<=1);
endproperty
assert legal_graycode(async_ptr);
","""SystemVerilog assertion for gray-code encoding and discussion on set patterns in RTL design""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p96.jpg,True,"The image contains Verilog code. Here it is:

```verilog
always_comb begin
    unique if (sel == 2'b00) y = a;
    else if (sel == 2'b01) y = b; // will get simulation warning
    else if (sel == 2'b01) y = c; // will get simulation warning
    else if (sel == 2'b11) y = d;
end

always_comb begin
    unique case (sel)
        2'b00: y = a;
        2'b01: y = b;  // will get simulation warning
        2'b01: y = c;  // will get simulation warning
        2'b11: y = d;
    endcase
end
```

The text below the code explains that the `unique` decision modifier requires simulators to report a warning if two or more decision selection expressions are true at the same time. It is emphasized not to ignore the simulation warnings generated by using `unique`, as they indicate there is a coding issue. The text also references additional examples in other sections of what seems to be a book or document.","
always_comb begin
    unique if (sel == 2'b00) y = a;
    else if (sel == 2'b01) y = b; // will get simulation warning
    else if (sel == 2'b01) y = c; // will get simulation warning
    else if (sel == 2'b11) y = d;
end

always_comb begin
    unique case (sel)
        2'b00: y = a;
        2'b01: y = b;  // will get simulation warning
        2'b01: y = c;  // will get simulation warning
        2'b11: y = d;
    endcase
end
","""Understanding Verilog's 'unique' construct to prevent simulation ambiguity.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p439.jpg,True,"The image contains Verilog code. Here is the code extracted from the image:

```verilog
parameter N = 4;
property path_cover(inIdx, outIdx, sourceId, destId);
    @(posedge clkIn)
        (startIn[inIdx] && sourceId == dataIn[inIdx]) ##
        (destId == dataIn[inIdx])
    @(posedge clkOut)
        (startOut[outIdx] && dataOut[outIdx] == sourceId) ##
        (dataOut[outIdx] == destId);
endproperty

generate
for (genvar pIn = 0; pIn < N; pIn++) begin : PORT_IN
    for (genvar pOut = 0; pOut < N; pOut++) begin : PORT_OUT
        for (genvar sId = 0; sId < 256; sId++) begin : SOURCE_ID
            for (genvar dId = 0; dId < 256; dId++) begin : DEST_ID
                cover_path:
                    cover property(path_cover(pIn, pOut, sId, dId));
            end
        end
    end
end
endgenerate
```

The provided Verilog code defines a parameter `N`, a `property` named `path_cover`, and utilizes generate loops to instantiate the property for various combinations of input and output indices, source identifiers, and destination identifiers.","
parameter N = 4;
property path_cover(inIdx, outIdx, sourceId, destId);
    @(posedge clkIn)
        (startIn[inIdx] && sourceId == dataIn[inIdx]) ##
        (destId == dataIn[inIdx])
    @(posedge clkOut)
        (startOut[outIdx] && dataOut[outIdx] == sourceId) ##
        (dataOut[outIdx] == destId);
endproperty

generate
for (genvar pIn = 0; pIn < N; pIn++) begin : PORT_IN
    for (genvar pOut = 0; pOut < N; pOut++) begin : PORT_OUT
        for (genvar sId = 0; sId < 256; sId++) begin : SOURCE_ID
            for (genvar dId = 0; dId < 256; dId++) begin : DEST_ID
                cover_path:
                    cover property(path_cover(pIn, pOut, sId, dId));
            end
        end
    end
end
endgenerate
",Figure 18.2: Example of using Verilog generate loops for coverage testing in a network switch scenario.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p435.jpg,True,"The image contains Verilog code related to the definition of an ATM cell type and a class definition for a UNI cell in a testbench. Here is the code as it appears in the image:

Sample 11.15 ATMCelIType
```verilog
typedef union packed {
  uniType uni;
  nniType nni;
  bit [0:52] [7:0] Mem;
} ATMCellType;
```

Sample 11.16 UNI_cell definition
```verilog
class UNI_cell extends BaseTr;
  // Physical fields
  rand bit      [3:0]   GFC;
  rand bit      [7:0]   VPI;
  rand bit      [15:0]  VCI;
  rand bit              CLP;
  rand bit      [2:0]   PT;
  rand bit      [7:0]   HEC;
  rand bit [0:47] [7:0] Payload;

  // Meta-data fields
  static bit [0:255] syndrome;
  static bit syndrome_not_generated = 1;

  extern function new();
  extern function void post_randomize();
  extern virtual function bit compare(input BaseTr to);
  extern virtual function void display(input string prefix="""");
  extern virtual function BaseTr copy(input BaseTr to=null);
  extern virtual function void pack(output ATMCellType to);
  extern virtual function void unpack(input ATMCellType from);
  extern function NNI_cell to_NNI();
  extern function void generate_syndrome();
  extern function bit [7:0] hec (bit [31:0] hdr);
endclass : UNI_cell
```","
typedef union packed {
  uniType uni;
  nniType nni;
  bit [0:52] [7:0] Mem;
} ATMCellType;


class UNI_cell extends BaseTr;
  // Physical fields
  rand bit      [3:0]   GFC;
  rand bit      [7:0]   VPI;
  rand bit      [15:0]  VCI;
  rand bit              CLP;
  rand bit      [2:0]   PT;
  rand bit      [7:0]   HEC;
  rand bit [0:47] [7:0] Payload;

  // Meta-data fields
  static bit [0:255] syndrome;
  static bit syndrome_not_generated = 1;

  extern function new();
  extern function void post_randomize();
  extern virtual function bit compare(input BaseTr to);
  extern virtual function void display(input string prefix="""");
  extern virtual function BaseTr copy(input BaseTr to=null);
  extern virtual function void pack(output ATMCellType to);
  extern virtual function void unpack(input ATMCellType from);
  extern function NNI_cell to_NNI();
  extern function void generate_syndrome();
  extern function bit [7:0] hec (bit [31:0] hdr);
endclass : UNI_cell
","Caption: ""Verilog code examples showing a union type definition for an ATM cell and a class definition for a UNI cell with physical and meta-data fields.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p103.jpg,True,"The image appears to contain excerpts of Verilog code within a document. Here is the code present in the image:

```verilog
sequence sdack_;
  ldack [*7];
endsequence

sequence soe_;
  $fell (oe_) ##1 (loe [*8]) ;
endsequence

property pwn;
  @(posedge clk) disable iff (!reset) $fell(bMode) |=> sdack_within_soe_;
endproperty
```

Note: The text in the image also includes simulation command lines and explanation about the ""disable iff"" operator, but the only Verilog code distinctively formatted is the one provided above.","
sequence sdack_;
  ldack [*7];
endsequence

sequence soe_;
  $fell (oe_) ##1 (loe [*8]) ;
endsequence

property pwn;
  @(posedge clk) disable iff (!reset) $fell(bMode) |=> sdack_within_soe_;
endproperty
","Caption: ""Explanation and example of the Verilog 'disable iff' operator in assertion properties, demonstrating how to conditionally disable assertion checking.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p421.jpg,True,"```verilog
interface risc_spm_if (input bit clk);

    bit rst;
    bit [7:0] data_out;
    logic [7:0] address;
    logic [7:0] data_in;
    logic write;
    modport DUT (input clk, data_out,
                 output address, data_in, write);

endinterface
```","
interface risc_spm_if (input bit clk);

    bit rst;
    bit [7:0] data_out;
    logic [7:0] address;
    logic [7:0] data_in;
    logic write;
    modport DUT (input clk, data_out,
                 output address, data_in, write);

endinterface
",A Verilog interface definition for a simple port memory (spm) with instructions to modify it for a parameterized address width.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p117.jpg,True,"The image contains the following Verilog code within a text about using `$rose` and `$fell` in procedural blocks:

```verilog
property checkiack;
@(posedge clk) intr |=> $rose(iack);
endproperty
aP: assert property (checkiack);
```

This code is a part of a discussion on edge detection in assertions within Verilog procedural blocks.","
property checkiack;
@(posedge clk) intr |=> $rose(iack);
endproperty
aP: assert property (checkiack);
","Caption: ""Understanding the use of $rose and $fell in Verilog assertions for edge detection in procedural blocks, with example code and timing diagram.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p186.jpg,True,"```verilog
`ifdef X_DETECTION

always @(posedge clk) begin
  if (reset_n)
    x_prob: assert(!($isunknown({req,tras_start,addr,burst,we}))) else
      $error(""undriven cpu input signal PC=%h trans_start=%h addr=%h burst=%h we=%h"",
             req, tras_start, addr, burst, we);
end

`endif
```","
`ifdef X_DETECTION

always @(posedge clk) begin
  if (reset_n)
    x_prob: assert(!($isunknown({req,tras_start,addr,burst,we}))) else
      $error(""undriven cpu input signal PC=%h trans_start=%h addr=%h burst=%h we=%h"",
             req, tras_start, addr, burst, we);
end

`endif
","""Example of a SystemVerilog assertion to check for unknown values in multiple signals with X-detection directive.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p82.jpg,True,"```verilog
always @(posedge clk)
  if (!rstn) clk_divided2 <= 0;
  else clk_divided2 <= ~clk_divided2;  // GOTCHA!

always @(posedge clk)
  if (!rstn) out1 <= 0;
  else out1 <= in1;                    // delay update to after delta

always @(posedge clk_divided2)
  if (!rstn) out2 <= 0;
  else out2 <= out1;                   // race condition with out1
```","
always @(posedge clk)
  if (!rstn) clk_divided2 <= 0;
  else clk_divided2 <= ~clk_divided2;  // GOTCHA!

always @(posedge clk)
  if (!rstn) out1 <= 0;
  else out1 <= in1;                    // delay update to after delta

always @(posedge clk_divided2)
  if (!rstn) out2 <= 0;
  else out2 <= out1;                   // race condition with out1
","""Page excerpt on the potential pitfalls of using nonblocking assignments in sequential logic for RTL modeling in Verilog, with example code illustrating race condition issues.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p347.jpg,True,"The image contains a snippet of Verilog code presented as an example within a book or a document discussing advanced object-oriented programming and testbench guidelines in the context of hardware verification language SystemVerilog. Here is the code from the image:

```verilog
class Xactor;
  task run();
    Print::error(""NYI"", ""This Xactor is not yet implemented"");
  endtask
endclass
```

The code demonstrates a static method call to a `Print` class method called `error`, indicating a task that has not yet been implemented.","
class Xactor;
  task run();
    Print::error(""NYI"", ""This Xactor is not yet implemented"");
  endtask
endclass
","""Exploring Advanced OOP and Testbench Guidelines: Singleton Class and Configuration Database in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p363.jpg,True,"```verilog
bit active[0:MAX_TAG];
initial
  active <= '0;
always @(posedge clk)
  if ($sampled(start))
    active[$sampled(tagIn)] <= 1'b1;
  else if ($sampled(complete))
    active[$sampled(tagOut)] <= 1'b0;
a_no_tag_reuse: assert property (start |-> !active[tagIn]);
a_comp_tag_ok: assert property (complete |-> active[tagIn]);
```","
bit active[0:MAX_TAG];
initial
  active <= '0;
always @(posedge clk)
  if ($sampled(start))
    active[$sampled(tagIn)] <= 1'b1;
  else if ($sampled(complete))
    active[$sampled(tagOut)] <= 1'b0;
a_no_tag_reuse: assert property (start |-> !active[tagIn]);
a_comp_tag_ok: assert property (complete |-> active[tagIn]);
","Caption: ""Example of Verilog code implementing a tag protocol control check using non-associative arrays and concurrent assertions for formal verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p374.jpg,True,"```verilog
typedef struct t_tfnodeinfo
{
    short node_type;
    short padding;
    union
    {
        struct t_vecval *vecval_p;
        struct t_strengthval *strengthval_p;
        char *memoryval_p;
        double *real_val_p;
    } node_value;
    char *node_symbol;
    int node_ngrcroups;
    int node_vec_size;
    int node_sign;
    int node_ms_index;
    int node_ls_index;
    int node_mem_size;
    int node_lhs_element;
    int node_rhs_element;
    int *node_handle;
} s_tfnodeinfo, *p_tfnodeinfo;
```","
typedef struct t_tfnodeinfo
{
    short node_type;
    short padding;
    union
    {
        struct t_vecval *vecval_p;
        struct t_strengthval *strengthval_p;
        char *memoryval_p;
        double *real_val_p;
    } node_value;
    char *node_symbol;
    int node_ngrcroups;
    int node_vec_size;
    int node_sign;
    int node_ms_index;
    int node_ls_index;
    int node_mem_size;
    int node_lhs_element;
    int node_rhs_element;
    int *node_handle;
} s_tfnodeinfo, *p_tfnodeinfo;
","Caption: ""Excerpt from The Verilog PLI Handbook, detailing the tf_nodeinfo() routine and the s_tfnodeinfo structure used in Verilog simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p409.jpg,True,"The image contains a snippet of Verilog code. Here's the code written in the image:

```verilog
interface x_if (input logic clk);
  logic [7:0] din, dout;
  logic reset_l, load;

  clocking cb @(posedge clk);
    output din, load;
    input dout;
  endclocking

  always @cb
    $strobe(""@%0t: %m: out=%0d, in=%0d, ld=%0d, r=%0d"", $time, dout, din, load, reset_l);

modport DUT (input clk, din, reset_l, load,
             output dout);

modport TB (clocking cb, output reset_l);
endinterface
```

This code defines a Verilog interface called `x_if` that is intended for use with an 8-bit counter. The interface includes input and output signals, a clocking block, and a `modport` for defining the interface's usage within different modules (DUT and TB). An `always` procedural block is used to print signal values whenever the clock edge occurs in the `clocking` block.","
interface x_if (input logic clk);
  logic [7:0] din, dout;
  logic reset_l, load;

  clocking cb @(posedge clk);
    output din, load;
    input dout;
  endclocking

  always @cb
    $strobe(""@%0t: %m: out=%0d, in=%0d, ld=%0d, r=%0d"", $time, dout, din, load, reset_l);

modport DUT (input clk, din, reset_l, load,
             output dout);

modport TB (clocking cb, output reset_l);
endinterface
","""Verilog interface example for an 8-bit counter used in mesh design configurations with virtual interfaces.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p405.jpg,True,"The image contains the following Verilog code:

```verilog
property my_always (property p) ;
  (nexttime[0] p)
  and
  nexttime my_always(p) ;
endproperty
```","
property my_always (property p) ;
  (nexttime[0] p)
  and
  nexttime my_always(p) ;
endproperty
","Fig. 17.1 Recursive encoding of always in Verilog, demonstrating an example of a recursive property called my_always.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p406.jpg,True,"```c
int PLIbook_ReadVector_miscft(int data, int reason)
{
    FILE *in_file;
    char *file_name;
    if (reason == REASON_ENDOFCOMPILE) { /* time to open vector file */
        if ((in_file = fopen(tf_getcstringp(1), ""r"")) == NULL)
            tf_error(""%sread_test_vector cannot open file %s"",
                     tf_getcstringp(1));
        tf_setworkarea((char*)in_file); /* save file pointer in workarea */
    }
    if (reason == REASON_FINISH) { /* time to close vector file */
        in_file = (FILE*)tf_getworkarea(); /* retrieve file pointer */
        fclose(in_file);
    }
    return(0);
}
```","LIbook_ReadVector_miscft(int data, int reason)
{
    FILE *in_file;
    char *file_name;
    if (reason == REASON_ENDOFCOMPILE) { /* time to open vector file */
        if ((in_file = fopen(tf_getcstringp(1), ""r"")) == NULL)
            tf_error(""%sread_test_vector cannot open file %s"",
                     tf_getcstringp(1));
        tf_setworkarea((char*)in_file); /* save file pointer in workarea */
    }
    if (reason == REASON_FINISH) { /* time to close vector file */
        in_file = (FILE*)tf_getworkarea(); /* retrieve file pointer */
        fclose(in_file);
    }
    return(0);
}
","Caption: ""Verilog Programming Language Interface (PLI) example with misctf callback function showing the use of the 'reason' argument to manage file operations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p411.jpg,True,"```verilog
typedef bit [0:$clog2(MAX_OUTSTANDING)] counterType;
property p_fifo_data_check_recur(
  local input dataType data,
  local input counterType numAhead
);
  //##1 complete[-1]
  |->
    if (numAhead == 0)
      dataOut == data;
    else
      p_fifo_data_check_recur(data, numAhead--);
endproperty

property p_fifo_all_checks_recur(
  local input counterType outstanding
);
  (start || complete)[-1]
  |->
    (
      (1'b1, outstanding += start - complete)
      |=> p_fifo_all_checks_recur(outstanding)
    )
and
    if (start) (
      (!complete && outstanding < MAX_OUTSTANDING)
        and p_fifo_data_check_recur(dataIn, outstanding)
    ) else (// complete
      !start && outstanding > 0
    );
endproperty
initial
  a_fifo_all_checks: assert property (
    p_fifo_all_checks_recur('0)
  );
```

This image contains Verilog code that defines two recursive properties within a system that seems to be handling a FIFO (First In, First Out) data checking protocol. The properties are meant to recursively check all FIFO protocol checks by using only local variables.","
typedef bit [0:$clog2(MAX_OUTSTANDING)] counterType;
property p_fifo_data_check_recur(
  local input dataType data,
  local input counterType numAhead
);
  //##1 complete[-1]
  |->
    if (numAhead == 0)
      dataOut == data;
    else
      p_fifo_data_check_recur(data, numAhead--);
endproperty

property p_fifo_all_checks_recur(
  local input counterType outstanding
);
  (start || complete)[-1]
  |->
    (
      (1'b1, outstanding += start - complete)
      |=> p_fifo_all_checks_recur(outstanding)
    )
and
    if (start) (
      (!complete && outstanding < MAX_OUTSTANDING)
        and p_fifo_data_check_recur(dataIn, outstanding)
    ) else (// complete
      !start && outstanding > 0
    );
endproperty
initial
  a_fifo_all_checks: assert property (
    p_fifo_all_checks_recur('0)
  );
",Verilog code for recursive property checks of a FIFO protocol.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p288.jpg,True,"The image contains two sections of Verilog code. Here are both sections transcribed:

First section of code (level 2 decode):
```verilog
// The Level 2 decode, which requires 4 decoders, fully utilized:
wire [16*4-1:0] DecodeL2;
wire [3:0] inL2;
assign inL2 = Address[5:2];
//
generate
genvar i;
// Generate the 4 4-16's:
for(i=0; i<=3; i=i+1)
begin: DL2
	wire [15:0] tempL2;
	Dec4_16 U2 (tempL2, inL2); // Each gets bits 2 - 5.
	//
	// Compose the decoded address from L1 and L2, and assign the bit:
	assign DecodeL2[(16*(i+1)-1):16*i] =
		(DecodedL1[i]==1'b1) ? DL2[i].tempL2 : 'b0;
end
endgenerate
```

Second section of code (level 3 decode):
```verilog
// The Level 3 decode requires 64 x 4-16's:
wire [(16*4)*16-1:0] AdrEna;
wire [3:0] inL3;
assign inL3 = Address[9:6];
//
generate
genvar j;
// Generate the 64 4-16's:
for(j=0; j<=4*16-1; j=j+1)
begin: DL3
	wire [15:0] tempL3;
	Dec4_16 U3 (tempL3, inL3); // Each gets bits 6 - 9.
	//
	// Compose the decoded address from L2 and L3, and assign the bit:
	assign AdrEna[(16*(j+1)-1):16*j] =
		(DecodedL2[j]==1'b1) ? DL3[j].tempL3 : 'b0;
end
endgenerate
```

These code snippets demonstrate generating instances for decoding in a hierarchy of levels, typically used in address decoding for memory selection.","
// The Level 2 decode, which requires 4 decoders, fully utilized:
wire [16*4-1:0] DecodeL2;
wire [3:0] inL2;
assign inL2 = Address[5:2];
//
generate
genvar i;
// Generate the 4 4-16's:
for(i=0; i<=3; i=i+1)
begin: DL2
	wire [15:0] tempL2;
	Dec4_16 U2 (tempL2, inL2); // Each gets bits 2 - 5.
	//
	// Compose the decoded address from L1 and L2, and assign the bit:
	assign DecodeL2[(16*(i+1)-1):16*i] =
		(DecodedL1[i]==1'b1) ? DL2[i].tempL2 : 'b0;
end
endgenerate


// The Level 3 decode requires 64 x 4-16's:
wire [(16*4)*16-1:0] AdrEna;
wire [3:0] inL3;
assign inL3 = Address[9:6];
//
generate
genvar j;
// Generate the 64 4-16's:
for(j=0; j<=4*16-1; j=j+1)
begin: DL3
	wire [15:0] tempL3;
	Dec4_16 U3 (tempL3, inL3); // Each gets bits 6 - 9.
	//
	// Compose the decoded address from L2 and L3, and assign the bit:
	assign AdrEna[(16*(j+1)-1):16*j] =
		(DecodedL2[j]==1'b1) ? DL3[j].tempL3 : 'b0;
end
endgenerate
",Verilog code examples demonstrating the implementation of level 2 and level 3 decoders in VLSI design.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p377.jpg,True,"The image contains Verilog code. Here are the contents:

```verilog
property p_mult_leading_clks;
    byte l_v = e;
    (@(posedge clk1) a1 until b1 == l_v)
    and
    (@(posedge clk2) a2 until b2 == l_v);
endproperty
```

```verilog
property p_mult_leading_clks;
    byte l_v;
    (@(posedge clk1) (1'b1, l_v = e) #-a1 until b1 == l_v)
    and
    (@(posedge clk2) (1'b1, l_v = e) #-a2 until b2 == l_v);
endproperty
```

Additionally, the image discusses declaring argument local variables in the context of SystemVerilog properties and sequence examples, and it includes an excerpt of an explanation about SystemVerilog capabilities in argument local variables.","
property p_mult_leading_clks;
    byte l_v = e;
    (@(posedge clk1) a1 until b1 == l_v)
    and
    (@(posedge clk2) a2 until b2 == l_v);
endproperty


property p_mult_leading_clks;
    byte l_v;
    (@(posedge clk1) (1'b1, l_v = e) #-a1 until b1 == l_v)
    and
    (@(posedge clk2) (1'b1, l_v = e) #-a2 until b2 == l_v);
endproperty
","This image shows a textbook excerpt discussing the concept of declaring argument local variables in Verilog, featuring examples of Verilog properties with local variable declarations.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p360.jpg,True,"The image contains snippets of text describing three TF routines from the Verilog PLI (Programming Language Interface) Handbook. Although not code in the sense of executable Verilog or C code, it does describe functions and their usage in an API reference style. Here are the function prototypes and descriptions provided in the image:

```c
p_tfexprinfo tf_exprinfo(n, info)
int          n        // index number of a system task/function argument.
p_tfexprinfo *info    // pointer to an application-allocated s_tfexprinfo structure to receive the expression information.
```

The `tf_exprinfo()` routine reads detailed information about a system task/function argument (an expression). The information is retrieved into an `s_tfexprinfo` structure.

```c
void tf_evaluatep(n)
int n   // index number of a system task/function argument.
```

The `tf_evaluatep()` routine re-reads the logic value of a system task/function argument. The value of argument n must have been previously read using `tf_exprinfo()`.

```c
void tf_propagatep(n)
int n   // index number of a system task/function argument.
```

The `tf_propagatep()` routine writes a logic value to a system task/function argument. The value of argument n must have been previously read using `tf_exprinfo()`.","xprinfo tf_exprinfo(n, info)
int          n        // index number of a system task/function argument.
p_tfexprinfo *info    // pointer to an application-allocated s_tfexprinfo structure to receive the expression information.

tf_evaluatep(n)
int n   // index number of a system task/function argument.

tf_propagatep(n)
int n   // index number of a system task/function argument.
","Caption: ""Excerpt from The Verilog PLI Handbook detailing the use of TF routines for reading and writing 4-state values in Verilog simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p175.jpg,True,"```verilog
class Transaction;
...
endclass

initial begin
Transaction trans[8]; // An array of 8 Transaction objects
trans = new;         // ERROR: cannot call new on object array
trans = new[8];      // ERROR: cannot call new on array element
end
```

```verilog
initial begin
Transaction trans[8]; // An array of 8 Transaction objects
foreach (trans[i])
trans[i] = new(); // Construct object and store handle in array
end
```","
class Transaction;
...
endclass

initial begin
Transaction trans[8]; // An array of 8 Transaction objects
trans = new;         // ERROR: cannot call new on object array
trans = new[8];      // ERROR: cannot call new on array element
end


initial begin
Transaction trans[8]; // An array of 8 Transaction objects
foreach (trans[i])
trans[i] = new(); // Construct object and store handle in array
end
","""Common mistake in Verilog OOP: Incorrect array of objects construction and the correct way to initialize object handles in an array.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p263.jpg,True,"Here is the Verilog code present in the image:

```verilog
// Example 1:
casex (X)
  4'b01xz: ...; // No match.
  4'b10xx: ...; // Executes, because it matches and comes first.
  4'b1xxz: ...; // Can't execute on this value of X.
  4'bxxxx: ...; // Would execute if 4'b10xx didn't.
  default: ...; // Would execute if nothing else did.
endcase

// Example 2: Some sort of bit-mask or decoder:
casex (Y)
  4'b??1?: ...; // Executes, because of casex LSB wildcard 'z' in Y above!
  4'b?1??: ...; // Would execute if the first one didn't.
  4'b?2??: ...; // Can't execute on this value of Y.
  4'b123?: ...; // Would execute if nothing above did.
  default: ...; // Would execute if no '1' or wildcard in Y.
endcase
```

And some conditional statements that are also considered as code:

```verilog
// Y = 4'b101z; // Y is reg[3:0].
//
if      (Y[0]!==1'b1) ...; // 'z' means no match (but === 1'bz would match).
else if (Y[1]===1'b1) ...; // This one executes.
else if (Y[2]!==1'b1) ...; // No, not '1' and below the first match.
else if (Y[3]!==1'b1) ...; // No, below the one that first matches.
else                 ...; // Executes if no '1' in Y.
```

Please note that the code snippets contain ellipses (...) indicating that there is additional code or functionality that should follow, which is not provided in the image.","
// Example 1:
casex (X)
  4'b01xz: ...; // No match.
  4'b10xx: ...; // Executes, because it matches and comes first.
  4'b1xxz: ...; // Can't execute on this value of X.
  4'bxxxx: ...; // Would execute if 4'b10xx didn't.
  default: ...; // Would execute if nothing else did.
endcase

// Example 2: Some sort of bit-mask or decoder:
casex (Y)
  4'b??1?: ...; // Executes, because of casex LSB wildcard 'z' in Y above!
  4'b?1??: ...; // Would execute if the first one didn't.
  4'b?2??: ...; // Can't execute on this value of Y.
  4'b123?: ...; // Would execute if nothing above did.
  default: ...; // Would execute if no '1' or wildcard in Y.
endcase


// Y = 4'b101z; // Y is reg[3:0].
//
if      (Y[0]!==1'b1) ...; // 'z' means no match (but === 1'bz would match).
else if (Y[1]===1'b1) ...; // This one executes.
else if (Y[2]!==1'b1) ...; // No, not '1' and below the first match.
else if (Y[3]!==1'b1) ...; // No, below the one that first matches.
else                 ...; // Executes if no '1' in Y.
","Caption: ""Examples of Verilog 'casex' and 'casez' Constructs and their Usage Considerations""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p390.jpg,True,"The image contains Verilog code. Here is the text of the code:

```verilog
covergroup CovDst35;
    kind: coverpoint tr.kind
        {bins zero = {0};
         bins lo   = {[1:3]};
         bins hi[] = {[8:5]};
         type_option.weight = 5;  // Count in total
        }
    dst: coverpoint tr.dst
        {bins dst[] = {[0:$]};
         type_option.weight = 0;  // Don't count towards total
        }
    cross kind, dst
        {type_option.weight = 10;}  // Give cross extra weight
endgroup
```

The code is an example (Sample 9.35) showing how to specify cross coverage weight in a covergroup for functional coverage in Verilog.","
covergroup CovDst35;
    kind: coverpoint tr.kind
        {bins zero = {0};
         bins lo   = {[1:3]};
         bins hi[] = {[8:5]};
         type_option.weight = 5;  // Count in total
        }
    dst: coverpoint tr.dst
        {bins dst[] = {[0:$]};
         type_option.weight = 0;  // Don't count towards total
        }
    cross kind, dst
        {type_option.weight = 10;}  // Give cross extra weight
endgroup
",Example of setting weights for coverpoints and cross coverage in Verilog functional coverage.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p55.jpg,True,"```verilog
logic [3:0] a; // unsigned 4-bit variable
logic signed [3:0] b; // signed 4-bit variable
logic [7:0] u; // unsigned 8-bit variable
logic signed [7:0] s; // signed 8-bit variable

u = 4'hC; // OK, 1100 (hex C) is zero-extended to 00001100

s = 4'hC; // GOTCHA! 1100 is zero-extended to 00001100,
          // even though s is a signed variable

u = 4'shC; // GOTCHA! 1100 is sign-extended to 11111100,
           // even though u is an unsigned variable

s = 4'shC; // OK, 1100 is sign-extended to 11111100

a = 4'hC;  // assign 4-bit literal to 4-bit unsigned variable
u = a;     // OK, 1100 is zero-extended to 00001100

s = a;     // GOTCHA! 1100 is zero-extended to 00001100,
           // even though s is a signed variable

b = 4'hC;  // assign 4-bit literal to 4-bit signed variable
u = b;     // GOTCHA! 1100 is sign-extended to 11111100,
           // even though u is an unsigned variable

s = b;     // OK, 1100 is sign-extended to 11111100
```

These are the Verilog code examples present in the image.","
logic [3:0] a; // unsigned 4-bit variable
logic signed [3:0] b; // signed 4-bit variable
logic [7:0] u; // unsigned 8-bit variable
logic signed [7:0] s; // signed 8-bit variable

u = 4'hC; // OK, 1100 (hex C) is zero-extended to 00001100

s = 4'hC; // GOTCHA! 1100 is zero-extended to 00001100,
          // even though s is a signed variable

u = 4'shC; // GOTCHA! 1100 is sign-extended to 11111100,
           // even though u is an unsigned variable

s = 4'shC; // OK, 1100 is sign-extended to 11111100

a = 4'hC;  // assign 4-bit literal to 4-bit unsigned variable
u = a;     // OK, 1100 is zero-extended to 00001100

s = a;     // GOTCHA! 1100 is zero-extended to 00001100,
           // even though s is a signed variable

b = 4'hC;  // assign 4-bit literal to 4-bit signed variable
u = b;     // GOTCHA! 1100 is sign-extended to 11111100,
           // even though u is an unsigned variable

s = b;     // OK, 1100 is sign-extended to 11111100
","""Verilog sign extension gotchas and examples""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p41.jpg,True,"The image contains Verilog code. Here is the code text from the image:

```verilog
module math_static ( ... ); // use static storage
  task math ( ... );
    logic [15:0] s1; // local variable
    ...
  endtask

  always_comb begin
    math(a1, b1, c1, o1);
    math(a2, b2, c2, o2);
  end
endmodule

module automatic math_auto(...); // use automatic storage
  task math ( ... );
    logic [15:0] s1; // local variable
    ...
  endtask

  always_comb begin
    math(a1, b1, c1, d1, o1a, o1b);
    math(a2, b2, c2, d2, o2a, o2b);
  end
endmodule
```

Please note that the ellipses (`...`) in the code likely denote omitted parts of the example code for brevity in the gotcha description.","
module math_static ( ... ); // use static storage
  task math ( ... );
    logic [15:0] s1; // local variable
    ...
  endtask

  always_comb begin
    math(a1, b1, c1, o1);
    math(a2, b2, c2, o2);
  end
endmodule

module automatic math_auto(...); // use automatic storage
  task math ( ... );
    logic [15:0] s1; // local variable
    ...
  endtask

  always_comb begin
    math(a1, b1, c1, d1, o1a, o1b);
    math(a2, b2, c2, d2, o2a, o2b);
  end
endmodule
","""Explanation of the use of automatic and static storage in Verilog tasks and the related gotchas.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p277.jpg,True,"Here are the Verilog code snippets provided in the image:

1.
```verilog
and #(3,5) InputGater[2:10](InBus, Dbus1, Dbus2, Dbus3);

```
This snippet describes an array of `and` gates called `InputGater`, with a delay of 3 and 5 units, instantiated for the indices 2 through 10 with input connections to `InBus`, `Dbus1`, `Dbus2`, and `Dbus3`.

2.
```verilog
MyBuffer Xbuff[1:3](.OutPin(OutBus), .InPin({InBus[5], InBus[3], InBus[7]}));
```
This snippet describes an array of instances of a module named `MyBuffer`, with the instances numbered 1 to 3. The output pin `OutPin` is connected to `OutBus`, and the `InPin` is connected to a concatenation of `InBus` at indices 5, 3, and 7.

These code examples illustrate the use of arrayed instances in Verilog, showing how to instantiate multiple modules or gates compactly with array syntax and how to connect them to different signals or signal parts.","
and #(3,5) InputGater[2:10](InBus, Dbus1, Dbus2, Dbus3);



MyBuffer Xbuff[1:3](.OutPin(OutBus), .InPin({InBus[5], InBus[3], InBus[7]}));
","Caption: ""An excerpt from a technical document explaining arrayed instances in Verilog, which shows how to create multiple instances of modules using arrays and how such declarations are functionally equivalent to individual instantiations of each module.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p384.jpg,True,"```verilog
bit [2:0] dst;
covergroup CovDst26;
  coverpoint tr.dst {
    wildcard bins even = {3'b??0};
    wildcard bins odd  = {3'b??1};
  }
endgroup

covergroup CovDst27;
  coverpoint tr.dst {
    ignore_bins hi = {6,7}; // Ignore upper 2 bins
  }
endgroup
```","
bit [2:0] dst;
covergroup CovDst26;
  coverpoint tr.dst {
    wildcard bins even = {3'b??0};
    wildcard bins odd  = {3'b??1};
  }
endgroup

covergroup CovDst27;
  coverpoint tr.dst {
    ignore_bins hi = {6,7}; // Ignore upper 2 bins
  }
endgroup
","""Explaining Verilog code for functional coverage using wildcard states, transitions, and ignore_bins construct.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p161.jpg,True,"The image contains a portion of text describing a concept in programming with Verilog, and includes a Verilog code snippet. Here is the code excerpt from the image:

```verilog
program automatic test;
    logic [7:0] a, b, c, sum, dif;
    int i; // GOTCHA! shared loop variable

    adder_subtractor dut (.*);

    initial begin
        fork
            begin: add_test
                for (i = 0; i < 10; i++) begin // increment i
                    a = i;
                    b = i + 10;
                    #10 $display(""At %0d, in scope %m: i=%0d sum=%0d"", $time, i, sum);
                end
            end

            begin: dif_test
                for (i = 8; i > 2; i--) begin // decrement i
                    c = i;
                    #10 $display(""At %0d, in scope %m: i=%0d dif=%0d"", $time, i, dif);
                end
            end
        join
        $display(""\nTests finished at time %0d\n"", $time);
        $finish;
    end
endmodule
```

This code is an example meant to illustrate a problem named ""Gotcha 66: Locked simulation due to concurrent for loops"" in Verilog. The issue being highlighted is the use of the same control variable (`i` in this case) for parallel `for` loops, which can interfere with each other during simulation.","
program automatic test;
    logic [7:0] a, b, c, sum, dif;
    int i; // GOTCHA! shared loop variable

    adder_subtractor dut (.*);

    initial begin
        fork
            begin: add_test
                for (i = 0; i < 10; i++) begin // increment i
                    a = i;
                    b = i + 10;
                    #10 $display(""At %0d, in scope %m: i=%0d sum=%0d"", $time, i, sum);
                end
            end

            begin: dif_test
                for (i = 8; i > 2; i--) begin // decrement i
                    c = i;
                    #10 $display(""At %0d, in scope %m: i=%0d dif=%0d"", $time, i, dif);
                end
            end
        join
        $display(""\nTests finished at time %0d\n"", $time);
        $finish;
    end
endmodule
","""Parallel for loops in Verilog with a shared control variable leading to simulation lockup""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p388.jpg,True,"```verilog
property p_ttype_vs_beats;
  transType l_ttype;
  int numBeats = 0;
  (start, l_ttype = ttype) ##1
  (
    (dataValid[->1], numBeats++) [*]
      ##1 dataValid[x]
    intersect
      complete[->1]
  )
|-> numBeatsOK(l_ttype, numBeats);
endproperty
```","
property p_ttype_vs_beats;
  transType l_ttype;
  int numBeats = 0;
  (start, l_ttype = ttype) ##1
  (
    (dataValid[->1], numBeats++) [*]
      ##1 dataValid[x]
    intersect
      complete[->1]
  )
|-> numBeatsOK(l_ttype, numBeats);
endproperty
","""Explaining the mechanics of local variables in Verilog using the `p_ttype_vs_beats` property as an example.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p149.jpg,True,"The image contains Verilog code. Here is the code from the image:

```verilog
module event_example2 ( ... );

event get_data, send_data; // handshaking flags

initial -> get_data; // OK, trigger get_data at time zero

always begin
  wait(get_data.triggered) // wait for a get_data event
  ... // do code to get data
  ... // when done, trigger send_data
  -> send_data; // sync with send_data process
end

always begin
  wait(send_data.triggered) // wait for a send_data event
  ... // do code to send data
  ... // when done, trigger get_data
  -> get_data; // sync with get_data process
end

endmodule
```

The text below the code explains the behavior of the `wait(get_data.triggered)` mechanism in Verilog.","
module event_example2 ( ... );

event get_data, send_data; // handshaking flags

initial -> get_data; // OK, trigger get_data at time zero

always begin
  wait(get_data.triggered) // wait for a get_data event
  ... // do code to get data
  ... // when done, trigger send_data
  -> send_data; // sync with send_data process
end

always begin
  wait(send_data.triggered) // wait for a send_data event
  ... // do code to send data
  ... // when done, trigger get_data
  -> get_data; // sync with get_data process
end

endmodule
","""Exploring Event Handling in Verilog with an Example of Handshaking Synchronization""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p69.jpg,True,"The image contains Verilog code, and here is the code as shown:

```verilog
always @* begin // GOTCHA! infers @(a, b)
    prod = mult(a, b); // call function that reads a, b, max_rtn
end

function [15:0] mult (input [7:0] m, n);
    mult = m * n;
    if (mult > max_rtn) // reference to external variable
        mult = max_rtn;
endfunction

always_comb begin // OK, infers @(a, b)
    sum = a + b;
end

always_comb begin // OK, infers @(a, b, max_rtn)
    prod = mult(a, b); // call function that reads a, b, max_rtn
end

always_comb begin // OK, infers @(sel, sum, prod)
    out = sel? sum : prod ;
end

function [15:0] mult (input [7:0] m, n);
    mult = m * n;
    if (mult > max_rtn) // reference external variable
        mult = max_rtn;
endfunction
```

The text discusses RTL modeling gotchas related to sensitivity lists in Verilog and recommends using `always_comb` and `always_latch` procedural blocks in SystemVerilog for improved sensitivity list inference.","
always @* begin // GOTCHA! infers @(a, b)
    prod = mult(a, b); // call function that reads a, b, max_rtn
end

function [15:0] mult (input [7:0] m, n);
    mult = m * n;
    if (mult > max_rtn) // reference to external variable
        mult = max_rtn;
endfunction

always_comb begin // OK, infers @(a, b)
    sum = a + b;
end

always_comb begin // OK, infers @(a, b, max_rtn)
    prod = mult(a, b); // call function that reads a, b, max_rtn
end

always_comb begin // OK, infers @(sel, sum, prod)
    out = sel? sum : prod ;
end

function [15:0] mult (input [7:0] m, n);
    mult = m * n;
    if (mult > max_rtn) // reference external variable
        mult = max_rtn;
endfunction
","Caption: ""Verilog code snippets demonstrating common RTL modeling gotchas and how to correctly infer sensitivity lists using SystemVerilog `always_comb` blocks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p539.jpg,True,"The image contains snippets of Verilog code. Here are the pieces of code presented in the image:

1. The first code snippet:

```verilog
...
begin : Search
  for ( j = 0; j <= 3; j = j ) // Might run forever.
    begin : WhileLoop
      while(l==1) // This while thus loops forever.
        begin
          ...
          if (CountOK==3)
            begin
              ...
              FoundPads = 1'b1;
              break; // Same as ""disable WhileLoop;"".
            end
          ...
        end
```

2. The second code snippet:

```verilog
for (i = 0; i<31; i = i+1)
  begin
    if (Reg[i] <= 8'h17)
      Reg[i] = Reg[i] + 1;
    else continue; // Try next i.
  end
```

3. The third code snippet:

```verilog
function[7:0] doCheckSum ( ... );
  ...
  doCheckSum = temp1[7:0] + temp2[7:0]^temp1[15:8] + temp2[15:8];
end
endfunction
```

4. The fourth code snippet:

```verilog
function[7:0] doCheckSum ( ... );
  ...
  return (temp1[7:0] + temp2[7:0]^temp1[15:8] + temp2[15:8]);
end
endfunction
```

Please note that the ellipses (`...`) indicate omitted code that is not shown in the snippets, and the comments in the code are part of the original excerpts. Additionally, due to the nature of image to text transcription, consider confirming the accuracy of the code against the original context or document.","
...
begin : Search
  for ( j = 0; j <= 3; j = j ) // Might run forever.
    begin : WhileLoop
      while(l==1) // This while thus loops forever.
        begin
          ...
          if (CountOK==3)
            begin
              ...
              FoundPads = 1'b1;
              break; // Same as ""disable WhileLoop;"".
            end
          ...
        end


for (i = 0; i<31; i = i+1)
  begin
    if (Reg[i] <= 8'h17)
      Reg[i] = Reg[i] + 1;
    else continue; // Try next i.
  end


function[7:0] doCheckSum ( ... );
  ...
  doCheckSum = temp1[7:0] + temp2[7:0]^temp1[15:8] + temp2[15:8];
end
endfunction


function[7:0] doCheckSum ( ... );
  ...
  return (temp1[7:0] + temp2[7:0]^temp1[15:8] + temp2[15:8]);
end
endfunction
","The image displays a textbook page discussing concepts in Digital VLSI Design using Verilog, including examples of Verilog code demonstrating the use of 'break' and 'continue' control statements, as well as the 'return' statement in SystemVerilog functions.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p179.jpg,True,"The image displays code related to a PSL (Property Specification Language) AHB (AMBA High-performance Bus) read burst mode transaction in Verilog. Here is the code presented in the image:

```verilog
`define AHB_WAIT  (!hready && (hresp==`OKAY))
`define AHB_OKAY  (hready && (hresp==`OKAY))
`define AHB_ERROR (hresp==`ERROR)
`define AHB_SPLIT (hresp==`SPLIT)
`define AHB_RETRY (hresp==`RETRY)

sequence SERE_AHB_SLAVE_RESPONSE = {
  `AHB_WAIT[*];
  {
    { `AHB_OKAY } |
    { (!hready; hready) && {`AHB_ERROR [*2]} } |
    { (!hready; hready) && {`AHB_SPLIT [*2]} } |
    { (!hready; hready) && {`AHB_RETRY [*2]} }
  }
};

`define AHB_FIRST_TRANS (htrans==`NONSEQ)
`define AHB_NEXT_TRANS  (htrans==`SEQ)
`define AHB_MASTER_BUSY (htrans==`BUSY)
`define AHB_READ_INCR   (!hwrite && (hburst==`INCR))

// slave response to the previous data in parallel with the master's
// assertion of the control signals for the next address

sequence SERE_AHB_READ_FIRST = {
  {SERE_AHB_SLAVE_RESPONSE} &&
  {`AHB_FIRST_TRANS && `AHB_READ_INCR}[*]
};

sequence SERE_AHB_READ_NEXT = {
  {SERE_AHB_SLAVE_RESPONSE} &&
  {
    {AHB_NEXT_TRANS && `AHB_READ_INCR}[*] |
    {`AHB_MASTER_BUSY[*]}
  }
};

sequence SERE_AHB_BURST_MODE_READ = {
  {SERE_AHB_READ_FIRST}; {SERE_AHB_READ_NEXT}[*]
};

cover {SERE_AHB_BURST_MODE_READ};
```

This snippet defines various macros for different AHB bus states, sequences for slave responses during a transaction, and a cover point to capture the read burst mode transactions for functional coverage analysis in a hardware verification context.","
`define AHB_WAIT  (!hready && (hresp==`OKAY))
`define AHB_OKAY  (hready && (hresp==`OKAY))
`define AHB_ERROR (hresp==`ERROR)
`define AHB_SPLIT (hresp==`SPLIT)
`define AHB_RETRY (hresp==`RETRY)

sequence SERE_AHB_SLAVE_RESPONSE = {
  `AHB_WAIT[*];
  {
    { `AHB_OKAY } |
    { (!hready; hready) && {`AHB_ERROR [*2]} } |
    { (!hready; hready) && {`AHB_SPLIT [*2]} } |
    { (!hready; hready) && {`AHB_RETRY [*2]} }
  }
};

`define AHB_FIRST_TRANS (htrans==`NONSEQ)
`define AHB_NEXT_TRANS  (htrans==`SEQ)
`define AHB_MASTER_BUSY (htrans==`BUSY)
`define AHB_READ_INCR   (!hwrite && (hburst==`INCR))

// slave response to the previous data in parallel with the master's
// assertion of the control signals for the next address

sequence SERE_AHB_READ_FIRST = {
  {SERE_AHB_SLAVE_RESPONSE} &&
  {`AHB_FIRST_TRANS && `AHB_READ_INCR}[*]
};

sequence SERE_AHB_READ_NEXT = {
  {SERE_AHB_SLAVE_RESPONSE} &&
  {
    {AHB_NEXT_TRANS && `AHB_READ_INCR}[*] |
    {`AHB_MASTER_BUSY[*]}
  }
};

sequence SERE_AHB_BURST_MODE_READ = {
  {SERE_AHB_READ_FIRST}; {SERE_AHB_READ_NEXT}[*]
};

cover {SERE_AHB_BURST_MODE_READ};
","""Verilog code for PSL AHB read burst mode transaction and functional coverage points""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p301.jpg,True,"The image contains Verilog code related to asynchronous FIFO test-benching and assertions. Here is the code from the image:

```verilog
efw: assert property (empty_full) else $display($stime,,, ""FAIL: Full and Empty BOTH asserted"");

/*-------------------------------------
rclk_reset_n Check on rclk
-------------------------------------*/

/*
Following property checks to see that empty pointer is high (i.e., empty) when you reset the FIFO
*/
property reset_n_rclk;
    @(posedge rclk) !rclk_reset_n |-> empty;
endproperty

reset_n_rclk_a: assert property (reset_n_rclk) else $display($stime,,, ""FAIL: FIFO not empty during rclk_reset_n"");
reset_n_rclk_c: cover property (reset_n_rclk) $display($stime,,, ""PASS: FIFO empty during rclk_reset_n"");

/*-------------------------------------
wclk_reset_n Check on wclk
-------------------------------------*/

/*
Following property checks to see that the FIFO is not full when you reset the FIFO. FIFO can only go Empty during reset, not Full.
*/
property reset_n_wclk;
    @(posedge wclk) !wclk_reset_n |-> !full;
endproperty

reset_n_wclk_a: assert property (reset_n_wclk) else $display($stime,,, ""FAIL: FIFO FULL during wclk_reset_n"");
reset_n_wclk_c: cover property (reset_n_wclk) $display($stime,,, ""PASS: FIFO FULL during rclk_wstn"");

endmodule
```

The code is making assertions (safety checks) and coverage analysis statements to ensure that the FIFO behaves as expected during resets on both the read clock (`rclk`) and write clock (`wclk`). It is verifying that the FIFO cannot be both full and empty at the same time and that it is empty when the read clock is reset and not full when the write clock is reset.","
efw: assert property (empty_full) else $display($stime,,, ""FAIL: Full and Empty BOTH asserted"");

/*-------------------------------------
rclk_reset_n Check on rclk
-------------------------------------*/

/*
Following property checks to see that empty pointer is high (i.e., empty) when you reset the FIFO
*/
property reset_n_rclk;
    @(posedge rclk) !rclk_reset_n |-> empty;
endproperty

reset_n_rclk_a: assert property (reset_n_rclk) else $display($stime,,, ""FAIL: FIFO not empty during rclk_reset_n"");
reset_n_rclk_c: cover property (reset_n_rclk) $display($stime,,, ""PASS: FIFO empty during rclk_reset_n"");

/*-------------------------------------
wclk_reset_n Check on wclk
-------------------------------------*/

/*
Following property checks to see that the FIFO is not full when you reset the FIFO. FIFO can only go Empty during reset, not Full.
*/
property reset_n_wclk;
    @(posedge wclk) !wclk_reset_n |-> !full;
endproperty

reset_n_wclk_a: assert property (reset_n_wclk) else $display($stime,,, ""FAIL: FIFO FULL during wclk_reset_n"");
reset_n_wclk_c: cover property (reset_n_wclk) $display($stime,,, ""PASS: FIFO FULL during rclk_wstn"");

endmodule
","""Verilog Assertions for Asynchronous FIFO Test-Bench""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p272.jpg,True,"The image contains Verilog code, and here it is transcribed:

```verilog
property p_mchk11;
    @(posedge clk)
    ($fell(framen) && (cxben[3:0] == (4'b0001))) |-> 
    (perrn [*1:$]
        ##0 ($rose (irdyn && trdyn))
        ##1 perrn[*2]);
endproperty

a_mchk11: assert property(p_mchk11);
c_mchk11: cover property(p_mchk11);
```

The code defines a property for verifying that a signal `perrn` should not be asserted during specific conditions in a PCI protocol based design, which include checking for falling edge of `framen` and certain values on `cxben`. It uses SystemVerilog assertions (SVA) to assert (`a_mchk11`) and cover (`c_mchk11`) the defined property `p_mchk11`.","
property p_mchk11;
    @(posedge clk)
    ($fell(framen) && (cxben[3:0] == (4'b0001))) |-> 
    (perrn [*1:$]
        ##0 ($rose (irdyn && trdyn))
        ##1 perrn[*2]);
endproperty

a_mchk11: assert property(p_mchk11);
c_mchk11: cover property(p_mchk11);
","Caption: ""Figure 6-13 depicts timing diagrams for a PCI interface, while the corresponding text outlines a Verilog property to ensure the PERR signal is not asserted during special cycles, as specified in a formal verification environment.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p390.jpg,True,"The image contains a code snippet written in Verilog. Here is the code:

```verilog
wire inset = {valid, attr[2:0], attr1[1:0]}
inside {6’ho,               // invalid
        6’b1_110_00,        // strobe 0
        6’b1_111_x1,        // strobe 1y
        6’b1_011_z1};       // strobe 3y
```

The code snippet demonstrates the use of the `inside` operator in Verilog. Also included is a representation of how don't care bits can be managed within the `inside` operator:

```
1’bx inside 1’b0, 1’b1 === 1’b0
```

Furthermore, there is discussion around SystemVerilog system tasks such as `$fatal` and `$error`, but no complete code example is given for these tasks.","
wire inset = {valid, attr[2:0], attr1[1:0]}
inside {6’ho,               // invalid
        6’b1_110_00,        // strobe 0
        6’b1_111_x1,        // strobe 1y
        6’b1_011_z1};       // strobe 3y

nside 1’b0, 1’b1 === 1’b0
","Caption: ""Understanding Verilog's 'inside' operator and SystemVerilog system tasks for error handling.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p151.jpg,True,"```verilog
interface bidir_if (input bit clk);
    wire [7:0] data; // Bidirectional signal
    clocking cb @(posedge clk);
        inout data;
    endclocking
    modport TEST (clocking cb);
endinterface

program automatic test(bidir_if.TEST mif);
    initial begin
        mif.cb.data <= 'lz;          // Tri-state the bus
        @(mif.cb);
        $displayh(mif.cb.data);       // Read from the bus
        @(mif.cb);
        mif.cb.data <= 7'h5a;         // Drive the bus
        @(mif.cb);
        $displayh(mif.cb.data);       // Read from the bus
        mif.cb.data <= 'lz;           // Release the bus
    end
endprogram

clocking cb @(posedge clk);
    default input #15ns output #10ns;
    output request;
    input grant;
endclocking
```","
interface bidir_if (input bit clk);
    wire [7:0] data; // Bidirectional signal
    clocking cb @(posedge clk);
        inout data;
    endclocking
    modport TEST (clocking cb);
endinterface

program automatic test(bidir_if.TEST mif);
    initial begin
        mif.cb.data <= 'lz;          // Tri-state the bus
        @(mif.cb);
        $displayh(mif.cb.data);       // Read from the bus
        @(mif.cb);
        mif.cb.data <= 7'h5a;         // Drive the bus
        @(mif.cb);
        $displayh(mif.cb.data);       // Read from the bus
        mif.cb.data <= 'lz;           // Release the bus
    end
endprogram

clocking cb @(posedge clk);
    default input #15ns output #10ns;
    output request;
    input grant;
endclocking
",Sample Verilog code demonstrating a bidirectional signal in an interface and a test program using a modport to interact with the bidirectional signal. The text also discusses specifying delays in clocking blocks in SystemVerilog.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p467.jpg,True,"The image contains Verilog code in a textbook or document page. Here is the Verilog code present on the page:

```verilog
class HLp;
    bit m_ev;
endclass

class Mclass;
    HLp m_obj;
    int m_a;

    covergroup Cov @(m_obj.m_ev);
        coverpoint m_a;
    endgroup

    function new( );
        m_obj = new; // coverage group 'Cov' uses m_obj. So, m_obj must be constructed before 'Cov'
        Cov = new;
    endfunction

endclass: HLp
```

This code defines two Verilog classes and one covergroup intended for coverage analysis in a verification environment.","
class HLp;
    bit m_ev;
endclass

class Mclass;
    HLp m_obj;
    int m_a;

    covergroup Cov @(m_obj.m_ev);
        coverpoint m_a;
    endgroup

    function new( );
        m_obj = new; // coverage group 'Cov' uses m_obj. So, m_obj must be constructed before 'Cov'
        Cov = new;
    endfunction

endclass: HLp
","The image shows a textbook page discussing the topic of ""Embedded covergroup: Hierarchical Accessibility"" in the context of Verilog/SystemVerilog code. It includes an example of class definitions and the instantiation of a covergroup within a class to demonstrate hierarchical access of class members for functional coverage.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p145.jpg,True,"Here is the Verilog code written in the image:

```verilog
program automatic test (arb_if.TEST arbif);
initial begin
    @arbif.cb;
    arbif.cb.request <= 2'b01;
    $display(""%0t: Drove req=01"", $time);
    repeat (2) @arbif.cb;
    if (arbif.cb.grant == 2'b01)
        $display(""%0t: Success: grant == 2'b01"", $time);
    else
        $display(""%0t: Error: grant != 2'b01"", $time);
end
endprogram : test
```","
program automatic test (arb_if.TEST arbif);
initial begin
    @arbif.cb;
    arbif.cb.request <= 2'b01;
    $display(""%0t: Drove req=01"", $time);
    repeat (2) @arbif.cb;
    if (arbif.cb.grant == 2'b01)
        $display(""%0t: Success: grant == 2'b01"", $time);
    else
        $display(""%0t: Error: grant != 2'b01"", $time);
end
endprogram : test
","""Example of a Verilog testbench program block with automated stimulus generation for interface testing.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p473.jpg,True,"```verilog
class ex_class extends uvm_component;
int myInt[10];
covergroup myCG (@posedge clk); //covergroup embedded in the class 'ex_class'
    coverpoint myInt
    {
        bins myInt_range_1 = {[124:0]};
        bins myInt_range_2 = {[325:125]};
    }
endgroup: myCG
function new (string name, uvm_component parent=null); //class constructor (UVM style)
    super.new(name , parent);
    foreach (myInt[ i ])
        myCG myCG[ i ]=new(myInt[ i ]); // ERROR
endfunction
endclass: ex_class

covergroup myCG (@posedge clk); //covergroup declared outside of the class 'ex_class'
    coverpoint myInt
    {
        bins myInt_range_1 = {[124:0]};
        bins myInt_range_2 = {[325:125]};
    }
endgroup: myCG
class ex_class extends uvm_component;
int myInt[10];
myCG myCG_val[10]; //An array of class 'myCG'
```","
class ex_class extends uvm_component;
int myInt[10];
covergroup myCG (@posedge clk); //covergroup embedded in the class 'ex_class'
    coverpoint myInt
    {
        bins myInt_range_1 = {[124:0]};
        bins myInt_range_2 = {[325:125]};
    }
endgroup: myCG
function new (string name, uvm_component parent=null); //class constructor (UVM style)
    super.new(name , parent);
    foreach (myInt[ i ])
        myCG myCG[ i ]=new(myInt[ i ]); // ERROR
endfunction
endclass: ex_class

covergroup myCG (@posedge clk); //covergroup declared outside of the class 'ex_class'
    coverpoint myInt
    {
        bins myInt_range_1 = {[124:0]};
        bins myInt_range_2 = {[325:125]};
    }
endgroup: myCG
class ex_class extends uvm_component;
int myInt[10];
myCG myCG_val[10]; //An array of class 'myCG'
","Caption: ""Example of correct and incorrect ways to declare a covergroup within a class in SystemVerilog for creating an array of its instances.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p149.jpg,True,"The image contains snippets of Verilog code, which are used to illustrate the usage of sequences and properties in assertions. Here are the code snippets from the image:

```verilog
// Example 6.45 solution
req ##[2:$] gnt.

// Assertion a1 in Example 6.46
initial a1: assert property (@(posedge clk) ##[1:*] s |-> p);

// Assertions equivalent to a1
a2: assert property (@(posedge clk) s |-> p);
a3: assert property (@(posedge clk) ##[*] s |-> p);

// Assertion a1 in section 6.10
a1: assert property (@(posedge clk) req |-> ##[1:5] gnt);

// Erroneous assertions in section 6.10
a2_wrong: assert property (@(posedge clk) req |-> ##[1:$] gnt);
a3_wrong: assert property (@(posedge clk) req |=> ##[*] gnt);
```

These snippets illustrate the syntax for writing assertions in SystemVerilog and the various ways sequences can be specified within these assertions.","
// Example 6.45 solution
req ##[2:$] gnt.

// Assertion a1 in Example 6.46
initial a1: assert property (@(posedge clk) ##[1:*] s |-> p);

// Assertions equivalent to a1
a2: assert property (@(posedge clk) s |-> p);
a3: assert property (@(posedge clk) ##[*] s |-> p);

// Assertion a1 in section 6.10
a1: assert property (@(posedge clk) req |-> ##[1:5] gnt);

// Erroneous assertions in section 6.10
a2_wrong: assert property (@(posedge clk) req |-> ##[1:$] gnt);
a3_wrong: assert property (@(posedge clk) req |=> ##[*] gnt);
","Caption: ""Excerpts from a textbook or reference material on Verilog discussing the use of assertions in temporal logic for hardware verification, focusing on basic sequences and unbounded sequences.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p266.jpg,True,"The image contains Verilog/SystemVerilog code related to a PCI Master check. Here is the code as seen in the image:

```verilog
sequence s_mchk7_before;
  @(posedge clk)
    (!devseln && $fell(stopn) && trdyn)
      ##1 reqn ##1 `s_BUS_IDLE;
endsequence

sequence s_mchk7_after;
  @(posedge clk)
    (!devseln && $fell(stopn) && trdyn)
      ##1 reqn ##1 `s_BUS_IDLE;
endsequence

property p_mchk7_before;
  @(posedge clk)
    s_mchk7_before.ended |-> reqn;
```

The code defines two sequences (s_mchk7_before and s_mchk7_after) and a property (p_mchk7_before) which are related to the timing and behavior of signals in a PCI interface as per certain conditions.","
sequence s_mchk7_before;
  @(posedge clk)
    (!devseln && $fell(stopn) && trdyn)
      ##1 reqn ##1 `s_BUS_IDLE;
endsequence

sequence s_mchk7_after;
  @(posedge clk)
    (!devseln && $fell(stopn) && trdyn)
      ##1 reqn ##1 `s_BUS_IDLE;
endsequence

property p_mchk7_before;
  @(posedge clk)
    s_mchk7_before.ended |-> reqn;
","Caption: ""Verilog code example and timing diagram for a PCI Master check, specifying the behavior of abort handling and request de-assertion.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p384.jpg,True,"The image contains Verilog code related to SystemVerilog Assertions for sequence and property declaration. Here is the code written in the image:

```verilog
*** not @(posedge clk) req && cmd == 4;

endproperty

property starts_at(start, grant, reset_n);
  disable iff (~reset_n) // async reset of property.
  @(posedge clk) (grant[-1]) ##1 grant & start;
endproperty
```

And another section below:

```verilog
sequence_declaration ::=
  sequence sequence_identifier [sequence_formal_list ] ';'
  { assertion_variable_declaration }
  sequence_expr ';'
endsquence [ ':' sequence_identifier ]

sequence_formal_list ::=
  '(' formal_list_item { ',' formal_list_item } ')'

assertion_variable_declaration ::=
  data_type_list_of_variable_declarations ';'
```

Additionally, there are a few examples of sequences:

```verilog
sequence op_retry;
  (req ##1 retry);

endsequence

sequence cache_fill(req, done, fill);
  (req ##1 done [-> 1] ##1 fill [->1]);

endsequence
```

This Verilog code is specifying the syntax for declaring sequences and properties in SystemVerilog, alongside examples of sequence usage.","
*** not @(posedge clk) req && cmd == 4;

endproperty

property starts_at(start, grant, reset_n);
  disable iff (~reset_n) // async reset of property.
  @(posedge clk) (grant[-1]) ##1 grant & start;
endproperty


sequence_declaration ::=
  sequence sequence_identifier [sequence_formal_list ] ';'
  { assertion_variable_declaration }
  sequence_expr ';'
endsquence [ ':' sequence_identifier ]

sequence_formal_list ::=
  '(' formal_list_item { ',' formal_list_item } ')'

assertion_variable_declaration ::=
  data_type_list_of_variable_declarations ';'


sequence op_retry;
  (req ##1 retry);

endsequence

sequence cache_fill(req, done, fill);
  (req ##1 done [-> 1] ##1 fill [->1]);

endsequence
","Caption: ""Excerpt from a textbook illustrating SystemVerilog assertions with examples of property and sequence declarations.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p315.jpg,True,"The image contains information about Verilog and provides a snippet of code. Here's the code written in the document:

```verilog
a1: assert property (@global_clock $changing_gclk(req) |-> $falling_gclk(req))
else $error(""req is not stable"");
```

The code is an example of using SystemVerilog assertion with global clocking sampled value functions, specifically demonstrating the use of `$changing_gclk` and `$falling_gclk` as part of an assertion property.","
a1: assert property (@global_clock $changing_gclk(req) |-> $falling_gclk(req))
else $error(""req is not stable"");
","A page from a technical document describing future global clocking sampled value functions in Verilog SVA (SystemVerilog Assertions), with an example code snippet illustrating the use of assert property with a future clocking event.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p610.jpg,True,"The image contains a portion of code written in C language, which appears to be a callback function for handling changes in logic values within a Verilog simulation using the PLI (Programming Language Interface). Please note that some of the code might not be fully visible due to the image boundaries, so I will provide what is visible:

```c
vcl_verilog_logic);

acc_close();
}
/***********************************************************************
 * consumer routine
 ***********************************************************************/
int PLIbook_MyMonitor_consumer(p_vc_record vc_record)
{
  char newValue[2];
  /* retrieve pointer to data structure array from user_data field */
  PLIbook_MyMon_p ArrayElem_p = (PLIbook_MyMon_p)vc_record->user_data;
  switch (vc_record->vc_reason) { /* check reason call-back occurred */
  case logic_value_change:        /* scalar net changed */
  case register_value_change :    /* scalar register changed */
    switch (vc_record->out_value.logic_value) { /* convert value */
      case vc0:  strcpy(newValue, ""0""); break; /* to string */
      case vc1:  strcpy(newValue, ""1""); break;
      case vcX:  strcpy(newValue, ""x""); break;
      case vcZ:  strcpy(newValue, ""z""); break;
    }
    io_printf(""At time %d: %-20s last value=%s new value=%s\n"",
              vc_record->vc_lowtime, ArrayElem_p->signalName,
              ArrayElem_p->lastValue, newValue);
    /* save the new value */
    
    strcpy(ArrayElem_p->lastValue, newValue);
  }
  return(0);
}
```

The code is part of a monitoring routine that looks for changes in signal values and prints out information when these changes occur. It's likely intended to be part of a larger Verilog simulation framework that uses C functions to interact with the simulation.","erilog_logic);

acc_close();
}
/***********************************************************************
 * consumer routine
 ***********************************************************************/
int PLIbook_MyMonitor_consumer(p_vc_record vc_record)
{
  char newValue[2];
  /* retrieve pointer to data structure array from user_data field */
  PLIbook_MyMon_p ArrayElem_p = (PLIbook_MyMon_p)vc_record->user_data;
  switch (vc_record->vc_reason) { /* check reason call-back occurred */
  case logic_value_change:        /* scalar net changed */
  case register_value_change :    /* scalar register changed */
    switch (vc_record->out_value.logic_value) { /* convert value */
      case vc0:  strcpy(newValue, ""0""); break; /* to string */
      case vc1:  strcpy(newValue, ""1""); break;
      case vcX:  strcpy(newValue, ""x""); break;
      case vcZ:  strcpy(newValue, ""z""); break;
    }
    io_printf(""At time %d: %-20s last value=%s new value=%s\n"",
              vc_record->vc_lowtime, ArrayElem_p->signalName,
              ArrayElem_p->lastValue, newValue);
    /* save the new value */
    
    strcpy(ArrayElem_p->lastValue, newValue);
  }
  return(0);
}
","""An excerpt from The Verilog PLI Handbook, showcasing a PLI consumer routine example in Verilog that handles value changes in simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p73.jpg,True,"```verilog
$show_all_nets(<module_instance_name>);
```","
$show_all_nets(<module_instance_name>);
","""Introduction to VPI Routines for Verilog HDL and the Specification of PLI Applications in Verilog Simulation""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p176.jpg,True,"The image contains two sections of code. One is a C function that converts VPI logic constants to characters, and the other defines a struct for time representation in Verilog. Here is the code:

Function to convert VPI logic constant to a character:
```c
char PLIbook_DecodeBitValue(int bit_constant)
{
    switch (bit_constant) {
        case vpi0:           return ('0'); break;
        case vpi1:           return ('1'); break;
        case vpiZ:           return ('Z'); break;
        case vpiX:           return ('X'); break;
        case vpiL:           return ('L'); break;
        case vpiH:           return ('H'); break;
        case vpiDontCare:    return ('?'); break;
        default:             return ('U'); /* undefined value passed in */
    }
}
```

Struct definition for the Verilog time variable:
```c
typedef struct t_vpi_time
{
    int type;
    unsigned int high, low;
    double real;
    s_vpi_time, *p_vpi_time;
} 
```

Please note that the syntax for the struct definition may be incomplete or incorrect as presented in the text. The intention here is just to represent the relevant code snippet from the image.","PLIbook_DecodeBitValue(int bit_constant)
{
    switch (bit_constant) {
        case vpi0:           return ('0'); break;
        case vpi1:           return ('1'); break;
        case vpiZ:           return ('Z'); break;
        case vpiX:           return ('X'); break;
        case vpiL:           return ('L'); break;
        case vpiH:           return ('H'); break;
        case vpiDontCare:    return ('?'); break;
        default:             return ('U'); /* undefined value passed in */
    }
}

ef struct t_vpi_time
{
    int type;
    unsigned int high, low;
    double real;
    s_vpi_time, *p_vpi_time;
} 
","""C Programming function for interpreting Verilog VPI logic constants and structure definition for Verilog time variables as per the Verilog PLI Handbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p161.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
a4: assert property (@(posedge clk) disable iff (rst) nexttime $onehot(sig ^ $past(sig)));
```

This line of Verilog code appears to be using the SystemVerilog Assertions (SVA) feature, which is a part of the IEEE 1800 SystemVerilog standard. The code defines an assertion that must hold true during simulation. It specifies that at the positive edge of the clock (`@(posedge clk)`), if the reset signal (`rst`) is not asserted (`disable iff (rst)`), then the property `nexttime $onehot(sig ^ $past(sig))` should be true. This property checks that in the next clock cycle, the signal `sig` should change to a one-hot encoded value compared to its past value (`$past(sig)`).","
a4: assert property (@(posedge clk) disable iff (rst) nexttime $onehot(sig ^ $past(sig)));
","""Excerpt on Verilog Assertions and $past System Function with a Table Demonstrating Past Values of Signals Relative to Clock Edges.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p179.jpg,True,"The image contains a snippet of text from a book about programming and object-oriented programming (OOP) concepts, and there is a portion of code written in presumably SystemVerilog. Here is the code from the image:

```systemverilog
Transaction t1, t2;  // Declare two handles
t1 = new();          // Allocate first Transaction object
t2 = t1;             // t1 & t2 point to it
t1 = new();          // Allocate second Transaction object
```

This code demonstrates the allocation of multiple objects and how handles (variables) can point to these objects within the context of SystemVerilog OOP.","erilog
Transaction t1, t2;  // Declare two handles
t1 = new();          // Allocate first Transaction object
t2 = t1;             // t1 & t2 point to it
t1 = new();          // Allocate second Transaction object
","The image contains text describing the difference between the `new()` function and the `new[]` operator in the context of Object-Oriented Programming, particularly related to SystemVerilog. Below the text, there is a sample Verilog code demonstrating how to allocate multiple objects and a diagram showing the relationship between handles and objects after allocation.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p67.jpg,True,"```c
typedef struct t_vpi_sysTf_data {
    int type;
    int subtype;
    char *tfname;
    int (*calltf)();
    int (*compiletf)();
    int (*sizetf)();
    char *user_data;
} s_vpi_sysTf_data, *p_vpi_sysTf_data;
```","ef struct t_vpi_sysTf_data {
    int type;
    int subtype;
    char *tfname;
    int (*calltf)();
    int (*compiletf)();
    int (*sizetf)();
    char *user_data;
} s_vpi_sysTf_data, *p_vpi_sysTf_data;
","Caption: ""Definition of the s_vpi_systf_data structure and its fields used in VPI based PLI Applications for Verilog Simulators.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p329.jpg,True,"The image contains some text explaining Verilog concepts and a snippet of Verilog code. Below is the provided code:

```verilog
property p1;
    req s_until_with gnt;
endproperty
```

This code defines a property named `p1` using SystemVerilog's property specification language. The `s_until_with` keyword is a part of this property specification language, and the property `p1` is checking for the event when `req` is true until `gnt` becomes true, with the additional constraint that both signals must be true on the same clock cycle where `gnt` is first true for the property to hold.","
property p1;
    req s_until_with gnt;
endproperty
","Caption: ""Understanding SystemVerilog Assertions: Explanation and example of 'until_with' property and a brief overview of 'nexttime' and 's_nexttime' in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p604.jpg,True,"Here is the code from the image:

```c
handle net_handle;
char *net_name;
char *net_name_keep;

/* obtain a handle for a net from the first task arg */
net_handle = acc_handle_tfarg(1);

/* allocate memory for the name of the net */
net_name = acc_fetch_name(net_handle);
net_name_keep = malloc(strlen(net_name)+1);
strcpy(net_name_keep, net_name); /* save net_name */

/* add a VCL flag to net--user_data is pointer to net name */
acc_vcl_add(net_handle,
            my_consumer_routine,
            (char*)net_name_keep,
            vcl_verilog_logic);
```","e net_handle;
char *net_name;
char *net_name_keep;

/* obtain a handle for a net from the first task arg */
net_handle = acc_handle_tfarg(1);

/* allocate memory for the name of the net */
net_name = acc_fetch_name(net_handle);
net_name_keep = malloc(strlen(net_name)+1);
strcpy(net_name_keep, net_name); /* save net_name */

/* add a VCL flag to net--user_data is pointer to net name */
acc_vcl_add(net_handle,
            my_consumer_routine,
            (char*)net_name_keep,
            vcl_verilog_logic);
","""Verilog PLI code snippet for adding a VCL flag to a net with associated user data""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p353.jpg,True,"```
PSL_Declaration ::= 
    Clock_Declaration
Clock_Declaration ::=
    default clock DEF_SYM Clock_Expression ;(see B.8.3.2)

SERE ::=
    SERE @ Clock_Expression

FL_Property ::=
    FL_Property @ Clock_Expression
```
```
Property ::=
    Replicator Property
Replicator ::=
    forall Name [ IndexRange ] in ValueSet :
IndexRange ::=
    LEFT_SYM finite_Range RIGHT_SYM
Flavor Macro LEFT_SYM =
    Verilog: |( VHDL: ( GDL: (
Flavor Macro RIGHT_SYM =
    Verilog: |) VHDL: ) GDL: )
ValueSet ::=
    { ValueRange { , ValueRange } }
    | boolean
ValueRange ::=
    Value
    | finite_Range
Range ::=
    LowBound RANGE_SYM HighBound
```","claration ::= 
    Clock_Declaration
Clock_Declaration ::=
    default clock DEF_SYM Clock_Expression ;(see B.8.3.2)

SERE ::=
    SERE @ Clock_Expression

FL_Property ::=
    FL_Property @ Clock_Expression

ty ::=
    Replicator Property
Replicator ::=
    forall Name [ IndexRange ] in ValueSet :
IndexRange ::=
    LEFT_SYM finite_Range RIGHT_SYM
Flavor Macro LEFT_SYM =
    Verilog: |( VHDL: ( GDL: (
Flavor Macro RIGHT_SYM =
    Verilog: |) VHDL: ) GDL: )
ValueSet ::=
    { ValueRange { , ValueRange } }
    | boolean
ValueRange ::=
    Value
    | finite_Range
Range ::=
    LowBound RANGE_SYM HighBound
",Syntax for default clock declaration and clocked property in Property Specification Language (PSL) for Verilog.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p189.jpg,True,"```verilog
reg [<msb>:<lsb>] <memory_name> [<first_addr>:<last_addr>];
integer <memory_name> [<first_addr>:<last_addr>];
time <memory_name> [<first_addr>:<last_addr>];
```","
reg [<msb>:<lsb>] <memory_name> [<first_addr>:<last_addr>];
integer <memory_name> [<first_addr>:<last_addr>];
time <memory_name> [<first_addr>:<last_addr>];
","""Explanation of accessing Verilog memory and variable arrays using VPI routines, including Verilog HDL syntax examples for array declarations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p228.jpg,True,"```verilog
module b;
endmodule
```","
module b;
endmodule
","""Introduction to basic Verilog module structure and naming conventions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p186.jpg,True,"The image contains examples of Verilog code. Here are the two code snippets from the image:

**Sample 5.15 - The class scope resolution operator**
```verilog
class Transaction;
    static int count = 0; // Number of objects created
endclass

initial begin
    run_test();
    $display(""%0d transactions were created"",
             Transaction::count); // Reference static w/o handle
end
```

**Sample 5.16 - Static storage for a handle**
```verilog
class Transaction;
    static Config cfg; // A handle with static storage
endclass

initial begin
    Transaction::cfg = new(.num_trans(42));
end
```

These two code snippets demonstrate how to use static class variables in Verilog.","
class Transaction;
    static int count = 0; // Number of objects created
endclass

initial begin
    run_test();
    $display(""%0d transactions were created"",
             Transaction::count); // Reference static w/o handle
end


class Transaction;
    static Config cfg; // A handle with static storage
endclass

initial begin
    Transaction::cfg = new(.num_trans(42));
end
","Caption: ""A textbook excerpt explaining the concept of static variables vs. global variables in Verilog, including sample code for initialization and usage of static class members.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p98.jpg,True,"```c
#include <stdlib.h>  /* ANSI C standard library */
#include <stdio.h>   /* ANSI C standard input/output library */
#include <vpi_user.h>    /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h""    /* IEEE 1364 PLI TF routine library */
                        /* using TF routines for simulation control */

/* prototypes of the PLI application routines */
int PLIbook_ShowSignals_compiletf(), PLIbook_ShowSignals_calltf();
void PLIbook_PrintSignalValues();

/**********************************************************************
 * show_all_signals Registration Data
 * (add this function name to the vlog_startup_routines array)
 *********************************************************************/
void show_all_signals_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type      = vpiSysTask;
    tf_data.tfname    = ""$show_all_signals"";
    tf_data.calltf    = PLIbook_ShowSignals_calltf;
    tf_data.compiletf = PLIbook_ShowSignals_compiletf;
    tf_data.sizetf    = NULL;
    vpi_register_systf(&tf_data);
    return;
}

/**********************************************************************
 * compiletf routine
 *********************************************************************/
```","ude <stdlib.h>  /* ANSI C standard library */
#include <stdio.h>   /* ANSI C standard input/output library */
#include <vpi_user.h>    /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h""    /* IEEE 1364 PLI TF routine library */
                        /* using TF routines for simulation control */

/* prototypes of the PLI application routines */
int PLIbook_ShowSignals_compiletf(), PLIbook_ShowSignals_calltf();
void PLIbook_PrintSignalValues();

/**********************************************************************
 * show_all_signals Registration Data
 * (add this function name to the vlog_startup_routines array)
 *********************************************************************/
void show_all_signals_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type      = vpiSysTask;
    tf_data.tfname    = ""$show_all_signals"";
    tf_data.calltf    = PLIbook_ShowSignals_calltf;
    tf_data.compiletf = PLIbook_ShowSignals_compiletf;
    tf_data.sizetf    = NULL;
    vpi_register_systf(&tf_data);
    return;
}

/**********************************************************************
 * compiletf routine
 *********************************************************************/
",This image shows Verilog PLI (Programming Language Interface) code that includes a snippet of a test bench and registration data for showing all signals in a simulation.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p347.jpg,True,"The image contains descriptions and syntax for sequence operators in what appears to be a section from a textbook or manual related to hardware description language, specifically from a chapter on Property Specification Language (PSL) in relation to Verilog. Here are the bits of syntax provided for each operator:

Sequence fusion operator:
```
SERE ::= SERE : SERE
```

Sequence non-length-matching and operator:
```
SERE ::= SERE & SERE
```

Sequence length-matching and operator:
```
SERE ::= SERE && SERE
```

Sequence or operator:
```
SERE ::= SERE | SERE
```",":= SERE : SERE

:= SERE & SERE

:= SERE && SERE

:= SERE | SERE
","A page from a document describing various sequence operators in PSL (Property Specification Language) for use with Verilog code, including sequence fusion (:), sequence non-length-matching (&), sequence length-matching (&&), and sequence or (|) operators.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p200.jpg,True,"The image contains two examples of Verilog code, demonstrating two different approaches to a situation, labeled as ""Bad: Slow / Less Obvious"" and ""Good: Fast / Simple and Clear""

Here is the code for both:

a) Bad: Slow / Less Obvious
```verilog
input [N-1:0]a;
output [N-1:0]b;
integer i;
reg[N:1]0]b;
always @(a) begin
    for(i=0; i<=N-1; i=i+1)
        b[i] = ~a[i];
end
```

b) Good: Fast / Simple and Clear
```verilog
input [N-1:0]a;
output [N-1:0]b;
assign b = ~a;
```

These samples illustrate two different ways of writing Verilog code to achieve the same logical function but with different considerations for simulation performance and ease of understanding.","
input [N-1:0]a;
output [N-1:0]b;
integer i;
reg[N:1]0]b;
always @(a) begin
    for(i=0; i<=N-1; i=i+1)
        b[i] = ~a[i];
end


input [N-1:0]a;
output [N-1:0]b;
assign b = ~a;
","Caption: ""Comparison of inefficient versus efficient Verilog for loops for better simulation performance.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p498.jpg,True,"The image contains the following Verilog code:

```verilog
bit [1:0] a,c;
bit [3:0] b;

covergroup cg @(posedge clk);
  bc: coverpoint b {
    bins bb = {[0:12]};
    bins cc = {[13,14,15,16]};
  }

  ic: cross a, b, c {
    bins isect_ab = binsOf(bc) intersect {[0:1]};
    bins isect_nab = !(binsOf(bc) intersect {[0:3]});
  }
endgroup

gc cg_inst = new();
```

Additionally, there's some explanation about the bins and intersection operations. The image discusses the use of `intersect` with ranges and `binsOf` to specify which bins should be included in cross products for functional coverage in Verilog.","
bit [1:0] a,c;
bit [3:0] b;

covergroup cg @(posedge clk);
  bc: coverpoint b {
    bins bb = {[0:12]};
    bins cc = {[13,14,15,16]};
  }

  ic: cross a, b, c {
    bins isect_ab = binsOf(bc) intersect {[0:1]};
    bins isect_nab = !(binsOf(bc) intersect {[0:3]});
  }
endgroup

gc cg_inst = new();
","Caption: ""Explanation of 'binsof' and 'intersect' operators in Verilog covergroups used for functional coverage analysis.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p299.jpg,True,"The image contains the following Verilog code:

```verilog
property p_schkl1;
@(posedge clk)
$fell (framen) |->
lgntn[2] || $rose (gntn[2]);
endproperty

a_schkl1: assert property(p_schkl1);
c_schkl1: cover property(p_schkl1);
``` 

This code defines a property for SystemVerilog Assertions (SVA) which specifies behavior related to two signals `framen` and `gntn` with respect to a clock edge labeled `clk`. The property is then utilized in an assert and a cover statement, ensuring that the behavior or scenario the property describes is both verified to occur and covered in the testbench scenarios.","
property p_schkl1;
@(posedge clk)
$fell (framen) |->
lgntn[2] || $rose (gntn[2]);
endproperty

a_schkl1: assert property(p_schkl1);
c_schkl1: cover property(p_schkl1);
","""Example of SystemVerilog Assertions for Verifying a PCI Arbiter""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p275.jpg,True,"The image contains Verilog code within a text section about building a counter using consecutive repetition operator. Here is the code provided in the image:

```verilog
property checkCounter;
int LCount;
@(posedge clk) disable iff (!rst_n)
(
    ($rose(startCount), LCount=initCount ) ##1
    (1, LCount = LCount+1[*0:$] ##1 (LCount == maxCount) |-> (Intr == 1'b1)
);

endproperty
assert property (checkCounter);
```

This code is given as an example of how to build a counter using the consecutive repetition operator in SystemVerilog Assertions (SVA).","
property checkCounter;
int LCount;
@(posedge clk) disable iff (!rst_n)
(
    ($rose(startCount), LCount=initCount ) ##1
    (1, LCount = LCount+1[*0:$] ##1 (LCount == maxCount) |-> (Intr == 1'b1)
);

endproperty
assert property (checkCounter);
","Caption: ""Example of SystemVerilog Assertion to Build a Counter Using the Consecutive Repetition Operator""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p306.jpg,True,"The image contains text and a diagram related to Verilog, and there is indeed Verilog code present in the text. Here is the code from the image:

1. Logical expression:
```verilog
signal1 && signal2 && signal3
```

2. Temporal relationship assertion:
```verilog
signal1 ##[min:max] signal2
``` 

These snippets demonstrate logical and temporal relationships in Verilog assertions or conditions.","
signal1 && signal2 && signal3


signal1 ##[min:max] signal2
","""Exploring Assertions and Logical Expression Evaluation in Verilog for Design Verification""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p513.jpg,True,"The image contains Verilog code related to coverage options in a coverage group. Here is the code from the image:

```verilog
logic [15:0] addr, data;
covergroup cov1;
  cov1_covpoint: coverpoint addr;
  {
    bins zero = {0}; //1 bin for value 0
    bins low = {1:3}; //1 bin for values 1,2,3
    bins high [] = {4:$}; //explicit number of bins for all remaining values
    option.weight = 5; //coverpoint 'cov1_covpoint' has a weight of 5
  }
  
  cov2_covpoint: coverpoint data;
  {
    bins all = {0:$}; //1 bin for all values
    option.weight = 0; //No weight; Exclude coverage of this coverpoint towards total
  }

  cross cov1_covpoint, cov2_covpoint;
  {
    option.weight = 10; //Higher weight for this 'cross' towards total
  }
endgroup
```","
logic [15:0] addr, data;
covergroup cov1;
  cov1_covpoint: coverpoint addr;
  {
    bins zero = {0}; //1 bin for value 0
    bins low = {1:3}; //1 bin for values 1,2,3
    bins high [] = {4:$}; //explicit number of bins for all remaining values
    option.weight = 5; //coverpoint 'cov1_covpoint' has a weight of 5
  }
  
  cov2_covpoint: coverpoint data;
  {
    bins all = {0:$}; //1 bin for all values
    option.weight = 0; //No weight; Exclude coverage of this coverpoint towards total
  }

  cross cov1_covpoint, cov2_covpoint;
  {
    option.weight = 10; //Higher weight for this 'cross' towards total
  }
endgroup
","""Example of Verilog code demonstrating how to define and manipulate coverage bins and options in a coverage group.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p507.jpg,True,"There is Verilog code in the image. Here it is:

```verilog
covergroup rg;
  pc: coverpoint pendreq;
  gc: coverpoint numMasters;
endgroup

rg my_rg = new;

real cov;

always @(posedge req)
  my_rg.start( );

always @(posedge grant)
begin
  my_rg.sample( );
  cov = my_rg.get_inst_coverage( ); //Coverage information on my_rg instance of 'covergroup rg'
  if (cov > 90) my_rg.stop;
end
```

This Verilog code demonstrates how to define a coverage group, instantiate it, collect coverage data, and selectively stop collecting coverage based on a certain threshold to save simulation resources.","
covergroup rg;
  pc: coverpoint pendreq;
  gc: coverpoint numMasters;
endgroup

rg my_rg = new;

real cov;

always @(posedge req)
  my_rg.start( );

always @(posedge grant)
begin
  my_rg.sample( );
  cov = my_rg.get_inst_coverage( ); //Coverage information on my_rg instance of 'covergroup rg'
  if (cov > 90) my_rg.stop;
end
","Caption: ""Example of Verilog code demonstrating how to query and control code coverage collection in a simulation environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p312.jpg,True,"The image displays a page with text and Verilog code. Here is the code as written on the page:

```verilog
begin
  a <= logical_op_reg[0];
  b <= logical_op_reg[1];
  repeat(1) @(posedge clk);
  logical_op_reg++;
end
```

```verilog
// on a given clock edge the leading signal has a
// falling edge and the trailing signal has a
// falling edge

property p2_ff;
  @(posedge clk) $fell(a) && $fell(b);
endproperty

// on a given clock edge the leading signal has a
// falling edge and the trailing signal has a
// rising edge

property p2_fr;
  @(posedge clk) $fell(a) && $rose(b);
endproperty

// on a given clock edge the leading signal has a
// rising edge and the trailing signal has a
// falling edge

property p2_rf;
  @(posedge clk) $rose(a) && $fell(b);
endproperty

// on a given clock edge the leading signal has a
// rising edge and the trailing signal has a
// rising edge

property p2_rr;
  @(posedge clk) $rose(a) && $rose(b);
endproperty
``` 

These are examples of Verilog SystemVerilog properties for modeling edge sensitive behavior in verification environments.","
begin
  a <= logical_op_reg[0];
  b <= logical_op_reg[1];
  repeat(1) @(posedge clk);
  logical_op_reg++;
end


// on a given clock edge the leading signal has a
// falling edge and the trailing signal has a
// falling edge

property p2_ff;
  @(posedge clk) $fell(a) && $fell(b);
endproperty

// on a given clock edge the leading signal has a
// falling edge and the trailing signal has a
// rising edge

property p2_fr;
  @(posedge clk) $fell(a) && $rose(b);
endproperty

// on a given clock edge the leading signal has a
// rising edge and the trailing signal has a
// falling edge

property p2_rf;
  @(posedge clk) $rose(a) && $fell(b);
endproperty

// on a given clock edge the leading signal has a
// rising edge and the trailing signal has a
// rising edge

property p2_rr;
  @(posedge clk) $rose(a) && $rose(b);
endproperty
",Page from a textbook showing Verilog code for checking stimulus generation regarding edge-sensitive logical relationships.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p261.jpg,True,"The image contains Verilog code. Here it is:

```verilog
/* Checks for the Test-bench */
property check_full_write_en;
    @(posedge wclk) disable iff (!wclk_reset_n)
    full |-> !write_en; //Stop the testbench from writing to
                        // a FIFO that is full.
endproperty

check_full_write_enA : assert property (check_full_write_en)
    else $display($stime,,""m FAIL: check_full_write_en"");
check_full_write_enC : cover property (check_full_write_en)
    $display($stime,,""m PASS: check_full_write_en"");

property check_empty_read_en;
    @(posedge rclk) disable iff (!rclk_reset_n)
    empty |-> !read_en; //Stop the testbench from reading
                        // from an empty FIFO.
endproperty

check_empty_read_enA : assert property (check_empty_read_en)
    else $display($stime,,""FAIL: %m check_full_write_en"");
check_empty_read_enC : cover property (check_empty_read_en)
    $display($stime,,""PASS: %m check_full_write_en"");

//Here's where your testbench code goes.
endmodule
```

Please note that there might be a typo or copy error in the mentions of `%m check_full_write_en` in the `check_empty_read_enA` and `check_empty_read_enC` blocks—it seems it should reference `check_empty_read_en` instead since that is the property being checked in those blocks.","
/* Checks for the Test-bench */
property check_full_write_en;
    @(posedge wclk) disable iff (!wclk_reset_n)
    full |-> !write_en; //Stop the testbench from writing to
                        // a FIFO that is full.
endproperty

check_full_write_enA : assert property (check_full_write_en)
    else $display($stime,,""m FAIL: check_full_write_en"");
check_full_write_enC : cover property (check_full_write_en)
    $display($stime,,""m PASS: check_full_write_en"");

property check_empty_read_en;
    @(posedge rclk) disable iff (!rclk_reset_n)
    empty |-> !read_en; //Stop the testbench from reading
                        // from an empty FIFO.
endproperty

check_empty_read_enA : assert property (check_empty_read_en)
    else $display($stime,,""FAIL: %m check_full_write_en"");
check_empty_read_enC : cover property (check_empty_read_en)
    $display($stime,,""PASS: %m check_full_write_en"");

//Here's where your testbench code goes.
endmodule
","""Verilog test-bench with assertions for checking full and empty conditions in a FIFO design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p764.jpg,True,"The image contains function prototypes and descriptions from The Verilog PLI Handbook, which is related to the Verilog hardware description language and its Programming Language Interface (PLI). Here are the prototypes and structures presented in the image:

```c
char *acc_fetch_itarg_str(n)
char *acc_fetch_itfarg_str(n, tfinst)
int     n                // position number of a PLI system task/function arg.
handle  tfinst           // handle for an instance of a PLI system task/function

void acc_fetch_timescale_info(object, timescale)
handle  object                    // handle for a module instance, module definition, PLI system task/function, or null.
p_timescale_info timescale        // pointer to an application-allocated s_timescale_info structure to receive the timescale information.

typedef struct t_timescale_info {
  short unit;
  short precision;
} s_timescale_info, *p_timescale_info;

int acc_fetch_type(object)
handle  object           // handle for an object.

char *acc_fetch_type_str(type)
int     type             // type or fulltype constant.
```

These are not complete code examples but rather declarations and descriptions of API calls used within the context of Verilog PLI.","*acc_fetch_itarg_str(n)
char *acc_fetch_itfarg_str(n, tfinst)
int     n                // position number of a PLI system task/function arg.
handle  tfinst           // handle for an instance of a PLI system task/function

void acc_fetch_timescale_info(object, timescale)
handle  object                    // handle for a module instance, module definition, PLI system task/function, or null.
p_timescale_info timescale        // pointer to an application-allocated s_timescale_info structure to receive the timescale information.

typedef struct t_timescale_info {
  short unit;
  short precision;
} s_timescale_info, *p_timescale_info;

int acc_fetch_type(object)
handle  object           // handle for an object.

char *acc_fetch_type_str(type)
int     type             // type or fulltype constant.
","Excerpt from ""The Verilog PLI Handbook"" detailing the usage of ACC (access) routines for fetching argument strings, timescale information, and object types in Verilog.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p249.jpg,True,"The image contains examples of Verilog code related to the ""assume"" statement used in formal verification and simulation. Here are the excerpts of the code as they appear in the image:

```verilog
property gntReq;
    @(posedge clk) gnt |-> !req;
endproperty
aP1: assume property (gntReq);

property req2ack;
    @(posedge clk) req |-> req[!*:$] ##0 ack;
endproperty
aP2: assume property (req2ack);
```

In these examples, there are two properties defined: `gntReq` and `req2ack`. Following each property definition, there is an `assume property` statement (`aP1` and `aP2`) that directs the formal verification tool to assume the specified property is true during analysis.","
property gntReq;
    @(posedge clk) gnt |-> !req;
endproperty
aP1: assume property (gntReq);

property req2ack;
    @(posedge clk) req |-> req[!*:$] ##0 ack;
endproperty
aP2: assume property (req2ack);
","Caption: ""Exploring the 'assume' statement in Verilog for simulation and formal verification, with examples of its use in constraining environments and properties in hardware description language.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p770.jpg,True,"The image contains text describing functions from what appears to be the Verilog Programming Language Interface (PLI) Handbook, but there is no code present. The text includes function prototypes and explanations for several functions such as `handle_acc_handle_tfarg(n)`, `handle_acc_handle_itfarg(n, tfinst)`, `handle_acc_handle_tfinst()`, `bool acc_initialize()`, `handle acc_next(type_list, scope, prev_object)`, `handle acc_next_bit(vector, prev_bit)`, and `handle acc_next_cell(module, prev_cell)`.

Here's the content, but please note that this is not code, but API documentation:

```
handle_acc_handle_tfarg(n)
handle_acc_handle_itfarg(n, tfinst)
int          n               position number of a PLI system task/function argument.
handle    tfinst         handle for an instance of a PLI system task/function.

Returns a handle for the object named as an argument in the calling system task/ function or a specific instance of a system task/function. Arguments are numbered from left to right beginning with 1. If the argument is the name of a port, a handle for the loconn of the port (the internal signal connected to the port) is returned.

handle_acc_handle_tfinst()

Returns a handle for the system task/function which called the PLI application.

bool acc_initialize()

Initializes the ACC environment. Resets configurations to default values. Returns 1 if successful and 0 if an error occured.

handle acc_next(type_list, scope, prev_object)
int        *type_list   static array with list of type or fulltype constants.
handle    scope          handle for the scope in which to scan for objects.
handle    prev_object handle for the previous object found; initially null.

Returns the handle for the next object of the types listed in an array within the scope specified. Type and fulltype constants must be for modules, primitives, nets, regs, variables or parameters. See the object diagrams for the constant names.

handle acc_next_bit(vector, prev_bit)
handle   vector          handle for a port, net or path terminal.
handle   prev_bit        handle for the previous bit found; initially null.

Returns the handle for the next bit within a port, net or path terminal. For nets, acc_object_of_type(accExpandedVector) must return true and acc_object_of_type(accCollapsedNet) must return false.

handle acc_next_cell(module, prev_cell)
handle   module        handle for a module.
handle   prev_cell     handle for the previous cell found; initially null.

Returns the handle for the next cell module at or below the specified scope. A cell module is a module which is flagged with the `cell_define` compiler directive or was loaded using a library scan option.
```","_acc_handle_tfarg(n)
handle_acc_handle_itfarg(n, tfinst)
int          n               position number of a PLI system task/function argument.
handle    tfinst         handle for an instance of a PLI system task/function.

Returns a handle for the object named as an argument in the calling system task/ function or a specific instance of a system task/function. Arguments are numbered from left to right beginning with 1. If the argument is the name of a port, a handle for the loconn of the port (the internal signal connected to the port) is returned.

handle_acc_handle_tfinst()

Returns a handle for the system task/function which called the PLI application.

bool acc_initialize()

Initializes the ACC environment. Resets configurations to default values. Returns 1 if successful and 0 if an error occured.

handle acc_next(type_list, scope, prev_object)
int        *type_list   static array with list of type or fulltype constants.
handle    scope          handle for the scope in which to scan for objects.
handle    prev_object handle for the previous object found; initially null.

Returns the handle for the next object of the types listed in an array within the scope specified. Type and fulltype constants must be for modules, primitives, nets, regs, variables or parameters. See the object diagrams for the constant names.

handle acc_next_bit(vector, prev_bit)
handle   vector          handle for a port, net or path terminal.
handle   prev_bit        handle for the previous bit found; initially null.

Returns the handle for the next bit within a port, net or path terminal. For nets, acc_object_of_type(accExpandedVector) must return true and acc_object_of_type(accCollapsedNet) must return false.

handle acc_next_cell(module, prev_cell)
handle   module        handle for a module.
handle   prev_cell     handle for the previous cell found; initially null.

Returns the handle for the next cell module at or below the specified scope. A cell module is a module which is flagged with the `cell_define` compiler directive or was loaded using a library scan option.
","""Reference page from the Verilog PLI Handbook containing function descriptions for interacting with Verilog data structures using the PLI (Programming Language Interface).""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p227.jpg,True,"The image includes Verilog code snippets. Here they are transcribed for you:

```verilog
// time-bounded combination pattern
assert property(@(posedge clk) disable iff ( rst_n )
                ($rose(Flush) |-> ##[1:100] !IntlFlushAck))
else $error(""Flush took too long (>100 cycles) to complete."");
```

```verilog
// pipelined-protocol pattern
// See pipelined_reqack template definition in Example 6-44

pipelined_reqack
sendReadReq(.req(SMQueueNew & !SMQueueWrEn), .valin(SmQueueAddr),
            .ack(EngMemRd),
            .dataout(EngMemAddr),
            .clk(clk), .latency(100), .pipdepth(6));
```

```verilog
// pipelined-protocol pattern
// See pipelined_reqack template definition in Example 6-44

pipelined_reqack
receiveData (.req(SmQueueNew & !SMQueueWrEn), .req_datain(),
             .ack(QueueBufValid),
             .dataout(),
             .clk(clk), .latency(100), .pipdepth(6));
```

Please note that in the second and third snippets, `pipelined_reqack` appears to be a custom construct or a macro, since it's not a standard Verilog statement as is. You would need the definition from ""Example 6-44"" as mentioned in the comments to fully understand and use these code snippets.","
// time-bounded combination pattern
assert property(@(posedge clk) disable iff ( rst_n )
                ($rose(Flush) |-> ##[1:100] !IntlFlushAck))
else $error(""Flush took too long (>100 cycles) to complete."");


// pipelined-protocol pattern
// See pipelined_reqack template definition in Example 6-44

pipelined_reqack
sendReadReq(.req(SMQueueNew & !SMQueueWrEn), .valin(SmQueueAddr),
            .ack(EngMemRd),
            .dataout(EngMemAddr),
            .clk(clk), .latency(100), .pipdepth(6));


// pipelined-protocol pattern
// See pipelined_reqack template definition in Example 6-44

pipelined_reqack
receiveData (.req(SmQueueNew & !SMQueueWrEn), .req_datain(),
             .ack(QueueBufValid),
             .dataout(),
             .clk(clk), .latency(100), .pipdepth(6));
","""Examples of SystemVerilog Assertions for Synchronous Interface Operations and Inter-Interface Protocol Timing Constraints""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p203.jpg,True,"```verilog
covergroup cg (ref int ra, int low, int high )
  @(posedge clk);
  coverpoint ra; // sample variable passed by reference
    bins good = { [low : high] };
  bins bad[] = default;
endgroup

initial begin
  int va, vb;
  int min=0, max=50;
  cg c1 = new(va, min, max);  // OK
  cg c2 = new(vb, 0, 50);    // GOTCHA! cannot pass constants
                              // to ref args
end
```

In the given image, there are code snippets related to the use of covergroup in Verilog for hardware verification, and the snippet is demonstrating an issue with passing constant values to a reference argument in a covergroup constructor.","
covergroup cg (ref int ra, int low, int high )
  @(posedge clk);
  coverpoint ra; // sample variable passed by reference
    bins good = { [low : high] };
  bins bad[] = default;
endgroup

initial begin
  int va, vb;
  int min=0, max=50;
  cg c1 = new(va, min, max);  // OK
  cg c2 = new(vb, 0, 50);    // GOTCHA! cannot pass constants
                              // to ref args
end
",Explaining the 'sticky' argument direction behavior in Verilog covergroups and a common mistake of passing constants to `ref` arguments.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p233.jpg,True,"The image contains Verilog code. Here is the code from the image:

```verilog
// use two decoded pointers starting with value 1
// when pointers are equal (and full is not set) FIFO is empty
parameter FIFO_depth=16;
reg [FIFO_depth-1:0] rdptr, wrptr;
reg                    full;
reg                    empty;

always @ (posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        rdptr <= 1;
        wrptr <= 1;
        full <= 0;
        ...
    end
    case ({push, pop})
    2’b10 : // WRITE
    begin
        // rotate the write pointer, set full if update will match rdptr
        wrptr <= {wrptr[FIFO_depth-2:0], wrptr[FIFO_depth-1]};
        full <= rdptr == {wrptr[FIFO_depth-2:0], wrptr[FIFO_depth-1]};
    end
    2’b01 : // READ
    begin
        // rotate read pointer, clear full since we can’t
        rdptr <= {rdptr[FIFO_depth-2:0], rdptr[FIFO_depth-1]};
        full <= 1’b0;
        ...
    end
```

There's also a section on PSL FIFO overflow assertion which has the following assertions:

```verilog
assert never (cnt == FIFO_depth & push & !pop); // for Example 7-1
assert never (full & push & !pop);              // for Example 7-2
```","
// use two decoded pointers starting with value 1
// when pointers are equal (and full is not set) FIFO is empty
parameter FIFO_depth=16;
reg [FIFO_depth-1:0] rdptr, wrptr;
reg                    full;
reg                    empty;

always @ (posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        rdptr <= 1;
        wrptr <= 1;
        full <= 0;
        ...
    end
    case ({push, pop})
    2’b10 : // WRITE
    begin
        // rotate the write pointer, set full if update will match rdptr
        wrptr <= {wrptr[FIFO_depth-2:0], wrptr[FIFO_depth-1]};
        full <= rdptr == {wrptr[FIFO_depth-2:0], wrptr[FIFO_depth-1]};
    end
    2’b01 : // READ
    begin
        // rotate read pointer, clear full since we can’t
        rdptr <= {rdptr[FIFO_depth-2:0], rdptr[FIFO_depth-1]};
        full <= 1’b0;
        ...
    end


assert never (cnt == FIFO_depth & push & !pop); // for Example 7-1
assert never (full & push & !pop);              // for Example 7-2
","""Verilog code snippet illustrating FIFO implementation with read and write pointers and assertions to prevent FIFO overflow.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p129.jpg,True,"The image contains Verilog code as follows:

```verilog
assign Packet[63:56] = Data3;
assign Packet[55:48] = Pad3; ... etc. ...
```

The code shows the use of continuous assignment in Verilog to assign values to specific bit ranges within a packet, with `Data3` and `Pad3` apparently representing data values. The ellipsis suggests that the pattern continues for other portions of the packet.","
assign Packet[63:56] = Data3;
assign Packet[55:48] = Pad3; ... etc. ...
","Caption: ""Extract from a digital design textbook discussing the assignment of packet data in Verilog code and outlining the design of a SerFrameEnc module for encoding framed data, with mention of simulation and synthesis for area and speed optimization.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p227.jpg,True,"The image contains Verilog code within a textbook example. Here is the code snippet:

```verilog
class Unconstrained;
  rand bit x;           // 0 or 1
  rand bit [1:0] y;     // 0, 1, 2, or 3
endclass
```","
class Unconstrained;
  rand bit x;           // 0 or 1
  rand bit [1:0] y;     // 0, 1, 2, or 3
endclass
","""Exploring Solution Probabilities for Unconstrained Random Variables in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p189.jpg,True,"```verilog
assign c_bp_hdr_val = (r_hdr_valids_1 == 11'h0b0) &&
                      (r_hdr_valids == 11'h400);
```","
assign c_bp_hdr_val = (r_hdr_valids_1 == 11'h0b0) &&
                      (r_hdr_valids == 11'h400);
","Caption: ""Best practices for non-proprietary Verilog coding style including embedded comments and an example of an assignment statement in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p39.jpg,True,"The image contains Verilog code. Here is the code written in the image:

```verilog
sequence s3_lib (a, b) ;
    a || b;
endsequence

sequence s3_lib_inst1;
    s3_lib(req1, req2);
```

This code snippet defines a sequence `s3_lib` with formal arguments `a` and `b`. The sequence passes if either `a` or `b` is true (`||` is the logical OR operator). The `endsequence` keyword denotes the end of the sequence definition.

Then, an instance of this sequence is created with the name `s3_lib_inst1`, which re-uses `s3_lib` with actual signals `req1` and `req2` passed as arguments.","
sequence s3_lib (a, b) ;
    a || b;
endsequence

sequence s3_lib_inst1;
    s3_lib(req1, req2);
","""Understanding Sequence Expressions in Verilog with Waveform Example and Code Snippets""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p228.jpg,True,"The image contains Verilog code related to using the Programming Language Interface (PLI) of Verilog. The PLI allows users to write C/C++ programs that can interact with Verilog simulations. Here is the code from the image:

```verilog
#include ""veriusert.h"" /* IEEE 1364 PLI TF routine library
                            (using TF routines for simulation control) */

/* prototypes of routines in this PLI application */
int PLIbook_MyStrobe_calltf(), PLIbook_MyStrobe_compiletf(),
    PLIbook_EndOfTimeStep_callback();

/**********************************************************************
 * VPI Registration Data
 *********************************************************************/
void PLIbook_MyStrobe_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type        = vpiSysTask;
    tf_data.tfname      = ""$my_strobe"";
    tf_data.calltf      = PLIbook_MyStrobe_calltf;
    tf_data.compiletf   = PLIbook_MyStrobe_compiletf;
    tf_data.sizetf      = NULL;
    tf_data.user_data   = NULL;
    vpi_register_systf(&tf_data);
}

/**********************************************************************
 * callback application
 *********************************************************************/
PLIbook_MyStrobe_calltf(char *user_data)
{
    vpiHandle       systf_h, arg_itr, arg_h;
    s_vpi_time      time_s;
    s_cb_data       cb_data_s;

    /* obtain a handle to the system task instance */
    systf_h = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handle to system task argument; */
    /* compiletf has already verified only 1 arg with correct type */
    arg_itr = vpi_iterate(vpiArgument, systf_h);
    arg_h = vpi_scan(arg_itr);
    vpi_free_object(arg_itr); /* free iterator--did not scan to null */

    /* setup end-of-time step callback */
    time_s.low = 0;
    time_s.high = 0;
    time_s.type = vpiSimTime;
    cb_data_s.reason    = cbReadOnlySynch;
    cb_data_s.user_data = (char *)arg_h;
    cb_data_s.cb_rtn    = PLIbook_EndOfTimeStep_callback;
    cb_data_s.obj       = arg_h;
    cb_data_s.time      = &time_s;
    cb_data_s.value     = NULL;
    vpi_register_cb(&cb_data_s);
}
```

This code snippet is setting up a system task (`$my_strobe`) and a callback for a simulation time step. The `vpi_register_systf()` function is used to register the system task, while the `vpi_register_cb()` function is used to register a callback that is invoked at a specific time of the simulation. The callback function is named `PLIbook_EndOfTimeStep_callback`, but its definition is not provided in this snippet.","
#include ""veriusert.h"" /* IEEE 1364 PLI TF routine library
                            (using TF routines for simulation control) */

/* prototypes of routines in this PLI application */
int PLIbook_MyStrobe_calltf(), PLIbook_MyStrobe_compiletf(),
    PLIbook_EndOfTimeStep_callback();

/**********************************************************************
 * VPI Registration Data
 *********************************************************************/
void PLIbook_MyStrobe_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type        = vpiSysTask;
    tf_data.tfname      = ""$my_strobe"";
    tf_data.calltf      = PLIbook_MyStrobe_calltf;
    tf_data.compiletf   = PLIbook_MyStrobe_compiletf;
    tf_data.sizetf      = NULL;
    tf_data.user_data   = NULL;
    vpi_register_systf(&tf_data);
}

/**********************************************************************
 * callback application
 *********************************************************************/
PLIbook_MyStrobe_calltf(char *user_data)
{
    vpiHandle       systf_h, arg_itr, arg_h;
    s_vpi_time      time_s;
    s_cb_data       cb_data_s;

    /* obtain a handle to the system task instance */
    systf_h = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handle to system task argument; */
    /* compiletf has already verified only 1 arg with correct type */
    arg_itr = vpi_iterate(vpiArgument, systf_h);
    arg_h = vpi_scan(arg_itr);
    vpi_free_object(arg_itr); /* free iterator--did not scan to null */

    /* setup end-of-time step callback */
    time_s.low = 0;
    time_s.high = 0;
    time_s.type = vpiSimTime;
    cb_data_s.reason    = cbReadOnlySynch;
    cb_data_s.user_data = (char *)arg_h;
    cb_data_s.cb_rtn    = PLIbook_EndOfTimeStep_callback;
    cb_data_s.obj       = arg_h;
    cb_data_s.time      = &time_s;
    cb_data_s.value     = NULL;
    vpi_register_cb(&cb_data_s);
}
","""Example of Verilog PLI code for registering a system task and setting up callbacks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p233.jpg,True,"The image contains an example of SystemVerilog code. Here is the code snippet from the image:

```verilog
class Transaction;
  rand bit [31:0] addr, data;
  constraint c1 {addr inside{[0:100],[1000:2000]};}
endclass

initial begin
  Transaction t;
  t = new();

  // addr is 50-100, 1000-1500, data < 10
  `SV_RAND_CHECK(t.randomize() with {addr >= 50; addr <= 1500;
                                      data < 10;});

  driveBus(t);

  // force addr to a specific value, data > 10
  `SV_RAND_CHECK(t.randomize() with {addr == 2000; data > 10;});

  driveBus(t);
end
```

This code snippet demonstrates how to use the randomize() function with specific constraints within a SystemVerilog class definition.","
class Transaction;
  rand bit [31:0] addr, data;
  constraint c1 {addr inside{[0:100],[1000:2000]};}
endclass

initial begin
  Transaction t;
  t = new();

  // addr is 50-100, 1000-1500, data < 10
  `SV_RAND_CHECK(t.randomize() with {addr >= 50; addr <= 1500;
                                      data < 10;});

  driveBus(t);

  // force addr to a specific value, data > 10
  `SV_RAND_CHECK(t.randomize() with {addr == 2000; data > 10;});

  driveBus(t);
end
","""Example of using randomized constraints in Verilog for addressing and data generation within a class.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p217.jpg,True,"```verilog
module m(logic clk, rst, send, ack, ...);
  import check_lib::*;
  ...
  request_granted_ack_received(send, ack, 1, posedge clk, rst);
endmodule : m

check_lib::request_granted_ack_received(
  send, ack, 1, posedge clk, rst);
```","
module m(logic clk, rst, send, ack, ...);
  import check_lib::*;
  ...
  request_granted_ack_received(send, ack, 1, posedge clk, rst);
endmodule : m

check_lib::request_granted_ack_received(
  send, ack, 1, posedge clk, rst);
","""Verilog Code Snippet: Importing and Instantiating a Checker Module""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p39.jpg,True,"The image contains text describing assertion statements in SystemVerilog Assertion (SVA) and it includes example code. Here is the code excerpt:

```verilog
bit ok;
// ...
a1: assert property (@(clk) ok);
m1: assume property (@(clk) ok);
c1: cover property (@(clk) ok);
``` 

This code snippet demonstrates the usage of `assert`, `assume`, and `cover` properties in the context of a signal `ok` being checked at clock events signaled by `clk`.","
bit ok;
// ...
a1: assert property (@(clk) ok);
m1: assume property (@(clk) ok);
c1: cover property (@(clk) ok);
","A textbook excerpt explaining the use of assertion statements in SystemVerilog with examples of `assert`, `assume`, and `cover` properties in a code snippet.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p571.jpg,True,"The image contains Verilog code snippets. Here is the code written in the image:

```verilog
int severity_level = `OVL_SEVERITY_DEFAULT,
int min_ack_cycle  = 0,
int max_ack_cycle  = 0,
int req_drop       = 0, // these three arguments
int deassert_count = 0, // may not be needed
int max_ack_length = 0, // since req is a sequence
int property_type  = `OVL_PROPERTY_DEFAULT,
string msg         = `OVL_MSG_DEFAULT,
int coverage_level = `OVL_COVER_DEFAULT,
int synthesis      = `SYNTHESIS,
output [`OVL_FIRE_WIDTH-1:0] fire
);
//...
generate // elaboration-time constant checks at compile time
if (min_ack_cycle < 0)
$error(""min_ack_cycle is negative"");
if (max_ack_cycle < min_ack_cycle) $error(
""max_ack_cycle is less than min_ack_cycle"");
if (req_drop < 0 || req_drop > 1) $warning(
""req_drop `%0d is not 0 or 1"",
req_drop, ""positive assumed 1"",
""anything less than 1 assumed 0"");
// ... checks for other arguments ...
endgenerate

default clocking checker_clk @clk; endclocking
default disable iff (reset); 
assign fire = {`OVL_FIRE_WIDTH{1'b0}}; // Tied low in V2.3
//... Body of the checker ...
endchecker : assert_handshake
```

The additional information talks about the instantiation of checker-based Verilog checkers and missing parameters in the context of the original checker code. The missing parameters are:

```verilog
parameter clock_edge    = `OVL_CLOCK_EDGE_DEFAULT;
parameter reset_polarity = `OVL_RESET_POLARITY_DEFAULT;
parameter gating_type   = `OVL_GATING_TYPE_DEFAULT;
```

It also explains why certain parameters are not needed due to the ability to use event expressions and contextual default expressions in Verilog.","
int severity_level = `OVL_SEVERITY_DEFAULT,
int min_ack_cycle  = 0,
int max_ack_cycle  = 0,
int req_drop       = 0, // these three arguments
int deassert_count = 0, // may not be needed
int max_ack_length = 0, // since req is a sequence
int property_type  = `OVL_PROPERTY_DEFAULT,
string msg         = `OVL_MSG_DEFAULT,
int coverage_level = `OVL_COVER_DEFAULT,
int synthesis      = `SYNTHESIS,
output [`OVL_FIRE_WIDTH-1:0] fire
);
//...
generate // elaboration-time constant checks at compile time
if (min_ack_cycle < 0)
$error(""min_ack_cycle is negative"");
if (max_ack_cycle < min_ack_cycle) $error(
""max_ack_cycle is less than min_ack_cycle"");
if (req_drop < 0 || req_drop > 1) $warning(
""req_drop `%0d is not 0 or 1"",
req_drop, ""positive assumed 1"",
""anything less than 1 assumed 0"");
// ... checks for other arguments ...
endgenerate

default clocking checker_clk @clk; endclocking
default disable iff (reset); 
assign fire = {`OVL_FIRE_WIDTH{1'b0}}; // Tied low in V2.3
//... Body of the checker ...
endchecker : assert_handshake


parameter clock_edge    = `OVL_CLOCK_EDGE_DEFAULT;
parameter reset_polarity = `OVL_RESET_POLARITY_DEFAULT;
parameter gating_type   = `OVL_GATING_TYPE_DEFAULT;
",Excerpt from a Verilog reference discussing checker libraries and showing a code snippet with default parameter values and conditional checks in Verilog.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p138.jpg,True,"The image contains text and Verilog code related to SystemVerilog Assertions (SVA). Here's the code extracted from the image:

```verilog
assign trdyP = trdy[1] && trdy[0];

property p_end_frame;
    @(posedge clk)
        $rose (frame && irdy) |-> ##2 $rose(trdyP);
endproperty

property p_bus_not_in_use;
    @(posedge clk)
        trdyP |->
            ($isunknown(data) && $isunknown(datao));
endproperty

a_target : assert property(p_target);
a_frame : assert property(p_frame);
a_irdy: assert property(p_irdy);
a_rsel: assert property(p_rsel);
a_rw: assert property(p_rw);
a_gnt: assert property(p_gnt);
a_req_gnt_w : assert property(p_req_gnt_w);
a_start_frame: assert property(p_start_frame);
a_end_frame: assert property(p_end_frame);
a_bus_in_use: assert property(p_bus_not_in_use);

c_target : cover property(p_target);
c_frame: cover property(p_frame);
c_irdy: cover property(p_irdy);
c_rsel: cover property(p_rsel);
c_rw: cover property(p_rw);
c_gnt: cover property(p_gnt);
c_req_gnt_w : cover property(p_req_gnt_w);
c_start_frame: cover property(p_start_frame);
c_end_frame: cover property(p_end_frame);
c_bus_in_use: cover property(p_bus_not_in_use);
```
This code appears to define properties and assertions for verification purposes using SystemVerilog Assertion constructs. Properties like `p_end_frame` and `p_bus_not_in_use` dictate certain requirements during simulation. Assertions and coverage points such as `a_target` and `c_target` check if these requirements are met during simulation.","
assign trdyP = trdy[1] && trdy[0];

property p_end_frame;
    @(posedge clk)
        $rose (frame && irdy) |-> ##2 $rose(trdyP);
endproperty

property p_bus_not_in_use;
    @(posedge clk)
        trdyP |->
            ($isunknown(data) && $isunknown(datao));
endproperty

a_target : assert property(p_target);
a_frame : assert property(p_frame);
a_irdy: assert property(p_irdy);
a_rsel: assert property(p_rsel);
a_rw: assert property(p_rw);
a_gnt: assert property(p_gnt);
a_req_gnt_w : assert property(p_req_gnt_w);
a_start_frame: assert property(p_start_frame);
a_end_frame: assert property(p_end_frame);
a_bus_in_use: assert property(p_bus_not_in_use);

c_target : cover property(p_target);
c_frame: cover property(p_frame);
c_irdy: cover property(p_irdy);
c_rsel: cover property(p_rsel);
c_rw: cover property(p_rw);
c_gnt: cover property(p_gnt);
c_req_gnt_w : cover property(p_req_gnt_w);
c_start_frame: cover property(p_start_frame);
c_end_frame: cover property(p_end_frame);
c_bus_in_use: cover property(p_bus_not_in_use);
","""Verilog Assertions and Properties for Simulation Methodology""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p566.jpg,True,"The image contains a snippet of code that is a C struct definition. Here is the code:

```c
typedef struct t_acc_time
{
    int type;
    int low;
    int high;
    double real;
} s_acc_time, *p_acc_time;
```

This code defines a structure `t_acc_time` with members `type`, `low`, `high`, and `real`, and it creates a type alias `s_acc_time` for the structure as well as a pointer type `p_acc_time` to the structure.","ef struct t_acc_time
{
    int type;
    int low;
    int high;
    double real;
} s_acc_time, *p_acc_time;
","""Excerpt from a textbook on ACC (Application Call Interface) routines in PLI (Programming Language Interface) for modifying values in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p565.jpg,True,"The image contains Verilog code. Here it is:

Example 24.2. let-based checker (in a package)
```verilog
let onehot0 (sig, reset = 1'b1) = 
`ifdef SYNTHESIS
// Selected for synthesis or formal
!|preset || !$onehot0(sig);
`else
// Selected for 4-valued simulation
reset === 0 ||
($onehot0(sig) && !$isunknown(reset_n);
`endif
```

Example 24.3. let-based checker instantiation
```verilog
module m (input logic [3:0] r1,
          output logic [3:0] r2);
  a1: assert final (onehot0(r1));
```","
let onehot0 (sig, reset = 1'b1) = 
`ifdef SYNTHESIS
// Selected for synthesis or formal
!|preset || !$onehot0(sig);
`else
// Selected for 4-valued simulation
reset === 0 ||
($onehot0(sig) && !$isunknown(reset_n);
`endif


module m (input logic [3:0] r1,
          output logic [3:0] r2);
  a1: assert final (onehot0(r1));
","Caption: ""Verilog code examples demonstrating a simple combinational checker and how it can be instantiated using a let declaration and an assert statement.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p214.jpg,True,"The image contains text regarding the Verilog Procedural Interface (VPI) routine for removing scheduled callbacks, as well as information about simulation action and simulation feature callbacks defined in the IEEE 1364 standard. There is a snippet of code in the image, which is a function prototype in C language syntax used for interfacing with Verilog simulations:

```c
int vpi_remove_cb(vpiHandle cb_object)
```

Please note that this is a function prototype, which declares the `vpi_remove_cb` function that takes a `vpiHandle` named `cb_object` as an argument and returns an `int`. This function is used to remove a previously scheduled callback in a PLI application.","pi_remove_cb(vpiHandle cb_object)
","""Documentation excerpt discussing the removal of scheduled callbacks and VPI simulation action callback constants in Verilog PLI.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p203.jpg,True,"Here is the Verilog code from the image:

```verilog
module m_seqprotocol1 #(parameter int bothedges = 0,
                        parameter type dataType = logic)
                       (input logic start, complete, clk, reset,
                        dataType dataIn, dataOut);
   if (bothedges) begin : L
      default clocking dclk @(clk); endclocking
   end
   else begin : L
      default clocking dclk @(posedge clk); endclocking
   end
   default disable iff reset;

   property match(x, y);
      x |-> !x until_with y;
   endproperty : match

   var type(dataIn) last_dataIn;

   always @L.dclk
      if (!$sampled(start))
         last_dataIn <= $sampled(dataIn);

   a_initial_no_complete:
      assert property ($fell(reset) |-> !complete until_with start);

   a_seq_data_check: assert property (
      $rose(complete) |-> dataOut == last_dataIn);
   a_no_start: assert property (match(start, complete));
   a_no_complete: assert property (match(complete, start));
endmodule : m_seqprotocol
```

This code snippet appears to define a module for a sequential protocol in Verilog with parameters for edge sensitivity and data type, inputs for signals and data, and uses assertions for property checking.","
module m_seqprotocol1 #(parameter int bothedges = 0,
                        parameter type dataType = logic)
                       (input logic start, complete, clk, reset,
                        dataType dataIn, dataOut);
   if (bothedges) begin : L
      default clocking dclk @(clk); endclocking
   end
   else begin : L
      default clocking dclk @(posedge clk); endclocking
   end
   default disable iff reset;

   property match(x, y);
      x |-> !x until_with y;
   endproperty : match

   var type(dataIn) last_dataIn;

   always @L.dclk
      if (!$sampled(start))
         last_dataIn <= $sampled(dataIn);

   a_initial_no_complete:
      assert property ($fell(reset) |-> !complete until_with start);

   a_seq_data_check: assert property (
      $rose(complete) |-> dataOut == last_dataIn);
   a_no_start: assert property (match(start, complete));
   a_no_complete: assert property (match(complete, start));
endmodule : m_seqprotocol
","Caption: ""Example of a Verilog module for a sequential protocol specification with parameterized clocking and properties for formal verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p317.jpg,True,"The image contains text discussing digital VLSI design using Verilog, and includes two snippets of Verilog code:

1. A snippet illustrating how to define a Verilog timescale using `mintypmax` expressions:

```verilog
or #(1:2:3) or_01(out_or, in1, in2, in3, in4);
```

2. A snippet with a Verilog primitive instantiation that models a gate with a slow turnoff:

```verilog
bufif1 #(1:3:4, 1:2:4, 6:7:8) triBuf_2057(OutBit, InBit, CtlBit);
```","
or #(1:2:3) or_01(out_or, in1, in2, in3, in4);


bufif1 #(1:3:4, 1:2:4, 6:7:8) triBuf_2057(OutBit, InBit, CtlBit);
","The image shows a textbook page discussing aspects of digital VLSI design with Verilog, including the use of min/typ/max values in simulations and a mention of switch-level components in Verilog. The page includes a written example of a Verilog code snippet.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p534.jpg,True,"The image contains pseudo code related to list manipulation algorithms, specifically for list reversing. Here is the code excerpt from the image:

```plaintext
1: while i ≠ null do
2:     k := i.next;
3:     i.next := j;
4:     j := i;
5:     i := k;
6: od
```

This pseudo code is part of an algorithm to reverse a linked list. The loop continues as long as 'i' (which can be assumed to be a pointer to the current element in the list) is not equal to 'null'. Inside the loop, 'k' is used to store the next element, 'i.next' is updated to point to 'j' (initially this might be 'null', effectively reversing the direction of the list), 'j' is updated to the current element, and 'i' is moved to the next element, which was saved in 'k'. Once 'i' is 'null', the loop stops, meaning the end of the list has been reached and the list has been reversed. The 'od' denotes the end of the while loop in some pseudo code notation systems.","xt
1: while i ≠ null do
2:     k := i.next;
3:     i.next := j;
4:     j := i;
5:     i := k;
6: od
","Caption: ""Excerpt from a technical document discussing the operational semantics of programs with counters and lists in Verilog, alongside an example code snippet depicting list reversing.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p176.jpg,True,"This image contains an excerpt of Verilog code. Here is the code snippet:

```verilog
assign erac0.core.in_p3_pkt_info.r5.scan_in[2:0] = {
erac0.core.in_p3_pkt_info.r5.iq[1],
erac0.core.out_m1.mux.r2.q[3],
erac0.core.in_p3_read_1.r2.q[4]};
```","
assign erac0.core.in_p3_pkt_info.r5.scan_in[2:0] = {
erac0.core.in_p3_pkt_info.r5.iq[1],
erac0.core.out_m1.mux.r2.q[3],
erac0.core.in_p3_read_1.r2.q[4]};
","Caption: ""Excerpt from a textbook discussing hierarchical naming and global/local name space considerations in Verilog coding for system-on-chip design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p458.jpg,True,"The image contains excerpts from a document that includes some code regarding Verilog. Here is the code present in the image:

```verilog
assign F_Valid = !F_Empty && !Reset;

assign F_ReadReq = !F_Empty && SerEncReadReq && SendSerial;

assign F_WriteReq = !F_Full && InParValid;
```

This code uses continuous assignment statements to assign values to the `F_Valid`, `F_ReadReq`, and `F_WriteReq` signals based on the specified conditions. These seem to be control signals for a FIFO (First-In-First-Out) buffer as part of a Serializer design, where:

- `F_Valid` is asserted when the FIFO is not empty and the system is not in reset.
- `F_ReadReq` is asserted when the FIFO is not empty, the Serializer Encoder Read Request (`SerEncReadReq`) is asserted, and the `SendSerial` signal is asserted.
- `F_WriteReq` is asserted when the FIFO is not full and the input parallel valid (`InParValid`) is asserted.

These signals are likely to be used in managing the flow of data through a FIFO buffer during serialization.","
assign F_Valid = !F_Empty && !Reset;

assign F_ReadReq = !F_Empty && SerEncReadReq && SendSerial;

assign F_WriteReq = !F_Full && InParValid;
","""Text excerpt on designing a Serializer in Verilog with directions for FIFO interface and control signal assignments.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p163.jpg,True,"```verilog
module dff_tri(qpin,qin,ck,dis);
parameter w = 3;
output [w-1:0] pin;
input [w-1:0] qin;
input ck;
input dis;
reg [w-1:0] qout;
always @(posedge ck)
  qout <= qin;
tri [w-1:0] pin = dis ? qout : {w{1'bZ}};
endmodule // dff_tri
```","
module dff_tri(qpin,qin,ck,dis);
parameter w = 3;
output [w-1:0] pin;
input [w-1:0] qin;
input ck;
input dis;
reg [w-1:0] qout;
always @(posedge ck)
  qout <= qin;
tri [w-1:0] pin = dis ? qout : {w{1'bZ}};
endmodule // dff_tri
","""Verilog example of a D flip-flop with a tri-state buffer module and description on handling tri-state buses in digital design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p509.jpg,True,"The image contains Verilog code for an operation named `func`. Here is the code:

```verilog
var arr : array[8] of int

op func(int index) returns int
    if (index < 0) then
        return 0
    else
        return arr[index]
    endif
endop
```","
var arr : array[8] of int

op func(int index) returns int
    if (index < 0) then
        return 0
    else
        return arr[index]
    endif
endop
","""Verilog function implementation and formula transformation for bounded model checking of concurrent data types""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p316.jpg,True,"The image contains a snippet of a document with text and small examples of delay value assignments in Verilog code. Here is the code:

```verilog
#t inst_name(...);
#(tr, tf) inst_name(...);
#(tr, tf, tz) inst_name(...);
```

The comment section describes the meaning of the values `t`, `tr`, `tf`, and `tz` used as delay specifications in Verilog modules.","
#t inst_name(...);
#(tr, tf) inst_name(...);
#(tr, tf, tz) inst_name(...);
","Caption: ""Verilog Timing Annotations and Delay Considerations in VLSI Design""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p598.jpg,True,"The image contains text with function prototypes and calls that are related to Verilog or a related simulation environment, but not actual source code. Nevertheless, I will provide you with the text related to the function calls:

```c
acc_configure(accPathDelayCount, ""1"");
acc_configure(accPathDelayCount, ""2"");
acc_configure(accPathDelayCount, ""3"");
acc_configure(accPathDelayCount, ""6"");
acc_configure(accPathDelayCount, ""12"");
```

The text also mentions that the default configuration is ""6"". These are function calls in C that configure something called `accPathDelayCount` with string arguments representing different values.","onfigure(accPathDelayCount, ""1"");
acc_configure(accPathDelayCount, ""2"");
acc_configure(accPathDelayCount, ""3"");
acc_configure(accPathDelayCount, ""6"");
acc_configure(accPathDelayCount, ""12"");
","""ACC (Access) Routines in Verilog for Handling Pulse Limits and Path Delay Configuration""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p202.jpg,True,"The image contains Verilog code. Here is the text of the code as shown in the image:

```verilog
module m_seqprotocol #(parameter type dataType = logic)
                      (input logic start, complete, clk, rst,
                       dataType dataIn, dataOut);

logic go, done, clock, reset;
logic [31:0] din, dout;

// The instantiation of module m_seqprotocol is as follows:
m_seqprotocol #( .dataType(logic [31:0])) inst1 (
    go, done, clock, reset, din, dout);

// If we want the specification be clocked by negedge clock instead of posedge clock,
// we simply need to pass the negation of clock:
m_seqprotocol #( .dataType(logic [31:0])) inst2 (
    go, done, !clock, reset, din, dout);

m_seqprotocol #( .dataType(logic [31:0]), .bothedges(1)) inst3 (
    go, done, clock, din, dout);
```

The given code provides an example of defining a Verilog module with a parameterized type and its instantiation with specific arguments. It also demonstrates using different clock edge sensitivities during instantiation.","
module m_seqprotocol #(parameter type dataType = logic)
                      (input logic start, complete, clk, rst,
                       dataType dataIn, dataOut);

logic go, done, clock, reset;
logic [31:0] din, dout;

// The instantiation of module m_seqprotocol is as follows:
m_seqprotocol #( .dataType(logic [31:0])) inst1 (
    go, done, clock, reset, din, dout);

// If we want the specification be clocked by negedge clock instead of posedge clock,
// we simply need to pass the negation of clock:
m_seqprotocol #( .dataType(logic [31:0])) inst2 (
    go, done, !clock, reset, din, dout);

m_seqprotocol #( .dataType(logic [31:0]), .bothedges(1)) inst3 (
    go, done, clock, din, dout);
","Caption: ""Excerpt from a document explaining how to create generic Verilog modules with parameterized data types and clocking behavior for verification purposes.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p38.jpg,True,"```verilog
module m2(input logic c, d, clk);
  logic a, b;
  always_comb begin
    a = c & d; b = c | d;
    // Immediate assertion
    a1: assert (a -> b);
    // Deferred assertion
    a2: assert final (a -> b);
    // Concurrent assertion
    a3: assert property (@clk a != b);
  end
  // Deferred assertion
  a4: assert final (a -> b);
  // Concurrent assertion
  a5: assert property (@clk a != b);
endmodule : m2
```","
module m2(input logic c, d, clk);
  logic a, b;
  always_comb begin
    a = c & d; b = c | d;
    // Immediate assertion
    a1: assert (a -> b);
    // Deferred assertion
    a2: assert final (a -> b);
    // Concurrent assertion
    a3: assert property (@clk a != b);
  end
  // Deferred assertion
  a4: assert final (a -> b);
  // Concurrent assertion
  a5: assert property (@clk a != b);
endmodule : m2
","""Examples of immediate, deferred, and concurrent assertions in SystemVerilog code""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p216.jpg,True,"The image contains Verilog code snippets. Here is the code from the image:

The first block of code:

```verilog
checker mycheck(event clk = $inferred_clock);
  a1: assert property (@clk a);
endchecker : mycheck
module m(input logic clk, ...);
  logic a = ...;
  mycheck check (posedge clk);
  ...
endmodule : m
```

The second block of code:

```verilog
checker mycheck(event clk = $inferred_clock);
  a1: assert property (@clk top.unit1.block2.a);
endchecker : mycheck
```

The third block of code:

```verilog
package check_lib;
  checker request_granted(sequence req, property gnt,
    untyped n = 1,
    event clk = $inferred_clock, untyped rst = $inferred_disable);
    a1: assert property(@clk disable iff (rst)
      req |-> nexttime[n] gnt);
  endchecker : request_granted
  // Other checkers ...
endpackage : check_lib
```","
checker mycheck(event clk = $inferred_clock);
  a1: assert property (@clk a);
endchecker : mycheck
module m(input logic clk, ...);
  logic a = ...;
  mycheck check (posedge clk);
  ...
endmodule : m


checker mycheck(event clk = $inferred_clock);
  a1: assert property (@clk top.unit1.block2.a);
endchecker : mycheck


package check_lib;
  checker request_granted(sequence req, property gnt,
    untyped n = 1,
    event clk = $inferred_clock, untyped rst = $inferred_disable);
    a1: assert property(@clk disable iff (rst)
      req |-> nexttime[n] gnt);
  endchecker : request_granted
  // Other checkers ...
endpackage : check_lib
","""Understanding Verilog Checkers and their Scope Issues with Example Code and Explanation on Packaging Multiple Checkers""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p567.jpg,True,"The image only shows a snippet of explanatory text and does not contain any complete code example. However, there is a tiny fragment of what appears to be a declaration in C language, which is not a full executable code. Here is the text fragment:

```c
int high, low;
``` 

Note that this is not a complete Verilog code; it’s just a part of the explanatory text discussing how 64-bit simulation time in Verilog is represented using two C integer variables.","igh, low;
","Caption: ""Representation of 64-bit simulation time in Verilog PLI using two 32-bit C integers, and steps for using acc_set_value() to write a value into an object in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p139.jpg,True,"The image contains Verilog code related to a module instantiation with parameters. Here is the code from the image:

```verilog
Module top(...);

// port declarations

master
#(.master_sva(1'b0), .master_sva_severity(1'b0))
u1 (ask[2], clk, req1, gnt1, frame1, irdy1, trdy, data1, rsel1, datao);

master
#(.master_sva(1'b0), .master_sva_severity(1'b0))
u2 (ask[1], clk, req2, gnt2, frame2, irdy2, trdy, data2, rsel2, datao);

master
#(.master_sva(1'b0), .master_sva_severity(1'b0))
u3 (ask[0], clk, req3, gnt3, frame3, irdy3, trdy, data3, rsel3, datao);

arbiter
#(.arb_sva(1'b0), .arb_sva_severity(1'b0))
u4 (clk, reset, frame, irdy, req1, req2, req3, gnt1, gnt2, gnt3);

glue
#(.glue_sva(1'b0), .glue_sva_severity(1'b0))
u5 (clk, frame1, irdy1, frame2, irdy2, frame3, irdy3, trdy, rsel1, rsel2, rsel3, data1, data2, data3, sel, data, dataout1, dataout2, datao);

target
#(.target_sva(1'b0), .target_sva_severity(1'b0))
u6 (clk, reset, sel[1], trdy[1], data, dataout1);

target
#(.target_sva(1'b0), .target_sva_severity(1'b0))
u7 (clk, reset, sel[0], trdy[0], data, dataout2);
```

The code shows the instantiation of several modules such as `master`, `arbiter`, `glue`, and `target` with instances named `u1` to `u7`. Each instance is passed parameters that appear to disable assertions (SVA) and severity levels by setting them to `1'b0`. The instantiations of these modules include lists of connections, which are typically signals or ports.","
Module top(...);

// port declarations

master
#(.master_sva(1'b0), .master_sva_severity(1'b0))
u1 (ask[2], clk, req1, gnt1, frame1, irdy1, trdy, data1, rsel1, datao);

master
#(.master_sva(1'b0), .master_sva_severity(1'b0))
u2 (ask[1], clk, req2, gnt2, frame2, irdy2, trdy, data2, rsel2, datao);

master
#(.master_sva(1'b0), .master_sva_severity(1'b0))
u3 (ask[0], clk, req3, gnt3, frame3, irdy3, trdy, data3, rsel3, datao);

arbiter
#(.arb_sva(1'b0), .arb_sva_severity(1'b0))
u4 (clk, reset, frame, irdy, req1, req2, req3, gnt1, gnt2, gnt3);

glue
#(.glue_sva(1'b0), .glue_sva_severity(1'b0))
u5 (clk, frame1, irdy1, frame2, irdy2, frame3, irdy3, trdy, rsel1, rsel2, rsel3, data1, data2, data3, sel, data, dataout1, dataout2, datao);

target
#(.target_sva(1'b0), .target_sva_severity(1'b0))
u6 (clk, reset, sel[1], trdy[1], data, dataout1);

target
#(.target_sva(1'b0), .target_sva_severity(1'b0))
u7 (clk, reset, sel[0], trdy[0], data, dataout2);
","Caption: ""Example of Verilog module instantiations with parameter overrides for system-level simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p570.jpg,True,"The image contains Verilog code. Here's the text for the code present in the image:

```verilog
module m(input logic clk, reset_n, load,
         input logic [3:0] r1,
         output logic [3:0] r2);

default disable iff reset_n;
always @(posedge clk) begin
    if (!reset_n) r2 <= 'b0;
    else if (load) r2 <= r1;
    loaded_r2: assert property(time_interval_p(
        $past(load), r2 == $past(r1))) else
        $error(""r2 not loaded correctly by r1"");
end
endmodule
```

And a different snippet of code is also visible:

```verilog
import std_ovl_defines::*;

checker assert_handshake (
    sequence req, sequence ack,
    event clk = $inferred_clock,
    untyped reset              = $inferred_disable,
    //elaboration-time constants:
);
```

This code is part of a book or document that talks about Examples of Typical Checker Kinds and a Checker-Based Temporal Checker in the context of Verilog/SystemVerilog assertions and properties.","
module m(input logic clk, reset_n, load,
         input logic [3:0] r1,
         output logic [3:0] r2);

default disable iff reset_n;
always @(posedge clk) begin
    if (!reset_n) r2 <= 'b0;
    else if (load) r2 <= r1;
    loaded_r2: assert property(time_interval_p(
        $past(load), r2 == $past(r1))) else
        $error(""r2 not loaded correctly by r1"");
end
endmodule


import std_ovl_defines::*;

checker assert_handshake (
    sequence req, sequence ack,
    event clk = $inferred_clock,
    untyped reset              = $inferred_disable,
    //elaboration-time constants:
);
","""Excerpt from a technical document illustrating examples of Verilog checkers and code instantiation for property-based verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p558.jpg,True,"Here is the code that is present in the image:

```verilog
checker check1(...);
bit [3:0] v = ...;
// ...
endchecker : check1

checker check2(...);
rand bit [3:0] v = ...;
// ...
endchecker : check2
```

Please note that the code is not complete and contains ellipses (...) indicating that parts of the code have been omitted in the text.","
checker check1(...);
bit [3:0] v = ...;
// ...
endchecker : check1

checker check2(...);
rand bit [3:0] v = ...;
// ...
endchecker : check2
","Caption: ""Textbook excerpt discussing implementation and modification of checkers in Verilog for formal verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p38.jpg,True,"The image includes a snippet of Verilog code in the section titled ""1.8 Sequence with logical relationship."" The code shown is as follows:

```verilog
sequence s3;
    @(posedge clk) a || b;
endsequence
``` 

This code defines a sequence `s3` that checks on every positive edge of the clock if either signal `a` or signal `b` is high. If both signals are low, the condition would not be satisfied.","
sequence s3;
    @(posedge clk) a || b;
endsequence
","Waveform and evaluation table for a simple Verilog sequence with edge definition, and an example of a sequence with logical relationship using SystemVerilog Assertions (SVA).",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p232.jpg,True,"```verilog
class Transaction;
  typedef enum {BYTE, WORD, LWRD, QWRD} length_e;
  typedef enum {READ, WRITE, RMW, INTR} access_e;
  rand length_e length;
  rand access_e access;

  constraint valid_RMW_LWRD {
    (access == RMW) -> (length == LWRD);
  }
endclass
```","
class Transaction;
  typedef enum {BYTE, WORD, LWRD, QWRD} length_e;
  typedef enum {READ, WRITE, RMW, INTR} access_e;
  rand length_e length;
  rand access_e access;

  constraint valid_RMW_LWRD {
    (access == RMW) -> (length == LWRD);
  }
endclass
",Sample Verilog code demonstrating the use of valid constraints in a Transaction class to ensure correct bus transaction randomization.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p229.jpg,True,"The image contains a snippet of code which appears to be related to Verilog VPI callbacks. Here is the code from the image:

```c
/***********************************************************************
 * Value change callback application
 **********************************************************************/
PLIbook_EndOfTimeStep_callback(p_cb_data cb_data_p)
{
    s_vpi_time time_s;
    s_vpi_value value_s;
    static char new_value[] = ""z"";
    vpiHandle arg_h = (vpiHandle)cb_data_p->user_data;
    
    value_s.format = vpiBinStrVal;
    vpi_get_value(arg_h, &value_s);
    vpi_printf(""$my_strobe: At %d: \t% s = % s\n"",
               cb_data_p->time->low,
               vpi_get_str(vpiFullName, arg_h),
               value_s.value.str);
}
```

This code is defining a function `PLIbook_EndOfTimeStep_callback` used as a VPI callback during a Verilog simulation. It uses the VPI routines to get information about a Verilog signal value and print it.","*******************************************************************
 * Value change callback application
 **********************************************************************/
PLIbook_EndOfTimeStep_callback(p_cb_data cb_data_p)
{
    s_vpi_time time_s;
    s_vpi_value value_s;
    static char new_value[] = ""z"";
    vpiHandle arg_h = (vpiHandle)cb_data_p->user_data;
    
    value_s.format = vpiBinStrVal;
    vpi_get_value(arg_h, &value_s);
    vpi_printf(""$my_strobe: At %d: \t% s = % s\n"",
               cb_data_p->time->low,
               vpi_get_str(vpiFullName, arg_h),
               value_s.value.str);
}
","""Value change callback example in Verilog using VPI Callbacks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p188.jpg,True,"```
// <vendor> coverage_off
// <vendor> coverage_on
// <vendor> synthesis_off
// <vendor> synthesis_on

// rtl_synthesis off
// test and diagnostic statements in Verilog>
// rtl_synthesis on

wire^4'value'/[31:0] tri_data;
```","ndor> coverage_off
// <vendor> coverage_on
// <vendor> synthesis_off
// <vendor> synthesis_on

// rtl_synthesis off
// test and diagnostic statements in Verilog>
// rtl_synthesis on

wire^4'value'/[31:0] tri_data;
","""Information on Verilog code coverage, synthesis control comments, and a wire declaration snippet.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p226.jpg,True,"The image contains two excerpts of Verilog code. Here they are:

```verilog
class BusOp;
    ...
    constraint c_addr_space {
        if (addr_space == MEM)
            addr inside {[0:32'h0FFF_FFFF]};
        else if (addr_space == IO)
            addr inside {[32'h1000_0000:32'h7FFF_FFFF]};
        else
            addr inside {[32'h8000_0000:32'hFFFF_FFFF]};
    }
```

```verilog
rand bit d, e;
constraint c { (d==1) <-> (e==1); }
```

Both snippets demonstrate the use of constraints in SystemVerilog, which is a hardware description and verification language. The constraints are used to specify conditions for random variable generation in a class. The first snippet, `c_addr_space`, conditionally constrains the `addr` variable based on the value of `addr_space`, while the second one, `c`, uses an equivalence operator `<->` to link the values of two random bits `d` and `e`.","
class BusOp;
    ...
    constraint c_addr_space {
        if (addr_space == MEM)
            addr inside {[0:32'h0FFF_FFFF]};
        else if (addr_space == IO)
            addr inside {[32'h1000_0000:32'h7FFF_FFFF]};
        else
            addr inside {[32'h8000_0000:32'hFFFF_FFFF]};
    }


rand bit d, e;
constraint c { (d==1) <-> (e==1); }
","""Verilog code excerpt demonstrating constraint blocks with multiple if-else operator and equivalence operator usage.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p105.jpg,True,"The image contains Verilog SystemVerilog Assertions (SVA) code, which is used to specify properties and assertions in hardware verification. Here is the code from the image:

```verilog
sequence s_display1;
  @(posedge clk)
    ($rose(a), $display(""Signal a arrived at %t\n"", $time));
endsequence

sequence s_display2;
  @(posedge clk)
    ($rose(b), $display(""Signal b arrived at %t\n"", $time));
endsequence

property p_display_window;
  @(posedge clk)
    s_display1 |-> ##[2:5] s_display2;
endproperty

a_display_window :
  assert property(p_display_window);
```

This code defines two sequences `s_display1` and `s_display2` that display messages when there is a rising edge on signals `a` and `b`, respectively. The property `p_display_window` is defined to check that whenever `s_display1` occurs, `s_display2` should occur within 2 to 5 clock cycles afterwards. The final assertion `a_display_window` asserts the property `p_display_window`.","
sequence s_display1;
  @(posedge clk)
    ($rose(a), $display(""Signal a arrived at %t\n"", $time));
endsequence

sequence s_display2;
  @(posedge clk)
    ($rose(b), $display(""Signal b arrived at %t\n"", $time));
endsequence

property p_display_window;
  @(posedge clk)
    s_display1 |-> ##[2:5] s_display2;
endproperty

a_display_window :
  assert property(p_display_window);
",Verilog Assertions (SVA) Using Subroutines in Sequence Matches,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p216.jpg,True,"The image contains text discussing an issue with random number generation in SystemVerilog, and there is a snippet of code shown. Here is the code presented in the image:

```verilog
class bad_constraint;
  rand bit [7:0] a, b, c;
  constraint equal { a == b == c; }
endclass
```","
class bad_constraint;
  rand bit [7:0] a, b, c;
  constraint equal { a == b == c; }
endclass
","""Exploring the Inconsistencies of Random Number Generators in Verilog Across Different Tools""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p232.jpg,True,"The image contains a fragment of Verilog code. Here it is transcribed:

```verilog
// use a counter to represent current depth of the FIFO
parameter FIFO_depth=16;
parameter logDEPTH=4;
reg [logDEPTH-1:0] cnt;

always @ (posedge clk) begin
    case ({push, pop})
    2'b10: begin
        cnt <= cnt + 1;
        ...
    2'b01: begin
        cnt <= cnt - 1;
        ...
```

This code snippet represents a FIFO (First-In-First-Out) queue with an index counter in Verilog. It shows the parameters and register declaration used to track the current depth of the FIFO, as well as the start of an always block that updates the counter based on push and pop signals.","
// use a counter to represent current depth of the FIFO
parameter FIFO_depth=16;
parameter logDEPTH=4;
reg [logDEPTH-1:0] cnt;

always @ (posedge clk) begin
    case ({push, pop})
    2'b10: begin
        cnt <= cnt + 1;
        ...
    2'b01: begin
        cnt <= cnt - 1;
        ...
","Caption: ""Verilog example demonstrating a FIFO queue implementation using an index counter.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p226.jpg,True,"The image contains Verilog code. Here is the transcribed code:

Example 6-55 SystemVerilog A Flush must remain active until FlushAck
```verilog
// event-bounded window pattern
assert property (@ (posedge clk) disable iff ( rst_n )
  ($rose(Flush) |-> (Flush throughout (##[0:100] FlushAck))) else
  $error(""Flush must be held until Ack asserted."");
```

Example 6-56 SystemVerilog FlushAck must be asserted for no more than one cycle
```verilog
// forbidden sequence pattern
assert property (@ (posedge clk) disable iff ( rst_n )
  not (FlushAck ##1 FlushAck)) else
  $error(""FlushAck must be a single pulse."");
```

Example 6-57 SystemVerilog A SMQueStop must remain active until StopAck is asserted
```verilog
// event-bounded window pattern
assert property (@ (posedge clk) disable iff ( rst_n )
  ($rose(SMQueStop) |->
  (SMQueStop throughout (##[0:100] StopAck))) else
  $error(""Stop must be held until ack is asserted."");
```

Example 6-58 SystemVerilog StopAck must be asserted for no more than one cycle
```verilog
// forbidden sequence
assert property (@ (posedge clk) disable iff ( rst_n )
  not (StopAck ##1 StopAck)) else
  $error(""StopAck must be a single pulse."");
```

Example 6-59 SystemVerilog FlushAck and !Flush are mutually exclusive
```verilog
// valid signal combination pattern
assert property (@ (posedge clk) disable iff ( rst_n )
  not (FlushAck & !Flush)) else
  $error(""FlushAck must not assert without Flush asserted."");
```

These are examples of assertions in SystemVerilog meant to ensure specific signal behaviors in a hardware description.","
// event-bounded window pattern
assert property (@ (posedge clk) disable iff ( rst_n )
  ($rose(Flush) |-> (Flush throughout (##[0:100] FlushAck))) else
  $error(""Flush must be held until Ack asserted."");


// forbidden sequence pattern
assert property (@ (posedge clk) disable iff ( rst_n )
  not (FlushAck ##1 FlushAck)) else
  $error(""FlushAck must be a single pulse."");


// event-bounded window pattern
assert property (@ (posedge clk) disable iff ( rst_n )
  ($rose(SMQueStop) |->
  (SMQueStop throughout (##[0:100] StopAck))) else
  $error(""Stop must be held until ack is asserted."");


// forbidden sequence
assert property (@ (posedge clk) disable iff ( rst_n )
  not (StopAck ##1 StopAck)) else
  $error(""StopAck must be a single pulse."");


// valid signal combination pattern
assert property (@ (posedge clk) disable iff ( rst_n )
  not (FlushAck & !Flush)) else
  $error(""FlushAck must not assert without Flush asserted."");
","""Examples of SystemVerilog assertion properties for queue management interface control.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p202.jpg,True,"```verilog
covergroup pixelProximity(ref bit signed [12:0] pixel1,
                         ref bit signed [12:0] pixel2)
    @(newPixel);
    cp1: coverpoint (pixel2 - pixel1) {
        bins lt = {[1:$]};  // pixel1's coord less than pixel2
        bins eq = {0};      // did the pixels coincide?
        bins gt = {[-4096:-1]}; // pixel1's coord greater than pixel2
    }
endgroup

pixelProximity px, py;

initial begin
    bit signed [12:0] x1, y1, x2, y2;
    px = new(x1, y1);     // construct first covergroup
    py = new(x2, y2);     // construct second covergroup
    ... // generate stimulus
    $get_coverage();      // GOTHCA! report lumps
                          // px and py together
end

covergroup pixelProximity(ref bit signed [12:0] pixel1,
                         ref bit signed [12:0] pixel2)
    @(newPixel);
    option.per_instance = 1; // report for each covergroup instance
    cp1: coverpoint (pixel2 - pixel1) {
        ...
    }
endgroup
```","
covergroup pixelProximity(ref bit signed [12:0] pixel1,
                         ref bit signed [12:0] pixel2)
    @(newPixel);
    cp1: coverpoint (pixel2 - pixel1) {
        bins lt = {[1:$]};  // pixel1's coord less than pixel2
        bins eq = {0};      // did the pixels coincide?
        bins gt = {[-4096:-1]}; // pixel1's coord greater than pixel2
    }
endgroup

pixelProximity px, py;

initial begin
    bit signed [12:0] x1, y1, x2, y2;
    px = new(x1, y1);     // construct first covergroup
    py = new(x2, y2);     // construct second covergroup
    ... // generate stimulus
    $get_coverage();      // GOTHCA! report lumps
                          // px and py together
end

covergroup pixelProximity(ref bit signed [12:0] pixel1,
                         ref bit signed [12:0] pixel2)
    @(newPixel);
    option.per_instance = 1; // report for each covergroup instance
    cp1: coverpoint (pixel2 - pixel1) {
        ...
    }
endgroup
","""Verilog Gotcha: Properly tracking coverage for multiple instances of a covergroup in SystemVerilog testbenches.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p765.jpg,True,"The image contains snippets of code as part of a document describing the IEEE 1364-1995 ACC Routine Library, which is related to Verilog. Here is the code visible in the image:

```c
char *acc_fetch_value(object, format_str, value)
handle object
char *format_str
p_acc_value value

typedef struct t_setval_value {
    int format;
    union {
        char *str;
        int scalar;
        int integer;
        double real;
        p_acc_vecval vector;
    } value;
} s_setval_value, *p_setval_value, s_acc_value, *p_acc_value;

typedef struct t_acc_vecval {
    int aval;  /* bit encoding: aval/bval: 0/0=0, 1/0=1, 1/1=z, 0/1=x */
    int bval;
} s_acc_vecval, *p_acc_vecval;

void acc_free(array_ptr)
handle *array_ptr

handle acc_handle_by_name(obj_name, scope)
char *obj_name
handle scope
```

These code excerpts are function declarations and type definitions from the ACC (Application C Interface) library of Verilog, which allows C programs to interface with the Verilog simulation kernel. Remember that the actual implementation of these functions would be found elsewhere and are not included in this snippet.","*acc_fetch_value(object, format_str, value)
handle object
char *format_str
p_acc_value value

typedef struct t_setval_value {
    int format;
    union {
        char *str;
        int scalar;
        int integer;
        double real;
        p_acc_vecval vector;
    } value;
} s_setval_value, *p_setval_value, s_acc_value, *p_acc_value;

typedef struct t_acc_vecval {
    int aval;  /* bit encoding: aval/bval: 0/0=0, 1/0=1, 1/1=z, 0/1=x */
    int bval;
} s_acc_vecval, *p_acc_vecval;

void acc_free(array_ptr)
handle *array_ptr

handle acc_handle_by_name(obj_name, scope)
char *obj_name
handle scope
","""IEEE 1364-1995 ACC Routine Library reference page for Verilog PLI functions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p506.jpg,True,"```verilog
class coverage;
    covergroup cg_abc with function sample (data_obj obj);
        coverpoint obj.mode {
            bins range = {[3:'hB]};
        }
    endgroup

    function new ( );
        data_obj obj;
        cg_abc = new ( );
    endfunction
endclass

module tb;
    initial begin
        coverage m_cov = new ( );
        for (int i = 0; i < 10; i++) begin
            data_obj obj = new ( );
            obj.randomize ( );
            m_cov.cg_abc.sample(obj);
        end
        $display(""Coverage : %0.2f %%"", m_cov.cg_abc.get_coverage());
    end
endmodule
```","
class coverage;
    covergroup cg_abc with function sample (data_obj obj);
        coverpoint obj.mode {
            bins range = {[3:'hB]};
        }
    endgroup

    function new ( );
        data_obj obj;
        cg_abc = new ( );
    endfunction
endclass

module tb;
    initial begin
        coverage m_cov = new ( );
        for (int i = 0; i < 10; i++) begin
            data_obj obj = new ( );
            obj.randomize ( );
            m_cov.cg_abc.sample(obj);
        end
        $display(""Coverage : %0.2f %%"", m_cov.cg_abc.get_coverage());
    end
endmodule
","Caption: ""An example of Verilog code demonstrating proper usage of a coverage group with a user-defined `sample()` function to avoid NULL pointer dereference errors during simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p313.jpg,True,"The image contains code written in the context of Verilog or SystemVerilog. Here it is:

```verilog
a2_ff: assert property(p2_ff);
a2_fr: assert property(p2_fr);
a2_rf: assert property(p2_rf);
a2_rr: assert property(p2_rr);

// on a given clock edge, if the leading signal
// has a falling edge, then the trailing signal
// must have a falling edge

property p4_oei_ff;
    @(posedge clk) $fell(a) |-> $fell(b);
endproperty

// on a given clock edge, if the leading signal
// has a falling edge, then the trailing signal
// must have a rising edge

property p4_oei_fr;
    @(posedge clk) $fell(a) |-> $rose(b);
endproperty

// on a given clock edge, if the leading signal
// has a rising edge, then the trailing signal
// must have a falling edge

property p4_oei_rf;
    @(posedge clk) $rose(a) |-> $fell(b);
endproperty

// on a given clock edge, if the leading signal
// has a rising edge, then the trailing signal
// must have a rising edge

property p4_oei_rr;
    @(posedge clk) $rose(a) |-> $rose(b);
endproperty

a4_oei_ff: assert property(p4_oei_ff);
a4_oei_fr: assert property(p4_oei_fr);
a4_oei_rf: assert property(p4_oei_rf);
```

The page discussing these code snippets seems to be from a manual or a book about logic verification in digital design using assertions. It defines several properties related to edge-sensitive signaling conditions in synchronous digital circuits and includes assertions for checking these properties.","
a2_ff: assert property(p2_ff);
a2_fr: assert property(p2_fr);
a2_rf: assert property(p2_rf);
a2_rr: assert property(p2_rr);

// on a given clock edge, if the leading signal
// has a falling edge, then the trailing signal
// must have a falling edge

property p4_oei_ff;
    @(posedge clk) $fell(a) |-> $fell(b);
endproperty

// on a given clock edge, if the leading signal
// has a falling edge, then the trailing signal
// must have a rising edge

property p4_oei_fr;
    @(posedge clk) $fell(a) |-> $rose(b);
endproperty

// on a given clock edge, if the leading signal
// has a rising edge, then the trailing signal
// must have a falling edge

property p4_oei_rf;
    @(posedge clk) $rose(a) |-> $fell(b);
endproperty

// on a given clock edge, if the leading signal
// has a rising edge, then the trailing signal
// must have a rising edge

property p4_oei_rr;
    @(posedge clk) $rose(a) |-> $rose(b);
endproperty

a4_oei_ff: assert property(p4_oei_ff);
a4_oei_fr: assert property(p4_oei_fr);
a4_oei_rf: assert property(p4_oei_rf);
","Caption: ""Verilog code segment showcasing properties for edge-sensitive signals in a digital system, with assertions to validate the timing relationships between signal transitions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p307.jpg,True,"There is indeed code in the image. The code examples provided are for different ways to express relationships between signals in Verilog SystemVerilog Assertions (SVA):

```
signal1 && signal2
signal1 |-> signal2
signal1 ##[1:3] signal2
signal1 |-> ##2 signal2
``` 

These statements in Verilog Assertions are used to define logical and temporal relationships between signal1 (the leading signal) and signal2 (the trailing signal).","1 && signal2
signal1 |-> signal2
signal1 ##[1:3] signal2
signal1 |-> ##2 signal2
","Caption: ""Excerpt from a textbook showing a section on Assertion Test Bench (ATB) for SystemVerilog Assertions (SVA) with examples of logical and timing relationships between two signals in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p759.jpg,True,"The image contains text and descriptions of some configuration parameters and functions related to Verilog ACC (Application Control Closure) routine library but does not contain any code. It is mainly documentation. Here is the textual information pertaining to the functions shown in the image:

```
int acc_count(next_routine, object)
handle *next_routine  name of any ACC next routine except acc_next_topmod()
handle object  reference object for the ACC next routine.
Returns the number of objects found by an ACC next routine.

int acc_fetch_argc()
Returns the number of command line arguments given on the command line used to invoke a Verilog simulator.

char **acc_fetch_argv()
Returns a pointer to an array of character string pointers containing the command line arguments used to invoke a Verilog simulator.
```

Please note that the actual definition of these functions would be according to the ACC Routine Library of IEEE 1364-1995, which is not a part of the visible text in the image.","c_count(next_routine, object)
handle *next_routine  name of any ACC next routine except acc_next_topmod()
handle object  reference object for the ACC next routine.
Returns the number of objects found by an ACC next routine.

int acc_fetch_argc()
Returns the number of command line arguments given on the command line used to invoke a Verilog simulator.

char **acc_fetch_argv()
Returns a pointer to an array of character string pointers containing the command line arguments used to invoke a Verilog simulator.
","""Appendix Documentation Detailing IEEE 1364-1995 ACC Routine Library for Verilog Simulation""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p274.jpg,True,"The image contains multiple snippets of Verilog code. I will transcribe them below:

First snippet:
```verilog
sequence sr1;
    @(posedge clk) req ##2 gnt;
endsequence

always @(sr1)
    $display($stime,,,""req ##2 gnt PASS"");
```

Second snippet:
```verilog
sequence ReadComplete;
    @(posedge clk) $rose(read) ##0 [-> 1] readC;
endproperty

initial
begin
    @(ReadComplete)
    begin
        -> issueNextRead;
    end
end
```

These Verilog code examples demonstrate the use of sequences in sensitivity lists and properties within Verilog SystemVerilog assertions (SVA).","
sequence sr1;
    @(posedge clk) req ##2 gnt;
endsequence

always @(sr1)
    $display($stime,,,""req ##2 gnt PASS"");


sequence ReadComplete;
    @(posedge clk) $rose(read) ##0 [-> 1] readC;
endproperty

initial
begin
    @(ReadComplete)
    begin
        -> issueNextRead;
    end
end
","""Examples of using sequences as event triggers in Verilog sensitivity lists.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p215.jpg,True,"The image contains several snippets of Verilog code. Here are the code excerpts found in the image:

Example 8-22 a) Blocking assignments with a race
```verilog
always @(posedge ck)
begin
    b = a;
end
always @(posedge ck)
begin
    c = b;
end
```

b) Non-blocking assignments eliminate the race
```verilog
always @(posedge ck)
begin
    b <= a;
end
always @(posedge ck)
begin
    c <= b;
end
```

c) Sequential/combinational blocks eliminate the race
```verilog
always @(posedge ck)
begin
    b <= a;
end
always @(b)
begin
    c = b;
end
```

d) Combined combinational block eliminates the race
```verilog
always @(a)
begin
    b = a;
    c = b;
end
```","
always @(posedge ck)
begin
    b = a;
end
always @(posedge ck)
begin
    c = b;
end


always @(posedge ck)
begin
    b <= a;
end
always @(posedge ck)
begin
    c <= b;
end


always @(posedge ck)
begin
    b <= a;
end
always @(b)
begin
    c = b;
end


always @(a)
begin
    b = a;
    c = b;
end
","Caption: ""Verilog coding examples illustrating race conditions and their resolution using blocking and non-blocking assignments.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p298.jpg,True,"The image contains Verilog code related to functional coverage points for PCI Target. Here's the code as seen in the image:

```verilog
property p_tcov1;
    @(posedge clk)
    $fell (framen) && (cxben[3:0] == 4'b0100) |-> deveseln [*1:5] ##0 $rose (framen);
endproperty

c_tcov1: cover property(p_tcov1);

property p_tcov2;
    @(posedge clk)
    $fell (framen) && (cxben[3:0] == 4'b0101) |-> deveseln [*1:5] ##0 $rose (framen);
endproperty

c_tcov2: cover property(p_tcov2);

property p_tcov3;
    @(posedge clk)
    $fell (framen) && (cxben[3:0] == 4'b1000) |-> deveseln [*1:5] ##0 $rose (framen);
endproperty

c_tcov3: cover property(p_tcov3);

property p_tcov4;
    @(posedge clk)
    $fell (framen) && (cxben[3:0] == 4'b1001) |-> deveseln [*1:5] ##1 $rose (framen);
endproperty

c_tcov4: cover property(p_tcov4);
```

These properties define conditions under which certain signals in a PCI Target design should be covered during verification. The `cover property` statements are used to specify that these properties should be monitored for coverage during simulation.","
property p_tcov1;
    @(posedge clk)
    $fell (framen) && (cxben[3:0] == 4'b0100) |-> deveseln [*1:5] ##0 $rose (framen);
endproperty

c_tcov1: cover property(p_tcov1);

property p_tcov2;
    @(posedge clk)
    $fell (framen) && (cxben[3:0] == 4'b0101) |-> deveseln [*1:5] ##0 $rose (framen);
endproperty

c_tcov2: cover property(p_tcov2);

property p_tcov3;
    @(posedge clk)
    $fell (framen) && (cxben[3:0] == 4'b1000) |-> deveseln [*1:5] ##0 $rose (framen);
endproperty

c_tcov3: cover property(p_tcov3);

property p_tcov4;
    @(posedge clk)
    $fell (framen) && (cxben[3:0] == 4'b1001) |-> deveseln [*1:5] ##1 $rose (framen);
endproperty

c_tcov4: cover property(p_tcov4);
","""Excerpt from a technical document featuring sample Verilog code for functional coverage points in a PCI Target context.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p499.jpg,True,"The image contains code written in the Verilog hardware description language, specifically showcasing the usage of `bins` and `covergroup` constructs. Here's the code from the image:

```verilog
bit [7:0] v_a, v_b;
covergroup cg @(posedge clk);
  a: coverpoint v_a
  {
    bins a1 = { [0:63] };
    bins a2 = { [64:127] };
    bins a3 = { [128:191] };
    bins a4 = { [192:255] };
  }
  b: coverpoint v_b
  {
    bins b1 = {0};
    bins b2 = { [1:84] };
    bins b3 = { [85:169] };
    bins b4 = { [170:255] };
  }
  c: cross a, b
  {
    bins c1 = !bins of(a) intersect {[100:200]}; // 4 cross products
    bins c2 = bins of(a.a2) || bins of(b.b2); // 7 cross products
    bins c3 = bins of(a.a1) && bins of(b.b4); // 1 cross product
  }
endgroup
```

This code snippet is an example describing the usage of `bins of`, `intersect`, logic inversion `!`, and logical operators `||` (logical or) and `&&` (logical and) within a `covergroup` construct in Verilog. It's used for functional coverage to track which scenarios have been tested, an important concept in verification of digital designs.","
bit [7:0] v_a, v_b;
covergroup cg @(posedge clk);
  a: coverpoint v_a
  {
    bins a1 = { [0:63] };
    bins a2 = { [64:127] };
    bins a3 = { [128:191] };
    bins a4 = { [192:255] };
  }
  b: coverpoint v_b
  {
    bins b1 = {0};
    bins b2 = { [1:84] };
    bins b3 = { [85:169] };
    bins b4 = { [170:255] };
  }
  c: cross a, b
  {
    bins c1 = !bins of(a) intersect {[100:200]}; // 4 cross products
    bins c2 = bins of(a.a2) || bins of(b.b2); // 7 cross products
    bins c3 = bins of(a.a1) && bins of(b.b4); // 1 cross product
  }
endgroup
","A Verilog code snippet demonstrating the use of ""binsof"" and ""intersect"" operators in coverage analysis.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p201.jpg,True,"The image contains Verilog code in a printed document. Here is the code as displayed in the image:

Example 8-11 a) Bad: Simulates slower
```verilog
input [15:0] a;
output [0:15] b;
integer i;
reg[0:15]b;
always @ (a) begin
  for(i=0; i<=15; i=i+1)
    b[15-i] = a[i];
end
```

b) Good: Simulates faster
```verilog
input [15:0] a;
output [0:15] b;
assign b = {a[0], a[1], a[2], a[3],
            a[4], a[5], a[6], a[7],
            a[8], a[9], a[10], a[11],
            a[12], a[13], a[14], a[15]};
```

The above Verilog code examples demonstrate two different approaches to bit-ordering reversal of a bus. The first example uses a procedural block with a `for` loop, which is indicated as simulating slower. The second example uses continuous assignment with concatenation, which is referred to as simulating faster.","
input [15:0] a;
output [0:15] b;
integer i;
reg[0:15]b;
always @ (a) begin
  for(i=0; i<=15; i=i+1)
    b[15-i] = a[i];
end


input [15:0] a;
output [0:15] b;
assign b = {a[0], a[1], a[2], a[3],
            a[4], a[5], a[6], a[7],
            a[8], a[9], a[10], a[11],
            a[12], a[13], a[14], a[15]};
","Caption: ""Comparison between suboptimal and optimized Verilog code for bit-reversal, highlighting the performance difference in simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p99.jpg,True,"```
int PLIbook_ShowSignals_compiletf(char *user_data)
{
    vpiHandle systf_handle, arg_iterator, arg_handle;
    int tfarg_type;

    /* obtain a handle to the system task instance */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handles to system task arguments */
    arg_iterator = vpi_iterate(vpiArgument, systf_handle);
    if (arg_iterator == NULL) {
        vpi_printf(""ERROR: show_all_signals requires 1 argument\n"");
        tf_dofinish(); /* abort simulation */
        return(0);
    }

    /* check the type of object in system task arguments */
    arg_handle = vpi_scan(arg_iterator);
    tfarg_type = vpi_get(vpiType, arg_handle);
    if (tfarg_type != vpiModule) {
        vpi_printf(""ERROR: show_all_signals arg 1"");
        vpi_printf("" must be a module instance\n"");
        vpi_free_object(arg_iterator); /* free iterator memory */
        tf_dofinish(); /* abort simulation */
        return(0);
    }

    /* check that there is only 1 system task argument */
    arg_handle = vpi_scan(arg_iterator);
    if (arg_handle != NULL) {
        vpi_printf(""ERROR: show_all_signals can only have 1 argument\n"");
        vpi_free_object(arg_iterator); /* free iterator memory */
        tf_dofinish(); /* abort simulation */
        return(0);
    }
    return(0);
}

/**********************************************************************
* callback routine
**********************************************************************/
int PLIbook_ShowSignals_calltf(char *user_data)
{
    vpiHandle systf_handle, arg_iterator, module_handle,
              signal_iterator;
    int format;
    s_vpi_time current_time;

    /* obtain a handle to the system task instance */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);
```","Ibook_ShowSignals_compiletf(char *user_data)
{
    vpiHandle systf_handle, arg_iterator, arg_handle;
    int tfarg_type;

    /* obtain a handle to the system task instance */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handles to system task arguments */
    arg_iterator = vpi_iterate(vpiArgument, systf_handle);
    if (arg_iterator == NULL) {
        vpi_printf(""ERROR: show_all_signals requires 1 argument\n"");
        tf_dofinish(); /* abort simulation */
        return(0);
    }

    /* check the type of object in system task arguments */
    arg_handle = vpi_scan(arg_iterator);
    tfarg_type = vpi_get(vpiType, arg_handle);
    if (tfarg_type != vpiModule) {
        vpi_printf(""ERROR: show_all_signals arg 1"");
        vpi_printf("" must be a module instance\n"");
        vpi_free_object(arg_iterator); /* free iterator memory */
        tf_dofinish(); /* abort simulation */
        return(0);
    }

    /* check that there is only 1 system task argument */
    arg_handle = vpi_scan(arg_iterator);
    if (arg_handle != NULL) {
        vpi_printf(""ERROR: show_all_signals can only have 1 argument\n"");
        vpi_free_object(arg_iterator); /* free iterator memory */
        tf_dofinish(); /* abort simulation */
        return(0);
    }
    return(0);
}

/**********************************************************************
* callback routine
**********************************************************************/
int PLIbook_ShowSignals_calltf(char *user_data)
{
    vpiHandle systf_handle, arg_iterator, module_handle,
              signal_iterator;
    int format;
    s_vpi_time current_time;

    /* obtain a handle to the system task instance */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);
","""Excerpt from a document on Verilog VPI Routine usage with example code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p131.jpg,True,"The image includes text and diagrams related to the conversion of proof structures in the context of logic or formal verification. There is a segment of pseudocode present in the text. Here is the pseudocode:

```plaintext
1: procedure CONVERT(Node: n )
2:     if n is leaf then return NewNode( n )
3:     if left(n) = (¬zi) then return Convert(right(n))
4:     if right(n) = (¬zi) then return Convert(left(n))
5:     return NewNode( Resolve(Convert(right(n)), Convert(left(n))) )
```

The pseudocode describes a procedure named `CONVERT` that appears to be part of an algorithm for transforming nodes in a logical proof or data structure. The rest of the image contains diagrams that illustrate the transformations referred to in the document but does not include Verilog code. Verilog is a hardware description language used for electronic design automation, which is not directly related to the content visible in the image.","xt
1: procedure CONVERT(Node: n )
2:     if n is leaf then return NewNode( n )
3:     if left(n) = (¬zi) then return Convert(right(n))
4:     if right(n) = (¬zi) then return Convert(left(n))
5:     return NewNode( Resolve(Convert(right(n)), Convert(left(n))) )
",Pseudocode for a proof transformation algorithm and conceptual illustrations of bubble proof transformation in the context of unsatisfiability.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p187.jpg,True,"```verilog
class Transaction;
    static Config cfg;
    static int count = 0;
    int id;

    // Static method to display static variables.
    static function void display_statics();
        if (cfg == null)
            $display(""ERROR: configuration not set"");
        else
            $display(""Transaction cfg.num_trans=%0d, count=%0d"",
                     cfg.num_trans, count);
    endfunction
endclass

Config cfg;
initial begin
    cfg = new(.num_trans(42));  // Pass argument by name
    Transaction::cfg = cfg;
    Transaction::display_statics();  // Static method call
end
```","
class Transaction;
    static Config cfg;
    static int count = 0;
    int id;

    // Static method to display static variables.
    static function void display_statics();
        if (cfg == null)
            $display(""ERROR: configuration not set"");
        else
            $display(""Transaction cfg.num_trans=%0d, count=%0d"",
                     cfg.num_trans, count);
    endfunction
endclass

Config cfg;
initial begin
    cfg = new(.num_trans(42));  // Pass argument by name
    Transaction::cfg = cfg;
    Transaction::display_statics();  // Static method call
end
","Caption: ""Example of a Verilog class with a static method to display static variables, demonstrating object-oriented programming concepts in SystemVerilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p229.jpg,True,"The image contains a snippet of Verilog code as follows:

```verilog
module module;
endmodule
```

This example is provided to illustrate that using Verilog keywords as names for modules is not legal.","
module module;
endmodule
",The image displays an excerpt from a Verilog tutorial discussing the structure of a `module` declaration and comment syntax within the Verilog language.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p346.jpg,True,"The image does not contain any executable code, but rather explanations and syntax for the SEquence and Regular Expression (SERE) constructs used in Verilog assertions. The text is related to the nonconsecutive repetition feature and the ""Goto repetition"" operator in SERE.

Here's the text related to the nonconsecutive repetition and Goto repetition syntax:

```
Syntax B-7 SERE nonconsecutive repetition

SERE ::=
       Boolean [ = Count ]

Count ::=
        Number | Range

Range ::=
         LowBound RANGE_SYM HighBound

LowBound ::=
            Number | MIN_VAL

HighBound ::=
             Number | MAX_VAL


B.4.7 Goto repetition ([->]) operator

Goto repetition allows for space between the repetition of the terms. The repetition ends on the Boolean expression being found. This facilitates searching for a particular expression and then continuing the sequence at the point it is found.

Note the RANGE_SYM is ‘:’ for Verilog and ‘to’ for VHDL.

Syntax B-8 Goto repetition of a sequence

SERE ::=
       Boolean [-> [positive Count ]]

Count ::=
        Number | Range

Range ::=
         LowBound RANGE_SYM HighBound

LowBound ::=
            Number | MIN_VAL

HighBound ::=
             Number | MAX_VAL
``` 

Please note that this is a description of the syntax and not a direct Verilog code example. The actual use of these constructs would appear within the context of a Verilog assertion within a hardware design specification."," B-7 SERE nonconsecutive repetition

SERE ::=
       Boolean [ = Count ]

Count ::=
        Number | Range

Range ::=
         LowBound RANGE_SYM HighBound

LowBound ::=
            Number | MIN_VAL

HighBound ::=
             Number | MAX_VAL


B.4.7 Goto repetition ([->]) operator

Goto repetition allows for space between the repetition of the terms. The repetition ends on the Boolean expression being found. This facilitates searching for a particular expression and then continuing the sequence at the point it is found.

Note the RANGE_SYM is ‘:’ for Verilog and ‘to’ for VHDL.

Syntax B-8 Goto repetition of a sequence

SERE ::=
       Boolean [-> [positive Count ]]

Count ::=
        Number | Range

Range ::=
         LowBound RANGE_SYM HighBound

LowBound ::=
            Number | MIN_VAL

HighBound ::=
             Number | MAX_VAL
","""Excerpt from a technical document describing Sequence Expression Repetition ('SERE') syntax for nonconsecutive and Goto repetition in Verilog Assertions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p352.jpg,True,"The image contains information relevant to Verilog code. The code presented in the image is as follows:

```verilog
FL_Property ::= never FL_Property
```

```verilog
Property_Declaration ::=
property Name [ ( Formal_Parameter_List ) ] DEF_SYM Property ;
```

These are code snippets showing the syntax for defining certain properties in Verilog and PSL (Property Specification Language).","
FL_Property ::= never FL_Property


Property_Declaration ::=
property Name [ ( Formal_Parameter_List ) ] DEF_SYM Property ;
","""Excerpt from a technical document detailing the use of Verilog with PSL (Property Specification Language) properties, including syntax for the 'never' temporal operator and named properties.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p188.jpg,True,"Here is the code in the image:

```verilog
vpi_get_str(vpiName, port_h, attribute_name, attribute_value);
}
return(0);
}

/*******************************************************************
* Function to return a specparam attribute value. 
*******************************************************************/
double PLIBook_GetAttributeValue(vpiHandle obj_h, char *attribute, 
                                 double default_value)
{
vpiHandle module_h, param_h;
char *object_name;
char param_name[1024]; /* character string to hold attribute name */
s_vpi_value param_val; /* structure to receive attribute value */

param_val.format = vpiRealVal;
module_h = vpi_handle(vpiModule, obj_h); /* get parent module */

/* build specparam name out of object name and attribute name */
object_name = vpi_get_str(vpiName, obj_h);
strcpy(param_name, attribute);
strcat(param_name, object_name);

/* try to get a handle to the object specific attribute */
param_h = vpi_handle_by_name(param_name, module_h);
if (!vpi_chk_error(NULL)) {
    vpi_get_value(param_h, &param_val);
    if (!vpi_chk_error(NULL)) {
        return(param_val.value.real); /* found specific attribute */
    }
}

/* try to get a handle to a general attribute */
strcpy(param_name, attribute);
param_h = vpi_handle_by_name(param_name, module_h);
if (!vpi_chk_error(NULL)) {
    vpi_get_value(param_h, &param_val);
    if (!vpi_chk_error(NULL)) {
        return(param_val.value.real); /* found general attribute */
    }
}

/* failed to find object-specific or general attribute specparam */
return(default_value);
}
```","
vpi_get_str(vpiName, port_h, attribute_name, attribute_value);
}
return(0);
}

/*******************************************************************
* Function to return a specparam attribute value. 
*******************************************************************/
double PLIBook_GetAttributeValue(vpiHandle obj_h, char *attribute, 
                                 double default_value)
{
vpiHandle module_h, param_h;
char *object_name;
char param_name[1024]; /* character string to hold attribute name */
s_vpi_value param_val; /* structure to receive attribute value */

param_val.format = vpiRealVal;
module_h = vpi_handle(vpiModule, obj_h); /* get parent module */

/* build specparam name out of object name and attribute name */
object_name = vpi_get_str(vpiName, obj_h);
strcpy(param_name, attribute);
strcat(param_name, object_name);

/* try to get a handle to the object specific attribute */
param_h = vpi_handle_by_name(param_name, module_h);
if (!vpi_chk_error(NULL)) {
    vpi_get_value(param_h, &param_val);
    if (!vpi_chk_error(NULL)) {
        return(param_val.value.real); /* found specific attribute */
    }
}

/* try to get a handle to a general attribute */
strcpy(param_name, attribute);
param_h = vpi_handle_by_name(param_name, module_h);
if (!vpi_chk_error(NULL)) {
    vpi_get_value(param_h, &param_val);
    if (!vpi_chk_error(NULL)) {
        return(param_val.value.real); /* found general attribute */
    }
}

/* failed to find object-specific or general attribute specparam */
return(default_value);
}
","""Verilog PLI code example for retrieving attribute values from a simulation object.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p193.jpg,True,"The image contains Verilog code. Here is the code:

```verilog
typedef class Statistics; // Define a lower level class

class Transaction;
    Statistics stats;    // Use Statistics class
    ...
endclass

class Statistics;       // Define Statistics class
    ...
endclass

task generator;
    Transaction t;
    t = new;
    transmit(t);
endtask

task transmit(input Transaction t);
    ...
endtask
```

This Verilog code snippet demonstrates the use of classes, object handles, and tasks in SystemVerilog's Object-Oriented Programming (OOP) features.","
typedef class Statistics; // Define a lower level class

class Transaction;
    Statistics stats;    // Use Statistics class
    ...
endclass

class Statistics;       // Define Statistics class
    ...
endclass

task generator;
    Transaction t;
    t = new;
    transmit(t);
endtask

task transmit(input Transaction t);
    ...
endtask
","Sample Verilog code demonstrating object-oriented programming concepts, including class declaration and passing object handles to methods.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p178.jpg,True,"The image includes Verilog code. Here it is:

Sample 5.6:

```verilog
class Transaction;
  logic [31:0] addr, csm, data[8];

  function new(input logic [31:0] a=3, d=5);
    addr = a;
    data = '{default:d};
  endfunction
endclass
```

And in the initial block:

```verilog
initial begin
  Transaction tr;
  tr = new(.a(10)); // a=10, d uses default of 5
end
```

Sample 5.7:

```verilog
class Transaction;
  logic [31:0] addr, csm, data[8];
endclass : Transaction

class Driver;
  Transaction tr;
  function new();
    // Driver's new function
    tr = new(); // Call the Transaction new function
  endfunction
endclass : Driver
```","
class Transaction;
  logic [31:0] addr, csm, data[8];

  function new(input logic [31:0] a=3, d=5);
    addr = a;
    data = '{default:d};
  endfunction
endclass


initial begin
  Transaction tr;
  tr = new(.a(10)); // a=10, d uses default of 5
end


class Transaction;
  logic [31:0] addr, csm, data[8];
endclass : Transaction

class Driver;
  Transaction tr;
  function new();
    // Driver's new function
    tr = new(); // Call the Transaction new function
  endfunction
endclass : Driver
","Caption: ""Explanation of creating new objects in SystemVerilog, demonstrating the use of the new() function with arguments in a Transaction class and a Driver class.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p328.jpg,True,"```verilog
property p1;
  req s_until gnt;
endproperty

property p1;
  req until_with gnt;
endproperty
```

The image contains these two pieces of Verilog code defining properties p1 using temporal logic operators `s_until` and `until_with`.","
property p1;
  req s_until gnt;
endproperty

property p1;
  req until_with gnt;
endproperty
",Explanation of the Verilog `until` and `until_with` properties using simulation log examples.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p160.jpg,True,"```verilog
a1: assert property (@(posedge clk) $past(a));

a1: assert property (@(posedge clk) gnt |-> $past(req));

a1_wrong: assert property (@(posedge clk) $onehot(sig ^ $past(sig)));

a2: assert property (@(posedge clk) nexttime $onehot(sig ^ $past(sig)));

a3_problematic: assert property (
    @(posedge clk) disable iff (rst) $onehot(sig ^ $past(sig)));
```","
a1: assert property (@(posedge clk) $past(a));

a1: assert property (@(posedge clk) gnt |-> $past(req));

a1_wrong: assert property (@(posedge clk) $onehot(sig ^ $past(sig)));

a2: assert property (@(posedge clk) nexttime $onehot(sig ^ $past(sig)));

a3_problematic: assert property (
    @(posedge clk) disable iff (rst) $onehot(sig ^ $past(sig)));
","""Exploring Assertion Techniques in Verilog with Sampled Value Functions and Solution Discussion""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p177.jpg,True,"```c
int PLIbook_ReadTimeVal_calltf(char *user_data)
{
  vpiHandle systf_h, arg_itr, arg_h, timevar_h;
  s_vpi_value timevar_val;  /* structure to receive variable value */

  /* obtain a handle to the system task instance */
  systf_h = vpi_handle(vpiSysTfCall, NULL);

  /* obtain handle to system task argument
     compiler has already verified only 1 arg with correct type */
  arg_itr = vpi_iterate(vpiArgument, systf_h);
  timevar_h = vpi_scan(arg_itr);
  vpi_free_object(arg_itr);  /* free iterator memory */

  timevar_val.format = vpiTimeVal;  /* set value format field */

  vpi_get_value(timevar_h, &timevar_val);  /* read variable's value */

  vpi_printf(""\nTime Variable %s: "", vpi_get_str(vpiName, timevar_h));
  vpi_printf("" hi-word/lo-word = &d/&d\n\n"",
             timevar_val.value.time->high,
             timevar_val.value.time->low);

  return(0);
}
```","LIbook_ReadTimeVal_calltf(char *user_data)
{
  vpiHandle systf_h, arg_itr, arg_h, timevar_h;
  s_vpi_value timevar_val;  /* structure to receive variable value */

  /* obtain a handle to the system task instance */
  systf_h = vpi_handle(vpiSysTfCall, NULL);

  /* obtain handle to system task argument
     compiler has already verified only 1 arg with correct type */
  arg_itr = vpi_iterate(vpiArgument, systf_h);
  timevar_h = vpi_scan(arg_itr);
  vpi_free_object(arg_itr);  /* free iterator memory */

  timevar_val.format = vpiTimeVal;  /* set value format field */

  vpi_get_value(timevar_h, &timevar_val);  /* read variable's value */

  vpi_printf(""\nTime Variable %s: "", vpi_get_str(vpiName, timevar_h));
  vpi_printf("" hi-word/lo-word = &d/&d\n\n"",
             timevar_val.value.time->high,
             timevar_val.value.time->low);

  return(0);
}
","Caption: ""Verilog code example for reading time variable values using VPI routines from a programming guide on Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p148.jpg,True,"The image contains code examples written in SystemVerilog, which is a hardware description and verification language. Below are the code examples from the image:

1.
```verilog
trans ##[0:1] ready
```

2.
```verilog
req ##[2:4] gnt
```

3.
```verilog
a1: assert property (@(posedge clk) req |-> ##[1:5] gnt);
```

4.
```verilog
initial a1: assert property (@(posedge clk) ##[10:12] ready);
```

5.
```verilog
req ##[+1] gnt
```

These snippets describe sequences for synchronization and assertion in hardware verification contexts.","
trans ##[0:1] ready


req ##[2:4] gnt


a1: assert property (@(posedge clk) req |-> ##[1:5] gnt);


initial a1: assert property (@(posedge clk) ##[10:12] ready);


req ##[+1] gnt
","The image shows a textbook section discussing sequence concatenation and delay in Verilog code, with examples and efficiency tips on using delay ranges and assertions within hardware verification.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p472.jpg,True,"```verilog
//constructor
function new (string name, uvm_component parent = null);
    super.new (name, parent);
    cGroup = new;
endfunction
....
endclass

useParams useP1 = new (32,64);

Here’s another example in the same line of thought.

class configurable_cGroup_class;
    int x;
    covergroup construct_bins_cg (input int min, max, num_bins);
        coverpoint x {
            bins lowest  = {min};
            bins highest = {max};
            bins middle[num_bins] = {[min+1:max-1]};
        }
    endgroup

    function new(int min, int width);
        int max = min + width - 1;
        int n_bins = (width - 2) / 4; // aim for 4 values per bin
        construct_bins_cg = new(min, max, n_bins);
    endfunction
endclass

configurable_cGroup_class cgClass = new(16, 32);
```","
//constructor
function new (string name, uvm_component parent = null);
    super.new (name, parent);
    cGroup = new;
endfunction
....
endclass

useParams useP1 = new (32,64);

Here’s another example in the same line of thought.

class configurable_cGroup_class;
    int x;
    covergroup construct_bins_cg (input int min, max, num_bins);
        coverpoint x {
            bins lowest  = {min};
            bins highest = {max};
            bins middle[num_bins] = {[min+1:max-1]};
        }
    endgroup

    function new(int min, int width);
        int max = min + width - 1;
        int n_bins = (width - 2) / 4; // aim for 4 values per bin
        construct_bins_cg = new(min, max, n_bins);
    endfunction
endclass

configurable_cGroup_class cgClass = new(16, 32);
","Caption: ""Example of creating a coverage group and an array of instances in Verilog for functional coverage measurement.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p314.jpg,True,"```verilog
global clocking @clk; endclocking
...
assert property(@(global_clock) a);
```

```verilog
assert property(@(clk) a);
```","
global clocking @clk; endclocking
...
assert property(@(global_clock) a);


assert property(@(clk) a);
","""Overview of Global Clocking in SystemVerilog and Implications on Simulation Efficiency""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p385.jpg,True,"The image contains text which appears to describe part of the Verilog Hardware Description Language (HDL) specification. Specifically, it's about sequence specification in Verilog and shows the Backus-Naur Form (BNF) grammar for this construct. However, it doesn't contain actual code written in Verilog, but rather the syntax rules for how to write sequence specifications. Here is the captured text from the image:

```
Example C-18 Sequence specification

cycle_delay_range ::=
    '##' constant_expression
   | '##' '[' const_range_expression ']'

const_range_expression ::=
    constant_expression : constant_expression
   | constant_expression : '$'

sequence_expr ::= [ cycle_delay_range ]
    sequence_expr { cycle_delay_range sequence_expr }
   | expression_or_dist [boolean_repeat]
   | expression_or_dist { ',' sequence_match_item } [boolean_repeat]
   | sequence_instance [ consecutive_repeat ]
   | sequence_expr { ',' sequence_match_item } [consecutive_repeat]
   | event_control sequence_expr
   | '(' sequence_expr ')'
   | sequence_expr and sequence_expr
   | sequence_expr or sequence_expr
   | sequence_expr intersect sequence_expr
   | sequence_expr within sequence_expr
   | expression throughout sequence_expr

sequence_match_item ::= variable_assignment | subroutine_call

expression_or_dist ::= expression
   | expression dist '{' dist_list '}'

boolean_repeat ::= consecutive_repeat
   | nonconsecutive_repeat
   | goto_repeat

consecutive_repeat ::=
    '[' '*' const_range_expression ']'

nonconsecutive_repeat ::=
    '[' '=' const_range_expression ']'

goto_repeat ::=
    '[' '->' const_range_expression ']'
```

This text outlines the formal grammar used for specifying sequences in Verilog assertions. It is an abstract representation and not executable code.","e C-18 Sequence specification

cycle_delay_range ::=
    '##' constant_expression
   | '##' '[' const_range_expression ']'

const_range_expression ::=
    constant_expression : constant_expression
   | constant_expression : '$'

sequence_expr ::= [ cycle_delay_range ]
    sequence_expr { cycle_delay_range sequence_expr }
   | expression_or_dist [boolean_repeat]
   | expression_or_dist { ',' sequence_match_item } [boolean_repeat]
   | sequence_instance [ consecutive_repeat ]
   | sequence_expr { ',' sequence_match_item } [consecutive_repeat]
   | event_control sequence_expr
   | '(' sequence_expr ')'
   | sequence_expr and sequence_expr
   | sequence_expr or sequence_expr
   | sequence_expr intersect sequence_expr
   | sequence_expr within sequence_expr
   | expression throughout sequence_expr

sequence_match_item ::= variable_assignment | subroutine_call

expression_or_dist ::= expression
   | expression dist '{' dist_list '}'

boolean_repeat ::= consecutive_repeat
   | nonconsecutive_repeat
   | goto_repeat

consecutive_repeat ::=
    '[' '*' const_range_expression ']'

nonconsecutive_repeat ::=
    '[' '=' const_range_expression ']'

goto_repeat ::=
    '[' '->' const_range_expression ']'
",The image shows a section of a document covering sequence composition in Verilog with an example of Backus-Naur Form (BNF) specification for sequence expressions.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p267.jpg,True,"The image contains Verilog code related to SystemVerilog Assertions (SVA). Here is the code from the image:

```verilog
endproperty

property p_mchk7_after;
@(posedge clk)
  s_mchk7_after.ended |-> reqn [*2];

endproperty

a_mchk7_before: assert property(p_mchk7_before);
a_mchk7_after: assert property(p_mchk7_after);

c_mchk7_before: cover property(p_mchk7_before);
c_mchk7_after: cover property(p_mchk7_after);
```

This Verilog code snippet defines a property `p_mchk7_after` and uses `assert` and `cover` directives to check and cover the property for certain conditions in a clocked process. The assertions (`a_mchk7_before` and `a_mchk7_after`) and coverage points (`c_mchk7_before` and `c_mchk7_after`) are based on the property(`p_mchk7_after`) which checks for a sequence of events related to the `reqn` signal after a positive edge of the `clk` signal.","
endproperty

property p_mchk7_after;
@(posedge clk)
  s_mchk7_after.ended |-> reqn [*2];

endproperty

a_mchk7_before: assert property(p_mchk7_before);
a_mchk7_after: assert property(p_mchk7_after);

c_mchk7_before: cover property(p_mchk7_before);
c_mchk7_after: cover property(p_mchk7_after);
","""Verilog SystemVerilog Assertions (SVA) for protocol interface checking in a PCI master application""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p273.jpg,True,"```verilog
property p_mchk12;
@(posedge clk)
`s_DUAL_ADDR_CYCLE && req64n |=> ...
```

The code in the image is cropped, and therefore incomplete. It shows just a snippet which appears to be a part of a SystemVerilog assertion to check a property named `p_mchk12`.","
property p_mchk12;
@(posedge clk)
`s_DUAL_ADDR_CYCLE && req64n |=> ...
","""Example of a SystemVerilog Assertion (SVA) for a PCI Master check with waveform diagram and description of a special cycle""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p300.jpg,True,"```verilog
@(negedge rclk) first_match(rd_detect(ptr),
$display($stime,,,"" Assertion Disp FIRST_MATCH ptr=%h Compare data=%h fifo_out=%h"", ptr, data, fifo_out) )
##0 (fifo_out === data);

endproperty

dcheck : assert property (data_check(aff1_wr_ptr)) else
$display($stime,,,""FAIL: DATA CHECK"");
dcheck:coverproperty(data_check(aff1_wr_ptr))$display($stime,,,""PASS: DATA CHECK"");
```

```verilog
property full_empty;
@(posedge wclk) disable iff (!wclk_reset_n)
@(posedge wclk) (full) |=> @(posedge rclk) (!empty);

endproperty

few: assert property (full_empty) else $display($stime,,,""FAIL: Full and Empty BOTH asserted"");
cfew: cover property (full_empty) $display($stime,,,"" PASS: Full and Empty check "");
```

```verilog
property empty_full;
@(posedge wclk) disable iff (!wclk_reset_n)
@(posedge rclk) (empty) |=> @(posedge wclk) (!full);

endproperty
```","
@(negedge rclk) first_match(rd_detect(ptr),
$display($stime,,,"" Assertion Disp FIRST_MATCH ptr=%h Compare data=%h fifo_out=%h"", ptr, data, fifo_out) )
##0 (fifo_out === data);

endproperty

dcheck : assert property (data_check(aff1_wr_ptr)) else
$display($stime,,,""FAIL: DATA CHECK"");
dcheck:coverproperty(data_check(aff1_wr_ptr))$display($stime,,,""PASS: DATA CHECK"");


property full_empty;
@(posedge wclk) disable iff (!wclk_reset_n)
@(posedge wclk) (full) |=> @(posedge rclk) (!empty);

endproperty

few: assert property (full_empty) else $display($stime,,,""FAIL: Full and Empty BOTH asserted"");
cfew: cover property (full_empty) $display($stime,,,"" PASS: Full and Empty check "");


property empty_full;
@(posedge wclk) disable iff (!wclk_reset_n)
@(posedge rclk) (empty) |=> @(posedge wclk) (!full);

endproperty
","""Verilog Assertions for Asynchronous FIFO: Data Match and Full/Empty Conditions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p466.jpg,True,"The image contains a snippet of Verilog code which is an example of a class that includes an embedded covergroup. Here is the code presented in the image:

```verilog
class xyz;
  bit [3:0] m_x;
  int m_y;
  bit m_z;

  covergroup xyzCover @(m_z);
    coverpoint m_x;
    coverpoint m_y;
  endgroup

  function new();
    xyzCover xyzCovInst = new;
  endfunction
endclass
```

Please note that this code snippet is a part of a more extensive explanation about using embedded ""covergroup"" within a ""class"" in SystemVerilog for functional coverage purposes.","
class xyz;
  bit [3:0] m_x;
  int m_y;
  bit m_z;

  covergroup xyzCover @(m_z);
    coverpoint m_x;
    coverpoint m_y;
  endgroup

  function new();
    xyzCover xyzCovInst = new;
  endfunction
endclass
","A textbook excerpt discussing the concept of embedding a ""covergroup"" within a ""class"" in SystemVerilog, including a code example.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p150.jpg,True,"The image includes a snippet of code from a Verilog-related context. Here's the code extracted from the image:

```verilog
##2 arbif.cb.request <= 0; // Wait 2 cycles then assign
##3; // Illegal - must be used with an assignment
```

This snippet is discussing the concept of introducing delays in signal assignments in Verilog, and what is considered legal or illegal in this context.","
##2 arbif.cb.request <= 0; // Wait 2 cycles then assign
##3; // Illegal - must be used with an assignment
","""Explaining signal drive with cycle delay in Verilog coding""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p469.jpg,True,"```verilog
x = 0;
y = 0;
while(true)
{
    if(x <= 50) y++;
    else y--;

    if(y < 0) break;

    x++;
}
```
This is the code snippet from the image which is written in a C-like syntax, not Verilog. The image is discussing a running example relating to program analysis, using a simple loop with non-regular behavior.","
x = 0;
y = 0;
while(true)
{
    if(x <= 50) y++;
    else y--;

    if(y < 0) break;

    x++;
}
","""An academic figure illustrating control-flow graph, program states, and state approximation for loop analysis in program verification""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p148.jpg,True,"The image contains two snippets of Verilog/SystemVerilog code which are presented as solutions to a specific Gotcha related to event triggering in Verilog and SystemVerilog. Here is the code from the image:

Verilog solution:

```verilog
initial #0 -> get_data;   // OK! delayed trigger

always @(get_data) begin  // wait for a get_data event
    ... // code to get data
```

SystemVerilog solution 1:

```verilog
initial ->> get_data;   // OK! trigger after delta

always @(get_data) begin  // wait for a get_data event
    ... // code to get data
```

The second part of SystemVerilog solution 2 is mentioned but not shown in the image.","
initial #0 -> get_data;   // OK! delayed trigger

always @(get_data) begin  // wait for a get_data event
    ... // code to get data


initial ->> get_data;   // OK! trigger after delta

always @(get_data) begin  // wait for a get_data event
    ... // code to get data
","This image includes text explaining how to avoid certain issues in Verilog and SystemVerilog, depicting examples of code to solve the trigger delay problem.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p538.jpg,True,"```verilog
always_comb
    begin
    Products = B*B + B*X - 1;
    Result = Products + xProducts;
    end

always_latch
    if (S_Z) S <= Z;

always_ff @(posedge Clk iff Rst == 1'b0)
    CountReg <= CountReg + 1;

module MyModule(rest of header);
    timeunit 1ns; // Time is in units of ns.
    timeprecision 100 ps; // Time is to a precision of 100 ps.
(rest of module)
endmodule

module MyOtherModule ( . . .);
    timeunit 1ns/100ps; // Same effect as ""`timescale 1ns/100ps"".
    . . .
endmodule
```","
always_comb
    begin
    Products = B*B + B*X - 1;
    Result = Products + xProducts;
    end

always_latch
    if (S_Z) S <= Z;

always_ff @(posedge Clk iff Rst == 1'b0)
    CountReg <= CountReg + 1;

module MyModule(rest of header);
    timeunit 1ns; // Time is in units of ns.
    timeprecision 100 ps; // Time is to a precision of 100 ps.
(rest of module)
endmodule

module MyOtherModule ( . . .);
    timeunit 1ns/100ps; // Same effect as ""`timescale 1ns/100ps"".
    . . .
endmodule
","Verilog code examples demonstrating always_comb, always_latch, and always_ff blocks, as well as information on new timescale alternatives and loop commands in SystemVerilog.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p68.jpg,True,"The image contains Verilog code. Here it is:

```verilog
always @* begin // OK, infers @(a, b)
  sum = a + b;
end

always @* begin // OK, infers @(a, b)
  prod = mult(a, b); // call function that reads a, b
end

always @* begin // OK, infers @(sel, sum, prod)
  out = sel? sum : prod ;
end

function [15:0] mult (input [7:0] m, n);
  mult = m * n;
endfunction
```","
always @* begin // OK, infers @(a, b)
  sum = a + b;
end

always @* begin // OK, infers @(a, b)
  prod = mult(a, b); // call function that reads a, b
end

always @* begin // OK, infers @(sel, sum, prod)
  out = sel? sum : prod ;
end

function [15:0] mult (input [7:0] m, n);
  mult = m * n;
endfunction
","""Understanding Sensitivity Lists in Verilog and the Gotchas of the @* Wildcard Sensitivity List""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p160.jpg,True,"```verilog
reg [3:0] i;                   // 4-bit loop control variable
for (i=0; i<=15; i=i+1)        // GOTCHA! i<=15 is always true
  begin
    // loop body */ end
```

```verilog
reg [3:0] result;               // 4-bit design or test variable
for (int i=0; i<=15; i=i+1)    // OK, i can have a value greater
                                // than 15
  @(posedge clk) result = i;    // OK, but mismatch in assignment
                                // sizes
```

The code in the image illustrates a ""gotcha"" or common mistake that can occur when using loops in Verilog, particularity when the loop control variable's size is too small to hold the necessary count, resulting in an infinite loop. The second block of code provides a correct way to define the loop control variable as an `int`, which can hold a value greater than 15.","
reg [3:0] i;                   // 4-bit loop control variable
for (i=0; i<=15; i=i+1)        // GOTCHA! i<=15 is always true
  begin
    // loop body */ end


reg [3:0] result;               // 4-bit design or test variable
for (int i=0; i<=15; i=i+1)    // OK, i can have a value greater
                                // than 15
  @(posedge clk) result = i;    // OK, but mismatch in assignment
                                // sizes
",An explanation of a common pitfall in Verilog coding: creating an infinite for loop by using a loop control variable that is too small.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p385.jpg,True,"There is Verilog code present in the image. Here are the code excerpts:

```verilog
covergroup CovDst28;
  coverpoint tr.dst {
    option.auto_bin_max = 4; // 0:1, 2:3, 4:5, 6:7
    ignore_bins hi = {6,7};  // Ignore upper 2 values
  }
endgroup
```

```verilog
covergroup CovDst29;
  coverpoint tr.dst {
    illegal_bins hi = {6,7}; // Give error if seen
  }
endgroup
```","
covergroup CovDst28;
  coverpoint tr.dst {
    option.auto_bin_max = 4; // 0:1, 2:3, 4:5, 6:7
    ignore_bins hi = {6,7};  // Ignore upper 2 values
  }
endgroup


covergroup CovDst29;
  coverpoint tr.dst {
    illegal_bins hi = {6,7}; // Give error if seen
  }
endgroup
","""Verilog Coverage Techniques Showing How to Use Auto Bin Max and Ignore Bins for Data Sampling""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p333.jpg,True,"The image contains a portion of text related to computer science, specifically it shows a BNF-like grammar definition that resembles code. Here is the content that looks like code:

```
P ::= defn thlist
thlist ::= null | stmt thlist
defn ::= int Y | lock L | defn ; defn
stmt ::= x := e
        | while (b) { stmt } | begin stmt end
        | if (b) { stmt } else { stmt } | skip
        | acquire(L) | release(L) | stmt ; stmt
e ::= i | x | Y | e + e | e * e | e/e
b ::= true | false | e op e | b ∨ b | ¬b

op ∈ {<, ≤, >, ≥, =, ≠}
x ∈ LVar, Y ∈ GVar, i ∈ Integer, L ∈ Lock
```

This excerpt is labeled as ""Fig. 2. SML syntax,"" suggesting an example of syntax definitions for some language, perhaps SML (Standard ML), although SML is itself a different programming language. This code-like text is defining the grammar of a simple language that includes variable definitions, statements, expressions, and boolean expressions for some theoretical or domain-specific language.","defn thlist
thlist ::= null | stmt thlist
defn ::= int Y | lock L | defn ; defn
stmt ::= x := e
        | while (b) { stmt } | begin stmt end
        | if (b) { stmt } else { stmt } | skip
        | acquire(L) | release(L) | stmt ; stmt
e ::= i | x | Y | e + e | e * e | e/e
b ::= true | false | e op e | b ∨ b | ¬b

op ∈ {<, ≤, >, ≥, =, ≠}
x ∈ LVar, Y ∈ GVar, i ∈ Integer, L ∈ Lock
","""Syntax definition for the SML language and an introduction to Petri nets and traces.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p276.jpg,True,"The image contains Verilog code. Here it is transcribed:

```verilog
assign B.D = C.Q;

assign A.B.D = A.C.Q;

assign A.D.E.OutBus = OutWire;

assign D.E.OutBus = C.OutWire;
```

These are examples of hierarchical references in Verilog for connecting different modules or instances within a digital design.","
assign B.D = C.Q;

assign A.B.D = A.C.Q;

assign A.D.E.OutBus = OutWire;

assign D.E.OutBus = C.OutWire;
",The image is a page from a textbook discussing the use of hierarchical names in Verilog code and the implications of such usage for digital VLSI design.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p391.jpg,True,"The image contains Verilog code for examples of cross coverage and use of bins. Here is the code as written in the image:

```verilog
Sample 9.36 Cross coverage with bin names

class Sample;
    rand bit a, b;
endclass

Sample sam;

covergroup CrossBinNames;
    a: coverpoint sam.a
    {
        bins a0 = {0};
        bins a1 = {1};
        option.weight=0;  // Don't count this coverpoint
    }
    b: coverpoint sam.b
    {
        bins b0 = {0};
        bins b1 = {1};
        option.weight=0;  // Don't count this coverpoint
    }
    ab: cross a, b
    {
        bins a0b0 = binsof(a.a0) && binsof(b.b0);
        bins a1b0 = binsof(a.a1) && binsof(b.b0);
        bins b1   = binsof(b.b1);
    }
endgroup
```

```verilog
Sample 9.37 Cross coverage with binsof

covergroup CrossBinsofIntersect;
    a: coverpoint sam.a
    {
        option.weight=0;  // Don't count this coverpoint
    }
    b: coverpoint sam.b
    {
        option.weight=0;  // Don't count this coverpoint
    }
    ab: cross a, b
    {
        bins a0b0 = binsof(a) intersect {0} &&
                    binsof(b) intersect {0};
        bins a1b0 = binsof(a) intersect {1} &&
                    binsof(b) intersect {0};
        bins b1   = binsof(b) intersect {1};
    }
endgroup
```

The text in the image also explains that you can name bins in cover points and then gather cross coverage using those bins. It also notes that one can use `binsof` to specify the cross coverage values more efficiently.","
Sample 9.36 Cross coverage with bin names

class Sample;
    rand bit a, b;
endclass

Sample sam;

covergroup CrossBinNames;
    a: coverpoint sam.a
    {
        bins a0 = {0};
        bins a1 = {1};
        option.weight=0;  // Don't count this coverpoint
    }
    b: coverpoint sam.b
    {
        bins b0 = {0};
        bins b1 = {1};
        option.weight=0;  // Don't count this coverpoint
    }
    ab: cross a, b
    {
        bins a0b0 = binsof(a.a0) && binsof(b.b0);
        bins a1b0 = binsof(a.a1) && binsof(b.b0);
        bins b1   = binsof(b.b1);
    }
endgroup


Sample 9.37 Cross coverage with binsof

covergroup CrossBinsofIntersect;
    a: coverpoint sam.a
    {
        option.weight=0;  // Don't count this coverpoint
    }
    b: coverpoint sam.b
    {
        option.weight=0;  // Don't count this coverpoint
    }
    ab: cross a, b
    {
        bins a0b0 = binsof(a) intersect {0} &&
                    binsof(b) intersect {0};
        bins a1b0 = binsof(a) intersect {1} &&
                    binsof(b) intersect {0};
        bins b1   = binsof(b) intersect {1};
    }
endgroup
",Verilog code examples demonstrating cross coverage with named bins and use of binsof operator to specify cross coverage values.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p262.jpg,True,"```verilog
X = 4'b101x;
Y = 4'b101z;
// ...
if (X==^4'b101x) ...; // Evaluates as '1x'; won't match the value above.
if (X==Y) ...;        // Won't match; and if (X!=Y) won't, either.
if (X==^X) ...;       // This won't match, either!
//
case (X)
    4'b1010: ...;
    4'b1011: ...;
    4'b101z: ...;
    4'bxxxx: ...;
    4'bzzzz: ...; // Comma separation is legal.
    default: ...; // This will execute because nothing else did.
endcase
case (X)
    4'b1010: ...;
    4'b101x: ...; // This matches and will execute.
    4'b101z: ...;
    4'bxxxx: ...;
    4'bzzzz: ...;
    default: ...;
endcase

// Consider these examples:

X = 4'b101x;
Y = 4'b101z;
// ...
if (X==^4'b101x) else ...; // expr = 1; the if executes.
if (X!==Y) else ...;       // expr = 1; the if executes.
if (X!=Y) else ...;        // expr = x; the else executes.
//
// The conditional operator is not an if but accepts case equality:
Z = (X==^Y) ? 1'b1: 1'b0;  // Assigns 1'bx.
Z = (X!==Y) ? 1'b1: 1'b0;  // Assigns 1'b0.
Z = (X!=Y) ? 1'b1: 1'b0;   // Assigns 1'b1.
```","
X = 4'b101x;
Y = 4'b101z;
// ...
if (X==^4'b101x) ...; // Evaluates as '1x'; won't match the value above.
if (X==Y) ...;        // Won't match; and if (X!=Y) won't, either.
if (X==^X) ...;       // This won't match, either!
//
case (X)
    4'b1010: ...;
    4'b1011: ...;
    4'b101z: ...;
    4'bxxxx: ...;
    4'bzzzz: ...; // Comma separation is legal.
    default: ...; // This will execute because nothing else did.
endcase
case (X)
    4'b1010: ...;
    4'b101x: ...; // This matches and will execute.
    4'b101z: ...;
    4'bxxxx: ...;
    4'bzzzz: ...;
    default: ...;
endcase

// Consider these examples:

X = 4'b101x;
Y = 4'b101z;
// ...
if (X==^4'b101x) else ...; // expr = 1; the if executes.
if (X!==Y) else ...;       // expr = 1; the if executes.
if (X!=Y) else ...;        // expr = x; the else executes.
//
// The conditional operator is not an if but accepts case equality:
Z = (X==^Y) ? 1'b1: 1'b0;  // Assigns 1'bx.
Z = (X!==Y) ? 1'b1: 1'b0;  // Assigns 1'b0.
Z = (X!=Y) ? 1'b1: 1'b0;   // Assigns 1'b1.
","Verilog code examples explaining conditional operator, case equality operator, and matching unknowns ('x' and 'z') in conditional statements.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p174.jpg,True,"```verilog
function void build_env(Consumer c, Producer p); // GOTCHA!
  c = new(); // construct object and store handle in c
  p = new(); // construct object and store handle in p
  ... // set up rest of environment
endfunction

initial begin
  Consumer c;
  Producer p;
  build_env(c, p); // construct and set up objects

  c.randomize;     // ERROR: c does not contain an object handle
end
```

```verilog
function void build_env(ref Consumer c, ref Producer p);
```
The image contains these snippets of Verilog code, along with an explanation of a common pitfall (Gotcha) and how to avoid it when passing handles to methods in Verilog/SystemVerilog.","
function void build_env(Consumer c, Producer p); // GOTCHA!
  c = new(); // construct object and store handle in c
  p = new(); // construct object and store handle in p
  ... // set up rest of environment
endfunction

initial begin
  Consumer c;
  Producer p;
  build_env(c, p); // construct and set up objects

  c.randomize;     // ERROR: c does not contain an object handle
end


function void build_env(ref Consumer c, ref Producer p);
","""Explanation of the importance of using 'ref' arguments instead of 'input' in Verilog methods when passing object handles to retain changes in the calling scope.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p504.jpg,True,"The image contains Verilog code. Here's the text extracted from it:

```verilog
`include ""FullDup.inc"" // timescale & period delays.
//
module FullDup
#(parameter DWid = 32 // 32 bits wide.
          , RxLogDepthA = 3, TxLogDepthA = 3 // 3 -> 8 words deep.
          , RxLogDepthB = 4, TxLogDepthB = 4 // 4 -> 16 words deep.
)
(
  output[DWid-1:0] OutParDataA, OutParDataB
, input[DWid-1:0] InParDataA, InParDataB
, input InParValidA, InParValidB
, ClockA, ClockB, Reset
);
//
wire SerLine1, SerLine2
, RxRequestA, RxRequestB, TxRequestA, TxRequestB;

assign RxRequestA = 1'b1;
assign RxRequestB = 1'b1;
assign TxRequestA = InParValidA;
assign TxRequestB = InParValidB;
//
SerDes #( .DWid(DWid) // Parameter values.
        , .RxLogDepth(RxLogDepthB)
        , .TxLogDepth(TxLogDepthA)
)
SerDes_U1 // Ports reordered:
( .ParOutRxCk(OutParDataB) , .SerLineXfer(SerLine1)
, .RxRequest(RxRequestB) , .ParDataIn(InParDataA)
, InParValid(InParValidA) , .TxRequest(TxRequestA)
, .InParClk(ClockA), .OutParClk(ClockB), .Reset(Reset)
);
(similarly for SerDes_U2; but, with SerLine2, and with 'A' & 'B' suffixes reversed)
```

The code snippet is for a `FullDup` Verilog module. Parameters and port definitions are provided for the module, and the instantiation of a `SerDes` component is given with parameters and port mappings. A portion of the SerDes instantiation for another unit `SerDes_U2` is mentioned but not provided in full detail, instead noted as having 'A' & 'B' suffixes reversed compared to `SerDes_U1`.","
`include ""FullDup.inc"" // timescale & period delays.
//
module FullDup
#(parameter DWid = 32 // 32 bits wide.
          , RxLogDepthA = 3, TxLogDepthA = 3 // 3 -> 8 words deep.
          , RxLogDepthB = 4, TxLogDepthB = 4 // 4 -> 16 words deep.
)
(
  output[DWid-1:0] OutParDataA, OutParDataB
, input[DWid-1:0] InParDataA, InParDataB
, input InParValidA, InParValidB
, ClockA, ClockB, Reset
);
//
wire SerLine1, SerLine2
, RxRequestA, RxRequestB, TxRequestA, TxRequestB;

assign RxRequestA = 1'b1;
assign RxRequestB = 1'b1;
assign TxRequestA = InParValidA;
assign TxRequestB = InParValidB;
//
SerDes #( .DWid(DWid) // Parameter values.
        , .RxLogDepth(RxLogDepthB)
        , .TxLogDepth(TxLogDepthA)
)
SerDes_U1 // Ports reordered:
( .ParOutRxCk(OutParDataB) , .SerLineXfer(SerLine1)
, .RxRequest(RxRequestB) , .ParDataIn(InParDataA)
, InParValid(InParValidA) , .TxRequest(TxRequestA)
, .InParClk(ClockA), .OutParClk(ClockB), .Reset(Reset)
);
(similarly for SerDes_U2; but, with SerLine2, and with 'A' & 'B' suffixes reversed)
","Caption: ""Excerpt from Digital VLSI Design with Verilog showing a segment of a Verilog code example for a Full Duplex module with parameter definitions and instantiation instructions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p410.jpg,True,"```verilog
typedef bit [0:$clog2(MAX_OUTSTANDING)] counterType;
property p_fifo_data_check(local input counterType numAhead);
    dataType data = dataIn;
    ##1 (numAhead > 0 ##0 complete[-1], numAhead--) [*]
    ##1 (numAhead == 0 ##0 complete[-1])
    |-> 
    dataOut == data;
endproperty

property p_fifo_all_checks;
    counterType outstanding, nextOutstanding = '0;
    (
        (start || complete) [-1],
        outstanding = nextOutstanding,
        nextOutstanding += start - complete
    ) [+]
    |->
    if (start) {
        (!complete && outstanding < MAX_OUTSTANDING)
        and p_fifo_data_check(.numAhead(outstanding))
    } else { // complete
        !start && outstanding > 0
    };
endproperty

initial
    a_fifo_all_checks: assert property (
        p_fifo_all_checks
    );
```","
typedef bit [0:$clog2(MAX_OUTSTANDING)] counterType;
property p_fifo_data_check(local input counterType numAhead);
    dataType data = dataIn;
    ##1 (numAhead > 0 ##0 complete[-1], numAhead--) [*]
    ##1 (numAhead == 0 ##0 complete[-1])
    |-> 
    dataOut == data;
endproperty

property p_fifo_all_checks;
    counterType outstanding, nextOutstanding = '0;
    (
        (start || complete) [-1],
        outstanding = nextOutstanding,
        nextOutstanding += start - complete
    ) [+]
    |->
    if (start) {
        (!complete && outstanding < MAX_OUTSTANDING)
        and p_fifo_data_check(.numAhead(outstanding))
    } else { // complete
        !start && outstanding > 0
    };
endproperty

initial
    a_fifo_all_checks: assert property (
        p_fifo_all_checks
    );
",Verilog code for FIFO protocol checks using properties in SystemVerilog.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p361.jpg,True,"The image contains code written in C that defines a structure for use with Verilog PLI (Programming Language Interface) tasks. I'll transcribe it for you:

```c
typedef struct t_tfexprinfo
{
    short expr_type;
    short padding;
    struct t_vecval *expr_value_p;
    double real_value;
    char *expr_string;
    int expr_nargs;
    int expr_vec_size;
    int expr_sign;
    int expr_lhs_select;
    int expr_rhs_select;
    s_tfexprinfo *p_tfexprinfo;
} s_tfexprinfo;
```
Additionally, there are examples showing how to allocate memory for such a structure:

```c
s_tfexprinfo arg_info;
tf_exprinfo(n, &arg_info);
```

And for persistent storage:

```c
p_tfexprinfo arg_info;
arg_info = (p_tfexprinfo)malloc(sizeof(s_tfexprinfo));
tf_exprinfo(n, arg_info);
```","ef struct t_tfexprinfo
{
    short expr_type;
    short padding;
    struct t_vecval *expr_value_p;
    double real_value;
    char *expr_string;
    int expr_nargs;
    int expr_vec_size;
    int expr_sign;
    int expr_lhs_select;
    int expr_rhs_select;
    s_tfexprinfo *p_tfexprinfo;
} s_tfexprinfo;

xprinfo arg_info;
tf_exprinfo(n, &arg_info);

xprinfo arg_info;
arg_info = (p_tfexprinfo)malloc(sizeof(s_tfexprinfo));
tf_exprinfo(n, arg_info);
","Caption: ""Excerpt from a book discussing the usage of the s_tfexprinfo structure in Verilog PLI (Programming Language Interface) with an example of how to allocate and use this structure in TF routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p376.jpg,True,"Here is the Verilog code present in the image:

```verilog
property p1(byte data);
    byte l_byte = data, l_byteMasked = l_byte & mask;
    ...
endproperty

property p1_illegal;
    byte l_byte, l_byteMasked = l_byte ^ mask;
    ...
endproperty
```","
property p1(byte data);
    byte l_byte = data, l_byteMasked = l_byte & mask;
    ...
endproperty

property p1_illegal;
    byte l_byte, l_byteMasked = l_byte ^ mask;
    ...
endproperty
","This image contains text and code examples discussing the mechanics of local variables in SystemVerilog, focusing on legal and illegal declaration assignments in the context of hardware verification properties.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p362.jpg,True,"The image contains Verilog code snippets. Here is the first code excerpt:

```verilog
dataType data[tagType];
always @(posedge clk)
  if ($sampled(start)) begin
    a_no_tag_reuse: assert final (
      !data.exists($sampled(tagIn))
    );
    data[$sampled(tagIn)] <= $sampled(dataIn);
  end else if ($sampled(complete)) begin
    a_comp_tag_ok: assert final (data.exists($sampled(tagOut))
    );
    a_data_check: assert final (
      $sampled(dataOut) == data[$sampled(tagOut)]
    );
    data.delete($sampled(tagOut));
  end
```

And here is the second code excerpt:

```verilog
property p_tag_data_check;
  tagType tag;
  dataType data;
  (start, tag = tagIn, data = dataIn)
  ##1 (complete && tagOut == tag) [-1]
  -> dataOut == data;
a_tag_data_check: assert property (p_tag_data_check);
```

These code blocks are related to the encoding of a tag protocol control and data check.","
dataType data[tagType];
always @(posedge clk)
  if ($sampled(start)) begin
    a_no_tag_reuse: assert final (
      !data.exists($sampled(tagIn))
    );
    data[$sampled(tagIn)] <= $sampled(dataIn);
  end else if ($sampled(complete)) begin
    a_comp_tag_ok: assert final (data.exists($sampled(tagOut))
    );
    a_data_check: assert final (
      $sampled(dataOut) == data[$sampled(tagOut)]
    );
    data.delete($sampled(tagOut));
  end


property p_tag_data_check;
  tagType tag;
  dataType data;
  (start, tag = tagIn, data = dataIn)
  ##1 (complete && tagOut == tag) [-1]
  -> dataOut == data;
a_tag_data_check: assert property (p_tag_data_check);
","""Example of Verilog code for tag protocol control and data check with assertions and properties""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p413.jpg,True,"```verilog
always @(a or b)
    $my_strobe(sum);
```

```verilog
always @(a or b)
    sum = a + b;
```

```c
int PLIbook_MyStrobe_calltf() {
    tf_rosynchronize();
    return(0);
}
```

```c
int PLIbook_MyStrobe_miscft(int user_data, int reason) {
    if (reason == REASON_ROSYNCH) {
        io_printf(""Status of tfarg 1 is %s:\n"", tf_strgetp(1,'b'));
    }
    return(0);
}
```","
always @(a or b)
    $my_strobe(sum);


always @(a or b)
    sum = a + b;

LIbook_MyStrobe_calltf() {
    tf_rosynchronize();
    return(0);
}

LIbook_MyStrobe_miscft(int user_data, int reason) {
    if (reason == REASON_ROSYNCH) {
        io_printf(""Status of tfarg 1 is %s:\n"", tf_strgetp(1,'b'));
    }
    return(0);
}
","""Understanding the use of $my_strobe in Verilog simulations with an example of misctf and calltf routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p408.jpg,True,"The image contains Verilog code. Here are the contents from the image:

Sample 10.13 Test harness without interfaces in the port list
```verilog
module top;
  bus_ifc bus();         // Instantiate the interface
  test t1();             // Don't use port list for test
  dut d1(bus);           // Still use port list for DUT
  ...
endmodule
```

This approach is recommended by methodologies such as the VMM to make your test code more reusable. If you add a new interface to your design, as shown in Sample 10.14, the test harness changes, but existing tests don’t have to change.

Sample 10.14 Test harness with a second interface
```verilog
module top;
  bus_ifc bus();         // Instantiate the interface
  new_ifc newb();        // and a new one
  test t1();             // Instantiation remains the same
  dut d1(bus, newb);
  ...
endmodule
```

The harness in Sample 10.14 works with the test in Sample 10.12 that does not know about the new interface, as well as the test in Sample 10.15 that does.

Sample 10.15 Test with two virtual interfaces and XMRs
```verilog
program automatic test ();
  virtual bus_ifc bus = top.bus;
  virtual new_ifc newb = top.newb

  initial begin
    $display(bus.data);  // Use existing interface
    $display(newb.addr); // and new one
  end
endprogram
```

---

Please note that the text in the image may contain additional context and information related to the code that I've transcribed above.","
module top;
  bus_ifc bus();         // Instantiate the interface
  test t1();             // Don't use port list for test
  dut d1(bus);           // Still use port list for DUT
  ...
endmodule


module top;
  bus_ifc bus();         // Instantiate the interface
  new_ifc newb();        // and a new one
  test t1();             // Instantiation remains the same
  dut d1(bus, newb);
  ...
endmodule


program automatic test ();
  virtual bus_ifc bus = top.bus;
  virtual new_ifc newb = top.newb

  initial begin
    $display(bus.data);  // Use existing interface
    $display(newb.addr); // and new one
  end
endprogram
","Caption: ""Examples of Verilog test harnesses utilizing interfaces to improve code reusability and maintenance in modular hardware verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p83.jpg,True,"The image contains a snippet of Verilog code. Here is the Verilog code that is shown:

```verilog
always @(posedge clk)
    if (!rstn) clk_divided2 = 0;
    else       clk_divided2 = ~clk_divided2; // OK, immediate update
```

This code represents a clock divider concept in Verilog, which uses blocking assignments to ensure an immediate update of the `clk_divided2` variable upon the positive edge of the `clk`. The comment indicates that it is an acceptable way to code for an immediate update, avoiding a race condition in simulation.","
always @(posedge clk)
    if (!rstn) clk_divided2 = 0;
    else       clk_divided2 = ~clk_divided2; // OK, immediate update
","Caption: ""An excerpt from a digital design textbook discussing RTL modeling gotchas, particularly race conditions in Verilog, and demonstrating how to avoid them using proper coding style with blocking assignments.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p187.jpg,True,"The image contains Verilog code in two examples. Here are the code snippets from the image:

Example 6-5 PSL valid range check:
```verilog
assert always (fifo_depth < 7) @ (posedge clk) abort (!reset_n);
```

Example 6-6 OVL valid range check:
```verilog
assert_range # (0,3,0,6) above_full (clk, reset_n, fifo_depth);
```","
assert always (fifo_depth < 7) @ (posedge clk) abort (!reset_n);


assert_range # (0,3,0,6) above_full (clk, reset_n, fifo_depth);
","""Examples of PSL and OVL range checks in Verilog for ensuring a fifo_depth variable is within a valid range.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p116.jpg,True,"The image contains two Verilog code examples. Here they are:

First code example:
```
property checkiack;
  @(posedge clk) intr |=> iack;
endproperty
aP: assert property (checkiack);
```

Second code example:
```
property checkiack;
  @(posedge clk) $rose(intr) |=> $rose(iack);
endproperty
```

The snippets demonstrate using SystemVerilog properties to verify certain conditions in a simulation environment. The text around the code provides context and explains the nuances of using these properties.","ty checkiack;
  @(posedge clk) intr |=> iack;
endproperty
aP: assert property (checkiack);

ty checkiack;
  @(posedge clk) $rose(intr) |=> $rose(iack);
endproperty
","Caption: ""Understanding the implications of edge detection in Verilog assertions and their performance impact.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p496.jpg,True,"The image contains a snippet of what appears to be formal verification or logical code related to a backward simulation proof, rather than code in the Verilog hardware description language. Here's the text from the image:

```plaintext
bsr(i, a): bool = i'keys = a'keys AND
              FORALL p: (i'pc(p) = a'pc
                              (i'pc(p) = a'pcDoCont AND
                               i'pc (p) = pcDoContResp(false) AND
                               a'seen_out(p)))
```

This is a predicate or function declaration used in formal methods, which is likely written in a language used for theorem proving or model checking, such as the Prototype Verification System (PVS) or similar.","xt
bsr(i, a): bool = i'keys = a'keys AND
              FORALL p: (i'pc(p) = a'pc
                              (i'pc(p) = a'pcDoCont AND
                               i'pc (p) = pcDoContResp(false) AND
                               a'seen_out(p)))
","Caption: ""Academic paper discussing the implementation and verification of an abstract automaton using Verilog, focusing on forward and backward simulations and the alterations made for handling the contains operation in a concurrent set context.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p420.jpg,True,"Yes, there is Verilog code in this image. Here is the content:

```verilog
program automatic test(risc_spm_if risc_bus);
    import my_package::*;
    Environment env;
    initial begin
        // Create object referenced by env handle
    end
endprogram

program automatic test(risc_spm_if risc_bus);
    ...
endprogram

`include ""risc_spm_if.sv""
module top;
    ...
    test t1(risc_bus);
    ...
endmodule
```

These excerpts appear to be from an educational text or workbook, and they describe parts of code in the context of exercises, but they do not provide complete code listings.","
program automatic test(risc_spm_if risc_bus);
    import my_package::*;
    Environment env;
    initial begin
        // Create object referenced by env handle
    end
endprogram

program automatic test(risc_spm_if risc_bus);
    ...
endprogram

`include ""risc_spm_if.sv""
module top;
    ...
    test t1(risc_bus);
    ...
endmodule
",Verilog exercises focusing on test program instantiation and interface handling using cross module references.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p346.jpg,True,"The image contains Verilog code. Here it is:

`Sample 8.38` Transactor class with dynamic print object
```verilog
class Xactor;
  Print p;
  function new();
    p = new(""Xactor"", ""solo"");
  endfunction // new

  task run();
    p.error(""NYI"", ""This Xactor is not yet implemented"");
  endtask
endclass // Xactor
```

`Sample 8.39` Static print class
```verilog
class Print;
  static bit [31:0] error_count = 0, error_limit = -1;
  static function void error(input string ID,
                             input string message);
    $display(""@%0t %m [%s] %s"", $realtime, ID, message);
    error_count++;
    if (error_count >= error_limit) begin
      $display(""Maximum error limit reached"");
      $finish;
    end
  endfunction
endclass
```","
class Xactor;
  Print p;
  function new();
    p = new(""Xactor"", ""solo"");
  endfunction // new

  task run();
    p.error(""NYI"", ""This Xactor is not yet implemented"");
  endtask
endclass // Xactor


class Print;
  static bit [31:0] error_count = 0, error_limit = -1;
  static function void error(input string ID,
                             input string message);
    $display(""@%0t %m [%s] %s"", $realtime, ID, message);
    error_count++;
    if (error_count >= error_limit) begin
      $display(""Maximum error limit reached"");
      $finish;
    end
  endfunction
endclass
","""Verilog code examples for dynamic and static printing classes in a testbench environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p352.jpg,True,"The image contains code written in Verilog. Here are the code snippets visible in the image:

Sample 8.48 Program block for test classes

```verilog
program automatic test;
  TestBase tb;
  initial begin
    tb = TestRegistry::get_test();
    tb.run_test();
  end
endprogram
```

Sample 8.49 Test class that puts a bad transaction in the generator

```verilog
class TestBad extends TestBase;
  function new();
    env = new();
    TestRegistry::register(""TestBad"", this);
  endfunction // new

  virtual task run_test();
    $display(""%m"");
    env.gen_config();
    env.build();
    begin
      BadTr bad = new();
      env.gen.blueprint = bad;
    end
    env.run();
    env.wrap_up();
  endtask
endclass

TestBad TestBad_handle = new(); // Declaration & constructing
```

The code snippets show examples of a test program block and a test class in Verilog. The text describes it as a system for creating test registries and registering tests, as well as showing how to integrate a bad transaction into a test flow. Please note, in actual implementation, you would need to have definitions for `TestBase`, `TestRegistry`, `env`, `BadTr`, and other elements used in code samples for them to be functional.","
program automatic test;
  TestBase tb;
  initial begin
    tb = TestRegistry::get_test();
    tb.run_test();
  end
endprogram


class TestBad extends TestBase;
  function new();
    env = new();
    TestRegistry::register(""TestBad"", this);
  endfunction // new

  virtual task run_test();
    $display(""%m"");
    env.gen_config();
    env.build();
    begin
      BadTr bad = new();
      env.gen.blueprint = bad;
    end
    env.run();
    env.wrap_up();
  endtask
endclass

TestBad TestBad_handle = new(); // Declaration & constructing
","Caption: ""Example of Verilog testbench structure using OOP methodologies, including a program block for running tests and a test class for creating and executing a test with a bad transaction in the test environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p102.jpg,True,"The image contains Verilog code which is described as part of a property declaration and an assertion. Here is the code:

```verilog
logic req, gnt;
property pr1(csig, enb='1'b1, logic pa, logic pb);
    @(csig) enb |-> pa ##2 pb;
endproperty

reqGnt: assert property ( pr1(posedge clk, cStart, req, gnt) );
```

This snippet shows a Verilog property declaration named `pr1` with formal arguments, and an assert statement labeled `reqGnt` which checks the property `pr1` using actual arguments.","
logic req, gnt;
property pr1(csig, enb='1'b1, logic pa, logic pb);
    @(csig) enb |-> pa ##2 pb;
endproperty

reqGnt: assert property ( pr1(posedge clk, cStart, req, gnt) );
","""Example of Verilog code demonstrating how to pass event control to a formal argument in a concurrent assertion.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p434.jpg,True,"The image contains Verilog code pertaining to configuration class methods, UNI cell format, and NNI cell format. Here is the code from the image:

```verilog
function Config::new(input bit [31:0] numRx, numTx);
    this.numRx = numRx;
    this.use_Rx = new[numRx];
    this.numTx = numTx;
    cells_per_chan = new[numRx];
endfunction : new

function void Config::display(input string prefix);
    $write(""%sConfig: numRx=%0d, numTx=%0d, nCells=%0d ("", 
           prefix, numRx, numTx, nCells);
    foreach (cells_per_chan[i])
        $write(""%0d "", cells_per_chan[i]);
    $write(""), enabled RX: "", prefix);
    foreach (in_use_Rx[i]) if (in_use_Rx[i]) $write(""%0d "", i);
    $display;
endfunction : display
```

In the configuration class methods, there are two functions, `new` and `display`. The `new` function initializes objects with the number of receivers `numRx` and transmitters `numTx`, while the `display` function displays this configuration with a prefix.

There is also additional code defining UNI and NNI cell formats:

```verilog
typedef struct packed {
    bit         [3:0]   GFC;
    bit         [7:0]   VPI;
    bit         [15:0]  VCI;
    bit                 CLP;
    bit         [2:0]   PT;
    bit         [7:0]   HEC;
    bit [0:47]  [7:0]   Payload;
} uniType;

typedef struct packed {
    bit         [11:0]  VPI;
    bit         [15:0]  VCI;
    bit                 CLP;
    bit         [2:0]   PT;
    bit         [7:0]   HEC;
    bit [0:47]  [7:0]   Payload;
} nniType;
```

These structs define the format for UNI (User Network Interface) and NNI (Network Node Interface) cells that are used in ATM (Asynchronous Transfer Mode) networks, describing the fields that each cell type contains. The fields include Generic Flow Control (GFC), Virtual Path Identifier (VPI), Virtual Channel Identifier (VCI), Cell Loss Priority (CLP), Payload Type (PT), Header Error Control (HEC), and Payload. The `packed` attribute ensures there are no alignment gaps between the fields within the structs.","
function Config::new(input bit [31:0] numRx, numTx);
    this.numRx = numRx;
    this.use_Rx = new[numRx];
    this.numTx = numTx;
    cells_per_chan = new[numRx];
endfunction : new

function void Config::display(input string prefix);
    $write(""%sConfig: numRx=%0d, numTx=%0d, nCells=%0d ("", 
           prefix, numRx, numTx, nCells);
    foreach (cells_per_chan[i])
        $write(""%0d "", cells_per_chan[i]);
    $write(""), enabled RX: "", prefix);
    foreach (in_use_Rx[i]) if (in_use_Rx[i]) $write(""%0d "", i);
    $display;
endfunction : display


typedef struct packed {
    bit         [3:0]   GFC;
    bit         [7:0]   VPI;
    bit         [15:0]  VCI;
    bit                 CLP;
    bit         [2:0]   PT;
    bit         [7:0]   HEC;
    bit [0:47]  [7:0]   Payload;
} uniType;

typedef struct packed {
    bit         [11:0]  VPI;
    bit         [15:0]  VCI;
    bit                 CLP;
    bit         [2:0]   PT;
    bit         [7:0]   HEC;
    bit [0:47]  [7:0]   Payload;
} nniType;
",Verilog code samples showing functions and structs for configuration and cell format in a testbench scenario.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p438.jpg,True,"The image contains Verilog code. Here is the transcription:

```verilog
typedef enum {
    info = 2'b10, control = 2'b01, void = 2'b00, forbid = 2'b11
} kind_t;
typedef logic [5:0] tag_t;
typedef logic [23:0] data_t;

typedef struct {
    kind_t kind; tag_t tag; data_t data;
} packet_t;

typedef struct { logic ack_received; tag_t tag; } ack_t;

checker spec (
    packet_t tx_packet, // Packet to be transmitted
    rx_packet,          // Last received packet
    logic sent,         // Packet sent
    ack_t ack,          // Acknowledge
    logic timeout,      // Timeout active
    logic err,          // Error signal
    event clk,          // System clock
    logic rst           // Reset
);
    default clocking @clk; endclocking
    default disable iff rst;

...same as before...

// coverage of different packet types
let packet_sent_type(packet_t tx_packet, kind_t kind) =
    sent && tx_packet.kind == kind;
cov_kinds_tx_info: cover property (
    packet_sent_type(tx_packet, info));
cov_kinds_tx_void: cover property (
    packet_sent_type(tx_packet, void));
cov_kinds_tx_control: cover property (
    packet_sent_type(tx_packet, control));
cov_kinds_tx_type: cover property (
    packet_sent_type(tx_packet, forbid));

// coverage of packet types transmission and acknowledgment.
property tx_rx_ack(kind_t kind);
    tag_t tag;
    (sent && tx_packet.kind == kind, tag = tx_packet.tag)
        ##1 s_eventually(ack.ack_received && ack.tag == tag);
endproperty

cov_sent_ack_info: cover property(tx_rx_ack(info));
cov_sent_ack_void: cover property(tx_rx_ack(void));
cov_sent_ack_control: cover property(tx_rx_ack(control));

endchecker : spec
```

This code appears to define a system specification with types for packets, cover properties for transmission and reception of different packet types, and a checker to assess the correct transmission and acknowledgment of these packets.","
typedef enum {
    info = 2'b10, control = 2'b01, void = 2'b00, forbid = 2'b11
} kind_t;
typedef logic [5:0] tag_t;
typedef logic [23:0] data_t;

typedef struct {
    kind_t kind; tag_t tag; data_t data;
} packet_t;

typedef struct { logic ack_received; tag_t tag; } ack_t;

checker spec (
    packet_t tx_packet, // Packet to be transmitted
    rx_packet,          // Last received packet
    logic sent,         // Packet sent
    ack_t ack,          // Acknowledge
    logic timeout,      // Timeout active
    logic err,          // Error signal
    event clk,          // System clock
    logic rst           // Reset
);
    default clocking @clk; endclocking
    default disable iff rst;

...same as before...

// coverage of different packet types
let packet_sent_type(packet_t tx_packet, kind_t kind) =
    sent && tx_packet.kind == kind;
cov_kinds_tx_info: cover property (
    packet_sent_type(tx_packet, info));
cov_kinds_tx_void: cover property (
    packet_sent_type(tx_packet, void));
cov_kinds_tx_control: cover property (
    packet_sent_type(tx_packet, control));
cov_kinds_tx_type: cover property (
    packet_sent_type(tx_packet, forbid));

// coverage of packet types transmission and acknowledgment.
property tx_rx_ack(kind_t kind);
    tag_t tag;
    (sent && tx_packet.kind == kind, tag = tx_packet.tag)
        ##1 s_eventually(ack.ack_received && ack.tag == tag);
endproperty

cov_sent_ack_info: cover property(tx_rx_ack(info));
cov_sent_ack_void: cover property(tx_rx_ack(void));
cov_sent_ack_control: cover property(tx_rx_ack(control));

endchecker : spec
",SystemVerilog code snippet demonstrating the use of coverage in hardware verification.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p97.jpg,True,"The image contains a segment of Verilog code, which is as follows:

```verilog
module address_decode (input logic [1:0] address, output logic rdata);

always_comb begin
  rdata = 1'b0;                  // default value for rdata
  unique case (address)          // decode address -- GOTCHA!
    2'b00 : rdata = 1'b1;
  endcase
end
endmodule
```

This code snippet demonstrates a potential issue when using the `unique case` construct in SystemVerilog.","
module address_decode (input logic [1:0] address, output logic rdata);

always_comb begin
  rdata = 1'b0;                  // default value for rdata
  unique case (address)          // decode address -- GOTCHA!
    2'b00 : rdata = 1'b1;
  endcase
end
endmodule
","""Highlighting the pitfalls of using unique case statements in Verilog for RTL modeling.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p193.jpg,True,"The image shows an excerpt from a book discussing assertion-based design in the context of Verilog/SystemVerilog. Here are the pieces of code present in the image:

```verilog
`define ADD 1
`define SUB 2
`define RD 3
`define WR 7

(opcode===`ADD) || (opcode===`RD) || (opcode===`SUB) || (opcode == `WR)
```

This code snippet represents a Verilog expression used to validate opcodes against predefined values.

```verilog
assert_always valid_opcode (clk, reset_n,
    (opcode===`RD) || (opcode===`SUB) || (opcode==`WR));
```

This code snippet employs the OVL (`assert_always`) to validate the opcode encoding.

Additionally, there is a SystemVerilog snippet using the `inside` operator:

```verilog
valid_op: assert property (@(posedge clk) disable iff (reset_n)
    opcode inside {`ADD, `RD, `SUB, `WR} ) else
$error(""CTL sent illegal opcode (%0h) to ALU."", opcode);
```

This SystemVerilog code demonstrates how to use concurrent assertion to check if an opcode is within the set of valid opcodes. If not, it triggers an error.

Please note that the code in the image may contain context-specific macros or identifiers that should align with other parts of the Verilog/SystemVerilog project.","
`define ADD 1
`define SUB 2
`define RD 3
`define WR 7

(opcode===`ADD) || (opcode===`RD) || (opcode===`SUB) || (opcode == `WR)


assert_always valid_opcode (clk, reset_n,
    (opcode===`RD) || (opcode===`SUB) || (opcode==`WR));


valid_op: assert property (@(posedge clk) disable iff (reset_n)
    opcode inside {`ADD, `RD, `SUB, `WR} ) else
$error(""CTL sent illegal opcode (%0h) to ALU."", opcode);
","""Verilog and SystemVerilog code examples demonstrating how to check for valid opcodes using assertions and the inside operator for design validation.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p417.jpg,True,"There is code on this page. Here it is:

```verilog
void tf_asynchon()

void tf_asynchoff()
```

Additionally, there is an example usage of a Verilog `initial` block, though it is not a complete code snippet:

```verilog
initial
  $my_monitor1(clock, d, q);
```

However, these code snippets are part of a documentation text and are not complete code in themselves. They are meant to illustrate the text explanation in the context of Verilog and PLI (Programming Language Interface) applications.","
void tf_asynchon()

void tf_asynchoff()


initial
  $my_monitor1(clock, d, q);
",Excerpt from a book discussing Verilog PLI callbacks for system task/function argument value changes.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p400.jpg,True,"The image contains a snippet of Verilog code. I'll transcribe it for you:

```verilog
sequence s_cnt_occurrences(bit a, untyped num_a);
  ##1 (b1, num_a = a)
  ##1 (a[-1]; num_a++)
  ##1 !a[0:$]
endsequence
```","
sequence s_cnt_occurrences(bit a, untyped num_a);
  ##1 (b1, num_a = a)
  ##1 (a[-1]; num_a++)
  ##1 !a[0:$]
endsequence
","""Verilog sequence example with untyped formal arguments for local variable assignment""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p371.jpg,True,"The image contains text and code related to Verilog and PLI (Programming Language Interface). Here is the code available in the image:

```c
#include ""veriuser.h""                            /* IEEE 1364 PLI TF routine library */
/***************************************************************
* checktf application
***************************************************************/
int PLIbook_propagateTest_checktf()
{
    if (tf_nump() != 1)
        tf_error(""Usage error: $propagatep_test(<signal>);"");
    return(0);
}

/***************************************************************
* misctf application
*
* The misctf application is used to call tf_exprinfo() at the
* beginning of simulation, so that the memory allocated by
* tf_exprinfo() is only allocated one time for each instance of
* $read_4state_value.
***************************************************************/
int PLIbook_propagateTest_misctf(int user_data, int reason)
{
    p_tfexprinfo info_p;           /* pointer to structure for tf_exprinfo() */
    
    if (reason != REASON_ENDOFCOMPILE)
        return(0);                 /* exit now if this is not the start of simulation */
    
    /* allocate memory for an s_tfexprinfo structure */
    info_p = (p_tfexprinfo)malloc(sizeof(s_tfexprinfo));
    tf_exprinfo(1, info_p);        /* read expression info for arg 1 */
    if ( (info_p->expr_type != tf_readwrite) &&
         (info_p->expr_type != tf_readwritereal) &&
         (info_p->expr_type != tf_rwbitselect) &&
         (info_p->expr_type != tf_rwpartselect) &&
         (info_p->expr_type != tf_rwmemselect) ) {
             io_printf(""ERROR: Signal type not supported by $propagatap_test\n"");
             tf_dofinish();
    }
    else
        tf_setworkarea((char *)info_p); /* save info pointer in workarea */
    
    return(0);
}
```

This code seems to be part of a Verilog PLI application, where functions are defined to check and handle signals during simulation in a hardware description language. The `checktf` function checks the number of arguments passed to a system task, and the `misctf` function processes signal types at the end of the compile phase in the simulation and allocates memory for an expression info structure.","ude ""veriuser.h""                            /* IEEE 1364 PLI TF routine library */
/***************************************************************
* checktf application
***************************************************************/
int PLIbook_propagateTest_checktf()
{
    if (tf_nump() != 1)
        tf_error(""Usage error: $propagatep_test(<signal>);"");
    return(0);
}

/***************************************************************
* misctf application
*
* The misctf application is used to call tf_exprinfo() at the
* beginning of simulation, so that the memory allocated by
* tf_exprinfo() is only allocated one time for each instance of
* $read_4state_value.
***************************************************************/
int PLIbook_propagateTest_misctf(int user_data, int reason)
{
    p_tfexprinfo info_p;           /* pointer to structure for tf_exprinfo() */
    
    if (reason != REASON_ENDOFCOMPILE)
        return(0);                 /* exit now if this is not the start of simulation */
    
    /* allocate memory for an s_tfexprinfo structure */
    info_p = (p_tfexprinfo)malloc(sizeof(s_tfexprinfo));
    tf_exprinfo(1, info_p);        /* read expression info for arg 1 */
    if ( (info_p->expr_type != tf_readwrite) &&
         (info_p->expr_type != tf_readwritereal) &&
         (info_p->expr_type != tf_rwbitselect) &&
         (info_p->expr_type != tf_rwpartselect) &&
         (info_p->expr_type != tf_rwmemselect) ) {
             io_printf(""ERROR: Signal type not supported by $propagatap_test\n"");
             tf_dofinish();
    }
    else
        tf_setworkarea((char *)info_p); /* save info pointer in workarea */
    
    return(0);
}
","""Example of Verilog PLI code for reading and writing simulation values using TF routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p299.jpg,True,"The image contains Verilog code which is given below:

```verilog
parameter ParHi = 31;
...
function [ParHi:0] Shift1(input [ParHi:0] OldSR, input NewBit);
    reg[ParHi:0] temp;
    begin
        temp = OldSR;
        temp = temp<<1; // MSB goes lost.
        temp[0] = NewBit;
        Shift1 = temp;
    end
endfunction
```

This snippet of code appears to be a function for deserializing a bitstream by shifting in a new bit (`NewBit`) into an existing shift register (`OldSR`). The parameter `ParHi` establishes the bit width of the shift register.","
parameter ParHi = 31;
...
function [ParHi:0] Shift1(input [ParHi:0] OldSR, input NewBit);
    reg[ParHi:0] temp;
    begin
        temp = OldSR;
        temp = temp<<1; // MSB goes lost.
        temp[0] = NewBit;
        Shift1 = temp;
    end
endfunction
","Caption: ""Example of a Verilog function for deserialization by shifting in a new bit to a serial data register.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p365.jpg,True,"The image contains code related to a Verilog data structure declaration. Here is the code extracted from the image:

```verilog
typedef struct t_vecval
{
    int avalbits;
    int bvalbits;
} s_vecval, *p_vecval;
``` 

This code defines a structure `t_vecval` (which is then typedef'd to `s_vecval` and `p_vecval`) with two integer members `avalbits` and `bvalbits`.","
typedef struct t_vecval
{
    int avalbits;
    int bvalbits;
} s_vecval, *p_vecval;
",Verilog Bit Mapping to C Integers for TF Routines in Simulation.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p403.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
always @(posedge clock)
$read_test_vector(""vectors.pat"", input_bus);
``` 

This code registers a process that triggers on the positive edge of the clock signal. When the clock has a rising edge, the function `$read_test_vector` is called with the arguments `""vectors.pat""` and `input_bus`.","
always @(posedge clock)
$read_test_vector(""vectors.pat"", input_bus);
","""Chapter on Verilog Simulations detailing the MiscTF Routines and PLI applications with sample Verilog code snippet.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p414.jpg,True,"The image contains a snippet of Verilog code, specifically a SystemVerilog Assertion (SVA). Here's the code from the image:

```verilog
property p_retry_check;
  dataType l_dataModel [MAX_BEATS];
  (start, l_dataModel = dataModel)
  |=>
  sync_reject_on(start) p_retry_check_recur(dataModel, 0);
endproperty

property p_retry_check_recur(
  local input dataType l_dataModel [MAX_BEATS],
  local input int unsigned i
);
  (dataValid || retry) [-1]
  |=>
  (dataValid [-> data == l_dataModel[i]) and
  if (retry)
    nexttime p_retry_check_recur(l_dataModel, 0)
  else if (complete)
    nexttime
      !dataValid and
      if (retry)
        nexttime p_retry_check_recur(l_dataModel, 0)
  else
    (i < MAX_BEATS-1) and
    nexttime p_retry_check_recur(l_dataModel, i+1)
);
endproperty

a_retry_check: assert property (p_retry_check);
```

This code defines two properties `p_retry_check` and `p_retry_check_recur` for checking a retry protocol, presumably used in formal verification of a hardware design. The last line is an assertion that essentially activates the property check within a simulation or formal verification environment.","
property p_retry_check;
  dataType l_dataModel [MAX_BEATS];
  (start, l_dataModel = dataModel)
  |=>
  sync_reject_on(start) p_retry_check_recur(dataModel, 0);
endproperty

property p_retry_check_recur(
  local input dataType l_dataModel [MAX_BEATS],
  local input int unsigned i
);
  (dataValid || retry) [-1]
  |=>
  (dataValid [-> data == l_dataModel[i]) and
  if (retry)
    nexttime p_retry_check_recur(l_dataModel, 0)
  else if (complete)
    nexttime
      !dataValid and
      if (retry)
        nexttime p_retry_check_recur(l_dataModel, 0)
  else
    (i < MAX_BEATS-1) and
    nexttime p_retry_check_recur(l_dataModel, i+1)
);
endproperty

a_retry_check: assert property (p_retry_check);
","Caption: ""Fig. 17.14 - Example of a Verilog property for recursive encoding of retry protocol checks in a SystemVerilog Formal Verification context.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p418.jpg,True,"The image contains Verilog code, which is given below:

```verilog
interface simple_if(input logic clk);
  logic addr;
  logic data;
  logic start = 0;
  bus_cmd_e cmd;

  modport TARGET(input addr, cmd, data,
                 import task targetRcv (output bus_cmd_e c, logic [7:0] a, d));

  modport INITIATOR(output addr, cmd, data,
                    import task initiatorSend(input bus_cmd_e c, logic [7:0] a, d));

  // Serial send
  task initiatorSend(input bus_cmd_e c, logic [7:0] a, d);
    @(posedge clk);
    start <= 1;
    cmd <= c;
    foreach (a[i]) begin
      addr <= a[i];
      data <= d[i];
      @(posedge clk);
    end
    start <= 0;
    cmd <= IDLE;
  endtask

  // Serial receive
  task targetRcv(output bus_cmd_e c, logic [7:0] a, d);
    @(posedge start);
    c = cmd;
    foreach (a[i]) begin
      @(posedge clk);
      a[i] = addr;
      d[i] = data;
    end 
  endtask

endinterface: simple_if
```

This code snippet shows how an interface `simple_if` is defined for a serial protocol, including tasks for both sending `initiatorSend` and receiving `targetRcv`. Each task interacts with the signals in the interface on positive clock edges or when certain conditions are met.","
interface simple_if(input logic clk);
  logic addr;
  logic data;
  logic start = 0;
  bus_cmd_e cmd;

  modport TARGET(input addr, cmd, data,
                 import task targetRcv (output bus_cmd_e c, logic [7:0] a, d));

  modport INITIATOR(output addr, cmd, data,
                    import task initiatorSend(input bus_cmd_e c, logic [7:0] a, d));

  // Serial send
  task initiatorSend(input bus_cmd_e c, logic [7:0] a, d);
    @(posedge clk);
    start <= 1;
    cmd <= c;
    foreach (a[i]) begin
      addr <= a[i];
      data <= d[i];
      @(posedge clk);
    end
    start <= 0;
    cmd <= IDLE;
  endtask

  // Serial receive
  task targetRcv(output bus_cmd_e c, logic [7:0] a, d);
    @(posedge start);
    c = cmd;
    foreach (a[i]) begin
      @(posedge clk);
      a[i] = addr;
      d[i] = data;
    end 
  endtask

endinterface: simple_if
","""Sample Verilog interface code for serial communication protocol with tasks for send and receive operations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p93.jpg,True,"```verilog
case (state)
  3'b001: nstate = 3'b010;
  3'b010: nstate = 3'b100;
  3'b100: nstate = 3'b001;
  default: nstate = 3'b001; // on error, go back to first state
endcase
```

The snippet above is a `case` statement in Verilog with a `default` branch, providing a way to handle unspecified values of `state`.","
case (state)
  3'b001: nstate = 3'b010;
  3'b010: nstate = 3'b100;
  3'b100: nstate = 3'b001;
  default: nstate = 3'b001; // on error, go back to first state
endcase
","""Addressing RTL Modeling Gotchas in Verilog with an Incomplete Case Statement Example""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p197.jpg,True,"```verilog
// declarative assertion
assert property ( @(posedge clk) disable iff (reset_n)
    not ({read, write, burst, size[1:0], wt} inside
        {6'b1_0_1_01_?, 6'b1_0_1_10_?, // wrong size
         6'b1_0_1_11_?, 
         6'b0_1_1_01_0, 6'b0_1_1_10_0, // wrong size
         6'b0_1_1_11_0, 
         6'b1_1_01_01_1, 6'b0_1_1_01_1, // burst writethru
         6'b0_1_1_10_1, 6'b0_1_1_11_1,
         6'b1_0_1_01_0, 6'b1_0_1_10_0})) // wrong size.
else $error(""Illegal memory request {read,write,burst,size,wt}=%0h "",
            {read, write, burst, size, wt});
```

```verilog
// declarative assertion
assert property ( @(posedge clk) disable iff (reset_n)
    not (invalidate & flush) )
else $error(""Cache received illegal invalidate and flush request."");
``` 

The code on this page is a set of declarative assertions in Verilog which are used to check for illegal signal combinations in a digital system design.","
// declarative assertion
assert property ( @(posedge clk) disable iff (reset_n)
    not ({read, write, burst, size[1:0], wt} inside
        {6'b1_0_1_01_?, 6'b1_0_1_10_?, // wrong size
         6'b1_0_1_11_?, 
         6'b0_1_1_01_0, 6'b0_1_1_10_0, // wrong size
         6'b0_1_1_11_0, 
         6'b1_1_01_01_1, 6'b0_1_1_01_1, // burst writethru
         6'b0_1_1_10_1, 6'b0_1_1_11_1,
         6'b1_0_1_01_0, 6'b1_0_1_10_0})) // wrong size.
else $error(""Illegal memory request {read,write,burst,size,wt}=%0h "",
            {read, write, burst, size, wt});


// declarative assertion
assert property ( @(posedge clk) disable iff (reset_n)
    not (invalidate & flush) )
else $error(""Cache received illegal invalidate and flush request."");
",Example Verilog code demonstrating assertions to check for illegal signal combinations in a SystemVerilog environment.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p430.jpg,True,"```verilog
// For each output TX channel, start monitor
foreach(mon[i]) begin
    int j=i; // Automatic var holds index in spawned threads
    fork
        mon[j].run();
    join_none
end

// Wait for all generators to finish, or time-out
fork: timeout_block
    wait (num_gen_running == 0);
    begin
        repeat (1_000_000) @(Rx[0].cbr);
        $display(""@%0t: %m ERROR: Generator timeout "", $time);
        cfg.nErrors++;
    end
    join_any
    disable timeout_block;

// Wait for the data to flow through switch, into monitors, // and scoreboards
    repeat (1_000) @(Rx[0].cbr);
endtask : run

//---------------------------------------------------
// Post-run cleanup / reporting
function void Environment::wrap_up();
    $display(""@%0t: End of sim, %0d errors, %0d warnings"",
             $time, cfg.nErrors, cfg.nWarnings);
    scb.wrap_up();
endfunction : wrap_up
```","
// For each output TX channel, start monitor
foreach(mon[i]) begin
    int j=i; // Automatic var holds index in spawned threads
    fork
        mon[j].run();
    join_none
end

// Wait for all generators to finish, or time-out
fork: timeout_block
    wait (num_gen_running == 0);
    begin
        repeat (1_000_000) @(Rx[0].cbr);
        $display(""@%0t: %m ERROR: Generator timeout "", $time);
        cfg.nErrors++;
    end
    join_any
    disable timeout_block;

// Wait for the data to flow through switch, into monitors, // and scoreboards
    repeat (1_000) @(Rx[0].cbr);
endtask : run

//---------------------------------------------------
// Post-run cleanup / reporting
function void Environment::wrap_up();
    $display(""@%0t: End of sim, %0d errors, %0d warnings"",
             $time, cfg.nErrors, cfg.nWarnings);
    scb.wrap_up();
endfunction : wrap_up
","Caption: ""Example Verilog testbench code demonstrating concurrency and synchronization for output channel monitoring, data flow, and post-run cleanup.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p106.jpg,True,"```verilog
endproperty
Nest_disable: assert property (
    disable iff (reset1) PCI_disable; //ILLEGAL
) else $error(""FAIL"");

endmodule
```
```verilog
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) start |-> sr1;
endproperty

reqGnt: assert property (pr1) else ;
```
```verilog
$fatal     //< run time fatal (quit simulation)

$error     //< run time Error. Default according to SV 3.1a LRM. Vendor
           // specific command line options may change this behavior.

$warning   //< run time warning.

$info      //< means this assertion failure carries no specific severity.
```
```verilog
reqGnt: assert property (pr1) else $fatal($stime,,""%%m Assert Fail"");
```","
endproperty
Nest_disable: assert property (
    disable iff (reset1) PCI_disable; //ILLEGAL
) else $error(""FAIL"");

endmodule


sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) start |-> sr1;
endproperty

reqGnt: assert property (pr1) else ;


$fatal     //< run time fatal (quit simulation)

$error     //< run time Error. Default according to SV 3.1a LRM. Vendor
           // specific command line options may change this behavior.

$warning   //< run time warning.

$info      //< means this assertion failure carries no specific severity.


reqGnt: assert property (pr1) else $fatal($stime,,""%%m Assert Fail"");
","Caption: ""The image shows an excerpt from a textbook or documentation concerning concurrent assertions in Verilog, specifically discussing the illegality of nesting disable iff statements and the various severity levels of error reporting in assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p356.jpg,True,"The image contains Verilog code which is associated with a SystemVerilog test registry framework. Here is the code:

```verilog
class svm_factory;
  // Assoc array from string to svm_object_wrapper handle
  static svm_object_wrapper m_type_names[string];
  
  static svm_factory m_inst; // Handle to this singleton

  static function svm_factory get();
    if (m_inst == null) m_inst = new();
    return m_inst;
  endfunction

  static function void register(svm_object_wrapper c);
    m_type_names[c.get_type_name()] = c;
  endfunction

  static function svm_component get_test();
    string name;
    svm_object_wrapper test_wrapper;
    svm_component test_comp;

    if (!($value$plusargs(""SVM_TESTNAME=%s"", name))) begin
      $display(""FATAL +SVM_TESTNAME not found"");
      $finish;
    end
    $display(""%m found +SVM_TESTNAME=%s"", name);
    test_wrapper = svm_factory::m_type_names[name];
    $cast(test_comp, test_wrapper.create_object(name));
    return test_comp;
  endfunction
endclass : svm_factory
```

This piece of code is part of a larger system designed for testbench organization using the Universal Verification Methodology (UVM) which is built on top of SystemVerilog for facilitating the design and verification of complex digital systems.","
class svm_factory;
  // Assoc array from string to svm_object_wrapper handle
  static svm_object_wrapper m_type_names[string];
  
  static svm_factory m_inst; // Handle to this singleton

  static function svm_factory get();
    if (m_inst == null) m_inst = new();
    return m_inst;
  endfunction

  static function void register(svm_object_wrapper c);
    m_type_names[c.get_type_name()] = c;
  endfunction

  static function svm_component get_test();
    string name;
    svm_object_wrapper test_wrapper;
    svm_component test_comp;

    if (!($value$plusargs(""SVM_TESTNAME=%s"", name))) begin
      $display(""FATAL +SVM_TESTNAME not found"");
      $finish;
    end
    $display(""%m found +SVM_TESTNAME=%s"", name);
    test_wrapper = svm_factory::m_type_names[name];
    $cast(test_comp, test_wrapper.create_object(name));
    return test_comp;
  endfunction
endclass : svm_factory
","""Verilog code for a SystemVerilog factory class implementing a test registry with associated methods.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p359.jpg,True,"The image contains excerpts from a book on Verilog that discuss how to handle string operations in Verilog, specifically the reading of Verilog strings and the TF (Task Functions) routines. The code present in the image is as follows:

Example of calling a system task:
```
$read_test_vector(""vector_file.pat"", input_vector);
```

Function prototype for getting a string from a system task/function argument:
```
char *tf_getcstringp(n)
int n     // index number of a system task/function argument.
```

Example code checking if the first argument is a string, in a checktf routine:
```c
if (tf_typep(1) != TF_STRING)
    tf_error(""$read_vector arg 1 must be literal string\n"");
```

Example code capturing a file name in a calltf routine:
```c
char *file_name;
file_name = tf_getcstringp(1);
```

A note explaining tf_getcstringp():
```
tf_getcstringp() returns a string pointer to a string, which is stored in a temporary string buffer. Because the buffer is temporary, the pointer will not remain valid. The PLI application should either use the string immediately, or copy the string into application-allocated storage. Refer to section 10.3 for details on PLI strings.
```

The code provided is intended for use with the Verilog Hardware Description Language (HDL), specifically within the context of PLI (Programming Language Interface) routines that enable custom functionality within Verilog simulators.","test_vector(""vector_file.pat"", input_vector);

tf_getcstringp(n)
int n     // index number of a system task/function argument.

f_typep(1) != TF_STRING)
    tf_error(""$read_vector arg 1 must be literal string\n"");

*file_name;
file_name = tf_getcstringp(1);

cstringp() returns a string pointer to a string, which is stored in a temporary string buffer. Because the buffer is temporary, the pointer will not remain valid. The PLI application should either use the string immediately, or copy the string into application-allocated storage. Refer to section 10.3 for details on PLI strings.
","""Excerpt from a Verilog textbook discussing how to read Verilog strings using TF routines and handling string arguments in system tasks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p342.jpg,True,"The image contains code. Here is the code written in the image:

```verilog
parameter int SIZE = 100;
class Stack # (type T=int);
  local T stack[SIZE];             // Holds data values
  local int top;

  function void push(input T i);   // Push new value on top
    stack[top++] = i;
  endfunction : push

  function T pop();                // Remove value from top
    return stack[--top];
  endfunction

endclass : Stack
```

The text in the image also references a different code segment titled Sample 8.33, but only its preamble and a few lines are visible:

```verilog
initial begin
  Stack # (real) rStack;           // Specialize the stack class
  rStack = new();                  // Construct a stack of reals
  for (int i = 0; i < SIZE; i++)
    rStack.push(i*2.0);            // Push values onto stack

  for (int i = 0; i < SIZE; i++)
    $display(""%f"", rStack.pop());  // Pop values off stack
end
```

This code provides an example of a parameterized class for a stack in the SystemVerilog language.","
parameter int SIZE = 100;
class Stack # (type T=int);
  local T stack[SIZE];             // Holds data values
  local int top;

  function void push(input T i);   // Push new value on top
    stack[top++] = i;
  endfunction : push

  function T pop();                // Remove value from top
    return stack[--top];
  endfunction

endclass : Stack


initial begin
  Stack # (real) rStack;           // Specialize the stack class
  rStack = new();                  // Construct a stack of reals
  for (int i = 0; i < SIZE; i++)
    rStack.push(i*2.0);            // Push values onto stack

  for (int i = 0; i < SIZE; i++)
    $display(""%f"", rStack.pop());  // Pop values off stack
end
","""Example of a Parameterized Stack Class in SystemVerilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p492.jpg,True,"The image contains pseudocode for a LazyList algorithm written in the style of a programming language, not specifically Verilog. Verilog is a hardware description language used to model electronic systems. Here is the pseudocode from the image:

```
contains(k) :
  curr := Head;
  while curr.key < k do
    curr := curr.next;
  if curr.key = k and
  ~curr.marked then
    return true
  else
    return false

locate(k) :
  res := true do
    pred := Head;
    curr := pred.next;
    while curr.key < k do
      pred := curr;
      curr := curr.next;
    pred.lock();
    curr.lock();
    if ~pred.marked and
    ~curr.marked and
    pred.next = curr then
      return pred, curr
    else
      pred.unlock();
      curr.unlock()

add(k) :
  pred, curr := locate(k);
  if curr.key != k then
    entry := new Entry();
    entry.key := k;
    entry.next := curr;
    pred.next := entry;
    res := true
  else
    res := false;
  pred.unlock();
  curr.unlock();
  return res

remove(k) :
  pred, curr := locate(k);
  if curr.key = k then
    curr.marked := true;
    entry := curr.next;
    pred.next := entry;
    res := true
  else
    res := false
  pred.unlock();
  curr.unlock();
  return res
```

Please note the tilde (~) operator is often used to denote logical NOT in various programming contexts. This pseudocode appears to implement concurrent operations on a linked list data structure, providing methods to check if a key is contained (`contains(k)`), add a new key (`add(k)`), and remove a key (`remove(k)`) with some form of synchronization using locks (`lock()` and `unlock()` methods), and checking if a node is marked (which may indicate logical deletion).","ns(k) :
  curr := Head;
  while curr.key < k do
    curr := curr.next;
  if curr.key = k and
  ~curr.marked then
    return true
  else
    return false

locate(k) :
  res := true do
    pred := Head;
    curr := pred.next;
    while curr.key < k do
      pred := curr;
      curr := curr.next;
    pred.lock();
    curr.lock();
    if ~pred.marked and
    ~curr.marked and
    pred.next = curr then
      return pred, curr
    else
      pred.unlock();
      curr.unlock()

add(k) :
  pred, curr := locate(k);
  if curr.key != k then
    entry := new Entry();
    entry.key := k;
    entry.next := curr;
    pred.next := entry;
    res := true
  else
    res := false;
  pred.unlock();
  curr.unlock();
  return res

remove(k) :
  pred, curr := locate(k);
  if curr.key = k then
    curr.marked := true;
    entry := curr.next;
    pred.next := entry;
    res := true
  else
    res := false
  pred.unlock();
  curr.unlock();
  return res
","Pseudocode for the LazyList concurrent algorithm with methods for checking containment, adding, and removing elements.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p424.jpg,True,"The image includes a sample of Verilog code. Here is the code:

```verilog
`timescale 1ns/1ns
`define TxPorts 4  // set number of transmit ports
`define RxPorts 4  // set number of receive ports

module top;
  parameter int NumRx = `RxPorts;
  parameter int NumTx = `TxPorts;

  logic rst, clk;
  // System Clock and Reset
  initial begin
    rst = 0; clk = 0;
    #5ns rst = 1;
    #5ns clk = 1;
    #5ns rst = 0; clk = 0;
    forever
      #5ns clk = ~clk;
  end

  Utopia Rx [0:`NumRx-1] (); // NumRx x Level 1 Utopia Rx Interface
  Utopia Tx [0:`NumTx-1] (); // NumTx x Level 1 Utopia Tx Interface
  u_ifc mif();               // Utopia management interface
  squaT #(NumRx, NumTx) squaT(Rx, Tx, mif, rst, clk); // DUT
  test #(NumRx, NumTx) tl(Rx, Tx, mif, rst);          // Test
endmodule : top
```

This snippet defines a top-level module in Verilog with parameters for receive (`RxPorts`) and transmit (`TxPorts`) ports. It includes clock and reset logic, and instances of Utopia interfaces, a device under test (DUT) and a test module are declared.","
`timescale 1ns/1ns
`define TxPorts 4  // set number of transmit ports
`define RxPorts 4  // set number of receive ports

module top;
  parameter int NumRx = `RxPorts;
  parameter int NumTx = `TxPorts;

  logic rst, clk;
  // System Clock and Reset
  initial begin
    rst = 0; clk = 0;
    #5ns rst = 1;
    #5ns clk = 1;
    #5ns rst = 0; clk = 0;
    forever
      #5ns clk = ~clk;
  end

  Utopia Rx [0:`NumRx-1] (); // NumRx x Level 1 Utopia Rx Interface
  Utopia Tx [0:`NumTx-1] (); // NumTx x Level 1 Utopia Tx Interface
  u_ifc mif();               // Utopia management interface
  squaT #(NumRx, NumTx) squaT(Rx, Tx, mif, rst, clk); // DUT
  test #(NumRx, NumTx) tl(Rx, Tx, mif, rst);          // Test
endmodule : top
","Verilog code sample defining a top-level module with system clock, reset logic, and instantiation of Utopia interfaces and test environment.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p87.jpg,True,"The image contains Verilog code snippets. Here is the code listed in the image:

```verilog
always_comb // inferred combinational logic sensitivity list
y = m + n; // immediate update to y with no clock-to-Q delay

always_ff @(posedge clk) // sequential sensitivity list with clock
m <= m + n; // scheduled change to m after clock-to-Q delta
```","
always_comb // inferred combinational logic sensitivity list
y = m + n; // immediate update to y with no clock-to-Q delay

always_ff @(posedge clk) // sequential sensitivity list with clock
m <= m + n; // scheduled change to m after clock-to-Q delta
","""Examples of combinational and sequential logic modeling in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p428.jpg,True,"The image contains two examples of Verilog code. Below is the text for both examples:

Example 18.3:
```verilog
prop_cov2: cover property ( disable iff (reset)
    @(posedge clk) a |-> s_eventually[1:100] b
)
begin
    my_count++;
    $display(""success of prop_cov2 at time %t"", $time);
end
```

Example 18.4:
```verilog
prop_cov3: cover property ( disable iff (reset)
    @(posedge clk) a #-# s_eventually[1:100] b
)
begin
    my_count++;
    $display(""success of prop_cov3 at time %t"", $time);
end
```","
prop_cov2: cover property ( disable iff (reset)
    @(posedge clk) a |-> s_eventually[1:100] b
)
begin
    my_count++;
    $display(""success of prop_cov2 at time %t"", $time);
end


prop_cov3: cover property ( disable iff (reset)
    @(posedge clk) a #-# s_eventually[1:100] b
)
begin
    my_count++;
    $display(""success of prop_cov3 at time %t"", $time);
end
","Caption: ""Understanding Verilog cover properties with examples of proper usage and efficiency tips for functional coverage in simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p158.jpg,True,"```verilog
module foo;
  integer i;
  initial begin
    for (i=0; i<15; i=i+1); // semicolon is NOT an error
    begin
      $display(""Loop pass executing""); // GOTCHA! only executes once
    end
  end
endmodule

initial begin
  reset_n = 0;
  repeat (8) @(posedge clock); // loop 8 clock cycles doing no-op
  reset_n = 1;
end
```","
module foo;
  integer i;
  initial begin
    for (i=0; i<15; i=i+1); // semicolon is NOT an error
    begin
      $display(""Loop pass executing""); // GOTCHA! only executes once
    end
  end
endmodule

initial begin
  reset_n = 0;
  repeat (8) @(posedge clock); // loop 8 clock cycles doing no-op
  reset_n = 1;
end
","Verilog Gotcha: Misplaced semicolons in for loops can lead to loops executing only once, despite being syntactically legal.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p78.jpg,True,"Here is the Verilog code from the image:

```verilog
always_ff @(posedge clk, negedge rst_n, negedge set_n)
  if (!rst_n)          // reset has priority over set
    q_out <= '1'b0;    // reset assignments
  else if (!set_n)
    q_out <= '1'b1;    // set assignments
  else
    q_out <= data_in;  // d input assignment
```","
always_ff @(posedge clk, negedge rst_n, negedge set_n)
  if (!rst_n)          // reset has priority over set
    q_out <= '1'b0;    // reset assignments
  else if (!set_n)
    q_out <= '1'b1;    // set assignments
  else
    q_out <= data_in;  // d input assignment
","Caption: ""Understanding the Gotchas in Verilog for Asynchronous Set/Reset Flip-Flop Modeling.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p500.jpg,True,"The image contains a snippet of Verilog code. Here's the text from the image:

```verilog
module FullDup (#parameter DwId = 32
                , RxLogDepthA = 3, TxLogDepthA = 3 // 3 -> 8 words.
                , RxLogDepthB = 4, TxLogDepthB = 4 // 4 -> 16 words.
                )
// ... (module port declarations) ...
```","
module FullDup (#parameter DwId = 32
                , RxLogDepthA = 3, TxLogDepthA = 3 // 3 -> 8 words.
                , RxLogDepthB = 4, TxLogDepthB = 4 // 4 -> 16 words.
                )
// ... (module port declarations) ...
",Caption: Instructions and Verilog code snippet for configuring a FullDuplex module with parameterized FIFO depths in Digital VLSI design using Verilog.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p50.jpg,True,"Here is the Verilog code displayed in the image:

```verilog
case (select)                  // intent is for a 4-to-1 MUX behavior
  00: y = a;
  01: y = b;
  10: y = c;                   // GOTCHA! This branch is never selected
  11: y = d;                   // GOTCHA! This branch is never selected
  default: $display(""select value of %b not decoded"", select);
endcase
```

```verilog
unique case (select)           // intent is for a 4-to-1 MUX behavior
  00: y = a;
  01: y = b;
  10: y = c;                   // GOTCHA! This branch is never selected
  11: y = d;                   // GOTCHA! This branch is never selected
endcase
```

```verilog
unique case (select)           // intent is for a 4-to-1 MUX behavior
  2’b00: y = a;
  2’b01: y = b;                // OK, this branch can be selected
  2’b10: y = c;                // OK, this branch can be selected
  2’b11: y = d;                // OK, this branch can be selected
endcase
```

This text contains a few areas where the apostrophe is used incorrectly in the bit width specifier (e.g., `2’b00` should be `2'b00`). Please make sure to correct this if you use the code in a Verilog simulator or any development environment.","
case (select)                  // intent is for a 4-to-1 MUX behavior
  00: y = a;
  01: y = b;
  10: y = c;                   // GOTCHA! This branch is never selected
  11: y = d;                   // GOTCHA! This branch is never selected
  default: $display(""select value of %b not decoded"", select);
endcase


unique case (select)           // intent is for a 4-to-1 MUX behavior
  00: y = a;
  01: y = b;
  10: y = c;                   // GOTCHA! This branch is never selected
  11: y = d;                   // GOTCHA! This branch is never selected
endcase


unique case (select)           // intent is for a 4-to-1 MUX behavior
  2’b00: y = a;
  2’b01: y = b;                // OK, this branch can be selected
  2’b10: y = c;                // OK, this branch can be selected
  2’b11: y = d;                // OK, this branch can be selected
endcase
","Caption: ""Understanding Verilog Gotchas: Correcting Case Statements with Default and Unique Modifiers""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p399.jpg,True,"The image contains a sample of code written in Verilog. Here is the code presented in the image:

```verilog
sequence s_cnt_occurrences(bit a, local output int num_a);
  (1'b1, num_a = a)
  ##1 (a[->1], num_a++)
    [*]
  ##1 !a[*];
endsequence

property p_num_dataValid_check;
  transType l_ttype;
  int num_dataValid;
  (start, l_ttype = ttype)
  ##1
  (
    s_cnt_occurrences(.a(dataValid), .num_a(num_dataValid))
    intersect
    complete[-1]
  )
  |-> num_dataValid_OK(l_ttype, num_dataValid);
endproperty

a_num_dataValid_check: assert property (p_num_dataValid_check);
```

This code snippet appears to be an example of using SystemVerilog assertions and sequences to check the number of occurrences of a signal `dataValid` based on conditions defined in the properties and sequences.","
sequence s_cnt_occurrences(bit a, local output int num_a);
  (1'b1, num_a = a)
  ##1 (a[->1], num_a++)
    [*]
  ##1 !a[*];
endsequence

property p_num_dataValid_check;
  transType l_ttype;
  int num_dataValid;
  (start, l_ttype = ttype)
  ##1
  (
    s_cnt_occurrences(.a(dataValid), .num_a(num_dataValid))
    intersect
    complete[-1]
  )
  |-> num_dataValid_OK(l_ttype, num_dataValid);
endproperty

a_num_dataValid_check: assert property (p_num_dataValid_check);
","""Verilog code snippet demonstrating the use of sequences and properties to check occurrences of a signal within a specified timeframe.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p170.jpg,True,"The image contains Verilog code. Here is the code excerpt:

```verilog
class Foo;
  int data;
  function new (int d);
    this.data = d; // assign to data at time of construction
  endfunction
  ...
endclass

class Bar;
  Foo f = new(3); // pass initial value to new method of Foo
endclass

class Foo;
  int data;
  ...
endclass

class Bar;
  Foo f = new;
  function change_data(int d); // assign to data after construction
    f.data = d;
  endfunction
endclass
```

The text discusses a gotcha in Verilog regarding executable code within a class outside of a task or function, and how to correctly assign values using class constructors and methods.","
class Foo;
  int data;
  function new (int d);
    this.data = d; // assign to data at time of construction
  endfunction
  ...
endclass

class Bar;
  Foo f = new(3); // pass initial value to new method of Foo
endclass

class Foo;
  int data;
  ...
endclass

class Bar;
  Foo f = new;
  function change_data(int d); // assign to data after construction
    f.data = d;
  endfunction
endclass
","Caption: ""Best practices for initializing and assigning values in Verilog class objects to avoid compilation errors.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p395.jpg,True,"The image contains an excerpt of a document discussing coverage options in Verilog. Here is the code from the document:

```verilog
covergroup CovDst44;
  kind: coverpoint tr.kind;
  dst: coverpoint tr.dst;
  cross kind, dst;
  option.cross_num_print_missing = 1_000;
endgroup
```

This code snippet is defining a covergroup for collecting coverage data in a verification environment, particular to the SystemVerilog language which is often used in the context of hardware design and verification.","
covergroup CovDst44;
  kind: coverpoint tr.kind;
  dst: coverpoint tr.dst;
  cross kind, dst;
  option.cross_num_print_missing = 1_000;
endgroup
","""Excerpt from a manual discussing coverage threshold and printing empty bins in Verilog simulation, along with a sample Verilog code for a coverage group.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p266.jpg,True,"```verilog
task CheckToggle(input[1:0] BitNo);
begin
  @(InBus[BitNo]) #1 ToggledReg = BitNo;
end
endtask
// 
always@(posedge CheckInBus) CheckToggle(0);
always@(posedge CheckInBus) CheckToggle(1);
always@(posedge CheckInBus) CheckToggle(2);
always@(posedge CheckInBus) CheckToggle(3);
...

// Use bit-selects:
always@(InBus[0]) TempToggledReg = 2'h0;
always@(InBus[1]) TempToggledReg = 2'h1;
always@(InBus[2]) TempToggledReg = 2'h2;
always@(InBus[3]) TempToggledReg = 2'h3;
always@(posedge CheckInBus) #1 ToggledReg = TempToggledReg;

always@(posedge CheckInBus)
begin  // begin/end not required.
fork
CheckToggle(0);
CheckToggle(1);
CheckToggle(2);
CheckToggle(3);
join
end
```","
task CheckToggle(input[1:0] BitNo);
begin
  @(InBus[BitNo]) #1 ToggledReg = BitNo;
end
endtask
// 
always@(posedge CheckInBus) CheckToggle(0);
always@(posedge CheckInBus) CheckToggle(1);
always@(posedge CheckInBus) CheckToggle(2);
always@(posedge CheckInBus) CheckToggle(3);
...

// Use bit-selects:
always@(InBus[0]) TempToggledReg = 2'h0;
always@(InBus[1]) TempToggledReg = 2'h1;
always@(InBus[2]) TempToggledReg = 2'h2;
always@(InBus[3]) TempToggledReg = 2'h3;
always@(posedge CheckInBus) #1 ToggledReg = TempToggledReg;

always@(posedge CheckInBus)
begin  // begin/end not required.
fork
CheckToggle(0);
CheckToggle(1);
CheckToggle(2);
CheckToggle(3);
join
end
",A textbook page discussing Verilog task instance concurrency with examples of non-synthesizable and synthesizable bit-checking solutions.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p381.jpg,True,"The image contains a snippet of Verilog code pertaining to specifying bin names for coverage in SystemVerilog. The code is as follows:

```verilog
covergroup CovKind18;
    coverpoint p.kind {
        bins zero = {0};          // 1 bin for kind==0
        bins lo   = {[1:3], 5};   // 1 bin for values 1:3, 5
        bins hi[] = {[8:$]};      // 8 separate bins: 8...15
        bins misc = default;      // 1 bin for rest, does not count
    }                            // No semicolon
endgroup
```

Please note that the code provided here is meant for illustrative purposes and may be part of a larger SystemVerilog testbench code. The bins specify the values to be covered during simulation to measure functional coverage. The `hi[]` bin uses the `$` sign, which is a SystemVerilog feature that allows the upper bound of the range to be determined automatically by the simulator based on the context.","
covergroup CovKind18;
    coverpoint p.kind {
        bins zero = {0};          // 1 bin for kind==0
        bins lo   = {[1:3], 5};   // 1 bin for values 1:3, 5
        bins hi[] = {[8:$]};      // 8 separate bins: 8...15
        bins misc = default;      // 1 bin for rest, does not count
    }                            // No semicolon
endgroup
","""Verilog Sample Code for Defining Coverage Bins and Output of Coverage Report""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p272.jpg,True,"The image contains Verilog code. Here it is:

```verilog
...
always@(posedge Clk)
begin : CPU
    ...
    #1 Dbus = $random($time);  // $time repeats only between simulations;
    #1 Abus = $random($time);  // so should the (32-bit) random patterns.
    ...
end
```

The code shows a Verilog `always` block that triggers on the positive edge of a clock signal (`posedge Clk`). Inside the block, it assigns pseudo-random values to `Dbus` and `Abus` with a one time-unit delay after each clock edge, using the `$random` function seeded with `$time`. The comments suggest that `$time` is used to repeat random values only between simulations, implying that within a given simulation run, `$time` would not change and thus the same sequence of random values would be produced.","
...
always@(posedge Clk)
begin : CPU
    ...
    #1 Dbus = $random($time);  // $time repeats only between simulations;
    #1 Abus = $random($time);  // so should the (32-bit) random patterns.
    ...
end
","Caption: Educational material explaining the implementation of a watchdog timer in Verilog, including instructions for creating the CPU functionality with random bit patterns using the system function $random.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p164.jpg,True,"```verilog
module test;
  int result;                // 32-bit variables
  function sum(int a, b);    // no return size specified
    return (a + b);
  endfunction

  initial begin
    result = sum(3,4);       // GOTCHA! 32-bit result is always 0 or 1
    $display(""sum(3,4) return = %h (hex)"", result);
  end
endmodule: test
```","
module test;
  int result;                // 32-bit variables
  function sum(int a, b);    // no return size specified
    return (a + b);
  endfunction

  initial begin
    result = sum(3,4);       // GOTCHA! 32-bit result is always 0 or 1
    $display(""sum(3,4) return = %h (hex)"", result);
  end
endmodule: test
","Caption: ""Understanding the importance of specifying the return size in Verilog functions to prevent unexpected truncation of the return value.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p44.jpg,True,"The image contains Verilog code. Here is the code that is visible in the image:

First code snippet:
```verilog
module chip_vlog_style (...);
    ...
    always @(posedge clk)
        for (i=0; i<=15; i=i+1) begin: loop // named block
            integer temp;                 // local variable
            ...
        end
endmodule

module test;
    ...
    chip_vlog_style dut (...);
    initial $display(""temp = %0d"", test.dut.loop.temp); // OK
endmodule
```

Second code snippet:
```verilog
module chip_sv_style (...);
    ...
    always_ff @(posedge clk)
        for (int i=0; i<=15; i++) begin // unnamed block
            integer temp;               // local variable
            ...
        end
endmodule
```

These code snippets are illustrating the difference between Verilog and SystemVerilog in terms of local variable declaration and reference in unnamed blocks.","
module chip_vlog_style (...);
    ...
    always @(posedge clk)
        for (i=0; i<=15; i=i+1) begin: loop // named block
            integer temp;                 // local variable
            ...
        end
endmodule

module test;
    ...
    chip_vlog_style dut (...);
    initial $display(""temp = %0d"", test.dut.loop.temp); // OK
endmodule


module chip_sv_style (...);
    ...
    always_ff @(posedge clk)
        for (int i=0; i<=15; i++) begin // unnamed block
            integer temp;               // local variable
            ...
        end
endmodule
","""Verilog Gotchas: Understanding hierarchical references to variables in unnamed blocks through code examples.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p140.jpg,True,"The image contains code that appears to be related to Verilog and possibly using PLI (Programming Language Interface). Here is the text extracted from the image:

```verilog
#ifndef MAXINT
#define MAXINT 32
#endif
#ifndef NUMWORDS
#define NUMWORDS (x) (x-1) / MAXINT
#endif
/*******************************************
 * checktf application to validate interface
 *******************************************/
int quiescent_state_checktf(char *user_data)
{
    s_tfexprinfo expr_info;
    int current_size, end_size;
    if (tf_nump() != 2)
        tf_error(""$assert_quiescent_state requires 2 arguments "");
    current_size = tf_sizep(1);
    end_size = tf_sizep(2);
    if (current_size != end_size)
        tf_error(""$assert_quiescent_state arg(1) and arg(2) size mismatch."");
    return (0);
}

/*******************************************
 * calltf routine
 *******************************************/
int quiescent_state_calltf(char *user_data)
{
    tf_rosynchronize ();
    return (0);
}

/*******************************************
 * misctf routine to perform end of sim. check
 *******************************************/
int quiescent_state_misctf(char *user_data, int reason, int paramvc)
{
    int current_quiescent_state,
        end_quiescent_state;
    int current_high, end_high;
    int i, size, ok=1;
    s_tfexprinfo current_expr_info, end_expr_info;

    if (reason != REASON_FINISH)
        return (0);
    size = tf_sizep(1);
    if (size < 32) {
        current_quiescent_state = tf_getp(1);
        end_quiescent_state = tf_getp(2);
        if (current_quiescent_state != end_quiescent_state)
            ok = 0;
    }
}
```

Note that the image shows Verilog PLI functions, which are used to create custom C functions that can interact with a Verilog simulator. The code above defines a couple of macros and functions that check the quiescent state (a stable state with no transitions) and includes calls to PLI functions such as `tf_nump()`, `tf_error()`, `tf_sizep()`, `tf_rosynchronize()`, `tf_getp()`, etc. These functions are provided by the PLI library to allow the user to interface C code with Verilog simulations.","
#ifndef MAXINT
#define MAXINT 32
#endif
#ifndef NUMWORDS
#define NUMWORDS (x) (x-1) / MAXINT
#endif
/*******************************************
 * checktf application to validate interface
 *******************************************/
int quiescent_state_checktf(char *user_data)
{
    s_tfexprinfo expr_info;
    int current_size, end_size;
    if (tf_nump() != 2)
        tf_error(""$assert_quiescent_state requires 2 arguments "");
    current_size = tf_sizep(1);
    end_size = tf_sizep(2);
    if (current_size != end_size)
        tf_error(""$assert_quiescent_state arg(1) and arg(2) size mismatch."");
    return (0);
}

/*******************************************
 * calltf routine
 *******************************************/
int quiescent_state_calltf(char *user_data)
{
    tf_rosynchronize ();
    return (0);
}

/*******************************************
 * misctf routine to perform end of sim. check
 *******************************************/
int quiescent_state_misctf(char *user_data, int reason, int paramvc)
{
    int current_quiescent_state,
        end_quiescent_state;
    int current_high, end_high;
    int i, size, ok=1;
    s_tfexprinfo current_expr_info, end_expr_info;

    if (reason != REASON_FINISH)
        return (0);
    size = tf_sizep(1);
    if (size < 32) {
        current_quiescent_state = tf_getp(1);
        end_quiescent_state = tf_getp(2);
        if (current_quiescent_state != end_quiescent_state)
            ok = 0;
    }
}
","""Example of Verilog PLI code for checking quiescent state assertion in Assertion-Based Design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p168.jpg,True,"Here is the Verilog code from the image:

```verilog
program automatic test(Rx_if.TB Rx0, Rx1, Rx2, Rx3,
                       Tx_if.TB Tx0, Tx1, Tx2, Tx3,
                       input logic clk, output bit rst);

    bit [7:0] bytes[ATM_CELL_SIZE];

    initial begin
        // Reset the device
        rst <= 1;
        Rx0.cb.data <= 0;
        ...
        receive_cell0();
        ...
    end

    task receive_cell0();
        @(Tx0.cb);
        Tx0.cb.clav <= 1;                 // Assert ready to receive
        wait (Tx0.cb.soc == 1);           // Wait for Start of Cell

        foreach (bytes[i]) begin
            wait (Tx0.cb.en == 0);        // Wait for enable
            @(Tx0.cb);
            bytes[i] = Tx0.cb.data;
            @(Tx0.cb);
            Tx0.cb.clav <= 0;             // Deassert flow control
        end
    endtask : receive_cell0

endprogram : test
```

This code is a sample from a textbook or reference material, discussing a testbench usage with an interface that includes a clocking block in a Verilog test scenario.","
program automatic test(Rx_if.TB Rx0, Rx1, Rx2, Rx3,
                       Tx_if.TB Tx0, Tx1, Tx2, Tx3,
                       input logic clk, output bit rst);

    bit [7:0] bytes[ATM_CELL_SIZE];

    initial begin
        // Reset the device
        rst <= 1;
        Rx0.cb.data <= 0;
        ...
        receive_cell0();
        ...
    end

    task receive_cell0();
        @(Tx0.cb);
        Tx0.cb.clav <= 1;                 // Assert ready to receive
        wait (Tx0.cb.soc == 1);           // Wait for Start of Cell

        foreach (bytes[i]) begin
            wait (Tx0.cb.en == 0);        // Wait for enable
            @(Tx0.cb);
            bytes[i] = Tx0.cb.data;
            @(Tx0.cb);
            Tx0.cb.clav <= 0;             // Deassert flow control
        end
    endtask : receive_cell0

endprogram : test
",Verilog code example showcasing a testbench with an interface for clocking block and tasks in SystemVerilog.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p173.jpg,True,"The image contains a snippet of C code that provides a function for converting Verilog `aval/bval` encoding to a 4-state logic representation. Here is the code from the image:

```c
/***********************************************************************
 * Function to convert aval/bval encoding to 4-state logic represented
 * as a C character.
 ***********************************************************************/
char PLIbook_get_4state_val(int aval, int bval)
{
    if      (!bval && !aval) return('0');
    else if (!bval &&  aval) return('1');
    else if ( bval && !aval) return('Z');
    else                     return('X');
}
```

Additionally, there's a `typedef` structure for representing Verilog strength values in C, which is also visible in the image:

```c
typedef struct t_vpi_strengthval
{
    int logic;
    int s0, s1;
} s_vpi_strengthval, *p_vpi_strengthval;
```","*******************************************************************
 * Function to convert aval/bval encoding to 4-state logic represented
 * as a C character.
 ***********************************************************************/
char PLIbook_get_4state_val(int aval, int bval)
{
    if      (!bval && !aval) return('0');
    else if (!bval &&  aval) return('1');
    else if ( bval && !aval) return('Z');
    else                     return('X');
}

ef struct t_vpi_strengthval
{
    int logic;
    int s0, s1;
} s_vpi_strengthval, *p_vpi_strengthval;
","Caption: ""Documentation on interfacing C with Verilog using VPI routines to read and modify logic values and strength levels.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p164.jpg,True,"The image contains Verilog code snippets. Here they are:

```verilog
b1: assert property (@(posedge clk) ##1 $fell(sig) |-> !sig[4]);
b2: assert property (@(posedge clk) $fell(sig) |-> !sig[4*x]);
```

```verilog
a1: assert property (@(posedge clk)
    nexttime ($rose(req) |-> ##[1:5] gnt));
```

Or there's another formulation provided:

```verilog
a2: assert property (@(posedge clk)
    ##1 $rose(req) |-> ##[1:5] gnt);
```

And a third assertion, also provided in the text:

```verilog
a3: assert property (@(posedge clk)
    !req ##1 req |-> ##[1:5] gnt);
```","
b1: assert property (@(posedge clk) ##1 $fell(sig) |-> !sig[4]);
b2: assert property (@(posedge clk) $fell(sig) |-> !sig[4*x]);


a1: assert property (@(posedge clk)
    nexttime ($rose(req) |-> ##[1:5] gnt));


a2: assert property (@(posedge clk)
    ##1 $rose(req) |-> ##[1:5] gnt);


a3: assert property (@(posedge clk)
    !req ##1 req |-> ##[1:5] gnt);
","""Discussion of the behavior of sampled value functions in Verilog assertions, with code examples showing how to assert properties with clock edge sensitivity and the importance of initial clock tick behavior.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p338.jpg,True,"The image contains an example of SystemVerilog code defining a property and asserting that property. Here is the code from the image:

```verilog
property p1;
  @(posedge clk) $fell(bMode) |-> reject_on(bMode)
  data_transfer[*4];
endproperty

assert property (p1);
```

The code demonstrates the use of an abort property feature in SystemVerilog where an assertion is setup to monitor data transfers and will be aborted if a condition (`bMode` going high) occurs during the monitoring period.","
property p1;
  @(posedge clk) $fell(bMode) |-> reject_on(bMode)
  data_transfer[*4];
endproperty

assert property (p1);
","Caption: ""Understanding Verilog Abort Properties: A passage describing the use of various abort operators in Verilog properties with an illustrative example of an assertion.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p167.jpg,True,"The image contains text describing how to read 4-state logic as C strings in Verilog, and it includes a snippet of code. Here is the code:

```c
int PLIbook_ShowNets_calltf(char *user_data)
{
    vpiHandle systf_handle, arg_iterator, module_handle, net_iterator, net_handle;
    s_vpi_time current_time;
    s_vpi_value current_value;

    /* obtain a handle to the system task instance */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handle to system task argument */
    /* compiler has already verified only 1 arg with correct type */
    arg_iterator = vpi_iterate(vpiArgument, systf_handle);
    module_handle = vpi_scan(arg_iterator);
    vpi_free_object(arg_iterator); /* free iterator memory */
}
``` 

The text above and below this code provides context, detailing that it's part of Example 5.4 and that the full source code is available on a CD accompanying the book. It's related to using vpi_get_value() to read 4-state values in Verilog.","LIbook_ShowNets_calltf(char *user_data)
{
    vpiHandle systf_handle, arg_iterator, module_handle, net_iterator, net_handle;
    s_vpi_time current_time;
    s_vpi_value current_value;

    /* obtain a handle to the system task instance */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handle to system task argument */
    /* compiler has already verified only 1 arg with correct type */
    arg_iterator = vpi_iterate(vpiArgument, systf_handle);
    module_handle = vpi_scan(arg_iterator);
    vpi_free_object(arg_iterator); /* free iterator memory */
}
","""Excerpt from a technical book on using VPI routines to read Verilog 4-state logic as C strings, with a code example of vpi_get_value().""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p170.jpg,True,"The image contains two pieces of code that are assertions written for verifying hardware designs with SystemVerilog, which is a hardware description and verification language:

1.
```verilog
a2: assert property(@(s$global_clock $changing_gclk(sig) -> |en);
```

2.
```verilog
a_fclk: assert property(@(s$global_clock) s_eventually $rising_gclk(clk));
``` 

These examples illustrate the use of temporal assertions in a hardware verification context.","
a2: assert property(@(s$global_clock $changing_gclk(sig) -> |en);


a_fclk: assert property(@(s$global_clock) s_eventually $rising_gclk(clk));
","""Exploring Clock Fairness and Efficiency in Assertions Using Verilog""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p62.jpg,True,"The image contains a snippet of C code related to the Verilog Programming Language Interface (PLI). Here is the code:

```c
#include <stdlib.h>  /* ANSI C standard library */
#include <stdio.h>   /* ANSI C standard input/output library */
#include <vpi_user.h> /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
/* TF library is used for aborting on error */
```

This is a verbatim transcription of the code included in the image. The code includes headers for the standard C library, standard input/output functions, and Verilog PLI specific functionalities.","ude <stdlib.h>  /* ANSI C standard library */
#include <stdio.h>   /* ANSI C standard input/output library */
#include <vpi_user.h> /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
/* TF library is used for aborting on error */
","Excerpt from a Verilog PLI handbook discussing the implementation of a system function $pow using PLI routines, with a reference to example source code.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p154.jpg,True,"The image contains Verilog code in two separate samples:

Sample 4.30 - Good clock generator in module:

```verilog
module clock_generator (output bit clk);
    bit local_clk = 0;
    assign clk = local_clk; // Drive port from local signal
    always #50 local_clk = ~local_clk;
endmodule
```

Sample 4.31 - Top module with implicit port connections:

```verilog
module top;
    bit clk;
    always #50 clk = ~clk;

    arb_if arbif(.*), // ... arbif(clk) From Sample 4-4
    arb_with_ifc al(.*); // ... al(arbif) From Sample 4-5
    test_with_ifc t1(.*); // ... t1(arbif) From Sample 4-6
endmodule : top
```","
module clock_generator (output bit clk);
    bit local_clk = 0;
    assign clk = local_clk; // Drive port from local signal
    always #50 local_clk = ~local_clk;
endmodule


module top;
    bit clk;
    always #50 clk = ~clk;

    arb_if arbif(.*), // ... arbif(clk) From Sample 4-4
    arb_with_ifc al(.*); // ... al(arbif) From Sample 4-5
    test_with_ifc t1(.*); // ... t1(arbif) From Sample 4-6
endmodule : top
","Caption: ""Excerpt from a Verilog digital design textbook explaining clock generator implementation and avoiding race conditions, along with an example of top module instantiation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p462.jpg,True,"```verilog
bins small = {1}; // will create a bin for the value `1` of bSize.
bins mid = {[2:max-1]}; // will create a bin for values 2 to max-1
bins large = {max}; // will create a bin for the `max` value

bins small = {1};
bins mid = {[2:1]};
bins large = {2};

bins small = {1};
bins mid = {[2:0]};
bins large = {1};

bins small = {1};
bins mid = {[2:-1]};
bins large = {0};

covergroup burstSize (int max, bSize);
cPburst_size : coverpoint bSize)
{
    bins small = {1};
    bins mid = {[2: max - 1] } with (max >= 3);
    bins large = {max } with (max > 3);
}
endgroup

burstSize bSizeInst [4, 8];
// None of the bins will overlap
``` 

This snippet of Verilog code comes from a book or document discussing functional coverage in the context of hardware description and verification using SystemVerilog, which is an extension of Verilog. The book appears to be illustrating how to correctly declare coverage bins to prevent overlap and the potential resulting compiler warnings.","
bins small = {1}; // will create a bin for the value `1` of bSize.
bins mid = {[2:max-1]}; // will create a bin for values 2 to max-1
bins large = {max}; // will create a bin for the `max` value

bins small = {1};
bins mid = {[2:1]};
bins large = {2};

bins small = {1};
bins mid = {[2:0]};
bins large = {1};

bins small = {1};
bins mid = {[2:-1]};
bins large = {0};

covergroup burstSize (int max, bSize);
cPburst_size : coverpoint bSize)
{
    bins small = {1};
    bins mid = {[2: max - 1] } with (max >= 3);
    bins large = {max } with (max > 3);
}
endgroup

burstSize bSizeInst [4, 8];
// None of the bins will overlap
","""Verilog code demonstrating functional coverage with bins, including an explanation of potential issues with overlapping bins and how to resolve them using the 'with' clause.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p304.jpg,True,"There is code in this image. The Verilog code snippet presented is a property definition for an assertion in a formal verification context:

```verilog
property CheckData;
  @(L2TxData) (L2TxData == L2ErrorData) |->
    (L2Abort == 1);
endproperty
```","
property CheckData;
  @(L2TxData) (L2TxData == L2ErrorData) |->
    (L2Abort == 1);
endproperty
","Caption: ""Fig. 19.2 Asynchronous Assertion—problem statement analysis continued, discussing the use of asynchronous edges in assertions within the context of Verilog coding.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p395.jpg,True,"The image contains text related to the Verilog hardware description language, specifically about sequence construction in the context of assertion-based design. It details the syntax for various sequence constructs. Here is the code excerpt from the image:

```verilog
cycle_delay_range ::=
    ### constant_expression
  | ###[ const_range_expression ]

const_range_expression ::= constant_expression : '$'
  | constant_expression : constant_expression

sequence_expr ::= [ cycle_delay_range ]
    sequence_expr { cycle_delay_sequence_expr }
  | expression_or_dist [boolean_repeat]
  | expression_or_dist { ';' sequence_match_item } [boolean_repeat]
  | sequence_instance [consecutive_repeat]
  | sequence_expr { ';' sequence_match_item } [consecutive_repeat]
  | event_control sequence_expr
  | (' sequence_expr ')
  | sequence_expr and sequence_expr
  | sequence_expr or sequence_expr
  | sequence_expr intersect sequence_expr
  | sequence_expr within sequence_expr
  | expression_or_dist throughout sequence_expr

sequence_match_item ::= variable_assignment | subroutine_call
expression_or_dist ::= expression
  | expression dist '{' dist_list '}'

boolean_repeat ::= consecutive_repeat
  | nonconsecutive_repeat
  | goto_repeat

consecutive_repeat ::=
    [* const_range_expression ]
nonconsecutive_repeat ::=
    [= const_range_expression ]
goto_repeat ::=
    [-> const_range_expression ]
```

This code is not a runnable Verilog code snippet but rather a description of the syntax used in defining sequence expressions in Verilog for assertion-based design.","
cycle_delay_range ::=
    ### constant_expression
  | ###[ const_range_expression ]

const_range_expression ::= constant_expression : '$'
  | constant_expression : constant_expression

sequence_expr ::= [ cycle_delay_range ]
    sequence_expr { cycle_delay_sequence_expr }
  | expression_or_dist [boolean_repeat]
  | expression_or_dist { ';' sequence_match_item } [boolean_repeat]
  | sequence_instance [consecutive_repeat]
  | sequence_expr { ';' sequence_match_item } [consecutive_repeat]
  | event_control sequence_expr
  | (' sequence_expr ')
  | sequence_expr and sequence_expr
  | sequence_expr or sequence_expr
  | sequence_expr intersect sequence_expr
  | sequence_expr within sequence_expr
  | expression_or_dist throughout sequence_expr

sequence_match_item ::= variable_assignment | subroutine_call
expression_or_dist ::= expression
  | expression dist '{' dist_list '}'

boolean_repeat ::= consecutive_repeat
  | nonconsecutive_repeat
  | goto_repeat

consecutive_repeat ::=
    [* const_range_expression ]
nonconsecutive_repeat ::=
    [= const_range_expression ]
goto_repeat ::=
    [-> const_range_expression ]
","""Excerpt from a technical document detailing the syntax for sequence construction in Verilog for assertion-based design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p629.jpg,True,"The image contains a portion of code that seems to be written in C programming language, intended to interface with Verilog simulation models using ACC (Application Call Interface) routines. Here's the code from the image:

```c
if (tf_getworkarea(instance_p) == NULL) {
    /* Schedule a synchronize callback to miscft for this instance */
    tf_isynchronize(instance_p);
    tf_setworkarea(""1"", instance_p); /* set work area to non-null */
}

return(0);
}

/***********************************************************************
* miscft routine: Serves as an interface between Verilog simulation 
* and the C model. Called by the VCI consumer application whenever 
* the C model inputs change value, reads the values of all inputs, 
* passes the values to the C model, and writes the C model outputs 
* into simulation.
***********************************************************************/
int PLIbook_ScientificALU_miscft(int user_data, int reason)
{
    double a, b, result;
    int opcode, excep, err;
    handle instance_h, result_h, excep_h, err_h,
           a_h, b_h, opcode_h;
    s_setval_value value_s;
    s_setval_delay delay_s;
    s_acc_time time_s;

    if (reason != REASON_SYNCH)
        return(0); /* abort miscft if not called for synchronize reason */

    acc_initialize();

    /* Set the TF work area for this instance to null (a flag that
    * this callback has been processed)
    */
    tf_setworkarea(null);

    /* Obtain handles to all task arguments */
    a_h = acc_handle_tfarg(ALU_A);
    b_h = acc_handle_tfarg(ALU_B);
    opcode_h = acc_handle_tfarg(ALU_OP);
    result_h = acc_handle_tfarg(ALU_RESULT);
    excep_h = acc_handle_tfarg(ALU_EXCEPT);
    err_h = acc_handle_tfarg(ALU_ERROR);

    /* Read current values of C model inputs from Verilog simulation */
    value_s.format = accRealVal;
    acc_fetch_value(a_h, ""%f"", &value_s);
    a = value_s.value.real;

    acc_fetch_value(b_h, ""%f"", &value_s);
    b = value_s.value.real;

    value_s.format = accIntVal;
    acc_fetch_value(opcode_h, ""%d"", &value_s);
    opcode = value_s.value.integer;
```

Please note that the full function and context are not completely visible in the image, and therefore, portions of code may be missing. This code snippet is used for interfacing with C models from Verilog simulations by using ACC routines.","f_getworkarea(instance_p) == NULL) {
    /* Schedule a synchronize callback to miscft for this instance */
    tf_isynchronize(instance_p);
    tf_setworkarea(""1"", instance_p); /* set work area to non-null */
}

return(0);
}

/***********************************************************************
* miscft routine: Serves as an interface between Verilog simulation 
* and the C model. Called by the VCI consumer application whenever 
* the C model inputs change value, reads the values of all inputs, 
* passes the values to the C model, and writes the C model outputs 
* into simulation.
***********************************************************************/
int PLIbook_ScientificALU_miscft(int user_data, int reason)
{
    double a, b, result;
    int opcode, excep, err;
    handle instance_h, result_h, excep_h, err_h,
           a_h, b_h, opcode_h;
    s_setval_value value_s;
    s_setval_delay delay_s;
    s_acc_time time_s;

    if (reason != REASON_SYNCH)
        return(0); /* abort miscft if not called for synchronize reason */

    acc_initialize();

    /* Set the TF work area for this instance to null (a flag that
    * this callback has been processed)
    */
    tf_setworkarea(null);

    /* Obtain handles to all task arguments */
    a_h = acc_handle_tfarg(ALU_A);
    b_h = acc_handle_tfarg(ALU_B);
    opcode_h = acc_handle_tfarg(ALU_OP);
    result_h = acc_handle_tfarg(ALU_RESULT);
    excep_h = acc_handle_tfarg(ALU_EXCEPT);
    err_h = acc_handle_tfarg(ALU_ERROR);

    /* Read current values of C model inputs from Verilog simulation */
    value_s.format = accRealVal;
    acc_fetch_value(a_h, ""%f"", &value_s);
    a = value_s.value.real;

    acc_fetch_value(b_h, ""%f"", &value_s);
    b = value_s.value.real;

    value_s.format = accIntVal;
    acc_fetch_value(opcode_h, ""%d"", &value_s);
    opcode = value_s.value.integer;
","""Example of interfacing Verilog with C models using ACC (Application Compiler Codasyl Committee) routines for cosimulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p277.jpg,True,"```verilog
@(posedge clk)
s_mchk15 |-> 
##[1:8] ((s$stable(ad[31:0]))
&& (s$stable (cxben[3:0])))
##1 (par ^ s$past (^ad[31:0]^cxben[3:0])) == 0);
endproperty

a_mchk15: assert property(p_mchk15);
c_mchk15: cover property(p_mchk15);
```","
@(posedge clk)
s_mchk15 |-> 
##[1:8] ((s$stable(ad[31:0]))
&& (s$stable (cxben[3:0])))
##1 (par ^ s$past (^ad[31:0]^cxben[3:0])) == 0);
endproperty

a_mchk15: assert property(p_mchk15);
c_mchk15: cover property(p_mchk15);
","Caption: ""Excerpt from a document illustrating a SystemVerilog Assertion (SVA) for protocol interface checking in a PCI Master transaction scenario, with accompanying waveform diagram and explanation.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p381.jpg,True,"The image contains Verilog code written in a text-based document, specifically regarding property implication syntax and examples. Here is the code:

For overlapping implication:
```verilog
property_expr ::= sequence_expr '|->' property_expr
```

For non-overlapping (suffix) implication:
```verilog
property_expr ::= sequence_expr '|=>' property_expr
```

Examples listed:
```verilog
a |->b                                 same as    a ? b : '1'b1

(a##1 b) |-> (c)                       same as    (a##1 b) ? c : '1'b1

(a ##1 b) |=> (c ##1 d)                same as    (a ##1 b) |-> ##1 c ##1 d
```

And it also mentions an equivalence:
```verilog
antecedent |-> first_match(property_is_a_sequence)
```","
property_expr ::= sequence_expr '|->' property_expr


property_expr ::= sequence_expr '|=>' property_expr


a |->b                                 same as    a ? b : '1'b1

(a##1 b) |-> (c)                       same as    (a##1 b) ? c : '1'b1

(a ##1 b) |=> (c ##1 d)                same as    (a ##1 b) |-> ##1 c ##1 d


antecedent |-> first_match(property_is_a_sequence)
","""Understanding Property Implication in Verilog Assertions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p263.jpg,True,"```verilog
property p_mchk3;
@(posedge clk)
$fell (irdyn) ##[0:5]
(!devseln) ##0 stpopn |-> 
( !irdyn ) [*0:16] ##0 !trdyn;
endproperty

a_mchk3: assert property(p_mchk3);
c_mchk3: cover property(p_mchk3);
```","
property p_mchk3;
@(posedge clk)
$fell (irdyn) ##[0:5]
(!devseln) ##0 stpopn |-> 
( !irdyn ) [*0:16] ##0 !trdyn;
endproperty

a_mchk3: assert property(p_mchk3);
c_mchk3: cover property(p_mchk3);
","Caption: ""Example of SystemVerilog Assertions (SVA) for protocol interface, focusing on the relationship between signals 'irdyn' and 'trdyn' during a data transfer phase.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p310.jpg,True,"The image contains text and code related to the `$changed` system function in Verilog. Here is the code snippet from the page:

```verilog
tp: assert property (@(posedge clk) toggleSig ##1 !toggleSig);
```
```verilog
tp: assert property (@(posedge clk) ##1 $changed(toggleSig));
```

The rest of the content on the page provides explanation and notes regarding the usage of the `$changed` function in SystemVerilog.","
tp: assert property (@(posedge clk) toggleSig ##1 !toggleSig);


tp: assert property (@(posedge clk) ##1 $changed(toggleSig));
",Caption: Explanation and example code segment demonstrating the use of the `$changed` construct in SystemVerilog for detecting changes in signal values across clock cycles.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p205.jpg,True,"```verilog
casez (c_hot) // RTL synthesis parallel_case
  8'b1???????: c_code = 3'b000;
  8'b?1??????: c_code = 3'b001;
  8'b??1?????: c_code = 3'b010;
  8'b???1????: c_code = 3'b011;
  8'b????1???: c_code = 3'b100;
  8'b?????1??: c_code = 3'b101;
  8'b??????1?: c_code = 3'b110;
  8'b???????1: c_code = 3'b111;
endcase
```","
casez (c_hot) // RTL synthesis parallel_case
  8'b1???????: c_code = 3'b000;
  8'b?1??????: c_code = 3'b001;
  8'b??1?????: c_code = 3'b010;
  8'b???1????: c_code = 3'b011;
  8'b????1???: c_code = 3'b100;
  8'b?????1??: c_code = 3'b101;
  8'b??????1?: c_code = 3'b110;
  8'b???????1: c_code = 3'b111;
endcase
","""Example of Verilog priority encoder using case and casex statements with parallel case synthesis considerations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p288.jpg,True,"```verilog
property p_tchk8;
@(posedge clk)
$fell (framen) && (cxben[3:0] == 4'b0001) |-> 
deveseln [*1:$] ##0 $rose (framen);
endproperty

a_tchk8: assert property(p_tchk8);
c_tchk8: cover property(p_tchk8);
```","
property p_tchk8;
@(posedge clk)
$fell (framen) && (cxben[3:0] == 4'b0001) |-> 
deveseln [*1:$] ##0 $rose (framen);
endproperty

a_tchk8: assert property(p_tchk8);
c_tchk8: cover property(p_tchk8);
","""Verilog property example and waveform for PCI Target check in digital design verification""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p211.jpg,True,"```verilog
module b (p, w, x, y, z);
input [7:0] w, x, y, z;
output [7:0] p;
wire [7:0] w, x, y, z;
reg [7:0] p, r, s;
always @(w or x or y or z)
begin
  r = w | x;             //rank 1
  p = r & s;             //rank 2
  s = y | z;             //rank 1
end
endmodule // b
```","
module b (p, w, x, y, z);
input [7:0] w, x, y, z;
output [7:0] p;
wire [7:0] w, x, y, z;
reg [7:0] p, r, s;
always @(w or x or y or z)
begin
  r = w | x;             //rank 1
  p = r & s;             //rank 2
  s = y | z;             //rank 1
end
endmodule // b
","Caption: ""Example Verilog module demonstrating procedural blocks with a discussion on best practices for timing and delay usage in RTL design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p489.jpg,True,"The image contains snippets of code written in Verilog, which seem to be related to specifying transition bins for coverage purposes in verification. Here is the code from the image:

Example 1 code snippet:
```
bins Tbin1 = (7 => 8 => 9), ( {10:11}, 12=> 13, 14 );
```

Example 2 code snippet:
```
bins Tbin2 = (1 => [->4:6] => 1;
1 => ...=>4 ...=>5 ...=> 6 => 1
```

The code defines coverage bins that specify various transition sequences that need to be covered during simulation for verification purposes. The notation `=>` represents a transition from one value to another, and the braces `{}` and brackets `[]` denote ranges or repetitions.","bin1 = (7 => 8 => 9), ( {10:11}, 12=> 13, 14 );

bin2 = (1 => [->4:6] => 1;
1 => ...=>4 ...=>5 ...=> 6 => 1
","Caption: ""Guidance on specifying transition bins in Verilog for coverage analysis, with examples using 'goto' and value transitions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p239.jpg,True,"The image includes some Verilog code as part of an example under the heading ""Operator precedence"". Here is the code extracted from the image:

```verilog
wire c, a;
wire [7:0] b;
assign c = a || b; // is not treated consistently
assign c = a || (b); // is treated consistently
```","
wire c, a;
wire [7:0] b;
assign c = a || b; // is not treated consistently
assign c = a || (b); // is treated consistently
",Verilog RTL tutorial excerpt discussing operator precedence and library-only operators in Verilog code.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p89.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
void vpi_get_time(object, time)
vpiHandle object;              // handle for an object.
p_vpi_time time;               // pointer to an application-allocated s_vpi_time structure
                               // to receive time information.

typedef struct t_vpi_time {
    int type;                  // vpiScaledRealTime, vpiSimTime */
    unsigned int high;         // when using vpiSimTime */
    unsigned int low;          // when using vpiSimTime */
    double real;               // when using vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;
```

This code defines a function `vpi_get_time` used for accessing current simulation time in Verilog simulations, as well as the definition of the `t_vpi_time` structure that is used with this function.","
void vpi_get_time(object, time)
vpiHandle object;              // handle for an object.
p_vpi_time time;               // pointer to an application-allocated s_vpi_time structure
                               // to receive time information.

typedef struct t_vpi_time {
    int type;                  // vpiScaledRealTime, vpiSimTime */
    unsigned int high;         // when using vpiSimTime */
    unsigned int low;          // when using vpiSimTime */
    double real;               // when using vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;
","""Documentation excerpt on reading the current simulation time in Verilog using VPI routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p197.jpg,True,"The image contains Verilog code in two samples. Below is the transcription of both code samples:

Sample 5.30 Using an array of handles
```verilog
task generator();
    Transaction tarray[10];
    foreach (tarray[i]) begin
        tarray[i] = new();       // Construct each object
        transmit(tarray[i]);
    end
endtask
```

Sample 5.31 Copying a simple class with new
```verilog
class Transaction;
    bit [31:0] addr, csm, data[8];
    function new();
        $display(""In %m"");
    endfunction
endclass

Transaction src, dst;
initial begin
    src = new();          // Create first object
    dst = new src;        // Make a copy with new operator
end
```","
task generator();
    Transaction tarray[10];
    foreach (tarray[i]) begin
        tarray[i] = new();       // Construct each object
        transmit(tarray[i]);
    end
endtask


class Transaction;
    bit [31:0] addr, csm, data[8];
    function new();
        $display(""In %m"");
    endfunction
endclass

Transaction src, dst;
initial begin
    src = new();          // Create first object
    dst = new src;        // Make a copy with new operator
end
",Sample Verilog Code: Demonstrating Object-Oriented Programming Concepts in Verilog with Examples on Array of Handles and Copying Objects with the New Operator.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p342.jpg,True,"The image contains a text excerpt about PSL (Property Specification Language) and its temporal layer, but it doesn't include any Verilog code. It describes SEQUENTIAL EXTENDED REGULAR EXPRESSIONS (SEREs) and provides the syntax for a SERE in a box labeled ""Syntax B-1"". Here is the syntax snippet from the image:

```
SERE ::= 
          Boolean
        | Sequence
```

This is not executable Verilog code but rather a formal syntax definition for a part of the PSL language.",":= 
          Boolean
        | Sequence
","Caption: ""Excerpt from a technical document explaining the concept of Sequence Extended Regular Expressions (SERE) as part of the PSL Temporal Layer in assertion-based design for hardware verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p198.jpg,True,"```c
int PLIbook_SetMipd_calltf(char *user_data) {
    vpiHandle tfarg_itr, tfarg_h, port_itr, port_h;
    int i;
    s_vpi_delay delay_struct;            /* structure to delay setup */
    s_vpi_time delay_array[3];           /* structure to hold delays */
    s_vpi_value tfarg_value;             /* structure to hold tfarg values */

    delay_struct.da = delay_array;
    delay_struct.no_of_delays = 3;
    delay_struct.time_type = vpiScaledRealTime;
    delay_struct.mtm_flag = 0;
    delay_struct.append_flag = 0;
    delay_struct.pulsere_flag = 0;
    tfarg_value.format = vpiRealVal;

    /* obtain handle to system task arguments;
       compilerf has already verified only 4 args with correct types */
    tfarg_itr = vpi_iterate(vpiArgument, vpi_handle(vpiSysTfCall, NULL));
    tfarg_h = vpi_scan(tfarg_itr);  /* read 1st tfarg */
    port_itr = vpi_iterate(vpiPort, tfarg_h);
    port_h = vpi_scan(port_itr);
    vpi_free_object(port_itr);      /* free iterator--did not scan to null */
    for (i=0; i<2; i++) {
        vpi_get_value(vpi_scan(tfarg_itr), &tfarg_value); /* read tfargs */
        delay_array[i].real = tfarg_value.value.real;
    }
    vpi_free_object(tfarg_itr);     /* free iterator--did not scan to null */

    vpi_put_delays(port_h, &delay_struct);
}

/***********************************************************************/

/* compiletf routine */
int PLIbook_SetMipd_compiletf(p_cb_data cb_data)
{
    vpiHandle systf_h, tfarg_itr, tfarg_h, port_itr, port_h;
    int i;

    systf_h = vpi_handle(vpiSysTfCall, NULL);

    /* ... */
}
```","LIbook_SetMipd_calltf(char *user_data) {
    vpiHandle tfarg_itr, tfarg_h, port_itr, port_h;
    int i;
    s_vpi_delay delay_struct;            /* structure to delay setup */
    s_vpi_time delay_array[3];           /* structure to hold delays */
    s_vpi_value tfarg_value;             /* structure to hold tfarg values */

    delay_struct.da = delay_array;
    delay_struct.no_of_delays = 3;
    delay_struct.time_type = vpiScaledRealTime;
    delay_struct.mtm_flag = 0;
    delay_struct.append_flag = 0;
    delay_struct.pulsere_flag = 0;
    tfarg_value.format = vpiRealVal;

    /* obtain handle to system task arguments;
       compilerf has already verified only 4 args with correct types */
    tfarg_itr = vpi_iterate(vpiArgument, vpi_handle(vpiSysTfCall, NULL));
    tfarg_h = vpi_scan(tfarg_itr);  /* read 1st tfarg */
    port_itr = vpi_iterate(vpiPort, tfarg_h);
    port_h = vpi_scan(port_itr);
    vpi_free_object(port_itr);      /* free iterator--did not scan to null */
    for (i=0; i<2; i++) {
        vpi_get_value(vpi_scan(tfarg_itr), &tfarg_value); /* read tfargs */
        delay_array[i].real = tfarg_value.value.real;
    }
    vpi_free_object(tfarg_itr);     /* free iterator--did not scan to null */

    vpi_put_delays(port_h, &delay_struct);
}

/***********************************************************************/

/* compiletf routine */
int PLIbook_SetMipd_compiletf(p_cb_data cb_data)
{
    vpiHandle systf_h, tfarg_itr, tfarg_h, port_itr, port_h;
    int i;

    systf_h = vpi_handle(vpiSysTfCall, NULL);

    /* ... */
}
","Caption: ""Verilog Procedural Interface (VPI) example code demonstrating the use of vpi_put_delays() function from 'The Verilog PLI Handbook, Part One'.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p183.jpg,True,"The image contains examples of Verilog/SystemVerilog code. Here is the code as presented in the image:

```verilog
class Transaction;
  bit [31:0] addr, csm, data[8];
  extern function void display();
endclass

function void Transaction::display();
  $display(""%0t: Transaction addr=%h, csm=%h, data=%p"", $time, addr, csm, data);
endfunction

class PCI_Tran;
  bit [31:0] addr, data; // Use realistic names
  extern function void display();
endclass

function void PCI_Tran::display();
  $display(""%0t: PCI: addr=%h, data=%h"", $time, addr, data);
endfunction
```

These snippets show how to define SystemVerilog methods outside of the class definition.","
class Transaction;
  bit [31:0] addr, csm, data[8];
  extern function void display();
endclass

function void Transaction::display();
  $display(""%0t: Transaction addr=%h, csm=%h, data=%p"", $time, addr, csm, data);
endfunction

class PCI_Tran;
  bit [31:0] addr, data; // Use realistic names
  extern function void display();
endclass

function void PCI_Tran::display();
  $display(""%0t: PCI: addr=%h, data=%h"", $time, addr, data);
endfunction
","Caption: ""Defining and implementing methods outside of a class in SystemVerilog as illustrated in a programming textbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p775.jpg,True,"The image contains text, which looks like documentation or excerpts from a manual related to Verilog, specifically the IEEE 1364-1995 ACC Routine Library. However, it does not contain actual Verilog code that can be executed or compiled. It describes functions from the ACC (Application Control Interface) library used in Verilog simulations for tasks such as replacing delay values and pulse control values for module paths. Here's the text related to the functions:

```plaintext
bool acc_replace_delays(object, d1, d2,...d12)
bool acc_replace_delays(object, dset_array)
handle object
double d1...d12
double *dset_array

bool acc_replace_pulsere(object, r1, e1,... r12, e12)
handle object
double r1... r12
double e1... e12

void acc_reset_buffer()

handle acc_set_interactive_scope()
``` 

The text above each function definition explains the parameters and the return values for the respective function, as well as any special notes on their usage.","xt
bool acc_replace_delays(object, d1, d2,...d12)
bool acc_replace_delays(object, dset_array)
handle object
double d1...d12
double *dset_array

bool acc_replace_pulsere(object, r1, e1,... r12, e12)
handle object
double r1... r12
double e1... e12

void acc_reset_buffer()

handle acc_set_interactive_scope()
","""Extract from the IEEE 1364-1995 ACC Routine Library documentation detailing functions for replacing delays and pulse controls in Verilog simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p270.jpg,True,"The image contains Verilog code. Here it is:

```verilog
sequence lvar_seq(pin,pout);
int local_data;
($rose(ptrue),local_data = pin,$display($stime,,,""pin=%0d"",pin) )
//
// This will be executed when $rose(ptrue) is detected..
//
##5
(pout == (local_data+5),$display($stime,,,""pout=%0d"",pout) );
//
// This will be executed ONLY IF
// the sequence MATCHES.
//
endsequence

property lvar;
@(posedge clk) cStart |-> lvar_seq(pipe_in,pipe_out);
endproperty

sequence lvar_seq(pin,pout);
int local_data;
($rose(ptrue),local_data = pin,lvar_seq_trigger(local_data))
##5
(pout == (local_data+5),lvar_seq_match(pin,pout,local_data));
endsequence

property lvar;
@(posedge clk) ptrue |-> lvar_seq(pipe_in,pipe_out);
endproperty

baseP: assert property (lvar) else gotoFail;
coverP: cover property (lvar) gotoPass;

task lvar_seq_trigger;
input ldata;
$display($stime,,,""%m ldata=%0d"",ldata);
// $display($stime,,,""%m ldata=%0d"",lvar_seq.pin);
// ** Error: Hierarchical access to formal parameter 'pin' of 'lvar_seq' is illegal.
endtask

task lvar_seq_match;
input tpin,tpout,ldata;
$display($stime,,,""%m pin=%0d pout=%0d ldata=%0d"",tpin,tpout,ldata);
endtask
```

The displayed code is about calling subroutines and handling local variables in Verilog. The code illustrates the use of sequence and property for verifying assertions in hardware description languages. Verilog is commonly used to model electronic systems and for formal verification of circuit designs.","
sequence lvar_seq(pin,pout);
int local_data;
($rose(ptrue),local_data = pin,$display($stime,,,""pin=%0d"",pin) )
//
// This will be executed when $rose(ptrue) is detected..
//
##5
(pout == (local_data+5),$display($stime,,,""pout=%0d"",pout) );
//
// This will be executed ONLY IF
// the sequence MATCHES.
//
endsequence

property lvar;
@(posedge clk) cStart |-> lvar_seq(pipe_in,pipe_out);
endproperty

sequence lvar_seq(pin,pout);
int local_data;
($rose(ptrue),local_data = pin,lvar_seq_trigger(local_data))
##5
(pout == (local_data+5),lvar_seq_match(pin,pout,local_data));
endsequence

property lvar;
@(posedge clk) ptrue |-> lvar_seq(pipe_in,pipe_out);
endproperty

baseP: assert property (lvar) else gotoFail;
coverP: cover property (lvar) gotoPass;

task lvar_seq_trigger;
input ldata;
$display($stime,,,""%m ldata=%0d"",ldata);
// $display($stime,,,""%m ldata=%0d"",lvar_seq.pin);
// ** Error: Hierarchical access to formal parameter 'pin' of 'lvar_seq' is illegal.
endtask

task lvar_seq_match;
input tpin,tpout,ldata;
$display($stime,,,""%m pin=%0d pout=%0d ldata=%0d"",tpin,tpout,ldata);
endtask
","""Verilog code examples demonstrating the use of subroutines and local variables in sequence properties.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p317.jpg,True,"Here is the code from the image:

```verilog
// On a given clock edge, the leading signal is
// high and after ""min_time"" clock cycles the
// trailing signal is low

property p3_hl;
    @(posedge clk) a ##min_time !b;
endproperty

// On a given clock edge, the leading signal is
// low and after ""min_time"" clock cycles the
// trailing signal is high

property p3_lh;
    @(posedge clk) !a ##min_time b;
endproperty

// On a given clock edge, the leading signal is
// low and after ""min_time"" clock cycles the
// trailing signal is low

property p3_ll;
    @(posedge clk) !a ##min_time !b;
endproperty

a3_f1: assert property(p3_hh);
a3_f2: assert property(p3_hl);
a3_f3: assert property(p3_lh);
a3_f4: assert property(p3_ll);

// On a given clock edge, the leading signal is
// high and between ""min_time"" and ""max_time""
// clock cycles the trailing signal is high

property p3_w1_hh;
    @(posedge clk) a ## [min_time : max_time] b;
endproperty
```

This is a segment from a document that provides examples of properties in Verilog which appear to be used for specifying timing relationships between signal edges within a digital system. The syntax includes the use of SystemVerilog assertions (properties and asserts).","
// On a given clock edge, the leading signal is
// high and after ""min_time"" clock cycles the
// trailing signal is low

property p3_hl;
    @(posedge clk) a ##min_time !b;
endproperty

// On a given clock edge, the leading signal is
// low and after ""min_time"" clock cycles the
// trailing signal is high

property p3_lh;
    @(posedge clk) !a ##min_time b;
endproperty

// On a given clock edge, the leading signal is
// low and after ""min_time"" clock cycles the
// trailing signal is low

property p3_ll;
    @(posedge clk) !a ##min_time !b;
endproperty

a3_f1: assert property(p3_hh);
a3_f2: assert property(p3_hl);
a3_f3: assert property(p3_lh);
a3_f4: assert property(p3_ll);

// On a given clock edge, the leading signal is
// high and between ""min_time"" and ""max_time""
// clock cycles the trailing signal is high

property p3_w1_hh;
    @(posedge clk) a ## [min_time : max_time] b;
endproperty
",Verilog code defining properties for signal timing relationships using SystemVerilog Assertions (SVA).,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p264.jpg,True,"The image contains examples of Verilog code. Here are the blocks of code present in the image:

First code block:

```verilog
always begin
  if (bState == CycleStart)
    @(posedge clk);
    // ERROR: test_procedural_assertion.sv(39):
    // always block must be sensitive to a clock as it
    // has concurrent assertions in it.
    aP: assert property (prg(req, gnt)) else
    $display($stime,,, ""FAIL;"");
end
```

Second code block:

```verilog
always begin
  @(posedge clk);
  if (bState == CycleStart)
    aP: assert property (prg(req, gnt)) else
    $display($stime,,, ""FAIL;"");
end
```

Third code block:

```verilog
always @(posedge clk) begin
  if (bState == CycleStart)
    @(negedge regCheck)
    // ERROR:
    // test_procedural_assertion.sv(40):
    // concurrent assertion can not be specified
    // after a timing control statement.
    aP: assert property (prg(req, gnt)) else
    $display($stime,,, ""FAIL;"");
end
```

Fourth code block:

```verilog
always @(posedge clk) begin
  #1;
  if (bState == CycleStart)
    aP: assert property (prg(req, gnt)) else
    $display($stime,,, ""FAIL;"");
end
```

Please note that the comments in the code are part of the learning material in the image, explaining why certain approaches may result in errors.","
always begin
  if (bState == CycleStart)
    @(posedge clk);
    // ERROR: test_procedural_assertion.sv(39):
    // always block must be sensitive to a clock as it
    // has concurrent assertions in it.
    aP: assert property (prg(req, gnt)) else
    $display($stime,,, ""FAIL;"");
end


always begin
  @(posedge clk);
  if (bState == CycleStart)
    aP: assert property (prg(req, gnt)) else
    $display($stime,,, ""FAIL;"");
end


always @(posedge clk) begin
  if (bState == CycleStart)
    @(negedge regCheck)
    // ERROR:
    // test_procedural_assertion.sv(40):
    // concurrent assertion can not be specified
    // after a timing control statement.
    aP: assert property (prg(req, gnt)) else
    $display($stime,,, ""FAIL;"");
end


always @(posedge clk) begin
  #1;
  if (bState == CycleStart)
    aP: assert property (prg(req, gnt)) else
    $display($stime,,, ""FAIL;"");
end
","Caption: ""Examples of correct and incorrect ways to embed concurrent assertions in Verilog procedural blocks, demonstrating sensitivity to clock signals and placement of assertions relative to timing control statements.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p206.jpg,True,"```verilog
always_ff @(posedge clk) begin
    if (state_e == FETCH)
        assert property (p_req_ack)     // GOTCHA!
    $display(""passed"")                  // pass statement
    else $display(""failed"");            // fail statement
    ...
end

property p_req_ack;
    @(posedge clk)
    req |-> ##1 ack;                    // a req should get an ack 1 cycle later
endproperty
```

This Verilog code excerpt is demonstrating a common issue related to concurrent assertions inside procedural blocks.","
always_ff @(posedge clk) begin
    if (state_e == FETCH)
        assert property (p_req_ack)     // GOTCHA!
    $display(""passed"")                  // pass statement
    else $display(""failed"");            // fail statement
    ...
end

property p_req_ack;
    @(posedge clk)
    req |-> ##1 ack;                    // a req should get an ack 1 cycle later
endproperty
","""Exploring Concurrent Assertions in Procedural Blocks in Verilog""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p222.jpg,True,"The image contains Verilog code. Here is the code written out:

```verilog
module sramInterface
#(
    parameter ADDRW = 16, // Number of address bits.
    parameter QueDepth = 6 // 2 <= QueDepth <= 16
)
(
    localparam IMWB = ADDRW-2; // Upper address bit. 
/* 
    The abbreviated specification of this sram controller is the 
    following:
    Provide a queued interface to a sram that accepts requests for
    reads/writes, but will not accept writes when previous reads are
    queued. Requests are issued to memory and completed when the memory
    sends memory done.
*/
    input                clk;             // The clock
    input                rst_n;           // The reset

    // SM interface to Queue.
    input                SMQueNew;        // New request on SM interface.
    input        [IMWB:1]SMQueAddr;       // Address of request
    input                SMQueSpec;       // Speculative request (only with reads).
    input        [3:0]   SMQueWrEn;       // Write enables (0000,0011,1100,1111 valid)
    input        [31:0]  SMWrData;        // Data written with enables (each byte)

    // ENG interface from Queue to memory.
    output               EngMemRd;        // Valid read request.
    output               EngMemWr;        // Valid write request.
    output       [IMWB:2]EngMemAddr;      // ENG address for operation.
    output       [63:0]  EngMemData;      // ENG write data
    output       [3:0]   EngMemWrEn;      // ENG write enables (each word).
    output               MemEngDone;      // Request is complete from memory.

    // Queue status bits.
    output               QueAlmostFull;   // No more entry available.
    output               QueFull;         // No more entries can be accepted.
    output               ReadExistsInQue; // Writes not sent to Q until no reads.

    // Queue management interface.
    input                Flush;           // Hold flush to flush the Q. Accept no new
    output               FlushAck;        // until FlushAck asserted-then clear Flush
    input                SMQueStop;       // Hold Stop to empty Q.
    output  reg          QueSMStopAck;    // Ack will occur when Stop and Q empty.
)
endmodule
```

This snippet defines a Verilog module called `sramInterface`, representing a memory interface with parameterized address width and queue depth. The module also outlines various input and output ports, indicating data and control flow for reading and writing operations, as well as queue management.","
module sramInterface
#(
    parameter ADDRW = 16, // Number of address bits.
    parameter QueDepth = 6 // 2 <= QueDepth <= 16
)
(
    localparam IMWB = ADDRW-2; // Upper address bit. 
/* 
    The abbreviated specification of this sram controller is the 
    following:
    Provide a queued interface to a sram that accepts requests for
    reads/writes, but will not accept writes when previous reads are
    queued. Requests are issued to memory and completed when the memory
    sends memory done.
*/
    input                clk;             // The clock
    input                rst_n;           // The reset

    // SM interface to Queue.
    input                SMQueNew;        // New request on SM interface.
    input        [IMWB:1]SMQueAddr;       // Address of request
    input                SMQueSpec;       // Speculative request (only with reads).
    input        [3:0]   SMQueWrEn;       // Write enables (0000,0011,1100,1111 valid)
    input        [31:0]  SMWrData;        // Data written with enables (each byte)

    // ENG interface from Queue to memory.
    output               EngMemRd;        // Valid read request.
    output               EngMemWr;        // Valid write request.
    output       [IMWB:2]EngMemAddr;      // ENG address for operation.
    output       [63:0]  EngMemData;      // ENG write data
    output       [3:0]   EngMemWrEn;      // ENG write enables (each word).
    output               MemEngDone;      // Request is complete from memory.

    // Queue status bits.
    output               QueAlmostFull;   // No more entry available.
    output               QueFull;         // No more entries can be accepted.
    output               ReadExistsInQue; // Writes not sent to Q until no reads.

    // Queue management interface.
    input                Flush;           // Hold flush to flush the Q. Accept no new
    output               FlushAck;        // until FlushAck asserted-then clear Flush
    input                SMQueStop;       // Hold Stop to empty Q.
    output  reg          QueSMStopAck;    // Ack will occur when Stop and Q empty.
)
endmodule
","""Example of a Verilog SRAM module interface definition with parameters and input/output signals""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p236.jpg,True,"The image contains examples of assertions in Verilog/SystemVerilog code. Here are the code excerpts from the image:

For the OVL valid flush operation example (7-7):
```verilog
// for Example 7-1
assert_next flush_7_1 (clk, rst_n, flush, (cnt == 0));
// for Example 7-2
assert_next flush_7_2 (clk, rst_n, flush, (!full && rdptr == wrptr));
```

SystemVerilog legal internal state for valid bits example (7-8):
```verilog
// Property for 6 deep FIFO to ensure legal state values
property legal_valid_states;
    @(posedge clk) (valid inside {6'b0, 6'b1, 6'b11, 6'b111, 
                                  6'b1111, 6'b1_1111, 6'b11_1111});
endproperty
assert property (legal_valid_states);
```

These snippets illustrate how to write assertions to check for proper system behavior in hardware description languages.","
// for Example 7-1
assert_next flush_7_1 (clk, rst_n, flush, (cnt == 0));
// for Example 7-2
assert_next flush_7_2 (clk, rst_n, flush, (!full && rdptr == wrptr));


// Property for 6 deep FIFO to ensure legal state values
property legal_valid_states;
    @(posedge clk) (valid inside {6'b0, 6'b1, 6'b11, 6'b111, 
                                  6'b1111, 6'b1_1111, 6'b11_1111});
endproperty
assert property (legal_valid_states);
",Caption: Examples of Verilog Assertions for FIFO Operations and Legal Internal States,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p212.jpg,True,"The image contains some Verilog code related to the `timescale` directive. Here is the code extracted from the image:

```verilog
`timescale 1ns/100ps  // 1 nanosecond units, 100 ps precision
module A (...);
  #2.3 ...             // delay represents 2.3 nanoseconds
endmodule

module B (...);
  #5.5 ...             // GOTCHA! delay represents 5.5 what?
endmodule

`timescale 1ps/1ps    // 1 picosecond units, 1 ps precision
module C (...);
  #7 ...               // delay represents 7 picoseconds
endmodule
```

The commented portions provide context to the `timescale` directive and its effect on the delay values specified in the modules.","
`timescale 1ns/100ps  // 1 nanosecond units, 100 ps precision
module A (...);
  #2.3 ...             // delay represents 2.3 nanoseconds
endmodule

module B (...);
  #5.5 ...             // GOTCHA! delay represents 5.5 what?
endmodule

`timescale 1ps/1ps    // 1 picosecond units, 1 ps precision
module C (...);
  #7 ...               // delay represents 7 picoseconds
endmodule
","""Understanding the `timescale` directive in Verilog and its impact on simulation consistency.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p574.jpg,True,"The image contains an excerpt of Verilog code. Here is the code from the image:

```verilog
module m;
bit clk;
logic rst_n, request,
Acknowledgment, endtrans;

default clocking @ (posedge clk iff enabled);
endclocking

default disable iff rst_n;

//... some design code ...

always @ (posedge clk) begin
  assert_handshake chk_handshake_inst(
    .req($rose(request)),
    .ack(acknowledgment ##1 endtrans));
  if (!rst_n) begin
    //... some design procedure ...
  end
end

//... some design code ...

endmodule
```

This is a code example for the instantiation of an assert_handshake checker within a Verilog module. Please note that some design code and procedures are denoted with ellipses (`...`) indicating they are abbreviated or omitted for simplicity.","
module m;
bit clk;
logic rst_n, request,
Acknowledgment, endtrans;

default clocking @ (posedge clk iff enabled);
endclocking

default disable iff rst_n;

//... some design code ...

always @ (posedge clk) begin
  assert_handshake chk_handshake_inst(
    .req($rose(request)),
    .ack(acknowledgment ##1 endtrans));
  if (!rst_n) begin
    //... some design procedure ...
  end
end

//... some design code ...

endmodule
","""Excerpt from a technical document showing Verilog code for an assert_handshake checker instantiation with explanations of its syntax and usage.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p563.jpg,True,"The image contains code in C that interfaces with Verilog hardware description language using PLI (Programming Language Interface). Here is the text of the code:

```c
#include ""veriuser.h""                     /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""                     /* IEEE 1364 PLI ACC routine library */
/***********************************************************************
 * PLIDook_ReadVecVal_calltf()
 *   Calltf routine to read a vector value into aval/bval format.
 ***********************************************************************/
int PLIDook_ReadVecVal_calltf()
{
    handle vector_h;
    s_acc_value vector_val;                /* structure to receive vector value */
    int vector_size, array_size, avalbit, bvalbit, bit_num;
    char vlogval;

    vector_h = acc_handle_tfarg(1);

    vector_size = acc_fetch_size(vector_h); /* determine number of...*/
    array_size = ((vector_size-1) / 32 + 1); /* ...elements in array */

    vector_val.value.vector = (p_acc_vecval)malloc(array_size*
                                sizeof(p_acc_vecval));

    vector_val.format = accVectorVal;      /* set value format field */

    acc_fetch_value(vector_h,""%v"",&vector_val); /* read vector's value */

    io_printf(""\nVector %s encoded value:\n"",
              acc_fetch_name(vector_h));

    for (i=0; i<array_size; i++) {
        /* the following loop assumes the Verilog LSB is bit 0 */
        for (bit_num=0; bit_num<31; bit_num++) {
            avalbit=PLIbook_getbit(vector_val.value.vector[i].aval, bit_num);
            bvalbit=PLIbook_getbit(vector_val.value.vector[i].bval, bit_num);
            vlogval=PLIbook_get_4state_val(avalbit, bvalbit);
            io_printf("" bit[%2d] aval/bval = %d/%d  4-state value = %c\n"",
                      (i*32+bit_num), avalbit, bvalbit, vlogval);
            /* quit when reach last bit of Verilog vector */
            if ((i*32+bit_num) == vector_size-1) break;
        }
    }
    return(0);
}
```

This code shows a C function intended to be used as a calltf (a callback function that is called when a system task or function is executed in a Verilog simulation) in the PLI/VPI interface. It reads the value of a Verilog vector into a C structure that includes both the logic value and the control value of every bit in the vector, allowing the C program to process Verilog data in a high level of detail.","ude ""veriuser.h""                     /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""                     /* IEEE 1364 PLI ACC routine library */
/***********************************************************************
 * PLIDook_ReadVecVal_calltf()
 *   Calltf routine to read a vector value into aval/bval format.
 ***********************************************************************/
int PLIDook_ReadVecVal_calltf()
{
    handle vector_h;
    s_acc_value vector_val;                /* structure to receive vector value */
    int vector_size, array_size, avalbit, bvalbit, bit_num;
    char vlogval;

    vector_h = acc_handle_tfarg(1);

    vector_size = acc_fetch_size(vector_h); /* determine number of...*/
    array_size = ((vector_size-1) / 32 + 1); /* ...elements in array */

    vector_val.value.vector = (p_acc_vecval)malloc(array_size*
                                sizeof(p_acc_vecval));

    vector_val.format = accVectorVal;      /* set value format field */

    acc_fetch_value(vector_h,""%v"",&vector_val); /* read vector's value */

    io_printf(""\nVector %s encoded value:\n"",
              acc_fetch_name(vector_h));

    for (i=0; i<array_size; i++) {
        /* the following loop assumes the Verilog LSB is bit 0 */
        for (bit_num=0; bit_num<31; bit_num++) {
            avalbit=PLIbook_getbit(vector_val.value.vector[i].aval, bit_num);
            bvalbit=PLIbook_getbit(vector_val.value.vector[i].bval, bit_num);
            vlogval=PLIbook_get_4state_val(avalbit, bvalbit);
            io_printf("" bit[%2d] aval/bval = %d/%d  4-state value = %c\n"",
                      (i*32+bit_num), avalbit, bvalbit, vlogval);
            /* quit when reach last bit of Verilog vector */
            if ((i*32+bit_num) == vector_size-1) break;
        }
    }
    return(0);
}
","""Verilog PLI Code Example for Reading Vector Values as Aval/Bval Pairs""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p205.jpg,True,"The image contains C code related to a Verilog simulation using VPI callbacks. The visible code is as follows:

```c
/* Work area structure definition */
typedef struct PLIbook_vpiworkarea *PLIbook_vpiworkarea_p;
typedef struct PLIbook_vpiworkarea {
    vpiHandle systf_h;  /* shows which systf instance owns this space */
    char *data;         /* data to be stored in workarea */
    PLIbook_vpiworkarea_p next_workarea;
} PLIbook_vpiworkarea_s;

/* allocate a global stack pointer */
static PLIbook_vpiworkarea_p PLIbook_vpiworkarea_stack = NULL;

/************************************************************
 * PLIbook_set_vpiworkarea()
 ************************************************************/
void PLIbook_set_vpiworkarea(vpiHandle systf_h, char *data)
{
    PLIbook_vpiworkarea_p workarea = PLIbook_vpiworkarea_stack;
```

Please note that the remainder of the function `PLIbook_set_vpiworkarea` is not visible in the image, so the function's code cannot be fully transcribed.","rk area structure definition */
typedef struct PLIbook_vpiworkarea *PLIbook_vpiworkarea_p;
typedef struct PLIbook_vpiworkarea {
    vpiHandle systf_h;  /* shows which systf instance owns this space */
    char *data;         /* data to be stored in workarea */
    PLIbook_vpiworkarea_p next_workarea;
} PLIbook_vpiworkarea_s;

/* allocate a global stack pointer */
static PLIbook_vpiworkarea_p PLIbook_vpiworkarea_stack = NULL;

/************************************************************
 * PLIbook_set_vpiworkarea()
 ************************************************************/
void PLIbook_set_vpiworkarea(vpiHandle systf_h, char *data)
{
    PLIbook_vpiworkarea_p workarea = PLIbook_vpiworkarea_stack;
","""Verilog VPI Callbacks: Implementing a Work Area Stack Structure and Functions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p212.jpg,True,"The image contains a piece of Verilog code within the text. Here is the code extracted for you:

```verilog
checker request_granted(
  sequence req, property gnt, untyped n = 1, ...
);
  if (!$isunbounded(n) && n < 0)
    $error(""Delay value n cannot be negative"", n);
  ...
  a1: assert property(req |-> nexttime[n] gnt) else $error(msg);
endchecker : request_granted
```","
checker request_granted(
  sequence req, property gnt, untyped n = 1, ...
);
  if (!$isunbounded(n) && n < 0)
    $error(""Delay value n cannot be negative"", n);
  ...
  a1: assert property(req |-> nexttime[n] gnt) else $error(msg);
endchecker : request_granted
","Caption: ""Enhancing Verilog checkers with generate statements and custom error messages for elaboration-time checks.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p211.jpg,True,"The image contains a code snippet in C, which is used to define a `struct` for Verilog simulations using VPI callbacks. Here is the code:

```c
typedef struct t_cb_data
{
    int reason;
    int (*cb_rtn) ();
    vpiHandle obj;
    p_vpi_time time;
    p_vpi_value value;
    int index;
    char *user_data;
} s_cb_data, *p_cb_data;
```","ef struct t_cb_data
{
    int reason;
    int (*cb_rtn) ();
    vpiHandle obj;
    p_vpi_time time;
    p_vpi_value value;
    int index;
    char *user_data;
} s_cb_data, *p_cb_data;
","""Structure definition for VPI callback data in Verilog simulations""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p206.jpg,True,"```verilog
module m(input logic go, done, clock, reset,
         logic [31:0] din, dout);
  default clocking @ (posedge clock); endclocking
  default disable iff reset;
  ...
  c_seqprotocol inst1(go, done, din, dout);
  c_seqprotocol inst2(go, done, din, dout, negedge clock);
  c_seqprotocol inst3(go, done, din, dout, edge clock);
endmodule : m
```

Additionally, there's a syntactical representation of a ""checker declaration"", but without any functional code:

```verilog
checker checker_name (checker_formal_arguments);
  ...
endchecker
```","
module m(input logic go, done, clock, reset,
         logic [31:0] din, dout);
  default clocking @ (posedge clock); endclocking
  default disable iff reset;
  ...
  c_seqprotocol inst1(go, done, din, dout);
  c_seqprotocol inst2(go, done, din, dout, negedge clock);
  c_seqprotocol inst3(go, done, din, dout, edge clock);
endmodule : m


checker checker_name (checker_formal_arguments);
  ...
endchecker
","Caption: ""Example of Verilog code showing the instantiation of a checker module with different clocking events.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p577.jpg,True,"```c
s_timescale_info ts_info;
handle module_h, tfinst_h;

/* obtain handle for a module instance */
/* obtain handle for a system task instance */

acc_fetch_timescale_info(module_h, &ts_info);
io_printf(""\nModule %s: units = %d precision = %d\n"",
          acc_fetch_fullname(module_h),
          ts_info.unit, ts_info.precision);

acc_fetch_timescale_info(tfinst_h, &ts_info);
io_printf(""\nSystem task: units = %d precision = %d\n"",
          ts_info.unit, ts_info.precision);

acc_fetch_timescale_info(null, &ts_info);
io_printf(""\ntimeformat units = %d precision = %d\n\n"",
          ts_info.unit, ts_info.precision);
```","escale_info ts_info;
handle module_h, tfinst_h;

/* obtain handle for a module instance */
/* obtain handle for a system task instance */

acc_fetch_timescale_info(module_h, &ts_info);
io_printf(""\nModule %s: units = %d precision = %d\n"",
          acc_fetch_fullname(module_h),
          ts_info.unit, ts_info.precision);

acc_fetch_timescale_info(tfinst_h, &ts_info);
io_printf(""\nSystem task: units = %d precision = %d\n"",
          ts_info.unit, ts_info.precision);

acc_fetch_timescale_info(null, &ts_info);
io_printf(""\ntimeformat units = %d precision = %d\n\n"",
          ts_info.unit, ts_info.precision);
","Caption: ""Excerpt from 'The Verilog PLI Handbook' showing the function 'acc_fetch_precision' and its usage in retrieving time scale information within Verilog simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p129.jpg,True,"```verilog
a_read1:
    assert property(p_read1)
    else if(glue_sva_severity) $fatal;

a_read0:
    assert property(p_read0)
    else if(glue_sva_severity) $fatal;

c_sel_1: cover property(p_sel_1);
c_sel_0: cover property(p_sel_0);
c_rsel1_write: cover property(p_rsel1_write);
c_rsel2_write: cover property(p_rsel2_write);
c_rsel3_write: cover property(p_rsel3_write);
c_read1: cover property(p_read1);
c_read0: cover property(p_read0);

end
end

endmodule
```","
a_read1:
    assert property(p_read1)
    else if(glue_sva_severity) $fatal;

a_read0:
    assert property(p_read0)
    else if(glue_sva_severity) $fatal;

c_sel_1: cover property(p_sel_1);
c_sel_0: cover property(p_sel_0);
c_rsel1_write: cover property(p_rsel1_write);
c_rsel2_write: cover property(p_rsel2_write);
c_rsel3_write: cover property(p_rsel3_write);
c_read1: cover property(p_read1);
c_read0: cover property(p_read0);

end
end

endmodule
","""Example of Verilog assertions and coverage properties in a hardware verification context.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p548.jpg,True,"Here is the Verilog code presented in the image:

1. Declaration of a random bit variable and an assumption:
```verilog
rand bit v;
bit a;
...
m1: assume final (v == a);
```

2. Declaration and usage of a property with a concurrent assertion:
```verilog
a1: assert property (@($global_clock v == a));
```

3. Declaration of a rigid variable:
```verilog
rand const bit [3:0] r;
```

4. Equivalent modeling of rigid variables with free variables:
```verilog
rand bit [3:0] r;
assume property (@($global_clock $steady_gclk(r)));
```

5. Example of rigid variable initialization:
```verilog
rand const bit [3:0] r = 4'd5;
```

These snippets present different concepts related to variables, assumptions, and properties in Verilog.","
rand bit v;
bit a;
...
m1: assume final (v == a);


a1: assert property (@($global_clock v == a));


rand const bit [3:0] r;


rand bit [3:0] r;
assume property (@($global_clock $steady_gclk(r)));


rand const bit [3:0] r = 4'd5;
","""Discussion and examples of free and rigid variables in Verilog for formal verification purposes.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p101.jpg,True,"The image contains a snippet of Verilog code demonstrating the ""expect"" construct. Here is the code as it appears in the image:

```verilog
initial
begin
  @(posedge clk);
  #2ns cpu_ready = 1'b1;
  expect (@(posedge clk) ##[1:16] memory_ready == 1'b1)
end
```

Please note that this is a code snippet, and it is intended for use in a larger Verilog module context; running it standalone would not be meaningful without the surrounding module and associated signals.","
initial
begin
  @(posedge clk);
  #2ns cpu_ready = 1'b1;
  expect (@(posedge clk) ##[1:16] memory_ready == 1'b1)
end
","""Explanation and example of SystemVerilog Assertions (SVA) using 'matched' and 'expect' constructs.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p35.jpg,True,"The image contains Verilog code. Here's the code from the image:

```verilog
// -------------------------------------------------------------------
// AndOr:  Combinational logic using & (and) and | (or).
// This module represents simple combinational logic including
// an AND and an OR expression.
//
// ANSI module header.
// -------------------------------------------------------------------
// 2004-11-25 jmw: v. 1.0 implemented.
// -------------------------------------------------------------------
module AndOr (output X, Y, input A, B, C);
//
assign #10 X = A & B;
assign #10 Y = B | C;
//
endmodule // AndOr.
```","
// -------------------------------------------------------------------
// AndOr:  Combinational logic using & (and) and | (or).
// This module represents simple combinational logic including
// an AND and an OR expression.
//
// ANSI module header.
// -------------------------------------------------------------------
// 2004-11-25 jmw: v. 1.0 implemented.
// -------------------------------------------------------------------
module AndOr (output X, Y, input A, B, C);
//
assign #10 X = A & B;
assign #10 Y = B | C;
//
endmodule // AndOr.
",Verilog module example illustrating continuous assignments and simple combinational logic with delays.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p28.jpg,True,"```
`ifdef ma
if(a & b)
$display
```"," ma
if(a & b)
$display
",An introductory page on SystemVerilog Assertions (SVA) with an example of a simple conditional assertion in Verilog code.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p294.jpg,True,"There is a small snippet of text that resembles code in the image:

```
#define p x>3
#property FG(p)
```

This seems to be an example of using preprocessor directives in a verification tool context (probably not Verilog itself), where `#define` is used to define a macro, and `#property` seems to be a special construct used by this tool (DIVINE) for specifying properties to verify. However, the context suggests that these are not actual Verilog code lines but rather related to the process of model checking within a GUI tool for verification.","e p x>3
#property FG(p)
",The image contains a page from an academic paper discussing the Graphical User Interface (GUI) interaction with the DiVinE tool for model checking. It includes text but no actual Verilog code.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p222.jpg,True,"The image contains two segments of Verilog code. Here they are:

The first segment from the image:
```verilog
initial begin
  Days days;
  days = new();

  days.choices = {Days::SUN, Days::SAT};
  `SV_RAND_CHECK(days.randomize());
  $display(""Random weekend day %s\n"", days.choice.name());

  days.choices = {Days::MON, Days::TUE, Days::WED,
                  Days::THU, Days::FRI};
  `SV_RAND_CHECK(days.randomize());
  $display(""Random week day %s"", days.choice.name());
end
```

The second segment from the image:
```verilog
class RandCInside;
  int array[];              // Values to choose
  randc bit [15:0] index;  // Index into array

  function new(input int a[]); // Construct & initialize
    array = a;
  endfunction

  function int pick();    // Return most recent pick
    return array[index];
  endfunction

  constraint c_size {index < array.size();}
endclass
```","
initial begin
  Days days;
  days = new();

  days.choices = {Days::SUN, Days::SAT};
  `SV_RAND_CHECK(days.randomize());
  $display(""Random weekend day %s\n"", days.choice.name());

  days.choices = {Days::MON, Days::TUE, Days::WED,
                  Days::THU, Days::FRI};
  `SV_RAND_CHECK(days.randomize());
  $display(""Random week day %s"", days.choice.name());
end


class RandCInside;
  int array[];              // Values to choose
  randc bit [15:0] index;  // Index into array

  function new(input int a[]); // Construct & initialize
    array = a;
  endfunction

  function int pick();    // Return most recent pick
    return array[index];
  endfunction

  constraint c_size {index < array.size();}
endclass
","""Verilog code samples showing randomization techniques for selecting from arrays and using enumerated types.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p236.jpg,True,"The image contains two snippets of Verilog code. Here they are:

```verilog
Sample 6.37 Constraint with a variable bound

class Packet;
    rand bit [31:0] length;
    bit [31:0] max_length = 100; // Configuration, not rand
    constraint c_length {
        length inside {[1:max_length]};
    }
endclass
```

```verilog
Sample 6.38 dist constraint with variable weights

typedef enum {READ8, READ16, READ32} read_e;
class ReadCommands;
    rand read_e cmd;
    int read8_wt=1, read16_wt=1, read32_wt=1;
    constraint c_read {
        read_cmd dist {READ8  := read8_wt,
                       READ16 := read16_wt,
                       READ32 := read32_wt};
    }
endclass
```

These samples show how to use variable bounds and weights in constraints to control the randomization of Verilog class properties.","
Sample 6.37 Constraint with a variable bound

class Packet;
    rand bit [31:0] length;
    bit [31:0] max_length = 100; // Configuration, not rand
    constraint c_length {
        length inside {[1:max_length]};
    }
endclass


Sample 6.38 dist constraint with variable weights

typedef enum {READ8, READ16, READ32} read_e;
class ReadCommands;
    rand read_e cmd;
    int read8_wt=1, read16_wt=1, read32_wt=1;
    constraint c_read {
        read_cmd dist {READ8  := read8_wt,
                       READ16 := read16_wt,
                       READ32 := read32_wt};
    }
endclass
","Caption: ""Verilog constraint examples demonstrating techniques for randomization with variable bounds and weights.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p198.jpg,True,"The image contains Verilog code as follows:

a) Bit references
```
c_ecc_out_1 ^= c_in [0] ^ c_in[1] 
             ^ c_in[2] ^ c_in[13]
             ^ c_in[14] ^ c_in[15]
             ^ c_in[16] ^ c_in[17]
             ^ c_in[18] ^ c_in[19]
             ^ c_in[20] ^ c_in[21]
             ^ c_in[22] ^ c_in[23]
             ^ c_in[24] ^ c_in[25]
             ^ c_in[26] ^ c_in[27]
             ^ c_in[28] ^ c_in[32]
             ^ c_in[35] ^ c_in[38]
             ^ c_in[39];
```

b) Parallel value operations
```
c_ecc_out_1 ^= (c_in & 40'h003fffff893);
```","out_1 ^= c_in [0] ^ c_in[1] 
             ^ c_in[2] ^ c_in[13]
             ^ c_in[14] ^ c_in[15]
             ^ c_in[16] ^ c_in[17]
             ^ c_in[18] ^ c_in[19]
             ^ c_in[20] ^ c_in[21]
             ^ c_in[22] ^ c_in[23]
             ^ c_in[24] ^ c_in[25]
             ^ c_in[26] ^ c_in[27]
             ^ c_in[28] ^ c_in[32]
             ^ c_in[35] ^ c_in[38]
             ^ c_in[39];

out_1 ^= (c_in & 40'h003fffff893);
",Optimizing RTL simulation performance in Verilog: bit vs. parallel value operations,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p448.jpg,True,"```verilog
always@(negedge SerClock, posedge Reset)
begin : Shift1
    // Respond to external reset:
    if (Reset==YES)
        FrameSR <= 'b0;
    else begin
        FrameSR <= FrameSR<<1;
        FrameSR[0] <= SerIn;
    end
end

localparam ParValidMinCnt = 8;  // Minimum number of SerClocks
                                // to hold ParValid asserted.
localparam ParValidTWidth = // Width of ParValidTimer reg.
    ( 2 > ParValidMinCnt ) ? 1
    : ((1<<2) > ParValidMinCnt ) ? 2
    : ((1<<3) > ParValidMinCnt ) ? 3
    : ((1<<4) > ParValidMinCnt ) ? 4
    : ((1<<5) > ParValidMinCnt ) ? 5
    : ((1<<6) > ParValidMinCnt ) ? 6
    : 7; // Thus, width is declared automatically.
// ...
reg [ParValidTWidth-1:0] ParValidTimer;
// ...
``` 

This code snippet is from a Verilog source code document and contains two distinct parts:

1. An always block that is triggered by either the falling edge of `SerClock` or the rising edge of `Reset`. Inside this block, the `FrameSR` register is either reset or shifted, and `SerIn` is assigned to the lowest bit of `FrameSR`.

2. Definitions of two local parameters, `ParValidMinCnt` and `ParValidTWidth`, and the declaration of the `ParValidTimer` register. `ParValidMinCnt` is set with a minimum count value, and `ParValidTWidth` is determined by a sequential test of bit widths to hold this minimum count. There are comments within the code that help clarify the purpose of these parameters.","
always@(negedge SerClock, posedge Reset)
begin : Shift1
    // Respond to external reset:
    if (Reset==YES)
        FrameSR <= 'b0;
    else begin
        FrameSR <= FrameSR<<1;
        FrameSR[0] <= SerIn;
    end
end

localparam ParValidMinCnt = 8;  // Minimum number of SerClocks
                                // to hold ParValid asserted.
localparam ParValidTWidth = // Width of ParValidTimer reg.
    ( 2 > ParValidMinCnt ) ? 1
    : ((1<<2) > ParValidMinCnt ) ? 2
    : ((1<<3) > ParValidMinCnt ) ? 3
    : ((1<<4) > ParValidMinCnt ) ? 4
    : ((1<<5) > ParValidMinCnt ) ? 5
    : ((1<<6) > ParValidMinCnt ) ? 6
    : 7; // Thus, width is declared automatically.
// ...
reg [ParValidTWidth-1:0] ParValidTimer;
// ...
","""Example of Verilog code demonstrating how to handle an external reset and adjust the assertion width of a signal in a digital system.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p173.jpg,True,"```verilog
c_x[23:16] = r_a;
c_x[15:8] = r_b;
c_x[7:0] = r_c;
```

```verilog
c_x = {r_a, r_b, r_c};
```

```verilog
cam_1 = s[30] | s[26] | s[22] | s[18] | s[14] | s[10] | s[6] | s[2];
```

```verilog
cam_1 = l & (8’b2’244444444);
```
The code snippets present Verilog concatenation and bitwise operations.","
c_x[23:16] = r_a;
c_x[15:8] = r_b;
c_x[7:0] = r_c;


c_x = {r_a, r_b, r_c};


cam_1 = s[30] | s[26] | s[22] | s[18] | s[14] | s[10] | s[6] | s[2];


cam_1 = l & (8’b2’244444444);
","Caption: ""Tips for efficient Verilog coding: using concatenation and parallel value operations for simulation performance.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p167.jpg,True,"The image contains Verilog code. Here are the code excerpts from the image:

```verilog
module chip0(
    chip timing inputs,
    chip function i/o's);
    tapper1 tapper(
        chip timing inputs
        core timing outputs);
    chip_core1 core(
        chip function i/o's);
endmodule // chip0

module chip_tapper1(
    chip timing inputs,
    core timing inputs);
    timing control procedures
endmodule // chip_tapper1

module chip_core1(
    core timing inputs,
    chip function i/o's);
    chip major module instances
endmodule // chip_core1
```

The code is part of a discussion on design hierarchy in Verilog.","
module chip0(
    chip timing inputs,
    chip function i/o's);
    tapper1 tapper(
        chip timing inputs
        core timing outputs);
    chip_core1 core(
        chip function i/o's);
endmodule // chip0

module chip_tapper1(
    chip timing inputs,
    core timing inputs);
    timing control procedures
endmodule // chip_tapper1

module chip_core1(
    core timing inputs,
    chip function i/o's);
    chip major module instances
endmodule // chip_core1
","Example of Verilog module hierarchy for chip design, with explanations on efficient design file management.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p312.jpg,True,"The image contains a Verilog code snippet defining a primitive UDP (User-Defined Primitive) for an `and`-`or` logic gate. Here is the code:

```verilog
primitive u2And1Or(output uZ, input uA1, uA2, uOr);
// Models uZ = (uA1 & uA2) | uOr.
//
table
// Output on right; inputs in declared order:
// and'ed inputs      or'ed input
// uA1 uA2            uOr        : uZ
    0    0             0         : 0;
    1    0             0         : 0;
    0    1             0         : 0;
    1    1             0         : 1;
    ?    ?             1         : 1;
endtable
endprimitive
```

This Verilog code describes the behavior of a simple combinational logic gate with two inputs that are `and`ed together, and a third input that is `or`ed with the result of the `and` operation. The truth table is specified within the `table` and `endtable` keywords to define the output for each combination of inputs.","
primitive u2And1Or(output uZ, input uA1, uA2, uOr);
// Models uZ = (uA1 & uA2) | uOr.
//
table
// Output on right; inputs in declared order:
// and'ed inputs      or'ed input
// uA1 uA2            uOr        : uZ
    0    0             0         : 0;
    1    0             0         : 0;
    0    1             0         : 0;
    1    1             0         : 1;
    ?    ?             1         : 1;
endtable
endprimitive
","The image contains an excerpt from a textbook or educational material explaining User-Defined Primitives (UDPs) in Verilog, including how Verilog code for a combinational UDP and example truth tables are formulated.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p588.jpg,True,"```verilog
acc_configure(accToHiZDelay, ""min"");
acc_configure(accToHiZDelay, ""max"");
acc_configure(accToHiZDelay, ""average"");
acc_configure(accToHiZDelay, ""from_user"");

acc_configure(accMinTypMaxDelays, ""false"");
```","
acc_configure(accToHiZDelay, ""min"");
acc_configure(accToHiZDelay, ""max"");
acc_configure(accToHiZDelay, ""average"");
acc_configure(accToHiZDelay, ""from_user"");

acc_configure(accMinTypMaxDelays, ""false"");
","""Excerpt from a technical document explaining how to configure ACC routines for reading and modifying delay values in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p460.jpg,True,"```verilog
assign FIFO_ReadReq = HalfParClk && !F_Empty && ParValid && !Reset;
```
This is the line of Verilog code found in the image.","
assign FIFO_ReadReq = HalfParClk && !F_Empty && ParValid && !Reset;
","Educational material displaying the block diagram of a ""SerEncoder"" module with a brief description of its internal functional blocks in Verilog.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p589.jpg,True,"```c
handle prim_h;
double add_rise, add_fall;
s_acc_value val_s;

acc_configure(accMinTypMaxDelays, ""false"");
acc_configure(accToHiZDelay, ""average"");
...
acc_append_delays(prim_h, add_rise, add_fall);
```

```c
acc_configure(accMinTypMaxDelays, ""true"");
```","e prim_h;
double add_rise, add_fall;
s_acc_value val_s;

acc_configure(accMinTypMaxDelays, ""false"");
acc_configure(accToHiZDelay, ""average"");
...
acc_append_delays(prim_h, add_rise, add_fall);

onfigure(accMinTypMaxDelays, ""true"");
","""Excerpt from The Verilog PLI Handbook detailing delay configurations for Verilog primitives and example code using acc_append_delays function.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p313.jpg,True,"```verilog
primitive uFF(output reg uQ, input uD, uClk, uRst);
//
initial uQ = 1'bx; // Not same as a module initial block.
//
table
// Output on right; inputs in declared order:
// uQ    uClk uRst current next
    0     (01)  0   :   ?  :   0 ; // Clock in 0
    1     (01)  0   :   ?  :   1 ; // Clock in 1
    0     (0?)  0   :   ?  :   0 ; // Default to keep same 0
    1     (0?)  0   :   ?  :   1 ; // Default to keep same 1
// Unclocked:
    ?     (1?)  0   :   ?  :   - ; // Ignore negedge.
    (??)   ?   0   :   ?  :   - ; // Retain state.
// Reset asserted:
    ?     (01)  1   :   ?  :   0 ; // Posedge reset
    ?     (??)  1   :   ?  :   0 ; // Ignore clock edge
    (??)   ?   1   :   ?  :   0 ; // Ignore clock state
    ?      ?   1   :   ?  :   0 ; // Ignore clock state
endtable
endprimitive
```","
primitive uFF(output reg uQ, input uD, uClk, uRst);
//
initial uQ = 1'bx; // Not same as a module initial block.
//
table
// Output on right; inputs in declared order:
// uQ    uClk uRst current next
    0     (01)  0   :   ?  :   0 ; // Clock in 0
    1     (01)  0   :   ?  :   1 ; // Clock in 1
    0     (0?)  0   :   ?  :   0 ; // Default to keep same 0
    1     (0?)  0   :   ?  :   1 ; // Default to keep same 1
// Unclocked:
    ?     (1?)  0   :   ?  :   - ; // Ignore negedge.
    (??)   ?   0   :   ?  :   - ; // Retain state.
// Reset asserted:
    ?     (01)  1   :   ?  :   0 ; // Posedge reset
    ?     (??)  1   :   ?  :   0 ; // Ignore clock edge
    (??)   ?   1   :   ?  :   0 ; // Ignore clock state
    ?      ?   1   :   ?  :   0 ; // Ignore clock state
endtable
endprimitive
","""Example of User-Defined Primitive (UDP) for a D flip-flop in Verilog""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p256.jpg,True,"The image contains pseudo-code for an algorithm, not actual Verilog code. Here is the pseudo-code provided in the image:

```
// Step 1: Identify quotient state space, i.e. all representative states
1. repr := reach
2. for (i := 1..N – 1)
3.     sorted_i := VARIABLESLessthanEquals(y_i, y_{i+1}) ^ reach
4.     repr := repr ^ sorted_i

// Step 2: Remove rows corresponding to non-representative states
5. trans := APPLY(x, trans, SWAPVARIABLES(repr, y, x))

// Step 3: Construct matrix for quotient model via bubble sort
6. for (i := N, ..., 2)
7.     trans_prev := trans
8.     for (j := 1, ..., i-1)
9.         good := APPLY(x, trans, sorted_j)
10.        bad := APPLY(x, trans, ¬sorted_j)
11.        fixed := SWAPVARIABLES(bad, y_j, y_{j+1})
12.        trans := APPLY(+, good, fixed)
13.    if (trans = trans_prev) return trans
14. return trans
```

Figure 2. MTBDD-based algorithm for computing the quotient model

This pseudo-code describes steps for an MTBDD-based algorithm used for computing a quotient model, which is likely related to model checking or formal verification techniques. The text explains the purpose of each step and the functions used in the algorithm. MTBDD refers to Multi-Terminal Binary Decision Diagrams, a data structure commonly used in formal methods.
","p 1: Identify quotient state space, i.e. all representative states
1. repr := reach
2. for (i := 1..N – 1)
3.     sorted_i := VARIABLESLessthanEquals(y_i, y_{i+1}) ^ reach
4.     repr := repr ^ sorted_i

// Step 2: Remove rows corresponding to non-representative states
5. trans := APPLY(x, trans, SWAPVARIABLES(repr, y, x))

// Step 3: Construct matrix for quotient model via bubble sort
6. for (i := N, ..., 2)
7.     trans_prev := trans
8.     for (j := 1, ..., i-1)
9.         good := APPLY(x, trans, sorted_j)
10.        bad := APPLY(x, trans, ¬sorted_j)
11.        fixed := SWAPVARIABLES(bad, y_j, y_{j+1})
12.        trans := APPLY(+, good, fixed)
13.    if (trans = trans_prev) return trans
14. return trans
","Pseudo-code for a BDD-based algorithm to compute quotient models, as part of a research paper on formal verification in the context of model checking.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p166.jpg,True,"The image contains snippets of both textual information and code. There's a piece of what appears to be Verilog code, which is a hardware description language used to model electronic systems. Additionally, there is a command line example that includes a model command and a define flag for Verilog compiler options. Here are the code-related portions from the image:

```verilog
`ifdef RTL
    ...
`else
    gate-level version of logic
`endif
```

The above is showing conditional compilation in Verilog, where if `RTL` is defined, some code which is not visible in the image (`...`) will be used, otherwise the text ""gate-level version of logic"" is a placeholder comment for actual code that would be used if `RTL` is not defined.

And the command line options:

```
-model1 a.v -model2 -define+RTL a.v
```

This command line illustrates how to set models and define flags with a Verilog compiler. In this case, `a.v` is the Verilog file being compiled, `-model1` and `-model2` are probably options for different simulation models or configurations, and `-define+RTL` is setting a preprocessor define flag to presumably conditionally compile RTL code within `a.v`.","
`ifdef RTL
    ...
`else
    gate-level version of logic
`endif

1 a.v -model2 -define+RTL a.v
","""Understanding conditional compilation and command-line options in Verilog source code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p449.jpg,True,"```verilog
always@(negedge SerClock, posedge Reset)
begin : Unload32
    if (Reset==YES)
    begin
        ParValid <= NO; // Lower the flag.
        ParOutr <= 'b0; // Zero the output.
        ParValidTimer <= 'b0;
    end
    else begin
        if (Unload==YES)
        begin
            ParOutr <= Decoder; // Move the data.
            ParValid <= YES; // Set the flag.
            ParValidTimer <= 'b0;
        end
        else begin
            if (ParValidTimer<ParValidMinCnt)
                ParValidTimer <= ParValidTimer + 1;
            if (ParValidTimer==ParValidMinCnt && ParClk==1'b0)
                ParValid <= NO; // Terminates assertion.
        end
    end // UnloadParData.
end
```","
always@(negedge SerClock, posedge Reset)
begin : Unload32
    if (Reset==YES)
    begin
        ParValid <= NO; // Lower the flag.
        ParOutr <= 'b0; // Zero the output.
        ParValidTimer <= 'b0;
    end
    else begin
        if (Unload==YES)
        begin
            ParOutr <= Decoder; // Move the data.
            ParValid <= YES; // Set the flag.
            ParValidTimer <= 'b0;
        end
        else begin
            if (ParValidTimer<ParValidMinCnt)
                ParValidTimer <= ParValidTimer + 1;
            if (ParValidTimer==ParValidMinCnt && ParClk==1'b0)
                ParValid <= NO; // Terminates assertion.
        end
    end // UnloadParData.
end
","""Example of Verilog code block for the Unload32 process with a description of its modification and an excerpt discussing synthesizing and simulating a Deserializer in a digital VLSI design text.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p172.jpg,True,"The image contains Verilog code. Here is the code as it appears in the image:

```verilog
if (((tr_tm_hdr_len == 2'h1) && (tr_tm_data_len == 4'h0)) ||
    ((tr_tm_hdr_len == 2'h0) && (tr_tm_data_len == 4'h1)))
    ...

if (cs_res_ready && (req_last || (c_req_ready))) begin
    ...
```

Please note that the code snippets provided in the image are incomplete (indicated by the ellipses `...`).","
if (((tr_tm_hdr_len == 2'h1) && (tr_tm_data_len == 4'h0)) ||
    ((tr_tm_hdr_len == 2'h0) && (tr_tm_data_len == 4'h1)))
    ...

if (cs_res_ready && (req_last || (c_req_ready))) begin
    ...
","""Guidelines and Best Practices for Writing Verilog Code: Logical Operators and Code Observability""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p199.jpg,True,"The image contains Verilog code. Here's the code presented in the image:

```verilog
module fifo(
...
parameter WIDTH = 13;
parameter DEPTH = 32;
parameter ENCODE = 0;
...
function [31:0] encoder;
input [WIDTH-1:0] indata;
begin
  if (ENCODE !=0) begin
    // calculate encode value based on indata >
  end
  else
    encoder = indata;
end
endfunction // encoder
...
```

The code snippet is part of a Verilog HDL module definition for a FIFO (First-In-First-Out) queue with some parameters and a function defined inside it. The ellipsis (...) implies that there is additional code or content not shown in this excerpt.","
module fifo(
...
parameter WIDTH = 13;
parameter DEPTH = 32;
parameter ENCODE = 0;
...
function [31:0] encoder;
input [WIDTH-1:0] indata;
begin
  if (ENCODE !=0) begin
    // calculate encode value based on indata >
  end
  else
    encoder = indata;
end
endfunction // encoder
...
","""Exploring parameterized configurations in Verilog with FIFO example code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p237.jpg,True,"Here is the Verilog code from the image:

```verilog
// Packet with variable length payload
class Packet;
  rand bit [7:0] length, payload[];
  constraint c_valid {length > 0;
                     payload.size() == length;}

  function void display(input string msg);
    $display(""\n%s:"", msg);
    $write(""\nPacket len=%0d, bytes = "", length);
    for(int i=0; (i<4 && i<payload.size()); i++)
      $write("" %0d"", payload[i]);
    $display;
  endfunction
endclass

Packet p;
initial begin
  p = new();
  `SV_RAND_CHECK(p.randomize()) // Randomize all variables
  p.display(""Simple randomize"");

  p.length.rand_mode(0);         // Make length nonrandom,
  p.length = 42;                 // set it to a constant value
  `SV_RAND_CHECK(p.randomize()) // then randomize the payload
  p.display(""Randomize with rand_mode()"");
end
```

This code is an example that illustrates how to use `rand_mode` to disable randomization for a specific class property, allowing for the control of non-random values in constrained random verification environments.","
// Packet with variable length payload
class Packet;
  rand bit [7:0] length, payload[];
  constraint c_valid {length > 0;
                     payload.size() == length;}

  function void display(input string msg);
    $display(""\n%s:"", msg);
    $write(""\nPacket len=%0d, bytes = "", length);
    for(int i=0; (i<4 && i<payload.size()); i++)
      $write("" %0d"", payload[i]);
    $display;
  endfunction
endclass

Packet p;
initial begin
  p = new();
  `SV_RAND_CHECK(p.randomize()) // Randomize all variables
  p.display(""Simple randomize"");

  p.length.rand_mode(0);         // Make length nonrandom,
  p.length = 42;                 // set it to a constant value
  `SV_RAND_CHECK(p.randomize()) // then randomize the payload
  p.display(""Randomize with rand_mode()"");
end
","""Example of Verilog code demonstrating how to use nonrandom values with constraints and the `rand_mode()` function""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p29.jpg,True,"```verilog
`ifdef ASSERT
    $display(""\nError:Mutually asserted check failed\n"");
`endif
```

```verilog
// Sample Verilog checker

always @(posedge a)
begin
```
The image contains snippets of Verilog code as described above.","
`ifdef ASSERT
    $display(""\nError:Mutually asserted check failed\n"");
`endif


// Sample Verilog checker

always @(posedge a)
begin
","This image is a page from a document discussing the motivation behind using SystemVerilog Assertions (SVA), as well as showing a code snippet from a Verilog hardware description language demonstrating a sample assertion checker.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p34.jpg,True,"The image contains Verilog code. Here is the code from the image:

```verilog
// ============================================================
// TestBench:  Simulation driver module (stimulus block)
// for the top-level block instance of Intro_Top.
//
// This module includes an initial block which assigns various
// values to top-level inputs for simulation.  initial blocks
// are ignored in logic synthesis.
//
// No module port declaration.
// ------------------------------------------------------------
// 2004-11-25 jmw: v. 1.0 implemented.
// ============================================================
//
`timescale 1 ns/100ps  // No semicolon after `anything.
module TestBench;       // Stimulus blocks have no port.
//
wire Xwatch, Ywatch, Zwatch;    // To connect to design instance.
reg  AStim, BStim, CStim, DStim; // To accept initialization.
//
initial
begin
  //
  // Each '#' precedes a delay time increment, here in 1 ns units:
  #
  #1 AStim = 1'b0;  // For AStim, 1 bit, representing a binary 0.
  #1 BStim = 1'b0;  // This occurs at time 1 + 1 = 2.
  #1 CStim = 1'b0;
  (other stimuli omitted here)
  #50 DStim = 1'b1;
  #50 AStim = 1'b0;
  #50 BStim = 1'b0;
  #50 CStim = 1'b0;
  #50 DStim = 1'b0;
  #50 $finish;  // Terminates simulation 50 ns after the last stimulus.
  // No semicolon after end.
end
// The instance of the design is named Topper01, and its
// ports are associated by name with stimulus input and simulation
// output wires:
//
Intro_Top Topper01 ( .X(Xwatch), .Y(Ywatch), .Z(Zwatch)
                    , .A(AStim), .B(BStim), .C(CStim), .D(DStim)
                    );
//
endmodule // TestBench.
```

The image's text also points out a note about the use of two different keyboard characters which may appear very similar:
- The `timescale` specifier uses a backquote `.
- The width specifier for literal constants uses a single-quote '.","
// ============================================================
// TestBench:  Simulation driver module (stimulus block)
// for the top-level block instance of Intro_Top.
//
// This module includes an initial block which assigns various
// values to top-level inputs for simulation.  initial blocks
// are ignored in logic synthesis.
//
// No module port declaration.
// ------------------------------------------------------------
// 2004-11-25 jmw: v. 1.0 implemented.
// ============================================================
//
`timescale 1 ns/100ps  // No semicolon after `anything.
module TestBench;       // Stimulus blocks have no port.
//
wire Xwatch, Ywatch, Zwatch;    // To connect to design instance.
reg  AStim, BStim, CStim, DStim; // To accept initialization.
//
initial
begin
  //
  // Each '#' precedes a delay time increment, here in 1 ns units:
  #
  #1 AStim = 1'b0;  // For AStim, 1 bit, representing a binary 0.
  #1 BStim = 1'b0;  // This occurs at time 1 + 1 = 2.
  #1 CStim = 1'b0;
  (other stimuli omitted here)
  #50 DStim = 1'b1;
  #50 AStim = 1'b0;
  #50 BStim = 1'b0;
  #50 CStim = 1'b0;
  #50 DStim = 1'b0;
  #50 $finish;  // Terminates simulation 50 ns after the last stimulus.
  // No semicolon after end.
end
// The instance of the design is named Topper01, and its
// ports are associated by name with stimulus input and simulation
// output wires:
//
Intro_Top Topper01 ( .X(Xwatch), .Y(Ywatch), .Z(Zwatch)
                    , .A(AStim), .B(BStim), .C(CStim), .D(DStim)
                    );
//
endmodule // TestBench.
",Verilog Testbench Example with Explanation of Timescale and Width Specifier Characters,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p100.jpg,True,"The image contains Verilog code in the form of SystemVerilog assertions (SVA). Here's the code it contains:

```verilog
property p_multiple_clocks_implied_illegal;
    @(posedge clk1) s1 |-> @(posedge clk2) s2;
endproperty
```

It also includes the following code for the matched construct:

```verilog
sequence s_a;
    @(posedge clk1) $rose(a);
endsequence

sequence s_b;
    @(posedge clk2) $rose(b);
endsequence

property p_match;
    @(posedge clk2) s_a.matched |=> s_b;
endproperty

a_match: assert property(p_match);
```

These segments of code are used to define properties and sequences in SystemVerilog to specify the behavior of digital circuits in terms of timing and logical operations, particularly for use in validation and functional verification.","
property p_multiple_clocks_implied_illegal;
    @(posedge clk1) s1 |-> @(posedge clk2) s2;
endproperty


sequence s_a;
    @(posedge clk1) $rose(a);
endsequence

sequence s_b;
    @(posedge clk2) $rose(b);
endsequence

property p_match;
    @(posedge clk2) s_a.matched |=> s_b;
endproperty

a_match: assert property(p_match);
","Caption: ""Verilog code example demonstrating the use of the `matched` construct in SystemVerilog Assertions (SVA) to verify sequences across multiple clocks.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p549.jpg,True,"The image contains Verilog code. Here is the code from the image:

```verilog
const bit [3:0] r = 4'd5;
```

```verilog
checker same1(bit [127:0] word1, word2,
  event clk = $inferred_clock);
  a1: assert property (@clk word1 == word2);
endchecker : same1
```

```verilog
checker same2(bit [127:0] word1, word2,
  event clk = $inferred_clock);
  rand const bit [6:0] i;
  a2: assert property (@clk word1[i] == word2[i]);
endchecker : same2
```

```verilog
checker data_consistency1(start_t, end_t, in_data, out_data,
  default clocking @clk; untyped rst = $inferred_disable);
  default disable iff rst;
  rand const var type(in_data) data;

  a1: assert property (start_t && data == in_data ##1 end_t[-1]
    |-> out_data == data);
endchecker : data_consistency1
```

```verilog
a10: assert property (start_t && 2'b00 == in_data ##1 end_t[-1]
    |-> out_data == 2'b00);
a11: assert property (start_t && 2'b01 == in_data ##1 end_t[-1]
    |-> out_data == 2'b01);
```","
const bit [3:0] r = 4'd5;


checker same1(bit [127:0] word1, word2,
  event clk = $inferred_clock);
  a1: assert property (@clk word1 == word2);
endchecker : same1


checker same2(bit [127:0] word1, word2,
  event clk = $inferred_clock);
  rand const bit [6:0] i;
  a2: assert property (@clk word1[i] == word2[i]);
endchecker : same2


checker data_consistency1(start_t, end_t, in_data, out_data,
  default clocking @clk; untyped rst = $inferred_disable);
  default disable iff rst;
  rand const var type(in_data) data;

  a1: assert property (start_t && data == in_data ##1 end_t[-1]
    |-> out_data == data);
endchecker : data_consistency1


a10: assert property (start_t && 2'b00 == in_data ##1 end_t[-1]
    |-> out_data == 2'b00);
a11: assert property (start_t && 2'b01 == in_data ##1 end_t[-1]
    |-> out_data == 2'b01);
","""Examples of Verilog checkers for data consistency and efficiency in verifying large data words.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p238.jpg,True,"The image contains a snippet of code from a section about the Verilog Programming Language Interface (PLI). Here is the code from the image:

```c
/**********************************************************************/
/* End-Of-Simulation callback -- close file and exit simulation.      */
/**********************************************************************/
int PLIbook_ReadOnlyEnd(p_cb_data cb_data_p)
{
    vpi_printf(""read_stimulus_?? reached End-Of-File.\n"");
    fclose((FILE *) cb_data_p->user_data);
    tf_dofinish();
    return(0);
}
```

This code defines a function that is supposed to be called at the end of a simulation. It prints a message to the console, closes a file (presumably one that was open to read simulation stimulus), and then calls `tf_dofinish()` to terminate the simulation. The function returns an integer, which in this case is `0`.","******************************************************************/
/* End-Of-Simulation callback -- close file and exit simulation.      */
/**********************************************************************/
int PLIbook_ReadOnlyEnd(p_cb_data cb_data_p)
{
    vpi_printf(""read_stimulus_?? reached End-Of-File.\n"");
    fclose((FILE *) cb_data_p->user_data);
    tf_dofinish();
    return(0);
}
","""Excerpt from The Verilog PLI Handbook showing an End-Of-Simulation callback function and a table of VPI simulation event callback constants.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p223.jpg,True,"The image contains Verilog code. Here it is:

```verilog
initial begin
  RandCInside ri;

  ri = new('{1,3,5,7,9,11,13});
  repeat (ri.array.size()) begin
    `SV_RAND_CHECK(ri.randomize());
    $display(""Picked %2d [%0d]"", ri.pick(), ri.index);
  end
end
```

```verilog
class Bidiir;
  rand bit [15:0] r, s, t;
  constraint c_bidiir { // All are solved in parallel
    r < t;             // A value for r affects s, t
    s == r;
    t < 10;
    s > 5;
  }
endclass
```","
initial begin
  RandCInside ri;

  ri = new('{1,3,5,7,9,11,13});
  repeat (ri.array.size()) begin
    `SV_RAND_CHECK(ri.randomize());
    $display(""Picked %2d [%0d]"", ri.pick(), ri.index);
  end
end


class Bidiir;
  rand bit [15:0] r, s, t;
  constraint c_bidiir { // All are solved in parallel
    r < t;             // A value for r affects s, t
    s == r;
    t < 10;
    s > 5;
  }
endclass
","""Example of SystemVerilog code demonstrating randomization and bidirectional constraints used in testbench design""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p207.jpg,True,"The image contains Verilog code in two examples. Here are the codes provided:

Example 9.1:
```verilog
checker request_granted(req, gnt, clk, rst);
  a1: assert property(@(clk) disable iff (rst) req |=> gnt);
endchecker : request_granted
```

Example 9.3:
```verilog
checker check(a, b, output logic c, d,
              input event clk, untyped rst);
```

These snippets are part of a textbook or educational material explaining how to declare Verilog checkers and define their formal arguments.","
checker request_granted(req, gnt, clk, rst);
  a1: assert property(@(clk) disable iff (rst) req |=> gnt);
endchecker : request_granted


checker check(a, b, output logic c, d,
              input event clk, untyped rst);
","""Explaining Verilog Checker Declaration and Argument Direction with Examples""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p210.jpg,True,"The image contains code snippets related to Verilog's Programming Language Interface (PLI). Here's the code presented in the image:

```c
vector_file = vector_data->file_ptr;
tfgarg2_h = vector_data->obj_h;

/* read next line from the file and apply vector to simulation */

return(0);
```

And further down in the text, you can see a function prototype:

```c
vpiHandle vpi_register_cb(data)
p_cb_data data           /* pointer to an application allocated s_cb_data structure
                            containing callback information. */
```

Additionally, the text outlines the steps to register a callback:

1. Allocate an `s_cb_data` structure.
2. Fill in the fields of the structure.
3. Call `vpi_register_cb()` with a pointer to the structure as an input.

The `s_cb_data` structure itself is mentioned but not shown in the image. It is defined in `vpi_user.h`. The actual definition of `s_cb_data` is not visible in the provided image.","r_file = vector_data->file_ptr;
tfgarg2_h = vector_data->obj_h;

/* read next line from the file and apply vector to simulation */

return(0);

ndle vpi_register_cb(data)
p_cb_data data           /* pointer to an application allocated s_cb_data structure
                            containing callback information. */
","""Excerpt from The Verilog PLI Handbook detailing the registration of simulation callback routines in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p128.jpg,True,"The image contains a snippet of Verilog code which is related to SVA (SystemVerilog Assertions) checks. Here's the code as it appears in the image:

```verilog
module glue(....);

// port declarations

parameter glue_sva = 1'b1;
parameter glue_sva_severity = 1'b1;

// glue design description
// glue SVA property description

// SVA Checks

always@(posedge clk)
begin
    if(glue_sva)
    begin
        a_sel_1:
            assert property(p_sel_1)
            else if(glue_sva_severity) $fatal;

        a_sel_0:
            assert property(p_sel_0)
            else if(glue_sva_severity) $fatal;

        a_rsel1_write:
            assert property(p_rsel1_write)
            else if(glue_sva_severity) $fatal;

        a_rsel2_write:
            assert property(p_rsel2_write)
            else if(glue_sva_severity) $fatal;

        a_rsel3_write:
            assert property(p_rsel3_write)
            else if(glue_sva_severity) $fatal;
```

Note that the code snippet might not be complete, as it looks like the page could be cut off at the bottom.","
module glue(....);

// port declarations

parameter glue_sva = 1'b1;
parameter glue_sva_severity = 1'b1;

// glue design description
// glue SVA property description

// SVA Checks

always@(posedge clk)
begin
    if(glue_sva)
    begin
        a_sel_1:
            assert property(p_sel_1)
            else if(glue_sva_severity) $fatal;

        a_sel_0:
            assert property(p_sel_0)
            else if(glue_sva_severity) $fatal;

        a_rsel1_write:
            assert property(p_rsel1_write)
            else if(glue_sva_severity) $fatal;

        a_rsel2_write:
            assert property(p_rsel2_write)
            else if(glue_sva_severity) $fatal;

        a_rsel3_write:
            assert property(p_rsel3_write)
            else if(glue_sva_severity) $fatal;
","Caption: ""Example of SystemVerilog Assertions (SVAs) for checking glue logic in simulation, with parameters to control assertion activation and severity levels.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p561.jpg,True,"The image contains Verilog code which is part of the module interface for a `module` named `ovl_handshake`. Here is the code:

```verilog
// Accellera Standard v2.8.1 Open Verification Library (OVL).
// All rights reserved
// Accellera Copyright (c) 2005-2014. All rights reserved.
`module ovl_handshake (
  clock, reset, enable, req, ack, fire);
parameter severity_level = `OVL_SEVERITY_DEFAULT;
parameter min_ack_cycle = 0;
parameter max_ack_cycle = 0;
parameter deassert_count = 0;
parameter max_ack_length = 0;
parameter drop = 0;
parameter property_type = `OVL_PROPERTY_DEFAULT;
parameter msg = `OVL_MSG_DEFAULT;
parameter coverage_level = `OVL_COVER_DEFAULT;
parameter clock_edge = `OVL_CLOCK_EDGE_DEFAULT;
parameter reset_polarity = `OVL_RESET_POLARITY_DEFAULT;
parameter gating_type = `OVL_GATING_TYPE_DEFAULT;
```

Note that the parameters are showing default values which are presumably macros defined elsewhere in the code or library. The backticks (`) in the parameter definitions suggest that these are predefined macros in OVL (Open Verification Library). Keep in mind that the source code may include additional content beyond what is shown here.","
// Accellera Standard v2.8.1 Open Verification Library (OVL).
// All rights reserved
// Accellera Copyright (c) 2005-2014. All rights reserved.
`module ovl_handshake (
  clock, reset, enable, req, ack, fire);
parameter severity_level = `OVL_SEVERITY_DEFAULT;
parameter min_ack_cycle = 0;
parameter max_ack_cycle = 0;
parameter deassert_count = 0;
parameter max_ack_length = 0;
parameter drop = 0;
parameter property_type = `OVL_PROPERTY_DEFAULT;
parameter msg = `OVL_MSG_DEFAULT;
parameter coverage_level = `OVL_COVER_DEFAULT;
parameter clock_edge = `OVL_CLOCK_EDGE_DEFAULT;
parameter reset_polarity = `OVL_RESET_POLARITY_DEFAULT;
parameter gating_type = `OVL_GATING_TYPE_DEFAULT;
",The image presents a section from a document discussing checker libraries in SystemVerilog Assertion (SVA) and highlights advantages of SVA for checker library development. It also includes an example Verilog code snippet for a module-based assert_handshake checker interface from the Open Verification Library (OVL).,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p213.jpg,True,"The image includes two pieces of code written in Verilog.

The first block of code is:

```verilog
checker request_granted(sequence req, property gnt,
  untyped n = 1, string msg = """",
  event clk = $inferred_clock,
  untyped rst = $inferred_disable, truncate = $);
  default clocking clk; endclocking
  default disable iff rst;
  if ($isunbounded(truncate))
    sequence ante; req; endsequence : ante
  else if (truncate < 1)
    $error(""truncate value should be positive"");
  else
    sequence ante;
      req intersect 1[*1:truncate];
    endsequence : ante
    a1:assert property(ante |-> nexttime[n] gnt) else $error(msg);
endchecker : request_granted
```

The second block of code is:

```verilog
checker simple_reset(rst) ;
  initial
    a1: assert property (@$global_clock rst[+] ##1 always !rst) ;
endchecker : simple_reset
```","
checker request_granted(sequence req, property gnt,
  untyped n = 1, string msg = """",
  event clk = $inferred_clock,
  untyped rst = $inferred_disable, truncate = $);
  default clocking clk; endclocking
  default disable iff rst;
  if ($isunbounded(truncate))
    sequence ante; req; endsequence : ante
  else if (truncate < 1)
    $error(""truncate value should be positive"");
  else
    sequence ante;
      req intersect 1[*1:truncate];
    endsequence : ante
    a1:assert property(ante |-> nexttime[n] gnt) else $error(msg);
endchecker : request_granted


checker simple_reset(rst) ;
  initial
    a1: assert property (@$global_clock rst[+] ##1 always !rst) ;
endchecker : simple_reset
","Caption: ""Excerpt from a technical document showing an example of a Verilog checker block with optional antecedent truncation.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p237.jpg,True,"```verilog
parameter N=FIFO_depth;

property legal_ptr(ptr);
    @(posedge clk) ($countones(ptr)==1);
endproperty

property good_ptr_update (ptr);
    @(posedge clk)
        ptr inside {0,                               // reset
                    $past(ptr),                      // stay same
                    $past({ptr[N-2:0], ptr[N-1]}) }; // rotate
endproperty

assert property (legal_ptr(wrptr));
assert property (legal_ptr(rdptr));
assert property (good_ptr_update(wrptr));
assert property (good_ptr_update(rdptr));
```","
parameter N=FIFO_depth;

property legal_ptr(ptr);
    @(posedge clk) ($countones(ptr)==1);
endproperty

property good_ptr_update (ptr);
    @(posedge clk)
        ptr inside {0,                               // reset
                    $past(ptr),                      // stay same
                    $past({ptr[N-2:0], ptr[N-1]}) }; // rotate
endproperty

assert property (legal_ptr(wrptr));
assert property (legal_ptr(rdptr));
assert property (good_ptr_update(wrptr));
assert property (good_ptr_update(rdptr));
","""SystemVerilog code for validating pointer behavior and ensuring FIFO functional coverage""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p213.jpg,True,"The image contains a snippet of Verilog code which illustrates how to use the `timeunit` and `timeprecision` enhancements in SystemVerilog. Here is the code:

```verilog
module B (...);
  timeunit 1ns;
  timeprecision 1ps;

  #5.5 ... // delay represents 5.5 nanoseconds
  #1ms ... // delay represents 1 millisecond
endmodule
```

This example code defines a module `B` with a specified `timeunit` of 1 nanosecond and `timeprecision` of 1 picosecond. Delays within the module are then defined with specific values and comments explaining the duration they represent based on the declared time units.","
module B (...);
  timeunit 1ns;
  timeprecision 1ps;

  #5.5 ... // delay represents 5.5 nanoseconds
  #1ms ... // delay represents 1 millisecond
endmodule
",Explanation of `timescale` directive in Verilog and enhancements in SystemVerilog to avoid tool compatibility issues.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p111.jpg,True,"The image contains a snippet of Verilog code, which is a hardware description language used to model electronic systems. Here is the text from the image:

```verilog
module SmoothComparator
  (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
reg[1:0] AdjFr;
assign AdjustFreq = AdjFr;
//
reg[2:0] HiCount;   // Counts PLL highs per ClockIn.
reg[1:0] EdgeCode;  // Locally encodes edge decision.
reg[3:0] AvgEdge;   // Decision variable.
reg[2:0] Done;      // Decision trigger variable.
//
always@(ClockIn, Reset)
  begin : CheckEdges
    if (Reset=='b1)
	begin
	  EdgeCode = 2'b01; // The value of EdgeCode will be used to
	  HiCount  = 'b0;   // increment or decrement AvgEdge.
	end
    else if (PLLClock=='b1) // Should be 1 of these per ClockIn cycle.
	HiCount = Hicount + 3'b1;
    else begin  // Check to see how many PLL 1's we caught:
	  case (HiCount)
	    3'b000: EdgeCode = 2'b00; // PLL too slow.
	    3'b001: EdgeCode = 2'b01; // Seems matched.
	    default: EdgeCode = 2'b11; // PLL too fast.
	  endcase
	  HiCount = 'b0; // Initialize for next ClockIn edge.
	end
  end // CheckEdges.
// (Second part is continued below)
```

This code appears to be part of a module named `SmoothComparator`, with the purpose of comparing signals from a Phase-Locked Loop (PLL) with a reference clock, `ClockIn`. The code as shown is incomplete and indicates that the second part of the code is continued below, which is not visible in the current image.","
module SmoothComparator
  (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
reg[1:0] AdjFr;
assign AdjustFreq = AdjFr;
//
reg[2:0] HiCount;   // Counts PLL highs per ClockIn.
reg[1:0] EdgeCode;  // Locally encodes edge decision.
reg[3:0] AvgEdge;   // Decision variable.
reg[2:0] Done;      // Decision trigger variable.
//
always@(ClockIn, Reset)
  begin : CheckEdges
    if (Reset=='b1)
	begin
	  EdgeCode = 2'b01; // The value of EdgeCode will be used to
	  HiCount  = 'b0;   // increment or decrement AvgEdge.
	end
    else if (PLLClock=='b1) // Should be 1 of these per ClockIn cycle.
	HiCount = Hicount + 3'b1;
    else begin  // Check to see how many PLL 1's we caught:
	  case (HiCount)
	    3'b000: EdgeCode = 2'b00; // PLL too slow.
	    3'b001: EdgeCode = 2'b01; // Seems matched.
	    default: EdgeCode = 2'b11; // PLL too fast.
	  endcase
	  HiCount = 'b0; // Initialize for next ClockIn edge.
	end
  end // CheckEdges.
// (Second part is continued below)
",Verilog module for a smooth comparator with edge detection logic and PLL synchronization.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p223.jpg,True,"The image contains two pieces of Verilog code, which are examples of SystemVerilog assertions within the context of a discussion on intra-interface assertions.

Example 6-46:
```verilog
// X detection pattern
assert property (@(posedge clk) disable iff (rst_n)
    (!$isunknown(SMQueNew) | !$isunknown(SMQueAddr, SMQueSpec, SMQueWrEn, SlvWrData)))
    else $error(""Unknown signal value when asserting a new request."");
```

Example 6-47:
```verilog
// invalid signal combination pattern
assert property (@(posedge clk) disable iff (rst_n)
    not (SMQueNew & SMQueWrEn & SMQueSpec))
    else $error(""Received illegal request for speculative (SMQueSpec) write."");
```

These code examples illustrate the use of assertions in detecting unexpected signal states or conditions within a digital design specified in SystemVerilog, which is a hardware description and verification language.","
// X detection pattern
assert property (@(posedge clk) disable iff (rst_n)
    (!$isunknown(SMQueNew) | !$isunknown(SMQueAddr, SMQueSpec, SMQueWrEn, SlvWrData)))
    else $error(""Unknown signal value when asserting a new request."");


// invalid signal combination pattern
assert property (@(posedge clk) disable iff (rst_n)
    not (SMQueNew & SMQueWrEn & SMQueSpec))
    else $error(""Received illegal request for speculative (SMQueSpec) write."");
","Caption: ""Examples of SystemVerilog assertions for verifying new request interface in digital design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p265.jpg,True,"The image contains several snippets of Verilog code. Here they are:

```verilog
property q1;
   $rose(a) |-> ##[1:5] b;
endproperty

property q2;
   @(posedge clk) q1;
endproperty

property q5;
   @(negedge clk) b[*3] |=> !b;
endproperty
```

```verilog
always @(negedge clk) begin
   a1: assert property ($fell(c) |=> q1); // LEGAL: contextually inferred leading clocking
   // event, @(negedge clk)
   a3: assert property ($fell(c) |=> q2); // ILLEGAL: multi-clocked property with contextually
   // inferred leading clocking event
   a4: assert property (q5); // LEGAL: contextually inferred leading clocking event, @(negedge clk)
end
```

```verilog
always @(clk) begin
   a = b + c;
   a1: assert property (z |=> d | e); //ILLEGAL
   .....
end
```

The text in the image provides important information and context that pertains to legality of assertions in Verilog, particularly relating to edge operators and clocking. It explains that certain types of assertions without edge operators are illegal because their clocks cannot be inferred.","
property q1;
   $rose(a) |-> ##[1:5] b;
endproperty

property q2;
   @(posedge clk) q1;
endproperty

property q5;
   @(negedge clk) b[*3] |=> !b;
endproperty


always @(negedge clk) begin
   a1: assert property ($fell(c) |=> q1); // LEGAL: contextually inferred leading clocking
   // event, @(negedge clk)
   a3: assert property ($fell(c) |=> q2); // ILLEGAL: multi-clocked property with contextually
   // inferred leading clocking event
   a4: assert property (q5); // LEGAL: contextually inferred leading clocking event, @(negedge clk)
end


always @(clk) begin
   a = b + c;
   a1: assert property (z |=> d | e); //ILLEGAL
   .....
end
","""Example of proper and improper use of assertions in Verilog with context regarding legal and illegal clock inference.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p316.jpg,True,"The image contains Verilog code. Here is the code snippet from the image:

```verilog
property p3_hh;
  @(posedge clk) a ##min_time b;
```

This code defines a property `p3_hh` that specifies a timing relationship where signal `a` should be high at the positive edge of the clock `clk` and after a certain minimum number of clock cycles specified by `min_time`, signal `b` should also be high. The `##` operator in Verilog is used for specifying sequential timing constraints.","
property p3_hh;
  @(posedge clk) a ##min_time b;
","Caption: ""Excerpt from a technical document discussing the verification of timing relationships in digital circuits, including a diagram of a timing relationship tree and a snippet of Verilog code for stimulus generation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p503.jpg,True,"The image contains Verilog code. Here it is:

```verilog
covergroup rg;
  pc: coverpoint pendreq;
  gc: coverpoint numMasters;
endgroup

rg my_rg = new;

always @(posedge req)
  my_rg.start();

always @(posedge gnt)
  my_rg.stop();

always @(posedge clk)
begin
  my_rg.sample();
end
```","
covergroup rg;
  pc: coverpoint pendreq;
  gc: coverpoint numMasters;
endgroup

rg my_rg = new;

always @(posedge req)
  my_rg.start();

always @(posedge gnt)
  my_rg.stop();

always @(posedge clk)
begin
  my_rg.sample();
end
","""Verilog coverage group example with user-defined sample() method and performance implications.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p517.jpg,True,"```verilog
bit [7:0] adr;
bit [1:0] offset;

covergroup cg1 (int iW, string iComment) @(posedge clk);
    type_option.comment = ""Coverage model for CG1 Bus"";
    type_option.strobe = 1;
    type_option.weight = 3;

    option.per_instance = 1;
    option.comment = iComment;

    ar: coverpoint adr
    {
        option.auto_bin_max = 4;
    }

    ofst: coverpoint offset
    {
        option.weight = iW;
    }
endgroup

cg1 cg1Inst = new(2,""Coverage for cg1Inst"");
cg1 cg2Inst = new(3,""Coverage for cg2Inst"");
```","
bit [7:0] adr;
bit [1:0] offset;

covergroup cg1 (int iW, string iComment) @(posedge clk);
    type_option.comment = ""Coverage model for CG1 Bus"";
    type_option.strobe = 1;
    type_option.weight = 3;

    option.per_instance = 1;
    option.comment = iComment;

    ar: coverpoint adr
    {
        option.auto_bin_max = 4;
    }

    ofst: coverpoint offset
    {
        option.weight = iW;
    }
endgroup

cg1 cg1Inst = new(2,""Coverage for cg1Inst"");
cg1 cg2Inst = new(3,""Coverage for cg2Inst"");
","""Example of Verilog coverage options for a coverage group illustrating code annotations and creation of cover instances.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p302.jpg,True,"The image contains a section of Verilog code related to the definition of a sequence and a property, and then assertions of the property using `assert` and `cover` statements. Here is the code from the image:

```verilog
sequence s_schk6;
@(posedge clk)
first_match(s_fell (gntn[2]) ##[1:8]
     $fell (framen) ##1 $fell(lockn));
endsequence

property p_schk6;
@(posedge clk)
s_schk6.ended |-> 
    ($past(cxben[1:0]) == 2'b10);
endproperty

a_schk6: assert property(p_schk6);
c_schk6: cover property(p_schk6);
```

This code is part of a verification environment in Verilog, where sequences and properties are used to specify and check behaviors in a design under test. The `assert` statement checks if the property holds true during simulation, and the `cover` statement tracks whether the scenario described by the property has occurred.","
sequence s_schk6;
@(posedge clk)
first_match(s_fell (gntn[2]) ##[1:8]
     $fell (framen) ##1 $fell(lockn));
endsequence

property p_schk6;
@(posedge clk)
s_schk6.ended |-> 
    ($past(cxben[1:0]) == 2'b10);
endproperty

a_schk6: assert property(p_schk6);
c_schk6: cover property(p_schk6);
",Figure illustrating the timing diagram and Verilog code for a PCI Arbiter check sequence.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p343.jpg,True,"The image contains syntax definitions rather than executable code. It shows descriptions from a Property Specification Language document, specifically about Sequences, Braced SERE, and SERE concatenation operator, as part of Verilog or SystemVerilog formal verification. Below are the syntax definitions as they appear in the image:

```
Syntax B-2 Sequence

Sequence ::= Repeated_SERE
            | Braced_SERE
            | Clocked_SERE
```

```
Syntax B-3 Sequence

Braced_SERE ::= { SERE }
```

```
Syntax B-4 Concatenation of sequences

SERE ::= SERE ; SERE
```"," B-2 Sequence

Sequence ::= Repeated_SERE
            | Braced_SERE
            | Clocked_SERE

 B-3 Sequence

Braced_SERE ::= { SERE }

 B-4 Concatenation of sequences

SERE ::= SERE ; SERE
","""Excerpt from a reference manual discussing PSL (Property Specification Language) syntax for sequences, SEREs, and their concatenation and repetition in hardware verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p182.jpg,True,"The image contains Verilog code. Here is the code transcribed from the image:

```verilog
class Transaction;
  bit [31:0] addr, csm, data[8];
  function void display();
    $display(""%0t: TR addr=%h, csm=%h, data=%p"", $time, addr, csm, data);
  endfunction
endclass

class PCI_Tran;
  bit [31:0] addr, data; // Use realistic names
  function void display();
    $display(""%0t: PCI: addr=%h, data=%h"", $time, addr, data);
  endfunction
endclass

Transaction t;
PCI_Tran pc;

initial begin
  t = new();            // Construct a Transaction
  t.display();          // Display a Transaction
  pc = new();           // Construct a PCI transaction
  pc.display();         // Display a PCI Transaction
end
```

The code is an example of SystemVerilog, and it shows the creation of classes and instantiation of objects within a verification context. Two classes are defined (`Transaction` and `PCI_Tran`) with `display` methods, and these objects are instantiated and their display methods are called in an initial block.","
class Transaction;
  bit [31:0] addr, csm, data[8];
  function void display();
    $display(""%0t: TR addr=%h, csm=%h, data=%p"", $time, addr, csm, data);
  endfunction
endclass

class PCI_Tran;
  bit [31:0] addr, data; // Use realistic names
  function void display();
    $display(""%0t: PCI: addr=%h, data=%h"", $time, addr, data);
  endfunction
endclass

Transaction t;
PCI_Tran pc;

initial begin
  t = new();            // Construct a Transaction
  t.display();          // Display a Transaction
  pc = new();           // Construct a PCI transaction
  pc.display();         // Display a PCI Transaction
end
","""Example of Verilog class methods with display functions in SystemVerilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p199.jpg,True,"The image contains C code that is related to Verilog simulation using the Verilog Programming Interface (VPI). Here is the code presented in the image:

```c
tfarg_itr = vpi_iterate(vpiArgument, systf_h);
if (tfarg_itr == NULL) {
    vpi_printf(""ERROR: $mipd_delays requires 4 arguments\n"");
    tf_dofinish();
    return(0);
}
tfarg_h = vpi_scan(tfarg_itr);
if (vpi_get(vpiType, tfarg_h) != vpiNet) {
    vpi_printf(""ERROR: $mipd_delays arg1 must be module input\n"");
    tf_dofinish();
    return(0);
}
port_itr = vpi_iterate(vpiPort, tfarg_h);
if (port_itr == NULL) {
    vpi_printf(""$mipd_delays arg1 not connected to module port\n"");
    tf_dofinish();
    return(0);
}
port_h = vpi_scan(port_itr);
vpi_free_object(port_itr); /* free iterator--did not scan to null */
if (vpi_get(vpiType, port_h) != vpiPort) {
    vpi_printf(""$mipd_delays arg1 not connected to an input port\n"");
    tf_dofinish();
    return(0);
}
for (i=2; i<=4; i++) {
    tfarg_h = vpi_scan(tfarg_itr);
    if (vpi_get(vpiType, tfarg_h) != vpiConstant) {
        vpi_printf(""$mipd_delays arg %d must be a number\n"", i);
        tf_dofinish();
        return(0);
    }
}
if (vpi_scan(tfarg_itr) != NULL) {
    vpi_printf(""ERROR: $mipd_delays requires only 4 arguments\n"");
    vpi_free_object(tfarg_itr); /* free iterator--did not scan to null*/
    tf_dofinish();
    return(0);
}
return(0);
```

This code seems to be part of a function that checks the arguments passed to a system task or function `$mipd_delays` in a Verilog simulation to ensure they meet certain criteria. It utilizes VPI routines to interact with the Verilog simulation elements such as nets, ports, and constants.","_itr = vpi_iterate(vpiArgument, systf_h);
if (tfarg_itr == NULL) {
    vpi_printf(""ERROR: $mipd_delays requires 4 arguments\n"");
    tf_dofinish();
    return(0);
}
tfarg_h = vpi_scan(tfarg_itr);
if (vpi_get(vpiType, tfarg_h) != vpiNet) {
    vpi_printf(""ERROR: $mipd_delays arg1 must be module input\n"");
    tf_dofinish();
    return(0);
}
port_itr = vpi_iterate(vpiPort, tfarg_h);
if (port_itr == NULL) {
    vpi_printf(""$mipd_delays arg1 not connected to module port\n"");
    tf_dofinish();
    return(0);
}
port_h = vpi_scan(port_itr);
vpi_free_object(port_itr); /* free iterator--did not scan to null */
if (vpi_get(vpiType, port_h) != vpiPort) {
    vpi_printf(""$mipd_delays arg1 not connected to an input port\n"");
    tf_dofinish();
    return(0);
}
for (i=2; i<=4; i++) {
    tfarg_h = vpi_scan(tfarg_itr);
    if (vpi_get(vpiType, tfarg_h) != vpiConstant) {
        vpi_printf(""$mipd_delays arg %d must be a number\n"", i);
        tf_dofinish();
        return(0);
    }
}
if (vpi_scan(tfarg_itr) != NULL) {
    vpi_printf(""ERROR: $mipd_delays requires only 4 arguments\n"");
    vpi_free_object(tfarg_itr); /* free iterator--did not scan to null*/
    tf_dofinish();
    return(0);
}
return(0);
",Verilog VPI Routines Example - Error Handling and Iteration in Simulation Code,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p196.jpg,True,"The image contains two code examples in Verilog. Here is the transcription of both:

First:
```verilog
task generator_bad(input int n);
    Transaction t;
    t = new();                     // Create one new object
    repeat (n) begin
        t.addr = $random();        // Initialize variables
        $display(""Sending addr=%h"", t.addr);
        transmit(t);               // Send it into the DUT
    end
endtask
```

Second:
```verilog
task generator_good(input int n);
    Transaction t;
    repeat (n) begin
        t = new();                 // Create one new object
        t.addr = $random();        // Initialize variables
        $display(""Sending addr=%h"", t.addr);
        transmit(t);               // Send it into the DUT
    end
endtask
```

The text explains the difference between the two code samples and the problems associated with not correctly creating new objects within a loop.","
task generator_bad(input int n);
    Transaction t;
    t = new();                     // Create one new object
    repeat (n) begin
        t.addr = $random();        // Initialize variables
        $display(""Sending addr=%h"", t.addr);
        transmit(t);               // Send it into the DUT
    end
endtask


task generator_good(input int n);
    Transaction t;
    repeat (n) begin
        t = new();                 // Create one new object
        t.addr = $random();        // Initialize variables
        $display(""Sending addr=%h"", t.addr);
        transmit(t);               // Send it into the DUT
    end
endtask
",Sample Verilog code illustrating correct and incorrect ways to dynamically create objects in a testbench.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p88.jpg,True,"```c
typedef struct t_vpi_value {
    int format;
    union {
        char *str;                 /* string value */
        int scalar;                /* scalar value */
        double real;               /* real value */
        struct t_vpi_time *time;   /* time value */
        struct t_vpi_vecval *vector; /* vector value */
        struct t_vpi_strengthval *strength; /* strength val */
        char *misc;                         /* reserved */
    } value;
} s_vpi_value, *p_vpi_value;
```

The code in the image is a C language typedef struct declaration for a data structure named `t_vpi_value` which contains an integer `format` and a union `value`. This data structure is used in Verilog procedural interface (PLI) applications.

Additionally, the image includes code for an example:

```c
vpiHandle net_handle;
s_vpi_value current_value;

current_value.format = vpiBinStrVal; /* read as a string */
vpi_get_value(net_handle, &current_value);
vpi_printf(""net %s value is %s (binary)\n"",
           vpi_get_str(vpiName, net_handle),
           current_value.value.str);
```

This snippet shows how to retrieve the logic value of a net as a C string using the Verilog PLI.","ef struct t_vpi_value {
    int format;
    union {
        char *str;                 /* string value */
        int scalar;                /* scalar value */
        double real;               /* real value */
        struct t_vpi_time *time;   /* time value */
        struct t_vpi_vecval *vector; /* vector value */
        struct t_vpi_strengthval *strength; /* strength val */
        char *misc;                         /* reserved */
    } value;
} s_vpi_value, *p_vpi_value;

ndle net_handle;
s_vpi_value current_value;

current_value.format = vpiBinStrVal; /* read as a string */
vpi_get_value(net_handle, &current_value);
vpi_printf(""net %s value is %s (binary)\n"",
           vpi_get_str(vpiName, net_handle),
           current_value.value.str);
","Caption: ""Excerpt from The Verilog PLI Handbook, detailing the structure and usage of the `t_vpi_value` data type in Verilog's Programming Language Interface (PLI).""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p238.jpg,True,"The image contains information about several Verilog operators which are part of Verilog HDL, a hardware description language used to model electronic systems. Here are the examples of the code snippets present in the image for each operator:

- **Conditional expression**:
  ```
  assign x = (m[3:0] == 4'd5) ? q[7:4] : r[3:0];
  ```
  
- **Concatenation**:
  ```
  assign t[7:0] = {3'h2, m[0], q[5:4], r[1:0]};
  ```
  
- **Replication**:
  ```
  assign v[7:0] = {8{T}};
  ```

These examples demonstrate the use of conditional expressions, concatenation, and replication operators in Verilog code.","gn x = (m[3:0] == 4'd5) ? q[7:4] : r[3:0];
  
gn t[7:0] = {3'h2, m[0], q[5:4], r[1:0]};
  
gn v[7:0] = {8{T}};
  ","""Excerpt from a textbook explaining Verilog logical, reduction, conditional, concatenation, and replication operators with examples.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p488.jpg,True,"The image shows text containing Verilog code related to a coverage group, defining bins for tracking transitions. The code present in the image is as follows:

```verilog
covergroup cg @(posedge clk);
  ac : coverpoint adr1
  {
    bins adrB3[] = (1=>3, 1=>4);
    bins adrB4[] = (1=>3, 1=>4, 
                    2=>3, 2=>4);
  }
```

Further down in the image, there is additional text explaining the code:

```verilog
`bins adrB4[ ] = (1=>3, 1=>4, 2=>3, 2=>4)` is equivalent to
`bins adrB4[ ] = (1=>(3, 1)=>(4, 2)=>(3, 2)=>4)`
```

This code is demonstrating how to specify bins in Verilog for capturing various state transitions in functional coverage.","
covergroup cg @(posedge clk);
  ac : coverpoint adr1
  {
    bins adrB3[] = (1=>3, 1=>4);
    bins adrB4[] = (1=>3, 1=>4, 
                    2=>3, 2=>4);
  }


`bins adrB4[ ] = (1=>3, 1=>4, 2=>3, 2=>4)` is equivalent to
`bins adrB4[ ] = (1=>(3, 1)=>(4, 2)=>(3, 2)=>4)`
","""Understanding Verilog Functional Coverage: Transition Bins and Simulation Log Analysis""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p210.jpg,True,"```verilog
module b (p, w, x, y, z);
  input [7:0] w, x, y, z;
  output [7:0] p;
  wire [7:0] w, x, y, z;
  reg [7:0] p, r, s;
  always @(w or x or y) // or z omitted
  begin
    r = w | x;
    s = y | z;
    p = r & s;
  end
endmodule // b
```","
module b (p, w, x, y, z);
  input [7:0] w, x, y, z;
  output [7:0] p;
  wire [7:0] w, x, y, z;
  reg [7:0] p, r, s;
  always @(w or x or y) // or z omitted
  begin
    r = w | x;
    s = y | z;
    p = r & s;
  end
endmodule // b
","Caption: ""Verilog example demonstrating a procedural block with potential latch inference issues and incorrect procedural statement ordering.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p204.jpg,True,"```verilog
module c (r_o, c_n);
    input [1:0] r_o;
    output [1:0] c_n;
    reg [1:0] c_n;
    always @(r_o)
        //rtl_synthesis full_case
        case (r_o)
            2'b00: c_n = 2'b01;
            2'b01: c_n = 2'b10;
            2'b10: c_n = 2'b00;
        endcase
endmodule // c
```","
module c (r_o, c_n);
    input [1:0] r_o;
    output [1:0] c_n;
    reg [1:0] c_n;
    always @(r_o)
        //rtl_synthesis full_case
        case (r_o)
            2'b00: c_n = 2'b01;
            2'b01: c_n = 2'b10;
            2'b10: c_n = 2'b00;
        endcase
endmodule // c
","""Verilog code example demonstrating synthesis-directing full_case and parallel_case statements""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p289.jpg,True,"The image contains Verilog code snippets. Here is the code from the image:

```verilog
sequence s_tchk9a;
    @(posedge clk)
        (!irdyn && !trdyn);
endsequence

sequence s_tchk9b;
    @(posedge clk)
        (!irdyn && !stopn);
endsequence

sequence s_tchk9_fast;
```

These sequences are likely used for timing checks in hardware description for verification purposes.","
sequence s_tchk9a;
    @(posedge clk)
        (!irdyn && !trdyn);
endsequence

sequence s_tchk9b;
    @(posedge clk)
        (!irdyn && !stopn);
endsequence

sequence s_tchk9_fast;
","Caption: ""Excerpt from a document detailing SVA (SystemVerilog Assertions) for protocol interface timing, showing a table with target latency for different device types and examples of sequence declarations in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p311.jpg,True,"The image contains the following Verilog code:

```verilog
property checka;
  @(posedge clk) $rose(b) |=> $changed(a);
endproperty

z1 : assert_property (@(posedge clk) $sampled(a) == $sampled(b));
z1 : assert_property (@(posedge clk) a == b);
```

This code fragment includes two assertions and one property definition, showing the usage of Verilog's assertion constructs and some special operators and functions like $changed, $rose, and $sampled in the context of verification.","
property checka;
  @(posedge clk) $rose(b) |=> $changed(a);
endproperty

z1 : assert_property (@(posedge clk) $sampled(a) == $sampled(b));
z1 : assert_property (@(posedge clk) a == b);
","Caption: ""Excerpt from a technical document discussing IEEE-1800-2009/2012 features for SystemVerilog, specifically the `$changed` event and `$sampled` function, along with Verilog code examples and timing diagrams illustrating pass and fail cases for assertions in simulations.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p262.jpg,True,"The image contains Verilog code related to a property definition and its assertions within the context of verification or formal checking. Here is the code from the image:

```verilog
property p_mchk2;
    @(posedge clk) $rose (framen) |->
    framen[*1:8] ##0 $rose (irdyn && trdyn);
endproperty

a_mchk2: assert property(p_mchk2);
c_mchk2: cover property(p_mchk2);
```

The code defines a property `p_mchk2` intended to capture a particular condition related to clock signal edges and the `framen`, `irdyn`, and `trdyn` signals. Then, it uses `assert` and `cover` directives to specify the behavior that must be assertively checked and the behavior that should be covered in a testbench or formal verification setting.","
property p_mchk2;
    @(posedge clk) $rose (framen) |->
    framen[*1:8] ##0 $rose (irdyn && trdyn);
endproperty

a_mchk2: assert property(p_mchk2);
c_mchk2: cover property(p_mchk2);
",Verilog code and timing diagram for a PCI master check condition using property assertions.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p380.jpg,True,"The image contains examples of code related to SystemVerilog assertions which are described in a textbook or reference document. Here are the excerpts of the code contained in the image:

- For matched sequence: 
```verilog
expression ::= sequence_identifier '.' matched

sequence_identifier ::= (identifier of type sequence)
```

- For first match: 
```verilog
sequence_expr ::= first_match sequence_expr
```

And examples of `first_match`:
```verilog
first_match (l [*1:5]) same as (1)
first_match (##[0:4] 1) same as (1)
first_match (##[0:1] a) same as (a) or (a ##1 a)
first_match (s1 intersect s2) same as (s1 intersect first_match(s2))
first_match (b throughout s1) same as (b throughout first_match(s1))
first_match(s1 within s2) same as (s1 within first_match (s2))
```

These are examples of SystemVerilog expressions using the `matched` and `first_match` methods to work with sequences in the context of temporal assertions for hardware verification.","
expression ::= sequence_identifier '.' matched

sequence_identifier ::= (identifier of type sequence)


sequence_expr ::= first_match sequence_expr


first_match (l [*1:5]) same as (1)
first_match (##[0:4] 1) same as (1)
first_match (##[0:1] a) same as (a) or (a ##1 a)
first_match (s1 intersect s2) same as (s1 intersect first_match(s2))
first_match (b throughout s1) same as (b throughout first_match(s1))
first_match(s1 within s2) same as (s1 within first_match (s2))
",This image contains a segment from a documentation page detailing examples of the 'matched' and 'first_match' sequence operations in SystemVerilog Assertions.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p141.jpg,True,"The image contains a snippet of Verilog code. Here is the code written in the image:

```verilog
interface arb_if(input bit clk);
    logic [1:0] grant, request;
    bit rst;

    clocking cb @(posedge clk);  // Declare cb
        output request;
        input grant;
    endclocking

    modport TEST (clocking cb,    // Use cb
                  output rst);

    modport DUT (input request, rst, clk,
                 output grant);
endinterface

// Trivial test, see Sample 4-21 for a better one
module test_with_cb(arb_if.TEST arbif);
    initial begin
        arbif.cb;
        arbif.cb.request <= 2'b01;
        @arbif.cb;
        $display(""%0t: Grant = %b"", $time, arbif.cb.grant);
        @arbif.cb;
        $display(""%0t: Grant = %b"", $time, arbif.cb.grant);
        $finish;
    end
endmodule
```

The code is demonstrating how to define and use an interface in Verilog that contains a clocking block for synchronizing with a clock signal. The code snippet also provides a very basic test scenario for the interface.","
interface arb_if(input bit clk);
    logic [1:0] grant, request;
    bit rst;

    clocking cb @(posedge clk);  // Declare cb
        output request;
        input grant;
    endclocking

    modport TEST (clocking cb,    // Use cb
                  output rst);

    modport DUT (input request, rst, clk,
                 output grant);
endinterface

// Trivial test, see Sample 4-21 for a better one
module test_with_cb(arb_if.TEST arbif);
    initial begin
        arbif.cb;
        arbif.cb.request <= 2'b01;
        @arbif.cb;
        $display(""%0t: Grant = %b"", $time, arbif.cb.grant);
        @arbif.cb;
        $display(""%0t: Grant = %b"", $time, arbif.cb.grant);
        $finish;
    end
endmodule
","Caption: ""Verilog code example illustrating an interface with a clocking block and modports for synchronous signal handling in a test module.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p463.jpg,True,"The image includes some snippets of Verilog code. Here they are:

```verilog
bins small = {1};
bins mid   = { [2:3] };
bins large = {4};

...

// PCI C/BE Commands
enum {iack, SpecialC, IORead, IOWrite, MemRead, MemWrite, ConfRead, ConfWrite, MemRMwLt, DualAddr, MemReadLine, MemWrInv} pciCommands;

covergroup pciCommands_cover @(negedge FRAME_);
    pciCmdCover : coverpoint pciCommands
    {
        bins pcireads [] = {IORead, MemRead, ConfRead, MemRMwLt, MemReadLine};
        bins pciwrites [] = {IOWrite, MemWrite, ConfWrite, MemWrInv};
        bins pcimisc [] = {iack, SpecialC};
    }

endgroup
```

This code defines bins for a covergroup used for coverage analysis in hardware verification, specifically dealing with PCI commands in Verilog.","
bins small = {1};
bins mid   = { [2:3] };
bins large = {4};

...

// PCI C/BE Commands
enum {iack, SpecialC, IORead, IOWrite, MemRead, MemWrite, ConfRead, ConfWrite, MemRMwLt, DualAddr, MemReadLine, MemWrInv} pciCommands;

covergroup pciCommands_cover @(negedge FRAME_);
    pciCmdCover : coverpoint pciCommands
    {
        bins pcireads [] = {IORead, MemRead, ConfRead, MemRMwLt, MemReadLine};
        bins pciwrites [] = {IOWrite, MemWrite, ConfWrite, MemWrInv};
        bins pcimisc [] = {iack, SpecialC};
    }

endgroup
","""Verilog covergroup and coverpoint example illustrating the use of bins for categorizing PCI cycle types in functional coverage.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p155.jpg,True,"The image contains three Verilog code snippets:

Sample 4.32:
```verilog
module uses_a_port(inout bit not_connected);
    ...
endmodule
```

Sample 4.33:
```verilog
// This will not compile without interface declaration
module uses_an_interface(arb_if.DUT arbif);
    initial arbif.grant = 0;
endmodule
```

Sample 4.34:
```verilog
module top;
    bit clk;
    always #50 clk = !clk;

    arb_if arbif(clk); // Interface with modport
    uses_an_interface u1(arbif); // needed to compile this
endmodule
```","
module uses_a_port(inout bit not_connected);
    ...
endmodule


// This will not compile without interface declaration
module uses_an_interface(arb_if.DUT arbif);
    initial arbif.grant = 0;
endmodule


module top;
    bit clk;
    always #50 clk = !clk;

    arb_if arbif(clk); // Interface with modport
    uses_an_interface u1(arbif); // needed to compile this
endmodule
","Caption: ""Understanding the requirement of connecting an interface within a SystemVerilog module's port list, and illustrating proper interface instantiation to compile Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p159.jpg,True,"The image contains Verilog code. Here is the code written out for you:

```verilog
logic a = 1’b1, b = 1’b0;
logic c;
bit d;
wire w = a;
initial c = 1’b1;
```

The code snippet presents an example of variable declarations and an initial block in Verilog.","
logic a = 1’b1, b = 1’b0;
logic c;
bit d;
wire w = a;
initial c = 1’b1;
","Caption: ""Understanding initial values and variable initialization in Verilog code, with examples of `$past` system function usage.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p276.jpg,True,"Here is the Verilog code from the image:

```verilog
sequence s_mchk15;
    @(posedge clk)
    first_match(s_fell (framen) ##[1:$]
                (framen && irdyn && !gntn && reqn));
endsequence

property p_mchk15;
```

This snippet appears to define a sequence and a property in the context of hardware verification using SystemVerilog Assertions (SVA).","
sequence s_mchk15;
    @(posedge clk)
    first_match(s_fell (framen) ##[1:$]
                (framen && irdyn && !gntn && reqn));
endsequence

property p_mchk15;
","""Timing diagram and SystemVerilog assertion for PCI bus operation and bus parking scenario.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p628.jpg,True,"```c
#include <stdio.h> /* ANSI C standard I/O library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */

#define ALU_A        1 /* system task arg 1 is ALU A input */
#define ALU_B        2 /* system task arg 2 is ALU B input */
#define ALU_OP       3 /* system task arg 3 is ALU opcode input */
#define ALU_RESULT   4 /* system task arg 4 is ALU result output */
#define ALU_EXCEPT   5 /* system task arg 5 is ALU exception output */
#define ALU_ERROR    6 /* system task arg 6 is ALU error output */

/***************************************************************
 * VCL simulation callback routine: Schedules a callback to the misctf
 * application synchronized to the end of a time step. Only schedules
 * one callback for a time step
 ***************************************************************/
int PLIbook_ScientificAlu_interface(p_vc_record vc_record)
{
    char *instance_p;

    /* Retrieve instance handle from VCL user_data field */
    instance_p = vc_record->user_data;

    /* If the TF work area for this instance is NULL, then no misctf
     * synchronize callback has been scheduled for this time step (the
     * work area is set to non-null by this routine, and is set to
     * NULL by the misctf after a callback is processed.
     */
```","ude <stdio.h> /* ANSI C standard I/O library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */

#define ALU_A        1 /* system task arg 1 is ALU A input */
#define ALU_B        2 /* system task arg 2 is ALU B input */
#define ALU_OP       3 /* system task arg 3 is ALU opcode input */
#define ALU_RESULT   4 /* system task arg 4 is ALU result output */
#define ALU_EXCEPT   5 /* system task arg 5 is ALU exception output */
#define ALU_ERROR    6 /* system task arg 6 is ALU error output */

/***************************************************************
 * VCL simulation callback routine: Schedules a callback to the misctf
 * application synchronized to the end of a time step. Only schedules
 * one callback for a time step
 ***************************************************************/
int PLIbook_ScientificAlu_interface(p_vc_record vc_record)
{
    char *instance_p;

    /* Retrieve instance handle from VCL user_data field */
    instance_p = vc_record->user_data;

    /* If the TF work area for this instance is NULL, then no misctf
     * synchronize callback has been scheduled for this time step (the
     * work area is set to non-null by this routine, and is set to
     * NULL by the misctf after a callback is processed.
     */
","""Excerpt from The Verilog PLI Handbook detailing a Verilog C model interface with code for callback synchronization at the end of a simulation time step.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p394.jpg,True,"The image shows a page from a technical document outlining the syntax rules for property construction in SystemVerilog Assertions (SVA). Here is the code:

```verilog
property_spec ::= [ event_control ]
                  [ disable iff ( ‘expression ‘ ) ] multi_clock_property_expr

property_expr ::=
                  sequence_expr
                | event_control property_expr
                | ‘(‘ property_expr ‘)’
                | not property_expr
                | property_expr or property_expr
                | property_expr and property_expr
                | sequence_expr |=> property_expr
                | sequence_expr |-> property_expr
                | if (‘ expression ‘) property_expr
                  [ else property_expr ]
                | property_instance

event_control ::= ‘@’ event_identifier
                | ‘@’ ‘(‘ event_expression ‘)’
```

This is not executable code but BNF (Backus-Naur Form) grammar that defines the structure of property specifications in SystemVerilog Assertions.","
property_spec ::= [ event_control ]
                  [ disable iff ( ‘expression ‘ ) ] multi_clock_property_expr

property_expr ::=
                  sequence_expr
                | event_control property_expr
                | ‘(‘ property_expr ‘)’
                | not property_expr
                | property_expr or property_expr
                | property_expr and property_expr
                | sequence_expr |=> property_expr
                | sequence_expr |-> property_expr
                | if (‘ expression ‘) property_expr
                  [ else property_expr ]
                | property_instance

event_control ::= ‘@’ event_identifier
                | ‘@’ ‘(‘ event_expression ‘)’
","""SystemVerilog Assertions: Defining Property Constructions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p305.jpg,True,"The image contains Verilog code within three solutions. Here is the code from each solution:

Solution 1:
```
property CheckData;
  @(L2TxData or L2ErrorData or L2Abort) (L2TxData == L2ErrorData)
  |-> (L2Abort == 1);
endproperty
```

Solution 2:
```
wire L2TxDataW, L2ErrorDataW, L2AbortW;

assign #1 L2TxDataW = L2TxData;
assign #1 L2ErrorDataW = L2ErrorData;
assign #1 L2AbortW = L2Abort;

property CheckData;
  @(L2TxDataW or L2ErrorDataW or L2AbortW) (L2TxData == L2ErrorData)
  |-> (L2Abort == 1);
endproperty
```

Solution 3:
```
always @(L2TxData or L2ErrorData or L2Abort)
begin
  if (L2TxData == L2ErrorData)
  begin
    if (L2Abort) $display(""L2Abort Check PASS"");
    else $display(""L2Abort Check FAIL"");
  end
end
```

These snippets appear in a section titled ""Asynchronous assertion—Solution"" and seem to be showing different ways of implementing an asynchronous data checking mechanism in Verilog.","ty CheckData;
  @(L2TxData or L2ErrorData or L2Abort) (L2TxData == L2ErrorData)
  |-> (L2Abort == 1);
endproperty

2TxDataW, L2ErrorDataW, L2AbortW;

assign #1 L2TxDataW = L2TxData;
assign #1 L2ErrorDataW = L2ErrorData;
assign #1 L2AbortW = L2Abort;

property CheckData;
  @(L2TxDataW or L2ErrorDataW or L2AbortW) (L2TxData == L2ErrorData)
  |-> (L2Abort == 1);
endproperty

 @(L2TxData or L2ErrorData or L2Abort)
begin
  if (L2TxData == L2ErrorData)
  begin
    if (L2Abort) $display(""L2Abort Check PASS"");
    else $display(""L2Abort Check FAIL"");
  end
end
","""Verilog Asynchronous Assertions: Comparing Three Different Solutions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p63.jpg,True,"```c
int PLIbook_PowSizetf(char *user_data)
{
    return(32); /* $pow returns 32-bit values */
}

int PLIbook_PowComplietf(char *user_data)
{
    vpiHandle systf_handle, arg_itr, arg_handle;
    int tfarg_type;

    systf_handle = vpi_handle(vpiSysTfCall, NULL);
    arg_itr = vpi_iterate(vpiArgument, systf_handle);
    if (arg_itr == NULL) {
        vpi_printf(""ERROR: $pow requires 2 arguments\n"");
        tf_dofinish();
        return(0);
    }
    arg_handle = vpi_scan(arg_itr);
    tfarg_type = vpi_get(vpiType, arg_handle);
    if ( (tfarg_type != vpiReg) &&
         (tfarg_type != vpiIntegerVar) &&
         (tfarg_type != vpiConstant) ) {
        vpi_printf(""ERROR: $pow arg1 must be number, variable or net\n"");
        tf_dofinish();
        return(0);
    }
    arg_handle = vpi_scan(arg_itr);
    if (arg_handle == NULL) {
        vpi_printf(""ERROR: $pow requires 2nd argument\n"");
        tf_dofinish();
        return(0);
    }
    tfarg_type = vpi_get(vpiType, arg_handle);
    if ( (tfarg_type != vpiReg) &&
         (tfarg_type != vpiIntegerVar) &&
         (tfarg_type != vpiConstant) ) {
        vpi_printf(""ERROR: $pow arg2 must be number, variable or net\n"");
        tf_dofinish();
        return(0);
    }
    if (vpi_scan(arg_itr) != NULL) {
        vpi_printf(""ERROR: $pow requires only 2 arguments\n"");
        vpi_free_object(arg_itr);
        tf_dofinish();
        return(0);
    }
    return(0);
}
```","LIbook_PowSizetf(char *user_data)
{
    return(32); /* $pow returns 32-bit values */
}

int PLIbook_PowComplietf(char *user_data)
{
    vpiHandle systf_handle, arg_itr, arg_handle;
    int tfarg_type;

    systf_handle = vpi_handle(vpiSysTfCall, NULL);
    arg_itr = vpi_iterate(vpiArgument, systf_handle);
    if (arg_itr == NULL) {
        vpi_printf(""ERROR: $pow requires 2 arguments\n"");
        tf_dofinish();
        return(0);
    }
    arg_handle = vpi_scan(arg_itr);
    tfarg_type = vpi_get(vpiType, arg_handle);
    if ( (tfarg_type != vpiReg) &&
         (tfarg_type != vpiIntegerVar) &&
         (tfarg_type != vpiConstant) ) {
        vpi_printf(""ERROR: $pow arg1 must be number, variable or net\n"");
        tf_dofinish();
        return(0);
    }
    arg_handle = vpi_scan(arg_itr);
    if (arg_handle == NULL) {
        vpi_printf(""ERROR: $pow requires 2nd argument\n"");
        tf_dofinish();
        return(0);
    }
    tfarg_type = vpi_get(vpiType, arg_handle);
    if ( (tfarg_type != vpiReg) &&
         (tfarg_type != vpiIntegerVar) &&
         (tfarg_type != vpiConstant) ) {
        vpi_printf(""ERROR: $pow arg2 must be number, variable or net\n"");
        tf_dofinish();
        return(0);
    }
    if (vpi_scan(arg_itr) != NULL) {
        vpi_printf(""ERROR: $pow requires only 2 arguments\n"");
        vpi_free_object(arg_itr);
        tf_dofinish();
        return(0);
    }
    return(0);
}
","Caption: ""Example of Verilog Procedural Interface (VPI) application code for checking arguments in a Verilog simulation environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p171.jpg,True,"```verilog
module m;
  bit clk;
  default clocking ck @(posedge clk); endclocking
  a: assert property ( ... );
  initial begin
    $assertoff();
  end
endmodule
```","
module m;
  bit clk;
  default clocking ck @(posedge clk); endclocking
  a: assert property ( ... );
  initial begin
    $assertoff();
  end
endmodule
","Caption: ""Document snippet on controlling assertions in Verilog code, including an example of assertion control using `$assertoff` task.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p166.jpg,True,"The image contains a snippet of code written in C for an interfacing task with Verilog using the PLI (Programming Language Interface). Here is the code provided in the image:

```c
char *PLIbook_getarg_stringval_vpi(int argNum)
{
    vpiHandle arg_h;
    s_vpi_value argVal;
    #ifdef PLIbookDebug
    s_vpi_error_info err; /* structure for error handling */
    #endif

    arg_h = PLIbook_getarg_handle_vpi(argNum);
    if (arg_h == NULL) {
        vpi_printf(""ERROR: PLIbook_getarg_stringval_vpi() could not obtain arg handle\n"");
        return(0);
    }

    argVal.format = vpiStringVal;
    vpi_get_value(arg_h, &argVal);
    #ifdef PLIbookDebug /* if error, generate verbose debug message */
    if (vpi_chk_error(&err)) {
        vpi_printf(""ERROR: PLIbook_getarg_stringval_vpi() could not obtain arg value\n"");
        vpi_printf(""File %s, Line %d: %s\n"",
            err.file, err.line, err.message);
        return("""");
    }
    #endif

    return(argVal.value.str);
}
```

This function appears to retrieve a string value from a Verilog argument through the PLI, and it provides error handling to debug. It is designed to be used within the context of Verilog simulations involving C code, allowing one to translate Verilog data types into C data types for manipulation or analysis.","*PLIbook_getarg_stringval_vpi(int argNum)
{
    vpiHandle arg_h;
    s_vpi_value argVal;
    #ifdef PLIbookDebug
    s_vpi_error_info err; /* structure for error handling */
    #endif

    arg_h = PLIbook_getarg_handle_vpi(argNum);
    if (arg_h == NULL) {
        vpi_printf(""ERROR: PLIbook_getarg_stringval_vpi() could not obtain arg handle\n"");
        return(0);
    }

    argVal.format = vpiStringVal;
    vpi_get_value(arg_h, &argVal);
    #ifdef PLIbookDebug /* if error, generate verbose debug message */
    if (vpi_chk_error(&err)) {
        vpi_printf(""ERROR: PLIbook_getarg_stringval_vpi() could not obtain arg value\n"");
        vpi_printf(""File %s, Line %d: %s\n"",
            err.file, err.line, err.message);
        return("""");
    }
    #endif

    return(argVal.value.str);
}
","Caption: ""Example of Verilog PLI code for reading string values into C strings.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p165.jpg,True,"This image contains a snippet of Verilog code related to assertion system functions for changed and stable states. Here is the code depicted in the image:

```verilog
a1_wrong: assert property (@(posedge clk) $stable(sig));
```

But it mentions that the implementation is wrong.

The correct implementation provided is:

```verilog
a2: assert property (@(posedge clk) nexttime $stable(sig));
```

There's also another assertion given as an example:

```verilog
a_toggle: assert property (@(posedge clk) ##1 $changed(sig));
```","
a1_wrong: assert property (@(posedge clk) $stable(sig));


a2: assert property (@(posedge clk) nexttime $stable(sig));


a_toggle: assert property (@(posedge clk) ##1 $changed(sig));
",Excerpt from a textbook explaining the use of changed and stable sampled value functions in Verilog assertions and providing examples of correct and incorrect implementations.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p172.jpg,True,"The image includes Verilog code. Here is the text of the code from the image:

```verilog
int PlIbook_ReadVecVal_calltf(char *user_data)
{
   vpiHandle systf_handle, arg_iterator, arg_handle, vector_h;
   s_vpi_value vector_val;     /* structure to receive vector value */
   int i, vector_size, array_size, avalbit, bvalbit, bit_num;
   char vlogval;

   /* obtain a handle to the system task instance */
   systf_handle = vpi_handle(vpiSysTfCall, NULL);

   /* obtain handle to system task argument */
   /* compiletf has already verified only 1 arg with correct type */
   arg_iterator = vpi_iterate(vpiArgument, systf_handle);
   vector_h = vpi_scan(arg_iterator);
   vpi_free_object(arg_iterator);    /* free iterator memory */

   vector_size = vpi_get(vpiSize, vector_h); /* determine number of...*/
   array_size = ((vector_size-1) / 32 + 1);  /* ...elements in array */

   vector_val.format = vpiVectorVal; /* set value format field */

   vpi_get_value(vector_h, &vector_val); /* read vector's logic value */

   vpi_printf(""\nVector %s encoded value:\n"",
      vpi_get_str(vpiName,vector_h));
   for (i=0; i<array_size; i++) {
      /* the following loop assumes the Verilog LSB is bit 0 */
      for (bit_num=0; bit_num<31; bit_num++) {
         avalbit=PlIbook_getbit(vector_val.value.vector[i].aval, bit_num);
         bvalbit=PlIbook_getbit(vector_val.value.vector[i].bval, bit_num);
         vlogval=PlIbook_get_4state_val(avalbit, bvalbit);
         vpi_printf("" bit[%2d] a/bval = %d/%d  4-state value = %c\n"",
            (i*32+bit_num), avalbit, bvalbit, vlogval);
      }
      if ((i*32+bit_num) == vector_size-1) break;
   }
   return(0);
}

/**********************************************************************
* Function to determine if a specific bit is set in a 32-bit word.
* Sets the least-significant bit of a mask value to 1 and shifts the
* mask left to the desired bit number.
***********************************************************************/
int PlIbook_getbit(int word, int bit_num)
{
   int mask;
   mask = 0x00000001 << bit_num;
   return((word & mask) ? TRUE: FALSE);
}
```

The code appears to be part of a Programming Language Interface (PLI) application in Verilog, specifically a function to read a vector value as ""aval"" and ""bval"" pairs, reflecting the four-state logic used in Verilog simulations. The `PlIbook_ReadVecVal_calltf` function obtains a vector from a Verilog simulation and prints its value in binary. It uses a helper function `PlIbook_getbit` to determine if a specific bit in a number is set.","
int PlIbook_ReadVecVal_calltf(char *user_data)
{
   vpiHandle systf_handle, arg_iterator, arg_handle, vector_h;
   s_vpi_value vector_val;     /* structure to receive vector value */
   int i, vector_size, array_size, avalbit, bvalbit, bit_num;
   char vlogval;

   /* obtain a handle to the system task instance */
   systf_handle = vpi_handle(vpiSysTfCall, NULL);

   /* obtain handle to system task argument */
   /* compiletf has already verified only 1 arg with correct type */
   arg_iterator = vpi_iterate(vpiArgument, systf_handle);
   vector_h = vpi_scan(arg_iterator);
   vpi_free_object(arg_iterator);    /* free iterator memory */

   vector_size = vpi_get(vpiSize, vector_h); /* determine number of...*/
   array_size = ((vector_size-1) / 32 + 1);  /* ...elements in array */

   vector_val.format = vpiVectorVal; /* set value format field */

   vpi_get_value(vector_h, &vector_val); /* read vector's logic value */

   vpi_printf(""\nVector %s encoded value:\n"",
      vpi_get_str(vpiName,vector_h));
   for (i=0; i<array_size; i++) {
      /* the following loop assumes the Verilog LSB is bit 0 */
      for (bit_num=0; bit_num<31; bit_num++) {
         avalbit=PlIbook_getbit(vector_val.value.vector[i].aval, bit_num);
         bvalbit=PlIbook_getbit(vector_val.value.vector[i].bval, bit_num);
         vlogval=PlIbook_get_4state_val(avalbit, bvalbit);
         vpi_printf("" bit[%2d] a/bval = %d/%d  4-state value = %c\n"",
            (i*32+bit_num), avalbit, bvalbit, vlogval);
      }
      if ((i*32+bit_num) == vector_size-1) break;
   }
   return(0);
}

/**********************************************************************
* Function to determine if a specific bit is set in a 32-bit word.
* Sets the least-significant bit of a mask value to 1 and shifts the
* mask left to the desired bit number.
***********************************************************************/
int PlIbook_getbit(int word, int bit_num)
{
   int mask;
   mask = 0x00000001 << bit_num;
   return((word & mask) ? TRUE: FALSE);
}
","""Example of Verilog Procedural Interface (VPI) code for reading 4-state vector values in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p169.jpg,True,"The image contains Verilog code. Here it is transcribed below:

```verilog
module incr(ref int c, d); // c variable is read and written
  always @(c)
    #1 d = c++; // d=c; c=c+1;
endmodule

module top;
  int c, d;
  incr il(c, d);
  initial begin
    $monitor(""%0d: c=%0d, d=%0d"", $time, c, d);
    c = 2;
    #10;
    c = 8;
    #10;
  end
endmodule
```","
module incr(ref int c, d); // c variable is read and written
  always @(c)
    #1 d = c++; // d=c; c=c+1;
endmodule

module top;
  int c, d;
  incr il(c, d);
  initial begin
    $monitor(""%0d: c=%0d, d=%0d"", $time, c, d);
    c = 2;
    #10;
    c = 8;
    #10;
  end
endmodule
","Caption: ""Example of a Verilog module using ref ports to pass variables by reference, along with a discussion on the usage of SystemVerilog interfaces in a book or documentation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p77.jpg,True,"The image includes Verilog code. Below is the code extracted from the image:

```verilog
module test;
  reg [1:0] test_in;
  wire [1:0] test_out;
  buf2 u1 (test_in, test_out);
  initial
    begin
      test_in = 3;
      #50 $display(""in=%d, out=%d"", test_in, test_out);
    end
endmodule

module buf2 (in, out);
  input [1:0] in;
  output [1:0] out;
  wire [1:0] in, out;
  buf #5 n0 (out[0], in[0]);
  buf #1 n1 (out[1], in[1]);
endmodule
```","
module test;
  reg [1:0] test_in;
  wire [1:0] test_out;
  buf2 u1 (test_in, test_out);
  initial
    begin
      test_in = 3;
      #50 $display(""in=%d, out=%d"", test_in, test_out);
    end
endmodule

module buf2 (in, out);
  input [1:0] in;
  output [1:0] out;
  wire [1:0] in, out;
  buf #5 n0 (out[0], in[0]);
  buf #1 n1 (out[1], in[1]);
endmodule
",Verilog HDL Example Illustrating Use of VPI Routines to Access and Modify Simulation Objects.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p339.jpg,True,"```verilog
property p1;
  @(posedge clk) $fell(bMode) |-> !(bMode) throughout data_transfer[*4];
endproperty
assert property (p1);

property reqack;
  @(posedge clk) accept_on(cycle_end) req |-> ##5 ack;
endproperty
assert property (reqack);

property p; (accept_on(a) p1) and (reject_on(b) p2);
endproperty
``` 

These are the Verilog code snippets from the image.","
property p1;
  @(posedge clk) $fell(bMode) |-> !(bMode) throughout data_transfer[*4];
endproperty
assert property (p1);

property reqack;
  @(posedge clk) accept_on(cycle_end) req |-> ##5 ack;
endproperty
assert property (reqack);

property p; (accept_on(a) p1) and (reject_on(b) p2);
endproperty
","Excerpt from a technical document explaining the usage of ""accept_on"" and ""reject_on"" properties in Verilog for assertion checks, with code examples and scenarios.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p165.jpg,True,"The image contains examples of Verilog code which define functions with different return types. Here's the code from the image:

```verilog
function int sum1 (int a, b); // return int type (32-bit)
function [15:0] sum1 (int a, b); // return 16-bit logic type
function logic sum1 (int a, b); // return 1-bit logic type
function bit [31:0] sum1 (int a, b); // return 32-bit bit type
function real sum1 (int a, b); // return real type
```

This snippet illustrates how to define functions in Verilog with various return types, including integer, logic vector, singular logic bit, bit vector, and real types.","
function int sum1 (int a, b); // return int type (32-bit)
function [15:0] sum1 (int a, b); // return 16-bit logic type
function logic sum1 (int a, b); // return 1-bit logic type
function bit [31:0] sum1 (int a, b); // return 32-bit bit type
function real sum1 (int a, b); // return real type
","Caption: ""Examples of Verilog function definitions with different return types and a discussion on potential gotchas related to function return type specification in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p515.jpg,True,"The image contains an excerpt from a textbook, and there is a snippet of code written in Verilog. The code snippet is:

```verilog
initial $sdf_annotate(""SDF_file_name.sdf"");
``` 

This line of code is typically used to annotate the simulation with timing information from the specified SDF (Standard Delay Format) file.","
initial $sdf_annotate(""SDF_file_name.sdf"");
","Caption: ""Excerpt from a textbook covering Verilog simulation back-annotation with SDF (Standard Delay Format), discussing the integration of timing information into a design netlist for simulation purposes.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p141.jpg,True,"The image includes a snippet of code which appears to be a mix of C and Verilog Programming Interface (PLI) calls. Here is the code:

```c
else if (size <= 64) {
    current_quiescent_state = 
        tf_getlongp(&current_high, 1);
    end_quiescent_state = 
        tf_getlongp(&end_high, 2); if
    (!(current_quiescent_state == 
        end_quiescent_state) &&
       (current_high == end_high))
    ) {
        ok = 0;
    }
} else {
    (void) tf_exprinfo(1, &current_expr_info);
    (void) tf_exprinfo(2, &end_expr_info);
    for (i=
        NUMWORDS(current_expr_info.expr_vec_size);
        i >= 0; i -= 1) {
    if (current_expr_info.expr_value_p[i].avalbits
        != end_expr_info.expr_value_p[i].avalbits) {
        ok = 0;
        break;
    }
    }
}
if (ok==0) {
    io_printf (""$assert_quiescent_state error: %s: %s\n"",
        tf_spname(), tf_getp(1));
}
return (0);
}
```

Please note that the above code utilizes TF (task/function) routines, which suggest this code is intended to be run in a Verilog simulator that supports the PLI. The PLI is used to create custom C functions that can be called from within a Verilog simulation. The code is performing a quiescent state assertion, which is a check to ensure that a signal or state remains stable over a certain condition or period.","if (size <= 64) {
    current_quiescent_state = 
        tf_getlongp(&current_high, 1);
    end_quiescent_state = 
        tf_getlongp(&end_high, 2); if
    (!(current_quiescent_state == 
        end_quiescent_state) &&
       (current_high == end_high))
    ) {
        ok = 0;
    }
} else {
    (void) tf_exprinfo(1, &current_expr_info);
    (void) tf_exprinfo(2, &end_expr_info);
    for (i=
        NUMWORDS(current_expr_info.expr_vec_size);
        i >= 0; i -= 1) {
    if (current_expr_info.expr_value_p[i].avalbits
        != end_expr_info.expr_value_p[i].avalbits) {
        ok = 0;
        break;
    }
    }
}
if (ok==0) {
    io_printf (""$assert_quiescent_state error: %s: %s\n"",
        tf_spname(), tf_getp(1));
}
return (0);
}
","Caption: ""Example of a Verilog code snippet utilizing PLI for quiescent state assertion in digital simulation.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p45.jpg,True,"The image contains a snippet of Verilog code. Here is the code extracted from the image:

```verilog
program automatic test;
...
chip_sv_style dut (...);
initial $display (""temp = %0d"", test.dut.temp); // GOTCHA!
endmodule
```

This is a fragment of a Verilog program that is part of a discussion on why certain practices in Verilog and SystemVerilog might cause issues, specifically with local variables in unnamed blocks.","
program automatic test;
...
chip_sv_style dut (...);
initial $display (""temp = %0d"", test.dut.temp); // GOTCHA!
endmodule
","This image shows a page from a book detailing a common pitfall (or ""gotcha"") related to the use of local variables within unnamed blocks in Verilog and SystemVerilog, accompanied by a snippet of example code and information on how to avoid this issue.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p51.jpg,True,"The image contains Verilog code. Here it is:

```verilog
byte in;              // signed 8-bit variables
int out1, out2;       // signed 32-bit variables

initial begin
    in = -5;
    out1 = in + 1;    // OK: -5 + 1 = -4 (literal 1 is signed)
    out2 = in + '1b1; // GOTCHA: -5 + '1b1 = 252 ('1b1 is unsigned)
end
```","
byte in;              // signed 8-bit variables
int out1, out2;       // signed 32-bit variables

initial begin
    in = -5;
    out1 = in + 1;    // OK: -5 + 1 = -4 (literal 1 is signed)
    out2 = in + '1b1; // GOTCHA: -5 + '1b1 = 252 ('1b1 is unsigned)
end
","""Understanding the sign in Verilog literal integers and avoiding common mistakes in increment operations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p501.jpg,True,"The image contains two snippets of code that seem to relate to instantiation of Verilog modules where parameters are being passed to a ""SerDes"" module:

```verilog
SerDes #( .DWid(DWid)
          , .RxDogDepth(RxDogDepthB)
          , .TxDogDepth(TxDogDepthA)
        ) ...

SerDes_U1 ( .ParDataOutRcvr ... // A sender; B receiver.

...

SerDes #( .DWid(DWid)
          , .RxDogDepth(RxDogDepthA)
          , .TxDogDepth(TxDogDepthB)
        ) ...

SerDes_U2 ( .ParDataOutRcvr ... // B sender; A receiver.
```

It's important to note that the code snippets show the module parameter instantiation syntax, but they are not complete code blocks—they are excerpts with ellipses indicating omitted code. The parameters `DWid`, `RxDogDepth`, and `TxDogDepth` are being set with values that are not shown in the image. Additionally, the instantiation of modules `SerDes_U1` and `SerDes_U2` includes a signal or port `ParDataOutRcvr` with omitted connections, indicated by the ellipses.","
SerDes #( .DWid(DWid)
          , .RxDogDepth(RxDogDepthB)
          , .TxDogDepth(TxDogDepthA)
        ) ...

SerDes_U1 ( .ParDataOutRcvr ... // A sender; B receiver.

...

SerDes #( .DWid(DWid)
          , .RxDogDepth(RxDogDepthA)
          , .TxDogDepth(TxDogDepthB)
        ) ...

SerDes_U2 ( .ParDataOutRcvr ... // B sender; A receiver.
","""Verilog code snippet showing example of parameter passing in module instances.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p267.jpg,True,"Here is the Verilog code from the image:

```verilog
always @(*)
begin
  #5 Za <= a;
  #1 Zb <= b;
  #1 Zc <= c;
  #1 Zd <= d;
  #1 Ze <= e;
end

always @(*)
begin
  fork
    #5 Za <= a;
    #1 Zb <= b;
    #1 Zc <= c;
    #1 Zd <= d;
  join
    #1 Ze <= e;
end
```

This code is part of an example discussing the effect of `fork-join` blocks on the scheduling of delayed events in Verilog. The accompanying text warns that it is a bad idea to mix blocking and nonblocking assignments in a real design.","
always @(*)
begin
  #5 Za <= a;
  #1 Zb <= b;
  #1 Zc <= c;
  #1 Zd <= d;
  #1 Ze <= e;
end

always @(*)
begin
  fork
    #5 Za <= a;
    #1 Zb <= b;
    #1 Zc <= c;
    #1 Zd <= d;
  join
    #1 Ze <= e;
end
","Caption: ""Impact of using fork-join on the scheduling of delayed events in Verilog, with an example showing the differences in signal timing when mixed blocking and nonblocking assignments are used.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p394.jpg,True,"The image contains several snippets of Verilog code:

```verilog
covergroup CoverLength(ref bit [2:0] len);
  coverpoint len;
  option.per_instance = 1;
endgroup
```

```verilog
covergroup CovDst42;
  type_option.comment = ""Section 3.2.14 Dst port numbers"";
  coverpoint tr.dst;
endgroup
```

```verilog
covergroup CovDst43(int lo,hi, string comment);
  option.comment = comment;
  option.per_instance = 1;
  coverpoint tr.dst
  {
    bins range = {[lo:hi]};
  }
endgroup
...
CovDst43 cd_lo = new(0,3, ""Low dst numbers"");
CovDst43 cd_hi = new(4,7, ""High dst numbers"");
```","
covergroup CoverLength(ref bit [2:0] len);
  coverpoint len;
  option.per_instance = 1;
endgroup


covergroup CovDst42;
  type_option.comment = ""Section 3.2.14 Dst port numbers"";
  coverpoint tr.dst;
endgroup


covergroup CovDst43(int lo,hi, string comment);
  option.comment = comment;
  option.per_instance = 1;
  coverpoint tr.dst
  {
    bins range = {[lo:hi]};
  }
endgroup
...
CovDst43 cd_lo = new(0,3, ""Low dst numbers"");
CovDst43 cd_hi = new(4,7, ""High dst numbers"");
","""Examples of specifying per-instance coverage and adding comments to cover groups in Verilog for functional coverage reporting.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p171.jpg,True,"The image does contain Verilog code. Here's the code from the image:

```verilog
interface arb_ifc(input logic clk);
    ...
endinterface

program automatic test (arb_ifc.TEST arb);

class Driver;
    arb_ifc arb; // GOTCHA! class cannot instantiate interface

    function new(arb_ifc arb); // GOTCHA! task/func arg cannot be an interface
        this.arb = arb;
    endfunction
endclass

initial begin
    Driver d;
    d = new(arb);
end
endprogram
```","
interface arb_ifc(input logic clk);
    ...
endinterface

program automatic test (arb_ifc.TEST arb);

class Driver;
    arb_ifc arb; // GOTCHA! class cannot instantiate interface

    function new(arb_ifc arb); // GOTCHA! task/func arg cannot be an interface
        this.arb = arb;
    endfunction
endclass

initial begin
    Driver d;
    d = new(arb);
end
endprogram
","""Common pitfalls in using Verilog interfaces with object-oriented testbenches and how to avoid them.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p398.jpg,True,"```verilog
sequence s_3_in_a_row(bit signal, goal);
    (signal == goal)[*3];
endsequence

property p_illegal_causality;
    bit l_v;
    (start, l_v = a)
      |-> s_3_in_a_row(.signal(b), .goal(l_v)).triggered;
endproperty
```","
sequence s_3_in_a_row(bit signal, goal);
    (signal == goal)[*3];
endsequence

property p_illegal_causality;
    bit l_v;
    (start, l_v = a)
      |-> s_3_in_a_row(.signal(b), .goal(l_v)).triggered;
endproperty
","""Understanding the Mechanics of Local Variables in SystemVerilog Assertions and Sequences""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p79.jpg,True,"Here is the Verilog code from the image:

```verilog
`ifdef SYNTHESIS  // start non-synthesizable simulation code
always @*
  if (~rst_n) force q_out = '1'b1;
  else        release q_out;
`endif           // start synthesizable and simulatable code
always_ff @(posedge clk, negedge rst_n, negedge set_n)
  if (!rst_n)              // reset has priority over set
    q_out <= '1'b0;        // reset assignments
  else if (!set_n)
    q_out <= '1'b1;        // set assignments
  else
    q_out <= data_in;      // d input assignment
```

The code snippet is demonstrating how to handle non-synthesizable simulation-specific code using conditional compilation and a synthesizable description of a flip-flop with asynchronous set/reset in Verilog.","
`ifdef SYNTHESIS  // start non-synthesizable simulation code
always @*
  if (~rst_n) force q_out = '1'b1;
  else        release q_out;
`endif           // start synthesizable and simulatable code
always_ff @(posedge clk, negedge rst_n, negedge set_n)
  if (!rst_n)              // reset has priority over set
    q_out <= '1'b0;        // reset assignments
  else if (!set_n)
    q_out <= '1'b1;        // set assignments
  else
    q_out <= data_in;      // d input assignment
","""Handling Asynchronous Set/Reset in Verilog for Accurate Simulation Versus Synthesis""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p343.jpg,True,"Here is the Verilog code from the image:

Sample 8.34 Parameterized generator class using blueprint pattern
```verilog
class Generator #(type T=BaseTr);
  mailbox #(Transaction) gen2drv;
  T blueprint; // Blueprint object

  function new(input mailbox #(Transaction) gen2drv);
    this.gen2drv = gen2drv;
    blueprint = new(); // Create default
  endfunction

  task run(input int num_tr = 10);
    T tr;
    repeat (num_tr) begin
      `SV_RAND_CHECK(blueprint.randomize);
      $cast(tr, blueprint.copy()); // Make a copy
      gen2drv.put(tr); // Send to driver
    end
  endtask
endclass
```
Using the Transaction class from Sample 8.25 and the generator in Sample 8.34, you can build a simple testbench like in Sample 8.35. It starts the generator and prints the first five transactions, using the mailbox synchronization shown in Sample 7.40.

Sample 8.35 Simple testbench using parameterized generator class
```verilog
program automatic test;

  initial begin
    Generator #(Transaction) gen;
    mailbox #(Transaction) gen2drv;
    gen2drv = new(1);
    gen = new(gen2drv);

    fork
      gen.run();
      repeat (5) begin
        Transaction tr;
        gen2drv.peek(tr); // Get next transaction
        tr.display();
        gen2drv.get(tr); // Remove transaction
      end
    join_any
  end
endprogram // test
```

Please note that the actual syntax might not work as expected without the full context and definitions from the rest of the source, such as the `Transaction` class and the `BaseTr` type which are referenced but not defined in the provided image.","
class Generator #(type T=BaseTr);
  mailbox #(Transaction) gen2drv;
  T blueprint; // Blueprint object

  function new(input mailbox #(Transaction) gen2drv);
    this.gen2drv = gen2drv;
    blueprint = new(); // Create default
  endfunction

  task run(input int num_tr = 10);
    T tr;
    repeat (num_tr) begin
      `SV_RAND_CHECK(blueprint.randomize);
      $cast(tr, blueprint.copy()); // Make a copy
      gen2drv.put(tr); // Send to driver
    end
  endtask
endclass


program automatic test;

  initial begin
    Generator #(Transaction) gen;
    mailbox #(Transaction) gen2drv;
    gen2drv = new(1);
    gen = new(gen2drv);

    fork
      gen.run();
      repeat (5) begin
        Transaction tr;
        gen2drv.peek(tr); // Get next transaction
        tr.display();
        gen2drv.get(tr); // Remove transaction
      end
    join_any
  end
endprogram // test
","""Example of a parameterized generator class in Verilog for testbench automation and transaction generation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p358.jpg,True,"The image contains the following Verilog code:

```verilog
module test;
    reg [7:0] reg1, reg2;
    initial
    begin
        reg1 = 0; reg2 = 0;
        $put_value(reg1, reg2);
        $display(""reg1=%d reg2=%d"", reg1, reg2);
        $strobe(""reg1=%d reg2=%d"", reg1, reg2);
        #1 $finish;
    end
endmodule
```

This code is intended to illustrate the problem of putting a value into simulation using a delay of zero.","
module test;
    reg [7:0] reg1, reg2;
    initial
    begin
        reg1 = 0; reg2 = 0;
        $put_value(reg1, reg2);
        $display(""reg1=%d reg2=%d"", reg1, reg2);
        $strobe(""reg1=%d reg2=%d"", reg1, reg2);
        #1 $finish;
    end
endmodule
","""Discussion on the distinction between no delay and zero delay in Verilog PLI, including example code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p429.jpg,True,"The image contains the following Verilog code excerpt:

```verilog
for (genvar i = 1; i <= 100; i++) begin : loop_delays
  prop_cov4: cover property ( disable iff (reset)
    @(posedge clk) a ##[i] b
  ) $display(
    ""prop_cov4 success, time %t, delay %0d"", $time, i
  );
end : loop_delays
```

This snippet appears to be from a textbook or document discussing coverage in the context of digital design verification, specifically using the SystemVerilog hardware description and verification language.","
for (genvar i = 1; i <= 100; i++) begin : loop_delays
  prop_cov4: cover property ( disable iff (reset)
    @(posedge clk) a ##[i] b
  ) $display(
    ""prop_cov4 success, time %t, delay %0d"", $time, i
  );
end : loop_delays
","""Exploring Sequence and Property Coverage with Covergroup in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p86.jpg,True,"The image contains two snippets of Verilog code. Here they are:

First snippet:
```verilog
always @(m, n) // combinational sensitivity list (no clock edge)
m = m + n; // OK, immediate update to m with no clock-to-Q delta
```

Second snippet:
```verilog
always_comb // inferred combinational logic sensitivity list
m <= m + n; // PROBABLE SYNTAX ERROR: no other process can
            // write to m
```

The text also discusses good practices in Verilog and SystemVerilog to avoid problems like simulation lock-up and combinational logic feedback loops.","
always @(m, n) // combinational sensitivity list (no clock edge)
m = m + n; // OK, immediate update to m with no clock-to-Q delta


always_comb // inferred combinational logic sensitivity list
m <= m + n; // PROBABLE SYNTAX ERROR: no other process can
            // write to m
","""Addressing Simulation Lock-up Issues in Verilog and SystemVerilog Code with Blocking Assignments and Specialized Procedural Blocks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p425.jpg,True,"```verilog
program automatic test
#(parameter int NumRx = 4, parameter int NumTx = 4)
(Utopia.TB_Rx Rx[0:NumRx-1],
 Utopia.TB_Tx Tx[0:NumTx-1],
 cpu_ifc.Test mif,
 input logic rst);

`include ""environment.sv""
Environment env;

initial begin
  env = new(Rx, Tx, NumRx, NumTx, mif);
  env.gen_cfg();
  env.build();
  env.run();
  env.wrap_up();
end
endprogram // test

interface cpu_ifc;
logic       BusMode, Sel, Rd_DS, Wr_RW, Rdy_Dtack;
logic [11:0] Addr;
CellCfgType DataIn, DataOut; // Defined in Sample 11-11

modport Peripheral
  (input  BusMode, Addr, Sel, DataIn, Rd_DS, Wr_RW,
   output DataOut, Rdy_Dtack);

modport Test
  (output BusMode, Addr, Sel, DataIn, Rd_DS, Wr_RW,
   input  DataOut, Rdy_Dtack);

endinterface : cpu_ifc

typedef virtual cpu_ifc.Test vCPU_T;
``` 

Here is the Verilog code displayed in the image.","
program automatic test
#(parameter int NumRx = 4, parameter int NumTx = 4)
(Utopia.TB_Rx Rx[0:NumRx-1],
 Utopia.TB_Tx Tx[0:NumTx-1],
 cpu_ifc.Test mif,
 input logic rst);

`include ""environment.sv""
Environment env;

initial begin
  env = new(Rx, Tx, NumRx, NumTx, mif);
  env.gen_cfg();
  env.build();
  env.run();
  env.wrap_up();
end
endprogram // test

interface cpu_ifc;
logic       BusMode, Sel, Rd_DS, Wr_RW, Rdy_Dtack;
logic [11:0] Addr;
CellCfgType DataIn, DataOut; // Defined in Sample 11-11

modport Peripheral
  (input  BusMode, Addr, Sel, DataIn, Rd_DS, Wr_RW,
   output DataOut, Rdy_Dtack);

modport Test
  (output BusMode, Addr, Sel, DataIn, Rd_DS, Wr_RW,
   input  DataOut, Rdy_Dtack);

endinterface : cpu_ifc

typedef virtual cpu_ifc.Test vCPU_T;
","""Example of a SystemVerilog testbench program and CPU Management Interface definition.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p107.jpg,True,"The image contains Verilog code snippets. Here they are:

First code snippet (designModule):
```verilog
module designModule (da,db,dclk);
input da,dclk;
output logic db;
always @(posedge dclk) db <= da;
endmodule
```

Second code snippet (propertyModule):
```verilog
module propertyModule (pa,pb,pclk);
input pa, pb, pclk;
property rc1;
pa |- > pb;
endproperty
base: assert property (@(posedge pclk) (rc1)) else $display($stime,,,,""property FAIL;"");
endmodule
```

Third code snippet (test_bindProperty):
```verilog
module test_bindProperty;
logic ta, tb, tclk;

designModule dM (.da(ta), .db(tb), .dclk(tclk));

// bind designModule propertyModule dM (.pa(da),.pb(db),.pclck(dclk));

bind dM propertyModule dM_p (.pa(da),.pb(db),.pclck(dclk));

endmodule
```

Please note that the comment in the third snippet contains what appears to be an incorrect spelling: "".pclck"" should probably be "".pclk"". Also, the ports to be bound in bind statement should match with the instance name 'dM' not the module name 'designModule'. So, the proper bind statement should be:

```verilog
bind dM propertyModule dM_p (.pa(ta),.pb(tb),.pclk(tclk));
```

This reflects binding the 'propertyModule' to the 'designModule' instance named 'dM' with the proper port connections.","
module designModule (da,db,dclk);
input da,dclk;
output logic db;
always @(posedge dclk) db <= da;
endmodule


module propertyModule (pa,pb,pclk);
input pa, pb, pclk;
property rc1;
pa |- > pb;
endproperty
base: assert property (@(posedge pclk) (rc1)) else $display($stime,,,,""property FAIL;"");
endmodule


module test_bindProperty;
logic ta, tb, tclk;

designModule dM (.da(ta), .db(tb), .dclk(tclk));

// bind designModule propertyModule dM (.pa(da),.pb(db),.pclck(dclk));

bind dM propertyModule dM_p (.pa(da),.pb(db),.pclck(dclk));

endmodule


bind dM propertyModule dM_p (.pa(ta),.pb(tb),.pclk(tclk));
",Verilog 'bind' construct example demonstrating how to keep design logic separate from assertion logic.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p431.jpg,True,"```verilog
class Scb_Driver_cbs extends Driver_cbs;
  Scoreboard scb;
  
  function new(input Scoreboard scb);
    this.scb = scb;
  endfunction : new
  
  // Send received cell to scoreboard
  virtual task post_tx(input Driver drv,
                       input UNI_cell c);
    scb.save_expected(c);
  endtask : post_tx
endclass : Scb_Driver_cbs
```

```verilog
class Scb_Monitor_cbs extends Monitor_cbs;
  Scoreboard scb;
  
  function new(input Scoreboard scb);
    this.scb = scb;
  endfunction : new
  
  // Send received cell to scoreboard
  virtual task post_rx(input Monitor mon,
                       input NNI_cell c);
    scb.check_actual(c, mon.PortID);
  endtask : post_rx
endclass : Scb_Monitor_cbs
```","
class Scb_Driver_cbs extends Driver_cbs;
  Scoreboard scb;
  
  function new(input Scoreboard scb);
    this.scb = scb;
  endfunction : new
  
  // Send received cell to scoreboard
  virtual task post_tx(input Driver drv,
                       input UNI_cell c);
    scb.save_expected(c);
  endtask : post_tx
endclass : Scb_Driver_cbs


class Scb_Monitor_cbs extends Monitor_cbs;
  Scoreboard scb;
  
  function new(input Scoreboard scb);
    this.scb = scb;
  endfunction : new
  
  // Send received cell to scoreboard
  virtual task post_rx(input Monitor mon,
                       input NNI_cell c);
    scb.check_actual(c, mon.PortID);
  endtask : post_rx
endclass : Scb_Monitor_cbs
",Sample Verilog code for connecting a driver and a monitor to a scoreboard using callback classes in a SystemVerilog testbench.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p92.jpg,True,"Here is the code from the image:

```verilog
logic [2:0] state, nstate; // 3-bit variables (8 possible values)

always @(state) begin // next state decoder
    case (state) //synthesis full_case -- GOTCHA!
        3’b001: nstate = 3’b010;
        3’b010: nstate = 3’b100;
        3’b100: nstate = 3’b001;
    endcase
end
```

Please note that in the literal text, there would be no apostrophes before the `b` in the numbers written like `3'b010`. It's likely that the apostrophe displayed in the text is due to some form of typo or OCR (optical character recognition) error. The correct Verilog syntax uses the single quote before the `b` to indicate a binary number.","
logic [2:0] state, nstate; // 3-bit variables (8 possible values)

always @(state) begin // next state decoder
    case (state) //synthesis full_case -- GOTCHA!
        3’b001: nstate = 3’b010;
        3’b010: nstate = 3’b100;
        3’b100: nstate = 3’b001;
    endcase
end
","Caption: ""Explaining the pitfalls of incomplete decision statements in Verilog/SystemVerilog with an example of a finite state machine code snippet.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p357.jpg,True,"```verilog
`define svm_component_utils(T) \
  typedef svm_component_registry #(T,""~T"") type_id; \
  virtual function string get_type_name (); \
    return ""~T""; \
  endfunction

class TestBase extends svm_component;
  Environment env;
  `svm_component_utils(TestBase)

  function new(string name) ;
    super.new(name);
    $display(""%m"");
    env = new();
  endfunction

  virtual task run_test();
  endtask
endclass : TestBase

program automatic test;
  initial begin
    svm_component test_obj;
    test_obj = svm_factory::get_test();
    test_obj.run_test();
  end
endprogram
```","
`define svm_component_utils(T) \
  typedef svm_component_registry #(T,""~T"") type_id; \
  virtual function string get_type_name (); \
    return ""~T""; \
  endfunction

class TestBase extends svm_component;
  Environment env;
  `svm_component_utils(TestBase)

  function new(string name) ;
    super.new(name);
    $display(""%m"");
    env = new();
  endfunction

  virtual task run_test();
  endtask
endclass : TestBase

program automatic test;
  initial begin
    svm_component test_obj;
    test_obj = svm_factory::get_test();
    test_obj.run_test();
  end
endprogram
","""Example of a SystemVerilog testbench with base test class definition, macro for component registration, and a test program for object creation and test execution.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p364.jpg,True,"The image contains a snippet of code from a Verilog handbook. Here's the code present in the image:

```verilog
reg [39:0] data;  /* little endian -- LSB is bit 0 */
reg [0:39] data2; /* big endian -- LSB is bit 39 */
reg [40:1] data3; /* little endian -- LSB is bit 1 */
```

This snippet shows how to declare 40-bit registers in Verilog using different bit numbering conventions.","
reg [39:0] data;  /* little endian -- LSB is bit 0 */
reg [0:39] data2; /* big endian -- LSB is bit 39 */
reg [40:1] data3; /* little endian -- LSB is bit 1 */
","Caption: ""Mapping of a 40-bit Verilog vector to an array of aval/bval C integer pairs as explained in The Verilog PLI Handbook, demonstrating different endianness conventions in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p419.jpg,True,"The image contains a snippet of text regarding SystemVerilog code. Here is the code from the image:

```verilog
class Driver;
    ...
    // Declare a virtual interface for the DUT
    function new(input inst_mbox #(Instruction) agt2d_drv, /* complete the argument list */);
        this.agt2drv = agt2d_drv;
        // Save the virtual interface argument in
        // the class-level variable
    endfunction
endclass

class Environment;
    Driver drv;
    .....
    drv = new(agt2d_drv, /* complete the argument list */);
    .....
endclass
```

In the code, the comments indicate where additional arguments should be added to complete the argument lists for the `new` function in the `Driver` class and the `new` instance creation of `Driver` in the `Environment` class.","
class Driver;
    ...
    // Declare a virtual interface for the DUT
    function new(input inst_mbox #(Instruction) agt2d_drv, /* complete the argument list */);
        this.agt2drv = agt2d_drv;
        // Save the virtual interface argument in
        // the class-level variable
    endfunction
endclass

class Environment;
    Driver drv;
    .....
    drv = new(agt2d_drv, /* complete the argument list */);
    .....
endclass
","Caption: ""Sample Verilog code showing the definition of a Driver class and Environment class with a focus on virtual interfaces and constructors in SystemVerilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p415.jpg,True,"```verilog
property p_check_data_xfer(
  local input dataType l_dataModel [MAX_BEATS]
);
  int unsigned j = 0;
  (
    (!retry && !(dataValid && complete))
    throughout dataValid[-1],
    [>*]
    ##1 (!(retry && !dataValid)[*]
    ##1 (dataValid, j++)
    |->
    (
      j <= MAX_BEATS
      and data == l_dataModel[j-1]
      and if (!retry && complete)
        nexttime !dataValid
    )
  );
endproperty

property p_check_retried_data_xfer(
  local input dataType l_dataModel [MAX_BEATS]
);
  (
    (!dataValid && complete) throughout retry[-1] )
    or
    (
      (!retry && !(dataValid && complete))[*]
      ##1 dataValid && complete
      ##0 first_match(##[0:1] retry)
    )
    |=> p_check_data_xfer(l_dataModel);
endproperty

property p_retry_check_non_rec;
  dataType l_dataModel [MAX_BEATS];
  (start, l_dataModel = dataModel)
  |=>
  sync_reject_on(start)
  (
    p_check_data_xfer(l_dataModel)
    and
    p_check_retried_data_xfer(l_dataModel)
  );
endproperty

a_retry_check_non_rec: assert property(p_retry_check_non_rec);
```

The image contains Verilog code defining several properties for what appears to be a retry protocol. The properties seem to be doing some sort of verification using assertions about data transfers and their validity in relation to retries. There are also non-recursive checks for the protocol.","
property p_check_data_xfer(
  local input dataType l_dataModel [MAX_BEATS]
);
  int unsigned j = 0;
  (
    (!retry && !(dataValid && complete))
    throughout dataValid[-1],
    [>*]
    ##1 (!(retry && !dataValid)[*]
    ##1 (dataValid, j++)
    |->
    (
      j <= MAX_BEATS
      and data == l_dataModel[j-1]
      and if (!retry && complete)
        nexttime !dataValid
    )
  );
endproperty

property p_check_retried_data_xfer(
  local input dataType l_dataModel [MAX_BEATS]
);
  (
    (!dataValid && complete) throughout retry[-1] )
    or
    (
      (!retry && !(dataValid && complete))[*]
      ##1 dataValid && complete
      ##0 first_match(##[0:1] retry)
    )
    |=> p_check_data_xfer(l_dataModel);
endproperty

property p_retry_check_non_rec;
  dataType l_dataModel [MAX_BEATS];
  (start, l_dataModel = dataModel)
  |=>
  sync_reject_on(start)
  (
    p_check_data_xfer(l_dataModel)
    and
    p_check_retried_data_xfer(l_dataModel)
  );
endproperty

a_retry_check_non_rec: assert property(p_retry_check_non_rec);
","""Verilog properties for nonrecursive encoding of retry protocol checks""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p402.jpg,True,"```verilog
switch (bit_val) {
    case '0': aval_ptr[group_num] = aval_ptr[group_num] & ~bit_mask;
              bval_ptr[group_num] = bval_ptr[group_num] & ~bit_mask;
              break;
    case '1': aval_ptr[group_num] = aval_ptr[group_num] | bit_mask;
              bval_ptr[group_num] = bval_ptr[group_num] & ~bit_mask;
              break;
    case 'z': aval_ptr[group_num] = aval_ptr[group_num] & ~bit_mask;
              bval_ptr[group_num] = bval_ptr[group_num] | bit_mask;
              break;
    case 'x': aval_ptr[group_num] = aval_ptr[group_num] | bit_mask;
              bval_ptr[group_num] = bval_ptr[group_num] | bit_mask;
              break;
}
```","
switch (bit_val) {
    case '0': aval_ptr[group_num] = aval_ptr[group_num] & ~bit_mask;
              bval_ptr[group_num] = bval_ptr[group_num] & ~bit_mask;
              break;
    case '1': aval_ptr[group_num] = aval_ptr[group_num] | bit_mask;
              bval_ptr[group_num] = bval_ptr[group_num] & ~bit_mask;
              break;
    case 'z': aval_ptr[group_num] = aval_ptr[group_num] & ~bit_mask;
              bval_ptr[group_num] = bval_ptr[group_num] | bit_mask;
              break;
    case 'x': aval_ptr[group_num] = aval_ptr[group_num] | bit_mask;
              bval_ptr[group_num] = bval_ptr[group_num] | bit_mask;
              break;
}
","A page from ""The Verilog PLI Handbook"" showing a switch-case example in Verilog and advice on coding efficiency.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p401.jpg,True,"The image contains Verilog code. Here it is:

```verilog
1. sequence s1(bit a, b, c);
     bit l_b;
     (a, l_b = b) throughout c[-:1];
   endsequence

2. sequence s2(bit a, b, c);
     bit l_b;
     a throughout (c, l_b = b) [-:1];
   endsequence

3. sequence s3;
     byte l_numBeats;
     (start, l_numBeats = numBeats) ##1
     (
       (dataValid[-:1]) [*l_numBeats] ##1 !dataValid[x]
       intersect
       complete[-:1]
     );
   endsequence

sequence s_illegal(local input bit l_a, l_b = l_a);
     bit l_c, l_d = l_c;
     (t, l_c = l_a) ##1 [l_a,l_b] != [l_c,l_d];
   endsequence
```

And here is the Property part of the code:

```verilog
1. sequence s1;
     byte l_v;
     a ##1 (b, l_v &= e);
   endsequence

2. property p2;
     byte l_v;
     (a, l_v = e)
     |-> 
     s_nexttime s_eventually (b == l_v);
   endproperty

3. property p3;
     byte l_v;
     (a, l_v = e)
     implies
     s_nexttime s_eventually (b == l_v);
   endproperty

4. property p4;
     bit [1:0] l_v = e;
```

This is a technical text discussing input and output with local variables in Verilog, along with the legality of specific local variable usage and local variable flow in sequence and property declarations.","
1. sequence s1(bit a, b, c);
     bit l_b;
     (a, l_b = b) throughout c[-:1];
   endsequence

2. sequence s2(bit a, b, c);
     bit l_b;
     a throughout (c, l_b = b) [-:1];
   endsequence

3. sequence s3;
     byte l_numBeats;
     (start, l_numBeats = numBeats) ##1
     (
       (dataValid[-:1]) [*l_numBeats] ##1 !dataValid[x]
       intersect
       complete[-:1]
     );
   endsequence

sequence s_illegal(local input bit l_a, l_b = l_a);
     bit l_c, l_d = l_c;
     (t, l_c = l_a) ##1 [l_a,l_b] != [l_c,l_d];
   endsequence


1. sequence s1;
     byte l_v;
     a ##1 (b, l_v &= e);
   endsequence

2. property p2;
     byte l_v;
     (a, l_v = e)
     |-> 
     s_nexttime s_eventually (b == l_v);
   endproperty

3. property p3;
     byte l_v;
     (a, l_v = e)
     implies
     s_nexttime s_eventually (b == l_v);
   endproperty

4. property p4;
     bit [1:0] l_v = e;
","""Examples of Verilog sequences and properties highlighting the use of local variables and their legality in digital design verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p416.jpg,True,"The image contains an example of Verilog PLI (Programming Language Interface) code written in C language. Here's the code from the image:

```c
#include <stdio.h>           /* ANSI C standard I/O library */
#include ""veriuser.h""        /* IEEE 1364 PLI TF routine library */
/******************************************************************/
/* calltf routine                                                 */
/******************************************************************/
int PLIbook_ReadStimulusShort_calltf()
{
    /* call the misctf routine at the end of current */
    tf_setdelay(0);    /* time step, with REASON_REACTIVATE; the misctf */
    /* routine reads the stimulus file. */
    return(0);
}

/******************************************************************/
/* misctf routine                                                 */
/******************************************************************/
int PLIbook_ReadStimulusShort_misctf(int user_data, int reason)
{
    int delay, foo;
    FILE *file_p;               /* pointer to the test vector file */
    char vector[1024];          /* stimulus vector -- hard coded limit */

    switch(reason) {
        case REASON_ENDOFCOMPILE: /* misctf called at start of simulation */
            file_p = fopen(tf_getcstringp(1), ""r"");
            /* store a pointer to the file in the work area */
            tf_setworkarea((char *)file_p);
            break;

        case REASON_REACTIVATE:  /* misctf called by tf_setdelay */
            /* get the file pointer from the work area */
            file_p = (FILE *)tf_getworkarea();
            /* read next line from the file */
            if ( fscanf(file_p, ""%d %s\n"", &delay, vector) == EOF ){
                io_printf(""**read_stimulus reached end-of-file\n"");
                return(0);
            }
            break;

            /* schedule the vector to be applied after the delay period */
            tf_strdelputp(2, tf_sizep(2), 'b', vector, delay, 0);
            /* call this routine back after delay time */
            tf_setdelay(delay);
            break;
    }
}
```

This code is meant to be used with a Verilog simulation, by interfacing with C through the PLI to read stimulus data for the simulation.","ude <stdio.h>           /* ANSI C standard I/O library */
#include ""veriuser.h""        /* IEEE 1364 PLI TF routine library */
/******************************************************************/
/* calltf routine                                                 */
/******************************************************************/
int PLIbook_ReadStimulusShort_calltf()
{
    /* call the misctf routine at the end of current */
    tf_setdelay(0);    /* time step, with REASON_REACTIVATE; the misctf */
    /* routine reads the stimulus file. */
    return(0);
}

/******************************************************************/
/* misctf routine                                                 */
/******************************************************************/
int PLIbook_ReadStimulusShort_misctf(int user_data, int reason)
{
    int delay, foo;
    FILE *file_p;               /* pointer to the test vector file */
    char vector[1024];          /* stimulus vector -- hard coded limit */

    switch(reason) {
        case REASON_ENDOFCOMPILE: /* misctf called at start of simulation */
            file_p = fopen(tf_getcstringp(1), ""r"");
            /* store a pointer to the file in the work area */
            tf_setworkarea((char *)file_p);
            break;

        case REASON_REACTIVATE:  /* misctf called by tf_setdelay */
            /* get the file pointer from the work area */
            file_p = (FILE *)tf_getworkarea();
            /* read next line from the file */
            if ( fscanf(file_p, ""%d %s\n"", &delay, vector) == EOF ){
                io_printf(""**read_stimulus reached end-of-file\n"");
                return(0);
            }
            break;

            /* schedule the vector to be applied after the delay period */
            tf_strdelputp(2, tf_sizep(2), 'b', vector, delay, 0);
            /* call this routine back after delay time */
            tf_setdelay(delay);
            break;
    }
}
","Caption: ""Verilog PLI example showing how to read stimulus data using the tf_setdelay() routine.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p370.jpg,True,"```c
io_printf("" avalbits[%d] = %x\n"", i, val_array[i].avalbits);
io_printf("" bvalbits[%d] = %x\n"", i, val_array[i].bvalbits);
```","intf("" avalbits[%d] = %x\n"", i, val_array[i].avalbits);
io_printf("" bvalbits[%d] = %x\n"", i, val_array[i].bvalbits);
","The image displays a page from ""The Verilog PLI Handbook, Part Two"" illustrating the use of the `tf_propagatep` routine to write and propagate 4-state logic values to function arguments in Verilog simulations.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p400.jpg,True,"The image contains a snippet of code in C that is related to accessing memory word bits efficiently within the context of the Verilog Programming Language Interface (PLI). Here is the code transcribed from the image:

```c
void PLIbook_DumpMemBin(p_tfnodeinfo node_info)
{
    char *aval_ptr, *bval_ptr;
    int word_increment, mem_address, word_bit;
    char aval_val, bval_val;

    io_printf("" Current memory contents in binary are:\n"");

    word_increment = node_info->node_ngroups * 2; /* 1 word = aval/bval pair */
    for (mem_address = 0;
         mem_address < node_info->node_mem_size;
         mem_address++)
    {
        /* set pointers to aval and bval words for the address */
        aval_ptr = node_info->node_value.memoryval_p
                 + (mem_address * word_increment);
        bval_ptr = aval_ptr + node_info->node_ngroups;

        /* print groups in word in reverse order so will match Verilog:
           the highest group number represents the left-most byte of a
           Verilog word, the lowest group represents the right-most byte */
        for (word_bit = node_info->node_vec_size - 1;
             word_bit >= 0;
             word_bit--)
        {
            aval_val = (aval_ptr[word_bit >> 3]) & (1 << (word_bit & 0x7));
            bval_val = (bval_ptr[word_bit >> 3]) & (1 << (word_bit & 0x7));

            /* translate aval/bval pair to 4-state logic value */
            if (!bval_val) {
                if (!aval_val)
                    io_printf(""0""); /* aval/bval == 0/0 */
                else
                    io_printf(""1""); /* aval/bval == 1/0 */
            }
            else {
                if (!aval_val)
                    io_printf(""Z""); /* aval/bval == 0/1 */
                else
                    io_printf(""X""); /* aval/bval == 1/1 */
            }
        }
        io_printf(""\n"");
    }
    return;
}
```

This function seems to print the current memory contents in a binary representation, translating the `aval` and `bval` pairs to a 4-state logic value commonly used in digital circuit simulation (0, 1, Z, X).","PLIbook_DumpMemBin(p_tfnodeinfo node_info)
{
    char *aval_ptr, *bval_ptr;
    int word_increment, mem_address, word_bit;
    char aval_val, bval_val;

    io_printf("" Current memory contents in binary are:\n"");

    word_increment = node_info->node_ngroups * 2; /* 1 word = aval/bval pair */
    for (mem_address = 0;
         mem_address < node_info->node_mem_size;
         mem_address++)
    {
        /* set pointers to aval and bval words for the address */
        aval_ptr = node_info->node_value.memoryval_p
                 + (mem_address * word_increment);
        bval_ptr = aval_ptr + node_info->node_ngroups;

        /* print groups in word in reverse order so will match Verilog:
           the highest group number represents the left-most byte of a
           Verilog word, the lowest group represents the right-most byte */
        for (word_bit = node_info->node_vec_size - 1;
             word_bit >= 0;
             word_bit--)
        {
            aval_val = (aval_ptr[word_bit >> 3]) & (1 << (word_bit & 0x7));
            bval_val = (bval_ptr[word_bit >> 3]) & (1 << (word_bit & 0x7));

            /* translate aval/bval pair to 4-state logic value */
            if (!bval_val) {
                if (!aval_val)
                    io_printf(""0""); /* aval/bval == 0/0 */
                else
                    io_printf(""1""); /* aval/bval == 1/0 */
            }
            else {
                if (!aval_val)
                    io_printf(""Z""); /* aval/bval == 0/1 */
                else
                    io_printf(""X""); /* aval/bval == 1/1 */
            }
        }
        io_printf(""\n"");
    }
    return;
}
",Verilog PLI function for dumping memory contents in binary with efficient memory bit access.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p417.jpg,True,"```verilog
property confounding;
   nexttime not confounding;
endproperty
```

The image also includes a logical expression which is not Verilog code but related to logical operators in the context of Systems Verilog Assertions (SVA) semantics:

```
s_eventually p ≡ not always not p
```","
property confounding;
   nexttime not confounding;
endproperty

tually p ≡ not always not p
","""Explanation of restrictions on negation and strong operators with an example property in Verilog SVA.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p198.jpg,True,"The image contains an example of a covergroup definition written in Verilog. Here is the code extracted from the image:

```verilog
enum {s1,s2,s3,s4,s5} state_e, nstate_e;

covergroup CSM @(posedge clk);
  coverpoint state_e {
    bins state1 = (s1);
    bins state2 = (s2);
    bins state3 = (s3);
    bins state4 = (s4);
    bins state5 = (s5);
    bins st1_3_5 = (s1=>s3=>s5);
    bins st5_1   = (s5=>s1);
  }
endgroup
```

The code snippet defines an enumerated type `state_e` and a covergroup `CSM` with a coverpoint `state_e` that describes several bins to track transitions between states for functional coverage in a hardware description.","
enum {s1,s2,s3,s4,s5} state_e, nstate_e;

covergroup CSM @(posedge clk);
  coverpoint state_e {
    bins state1 = (s1);
    bins state2 = (s2);
    bins state3 = (s3);
    bins state4 = (s4);
    bins state5 = (s5);
    bins st1_3_5 = (s1=>s3=>s5);
    bins st5_1   = (s5=>s1);
  }
endgroup
","""Discussion on covergroup reporting behavior in SystemVerilog with an example of state machine coverage bins.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p366.jpg,True,"The image contains a code snippet written in C that is interfacing with Verilog code using the Programming Language Interface (PLI). Here's the code from the image:

```c
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
int PLIbook_exprinfoTest_calltf()
{
    s_tfexprinfo info_s; /* structure for tf_exprinfo() */
    p_vecval val_array; /* pointer to value array in info struct */
    int i;

    tf_exprinfo(1, &info_s); /* read expression info for arg 1 */

    io_printf(""Expression info:\n"");
    switch (info_s.expr_type) {
        case TF_NULLPARAM: io_printf("" type = TF_NULLPARAM\n""); break;
        case TF_STRING: io_printf("" type = TF_STRING\n""); break;
        case TF_READONLY: io_printf("" type = TF_READONLY\n""); break;
        case TF_READONLYREAL: io_printf("" type = TF_READONLYREAL\n""); break;
        case TF_READWRITEX: io_printf("" type = TF_READWRITEX\n""); break;
        case TF_READWRITEAREAL: io_printf("" type = TF_READWRITEAREAL\n""); break;
        case TF_RWBITSELECT: io_printf("" type = TF_RWBITSELECT\n""); break;
        case TF_RWPARTSELECT: io_printf("" type = TF_RWPARTSELECT\n""); break;
        case TF_RWMEMSELECT: io_printf("" type = TF_RWMEMSELECT\n""); break;
        default: io_printf("" type is unknown (%d)\n"", info_s.expr_type);
    }
}
```

The function `PLIbook_exprinfoTest_calltf()` is a C function using the PLI to access information about expressions within a Verilog simulation environment. The structure `s_tfexprinfo` is populated with information about an expression argument to a Verilog task or function, and then a switch statement is used to print out the type of the expression (string, read-only, read-write, etc.) based on the `expr_type` member of the structure.","ude ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
int PLIbook_exprinfoTest_calltf()
{
    s_tfexprinfo info_s; /* structure for tf_exprinfo() */
    p_vecval val_array; /* pointer to value array in info struct */
    int i;

    tf_exprinfo(1, &info_s); /* read expression info for arg 1 */

    io_printf(""Expression info:\n"");
    switch (info_s.expr_type) {
        case TF_NULLPARAM: io_printf("" type = TF_NULLPARAM\n""); break;
        case TF_STRING: io_printf("" type = TF_STRING\n""); break;
        case TF_READONLY: io_printf("" type = TF_READONLY\n""); break;
        case TF_READONLYREAL: io_printf("" type = TF_READONLYREAL\n""); break;
        case TF_READWRITEX: io_printf("" type = TF_READWRITEX\n""); break;
        case TF_READWRITEAREAL: io_printf("" type = TF_READWRITEAREAL\n""); break;
        case TF_RWBITSELECT: io_printf("" type = TF_RWBITSELECT\n""); break;
        case TF_RWPARTSELECT: io_printf("" type = TF_RWPARTSELECT\n""); break;
        case TF_RWMEMSELECT: io_printf("" type = TF_RWMEMSELECT\n""); break;
        default: io_printf("" type is unknown (%d)\n"", info_s.expr_type);
    }
}
","""Example of Verilog PLI for reading 4-state logic values using tf_exprinfo()""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p365.jpg,True,"Here is the Verilog code from the image:

```verilog
typedef bit [0:`$clog2(MAX_OUTSTANDING)] counterType;
property p_fifo_data_check(local input counterType numAhead);
  dataType data = dataIn;
  ##1 (numAhead > 0 ##0 complete[-1], numAhead--) [*0]
  ##1 (numAhead == 0 ##0 complete[-1])
  |->
  dataOut == data;
endproperty

property p_fifo_all_checks;
  counterType outstanding, nextOutstanding = '0;
  (
    (start || complete) [-1],
    outstanding = nextOutstanding,
    nextOutstanding += start - complete
  ) [+]
  |->
  if (start) {
    (!complete && outstanding < MAX_OUTSTANDING)
    and p_fifo_data_check(.numAhead(outstanding))
  } else { // complete
    !start && outstanding > 0
  };
endproperty

initial
  a_fifo_all_checks: assert property (p_fifo_all_checks);
```

Note: the `$clog2` directive is meant to compute the ceiling log base 2, however, in the code provided, it is used with a dollar sign and should likely be `clog2` without the dollar sign (as `$clog2` suggests it might have been intended as a system task). Additionally, since the image does not provide the definitions of `dataType`, `dataIn`, `complete`, `dataOut`, `start`, and `MAX_OUTSTANDING`, certain context is missing which is essential for understanding the full functionality of this property.","
typedef bit [0:`$clog2(MAX_OUTSTANDING)] counterType;
property p_fifo_data_check(local input counterType numAhead);
  dataType data = dataIn;
  ##1 (numAhead > 0 ##0 complete[-1], numAhead--) [*0]
  ##1 (numAhead == 0 ##0 complete[-1])
  |->
  dataOut == data;
endproperty

property p_fifo_all_checks;
  counterType outstanding, nextOutstanding = '0;
  (
    (start || complete) [-1],
    outstanding = nextOutstanding,
    nextOutstanding += start - complete
  ) [+]
  |->
  if (start) {
    (!complete && outstanding < MAX_OUTSTANDING)
    and p_fifo_data_check(.numAhead(outstanding))
  } else { // complete
    !start && outstanding > 0
  };
endproperty

initial
  a_fifo_all_checks: assert property (p_fifo_all_checks);
","""Verilog code snippet demonstrating an encoding of the FIFO protocol checks with local variables.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p372.jpg,True,"The image contains Verilog PLI (Programming Language Interface) code. Here it is:

```c
/*******************************************************************************
 * calltf application
 ******************************************************************************/

/* prototype for subroutine used by calltf routine */
void PLIbook_Print4stateValue();

int PLIbook_propagateTest_calltf()
{
    p_tfexprinfo info_p;     /* pointer to structure for tf_exprinfo() */

    info_p = (p_tfexprinfo)tf_getworkarea(); /* retrieve info pointer */

    io_printf(""propagate_test called at time %d to read & modify arg value\n"",
              tf_gettime());

    /* read current value of argument 1 */
    io_printf("" current value:\n"");
    tf_evaluate(1);
    PLIbook_Print4stateValue(info_p);

    /* modify value of argument 1 */
    switch (info_p->expr_type) {
        case TF_READWRITE:
        case TF_RWBITSELECT:
        case TF_RWPARTSELECT:
        case TF_RWMEMSELECT:
            info_p->expr_value_p[0].avalbits++;
            info_p->expr_value_p[0].bvalbits = 0;
            break;
        case TF_READWRITEREAL:
            info_p->real_value++;
            break;
    }
    tf_propagatep(1);

    /* read new value of argument 1 */
    io_printf("" new value:\n"");
    tf_evaluate(1);
    PLIbook_Print4stateValue(info_p);

    return(0);
}

void PLIbook_Print4stateValue(p_tfexprinfo info_p)
{
    int i;

    switch (info_p->expr_type) {
        case TF_READWRITEREAL:
            io_printf("" real value = %0.1f\n"", info_p->real_value); break;
        case TF_READWRITE:
        case TF_RWBITSELECT:
        case TF_RWPARTSELECT:
    }
}
```

This code is related to the Verilog Programming Language Interface and is written in C. It involves a calltf function named `PLIbook_propagateTest_calltf` which is used to read and modify the value of a Verilog module argument from within a PLI application. There is also a helper function `PLIbook_Print4stateValue` which prints the value of the argument.","***************************************************************************
 * calltf application
 ******************************************************************************/

/* prototype for subroutine used by calltf routine */
void PLIbook_Print4stateValue();

int PLIbook_propagateTest_calltf()
{
    p_tfexprinfo info_p;     /* pointer to structure for tf_exprinfo() */

    info_p = (p_tfexprinfo)tf_getworkarea(); /* retrieve info pointer */

    io_printf(""propagate_test called at time %d to read & modify arg value\n"",
              tf_gettime());

    /* read current value of argument 1 */
    io_printf("" current value:\n"");
    tf_evaluate(1);
    PLIbook_Print4stateValue(info_p);

    /* modify value of argument 1 */
    switch (info_p->expr_type) {
        case TF_READWRITE:
        case TF_RWBITSELECT:
        case TF_RWPARTSELECT:
        case TF_RWMEMSELECT:
            info_p->expr_value_p[0].avalbits++;
            info_p->expr_value_p[0].bvalbits = 0;
            break;
        case TF_READWRITEREAL:
            info_p->real_value++;
            break;
    }
    tf_propagatep(1);

    /* read new value of argument 1 */
    io_printf("" new value:\n"");
    tf_evaluate(1);
    PLIbook_Print4stateValue(info_p);

    return(0);
}

void PLIbook_Print4stateValue(p_tfexprinfo info_p)
{
    int i;

    switch (info_p->expr_type) {
        case TF_READWRITEREAL:
            io_printf("" real value = %0.1f\n"", info_p->real_value); break;
        case TF_READWRITE:
        case TF_RWBITSELECT:
        case TF_RWPARTSELECT:
    }
}
","""Example of Verilog PLI code for manipulating and printing state values.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p369.jpg,True,"```verilog
program automatic test(busifc.TB ifc);

  class Transaction;
    rand bit [31:0] data;
    rand bit [ 2:0] dst;  // Eight dst port numbers
  endclass

  Transaction tr;  // Transaction to be sampled

  covergroup CovDst2;
    coverpoint tr.dst;  // Measure coverage
  endgroup

  initial begin
    CovDst2 ck;  // Instantiate group
    ck = new();  // Run a few cycles
    repeat (32) begin  // Wait a cycle
      @ifc.cb;
      tr = new();
      `SV_RAND_CHECK(tr.randomize());  // Create a transaction
      ifc.cb.dst <= tr.dst;            // and transmit
      ifc.cb.data <= tr.data;          // onto interface
      ck.sample();                     // Gather coverage
    end
  end

endprogram
```","
program automatic test(busifc.TB ifc);

  class Transaction;
    rand bit [31:0] data;
    rand bit [ 2:0] dst;  // Eight dst port numbers
  endclass

  Transaction tr;  // Transaction to be sampled

  covergroup CovDst2;
    coverpoint tr.dst;  // Measure coverage
  endgroup

  initial begin
    CovDst2 ck;  // Instantiate group
    ck = new();  // Run a few cycles
    repeat (32) begin  // Wait a cycle
      @ifc.cb;
      tr = new();
      `SV_RAND_CHECK(tr.randomize());  // Create a transaction
      ifc.cb.dst <= tr.dst;            // and transmit
      ifc.cb.data <= tr.data;          // onto interface
      ck.sample();                     // Gather coverage
    end
  end

endprogram
","""Example Verilog code demonstrating a simple functional coverage test program for transaction-based verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p139.jpg,True,"Here is the Verilog code present in the image:

```verilog
sequence $ab;
  a ##[0:$] b;
endsequence

property ab;
  @(posedge clk) |-> $ab;
endproperty
```

These code snippets demonstrate the usage of the clock delay range operator `##[m:n]` and how to define a sequence and a property in Verilog. The discussion in the image is about how to use the clock delay range operator to express a delay from '0' to an infinite amount of time, which means that 'b' can be true at any time from the clock edge when 'a' is true until the end of the simulation. The text also indicates that the property will match the very first time 'b' is true.","
sequence $ab;
  a ##[0:$] b;
endsequence

property ab;
  @(posedge clk) |-> $ab;
endproperty
","""Explanation of Verilog clock delay range operators with a code example and simulation output.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p427.jpg,True,"The image contains a section of a book that describes Testbench Blocks and includes a Verilog code snippet that defines an Environment class. Here is the code:

```verilog
class Environment;
  UNIT_generator gen[1];
  mailbox gen2drv[1];
  event drv2gen[1];
  Driver drv[1];
  Monitor mon[1];
  Config cfg;
  Scoreboard scb;
  Coverage cov;
  virtual Utopia_TB_Rx Rx [1];
  virtual Utopia_TB_Tx Tx [1];
  int numRx, numTx;
  vCPU_T mif;
  CPU_driver cpu;

  extern function new(input vUtopiaRx Rx [1],
                      input vUtopiaTx Tx [1],
                      input int numRx, numTx,
                      input vCPU_T mif);
  extern virtual function void gen_cfg();
  extern virtual function void build();
  extern virtual function task run();
  extern virtual function void wrap_up();

endclass : Environment
```

This code defines an Environment class with various members such as generators, mailboxes, events, drivers, monitors, and others. It also declares external functions that would be defined elsewhere to handle creating a new instance, configuration generation, system building, running a test, and wrapping up. Please note that this code might be incomplete and is part of explanatory material in the book. The class name `UNIT_generator`, `Driver`, `Monitor`, `Config`, `Scoreboard`, `Coverage`, and `CPU_driver` refer to components that would typically be defined elsewhere in the testbench codebase. The `vCPU_T`, `vUtopiaRx`, and `vUtopiaTx` types are likely virtual interfaces or some other custom-defined types.","
class Environment;
  UNIT_generator gen[1];
  mailbox gen2drv[1];
  event drv2gen[1];
  Driver drv[1];
  Monitor mon[1];
  Config cfg;
  Scoreboard scb;
  Coverage cov;
  virtual Utopia_TB_Rx Rx [1];
  virtual Utopia_TB_Tx Tx [1];
  int numRx, numTx;
  vCPU_T mif;
  CPU_driver cpu;

  extern function new(input vUtopiaRx Rx [1],
                      input vUtopiaTx Tx [1],
                      input int numRx, numTx,
                      input vCPU_T mif);
  extern virtual function void gen_cfg();
  extern virtual function void build();
  extern virtual function task run();
  extern virtual function void wrap_up();

endclass : Environment
",Sample of a SystemVerilog environment class header for testbench blocks.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p84.jpg,True,"The image contains Verilog code. Here is the code excerpt from the image:

```verilog
always @(m, n) // combinatorial sensitivity list (no clock edge)
    m <= m + n; // GOTCHA! schedules change after clock-to-Q delta
```

This code is given as an example of a non-blocking assignment used incorrectly inside a combinatorial logic block, leading to a potential simulation lock-up.","
always @(m, n) // combinatorial sensitivity list (no clock edge)
    m <= m + n; // GOTCHA! schedules change after clock-to-Q delta
","Caption: Discussion on the risks of using nonblocking assignments in combinational logic in Verilog, which can lead to simulation lock-up due to infinite loops.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p341.jpg,True,"```verilog
parameter int SIZE = 100;
class IntStack;
  local int stack[SIZE];             // Holds data values
  local int top;

  function void push(input int i);   // Push value on top
    stack[top++] = i;
  endfunction : push

  function int pop();                // Remove value from top
    return stack[--top];
  endfunction

endclass : IntStack
```","
parameter int SIZE = 100;
class IntStack;
  local int stack[SIZE];             // Holds data values
  local int top;

  function void push(input int i);   // Push value on top
    stack[top++] = i;
  endfunction : push

  function int pop();                // Remove value from top
    return stack[--top];
  endfunction

endclass : IntStack
",A sample Verilog code for implementing a stack data structure with push and pop functions.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p355.jpg,True,"The image includes a section of code written in Verilog/SystemVerilog. Here is the code:

```verilog
class svm_component_registry #(type T=svm_component,
                               string Tname=""<unknown>"")
    extends svm_object_wrapper;
    
    typedef svm_component_registry #(T,Tname) this_type;

    virtual function string get_type_name();
        return Tname;
    endfunction

    local static this_type me = get(); // Handle to singleton

    static function this_type get();
        if (me == null) begin                       // Is there an instance?
            svm_factory f = svm_factory::get();     // Build factory
            me = new();                             // Build the singleton
            f.register(me);                         // Register class
        end
        return me;
    endfunction

    virtual function svm_object create_object (string name="""");
        T obj;
        obj = new(name);
        return obj;
    endfunction

    static function T create(string name);
        create = new(name);
    endfunction

endclass : svm_component_registry
```

This code snippet is an example of a parameterized proxy class for use in a SystemVerilog verification environment.","
class svm_component_registry #(type T=svm_component,
                               string Tname=""<unknown>"")
    extends svm_object_wrapper;
    
    typedef svm_component_registry #(T,Tname) this_type;

    virtual function string get_type_name();
        return Tname;
    endfunction

    local static this_type me = get(); // Handle to singleton

    static function this_type get();
        if (me == null) begin                       // Is there an instance?
            svm_factory f = svm_factory::get();     // Build factory
            me = new();                             // Build the singleton
            f.register(me);                         // Register class
        end
        return me;
    endfunction

    virtual function svm_object create_object (string name="""");
        T obj;
        obj = new(name);
        return obj;
    endfunction

    static function T create(string name);
        create = new(name);
    endfunction

endclass : svm_component_registry
","""Example of a parameterized proxy class in SystemVerilog for a component registry.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p359.jpg,True,"The image contains a snippet of Verilog code from a book or document. Here is the code extracted from the image:

```verilog
property p_fifo_data_check;
  dataType data;
  bit [0:$clog2(MAX_OUTSTANDING)] numAhead;
  @(start, data = dataIn, numAhead = outstanding)
  ##1 (numAhead > 0 ##0 complete[-1], numAhead--) [*]
  ##1 (numAhead == 0 ##0 complete[-1])
  |-> dataOut == data;
endproperty
a_fifo_data_check: assert property (p_fifo_data_check);
```

This appears to be a SystemVerilog property definition that is meant to be used in a formal verification environment to check the correctness of a FIFO (First-In-First-Out) data structure implementation. It uses local variables and sequence repetition to express complex timing relationships.","
property p_fifo_data_check;
  dataType data;
  bit [0:$clog2(MAX_OUTSTANDING)] numAhead;
  @(start, data = dataIn, numAhead = outstanding)
  ##1 (numAhead > 0 ##0 complete[-1], numAhead--) [*]
  ##1 (numAhead == 0 ##0 complete[-1])
  |-> dataOut == data;
endproperty
a_fifo_data_check: assert property (p_fifo_data_check);
",Verilog property example for checking FIFO data integrity using local variables.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p90.jpg,True,"The image contains Verilog code. Here is the code extract from the image:

```verilog
always_comb begin
  casex (instruction)                // potential GOTCHA!
    4'b0???: opcode = instruction[2:0]; // only test upper bit
    4'b1000: opcode = 3'b001; 
    ... // decode other valid instructions
    default: begin
      $display (""ERROR: invalid instruction!"");
      opcode = 3'bx;
    end
  endcase
end
```
","
always_comb begin
  casex (instruction)                // potential GOTCHA!
    4'b0???: opcode = instruction[2:0]; // only test upper bit
    4'b1000: opcode = 3'b001; 
    ... // decode other valid instructions
    default: begin
      $display (""ERROR: invalid instruction!"");
      opcode = 3'bx;
    end
  endcase
end
","""Explaining the use of casex and casez statements in Verilog with a potential gotcha in case expression masking.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p194.jpg,True,"```verilog
`ifdef ASSERT_ON

reg trans_ok;

always @(read or write or burst or size or wt)
  casez({read, write, burst, size, wt})
    6'b1_0_1_00_?, // cache (burst) read.
    6'b0_1_0_00_?, // single byte read
    6'b1_0_0_01_?, // halfword read
    6'b0_1_0_11_?, // word read
    6'b0_1_1_00_0, // cache (burst) write
    6'b0_1_0_00_0, // single byte write
    6'b0_1_0_01_0, // halfword write
    6'b0_1_1_01_0, // word write
    6'b0_1_0_00_1, // single byte writethru
    6'b0_1_0_01_1, // halfword writethru
    6'b0_1_0_11_1, // word writethru
    6'b0_0_0_00_0: // nothing,
                    trans_ok = 1'b1;
    default:        trans_ok = 1'b0;
  endcase

// OVL assertion
assert_always illegal_mem_req (clk, reset_n, trans_ok);

`ifdef ASSERT_OFF
```","
`ifdef ASSERT_ON

reg trans_ok;

always @(read or write or burst or size or wt)
  casez({read, write, burst, size, wt})
    6'b1_0_1_00_?, // cache (burst) read.
    6'b0_1_0_00_?, // single byte read
    6'b1_0_0_01_?, // halfword read
    6'b0_1_0_11_?, // word read
    6'b0_1_1_00_0, // cache (burst) write
    6'b0_1_0_00_0, // single byte write
    6'b0_1_0_01_0, // halfword write
    6'b0_1_1_01_0, // word write
    6'b0_1_0_00_1, // single byte writethru
    6'b0_1_0_01_1, // halfword writethru
    6'b0_1_0_11_1, // word writethru
    6'b0_0_0_00_0: // nothing,
                    trans_ok = 1'b1;
    default:        trans_ok = 1'b0;
  endcase

// OVL assertion
assert_always illegal_mem_req (clk, reset_n, trans_ok);

`ifdef ASSERT_OFF
","""Example of Verilog code implementing a Valid Signal Combination Check""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p428.jpg,True,"```c
case REASON_SAVE: /* miscft called for $save */

/* get the pointer to the application data from the work area */
data_p = (PLIbook_stim_data_p)tf_getworkarea();

/* save current file position in the application data */
data_p->file_position = ftell(data_p->file_ptr);

/* add application data to simulation save file */
tf_write_save((char *)data_p, sizeof(PLIbook_stim_data_s));
if (debug)
    io_printf(""\nPLI data saved (last file position was %ld)\n\n"",
              data_p->file_position);

break;

case REASON_RESTART: /* miscft called end of simulation */

/* re-allocate memory for PLI application data */
data_p=(PLIbook_stim_data_p)malloc(sizeof(PLIbook_stim_data_s));

/* save new application data pointer in work area */
tf_setworkarea((char *)data_p);

/* retrieve old application data from save file */
if (!tf_read_restart((char *)data_p,
                     sizeof(PLIbook_stim_data_s))) {
    tf_error(""\nError retrieving PLI data from save file!\n"");
    return(0);
}
if (debug) {
    io_printf(""\nPLI data retrieved from save file.\n"");
    /* test to see if old application data was restored */
    io_printf("" dummy message = %s, file position = %ld\n\n"",
              data_p->dummy_msg, data_p->file_position);
}

/* re-open test vector file */
data_p->file_ptr = fopen(tf_getcstringp(1), ""r"");
if (!data_p->file_ptr) {
    tf_error(""%read_stimulus_?? could not re-open file %s"",
             tf_getcstringp(1));
    tf_dofinish(); /* exit simulation if cannot open file */
}

/* re-position file to next test vector to be read */
if (fseek(data_p->file_ptr, data_p->file_position, SEEK_SET)) {
    tf_error(""%read_stimulus_?? could not reposition file"");
    tf_dofinish(); /* exit simulation if reposition open file */
}

break;
}
return(0);
```","REASON_SAVE: /* miscft called for $save */

/* get the pointer to the application data from the work area */
data_p = (PLIbook_stim_data_p)tf_getworkarea();

/* save current file position in the application data */
data_p->file_position = ftell(data_p->file_ptr);

/* add application data to simulation save file */
tf_write_save((char *)data_p, sizeof(PLIbook_stim_data_s));
if (debug)
    io_printf(""\nPLI data saved (last file position was %ld)\n\n"",
              data_p->file_position);

break;

case REASON_RESTART: /* miscft called end of simulation */

/* re-allocate memory for PLI application data */
data_p=(PLIbook_stim_data_p)malloc(sizeof(PLIbook_stim_data_s));

/* save new application data pointer in work area */
tf_setworkarea((char *)data_p);

/* retrieve old application data from save file */
if (!tf_read_restart((char *)data_p,
                     sizeof(PLIbook_stim_data_s))) {
    tf_error(""\nError retrieving PLI data from save file!\n"");
    return(0);
}
if (debug) {
    io_printf(""\nPLI data retrieved from save file.\n"");
    /* test to see if old application data was restored */
    io_printf("" dummy message = %s, file position = %ld\n\n"",
              data_p->dummy_msg, data_p->file_position);
}

/* re-open test vector file */
data_p->file_ptr = fopen(tf_getcstringp(1), ""r"");
if (!data_p->file_ptr) {
    tf_error(""%read_stimulus_?? could not re-open file %s"",
             tf_getcstringp(1));
    tf_dofinish(); /* exit simulation if cannot open file */
}

/* re-position file to next test vector to be read */
if (fseek(data_p->file_ptr, data_p->file_position, SEEK_SET)) {
    tf_error(""%read_stimulus_?? could not reposition file"");
    tf_dofinish(); /* exit simulation if reposition open file */
}

break;
}
return(0);
","""Excerpt from The Verilog PLI Handbook demonstrating Verilog PLI code for saving and restoring simulation state.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p433.jpg,True,"The image contains code from a book describing SystemVerilog code syntax. Here is the visible code from the image:

```systemverilog
class Config;
  int nErrors, nWarnings; // Number of errors, warnings
  bit [31:0] numRx, numTx; // Copy of parameters
  
  rand bit [31:0] nCells; // Total cells
  constraint c_nCells_valid
    {nCells > 0; }
  constraint c_nCells_reasonable
    {nCells < 1000; }

  rand bit in_use_Rx[];
  constraint c_in_use_valid
    {in_use_Rx.sum() > 0; } // At least one RX is enabled

  rand bit [31:0] cells_per_chan[];
  constraint c_sum_ncells_sum // Split cells over all channels
    {cells_per_chan.sum() == nCells;} // Total number of cells

  // Set the cell count to zero for any channel not in use
  constraint zero_unused_channels
  {
    foreach (cells_per_chan[i])
    {
      // Needed for even dist of in_use
      solve in_use_Rx[i] before cells_per_chan[i];
      if (in_use_Rx[i])
        cells_per_chan[i] inside { [1:nCells] };
      else cells_per_chan[i] == 0;
    }
  }

  extern function new(input bit [31:0] numRx, numTx);
  extern virtual function void display(input string prefix="""");
endclass : Config

typedef struct packed {
  bit [‘TxPorts-1:0] FWD;
  bit [11:0] VPI;
} CellCfgType;
```

Please note that there are small errors in the code due to OCR-related inaccuracies from the image. For example, where it says ‘TxPorts-1:0’, it most likely should be ‘TxPorts-1:0' with backticks indicating a macro or define in SystemVerilog. Also, note that actual code may include elements not displayed in the image, and comments may not be complete.","erilog
class Config;
  int nErrors, nWarnings; // Number of errors, warnings
  bit [31:0] numRx, numTx; // Copy of parameters
  
  rand bit [31:0] nCells; // Total cells
  constraint c_nCells_valid
    {nCells > 0; }
  constraint c_nCells_reasonable
    {nCells < 1000; }

  rand bit in_use_Rx[];
  constraint c_in_use_valid
    {in_use_Rx.sum() > 0; } // At least one RX is enabled

  rand bit [31:0] cells_per_chan[];
  constraint c_sum_ncells_sum // Split cells over all channels
    {cells_per_chan.sum() == nCells;} // Total number of cells

  // Set the cell count to zero for any channel not in use
  constraint zero_unused_channels
  {
    foreach (cells_per_chan[i])
    {
      // Needed for even dist of in_use
      solve in_use_Rx[i] before cells_per_chan[i];
      if (in_use_Rx[i])
        cells_per_chan[i] inside { [1:nCells] };
      else cells_per_chan[i] == 0;
    }
  }

  extern function new(input bit [31:0] numRx, numTx);
  extern virtual function void display(input string prefix="""");
endclass : Config

typedef struct packed {
  bit [‘TxPorts-1:0] FWD;
  bit [11:0] VPI;
} CellCfgType;
","""Sample of a SystemVerilog environment configuration class with constraints and methods""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p105.jpg,True,"The image contains Verilog code which demonstrates the use of `default disable iff` and examples of legal and illegal `disable iff` in assertions. Below is the code from the image:

```verilog
module examples (input logic a, b, clk, rst, rst1);

default disable iff rst; //Default disable condition is based on the signal `rst`
property p1;
    disable iff (rst1) a |=> b; //explicit declaration of disable iff in property p1
endproperty

// Disable condition is rst1 - explicitly specified within a1
a1 : assert property (@(posedge clk) disable iff (rst1) a |=> b);

// Disable condition is `rst1` - explicitly specified within p1
a2 : assert property (@(posedge clk) p1);

// Disable condition is `rst` - no explicit specification, inferred from default disable iff declaration
a3 : assert property (@(posedge clk) a |=> b);

endmodule
```

```verilog
module m_illegal_disable_nesting(logic reset, a, b, clk);
default clocking PCLK @(posedge clk); endclocking

property PCI_disable;
    disable iff (reset) IRDY |=> FRAME_;
```

These snippets discuss and exemplify the proper way to use `disable iff` clauses in assertions, and illustrate an illegal example of nesting `disable iff` conditions in Verilog. The illegal example is incomplete as it ends abruptly.","
module examples (input logic a, b, clk, rst, rst1);

default disable iff rst; //Default disable condition is based on the signal `rst`
property p1;
    disable iff (rst1) a |=> b; //explicit declaration of disable iff in property p1
endproperty

// Disable condition is rst1 - explicitly specified within a1
a1 : assert property (@(posedge clk) disable iff (rst1) a |=> b);

// Disable condition is `rst1` - explicitly specified within p1
a2 : assert property (@(posedge clk) p1);

// Disable condition is `rst` - no explicit specification, inferred from default disable iff declaration
a3 : assert property (@(posedge clk) a |=> b);

endmodule


module m_illegal_disable_nesting(logic reset, a, b, clk);
default clocking PCLK @(posedge clk); endclocking

property PCI_disable;
    disable iff (reset) IRDY |=> FRAME_;
","""Verilog code examples illustrating correct and illegal usage of nested 'disable iff' in assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p259.jpg,True,"```verilog
// Technique 2:
begin: Mod16_Counter
  forever
  begin
    Count = Count + 1;  // Count is an integer or wide reg.
    #5 Dbus[4:0] = Count%16; // This delay avoids hanging the simulator.
  end // Mod16_Counter.
  // (somewhere else, or in the loop, put disable Mod16_Counter)

always@(posedge Run)
  begin : RunClock1
    Clock1 = 1'b0;
    forever #10 Clock1 <= !Clock1;
  end
always@(negedge Run) disable RunClock1;

...

i = 0;
repeat (32)
  begin
    #2 Abus[i] = LocalAbus[i+32] + AdrOffset;
    i = i + 1;
  end
```","
// Technique 2:
begin: Mod16_Counter
  forever
  begin
    Count = Count + 1;  // Count is an integer or wide reg.
    #5 Dbus[4:0] = Count%16; // This delay avoids hanging the simulator.
  end // Mod16_Counter.
  // (somewhere else, or in the loop, put disable Mod16_Counter)

always@(posedge Run)
  begin : RunClock1
    Clock1 = 1'b0;
    forever #10 Clock1 <= !Clock1;
  end
always@(negedge Run) disable RunClock1;

...

i = 0;
repeat (32)
  begin
    #2 Abus[i] = LocalAbus[i+32] + AdrOffset;
    i = i + 1;
  end
","Caption: ""Exploring Verilog Coding Techniques for Clock Generators and Looping Constructs in Digital VLSI Design""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p47.jpg,True,"The image contains Verilog/SystemVerilog code. Here is the code:

```verilog
package chip_types;
  typedef enum logic [1:0] {RESET, HOLD, LOAD, READY} states_t;
endpackage

module chip (...);
  import chip_types::states_t;  // explicit import of states_t type
  states_t state_e, nstate_e;

  always_ff @(posedge clock, negedge reset_n)
    if (!reset_n) state_e <= RESET;  // GOTCHA: RESET not imported
    else state_e <= nstate_e;
  ...
endmodule
```

Additionally, the image lays out ways to avoid a gotcha related to importing enumerated types:

```verilog
// Explicit imports for each enumerated label
import chip_types::states_t;  // explicit import of states_t type
import chip_types::RESET;     // and its labels
import chip_types::HOLD;
import chip_types::LOAD;
import chip_types::READY;

// Wildcard import for all package declarations
import chip_types::*;  // wildcard import of package declarations
```

The text discusses a common issue where importing an enumerated type from a package does not import its labels, thus causing an error when the labels are used without proper import statements.","
package chip_types;
  typedef enum logic [1:0] {RESET, HOLD, LOAD, READY} states_t;
endpackage

module chip (...);
  import chip_types::states_t;  // explicit import of states_t type
  states_t state_e, nstate_e;

  always_ff @(posedge clock, negedge reset_n)
    if (!reset_n) state_e <= RESET;  // GOTCHA: RESET not imported
    else state_e <= nstate_e;
  ...
endmodule


// Explicit imports for each enumerated label
import chip_types::states_t;  // explicit import of states_t type
import chip_types::RESET;     // and its labels
import chip_types::HOLD;
import chip_types::LOAD;
import chip_types::READY;

// Wildcard import for all package declarations
import chip_types::*;  // wildcard import of package declarations
","Caption: ""Common pitfall in Verilog when importing enumerated types from packages without their labels and how to avoid it by explicit or wildcard import.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p143.jpg,True,"The image contains Verilog code, which I will provide below:

```verilog
assert_quiescent_state valid_state (ck,
                                    reset_n, controller_state[7:0],
                                    'CNTRL_START_STATE, 1'b0);
``` 

This is a code snippet showing an instantiation of an OVL (Open Verification Library) assertion to check for a specific state at the end of simulation in Verilog.","
assert_quiescent_state valid_state (ck,
                                    reset_n, controller_state[7:0],
                                    'CNTRL_START_STATE, 1'b0);
","Caption: ""Verilog OVL instantiated assertion example to check for an end-of-simulation condition.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p517.jpg,True,"The image contains some text and appears to be part of a textbook or instructional material for digital VLSI design with Verilog. There is a snippet of code provided which seems to be specifying arguments for a simulator file list for Verilog testbenches. The code provided in the image is:

```
TestBench.v
Intro_TopNetlist.v
-v tcbn90ghp_v2001.v
```

Above this code snippet, there is an explanation for making a new simulator file list, but no other code corresponding to Verilog design or testbenches.

Additionally, the image below the text shows a graphical waveform generated from a simulation, likely comparing the waveforms of the original design versus the synthesized netlist. However, this waveform is not code, so I will not transcribe it.","nch.v
Intro_TopNetlist.v
-v tcbn90ghp_v2001.v
","Caption: ""Illustrating the process of netlist synthesis from Verilog code and comparing the timing differences between the original Verilog source and the synthesized netlist using waveform diagrams.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p382.jpg,True,"The image contains multiple snippets of code related to Verilog or SystemVerilog for functional coverage. Here they are transcribed below:

The first code snippet (Sample 9.20):

```verilog
int i;
covergroup range_cover;
    coverpoint i {
        bins neg = {[:$-1]}; // Negative values
        bins zero = {0};     // Zero
        bins pos = {[1:$]};  // Positive values
    }
endgroup
```

The second code snippet (Sample 9.21):

```verilog
covergroup CovDst21;
    // Don't gather coverage when rst==1
    coverpoint tr.dst iff (!bus_if.rst);
endgroup
```

The third code snippet (Sample 9.22):

```verilog
initial begin
    CovDst22 ck = new();        // Instantiate cover group

    // Reset sequence stops collection of coverage data
    #1ns ck.stop();
    bus_if.rst = 1;

    #100ns bus_if.rst <= 0; // End of reset
    ck.start();
    ...
end
```

Please note that `...` generally indicates that the code continues beyond what is shown.","
int i;
covergroup range_cover;
    coverpoint i {
        bins neg = {[:$-1]}; // Negative values
        bins zero = {0};     // Zero
        bins pos = {[1:$]};  // Positive values
    }
endgroup


covergroup CovDst21;
    // Don't gather coverage when rst==1
    coverpoint tr.dst iff (!bus_if.rst);
endgroup


initial begin
    CovDst22 ck = new();        // Instantiate cover group

    // Reset sequence stops collection of coverage data
    #1ns ck.stop();
    bus_if.rst = 1;

    #100ns bus_if.rst <= 0; // End of reset
    ck.start();
    ...
end
","""Verilog Code Examples Illustrating Functional Coverage and Conditional Coverage Techniques""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p399.jpg,True,"The image contains snippets of text showing C code examples. Here is the code written in the image:

```c
aval_ptr = node_info->node_value.memoryval_p
          + (mem_address * word_increment);

bval_ptr = aval_ptr + node_info->node_value.ngroups;

aval_bit_value =
  (aval_ptr[word_bit >> 3]) & (1 << (word_bit & 0x7));

bval_bit_value =
  (bval_ptr[word_bit >> 3]) & (1 << (word_bit & 0x7));
```

These code snippets appear to demonstrate how to access individual bits of a memory word in C, a technique that might be used in conjunction with simulating or interfacing with Verilog hardware description language in a verification environment.","ptr = node_info->node_value.memoryval_p
          + (mem_address * word_increment);

bval_ptr = aval_ptr + node_info->node_value.ngroups;

aval_bit_value =
  (aval_ptr[word_bit >> 3]) & (1 << (word_bit & 0x7));

bval_bit_value =
  (bval_ptr[word_bit >> 3]) & (1 << (word_bit & 0x7));
",Efficient Bit Selection Technique in Verilog Using C Code Example,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p167.jpg,True,"The image contains Verilog code. Here it is:

```verilog
module clock_gen;
timeunit 1ns; timeprecision 1ns;

logic clock0, clock3, clock6;

initial begin
  clock0 < 0;
  forever #5 clock0 = ~clock0;
end

assign #3 clock3 = clock0;  // OK, clock3 works as expected
assign #6 clock6 = clock0;  // GOTCHA! clock6 flat lines

initial begin
  $timeformat(-9, 0, ""ns"", 7);
  $monitor($t: clock0 = %b clock3 = %b clock6 = %b"",
           $time, clock0, clock3, clock6);
  #30 $finish;
end
endmodule: clock_gen
```

The code is an example used to demonstrate a ""gotcha"" in Verilog programming related to continuous assignments with delays and how they can cancel input glitches. The example shows how two different delayed versions of a clock signal are generated, with an intended glitch and a problematic flat line as output.","
module clock_gen;
timeunit 1ns; timeprecision 1ns;

logic clock0, clock3, clock6;

initial begin
  clock0 < 0;
  forever #5 clock0 = ~clock0;
end

assign #3 clock3 = clock0;  // OK, clock3 works as expected
assign #6 clock6 = clock0;  // GOTCHA! clock6 flat lines

initial begin
  $timeformat(-9, 0, ""ns"", 7);
  $monitor($t: clock0 = %b clock3 = %b clock6 = %b"",
           $time, clock0, clock3, clock6);
  #30 $finish;
end
endmodule: clock_gen
","""Exploring a Verilog Gotcha: Issues with Continuous Assignments and Delays""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p173.jpg,True,"The image contains text and some code snippets written in Verilog. Below is the code from the image:

First code snippet:

```verilog
class My_class;
  rand int data;
  rand logic [47:0] address;
  ...
endclass

My_class h = new; // Gotcha! construct one My_class object

repeat (10) begin
  h.randomize();  // randomize properties in the object
  mbx.put(h);     // store handle to object in a mailbox
end
```

Second code snippet:

```verilog
my_class h;
repeat (10) begin
  h = new;           // construct a My_class object
  h.randomize();     // randomize properties in the object
  mbx.put(h);        // store handle to object in a mailbox
end
```

These code snippets demonstrate an issue and its solution related to object randomization and storage in a mailbox in object-oriented programming with Verilog.","
class My_class;
  rand int data;
  rand logic [47:0] address;
  ...
endclass

My_class h = new; // Gotcha! construct one My_class object

repeat (10) begin
  h.randomize();  // randomize properties in the object
  mbx.put(h);     // store handle to object in a mailbox
end


my_class h;
repeat (10) begin
  h = new;           // construct a My_class object
  h.randomize();     // randomize properties in the object
  mbx.put(h);        // store handle to object in a mailbox
end
","A common Verilog coding pitfall involving object instantiation and randomization, with an example of incorrect and correct usage.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p396.jpg,True,"The image contains two snippets of Verilog code.

Here is the first snippet:

```verilog
covergroup CovDst45;
  coverpoint tr_dst;
  option.goal = 90; // Settle for partial coverage
endgroup
```

And here is the second snippet:

```verilog
class Packet;
  rand bit [2:0] hdr_len;
  rand bit [3:0] payload_len;
  rand bit [4:0] len;

  constraint length {len == hdr_len + payload_len; }
endclass
```","
covergroup CovDst45;
  coverpoint tr_dst;
  option.goal = 90; // Settle for partial coverage
endgroup


class Packet;
  rand bit [2:0] hdr_len;
  rand bit [3:0] payload_len;
  rand bit [4:0] len;

  constraint length {len == hdr_len + payload_len; }
endclass
","Caption: ""Exploring Functional Coverage in Verilog: Coverage goal setting and analyzing coverage data with an example class definition for packet length.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p53.jpg,True,"Here is the Verilog code from the image:

```verilog
64'h0; // fills all 64 bits with 0
64'bz; // fills all 64 bits with Z

logic signed [11:0] a, b;

initial begin
  a = 12'sh3C; // OK, signed 00111100 expands to 000000111100
  b = 12'so74; // GOTCHA! signed 111100 expands to 000000111100
end

12'shFFB // expands to 111111111011, which is -5 decimal
-12'sh5  // expands to 111111111011, which is -5 decimal
```","
64'h0; // fills all 64 bits with 0
64'bz; // fills all 64 bits with Z

logic signed [11:0] a, b;

initial begin
  a = 12'sh3C; // OK, signed 00111100 expands to 000000111100
  b = 12'so74; // GOTCHA! signed 111100 expands to 000000111100
end

12'shFFB // expands to 111111111011, which is -5 decimal
-12'sh5  // expands to 111111111011, which is -5 decimal
",Explaining Verilog size extension rules and common gotchas with signed bit extensions in Verilog code.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p164.jpg,True,"```c
int PLIbook_getarg_intval_vpi(int argNum)
{
    vpiHandle arg_h;
    s_vpi_value argVal;
    #ifdef PLIbookDebug
        s_vpi_error_info err; /* structure for error handling */
    #endif

    arg_h = PLIbook_getarg_handle_vpi(argNum);
    if (arg_h == NULL) {
        vpi_printf(""ERROR: PLIbook_getarg_intval_vpi() could not obtain arg handle\n"");
        return(0);
    }

    argVal.format = vpiIntVal;
    vpi_get_value(arg_h, &argVal);
    #ifdef PLIbookDebug /* if error, generate verbose debug message */
        if (vpi_chk_error(&err)) {
            vpi_printf(""ERROR: PLIbook_getarg_intval_vpi() could not obtain arg value\n"");
            vpi_printf(""File %s, Line %d: %s\n"", 
                       err.file, err.line, err.message);
            return(0);
        }
    #endif
    return(argVal.value.integer);
}
```","LIbook_getarg_intval_vpi(int argNum)
{
    vpiHandle arg_h;
    s_vpi_value argVal;
    #ifdef PLIbookDebug
        s_vpi_error_info err; /* structure for error handling */
    #endif

    arg_h = PLIbook_getarg_handle_vpi(argNum);
    if (arg_h == NULL) {
        vpi_printf(""ERROR: PLIbook_getarg_intval_vpi() could not obtain arg handle\n"");
        return(0);
    }

    argVal.format = vpiIntVal;
    vpi_get_value(arg_h, &argVal);
    #ifdef PLIbookDebug /* if error, generate verbose debug message */
        if (vpi_chk_error(&err)) {
            vpi_printf(""ERROR: PLIbook_getarg_intval_vpi() could not obtain arg value\n"");
            vpi_printf(""File %s, Line %d: %s\n"", 
                       err.file, err.line, err.message);
            return(0);
        }
    #endif
    return(argVal.value.integer);
}
","Caption: ""Example of C code using the Verilog Programming Language Interface (PLI) to read Verilog values as C integers.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p173.jpg,True,"The image contains Verilog code snippets. Here is the code transcribed from the image:

```verilog
$asserton
$assertoff
$assertkill
list_of_scopes_or_assertions ::= scope_or_assertion, {scope_or_assertion}
scope_or_assertion ::=
    scope_identifier
  | assertion_identifier
  | hierarchical_identifier

a: assert property(p1)
   begin // pass action block
      process_pass();
      $info(""assertion PASSED"");
   end
   else begin // fail action block
      process_failure();
      $error(""assertion FAILED"");
   end
c: cover property(p2)
   begin // pass action block
      process_cover();
      $info(""COVERED"");
   end
```

Additionally, the image contains explanatory text regarding Verilog code related to assertion system functions, tasks and action blocks in SystemVerilog. Please note that the process_pass, process_failure, and process_cover functions are most likely pseudo-code examples meant to illustrate the typical structure and are not standard Verilog/SystemVerilog functions.","
$asserton
$assertoff
$assertkill
list_of_scopes_or_assertions ::= scope_or_assertion, {scope_or_assertion}
scope_or_assertion ::=
    scope_identifier
  | assertion_identifier
  | hierarchical_identifier

a: assert property(p1)
   begin // pass action block
      process_pass();
      $info(""assertion PASSED"");
   end
   else begin // fail action block
      process_failure();
      $error(""assertion FAILED"");
   end
c: cover property(p2)
   begin // pass action block
      process_cover();
      $info(""COVERED"");
   end
","Caption: ""Excerpt from a textbook or documentation on SystemVerilog showing syntax for assertion control tasks and an example of using action blocks with assertions and cover statements in Verilog.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p61.jpg,True,"The image contains a single line of code:

```c
(int (*) ()) PLIbook_PowCalltf
```","(*) ()) PLIbook_PowCalltf
","""Interfacing VPI based PLI Applications to Verilog Simulators and an example of typecasting a function pointer in C for a Verilog simulation callback.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p602.jpg,True,"```c
void acc_vcl_add(object, consumer, user_data, vcl_flag)
handle object; /* handle for a net, register, event, port, primitive output
                  terminal or primitive inout terminal. */
int *consumer; /* unquoted name of a C consumer routine. */
char *user_data; /* user-defined data value. */
int vcl_flag; /* constant: vcl_verilog_logic, vcl_verilog_strength. */
```","acc_vcl_add(object, consumer, user_data, vcl_flag)
handle object; /* handle for a net, register, event, port, primitive output
                  terminal or primitive inout terminal. */
int *consumer; /* unquoted name of a C consumer routine. */
char *user_data; /* user-defined data value. */
int vcl_flag; /* constant: vcl_verilog_logic, vcl_verilog_strength. */
","Caption: ""Page from 'The Verilog PLI Handbook' detailing the use of Value Change Link (VCL) routines for monitoring logic changes in Verilog simulations, including the prototype for adding VCL flags to Verilog objects using acc_vcl_add function.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p248.jpg,True,"The image contains a snippet of Verilog code related to a sequence and a property definition. Here is the code:

```verilog
sequence s_data_trans;
  (!sel_n[3] && oe_n && ($stable(addr)==0) && $stable(oe_n)) ##0 $isunknown(data)
  ##3 $isunknown(data)==0;
endsequence

property p_tAPA;
  @(posedge clk)
  s_data_trans |-> $stable(addr);
endproperty

a_tAPA: assert property(p_tAPA);
c_tAPA: cover property(p_tAPA);
```

This code appears to be part of a formal verification effort for a system. Formal verification uses mathematical models to prove the correctness of systems. In this snippet:

- A sequence named `s_data_trans` is defined, which looks for specific conditions related to signals `sel_n`, `oe_n`, `addr`, and `data`.
- A property named `p_tAPA` is asserted and covered based on the sequence, which uses the positive edge-triggered clock (`posedge clk`).
- Assertions (`assert`) and covers (`cover`) are then used in conjunction with the defined property to check its validity during simulation or formal verification.","
sequence s_data_trans;
  (!sel_n[3] && oe_n && ($stable(addr)==0) && $stable(oe_n)) ##0 $isunknown(data)
  ##3 $isunknown(data)==0;
endsequence

property p_tAPA;
  @(posedge clk)
  s_data_trans |-> $stable(addr);
endproperty

a_tAPA: assert property(p_tAPA);
c_tAPA: cover property(p_tAPA);
","""Verilog code snippet showing a sequence and property definition for data transaction verification with waveform illustration for burst read command in tAPA context.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p75.jpg,True,"```c
#include <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard I/O library */
#include ""vpi_user.h"" /* IEEE 1364 PLI VPI library */
```","ude <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard I/O library */
#include ""vpi_user.h"" /* IEEE 1364 PLI VPI library */
","Caption: ""Understanding the VPI Routines in Verilog: An excerpt from a text explaining the use of VPI library for Verilog simulation and its integration with ANSI C libraries, showcasing example header file inclusion.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p170.jpg,True,"The image contains a snippet of code related to the Verilog Hardware Description Language. The code shown is:

```verilog
typedef struct t_vpi_vecval
{
  int aval, bval;
} s_vpi_vecval, *p_vpi_vecval;
```

Above that, there's a Verilog declaration mentioned in the text, but not as a proper code block:

```
reg [1:40] data;
```

The image also includes an explanation and a diagram representing how Verilog vector `data[1:40]` maps to C integers in `aval/bval` pairs.","
typedef struct t_vpi_vecval
{
  int aval, bval;
} s_vpi_vecval, *p_vpi_vecval;

:40] data;
","""Understanding Verilog bit mapping and the use of aval/bval pairs in C integrations from 'The Verilog PLI Handbook, Part One'.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p167.jpg,True,"The image includes information about Verilog past global clocking sampled value functions, which are expressed as:

```verilog
$past_gclk(e)     = $past(e, 1, 1, @$global_clock)
$rose_gclk(e)     = $rose(e, @$global_clock)
$fell_gclk(e)     = $fell(e, @$global_clock)
$changed_gclk(e)  = $changed(e, @$global_clock)
$stable_gclk(e)   = $stable(e, @$global_clock)
```

These are Verilog constructs for checking the past state of signals with respect to a global clock.","
$past_gclk(e)     = $past(e, 1, 1, @$global_clock)
$rose_gclk(e)     = $rose(e, @$global_clock)
$fell_gclk(e)     = $fell(e, @$global_clock)
$changed_gclk(e)  = $changed(e, @$global_clock)
$stable_gclk(e)   = $stable(e, @$global_clock)
",Table and explanation of past global clocking sampled value functions in Verilog.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p143.jpg,True,"The image contains Verilog code. The code is as follows:

```verilog
module memory(input wire start, write,
              input wire [7:0] addr,
              input wire [7:0] data);
    logic [7:0] mem[256];
    always @(posedge start) begin
        if (write)
            mem[addr] <= data;
        ...
    end
endmodule

module test(output logic start, write,
            output logic [7:0] addr, data);
    initial begin
        start = 0;                  // Initialize signals
        write = 0;
        #10;                        // Short delay
        addr = 8'h42;               // Start first command
        data = 8'h5a;
        start = 1;
        write = 1;
        ...
    end
endmodule
```
Please note that the code has ellipses (`...`) indicating that some parts of the code are not shown in the image.","
module memory(input wire start, write,
              input wire [7:0] addr,
              input wire [7:0] data);
    logic [7:0] mem[256];
    always @(posedge start) begin
        if (write)
            mem[addr] <= data;
        ...
    end
endmodule

module test(output logic start, write,
            output logic [7:0] addr, data);
    initial begin
        start = 0;                  // Initialize signals
        write = 0;
        #10;                        // Short delay
        addr = 8'h42;               // Start first command
        data = 8'h5a;
        start = 1;
        write = 1;
        ...
    end
endmodule
","Verilog code snippet demonstrating a race condition between testbench and design modules, along with explanatory text on stimulus timing and mixed events in design and testbench.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p475.jpg,True,"The image contains a fragment of Verilog code as follows:

```verilog
function void write (input bus_tx t);
  m_item = t;
  m_address_delta = m_item.current_address - m_item.previous_address;
  m_cov.sample ( );
endfunction : write

endclass : my_coverage
```","
function void write (input bus_tx t);
  m_item = t;
  m_address_delta = m_item.current_address - m_item.previous_address;
  m_cov.sample ( );
endfunction : write

endclass : my_coverage
","A page from a reference manual or book providing guidelines for writing SystemVerilog code for coverage points in verification, including an example of a function within a class.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p382.jpg,True,"```verilog
property_expr ::= if (expression) property_expr1
                | if (expression) property_expr1 else property_expr2
```

The example provided in the image is as follows:

```verilog
A |=> first_match(##[1:10] B | C)
   |=> if(B) D ##[1:10] F
       else G [*2]
```

The text explains that the first line identifies that sequence B should follow A or C after A. The second line uses a conditional selection operator to choose the next property based on which sequence was detected. If B was found, `D ##[1:10] F` is expected to match. If B was not found (implying C was found), the property `G [*2]` is expected to match.","
property_expr ::= if (expression) property_expr1
                | if (expression) property_expr1 else property_expr2


A |=> first_match(##[1:10] B | C)
   |=> if(B) D ##[1:10] F
       else G [*2]
","Caption: ""Example of Conditional Property Selection in SystemVerilog Assertions using if...else statement.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p260.jpg,True,"```verilog
`define s_IO_READ          ($fell(framen) && (cxben[3:0] == 4'b0010))
`define s_IO_WRITE         ($fell(framen) && (cxben[3:0] == 4'b0011))
`define s_MEM_READ         ($fell(framen) && (cxben[3:0] == 4'b0110))
`define s_MEM_WRITE        ($fell(framen) && (cxben[3:0] == 4'b0111))
`define s_CONFIG_READ      ($fell(framen) && (cxben[3:0] == 4'b1010))
`define s_CONFIG_WRITE     ($fell(framen) && (cxben[3:0] == 4'b1011))
`define s_DUAL_ADDR_CYCLE  ($fell(framen) && (cxben[3:0] == 4'b1101))
`define s_MEM_READ_LINE    ($fell(framen) && (cxben[3:0] == 4'b1110))
`define s_MEM_WRITE_INV    ($fell(framen) && (cxben[3:0] == 4'b1111))
```","
`define s_IO_READ          ($fell(framen) && (cxben[3:0] == 4'b0010))
`define s_IO_WRITE         ($fell(framen) && (cxben[3:0] == 4'b0011))
`define s_MEM_READ         ($fell(framen) && (cxben[3:0] == 4'b0110))
`define s_MEM_WRITE        ($fell(framen) && (cxben[3:0] == 4'b0111))
`define s_CONFIG_READ      ($fell(framen) && (cxben[3:0] == 4'b1010))
`define s_CONFIG_WRITE     ($fell(framen) && (cxben[3:0] == 4'b1011))
`define s_DUAL_ADDR_CYCLE  ($fell(framen) && (cxben[3:0] == 4'b1101))
`define s_MEM_READ_LINE    ($fell(framen) && (cxben[3:0] == 4'b1110))
`define s_MEM_WRITE_INV    ($fell(framen) && (cxben[3:0] == 4'b1111))
","""Defining SystemVerilog Assertions for PCI Master Functionality Verification""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p313.jpg,True,"The image contains Verilog code. Here it is:

```verilog
z1 : assert property (@ (posedge clk) a === b));
$display("" a=%0b b=%0b"", $sampled (a), $sampled (b));
```

And there is another code sample further down:

```verilog
module top_pd;
  logic clk;
  global clocking sys_clk @(clk); endclocking
  ....
endmodule
```

These code blocks are part of a Verilog tutorial or reference material, discussing the use of `assert property` with `sampled` system function and global clocking declarations.","
z1 : assert property (@ (posedge clk) a === b));
$display("" a=%0b b=%0b"", $sampled (a), $sampled (b));


module top_pd;
  logic clk;
  global clocking sys_clk @(clk); endclocking
  ....
endmodule
","The image contains a text excerpt discussing IEEE-1800-2009/2012 features in Verilog related to assertions and global clocking sampled value functions. The excerpt includes examples of system functions like $past_gclk and $sampled, and a snippet of a Verilog module declaring a global clock.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p307.jpg,True,"Here's the Verilog code from the image:

```verilog
endproperty: detect_glitch

//The following property is simply to showcase how you would
//display the Glitch Width that //results in a glitch. Note the
//use of $display used as a subroutine attached to always true
//b1.
property display_glitch_width;
    time leading;
    @(glitch) (1'b1,leading=$time) |=> 
    (1'b1, $display(""%0t Glitch Width = %0t"",$time, 
    ($time-leading)));
endproperty

//Assert both properties
glitchD: assert property (detect_glitch) else $display(""At
%0tns ERROR: Glitch Detected\n"",$time);
glitchW: assert property (display_glitch_width);

initial
begin
    glitch = 1'b0;
    #5ns glitch = !glitch;
    #5ns glitch = !glitch;
    #2ns glitch = !glitch; //12ns - Glitch
    #5ns glitch = !glitch;
    #2ns glitch = !glitch; //19ns - Glitch
    #2ns glitch = !glitch; //21ns - Glitch

    #100 $finish(2);
end
endmodule
```

This code snippet appears to demonstrate how to write properties and assertions to detect glitches and their timing characteristics in digital logic using SystemVerilog assertion (SVA).

Note: The image contains a typo: the first line `endproperty: detect_glitch` should probably be `property detect_glitch;`. It seems to be the end of another property that is not fully shown in the image.","
endproperty: detect_glitch

//The following property is simply to showcase how you would
//display the Glitch Width that //results in a glitch. Note the
//use of $display used as a subroutine attached to always true
//b1.
property display_glitch_width;
    time leading;
    @(glitch) (1'b1,leading=$time) |=> 
    (1'b1, $display(""%0t Glitch Width = %0t"",$time, 
    ($time-leading)));
endproperty

//Assert both properties
glitchD: assert property (detect_glitch) else $display(""At
%0tns ERROR: Glitch Detected\n"",$time);
glitchW: assert property (display_glitch_width);

initial
begin
    glitch = 1'b0;
    #5ns glitch = !glitch;
    #5ns glitch = !glitch;
    #2ns glitch = !glitch; //12ns - Glitch
    #5ns glitch = !glitch;
    #2ns glitch = !glitch; //19ns - Glitch
    #2ns glitch = !glitch; //21ns - Glitch

    #100 $finish(2);
end
endmodule
",Verilog code demonstrating asynchronous assertion to detect and measure glitch width.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p274.jpg,True,"```verilog
not $fell (irdyn);
endproperty

a_mchk12: assert property(p_mchk12);
c_mchk12: cover property(p_mchk12);

property p_mchk13;
@(posedge clk)
$fell (gntn) ##[1:8]
$fell (framen) && $fell(req64n) |->
##[1:5] $fell (ack64n) && $fell(devseln);
endproperty

a_mchk13: assert property(p_mchk13);
c_mchk13: cover property(p_mchk13);
```","
not $fell (irdyn);
endproperty

a_mchk12: assert property(p_mchk12);
c_mchk12: cover property(p_mchk12);

property p_mchk13;
@(posedge clk)
$fell (gntn) ##[1:8]
$fell (framen) && $fell(req64n) |->
##[1:5] $fell (ack64n) && $fell(devseln);
endproperty

a_mchk13: assert property(p_mchk13);
c_mchk13: cover property(p_mchk13);
","Caption: ""Excerpt from a technical document showing Verilog code for signal property assertions and coverage in 64-bit transactions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p157.jpg,True,"Here is the Verilog code present in the image:

```verilog
module top;
    bit clk;
    test t1(.*);
endmodule

`define TOP $root.top
program automatic test;
    initial begin
        // Absolute reference
        $display(""clk=%b"", $root.top.clk);
        $display(""clk=%b"", `TOP.clk); // With macro

        // Relative reference
        $display(""clk=%b"", top.clk);
    end
endprogram
```","
module top;
    bit clk;
    test t1(.*);
endmodule

`define TOP $root.top
program automatic test;
    initial begin
        // Absolute reference
        $display(""clk=%b"", $root.top.clk);
        $display(""clk=%b"", `TOP.clk); // With macro

        // Relative reference
        $display(""clk=%b"", top.clk);
    end
endprogram
","""Verilog example demonstrating program-to-module interactions with absolute and relative references.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p461.jpg,True,"```verilog
covergroup burstSize (int max, bSize);
  cBurst_size : coverpoint bSize
  {
    bins small = {1};
    bins mid = { [2 : max - 1] };
    bins large = { max };
  }
endgroup

burstSize bSizeInst = new(2, 8);
```","
covergroup burstSize (int max, bSize);
  cBurst_size : coverpoint bSize
  {
    bins small = {1};
    bins mid = { [2 : max - 1] };
    bins large = { max };
  }
endgroup

burstSize bSizeInst = new(2, 8);
","""Understanding the use of the 'with' clause in Verilog for specifying bins in a coverpoint and avoiding warnings for overlapping bins.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p212.jpg,True,"The image contains a Verilog code snippet. Here is the code transcribed from the image:

```verilog
module dff_2 (q, ck ,rst, d);
  input ck ,rst, d;
  input [1:0] d;
  output [1:0] q;
  reg [1:0] q;
  always @ (posedge ck)
    q <= #1 (rst == 1'b0) ? d : 2'b00;
endmodule // dff_2
```","
module dff_2 (q, ck ,rst, d);
  input ck ,rst, d;
  input [1:0] d;
  output [1:0] q;
  reg [1:0] q;
  always @ (posedge ck)
    q <= #1 (rst == 1'b0) ? d : 2'b00;
endmodule // dff_2
","""Exploring potential pitfalls of flip-flop assignment delays in Verilog as illustrated by example code snippet.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p180.jpg,True,"Here is the code from the image:

```verilog
Transaction t;    // Create a handle
t = new();        // Allocate a new Transaction
t = new();        // Allocate a second one, free the first
t = null;         // Deallocate the second
```

This sample code is demonstrating how to create an object in SystemVerilog, allocate memory to it, and then deallocate memory.","
Transaction t;    // Create a handle
t = new();        // Allocate a new Transaction
t = new();        // Allocate a second one, free the first
t = null;         // Deallocate the second
","Caption: ""Understanding Object Deallocation in SystemVerilog with sample code on creating and deallocating objects.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p194.jpg,True,"The image contains Verilog code examples. Here is the code from the image:

Sample 5.25 Passing objects

```verilog
// Transmit a packet onto a 32-bit bus
task transmit(input Transaction tr);
    tr.data[0] = ~tr.data[0]; // Corrupt the first word
    CBbus.rx_data <= tr.data[0];
    ...
endtask

Transaction tr;
initial begin
    tr = new();
    tr.addr = 42; // Initialize values
    transmit(tr); // Pass object to task
end
```

The block of code demonstrates how to pass objects in Verilog and includes an example of a task that modifies a data field within a Transaction object. The code also shows an initial block where a Transaction object is created and passed to the task.","
// Transmit a packet onto a 32-bit bus
task transmit(input Transaction tr);
    tr.data[0] = ~tr.data[0]; // Corrupt the first word
    CBbus.rx_data <= tr.data[0];
    ...
endtask

Transaction tr;
initial begin
    tr = new();
    tr.addr = 42; // Initialize values
    transmit(tr); // Pass object to task
end
",Verilog example demonstrating the use of object handles in tasks and the potential pitfalls of not using the ref modifier for arguments that need to be modified within the task.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p328.jpg,True,"The image contains several Verilog properties. Here they are:

```verilog
// on a given clock edge the leading signal has a
// falling edge and after ""start_wait"" cycles,
// the trailing signal is low ""repetition"" times

property p7_c_rpt_fl;
    @(posedge clk) $fell(a) ##start_wait |b[*repetition];
endproperty
```

```verilog
// on a give clock edge, the leading signal has a
// rising edge and stays high until the trailing
// signal is low

property p7_cu_rpt_rl;
    @(posedge clk) $rose(b) ##0 b[*1:$] ##1 !a;
endproperty
```

```verilog
// on a given clock edge, the leading signal has
// a falling edge and stays low until the
// trailing signal is low

property p7_cu_rpt_fl;
    @(posedge clk) $fell(b) ##0 |b[*1:$] ##1 !a;
endproperty
```

```verilog
// on a given clock edge, the leading signal has
// a rising edge and stays high until the
// trailing signal is high

property p7_cu_rpt_rh;
    @(posedge clk) $rose(b) ##0 b[*1:$] ##1 a;
endproperty
```

```verilog
// on a given clock edge, the leading signal has
// a falling edge and stays high until the
// trailing signal is high

property p7_cu_rpt_fh;
    @(posedge clk) $fell(b) ##0 |b[*1:$] ##1 a;
endproperty
```","
// on a given clock edge the leading signal has a
// falling edge and after ""start_wait"" cycles,
// the trailing signal is low ""repetition"" times

property p7_c_rpt_fl;
    @(posedge clk) $fell(a) ##start_wait |b[*repetition];
endproperty


// on a give clock edge, the leading signal has a
// rising edge and stays high until the trailing
// signal is low

property p7_cu_rpt_rl;
    @(posedge clk) $rose(b) ##0 b[*1:$] ##1 !a;
endproperty


// on a given clock edge, the leading signal has
// a falling edge and stays low until the
// trailing signal is low

property p7_cu_rpt_fl;
    @(posedge clk) $fell(b) ##0 |b[*1:$] ##1 !a;
endproperty


// on a given clock edge, the leading signal has
// a rising edge and stays high until the
// trailing signal is high

property p7_cu_rpt_rh;
    @(posedge clk) $rose(b) ##0 b[*1:$] ##1 a;
endproperty


// on a given clock edge, the leading signal has
// a falling edge and stays high until the
// trailing signal is high

property p7_cu_rpt_fh;
    @(posedge clk) $fell(b) ##0 |b[*1:$] ##1 a;
endproperty
","Caption: ""Examples of Verilog properties specifying 'repeat until' behaviors for leading and trailing signals on clock edges.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p776.jpg,True,"The image contains text describing two functions related to the Verilog Programming Language Interface (PLI), but it does not contain any actual code. It describes the usage or signatures of the functions, not the implementation. Here is the text describing the function signatures:

```
void acc_set_pulsere(object, r_percent, e_percent)
handle    object            handle for a module path.
double    r_percent         pulse reject limit.
double    e_percent         pulse error limit.

Sets pulse control values of a path as a percentage of the path delays.

char *acc_set_scope(module, name)
handle    module            handle for a module.
char      *name             (optional) name of a module.

Sets the scope and search rules for acc_handle_object(), based on the configuration
of acc_configure(accEnableArgs,...):

• If ""no_acc_set_scope"" (default), and module is a valid module handle, then the
  PLI scope is set to the level of the module handle.
• If ""no_acc_set_scope"" (default), and module is null, then the PLI scope is set to
  the first top-level module.
• If ""acc_set_scope"", and module is a valid module handle, then the PLI scope is
  set to the level of the module handle.
• If ""acc_set_scope"", and module is null, then the PLI scope is set to the level of the
  module name.
• If ""acc_set_scope"", and module is null and module name is null, then the PLI
  scope is set to the first top-level module.

Returns a pointer to a string containing the full hierarchical path name of the new
PLI scope, or null if an error occurred.
```

These function signatures and the accompanying text are part of the documentation for the Verilog PLI and are intended to help developers understand how to use these functions within the context of Verilog simulations.","cc_set_pulsere(object, r_percent, e_percent)
handle    object            handle for a module path.
double    r_percent         pulse reject limit.
double    e_percent         pulse error limit.

Sets pulse control values of a path as a percentage of the path delays.

char *acc_set_scope(module, name)
handle    module            handle for a module.
char      *name             (optional) name of a module.

Sets the scope and search rules for acc_handle_object(), based on the configuration
of acc_configure(accEnableArgs,...):

• If ""no_acc_set_scope"" (default), and module is a valid module handle, then the
  PLI scope is set to the level of the module handle.
• If ""no_acc_set_scope"" (default), and module is null, then the PLI scope is set to
  the first top-level module.
• If ""acc_set_scope"", and module is a valid module handle, then the PLI scope is
  set to the level of the module handle.
• If ""acc_set_scope"", and module is null, then the PLI scope is set to the level of the
  module name.
• If ""acc_set_scope"", and module is null and module name is null, then the PLI
  scope is set to the first top-level module.

Returns a pointer to a string containing the full hierarchical path name of the new
PLI scope, or null if an error occurred.
","The image displays a page from ""The Verilog PLI Handbook,"" detailing the usage of the acc_set_pulserej() and acc_set_scope() Verilog PLI functions.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p762.jpg,True,"There is no executable Verilog code in the image provided. However, the image contains descriptions of functions and data structures from the Verilog Programming Language Interface (PLI), which is used for interfacing Verilog simulations with external C functions. There is also a typdef for a `struct` in C, which is given below:

```c
typedef struct t_location {
    int line_no;
    char *filename;
} s_location, *p_location;
```","ef struct t_location {
    int line_no;
    char *filename;
} s_location, *p_location;
","Page from ""The Verilog PLI Handbook"" detailing functions for Verilog Programming Language Interface (PLI).",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p314.jpg,True,"The image contains Verilog code. Here it is:

```verilog
// sample test code for logical relationship
// between edge sensitive signals

for(i=0; i<8; i++)
begin
    a <= logical_op_reg[0];
    b <= logical_op_reg[1];
    repeat(1) @(posedge clk);
    logical_op_reg++;
end
```

And it continues with more Verilog code outside of the visible area:

```verilog
// sample test code for logical relationship
// between edge sensitive signals
for(i=0; i<8; i++)
begin
```

The remaining part of the code is not visible in the image.","
// sample test code for logical relationship
// between edge sensitive signals

for(i=0; i<8; i++)
begin
    a <= logical_op_reg[0];
    b <= logical_op_reg[1];
    repeat(1) @(posedge clk);
    logical_op_reg++;
end


// sample test code for logical relationship
// between edge sensitive signals
for(i=0; i<8; i++)
begin
","Caption: ""Verilog code example for testing a logical relationship between edge-sensitive signals, demonstrating assert property usage, along with a waveform diagram showing fall-fall and fall-rise edge conditions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p267.jpg,True,"```verilog
initial begin
  clk = 0;
  int i = 10; //Note that `i` is initialized to 10 before the for loop starts.
  forever begin #10; clk = ~clk; end //meaning posedge clk won't occur until time 10
end

always @(posedge clk) begin
  for (i=0; i<10; i++) begin
    a1: assert property (req[i] && ack[i]);
  end
end
```

The second code block with the suggested fix is:

```verilog
initial begin
  clk = 0;
  int i = 10; //Note that `i` is initialized to 10
  forever begin #10; clk = ~clk; end //meaning posedge clk won't occur until time 10
end

always @(posedge clk) begin
  for (i=0; i<10; i++) begin
    a1: assert property (req[const' (i)] && ack[const' (i)]);
    //Note const' cast
  end
end
```","
initial begin
  clk = 0;
  int i = 10; //Note that `i` is initialized to 10 before the for loop starts.
  forever begin #10; clk = ~clk; end //meaning posedge clk won't occur until time 10
end

always @(posedge clk) begin
  for (i=0; i<10; i++) begin
    a1: assert property (req[i] && ack[i]);
  end
end


initial begin
  clk = 0;
  int i = 10; //Note that `i` is initialized to 10
  forever begin #10; clk = ~clk; end //meaning posedge clk won't occur until time 10
end

always @(posedge clk) begin
  for (i=0; i<10; i++) begin
    a1: assert property (req[const' (i)] && ack[const' (i)]);
    //Note const' cast
  end
end
",Caption: Verilog code example illustrating a debugging scenario with a for loop and concurrent assertions in a testbench.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p273.jpg,True,"The image contains a snippet of code written in Verilog which is a hardware description language. Here is the code provided in the image:

```verilog
sequence seq;
  c ##1 d ##1 e;
endsequence

property rc1(ra,rb);
  rb or (ra and ( `true` |=> rc1(ra,rb) ));
endproperty

property s_rc1(c_seq,ra,rb);
  (c_seq.tdip) |=> rc1(ra,rb);
endproperty

baseP: assert property (@(posedge clk) s_rc1(seq,a,b)) else gotoFail;
```

This code defines a sequence `seq` and a property `rc1` along with another property `s_rc1` that references the sequence. An assertion `baseP` is also created using the `s_rc1` property and is triggered at the positive edge of the clock signal (`posedge clk`). If the assertion fails, it will execute `gotoFail`.","
sequence seq;
  c ##1 d ##1 e;
endsequence

property rc1(ra,rb);
  rb or (ra and ( `true` |=> rc1(ra,rb) ));
endproperty

property s_rc1(c_seq,ra,rb);
  (c_seq.tdip) |=> rc1(ra,rb);
endproperty

baseP: assert property (@(posedge clk) s_rc1(seq,a,b)) else gotoFail;
","""Explaining the use of sequences as antecedents in SystemVerilog Assertions (SVA)""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p300.jpg,True,"```verilog
property p_sch2k2;
@(posedge clk)
  $onehot0({!gntn[3], !gntn[2]});
endproperty

a_sch2k2: assert property(p_sch2k2);
c_sch2k2: cover property(p_sch2k2);

property p_sch3k3;
@(posedge clk)
  $rose(gntn[2]) &&
  (!framen || !irdyn) |->
```","
property p_sch2k2;
@(posedge clk)
  $onehot0({!gntn[3], !gntn[2]});
endproperty

a_sch2k2: assert property(p_sch2k2);
c_sch2k2: cover property(p_sch2k2);

property p_sch3k3;
@(posedge clk)
  $rose(gntn[2]) &&
  (!framen || !irdyn) |->
","""Verilog Code Example and Signal Timing Diagram for PCI Arbiter Checks""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p209.jpg,True,"The image contains Verilog code within an explanatory context from a book or document. The code present in the image is as follows:

```verilog
// declarative assertion
// assert that ack must occur within 100 cycles after a req.

assert always (req -> next {[*1:100];ack}) @ (posedge clk);
```","
// declarative assertion
// assert that ack must occur within 100 cycles after a req.

assert always (req -> next {[*1:100];ack}) @ (posedge clk);
","Caption: ""PSL time limit sequence check in Verilog code demonstrating the use of assertions to ensure a response (ack) occurs within a specified time window after a request (req).""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p298.jpg,True,"The image contains Verilog code. Here's the code extracted from the image:

```verilog
property check_full;
  @(posedge wclk) disable iff (!wclk_rstn)
    (full) |=> @(posedge wclk) aff1_wr_ptr == $past(aff1_wr_ptr);
endproperty

cfull: assert property (check_full) else $display($stime,,,""%m Check wr_ptr full FAIL"");
cfullc: cover property (check_full) $display($stime,,,""%m Check wr_ptr full PASS"");

property check_empty;
  @(posedge rclk) disable iff (!rclk_rstn)
    (empty) |=> @(posedge rclk)
      if(!$isunknown($past(aff1_rd_ptr)))
        (aff1_rd_ptr == $past(aff1_rd_ptr));
endproperty

cempty: assert property (check_empty) else $display($stime,,,""%m Check rd_ptr empty FAIL"");
cemptyc: cover property (check_empty) $display($stime,,,""%m Check rd_ptr empty PASS"");
```

This code represents properties used in formal verification of an asynchronous FIFO, specifically for checking the conditions when the FIFO is full or empty.","
property check_full;
  @(posedge wclk) disable iff (!wclk_rstn)
    (full) |=> @(posedge wclk) aff1_wr_ptr == $past(aff1_wr_ptr);
endproperty

cfull: assert property (check_full) else $display($stime,,,""%m Check wr_ptr full FAIL"");
cfullc: cover property (check_full) $display($stime,,,""%m Check wr_ptr full PASS"");

property check_empty;
  @(posedge rclk) disable iff (!rclk_rstn)
    (empty) |=> @(posedge rclk)
      if(!$isunknown($past(aff1_rd_ptr)))
        (aff1_rd_ptr == $past(aff1_rd_ptr));
endproperty

cempty: assert property (check_empty) else $display($stime,,,""%m Check rd_ptr empty FAIL"");
cemptyc: cover property (check_empty) $display($stime,,,""%m Check rd_ptr empty PASS"");
","Caption: ""This image shows a Verilog code snippet for FIFO full and empty assertions, which are part of Asynchronous FIFO Assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p235.jpg,True,"```verilog
// see details section Example 6-44 on page 201
pipeline_reqack FIFO_check
    (.pipedepth (8),             // depth of FIFO
     .latency (20),              // latency to acknowledge
     .req (push),                // data put into FIFO
     .req_datain (data_in),      // data put into FIFO
     .ack (pop), 
     .dataout (data_out),        // data exiting the FIFO
     .clk (clk));
```","
// see details section Example 6-44 on page 201
pipeline_reqack FIFO_check
    (.pipedepth (8),             // depth of FIFO
     .latency (20),              // latency to acknowledge
     .req (push),                // data put into FIFO
     .req_datain (data_in),      // data put into FIFO
     .ack (pop), 
     .dataout (data_out),        // data exiting the FIFO
     .clk (clk));
","""SystemVerilog code snippet for a FIFO integrity check module to prevent data corruption""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p205.jpg,True,"The image contains Verilog code. Here is the code presented:

```verilog
assert property (p_req_ack) else $error; // OK. no pass statement

property p_req_ack;
    @(posedge clk) $rose(req) |-> #1 ($rose(ack), inc_cnt);
endproperty

function void inc_cnt;
    req_ack_count++;  // OK, not executed on vacuous success
endfunction
``` 

This snippet is discussing the correct usage of assertions in Verilog to avoid certain errors, specifically how to increment a counter in a function when a property, rather than an assertion, is successfully evaluated.","
assert property (p_req_ack) else $error; // OK. no pass statement

property p_req_ack;
    @(posedge clk) $rose(req) |-> #1 ($rose(ack), inc_cnt);
endproperty

function void inc_cnt;
    req_ack_count++;  // OK, not executed on vacuous success
endfunction
","""Addressing Assertion Gotchas in SystemVerilog Code by Using Functions within Properties""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p574.jpg,True,"The image contains an excerpt from a book that discusses some concepts within Verilog HDL, including delay representation and the `timescale` directive. Here is the Verilog code snippet present in the image:

```verilog
`timescale 1ns/10ps //nanosecond units, 2 decimal points
module A;
    ...
    nand #5.3 n1 (y, a, b);
    ...
endmodule
```

The code demonstrates the use of the `timescale` directive and the definition of a module that includes a gate-level instantiation of a nand gate with a specified delay.","
`timescale 1ns/10ps //nanosecond units, 2 decimal points
module A;
    ...
    nand #5.3 n1 (y, a, b);
    ...
endmodule
","A textbook page discussing Verilog delay transitions, the `timescale` directive, and showing an example of its usage in a Verilog module.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p205.jpg,True,"There's no actual Verilog code written out as text in this image, but the image refers to code and mentions lines which would appear to be part of code examples discussed in the text. A snippet of what seems to be Verilog syntax is mentioned in the context of checker instantiation:

```
c_seqprotocol inst1(go, done, din, dout, posedge clock, reset);
```

This line represents a checker instantiation with the name `c_seqprotocol` and instance name `inst1`, passing signals and events as arguments to it. The instantiation includes `go`, `done`, `din`, `dout`, and uses the Verilog's `posedge` keyword to specify a positive edge-triggered clock event, along with a `reset` signal.

The rest of the text discusses various concepts related to sequential protocol, properties, sequences, and system functions in the context of Verilog checkers.","rotocol inst1(go, done, din, dout, posedge clock, reset);
","Caption: ""Excerpt discussing checker instantiation in Verilog for sequential protocol assertion, highlighting the use of `inferred_clock` and `inferred_disable`.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p206.jpg,True,"Here is the code from the image:

```c
/* locate the workarea in the stack for this task instance */
while (workarea && (workarea->systf_h != systf_h))
    workarea = workarea->next_workarea;

/* if no work area found for this task instance, create one */
if (workarea == NULL) {
    workarea = (PLIbook_vpimalloc(sizeof(PLIbook_vpiworkarea_s));
    workarea->systf_h = systf_h;    /* set owner of this workarea */
    if (PLIbook_vpiworkarea_stack == NULL) {
        /* work area stack doesn't exist yet, create first location */
        workarea->next_workarea = NULL;
        PLIbook_vpiworkarea_stack = workarea;
    }
    else {
        workarea->next_workarea = PLIbook_vpiworkarea_stack;
        PLIbook_vpiworkarea_stack = workarea;
    }
}

/* store data in the work area */
workarea->data = data;
return;

/************************************************************
* PLIbook_get_vpimalloc()
************************************************************/
char *PLIbook_get_vpimalloc(vpiHandle systf_h)
{
    PLIbook_vpiworkarea_p workarea;

    /* locate the workarea in the stack for this task instance */
    workarea = PLIbook_vpiworkarea_stack;
    while (workarea && (workarea->systf_h != systf_h))
        workarea = workarea->next_workarea;

    if (workarea == NULL) {
        #ifdef PLIbookDebug /* generate verbose debug message */
        vpi_printf(""Warning: workarea not found for this instance\n"");
        #endif
        return(NULL);
    }
    return(workarea->data);
}
```
Please note that there seems to be a missing parenthesis in the line with `PLIbook_vpimalloc(sizeof(PLIbook_vpiworkarea_s))`. It should probably be `PLIbook_vpimalloc(sizeof(PLIbook_vpiworkarea_s))` to correctly close the function arguments.","cate the workarea in the stack for this task instance */
while (workarea && (workarea->systf_h != systf_h))
    workarea = workarea->next_workarea;

/* if no work area found for this task instance, create one */
if (workarea == NULL) {
    workarea = (PLIbook_vpimalloc(sizeof(PLIbook_vpiworkarea_s));
    workarea->systf_h = systf_h;    /* set owner of this workarea */
    if (PLIbook_vpiworkarea_stack == NULL) {
        /* work area stack doesn't exist yet, create first location */
        workarea->next_workarea = NULL;
        PLIbook_vpiworkarea_stack = workarea;
    }
    else {
        workarea->next_workarea = PLIbook_vpiworkarea_stack;
        PLIbook_vpiworkarea_stack = workarea;
    }
}

/* store data in the work area */
workarea->data = data;
return;

/************************************************************
* PLIbook_get_vpimalloc()
************************************************************/
char *PLIbook_get_vpimalloc(vpiHandle systf_h)
{
    PLIbook_vpiworkarea_p workarea;

    /* locate the workarea in the stack for this task instance */
    workarea = PLIbook_vpiworkarea_stack;
    while (workarea && (workarea->systf_h != systf_h))
        workarea = workarea->next_workarea;

    if (workarea == NULL) {
        #ifdef PLIbookDebug /* generate verbose debug message */
        vpi_printf(""Warning: workarea not found for this instance\n"");
        #endif
        return(NULL);
    }
    return(workarea->data);
}
","""Excerpt from 'The Verilog PLI Handbook' showing functions related to work area management for Verilog Procedural Interface (VPI) tasks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p211.jpg,True,"```verilog
module m(...);
logic req, gnt;
...
endmodule : m

module top;
logic clock, reset;
...
m m1(...);
request_granted c1(clock, reset);
endmodule : top

checker request_granted(clk, rst);
    a1: assert property(@(clk) disable_iff (rst) m1.req |=> m1.gnt);
endchecker : request_granted
```
","
module m(...);
logic req, gnt;
...
endmodule : m

module top;
logic clock, reset;
...
m m1(...);
request_granted c1(clock, reset);
endmodule : top

checker request_granted(clk, rst);
    a1: assert property(@(clk) disable_iff (rst) m1.req |=> m1.gnt);
endchecker : request_granted
","Caption: ""Guidelines for using sequences and properties in Verilog checkers with an example of hierarchical reference.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p488.jpg,True,"Here is the Verilog code extracted from the image:

```verilog
module PDC0204CDG_18_Out (output PAD, input I);
module PDC0204CDG_18_Tri (output PAD, input I, OEN);
module PDC0204CDG_18_In (output C, input PAD);

PDC0204CDG_18_Out Xpad1 ( .PAD(X), .I(toX) ); // X is port; toX is wire.
PDC0204CDG_18_Out Ypad1 ( .PAD(Y), .I(toY) ); // Y is port; toY is wire.
PDC0204CDG_18_Out Zpad1 ( .PAD(Z), .I(toZ) ); // Z is port; toZ is wire.
PDC0204CDG_18_In padA1 ( .C(fromA), .PAD(A) ); // A is port; fromA is wire.
PDC0204CDG_18_In padB1 ( .C(fromB), .PAD(B) ); // B is port; fromB is wire.
PDC0204CDG_18_In padC1 ( .C(fromC), .PAD(C) ); // C is port; fromC is wire.
PDC0204CDG_18_In padD1 ( .C(fromD), .PAD(D) ); // D is port; fromD is wire.

PDC0204CDG_18_Tri TDQpad1 ( .PAD(ScanOut) /* , .I(), .OEN() */ );
PDC0204CDG_18_In padTMS1 ( . /* C(), */ .PAD(ScanMode) );
PDC0204CDG_18_In padTDI1 ( . /* C(), */ .PAD(ScanIn) );
PDC0204CDG_18_In padTCK1 ( . /* C(), */ .PAD(ScanClk) );
PDC0204CDG_18_In padTRST1 ( . /* C(), */ .PAD(ScanRst) );
```

Please note that some parts of the code related to port connections for the `PDC0204CDG_18_Tri TDQpad1` and four subsequent instances are commented out (e.g., `.I()` and `.OEN()` inside the comments). Also, `C()` in `padTMS1`, `padTDI1`, `padTCK1`, and `padTRST1` are commented out, indicating that these connections might be specified elsewhere or not needed in this context.","
module PDC0204CDG_18_Out (output PAD, input I);
module PDC0204CDG_18_Tri (output PAD, input I, OEN);
module PDC0204CDG_18_In (output C, input PAD);

PDC0204CDG_18_Out Xpad1 ( .PAD(X), .I(toX) ); // X is port; toX is wire.
PDC0204CDG_18_Out Ypad1 ( .PAD(Y), .I(toY) ); // Y is port; toY is wire.
PDC0204CDG_18_Out Zpad1 ( .PAD(Z), .I(toZ) ); // Z is port; toZ is wire.
PDC0204CDG_18_In padA1 ( .C(fromA), .PAD(A) ); // A is port; fromA is wire.
PDC0204CDG_18_In padB1 ( .C(fromB), .PAD(B) ); // B is port; fromB is wire.
PDC0204CDG_18_In padC1 ( .C(fromC), .PAD(C) ); // C is port; fromC is wire.
PDC0204CDG_18_In padD1 ( .C(fromD), .PAD(D) ); // D is port; fromD is wire.

PDC0204CDG_18_Tri TDQpad1 ( .PAD(ScanOut) /* , .I(), .OEN() */ );
PDC0204CDG_18_In padTMS1 ( . /* C(), */ .PAD(ScanMode) );
PDC0204CDG_18_In padTDI1 ( . /* C(), */ .PAD(ScanIn) );
PDC0204CDG_18_In padTCK1 ( . /* C(), */ .PAD(ScanClk) );
PDC0204CDG_18_In padTRST1 ( . /* C(), */ .PAD(ScanRst) );
","""Verilog code examples for digital VLSI design, showcasing the instantiation of pad cells and three-state buffers.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p577.jpg,True,"The image contains text as well as some snippets of code written in Verilog, which are provided below:

Example A.3:
```
wire w = a;
```

Example A.4:
```
bit a;
logic [3:0] b = 7, c = 4;
```

Example A.5:
```
for (int i = 0; i < 7; i++) begin
    ...
end
```

These are the pieces of code present in the image. The rest of the text describes certain rules and examples concerning the default sampled values in Verilog expressions and variables."," = a;


logic [3:0] b = 7, c = 4;

nt i = 0; i < 7; i++) begin
    ...
end
","Caption: ""Excerpt from a document discussing default sampled values of variables and expressions in Verilog, along with code examples illustrating the concepts.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p560.jpg,True,"```verilog
reg [39:0] data; // little endian -- LSB is bit 0
reg [0:39] data2; // big endian -- LSB is bit 39
reg [40:1] data3; // little endian -- LSB is bit 1
```","
reg [39:0] data; // little endian -- LSB is bit 0
reg [0:39] data2; // big endian -- LSB is bit 39
reg [40:1] data3; // little endian -- LSB is bit 1
","""Understanding Bit Mapping and Endianness in Verilog Vector Representations""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p548.jpg,True,"```
double acc_fetch_tfarg(n)
int n position number of a PLI system task/function arg.

int acc_fetch_tfarg_int(n)
int n position number of a PLI system task/function arg.

char* acc_fetch_tfarg_str(n)
int n position number of a PLI system task/function arg.
```"," acc_fetch_tfarg(n)
int n position number of a PLI system task/function arg.

int acc_fetch_tfarg_int(n)
int n position number of a PLI system task/function arg.

char* acc_fetch_tfarg_str(n)
int n position number of a PLI system task/function arg.
","The image contains a text excerpt discussing the use of ACC (Application Control Center) routines in Verilog for reading and modifying values of system task/function arguments, emphasizing the uniqueness of system task/function instances within Verilog simulations.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p235.jpg,True,"The image contains examples of Verilog code. Here they are:

```verilog
a = $urandom_range(3, 10); // Pick a value from 3 to 10
a = $urandom_range(10, 3); // Pick a value from 3 to 10
b = $urandom_range(5);     // Pick a value from 0 to 5
```","
a = $urandom_range(3, 10); // Pick a value from 3 to 10
a = $urandom_range(10, 3); // Pick a value from 3 to 10
b = $urandom_range(5);     // Pick a value from 0 to 5
",Caption: Excerpt from a textbook discussing Verilog/SystemVerilog random number functions and providing examples of `$urandom_range` usage.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p221.jpg,True,"The image contains Verilog/SystemVerilog code for several examples. Below is the code transcribed from the image:

```verilog
Sample 6.15 Printing a histogram

initial begin
    Fib fib;
    int count[9], maxx[$];

    fib = new();

    repeat (20_000) begin
        `SV_RAND_CHECK(fib.randomize());
        count[fib.f]++; // Count the number of hits
    end
    maxx = count.max(); // Get largest value in count

    // Print histogram of count
    foreach(count[i])
        if (count[i]) begin
            $write(""count[%0d] =%5d "", i, count[i]);
            repeat (count[i]*40/maxx[0]) $write(""*"");
            $display;
        end
end

Sample 6.16 Histogram for inside constraint

count[1] = 3980 ****************************************************
count[2] = 3924 ****************************************************
count[3] = 3922 *****************************************************
count[5] = 4175 ******************************************************
count[8] = 3999 ****************************************************

Samples 6.17 and 6.18 choose a day of the week from a list of enumerated val-
ues. You can change the list of choices on the fly. If you make choice a randc
variable, the simulator tries every possible value before repeating.

Sample 6.17 Class to choose from an array of possible values

class Days;
    typedef enum {SUN, MON, TUE, WED,
                  THU, FRI, SAT} days_e;
    days_e choices[5];
    rand days_e choice;
    constraint cday {choice inside choices;}
endclass
```
The Verilog/SystemVerilog code highlights examples of creating a histogram, working with constraints, and choosing from enumerated types.","
Sample 6.15 Printing a histogram

initial begin
    Fib fib;
    int count[9], maxx[$];

    fib = new();

    repeat (20_000) begin
        `SV_RAND_CHECK(fib.randomize());
        count[fib.f]++; // Count the number of hits
    end
    maxx = count.max(); // Get largest value in count

    // Print histogram of count
    foreach(count[i])
        if (count[i]) begin
            $write(""count[%0d] =%5d "", i, count[i]);
            repeat (count[i]*40/maxx[0]) $write(""*"");
            $display;
        end
end

Sample 6.16 Histogram for inside constraint

count[1] = 3980 ****************************************************
count[2] = 3924 ****************************************************
count[3] = 3922 *****************************************************
count[5] = 4175 ******************************************************
count[8] = 3999 ****************************************************

Samples 6.17 and 6.18 choose a day of the week from a list of enumerated val-
ues. You can change the list of choices on the fly. If you make choice a randc
variable, the simulator tries every possible value before repeating.

Sample 6.17 Class to choose from an array of possible values

class Days;
    typedef enum {SUN, MON, TUE, WED,
                  THU, FRI, SAT} days_e;
    days_e choices[5];
    rand days_e choice;
    constraint cday {choice inside choices;}
endclass
","Caption: ""Examples of Verilog code for printing a histogram and utilizing constraints with enumerated values in system-level verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p102.jpg,True,"```verilog
$display(""Hand shake successful\n"");
else
begin
$display(""Hand shake failed: exiting\n"")
$finish();
end

for(i=0; i<64; i++)
begin
send_packet();
$display(""PACKET %0d sent\n"", i);
end

end
```

Additionally, there is another code snippet regarding SVA (SystemVerilog Assertions) using local variables:

```verilog
property p_local_var1;
int var1;
@(posedge clk)
($rose(enable1), var1 = a) |->
##1 (aa == (1var1*1var1*1var1));
endproperty

a_local_var1: assert property(p_local_var1);
```

Note: In the second code snippet, there seems to be a typographical error with `1var1` in the calculation. It's likely intended to be `var1`. Additionally, the `$rose` function is used to detect a rising edge on a boolean signal.","
$display(""Hand shake successful\n"");
else
begin
$display(""Hand shake failed: exiting\n"")
$finish();
end

for(i=0; i<64; i++)
begin
send_packet();
$display(""PACKET %0d sent\n"", i);
end

end


property p_local_var1;
int var1;
@(posedge clk)
($rose(enable1), var1 = a) |->
##1 (aa == (1var1*1var1*1var1));
endproperty

a_local_var1: assert property(p_local_var1);
","Caption: ""Excerpt from a book providing an introduction to SystemVerilog Assertions (SVA) with example code for handshake verification and local variable usage in properties.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p36.jpg,True,"The image contains Verilog code for an SR Latch. Here is the code as shown in the image:

```verilog
// ============================================================
// SR: An S-R Latch using ~ and &.
// ""SR"" means Set-Reset.
// This module represents the functionality of a simple latch,
// which is a sequential logic device, using combinational
// ~AND expressions connected to feed back on each other.
//
// ANSI module header.
//
// ============================================================
// 2005-04-09 jmw: v. 1.1 modified comment on wire declarations.
// 2004-11-25 jmw: v. 1.0 implemented.
// ============================================================

module SR (output Q, Qn, input S, R);
  wire q, qn; // For internal wiring.
  //
  assign #1 Q = q;
  assign #1 Qn = qn;
  //
  assign #10 q = ~(S & qn);
  assign #10 qn = ~(R & q);
  //
endmodule // SR.
```

This code defines a simple SR latch in Verilog, including comments about its functionality and the version history of the code.","
// ============================================================
// SR: An S-R Latch using ~ and &.
// ""SR"" means Set-Reset.
// This module represents the functionality of a simple latch,
// which is a sequential logic device, using combinational
// ~AND expressions connected to feed back on each other.
//
// ANSI module header.
//
// ============================================================
// 2005-04-09 jmw: v. 1.1 modified comment on wire declarations.
// 2004-11-25 jmw: v. 1.0 implemented.
// ============================================================

module SR (output Q, Qn, input S, R);
  wire q, qn; // For internal wiring.
  //
  assign #1 Q = q;
  assign #1 Qn = qn;
  //
  assign #10 q = ~(S & qn);
  assign #10 qn = ~(R & q);
  //
endmodule // SR.
","Caption: ""Verilog code for an SR Latch with accompanying schematic diagram from a Digital VLSI Design textbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p164.jpg,True,"```verilog
module rec_tri_4(pin);
    inout [3:0] pin;
    reg [3:0] ipin, opin;
    always @ (pin or opin) begin
        ipin = pin;
        $traza2x(ipin,pin,opin);
    end
    initial
        $initialState(opin);
endmodule // rec_tri_4
```","
module rec_tri_4(pin);
    inout [3:0] pin;
    reg [3:0] ipin, opin;
    always @ (pin or opin) begin
        ipin = pin;
        $traza2x(ipin,pin,opin);
    end
    initial
        $initialState(opin);
endmodule // rec_tri_4
","Caption: ""Example of Verilog code for a receiver module with initial state setup, alongside explanations on defining constants and compiler options in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p170.jpg,True,"The image contains examples of what appears to be the structure for Verilog code modules, but it doesn't contain actual Verilog code with specific functionality. It lays out templates for module organization without implementing specific logic or functionality. Here are the templates from the image:

Example 7-14:
```
<header comment block>
`include ""<file name>""
module <prefix><name><level number> (input-output);
    <input declarations>
    <clocks>
    <reset>
    <data>
    <output declarations>
    <inout declarations>
    <wire declarations>
    <major submodule instances - explicit port connections>
endmodule // <prefix><name><level number>
```

Example 7-15:
```
<header comment block>
`include ""<file name>""
module <prefix><name><level number> (input-output);
    <input declarations>
    <clocks>
    <reset>
    <data>
    <output declarations>
    <inout declarations>
    <wire declarations>
    <reg declarations>
    <always procedural blocks>
    <assign statements>
    <major submodule instances - explicit port connections>
    <library module instances - 
     may have implicit port connections>
endmodule // <prefix><name><level number>
```

The angle brackets (<>) are placeholders for actual names and declarations that should be replaced with relevant identifiers and code in a real Verilog module.","r comment block>
`include ""<file name>""
module <prefix><name><level number> (input-output);
    <input declarations>
    <clocks>
    <reset>
    <data>
    <output declarations>
    <inout declarations>
    <wire declarations>
    <major submodule instances - explicit port connections>
endmodule // <prefix><name><level number>

r comment block>
`include ""<file name>""
module <prefix><name><level number> (input-output);
    <input declarations>
    <clocks>
    <reset>
    <data>
    <output declarations>
    <inout declarations>
    <wire declarations>
    <reg declarations>
    <always procedural blocks>
    <assign statements>
    <major submodule instances - explicit port connections>
    <library module instances - 
     may have implicit port connections>
endmodule // <prefix><name><level number>
","Caption: ""Examples of Verilog module templates showing structure and elements for code organization.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p158.jpg,True,"The image contains Verilog code. Here is the transcription of the code:

```verilog
module one_hot(c_hot, c_code);
input [7:0] c_hot;
output [2:0] c_code;
reg [2:0] c_code;
always @ (c_hot) begin
    case (c_hot) //RTL synthesis full_case
        8'b10000000: c_code = 3'b000;
        8'b01000000: c_code = 3'b001;
        8'b00100000: c_code = 3'b010;
        8'b00010000: c_code = 3'b011;
        8'b00001000: c_code = 3'b100;
        8'b00000100: c_code = 3'b101;
        8'b00000010: c_code = 3'b110;
        8'b00000001: c_code = 3'b111;
        default: c_code = 3'b000; // causes 3X gates
    endcase
end //always (c_hot)
endmodule // one_hot
``` 

This code describes a Verilog module that translates a one-hot encoded input signal to a binary coded output signal.","
module one_hot(c_hot, c_code);
input [7:0] c_hot;
output [2:0] c_code;
reg [2:0] c_code;
always @ (c_hot) begin
    case (c_hot) //RTL synthesis full_case
        8'b10000000: c_code = 3'b000;
        8'b01000000: c_code = 3'b001;
        8'b00100000: c_code = 3'b010;
        8'b00010000: c_code = 3'b011;
        8'b00001000: c_code = 3'b100;
        8'b00000100: c_code = 3'b101;
        8'b00000010: c_code = 3'b110;
        8'b00000001: c_code = 3'b111;
        default: c_code = 3'b000; // causes 3X gates
    endcase
end //always (c_hot)
endmodule // one_hot
","""Example of a Verilog module implementing a one-hot decoder with a full case statement including a default case, highlighting concerns about synthesis minimization and gate count increase.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p171.jpg,True,"The image contains two snippets of Verilog code under the heading ""Example 7-16"":

a) Implicit port-order based signal connections input
```verilog
dff #(4) reg_head (_head, ck, c_head);
```

b) Explicit port-signal connections output
```verilog
dff #(4) reg_head (.d(c_head),
                   .ck(ck),
                   .q(r_head));
```","
dff #(4) reg_head (_head, ck, c_head);


dff #(4) reg_head (.d(c_head),
                   .ck(ck),
                   .q(r_head));
","Caption: ""Exploring Verilog connection styles with examples of implicit and explicit signal connections in RTL design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p220.jpg,True,"The image contains Verilog code. Here it is:

```verilog
constraint c_range {
    !(c inside {[lo:hi]});  // c < lo or c > hi
}
```

```verilog
class Fib;
    rand bit [7:0] f;
    bit [7:0] vals[ ] = '{1,2,3,5,8};
    constraint c_fibonacci {
        f inside vals;
    }
endclass
```

```verilog
constraint c_fibonacci {
    (f == vals[0]) ||  // f==1
    (f == vals[1]) ||  // f==2
    (f == vals[2]) ||  // f==3
    (f == vals[3]) ||  // f==5
    (f == vals[4]);    // f==8
}
```

```verilog
class NotFib;
    rand bit [7:0] notf;
    bit [7:0] vals[ ] = '{1,2,3,5,8};
    constraint c_fibonacci {
        !(notf inside vals);
    }
endclass
```","
constraint c_range {
    !(c inside {[lo:hi]});  // c < lo or c > hi
}


class Fib;
    rand bit [7:0] f;
    bit [7:0] vals[ ] = '{1,2,3,5,8};
    constraint c_fibonacci {
        f inside vals;
    }
endclass


constraint c_fibonacci {
    (f == vals[0]) ||  // f==1
    (f == vals[1]) ||  // f==2
    (f == vals[2]) ||  // f==3
    (f == vals[3]) ||  // f==5
    (f == vals[4]);    // f==8
}


class NotFib;
    rand bit [7:0] notf;
    bit [7:0] vals[ ] = '{1,2,3,5,8};
    constraint c_fibonacci {
        !(notf inside vals);
    }
endclass
","""Examples of Verilog constraints using arrays and sets for randomization.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p37.jpg,True,"```verilog
// ============================================================
// XorNor:  Combinational logic using ^ and ~|.
// This module represents simple combinational logic including
// an XOR and a NOR expression.
// 
// ANSI module header.
// ------------------------------------------------------------
// 2005-04-09 jmw: v. 1.1 modified comment on wire declarations.
// 2004-11-25 jmw: v. 1.0 implemented.
// ============================================================
module XorNor (output X, Y, input A, B, C);
wire x; // To illustrate use of internal wiring.
// ------------------------------------------------------------
assign #1 X = x; // Verilog is case-sensitive; 'X' and 'x' are different.
//
assign #10 x = A ^ B;
assign #10 Y = ~(x | C);
//
endmodule // XorNor.
```","
// ============================================================
// XorNor:  Combinational logic using ^ and ~|.
// This module represents simple combinational logic including
// an XOR and a NOR expression.
// 
// ANSI module header.
// ------------------------------------------------------------
// 2005-04-09 jmw: v. 1.1 modified comment on wire declarations.
// 2004-11-25 jmw: v. 1.0 implemented.
// ============================================================
module XorNor (output X, Y, input A, B, C);
wire x; // To illustrate use of internal wiring.
// ------------------------------------------------------------
assign #1 X = x; // Verilog is case-sensitive; 'X' and 'x' are different.
//
assign #10 x = A ^ B;
assign #10 Y = ~(x | C);
//
endmodule // XorNor.
","Caption: ""Schematic diagram and Verilog code snippet for a combinational logic circuit implementing the XOR and NOR functions in a module named XorNor.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p103.jpg,True,"The image contains Verilog SystemVerilog Assertion (SVA) code. Here is the code snippet from the image:

```verilog
property p_lvar_accum;
  int lvar;
  @(posedge clk) $rose(start) |=> (enable1 ##2 enable2, lvar = lvar + aa) [*4]
  ##1 (stop && (aout == lvar));
endproperty

a_lvar_accum : assert property(p_lvar_accum);
```

This Verilog code defines a property `p_lvar_accum` for use in formal verification to check certain conditions over time in a digital circuit design. Then it instantiates an assertion `a_lvar_accum` that asserts this property.","
property p_lvar_accum;
  int lvar;
  @(posedge clk) $rose(start) |=> (enable1 ##2 enable2, lvar = lvar + aa) [*4]
  ##1 (stop && (aout == lvar));
endproperty

a_lvar_accum : assert property(p_lvar_accum);
","""Simulation waveform and SystemVerilog Assertions (SVA) with local variables example in Verilog.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p549.jpg,True,"```verilog
$read_test_vector(""vectors.pat"", input_bus);
```

```c
char *file_name;
int bus_value;

file_name = acc_fetch_tfarg_str(1);
bus_value = acc_fetch_tfarg_int(2);
```","
$read_test_vector(""vectors.pat"", input_bus);

*file_name;
int bus_value;

file_name = acc_fetch_tfarg_str(1);
bus_value = acc_fetch_tfarg_int(2);
","Page from ""The Verilog PLI Handbook"" discussing ACC routines and error handling when reading system task/function arguments in Verilog PLI, with an example and C code snippet provided.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p234.jpg,True,"Here is the Verilog code present in the image:

```verilog
class Bathtub;
    int value; // Random variable with bathtub dist
    int WIDTH = 50, DEPTH=6, seed=1;

    function void pre_randomize();
        // Calculate an exponential curve
        value = $dist_exponential(seed, DEPTH);
        if (value > WIDTH) value = WIDTH;

        // Randomly put this point on the left or right curve
        if ($urandom_range(1)) // Random 0 or 1
            value = WIDTH - value;
    endfunction

endclass
```

This code snippet is for building a bathtub distribution as part of a randomization class in a hardware description language called Verilog. The `pre_randomize` function generates a value following an exponential curve and then places it randomly on either left or right side of the curve to create a bathtub-shaped distribution.","
class Bathtub;
    int value; // Random variable with bathtub dist
    int WIDTH = 50, DEPTH=6, seed=1;

    function void pre_randomize();
        // Calculate an exponential curve
        value = $dist_exponential(seed, DEPTH);
        if (value > WIDTH) value = WIDTH;

        // Randomly put this point on the left or right curve
        if ($urandom_range(1)) // Random 0 or 1
            value = WIDTH - value;
    endfunction

endclass
","""Verilog code example for building a bathtub distribution using exponential curves and randomization techniques.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p238.jpg,True,"The image contains examples of assertions using SystemVerilog properties. Here is the code from the image:

```verilog
initial a1: assert property(a ##[+] b);
initial a2: assert property(strong(a ##[+] b));

a3: assert property(!(a ##1 a |->
                  b[*1 ##1 c]));
a4: assert property(!(a ##1 a |->
                  strong(b[*1 ##1 c]));

c1: cover property(a ##[+] b);
c2: cover property(weak(a ##[+] b));
```

Additionally, there is a table of property operators with their associativity, but it is not executable code.","
initial a1: assert property(a ##[+] b);
initial a2: assert property(strong(a ##[+] b));

a3: assert property(!(a ##1 a |->
                  b[*1 ##1 c]));
a4: assert property(!(a ##1 a |->
                  strong(b[*1 ##1 c]));

c1: cover property(a ##[+] b);
c2: cover property(weak(a ##[+] b));
","""Exploration of Sequential Properties in Verilog with examples of assert and cover statements""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p210.jpg,True,"There is a snippet of code in the image:

```verilog
a1: assert property(req |-> nexttime[gnt] else $error(msg);
```

Please note that there may be a syntactic error in the code snippet as there is a missing closing parenthesis. The corrected code would be:

```verilog
a1: assert property(req |-> nexttime[gnt]) else $error(msg);
```","
a1: assert property(req |-> nexttime[gnt] else $error(msg);


a1: assert property(req |-> nexttime[gnt]) else $error(msg);
","Caption: ""Guidelines on specifying explicit types for SystemVerilog checker formal arguments and restrictions on checker contents.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p207.jpg,True,"Here is the code from the image:

```c
int my_data = 5;
PLIbook_set_vpiworkarea(systf_handle, (char *)my_data);

/***************************************************************/

int PLIbook_StartOfSim(p_cb_data cb_data)
{
    FILE *vector_file;

    /* add code to open the test vector file */

    /* store file pointer in a work area for this task instance */
    PLIbook_set_vpiworkarea(systf_handle, (char *)vector_file);

    return(0);
}

/***************************************************************/

int ReadVectorcalltf(char *user_data)
{
    FILE *vector_file;

    systf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* get file pointer from a work area for this task instance */
    vector_file = (FILE *)PLIbook_get_vpiworkarea(systf_handle);

    /* read next line from the file */

    return(0);
}
```

Please note that to use this code effectively, you would need to fill in the details of the functions `PLIbook_set_vpiworkarea`, `PLIbook_get_vpiworkarea`, and also add the actual file reading code in the `ReadVectorcalltf` function, as well as opening the file in `PLIbook_StartOfSim`. The code seems to be demonstrating the use of VPI callbacks in a C program that is interfacing with a Verilog simulation.","y_data = 5;
PLIbook_set_vpiworkarea(systf_handle, (char *)my_data);

/***************************************************************/

int PLIbook_StartOfSim(p_cb_data cb_data)
{
    FILE *vector_file;

    /* add code to open the test vector file */

    /* store file pointer in a work area for this task instance */
    PLIbook_set_vpiworkarea(systf_handle, (char *)vector_file);

    return(0);
}

/***************************************************************/

int ReadVectorcalltf(char *user_data)
{
    FILE *vector_file;

    systf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* get file pointer from a work area for this task instance */
    vector_file = (FILE *)PLIbook_get_vpiworkarea(systf_handle);

    /* read next line from the file */

    return(0);
}
","Caption: ""Example of using VPI callbacks in C to interact with Verilog simulations, demonstrating how to store and retrieve data in the application work area.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p561.jpg,True,"Below is the Verilog code from the image:

```verilog
reg [1:40] data;
```

And here is the C structure declaration from the image:

```c
typedef struct t_acc_vecval
{
  int aval;
  int bval;
} s_acc_vecval, *p_acc_vecval;
```","
reg [1:40] data;

ef struct t_acc_vecval
{
  int aval;
  int bval;
} s_acc_vecval, *p_acc_vecval;
","Caption: ""Mapping Verilog Vectors to C Integers using aval/bval pairs, as described in The Verilog PLI Handbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p576.jpg,True,"The image contains Verilog code snippets. Here they are:

Example A.1:
```verilog
logic [7:0] a = 8’h15;
```
Φ(a) = 8’h15.

Example A.2:
```verilog
logic [7:0] b;
```
Φ(a) = 8’hxx, because the variables of type logic are initialized by default with x.","
logic [7:0] a = 8’h15;


logic [7:0] b;
","""Understanding Default Sampled Values in SystemVerilog Expressions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p575.jpg,True,"```verilog
`timescale 1us/100ns //microsecond units, 3 decimal points
module B;
    ...
    nand #3.581 n1 (y, a, b);
    ...
endmodule
```

```c
void acc_fetch_timescale_info(object, timescale)
handle object;                                  // handle for a module instance, module definition, PLI system task/function, or null.
p_timescale_info timescale;                     // pointer to an application-allocated s_timescale_info structure to receive the timescale information.
```

```c
typedef struct t_timescale_info
{
    short unit;
    short precision;
} s_timescale_info, *p_timescale_info;
```","
`timescale 1us/100ns //microsecond units, 3 decimal points
module B;
    ...
    nand #3.581 n1 (y, a, b);
    ...
endmodule

acc_fetch_timescale_info(object, timescale)
handle object;                                  // handle for a module instance, module definition, PLI system task/function, or null.
p_timescale_info timescale;                     // pointer to an application-allocated s_timescale_info structure to receive the timescale information.

ef struct t_timescale_info
{
    short unit;
    short precision;
} s_timescale_info, *p_timescale_info;
","Caption: ""Understanding Time Scale Specification and Retrieval in Verilog, featuring a `timescale` directive and ACC routine usage to fetch time scale information from a module.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p562.jpg,True,"```verilog
input clock, reset, enable;
input req;
input ack;
output [`OVL_FIRE_WIDTH-1:0] fire;
//...
endmodule // ovl_handshake
```","
input clock, reset, enable;
input req;
input ack;
output [`OVL_FIRE_WIDTH-1:0] fire;
//...
endmodule // ovl_handshake
","""An excerpt from a text discussing Verilog checkers, their types, and characteristics, along with an example of Verilog code showing input and output declarations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p204.jpg,True,"Here is the Verilog code from the image:

```verilog
checker c_seqprotocol(start, complete,
    dataIn, dataOut,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable);
    
    default clocking @clk; endclocking
    default disable iff rst;
    
    property match(x, y);
        x |=> !x until_with y;
    endproperty : match
    
    var type(dataIn) last_dataIn;
    
    always_ff @clk
        if (start)
            last_dataIn <= dataIn;
            
    a_initial_no_complete:
        assert property ($fell(rst) |-> !complete until_with start);
    
    a_seq_data_check: assert property (
        complete |-> dataOut == last_dataIn );
        
    a_no_start: assert property (match(start, complete));
    a_no_complete: assert property (match(complete, start));
    
endchecker : c_seqprotocol
```

This code snippet defines a checker for a sequential protocol in SystemVerilog. It captures property specifications and assertions checking the behavior of the protocol, such as no completion without start and sequential data correctness.","
checker c_seqprotocol(start, complete,
    dataIn, dataOut,
    event clk = $inferred_clock,
    untyped rst = $inferred_disable);
    
    default clocking @clk; endclocking
    default disable iff rst;
    
    property match(x, y);
        x |=> !x until_with y;
    endproperty : match
    
    var type(dataIn) last_dataIn;
    
    always_ff @clk
        if (start)
            last_dataIn <= dataIn;
            
    a_initial_no_complete:
        assert property ($fell(rst) |-> !complete until_with start);
    
    a_seq_data_check: assert property (
        complete |-> dataOut == last_dataIn );
        
    a_no_start: assert property (match(start, complete));
    a_no_complete: assert property (match(complete, start));
    
endchecker : c_seqprotocol
","Caption: ""Example of a SystemVerilog sequential protocol verification using a checker construct.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p213.jpg,True,"```verilog
always @(posedge clock)
   $read_test_vector(""A.dat"", data_bus);

always @(negedge clock)
   $read_test_vector(""B.dat"", data_bus);
```","
always @(posedge clock)
   $read_test_vector(""A.dat"", data_bus);

always @(negedge clock)
   $read_test_vector(""B.dat"", data_bus);
","""Example of using VPI callbacks in Verilog simulations with $read_test_vector system task instances.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p208.jpg,True,"The image contains a snapshot from a book or document with exercises, including some Verilog code. Here is the code that is visible in the image:

```verilog
program automatic test;
    import my_package::*; // Define class Transaction

    initial begin
        // Declare an array of 5 Transaction handles
        // Call a generator task to create the objects
    end

    task generator(...); // Complete the task header
        // Create objects for every handle in the array
        // and transmit the object.
    endtask

    task transmit(Transaction tr);
        ......
    endtask : transmit

endprogram

package automatic my_package;
    class MemTrans;
        bit [7:0] data_in;
        bit [3:0] address;
        Statistics stats;
        function new();
            data_in = 3;
            address = 5;
            stats = new();
        endfunction
    endclass;
endpackage
```

This Verilog code snippet is related to a testbench program using classes and methods for hardware verification. It includes a program block, a class definition, and a package. The class `MemTrans` defined within the package `my_package` includes an initializer method `new()`. Some parts of the code are incomplete and intended for exercise purposes, with comments suggesting what the reader should do to complete the code.","
program automatic test;
    import my_package::*; // Define class Transaction

    initial begin
        // Declare an array of 5 Transaction handles
        // Call a generator task to create the objects
    end

    task generator(...); // Complete the task header
        // Create objects for every handle in the array
        // and transmit the object.
    endtask

    task transmit(Transaction tr);
        ......
    endtask : transmit

endprogram

package automatic my_package;
    class MemTrans;
        bit [7:0] data_in;
        bit [3:0] address;
        Statistics stats;
        function new();
            data_in = 3;
            address = 5;
            stats = new();
        endfunction
    endclass;
endpackage
","Verilog code snippet illustrating a test program with tasks for object generation and transmission, and a class definition in a package.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p220.jpg,True,"The image contains Verilog code. Here is the text from the code sections visible in the image:

```verilog
module pipelined_reqack // all arguments are inputs
(
    clk,
    req,
    ack,
    req_datain, // Used to sample data at request time.
    dataaout, // Data exiting fifo to compare.
    latency, // a constant expression
    pipedepth
);

// Setup two counters to tag the req' s and ack' s.
reg [3:0] req_cnt = 4'b0,
    ack_cnt = 4'b0;

// Update counters when req or ack event seen.
always @(posedge clk)
begin
    if (req) req_cnt <= req_cnt + 1'b1;
    if (ack) ack_cnt <= ack_cnt + 1'b1;
end

property req_no_ack;
    int cnt, req_data; // dynamic variables
    @(posedge clk)
    (req, cnt=req_cnt, req_data=req_datain |-> ##[1:latency] ack && ack_cnt==cnt
    ##0 req_data==dataaout);
endproperty

property exceeded_depth;
    @(posedge clk) (req_cnt - ack_cnt) < pipedepth;
endproperty

// We don't want to see an ack twice with the same tag without
// a request with that tag between them.
property no_extra_ack;
    reg [3:0] ackcnt; // dynamic variables
    @(posedge clk) not (ack, ackcnt=ack_cnt ##1 !(req && req_cnt == ackcnt) [* 1:$]
    ##0 ack && ackcnt == ack_cnt);
endproperty

assert property (req_no_ack)
    else $error(""Ack not received within timeout limits %0d or ack_check_seq failed."", latency);
assert property (exceeded_depth)
    else $error(""Exceeded pipedepth of interface."");
assert property (no_extra_ack)
    else $error(""Additional ack not matching req."");
endmodule
```
The code snippet is part of a pipelined request-acknowledge module in SystemVerilog, a hardware description and verification language used to model, design, and verify integrated circuits and systems.","
module pipelined_reqack // all arguments are inputs
(
    clk,
    req,
    ack,
    req_datain, // Used to sample data at request time.
    dataaout, // Data exiting fifo to compare.
    latency, // a constant expression
    pipedepth
);

// Setup two counters to tag the req' s and ack' s.
reg [3:0] req_cnt = 4'b0,
    ack_cnt = 4'b0;

// Update counters when req or ack event seen.
always @(posedge clk)
begin
    if (req) req_cnt <= req_cnt + 1'b1;
    if (ack) ack_cnt <= ack_cnt + 1'b1;
end

property req_no_ack;
    int cnt, req_data; // dynamic variables
    @(posedge clk)
    (req, cnt=req_cnt, req_data=req_datain |-> ##[1:latency] ack && ack_cnt==cnt
    ##0 req_data==dataaout);
endproperty

property exceeded_depth;
    @(posedge clk) (req_cnt - ack_cnt) < pipedepth;
endproperty

// We don't want to see an ack twice with the same tag without
// a request with that tag between them.
property no_extra_ack;
    reg [3:0] ackcnt; // dynamic variables
    @(posedge clk) not (ack, ackcnt=ack_cnt ##1 !(req && req_cnt == ackcnt) [* 1:$]
    ##0 ack && ackcnt == ack_cnt);
endproperty

assert property (req_no_ack)
    else $error(""Ack not received within timeout limits %0d or ack_check_seq failed."", latency);
assert property (exceeded_depth)
    else $error(""Exceeded pipedepth of interface."");
assert property (no_extra_ack)
    else $error(""Additional ack not matching req."");
endmodule
","Caption: ""Example of a SystemVerilog pipelined request-acknowledge (reqack) module with related properties and assertions to check the protocol behavior.""
",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p204.jpg,True,"This image contains snippets of Verilog code. Below is the code you requested:

```verilog
assert property (p_req_ack) $display(""passed"");
else $display(""failed"");

assert property (p_req_ack) req_ack_count++; else $error; // GOTCHA

property p_req_ack;
  @(posedge clk) req |-> ##1 ack; // if req, check for ack
                                  // on next cycle
endproperty
``` 

These are code samples related to SystemVerilog assertions.","
assert property (p_req_ack) $display(""passed"");
else $display(""failed"");

assert property (p_req_ack) req_ack_count++; else $error; // GOTCHA

property p_req_ack;
  @(posedge clk) req |-> ##1 ack; // if req, check for ack
                                  // on next cycle
endproperty
","""Discussion of vacuous success in Verilog assertions and a code example showing an assert property statement.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p112.jpg,True,"The image contains Verilog code. Here it is transcribed:

```verilog
// (continued from above)
always @(ClockIn, Reset)
begin : MakeDecision
if (Reset=='b1)
begin
Adjr = 2'b1; // No change code.
Done = 'b0;
AvgEdge = 4'h8; // 7..9 mean no adjustment of VFO freq.
end
else begin // Update the AvgEdge & check for decision:
case (EdgeCode)
2'b11: AvgEdge = AvgEdge + 1; // Add to PLL edge count.
2'b00: AvgEdge = AvgEdge - 1; // Sub from PLL edge count.
// default: do nothing.
endcase
Done = Done + 1;
if (Done=='b0) // Wrap-around.
begin
if ( AvgEdge<7 )
Adjr = 2'b11; // Better speed it up.
else if ( AvgEdge>9 )
Adjr = 2'b00; // Must be too fast.
else Adjr = 2'b01; // No change.
AvgEdge = 4'h8; // Initialize for next average.
end
end // of MakeDecision.
endmodule // SmoothComparator.
```

Please, make sure to check the source for any syntax errors and adherence to the project's coding guidelines as this is a direct transcription from the image.","
// (continued from above)
always @(ClockIn, Reset)
begin : MakeDecision
if (Reset=='b1)
begin
Adjr = 2'b1; // No change code.
Done = 'b0;
AvgEdge = 4'h8; // 7..9 mean no adjustment of VFO freq.
end
else begin // Update the AvgEdge & check for decision:
case (EdgeCode)
2'b11: AvgEdge = AvgEdge + 1; // Add to PLL edge count.
2'b00: AvgEdge = AvgEdge - 1; // Sub from PLL edge count.
// default: do nothing.
endcase
Done = Done + 1;
if (Done=='b0) // Wrap-around.
begin
if ( AvgEdge<7 )
Adjr = 2'b11; // Better speed it up.
else if ( AvgEdge>9 )
Adjr = 2'b00; // Must be too fast.
else Adjr = 2'b01; // No change.
AvgEdge = 4'h8; // Initialize for next average.
end
end // of MakeDecision.
endmodule // SmoothComparator.
","""Excerpt from a Verilog code showing an always block for decision-making in digital VLSI design, with a focus on updating average edge counts and frequency adjustment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p210.jpg,True,"```verilog
property p_req_ack2;
  @(posedge clk)
    $rose(req) |-> ##[1:5] $rose(ack)
                ##[1:5] $rose(done) ##1 $fell(bus_en);  // GOTCHA!
endproperty

property p_req_ack;
  @(posedge clk) $rose(req) |-> ##[1:5] $rose(ack);  // OK
endproperty

property p_ack_done;
  @(posedge clk) $rose(ack) |-> ##1 $rose(done);  // OK
endproperty

property p_req_ack2;
  @(posedge clk)
    $rose(req) |-> ##1 ($rose(ack) [-1]) ##1 $rose(done);  // OK
endproperty
```","
property p_req_ack2;
  @(posedge clk)
    $rose(req) |-> ##[1:5] $rose(ack)
                ##[1:5] $rose(done) ##1 $fell(bus_en);  // GOTCHA!
endproperty

property p_req_ack;
  @(posedge clk) $rose(req) |-> ##[1:5] $rose(ack);  // OK
endproperty

property p_ack_done;
  @(posedge clk) $rose(ack) |-> ##1 $rose(done);  // OK
endproperty

property p_req_ack2;
  @(posedge clk)
    $rose(req) |-> ##1 ($rose(ack) [-1]) ##1 $rose(done);  // OK
endproperty
","""Exploring Verilog gotchas related to property specifications and strategies to avoid infinite waiting for conditions in system-level verification""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p234.jpg,True,"Here is the code from the image:

Example 7-4 PSL FIFO underflow with feed forward design
```verilog
assert never ((cnt == 0) & !push & pop);   // Example 7-1
assert never ((wptr == rptr) & {!full | push & pop}); // Example 7-2
```

Example 7-5 PSL FIFO underflow without feed forward
```verilog
assert never ((cnt == 0) & pop);  // for Example 7-1
assert never ((wptr == rptr) & {!full & pop}); // for Example 7-2
```","
assert never ((cnt == 0) & !push & pop);   // Example 7-1
assert never ((wptr == rptr) & {!full | push & pop}); // Example 7-2


assert never ((cnt == 0) & pop);  // for Example 7-1
assert never ((wptr == rptr) & {!full & pop}); // for Example 7-2
","""Verilog Assertions for Detecting FIFO Underflow Conditions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p299.jpg,True,"The image includes two pieces of Verilog code. Here is the code presented in the image:

```verilog
sequence rd_detect(ptr);
    ##[0:$] (read_en && !empty && (aff1.rd_ptr == ptr));
endsequence

property data_check(wr_ptr);
    integer ptr, data;
    @(posedge wclk) disable iff (!wclk_reset_n || !rclk_reset_n)
        (write_en && !full; ptr=wr_ptr, data=fifo_in,
            $display($stime, ""\t Assertion Disp wr_ptr=%h data=%h"", wr_ptr, fifo_in))
    |=>
        rd_detect(ptr) throughout (ptr == wr_ptr && data == fifo_out);
endproperty
```

In the code snippet, a sequence `rd_detect` and a property `data_check` are defined for use in assertion-based verification within a SystemVerilog testbench to ensure the correct behavior of a FIFO buffer.","
sequence rd_detect(ptr);
    ##[0:$] (read_en && !empty && (aff1.rd_ptr == ptr));
endsequence

property data_check(wr_ptr);
    integer ptr, data;
    @(posedge wclk) disable iff (!wclk_reset_n || !rclk_reset_n)
        (write_en && !full; ptr=wr_ptr, data=fifo_in,
            $display($stime, ""\t Assertion Disp wr_ptr=%h data=%h"", wr_ptr, fifo_in))
    |=>
        rd_detect(ptr) throughout (ptr == wr_ptr && data == fifo_out);
endproperty
","Caption: ""Excerpt from a document explaining asynchronous FIFO test-bench and assertions in Verilog, including code samples for sequence and property definitions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p208.jpg,True,"The image contains snippets of Verilog code. Here are the two code examples included in the image:

Example 6-31:
```verilog
// declarative assertion
// assert cache will not return a hit within 4 cycles after invalidate
assert_cycle_sequence #(0,4) inv_hit
  (clk, 'TRUE, invalidate, (4{!hit}));
```

Example 6-32:
```verilog
// declarative assertion
// assert cache will not return a hit within 4 cycle after invalidate
assert property (@ (posedge clk) disable iff (reset_n)
  (invalidate |=> !hit [+'4]));
```","
// declarative assertion
// assert cache will not return a hit within 4 cycles after invalidate
assert_cycle_sequence #(0,4) inv_hit
  (clk, 'TRUE, invalidate, (4{!hit}));


// declarative assertion
// assert cache will not return a hit within 4 cycle after invalidate
assert property (@ (posedge clk) disable iff (reset_n)
  (invalidate |=> !hit [+'4]));
","""Verilog Assertions for Checking Cache Response within 4 Cycles and Explanation of Window Patterns in Hardware Verification""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p301.jpg,True,"The image contains snippets of code, which appear to be written in SystemVerilog Assertions (SVA) used for verifying hardware designs. Here is the code from the image:

```
not $fell (gntn[3]);
endproperty

a_schK3: assert property(p_schK3);
c_schK3: cover property(p_schK3);

sequence s_schK4a;
@(posedge clk)
first_match($fell (lockn) ##[0:5] !devseln);
endsequence

sequence s_schK4b;
@(posedge clk)
framen && !irdyn && (!trdyn || !stopn);
endsequence

property p_schK4;
@(posedge clk)
s_schK4a |-> !lockn [*1:$] ##0 s_schK4b;
endproperty

a_schK4: assert property(p_schK4);
c_schK4: cover property(p_schK4);

property p_schK5;
@(posedge clk)
$fell (lockn) |->
    (($past (framen) == 0)
    && ($past(framen,2) == 1));
endproperty

a_schK5: assert property(p_schK5);
c_schK5: cover property(p_schK5);
```

Please note that these are assertions and sequences that could be part of a larger SystemVerilog verification code. They are used to specify certain properties of the signals in a Verilog design to be checked during simulation.","ell (gntn[3]);
endproperty

a_schK3: assert property(p_schK3);
c_schK3: cover property(p_schK3);

sequence s_schK4a;
@(posedge clk)
first_match($fell (lockn) ##[0:5] !devseln);
endsequence

sequence s_schK4b;
@(posedge clk)
framen && !irdyn && (!trdyn || !stopn);
endsequence

property p_schK4;
@(posedge clk)
s_schK4a |-> !lockn [*1:$] ##0 s_schK4b;
endproperty

a_schK4: assert property(p_schK4);
c_schK4: cover property(p_schK4);

property p_schK5;
@(posedge clk)
$fell (lockn) |->
    (($past (framen) == 0)
    && ($past(framen,2) == 1));
endproperty

a_schK5: assert property(p_schK5);
c_schK5: cover property(p_schK5);
",Verilog Assertions for Protocol Interface Verification,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p272.jpg,True,"The image contains the following Verilog code:

```verilog
sequence RstSeq;
   l_rst ##2 rst;
endsequence

property s_rc1(seq,sra,srb);
   seq |=> sra ##1 srb;
endproperty

baseP: assert property (@(posedge clk) s_rc1 (RstSeq, L1ifaceReady, L1RdRequest)) else gotoFail;
```

This excerpt is from a technical document discussing the use of sequences as formal arguments in Verilog properties.","
sequence RstSeq;
   l_rst ##2 rst;
endsequence

property s_rc1(seq,sra,srb);
   seq |=> sra ##1 srb;
endproperty

baseP: assert property (@(posedge clk) s_rc1 (RstSeq, L1ifaceReady, L1RdRequest)) else gotoFail;
","Caption: ""An excerpt from a technical document explaining the use of sequences as formal arguments in SystemVerilog properties, with an example of Reset Sequence usage.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p514.jpg,True,"```verilog
bit [7:0] adr;
bit [1:0] offset;

covergroup cg1 (int iW, string iComment) @(posedge clk);
  option.per_instance = 1;
  option.comment = iComment;
  
  adr: coverpoint adr
    {
      option.auto_bin_max = 4;
    }
  ofst: coverpoint offset
    {
      option.weight = iW;
    }
endgroup

cg1 cg1Inst = new(2,""Coverage for cg1Inst"");
cg1 cg2Inst = new(3,""Coverage for cg2Inst"");
```","
bit [7:0] adr;
bit [1:0] offset;

covergroup cg1 (int iW, string iComment) @(posedge clk);
  option.per_instance = 1;
  option.comment = iComment;
  
  adr: coverpoint adr
    {
      option.auto_bin_max = 4;
    }
  ofst: coverpoint offset
    {
      option.weight = iW;
    }
endgroup

cg1 cg1Inst = new(2,""Coverage for cg1Inst"");
cg1 cg2Inst = new(3,""Coverage for cg2Inst"");
",Example of Verilog coverage group instance-specific options with annotations explaining each part of the code.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p500.jpg,True,"The image contains Verilog code related to functional coverage. Here's the code written in the image:

```verilog
bins c2 = binsof(a.a2) || binsof(b.b2);

bins c3 = binsof(a.a1) && binsof(b.b4);
```

The code demonstrates the use of ""binsof"" and logical operators to define cross coverage bins in a Verilog functional coverage block. ""binsof"" is used to reference bins defined for other coverpoints, and logical operators like OR (`||`) and AND (`&&`) are used to combine those into cross coverage bins.","
bins c2 = binsof(a.a2) || binsof(b.b2);

bins c3 = binsof(a.a1) && binsof(b.b4);
","""Understanding Cross Bins in Functional Coverage Using Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p266.jpg,True,"The image contains examples of code in the Verilog hardware description language. Here are the code excerpts provided in the image:

First code block:
```verilog
always @(posedge (dma_intr | intr) begin
    intrIn = intr;
    a1: assert property (z |=> d | e); //ILLEGAL
    ....
end
```

Second code block:
```verilog
always @(posedge dma_intr or posedge intr) begin
    .......
    a1: assert property (z |=> d | e); //ILLEGAL
    .......
end
```

Third code block:
```verilog
logic [7:0] a;
logic [15:0] b;
always @(posedge clk) begin
    If (!reset) begin
        for (int i = 0; i < 4; i++) begin
            ....
            z1: assert property (a [i] ##[1:16] b[i]);
        end
    end
end
end
```

The image explains the context of embedding concurrent assertions in procedural blocks and highlights cases that are considered illegal in Verilog because of issues related to clock inference and ambiguity. The third code block illustrates the correct use of assertions in a 'for' loop with an inferred clock within a procedural block.","
always @(posedge (dma_intr | intr) begin
    intrIn = intr;
    a1: assert property (z |=> d | e); //ILLEGAL
    ....
end


always @(posedge dma_intr or posedge intr) begin
    .......
    a1: assert property (z |=> d | e); //ILLEGAL
    .......
end


logic [7:0] a;
logic [15:0] b;
always @(posedge clk) begin
    If (!reset) begin
        for (int i = 0; i < 4; i++) begin
            ....
            z1: assert property (a [i] ##[1:16] b[i]);
        end
    end
end
end
","Caption: ""Examples of illegal embedding of concurrent assertions in procedural blocks with explanations, and a correct usage within a for loop in Verilog.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p315.jpg,True,"```verilog
a <= !logical_op_reg[0];
b <= !logical_op_reg[1];
repeat(1) @(posedge clk);
logical_op_reg++;
```
The snippet of code provided is written in Verilog, which is a hardware description language used to model electronic systems. This code appears to be part of a sequential logic block where the negated values of two elements within a register array `logical_op_reg` are being assigned to signals `a` and `b`, and there is a clock edge wait statement followed by an increment operation on `logical_op_reg`.","
a <= !logical_op_reg[0];
b <= !logical_op_reg[1];
repeat(1) @(posedge clk);
logical_op_reg++;
","Caption: ""Verilog sample code and timing diagrams illustrating logical conditions on edge-based signals.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p777.jpg,True,"The image contains code related to Verilog within a documented section. Here is the code transcribed from the image:

```c
typedef struct t_setval_value {
    int format;              /* accBinStrVal, accOctStrVal,
                                accDecStrVal, accHexStrVal,
                                accScalarVal, accIntVal,
                                accRealVal, accStringVal,
                                accVectorVal */
    union {
        char *str;
        int scalar;
        int integer;
        double real;
        p_acc_vecval vector;
    } value;
} s_setval_value, *p_setval_value,
  s_acc_value, *p_acc_value;

typedef struct t_acc_vecval {
    int aval;
    int bval;
} s_acc_vecval, *p_acc_vecval;

typedef struct t_setval_delay {
    s_acc_time time;
    int model;
} s_setval_delay, *p_setval_delay;
```

This code defines structures used for setting values and delays in a Verilog simulation environment, commonly used with the Verilog PLI (Programming Language Interface).","ef struct t_setval_value {
    int format;              /* accBinStrVal, accOctStrVal,
                                accDecStrVal, accHexStrVal,
                                accScalarVal, accIntVal,
                                accRealVal, accStringVal,
                                accVectorVal */
    union {
        char *str;
        int scalar;
        int integer;
        double real;
        p_acc_vecval vector;
    } value;
} s_setval_value, *p_setval_value,
  s_acc_value, *p_acc_value;

typedef struct t_acc_vecval {
    int aval;
    int bval;
} s_acc_vecval, *p_acc_vecval;

typedef struct t_setval_delay {
    s_acc_time time;
    int model;
} s_setval_delay, *p_setval_delay;
","This image shows a page from the IEEE 1364-1995 ACC Routine Library, specifically documenting the `acc_set_value` function and associated data structures in Verilog.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p329.jpg,True,"The image contains Verilog code. Here is the code written in the image:

```verilog
// sample Verilog test code for repetition

logic [1:0] stop_wait;

if(rpt_edge == 2'b11) begin
  a = 1'b0; b=1'b0; end

if(rpt_edge == 2'b00) begin
  a = 1'b1; b=1'b1; end

if(rpt_edge == 2'b01) begin
  a = 1'b1; b=1'b0; end

if(rpt_edge == 2'b10) begin
  a = 1'b0; b=1'b1; end

for(i=(repetition-1); i<(repetition+3); i++)
begin
  repeat(1) @(posedge clk);
  a <= ~a;
  repeat(start_wait) @(posedge clk);
  b <= ~b;

// consecutive repeat condition

  repeat((i)) @(posedge clk);
  b <= ~b;
  stop_wait <= $random() % 4;
  repeat(stop_wait[0]) @(posedge clk);
  a <= ~a;
end
```","
// sample Verilog test code for repetition

logic [1:0] stop_wait;

if(rpt_edge == 2'b11) begin
  a = 1'b0; b=1'b0; end

if(rpt_edge == 2'b00) begin
  a = 1'b1; b=1'b1; end

if(rpt_edge == 2'b01) begin
  a = 1'b1; b=1'b0; end

if(rpt_edge == 2'b10) begin
  a = 1'b0; b=1'b1; end

for(i=(repetition-1); i<(repetition+3); i++)
begin
  repeat(1) @(posedge clk);
  a <= ~a;
  repeat(start_wait) @(posedge clk);
  b <= ~b;

// consecutive repeat condition

  repeat((i)) @(posedge clk);
  b <= ~b;
  stop_wait <= $random() % 4;
  repeat(stop_wait[0]) @(posedge clk);
  a <= ~a;
end
","Caption: ""Verilog test code demonstrating the use of 'repeat' conditions for generating stimulus in hardware verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p195.jpg,True,"The image contains two code samples described as examples of Verilog code related to the object-oriented programming (OOP) concept of handling transactions.

The first code sample is labeled ""Sample 5.26 Bad transaction creator task, missing ref on handle"" and contains the following Verilog code:

```verilog
function void create(Transaction tr); // Bug, missing ref
  tr = new();
  tr.addr = 42;
  // Initialize other fields
  ...
endfunction
```

The second code sample is labeled ""Sample 5.27 Good transaction creator task with ref on handle"" and contains the following code:

```verilog
function void create(ref Transaction tr);
  ...
endfunction : create
```

The text also mentions that a method that modifies the handle of an object should declare the handle as an input argument with the `ref` keyword.","
function void create(Transaction tr); // Bug, missing ref
  tr = new();
  tr.addr = 42;
  // Initialize other fields
  ...
endfunction


function void create(ref Transaction tr);
  ...
endfunction : create
","Caption: ""Understanding the importance of using the 'ref' keyword when passing object handles in Verilog functions to allow modifications.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p181.jpg,True,"The image contains a snippet of Verilog code. Here is the code provided in the image:

```verilog
Transaction t;        // Declare a handle to a Transaction
t = new();            // Construct a Transaction object
t.addr = 32'h42;      // Set the value of a variable
t.display();          // Call a routine
```

This sample shows how to declare a handle to an object, construct the object, set a value of a variable in the object, and call a method of the object.","
Transaction t;        // Declare a handle to a Transaction
t = new();            // Construct a Transaction object
t.addr = 32'h42;      // Set the value of a variable
t.display();          // Call a routine
","""An excerpt from a textbook discussing object-oriented principles in SystemVerilog with an example code snippet.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p340.jpg,True,"The image contains a list but not any specific code. The content presented is a table labeled ""Table B.1 PSL Keywords"" from a reference manual, detailing keywords used in Property Specification Language (PSL). Here are the keywords listed in the table:

```
A                  E                  never             sequence
AF                 EF                 next              stable
AG                 EG                 next!             strong
AX                 EX                 next_a            t0^5
abort              endpoint           next_a!           U
always             eventually!        next_e            union
and'               F                  next_e!           until
assert             fairness           next_event        until!
assume             fell               next_event!       until_!
assume_guarantee   for all            next_event_a      vmode
e                                     next_event_a!     vprop
before             G                  next_event_e      vunit
before!            in                 next_event_e!     W
before!_           inf                not^3             within
before_boolean     inherit
clock              is^2               onehot            X
const              is unknown         onehot0           X!
countones                             or^4
cover              property
                   prev
default            report
                   rose
```

Footnotes indicate that some keywords like `not`, `or`, `is`, and `t0` are only in the VHDL flavor of PSL.

Please note that while this is not executable code, it is related to writing specifications in Verilog, using PSL for verification purposes.","             E                  never             sequence
AF                 EF                 next              stable
AG                 EG                 next!             strong
AX                 EX                 next_a            t0^5
abort              endpoint           next_a!           U
always             eventually!        next_e            union
and'               F                  next_e!           until
assert             fairness           next_event        until!
assume             fell               next_event!       until_!
assume_guarantee   for all            next_event_a      vmode
e                                     next_event_a!     vprop
before             G                  next_event_e      vunit
before!            in                 next_event_e!     W
before!_           inf                not^3             within
before_boolean     inherit
clock              is^2               onehot            X
const              is unknown         onehot0           X!
countones                             or^4
cover              property
                   prev
default            report
                   rose
","The image shows a table of PSL (Property Specification Language) keywords as referenced in a section on assertion-based design, highlighting their case sensitivity and specific usage in VHDL contexts.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p207.jpg,True,"```verilog
casex (1'b1) //RTL synthesis parallel_case
  c_hot[7] : c_code = 3'b000;
  c_hot[6] : c_code = 3'b001;
  c_hot[5] : c_code = 3'b010;
  c_hot[4] : c_code = 3'b011;
  c_hot[3] : c_code = 3'b100;
  c_hot[2] : c_code = 3'b101;
  c_hot[1] : c_code = 3'b110;
  c_hot[0] : c_code = 3'b111;
endcase
```","
casex (1'b1) //RTL synthesis parallel_case
  c_hot[7] : c_code = 3'b000;
  c_hot[6] : c_code = 3'b001;
  c_hot[5] : c_code = 3'b010;
  c_hot[4] : c_code = 3'b011;
  c_hot[3] : c_code = 3'b100;
  c_hot[2] : c_code = 3'b101;
  c_hot[1] : c_code = 3'b110;
  c_hot[0] : c_code = 3'b111;
endcase
","""Discussion on state machines in Verilog, highlighting the use of case and casex, with a parallel_case example code snippet.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p213.jpg,True,"The image contains Verilog code. Here is the code from the image:

```verilog
a) Custom-timed inserted states
always @(posedge ck)
begin
  o_ad_valid  <= #0.01 2'bz;
  o_ad_valIdb <= #0.01 2'bz;
  o_trans_id  <= #0.01 6'bz;
  o_master_id <= #0.01 3'bz;
end

b) Common-timed inserted states
always @(posedge ck)
begin
  o_ad_valid  <= `DELAYNBA 2'bz;
  o_ad_valIdb <= `DELAYNBA 2'bz;
  o_trans_id  <= `DELAYNBA 6'bz;
  o_master_id <= `DELAYNBA 3'bz;
end

c) Clock-timed inserted states
always @(posedge `top.ck_i)
begin
  o_ad_valid  <= 2'bz;
  o_ad_valIdb <= 2'bz;
  o_trans_id  <= 6'bz;
  o_master_id <= 3'bz;
end
```

Note: The code snippets are examples of how to insert different kinds of delays in Verilog testbenches. They use a construct `always @(posedge ...)` to perform operations at the rising edge of a clock signal, and `<=` represents a non-blocking assignment with an optional delay specified before the value. Also, `2'bz`, `6'bz`, and `3'bz` are values representing high-impedance states for 2, 6, and 3 bit signals, respectively. There might be a typo in the 'o_ad_validb' identifier—it seems inconsistent with the other identifiers and could be intended to match 'o_ad_valid'. Also, please note the use of the backtick (`) for 'DELAYNBA' and '`top.ck_i', which usually indicates a macro or a global definition in Verilog.","
a) Custom-timed inserted states
always @(posedge ck)
begin
  o_ad_valid  <= #0.01 2'bz;
  o_ad_valIdb <= #0.01 2'bz;
  o_trans_id  <= #0.01 6'bz;
  o_master_id <= #0.01 3'bz;
end

b) Common-timed inserted states
always @(posedge ck)
begin
  o_ad_valid  <= `DELAYNBA 2'bz;
  o_ad_valIdb <= `DELAYNBA 2'bz;
  o_trans_id  <= `DELAYNBA 6'bz;
  o_master_id <= `DELAYNBA 3'bz;
end

c) Clock-timed inserted states
always @(posedge `top.ck_i)
begin
  o_ad_valid  <= 2'bz;
  o_ad_valIdb <= 2'bz;
  o_trans_id  <= 6'bz;
  o_master_id <= 3'bz;
end
","""Examples of different techniques for inserting delays in Verilog testbenches.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p275.jpg,True,"The image contains a screenshot from a book or document with text and a waveform diagram related to a protocol interface, likely from a section about SystemVerilog Assertions (SVA) for protocol interfaces. There is Verilog code in the image, and here it is transcribed:

```verilog
property p_mchk14;
@(posedge clk)
(!ack64n && !irdyn && !trdyn && !devseln) &&
(^{ad[63:32]*cxben[7:4]} == 1) |=> 
par64;

endproperty

a_mchk14: assert property(p_mchk14);
c_mchk14: cover property(p_mchk14);
```

Note: The text within curly braces `{}` in `ad[63:32]*cxben[7:4]` might represent bitwise concatenation (usually done with `{}` in SystemVerilog), but the multiplication symbol `*` could be a typo or print artifact causing confusion—it's not valid syntax for concatenation. The correct syntax should be checked against the source document or the intended implementation.","
property p_mchk14;
@(posedge clk)
(!ack64n && !irdyn && !trdyn && !devseln) &&
(^{ad[63:32]*cxben[7:4]} == 1) |=> 
par64;

endproperty

a_mchk14: assert property(p_mchk14);
c_mchk14: cover property(p_mchk14);
","A Verilog code snippet showcasing the use of SystemVerilog Assertions (SVA) for protocol interface checking, specifically for checking the parity of a 64-bit signal in PCI transactions.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p306.jpg,True,"Here is the Verilog code from the image:

```verilog
module glitch_detect_SVA ( );
  parameter duration = 3ns;
  logic glitch;

  //The following property checks to see that signal 'glitch'
  //stays high for greater than (or equal to) the 'duration'
  //(i.e. the glitch width). If so, the property PASSES or else
  //it FAILs. In other words, if the width of signal 'glitch'
  //is less than the duration, it's a glitch.
  //You can parametrize the property 'detect_glitch' to make it
  //generic for different glitch widths.

  property detect_glitch;
    time leading; //local variable 'leading' of type 'time'.

    @(glitch) //Sampling edge is asynchronous
    //At asynchronous edge of signal 'glitch', store the time at
    //which it changed in the local variable 'leading'.
    (1'b1, leading=$time)
    |=> //Non-overlapping signifies @ the next asynchronous
        //change in signal 'glitch'
        (
          ($time - leading) >= duration
        )
    //At the next change in 'glitch', subtract the 'leading' time
    //from the current time. That gives us the width of the signal.
    //Check to see that it's >= the signal 'glitch' duration.
    //If so, the property passes.
  ;
```

This Verilog code defines a module for glitch detection using SystemVerilog Assertions (SVA). It includes the definition of the property `detect_glitch` that checks whether the signal `glitch` stays high for a duration equal to or greater than a specified value.","
module glitch_detect_SVA ( );
  parameter duration = 3ns;
  logic glitch;

  //The following property checks to see that signal 'glitch'
  //stays high for greater than (or equal to) the 'duration'
  //(i.e. the glitch width). If so, the property PASSES or else
  //it FAILs. In other words, if the width of signal 'glitch'
  //is less than the duration, it's a glitch.
  //You can parametrize the property 'detect_glitch' to make it
  //generic for different glitch widths.

  property detect_glitch;
    time leading; //local variable 'leading' of type 'time'.

    @(glitch) //Sampling edge is asynchronous
    //At asynchronous edge of signal 'glitch', store the time at
    //which it changed in the local variable 'leading'.
    (1'b1, leading=$time)
    |=> //Non-overlapping signifies @ the next asynchronous
        //change in signal 'glitch'
        (
          ($time - leading) >= duration
        )
    //At the next change in 'glitch', subtract the 'leading' time
    //from the current time. That gives us the width of the signal.
    //Check to see that it's >= the signal 'glitch' duration.
    //If so, the property passes.
  ;
","Caption: ""An excerpt from a document explaining glitch detection in Verilog using SystemVerilog Assertions (SVA) with annotated code example.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p460.jpg,True,"The image contains examples of Verilog code pertaining to functional coverage using coverpoints and bins with expressions. Here's the code that is visible in the image:

First snippet:
```verilog
bit cp_parity: coverpoint $countones(serial_word)
{
    bins set_bits_count[ ] = {[0:$bits(serial_word)]};
}
```

Second snippet:
```verilog
int myValue, x;
a: coverpoint x
{
    bins mod6[ ] = {[0:255]} with (myValue % 6 == 0);
}
```

Third snippet:
```verilog
a: coverpoint x
{
    bins mod3[ ] = {[0:255]} with ((myValue % 2) || (yourValue % 3) 
    || no_value);
}
```

Fourth snippet:
```verilog
a: coverpoint x
{
    bins func[ ] = x with (myValue % 6 == 0) iff (!reset);
}
```

These snippets showcase how to define bins based on certain conditions using the ""with"" and ""iff"" clauses. Each block defines a coverage point ""a"" and the associated bins that are used to capture and categorize the values of the variable ""x"" based on different conditions for functional coverage analysis.","
bit cp_parity: coverpoint $countones(serial_word)
{
    bins set_bits_count[ ] = {[0:$bits(serial_word)]};
}


int myValue, x;
a: coverpoint x
{
    bins mod6[ ] = {[0:255]} with (myValue % 6 == 0);
}


a: coverpoint x
{
    bins mod3[ ] = {[0:255]} with ((myValue % 2) || (yourValue % 3) 
    || no_value);
}


a: coverpoint x
{
    bins func[ ] = x with (myValue % 6 == 0) iff (!reset);
}
","Caption: ""Examples of Verilog code for coverpoint and bin definitions with bit count and filtering using the 'with' clause in functional coverage.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p156.jpg,True,"The image contains a snippet of Verilog code. Here is the code written out for you:

```verilog
// root.sv
`timescale 1ns/1ns
parameter int TIMEOUT = 1_000_000;
const string time_out_msg = ""ERROR: Time out"";
module top;
  test t1();
endmodule

program automatic test;
  ...
  initial begin
    #TIMEOUT;
    $display(""%s"", time_out_msg);
    $finish;
  end
endprogram
```
Please note that the code snippet starts with a comment indicating the file name (`root.sv`), and within the program block, some part of the code is represented with ellipsis (`...`), indicating that the original code contains more content that is not displayed in this image.","
// root.sv
`timescale 1ns/1ns
parameter int TIMEOUT = 1_000_000;
const string time_out_msg = ""ERROR: Time out"";
module top;
  test t1();
endmodule

program automatic test;
  ...
  initial begin
    #TIMEOUT;
    $display(""%s"", time_out_msg);
    $finish;
  end
endprogram
",Excerpt from a text discussing the top-level scope in SystemVerilog and a sample Verilog code snippet defining global constants and a timeout parameter.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p159.jpg,True,"The image contains text as well as a snippet of code related to the Verilog Programming Interface (VPI). Here is the code from the image:

```c
void vpi_get_value (expr, value)
vpiHandle expr;          /* handle for an object which has a value property. */
p_vpi_value value;       /* pointer to an application-allocated s_vpi_value structure
                             to receive value information. */
```

The text explains the usage of the `vpi_get_value()` routine and how Verilog logic values are converted to various C representations.","vpi_get_value (expr, value)
vpiHandle expr;          /* handle for an object which has a value property. */
p_vpi_value value;       /* pointer to an application-allocated s_vpi_value structure
                             to receive value information. */
","Image of a textbook page describing VPI routines for reading and modifying Verilog values, with emphasis on the conversion of Verilog logic values to C representations and the `vpi_get_value` routine usage.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p474.jpg,True,"The image contains two blocks of Verilog code. Here is the first block of code:

```verilog
function new(string name, uvm_component parent=null); //class constructor(UVM style)
  super.new(name, parent);
  foreach (myInt[ i ])
    myCG_val myCG[ i ].new(myInt[ i ]); // NO ERROR
endfunction
endclass: ex_class
```

Here is the second block of code:

```verilog
class my_coverage extends uvm_subscriber #(bus_tx);
  `uvm_component_utils(my_coverage)

  bus_tx m_item; //m_item of type bus_tx
  int m_address_delta;
  
  covergroup m_cov;
    cp_address_delta: coverpoint m_address_delta {
      bins zero = {0};
      bins one = {1};
      bins Lower_Qword = { [1: 127] };
    }
  endgroup
  
  function new(string name, uvm_component parent);
    super.new(name, parent);
    m_cov = new;
  endfunction : new
```

The code snippets are related to Universal Verification Methodology (UVM) for functional coverage in HDL (Hardware Description Language) code.","
function new(string name, uvm_component parent=null); //class constructor(UVM style)
  super.new(name, parent);
  foreach (myInt[ i ])
    myCG_val myCG[ i ].new(myInt[ i ]); // NO ERROR
endfunction
endclass: ex_class


class my_coverage extends uvm_subscriber #(bus_tx);
  `uvm_component_utils(my_coverage)

  bus_tx m_item; //m_item of type bus_tx
  int m_address_delta;
  
  covergroup m_cov;
    cp_address_delta: coverpoint m_address_delta {
      bins zero = {0};
      bins one = {1};
      bins Lower_Qword = { [1: 127] };
    }
  endgroup
  
  function new(string name, uvm_component parent);
    super.new(name, parent);
    m_cov = new;
  endfunction : new
","""Verilog Code Example Demonstrating UVM Coverage Group Array Instantiation and Functional Coverage Collection Techniques""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p312.jpg,True,"Here is the code found in the image:

```verilog
property syncIff;
  @(posedge clk) disable iff ($(sampled(rst)) a |=> b;
endproperty

z1 : assert property (@(posedge clk) a == b)); $display(""a=%b b=%b"", a, b );
```

Please note that the syntax in the code may not be fully correct due to the image's content. For example, the `$(sampled(rst))` might actually be `$sampled(rst)`, as `$` is commonly used for system functions in Verilog. The actual syntax requires careful review in the relevant Verilog documentation or texts.","
property syncIff;
  @(posedge clk) disable iff ($(sampled(rst)) a |=> b;
endproperty

z1 : assert property (@(posedge clk) a == b)); $display(""a=%b b=%b"", a, b );
","""Understanding the semantics of the SystemVerilog $sampled function in assertions and the changes from IEEE Std 1800-2005 to the 2012 standard.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p261.jpg,True,"The image contains Verilog code along with explanatory text. The Verilog code in the image is:

```verilog
`define s_BUS_IDLE
(framen && irdyn)

property p_mchk1;
@(posedge clk)
    $rose (framen) |-> (irdyn == 0);
endproperty

a_mchk1: assert property(p_mchk1);
c_mchk1: cover property(p_mchk1);
```","
`define s_BUS_IDLE
(framen && irdyn)

property p_mchk1;
@(posedge clk)
    $rose (framen) |-> (irdyn == 0);
endproperty

a_mchk1: assert property(p_mchk1);
c_mchk1: cover property(p_mchk1);
","Caption: ""Verilog code snippet depicting SystemVerilog Assertions (SVA) for protocol interface checking with an accompanying waveform trace example.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p383.jpg,True,"The image contains text and code related to Verilog properties, specifically SystemVerilog property declarations. Here are the code excerpts from the image:

Example C-16 Property declaration

```verilog
property_declaration ::=
    property property_identifier [ property_formal_list ]’;’
    { property_decl_item }
    property_spec ‘;’
endproperty [ ‘:’ property_identifier ]
```

```verilog
property_formal_list ::= ‘(‘ formal_list_item {‘,’ formal_list_item } ‘)’
formal_list_item ::= formal_identifier [ ‘=’ actual_arg_expr ]
Actual_arg_expr ::= expression | identifier | event_control | ‘$’
```

```verilog
property_decl_item ::= sequence_declaration
    | list_of_variable_identifiers_or_assignments
```

```verilog
property_spec ::= [ event_control ]
    | disable iff ‘(‘ expression ‘)’ ] property_expr
```

```verilog
property_expr ::=
    sequence_expr
    | event_control property_expr
    | ‘(‘ property_expr ‘)’
    | not property_expr
    | property_expr or property_expr
    | property_expr and property_expr
    | sequence_expr ‘|->’ property_expr
    | sequence_expr ‘|=>’ property_expr
    | if ‘(‘ expression ‘)’ property_expr
    | if ‘(‘ expression ‘)’ property_expr else property_expr
    | property_instance
```

```verilog
event_control ::= ‘@’ event_identifier
    | ‘@@’ ‘(‘ event_expression ‘)’
```

Below that, there are some examples of property usage:

```verilog
property req_t1_start;
    @(posedge clk) req && req_tag == t1;
endproperty

property illegal_op;
    @(posedge clk) not req && cmd == 4;
endproperty
```

These snippets show the syntax for defining properties in SystemVerilog, which are used in formal verification and hardware design.","
property_declaration ::=
    property property_identifier [ property_formal_list ]’;’
    { property_decl_item }
    property_spec ‘;’
endproperty [ ‘:’ property_identifier ]


property_formal_list ::= ‘(‘ formal_list_item {‘,’ formal_list_item } ‘)’
formal_list_item ::= formal_identifier [ ‘=’ actual_arg_expr ]
Actual_arg_expr ::= expression | identifier | event_control | ‘$’


property_decl_item ::= sequence_declaration
    | list_of_variable_identifiers_or_assignments


property_spec ::= [ event_control ]
    | disable iff ‘(‘ expression ‘)’ ] property_expr


property_expr ::=
    sequence_expr
    | event_control property_expr
    | ‘(‘ property_expr ‘)’
    | not property_expr
    | property_expr or property_expr
    | property_expr and property_expr
    | sequence_expr ‘|->’ property_expr
    | sequence_expr ‘|=>’ property_expr
    | if ‘(‘ expression ‘)’ property_expr
    | if ‘(‘ expression ‘)’ property_expr else property_expr
    | property_instance


event_control ::= ‘@’ event_identifier
    | ‘@@’ ‘(‘ event_expression ‘)’


property req_t1_start;
    @(posedge clk) req && req_tag == t1;
endproperty

property illegal_op;
    @(posedge clk) not req && cmd == 4;
endproperty
","""SystemVerilog Property Declarations and Usage Examples""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p249.jpg,True,"The image contains text related to DDR-SDRAM Verification and includes a fragment of code written in SystemVerilog Assertion (SVA) syntax, which is used for formal verification in the hardware description language Verilog. The visible part of the code is:

```verilog
sequence s_read;
    @(posedge clk)
    (ras_n && !sel_n[0] && we_n && !cas_n);
```","
sequence s_read;
    @(posedge clk)
    (ras_n && !sel_n[0] && we_n && !cas_n);
","Caption: ""Excerpt from a technical document discussing DDR-SDRAM Verification and showcasing an SVA (SystemVerilog Assertion) for burst read operations on DDR memories.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p617.jpg,True,"The image contains C code for a scientific ALU (Arithmetic Logic Unit) C model. Here is the code extracted from the image:

```c
#include <math.h>
#include <errno.h>
void PLIbook_ScientificALU_c_model(
    double a, /* input */
    double b, /* input */
    int opcode, /* input */
    double *result, /* output from ALU */
    int *excep, /* output; set if result is out of range */
    int *err) /* output; set if input is out of range */
{
    switch (opcode) {
        case 0x0: *result = pow (a, b); break;
        case 0x1: *result = sqrt (a); break;
        case 0x2: *result = exp (a); break;
        case 0x3: *result = ldexp (a, (int)b); break;
        case 0x4: *result = fabs (a); break;
        case 0x5: *result = fmod (a, b); break;
        case 0x6: *result = ceil (a); break;
        case 0x7: *result = floor (a); break;
        case 0x8: *result = log (a); break;
        case 0x9: *result = log10 (a); break;
        case 0xA: *result = sin (a); break;
        case 0xB: *result = cos (a); break;
        case 0xC: *result = tan (a); break;
        case 0xD: *result = asin (a); break;
        case 0xE: *result = acos (a); break;
        case 0xF: *result = atan (a); break;
    }
    *err = (errno == EDOM); /* arg to math func. out of range */
    *excep = (errno == ERANGE); /* result of math func. out of range */
    errno = 0; /* clear the error flag */
    if (*err) *result = 0.0; /* set result to 0 if error occurred */
    return;
}
```

The code shows a function that takes two `double` values `a` and `b`, an `int` opcode to select the operation, and pointers to store the result and any exceptions or errors. It switches based on the opcode and performs various mathematical operations accordingly.","ude <math.h>
#include <errno.h>
void PLIbook_ScientificALU_c_model(
    double a, /* input */
    double b, /* input */
    int opcode, /* input */
    double *result, /* output from ALU */
    int *excep, /* output; set if result is out of range */
    int *err) /* output; set if input is out of range */
{
    switch (opcode) {
        case 0x0: *result = pow (a, b); break;
        case 0x1: *result = sqrt (a); break;
        case 0x2: *result = exp (a); break;
        case 0x3: *result = ldexp (a, (int)b); break;
        case 0x4: *result = fabs (a); break;
        case 0x5: *result = fmod (a, b); break;
        case 0x6: *result = ceil (a); break;
        case 0x7: *result = floor (a); break;
        case 0x8: *result = log (a); break;
        case 0x9: *result = log10 (a); break;
        case 0xA: *result = sin (a); break;
        case 0xB: *result = cos (a); break;
        case 0xC: *result = tan (a); break;
        case 0xD: *result = asin (a); break;
        case 0xE: *result = acos (a); break;
        case 0xF: *result = atan (a); break;
    }
    *err = (errno == EDOM); /* arg to math func. out of range */
    *excep = (errno == ERANGE); /* result of math func. out of range */
    errno = 0; /* clear the error flag */
    if (*err) *result = 0.0; /* set result to 0 if error occurred */
    return;
}
","""Sample C model code for a scientific ALU as part of a chapter discussing interfacing to C models using ACC routines in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p166.jpg,True,"The image contains Verilog code snippets within the text. Here is the code from the image:

First code snippet:

```verilog
a1: assert property(@(posedge clk) 
                    ##1 $changed(sig) |=> $stable(sig)[*4]);
```

Second code snippet:

```verilog
a2: assert property(@(edge clk)
                    ##1 $changed(sig) |=> $stable(sig)[*4]);
```

Third code snippet:

```verilog
a_stable: assert property (@(posedge clk)
             start_ev |=> $stable(sig) until_with end_ev);
```","
a1: assert property(@(posedge clk) 
                    ##1 $changed(sig) |=> $stable(sig)[*4]);


a2: assert property(@(edge clk)
                    ##1 $changed(sig) |=> $stable(sig)[*4]);


a_stable: assert property (@(posedge clk)
             start_ev |=> $stable(sig) until_with end_ev);
","Caption: ""Examples of Verilog Assertions for Signal Stability and Clock Inference""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p60.jpg,True,"```verilog
always @(posedge clock)
  $read_test_vector(""vectors.pat"", in1);
```
","
always @(posedge clock)
  $read_test_vector(""vectors.pat"", in1);
","""Overview of Verilog PLI callback routines and their usage in simulation, with an example code snippet and flowchart.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p172.jpg,True,"The image contains snippets of Verilog code. Here are the two code excerpts presented:

**First code snippet:**
```verilog
module m;
//... await reset activity completed ...
@clk; //synchronize and start assertion from this tick
$asserton();
end
//... other code ..
endmodule
```

**Second code snippet:**
```verilog
module m;
bit clk;
prg my_program();
default clocking ck @ (posedge clk); endclocking
a: assert property (... some_property ...);
//... other code ..
endmodule

program prg;
initial begin
$assertoff();
//... await reset activity completed ...
@.ck; //synchronize and start assertion from this tick
$asserton();
end
//... other code...
endprogram
```

These snippets discuss the usage of `$asserton()` and `$assertoff()` tasks in the context of controlling assertions and runtime violations in Verilog/SystemVerilog simulations.","
module m;
//... await reset activity completed ...
@clk; //synchronize and start assertion from this tick
$asserton();
end
//... other code ..
endmodule


module m;
bit clk;
prg my_program();
default clocking ck @ (posedge clk); endclocking
a: assert property (... some_property ...);
//... other code ..
endmodule

program prg;
initial begin
$assertoff();
//... await reset activity completed ...
@.ck; //synchronize and start assertion from this tick
$asserton();
end
//... other code...
endprogram
","Caption: ""An excerpt from a technical document discussing the use of tasks to control assertions and manage runtime violations in Verilog, with code examples showing proper synchronization and initiation of assertions within simulation.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p165.jpg,True,"```c
double PLIbook_getarg_realval_vpi(int argNum)
{
    vpiHandle arg_h;
    s_vpi_value argVal;
    #ifdef PLIbookDebug
    s_vpi_error_info err; /* structure for error handling */
    #endif

    arg_h = PLIbook_getarg_handle_vpi(argNum);
    if (arg_h == NULL) {
        vpi_printf(""ERROR: PLIbook_getarg_realval_vpi() could not obtain arg handle\n"");
        return(0);
    }

    argVal.format = vpiRealVal;
    vpi_get_value(arg_h, &argVal);
    #ifdef PLIbookDebug /* if error, generate verbose debug message */
    if (vpi_chk_error(&err)) {
        vpi_printf(""ERROR: PLIbook_getarg_realval_vpi() could not obtain arg value\n"");
        vpi_printf(""File %s, Line %d: %s\n"",
            err.file, err.line, err.message);
        return(0.0);
    }
    #endif

    return(argVal.value.real);
}
```","e PLIbook_getarg_realval_vpi(int argNum)
{
    vpiHandle arg_h;
    s_vpi_value argVal;
    #ifdef PLIbookDebug
    s_vpi_error_info err; /* structure for error handling */
    #endif

    arg_h = PLIbook_getarg_handle_vpi(argNum);
    if (arg_h == NULL) {
        vpi_printf(""ERROR: PLIbook_getarg_realval_vpi() could not obtain arg handle\n"");
        return(0);
    }

    argVal.format = vpiRealVal;
    vpi_get_value(arg_h, &argVal);
    #ifdef PLIbookDebug /* if error, generate verbose debug message */
    if (vpi_chk_error(&err)) {
        vpi_printf(""ERROR: PLIbook_getarg_realval_vpi() could not obtain arg value\n"");
        vpi_printf(""File %s, Line %d: %s\n"",
            err.file, err.line, err.message);
        return(0.0);
    }
    #endif

    return(argVal.value.real);
}
","Caption: ""Example of a C function for reading Verilog values as C doubles using VPI routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p264.jpg,True,"The image contains snippets of Verilog code. Here are the extracts:

For Example,

```verilog
X <= 4'b1x00; // X is reg[3:0].
// Example 1: No match for any of the alternatives:
casez (X)
    4'b100x: ...;
    4'b10xz: ...;
    4'b1xzx: ...;
    4'bxxxx: ...;
    4'b0zzz: ...;
    default: ...; // Executes.
endcase
// Example 2: '?' is same as 'z'
casez (X)
    4'b???1: ...; // No match.
    4'b??11: ...; // No match.
    4'b?1??: ...; // No match.
    4'b1???: ...; // Executes; X[3] matches 1==1, and others are wild.
    default: ...; // Can execute on X == 4'b0000, or on anything
                 // with no '1' or 'z' anywhere, etc.
endcase
```

These examples demonstrate the use of the `casez` statement in Verilog to handle wildcard matches within a switch-case structure.","
X <= 4'b1x00; // X is reg[3:0].
// Example 1: No match for any of the alternatives:
casez (X)
    4'b100x: ...;
    4'b10xz: ...;
    4'b1xzx: ...;
    4'bxxxx: ...;
    4'b0zzz: ...;
    default: ...; // Executes.
endcase
// Example 2: '?' is same as 'z'
casez (X)
    4'b???1: ...; // No match.
    4'b??11: ...; // No match.
    4'b?1??: ...; // No match.
    4'b1???: ...; // Executes; X[3] matches 1==1, and others are wild.
    default: ...; // Can execute on X == 4'b0000, or on anything
                 // with no '1' or 'z' anywhere, etc.
endcase
","The image contains a discussion on the usage of casez and casex constructs in Verilog, highlighting potential issues and best practices for synthesizable code.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p397.jpg,True,"The image includes a snippet of Verilog code. Here it is:

```verilog
constraint length {
  {len == hdr_len + payload_len;
  solve len before hdr_len, payload_len; }
}
```","
constraint length {
  {len == hdr_len + payload_len;
  solve len before hdr_len, payload_len; }
}
","""Explaining the use of 'solve...before' constraint in Verilog for even distribution of packet length, along with a graph illustrating the even probability for packet length.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p172.jpg,True,"The image contains the following Verilog/SystemVerilog code:

```verilog
class driver;
  virtual arb_ifc arb;               // pointer to interface

  function new(virtual arb_ifc arb); // pointer to interface
    this.arb = arb;
  endfunction
endclass
```

Below the code, there is a brief explanation: Virtual interfaces are the bridge or link between the class-based testbench and the Device Under Test (DUT).","
class driver;
  virtual arb_ifc arb;               // pointer to interface

  function new(virtual arb_ifc arb); // pointer to interface
    this.arb = arb;
  endfunction
endclass
","""Example of a SystemVerilog class with a virtual interface demonstrating the use of virtual interfaces as bridges in testbenches""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p52.jpg,True,"The image contains Verilog code snippets. Here they are:

```verilog
logic signed [11:0] a;
a = 12'shFF; // GOTCHA! signed value hex FF does not represent -1
             // 8-bit FF value extends to 12-bit 000011111111
             // WHY?
```

```verilog
logic signed [7:0] b;
b = -4'sd15; // GOTCHA! 11110001 (-15) is truncated to 0001 (+1)
```

These code snippets illustrate examples related to signed literal integers and how they zero extend to their specified size in Verilog. The commentary in the code explains the unintended behaviors (gotchas) that can occur when the size specified for a literal integer does not match the number of bits in its value.","
logic signed [11:0] a;
a = 12'shFF; // GOTCHA! signed value hex FF does not represent -1
             // 8-bit FF value extends to 12-bit 000011111111
             // WHY?


logic signed [7:0] b;
b = -4'sd15; // GOTCHA! 11110001 (-15) is truncated to 0001 (+1)
","""Common pitfalls in Verilog related to signed literals and size declaration rules, with code examples highlighting signed integer extension issues.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p142.jpg,True,"The image contains code written in Verilog. Here's the code extracted from the image:

```verilog
module assert_quiescent_state (clk, reset_n,
  state_expr, check_value, sample_event);
// rtl_synthesis template
parameter severity_level = 0;
parameter width=1;
parameter options = 0;
parameter msg=""VIOLATION"";
input clk, reset_n, sample_event;
input [width-1:0] state_expr, check_value;

//rtl_synthesis translate_off
`ifdef ASSERT_ON
parameter assert_name = ""ASSERT_QUIESCENT_STATE"";

integer error_count;
initial error_count = 0;

`include ""ovl_task.h""
`ifdef ASSERT_INIT_MSG
  initial ovl_init_msg;
`endif

reg r_sample_event;
initial r_sample_event=1'b0;

always @ (posedge clk)
  r_sample_event <= sample_event;

reg r_PLI_active;
initial r_PLI_active=1'b0;
always @ (posedge clk)
  if (r_PLI_active==1'b0) begin
    r_PLI_active=1'b1;
    $assert_quiescent_state (state_expr, check_value);
  end
always @ (posedge clk) begin
  `ifdef ASSERT_GLOBAL_RESET
    if (`ASSERT_GLOBAL_RESET != 1'b0)
  `else
    if (reset_n != 0)
  `endif
  begin
    if ((r_sample_event == 1'b0 && sample_event == 1'b1) &&
      (state_expr != check_value))
    begin
      ovl_error("""");
    end
  end
end
`endif
//rtl_synthesis translate_on
endmodule
```

This Verilog module is an example of an OVL (Open Verification Library) assert_quiescent_state assertion, which is enhanced with a PLI (Programming Language Interface) task. The module monitors for a particular quiescent state and triggers an error message if the expected state is not met after a sample event occurs.","
module assert_quiescent_state (clk, reset_n,
  state_expr, check_value, sample_event);
// rtl_synthesis template
parameter severity_level = 0;
parameter width=1;
parameter options = 0;
parameter msg=""VIOLATION"";
input clk, reset_n, sample_event;
input [width-1:0] state_expr, check_value;

//rtl_synthesis translate_off
`ifdef ASSERT_ON
parameter assert_name = ""ASSERT_QUIESCENT_STATE"";

integer error_count;
initial error_count = 0;

`include ""ovl_task.h""
`ifdef ASSERT_INIT_MSG
  initial ovl_init_msg;
`endif

reg r_sample_event;
initial r_sample_event=1'b0;

always @ (posedge clk)
  r_sample_event <= sample_event;

reg r_PLI_active;
initial r_PLI_active=1'b0;
always @ (posedge clk)
  if (r_PLI_active==1'b0) begin
    r_PLI_active=1'b1;
    $assert_quiescent_state (state_expr, check_value);
  end
always @ (posedge clk) begin
  `ifdef ASSERT_GLOBAL_RESET
    if (`ASSERT_GLOBAL_RESET != 1'b0)
  `else
    if (reset_n != 0)
  `endif
  begin
    if ((r_sample_event == 1'b0 && sample_event == 1'b1) &&
      (state_expr != check_value))
    begin
      ovl_error("""");
    end
  end
end
`endif
//rtl_synthesis translate_on
endmodule
","Caption: ""Example 4-15 from a reference material showing Verilog code for an assertion module that uses Property Specification Language (PSL) and Programming Language Interface (PLI) to enhance the assert_quiescent_state check in assertion-based design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p46.jpg,True,"The image contains excerpts of Verilog/SystemVerilog code. Here it is written out:

```verilog
package chip_types;
  typedef enum logic [1:0] {RESET, HOLD, LOAD, READY} states_t;
endpackage: chip_types

module chip (...);
  import chip_types::*; // wildcard import definitions in package
endmodule: chip

module top;
  chip chip (...);  // instance of design that uses the package
  test test (...);  // instance of test program
endmodule: top

program automatic test (...);
  ...
  initial begin
    $display (""RESET is %b"", top.chip.RESET); // GOTCHA! illegal
  endprogram: test
```

And a correct way to access the package item as provided in the text:

```verilog
$display (""RESET is %b"", chip_types::RESET); // OK
```

The image explains a gotcha related to hierarchical references to imported package items in SystemVerilog. It highlights that when using imported package items, identifiers must be referenced using the scope resolution operators (::) instead of hierarchically to avoid errors. The example shows illegal and correct usages accordingly.","
package chip_types;
  typedef enum logic [1:0] {RESET, HOLD, LOAD, READY} states_t;
endpackage: chip_types

module chip (...);
  import chip_types::*; // wildcard import definitions in package
endmodule: chip

module top;
  chip chip (...);  // instance of design that uses the package
  test test (...);  // instance of test program
endmodule: top

program automatic test (...);
  ...
  initial begin
    $display (""RESET is %b"", top.chip.RESET); // GOTCHA! illegal
  endprogram: test


$display (""RESET is %b"", chip_types::RESET); // OK
",A page from a technical document highlighting a common mistake in Verilog testbenches related to hierarchical references to imported package items.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p166.jpg,True,"The image contains snippets of Verilog/SystemVerilog code. Here are the extracted code snippets:

1.
```verilog
function automatic int array_sum(ref int a[], int start=0);
  for(int i=start; i<a.size(); i++)
    array_sum += a[i];
endfunction
```

2.
```verilog
function int array_sum(ref int a[], input int start=0);
```

These snippets are used in the context of explaining a concept related to task/function arguments with default values in Verilog/SystemVerilog.","
function automatic int array_sum(ref int a[], int start=0);
  for(int i=start; i<a.size(); i++)
    array_sum += a[i];
endfunction


function int array_sum(ref int a[], input int start=0);
","""Understanding the Importance of Specifying Argument Directions for Default Values in SystemVerilog Functions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p398.jpg,True,"```c
void PLIbook_DumpMemBin(p_t_nodeinfo node_info)
{
    char *aval_ptr, *bval_ptr;
    int word_increment, mem_address, word_bit, group_num, group_bit;
    char aval_val, bval_val, bit_mask;

    io_printf("" Current memory contents in binary are:\n"");

    word_increment = node_info->node_nGroups * 2;

    for (mem_address = 0;
         mem_address < node_info->node_mem_size;
         mem_address++) {

        /* step 1: set pointers to aval and bval words for the address */
        aval_ptr = node_info->node_value.memoryval_p
                     + (mem_address * word_increment);

        bval_ptr = aval_ptr + node_info->node_nGroups;

        for (word_bit = node_info->node_vec_size - 1;
             word_bit >= 0;
             word_bit--) {

            /* step 2: determine the group which contains the bit number */
            group_num = word_bit / 8;

            /* step 3: determine which bit in the group contains the bit */
            group_bit = word_bit % 8;

            /* step 4: set an 8-bit mask to block all unwanted bits in group */
            bit_mask = 0x01; /* Set mask to most-signifi. bit of 8-bit group */
            bit_mask = bit_mask << group_bit; /* Shift to bit to be modified */

            /* step 5: select desired aval and bval bits from the groups */
            aval_val = aval_ptr[group_num] & bit_mask;
            bval_val = bval_ptr[group_num] & bit_mask;

            /* translate aval/bval pair to 4-state logic value */
            if (!bval_val) {
                if (!aval_val)
                    io_printf(""0""); /* aval/bval == 0/0 */
                else
                    io_printf(""1""); /* aval/bval == 1/0 */
            }
            else {
                if (!aval_val)
                    io_printf(""z""); /* aval/bval == 0/1 */
                else
                    io_printf(""x""); /* aval/bval == 1/1 */
            }
        }
        io_printf(""\n"");
    }
    io_printf(""\n"");
    return;
}
```","PLIbook_DumpMemBin(p_t_nodeinfo node_info)
{
    char *aval_ptr, *bval_ptr;
    int word_increment, mem_address, word_bit, group_num, group_bit;
    char aval_val, bval_val, bit_mask;

    io_printf("" Current memory contents in binary are:\n"");

    word_increment = node_info->node_nGroups * 2;

    for (mem_address = 0;
         mem_address < node_info->node_mem_size;
         mem_address++) {

        /* step 1: set pointers to aval and bval words for the address */
        aval_ptr = node_info->node_value.memoryval_p
                     + (mem_address * word_increment);

        bval_ptr = aval_ptr + node_info->node_nGroups;

        for (word_bit = node_info->node_vec_size - 1;
             word_bit >= 0;
             word_bit--) {

            /* step 2: determine the group which contains the bit number */
            group_num = word_bit / 8;

            /* step 3: determine which bit in the group contains the bit */
            group_bit = word_bit % 8;

            /* step 4: set an 8-bit mask to block all unwanted bits in group */
            bit_mask = 0x01; /* Set mask to most-signifi. bit of 8-bit group */
            bit_mask = bit_mask << group_bit; /* Shift to bit to be modified */

            /* step 5: select desired aval and bval bits from the groups */
            aval_val = aval_ptr[group_num] & bit_mask;
            bval_val = bval_ptr[group_num] & bit_mask;

            /* translate aval/bval pair to 4-state logic value */
            if (!bval_val) {
                if (!aval_val)
                    io_printf(""0""); /* aval/bval == 0/0 */
                else
                    io_printf(""1""); /* aval/bval == 1/0 */
            }
            else {
                if (!aval_val)
                    io_printf(""z""); /* aval/bval == 0/1 */
                else
                    io_printf(""x""); /* aval/bval == 1/1 */
            }
        }
        io_printf(""\n"");
    }
    io_printf(""\n"");
    return;
}
","Caption: ""Example of Verilog PLI code for accessing and printing the binary contents of a memory word, demonstrating bit-level operations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p270.jpg,True,"The image contains some Verilog code. Here is the code excerpt:

```verilog
always @(negedge ClockIn)
    begin : Ticker
        reg[7:0] ClockCount; // A new declaration, no matter whether some
                             // other ""ClockCount"" is declared elsewhere.
        if (StartCount!='b1) // other ""ClockCount"" is declared elsewhere.
            ClockCount = 'b0;
        else ClockCount = ClockCount + 8'h1;
        ...
    end
```

The code is a sample from a Verilog design illustrating a negedge-triggered always block, which includes the declaration of a register `ClockCount` and a conditional statement to update its value.","
always @(negedge ClockIn)
    begin : Ticker
        reg[7:0] ClockCount; // A new declaration, no matter whether some
                             // other ""ClockCount"" is declared elsewhere.
        if (StartCount!='b1) // other ""ClockCount"" is declared elsewhere.
            ClockCount = 'b0;
        else ClockCount = ClockCount + 8'h1;
        ...
    end
",Verilog code for a clock counter and a description of a laboratory session on concurrency in procedural code.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p383.jpg,True,"The image contains a page from a textbook or a technical document, and it does include code. Here is the Verilog code present in the image:

```verilog
typedef enum {INIT, DECODE, IDLE} fsmstate_e;
fsmstate_e pstate, nstate; // declare typed variables
covergroup CovFsm23;
    coverpoint pstate;
endgroup
```

There is also an example of specifying transitions for a cover point:

```verilog
covergroup CovDst25;
    coverpoint tr.dst {
        bins t1 = (0 => 1), (0 => 2), (0 => 3);
    }
endgroup
```

These examples are part of a discussion on creating bins for enumerated types and specifying transitions for cover points in the context of functional coverage in SystemVerilog.","
typedef enum {INIT, DECODE, IDLE} fsmstate_e;
fsmstate_e pstate, nstate; // declare typed variables
covergroup CovFsm23;
    coverpoint pstate;
endgroup


covergroup CovDst25;
    coverpoint tr.dst {
        bins t1 = (0 => 1), (0 => 2), (0 => 3);
    }
endgroup
",Verilog Code Snippet: Defining Coverage for Enumerated Types and State Transitions.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p258.jpg,True,"The image contains snippets of Verilog code and explanatory text. Here I'll transcribe the Verilog code as displayed:

```verilog
initial
begin : Clock_gen
Clock1 = 1'b0;
forever #10 Clock1 = ~Clock1; // Works, but don't do this!
end
...
initial
begin : Test_vectors
Abus = 32'h0101_1010;
Dbus = 'b0;
#5 Reset = 1'b0;
...
#220 $finish; // Terminate the simulation after about 10 clocks.
end
```

And another piece of code at the bottom:

```verilog
// Technique 1:
forever
begin
    #1 Count = Count + 1; // Must include a delay or @!
    if (Count>=1000) $finish;
end
```

These code snippets are examples of how to create clock generators and termination methods in Verilog.","
initial
begin : Clock_gen
Clock1 = 1'b0;
forever #10 Clock1 = ~Clock1; // Works, but don't do this!
end
...
initial
begin : Test_vectors
Abus = 32'h0101_1010;
Dbus = 'b0;
#5 Reset = 1'b0;
...
#220 $finish; // Terminate the simulation after about 10 clocks.
end


// Technique 1:
forever
begin
    #1 Count = Count + 1; // Must include a delay or @!
    if (Count>=1000) $finish;
end
","Caption: ""Understanding Verilog Simulation Constructs: Differences between 'forever' and 'always' blocks and insights on non-synthesizable code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p358.jpg,True,"Here is the Verilog code from the image:

Assertion for 'a_start_valid':
```verilog
a_start_valid: assert property (
    start |-> !complete && outstanding < MAX_OUTSTANDING
);
```

Assertion for 'a_complete_valid':
```verilog
a_complete_valid: assert property (
    complete |-> !start && outstanding > 0
);
```

Part of 'dataType' declaration and the always block:
```verilog
dataType dataQ[$:MAX_OUTSTANDING-1] = {};
always @(posedge clk)
    if ($sampled(start))
        dataQ.push_back($sampled(dataIn));
    else if ($sampled(complete))
        dataQ.pop_front;
```

Assertion for 'a_fifo_data_check':
```verilog
a_fifo_data_check: assert property (
    complete |-> dataOut == dataQ[0]
);
```","
a_start_valid: assert property (
    start |-> !complete && outstanding < MAX_OUTSTANDING
);


a_complete_valid: assert property (
    complete |-> !start && outstanding > 0
);


dataType dataQ[$:MAX_OUTSTANDING-1] = {};
always @(posedge clk)
    if ($sampled(start))
        dataQ.push_back($sampled(dataIn));
    else if ($sampled(complete))
        dataQ.pop_front;


a_fifo_data_check: assert property (
    complete |-> dataOut == dataQ[0]
);
","""Verilog Assertions and FIFO Protocol Integrity Check Example""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p354.jpg,True,"```verilog
virtual class uvm_component extends uvm_object;
  protected uvm_component m_children[string];
  string name;

  function new(string name);
    this.name = name;
    $display(""%m name='%s'"", name);
  endfunction

  pure virtual task run_test();
endclass

virtual class uvm_object_wrapper;
  pure virtual function string get_type_name();
  pure virtual function uvm_object create_object(string name);
endclass
```","
virtual class uvm_component extends uvm_object;
  protected uvm_component m_children[string];
  string name;

  function new(string name);
    this.name = name;
    $display(""%m name='%s'"", name);
  endfunction

  pure virtual task run_test();
endclass

virtual class uvm_object_wrapper;
  pure virtual function string get_type_name();
  pure virtual function uvm_object create_object(string name);
endclass
","Caption: ""Excerpt from a textbook detailing the creation of a test registry in UVM with examples of component class and proxy class in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p104.jpg,True,"The image contains a segment of Verilog code as follows:

```verilog
module M1;
    bit RST;

    default disable iff RST;

    a1: assert property (@(posedge clk) propertyP1); //propertyP1 is defined elsewhere
    a2: assert property (@(negedge clk) propertyP2); //propertyP2 is defined elsewhere

endmodule
```

This code snippet shows a Verilog module named M1 with a 'bit' signal named RST. The code uses the `default disable iff` construct to specify a default condition under which assertions within the module are disabled. It contains two assertions labeled 'a1' and 'a2' referring to properties 'propertyP1' and 'propertyP2', which are defined elsewhere.","
module M1;
    bit RST;

    default disable iff RST;

    a1: assert property (@(posedge clk) propertyP1); //propertyP1 is defined elsewhere
    a2: assert property (@(negedge clk) propertyP2); //propertyP2 is defined elsewhere

endmodule
","Caption: Excerpt from a document explaining the rules for using the ""disable iff"" construct in Verilog properties, along with an example of declaring a ""default disable iff"" condition within a Verilog module for concurrent assertions.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p432.jpg,True,"```verilog
class Cov_Monitor_cbs extends Monitor_cbs;
    Coverage cov;

    function new(input Coverage cov);
        this.cov = cov;
    endfunction : new

    // Send received cell to coverage
    virtual task post_rx(input Monitor mon,
                         input NNI_cell c);
        CellCfgType CellCfg = top.squat.lut.read(c.VPI);
        cov.sample(mon.PortID, CellCfg.FWD);
    endtask : post_rx
endclass : Cov_Monitor_cbs
```","
class Cov_Monitor_cbs extends Monitor_cbs;
    Coverage cov;

    function new(input Coverage cov);
        this.cov = cov;
    endfunction : new

    // Send received cell to coverage
    virtual task post_rx(input Monitor mon,
                         input NNI_cell c);
        CellCfgType CellCfg = top.squat.lut.read(c.VPI);
        cov.sample(mon.PortID, CellCfg.FWD);
    endtask : post_rx
endclass : Cov_Monitor_cbs
","""Example of Verilog SystemVerilog Callback Class for Testbench Monitoring and Coverage""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p429.jpg,True,"The image contains a code snippet written in C. Here is the code:

```c
/*********************************************************************/
/* Function to convert reason integer to reason name                 */
/*********************************************************************/
char *PLIbook_reason_name(int reason)
{
    char str[25];
    switch (reason) {
        case REASON_ENDOFCOMPILE : return(""REASON_ENDOFCOMPILE""); break;
        case REASON_FINISH       : return(""REASON_FINISH""); break;
        case REASON_INTERACTIVE  : return(""REASON_INTERACTIVE""); break;
        case REASON_SYNCH        : return(""REASON_SYNCH""); break;
        case REASON_ROSYNCH      : return(""REASON_ROSYNCH""); break;
        case REASON_REACTIVATE   : return(""REASON_REACTIVATE""); break;
        case REASON_PARAMVC      : return(""REASON_PARAMVC""); break;
        case REASON_PARAMDC      : return(""REASON_PARAMDC""); break;
        case REASON_SAVE         : return(""REASON_SAVE""); break;
        case REASON_RESTART      : return(""REASON_RESTART""); break;
        case REASON_RESET        : return(""REASON_RESET""); break;
        case REASON_ENDOFRESET   : return(""REASON_ENDOFRESET""); break;
        case REASON_FORCE        : return(""REASON_FORCE""); break;
        case REASON_RELEASE      : return(""REASON_RELEASE""); break;
    }
    return(""Non-standard or Unknown Reason"");
}
```
This code defines a function `PLIbook_reason_name` which takes an integer `reason` as its parameter and returns a pointer to a string that corresponds to a defined case.

The function uses a `switch` statement to check the integer value against predefined constants, returning a string literal associated with each specific cause. If none of the predefined constants match the input value, the function returns the string ""Non-standard or Unknown Reason"".","*****************************************************************/
/* Function to convert reason integer to reason name                 */
/*********************************************************************/
char *PLIbook_reason_name(int reason)
{
    char str[25];
    switch (reason) {
        case REASON_ENDOFCOMPILE : return(""REASON_ENDOFCOMPILE""); break;
        case REASON_FINISH       : return(""REASON_FINISH""); break;
        case REASON_INTERACTIVE  : return(""REASON_INTERACTIVE""); break;
        case REASON_SYNCH        : return(""REASON_SYNCH""); break;
        case REASON_ROSYNCH      : return(""REASON_ROSYNCH""); break;
        case REASON_REACTIVATE   : return(""REASON_REACTIVATE""); break;
        case REASON_PARAMVC      : return(""REASON_PARAMVC""); break;
        case REASON_PARAMDC      : return(""REASON_PARAMDC""); break;
        case REASON_SAVE         : return(""REASON_SAVE""); break;
        case REASON_RESTART      : return(""REASON_RESTART""); break;
        case REASON_RESET        : return(""REASON_RESET""); break;
        case REASON_ENDOFRESET   : return(""REASON_ENDOFRESET""); break;
        case REASON_FORCE        : return(""REASON_FORCE""); break;
        case REASON_RELEASE      : return(""REASON_RELEASE""); break;
    }
    return(""Non-standard or Unknown Reason"");
}
","Caption: ""Verilog code example demonstrating a function for mapping simulation callback reasons to their string representations within a chapter on synchronizing to Verilog simulations using PLI routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p195.jpg,True,"The image contains a code example written in SystemVerilog. Here is the code:

```systemverilog
//declarative assertion

assert property ( @(posedge clk)
                  {read, write, burst, size, wt} inside
                  {6'b1_00_0_0?,    // cache (burst) read.
                   6'b1_00_0_00?,   // single byte read
                   6'b1_00_0_01?,   // halfword read
                   6'b1_00_0_11?,   // word read
                   6'b1_1_00_0_00,  // cache (burst) write
                   6'b0_1_00_0_00,  // single byte write
                   6'b0_1_00_0_01,  // halfword write
                   6'b0_1_00_0_11,  // word write
                   6'b0_1_00_0_10,  // single byte writethru
                   6'b0_1_00_0_11,  // half word writethru
                   6'b0_1_00_0_11,  // word writethru
                   6'b0_0_00_0_00}) // nothing.
else $error (""Illegal memory request (read,write,burst,size,wt)=%0h"", 
             {read, write, burst, size, wt});
```

The code is a declarative assertion in SystemVerilog which uses the `assert property` construct to verify that a combination of signals (`read`, `write`, `burst`, `size`, `wt`) matches one of the specified legal binary patterns for a processor-to-memory interface operation. If the signal combination does not match any of the patterns (indicating an illegal memory request), an error is reported.","erilog
//declarative assertion

assert property ( @(posedge clk)
                  {read, write, burst, size, wt} inside
                  {6'b1_00_0_0?,    // cache (burst) read.
                   6'b1_00_0_00?,   // single byte read
                   6'b1_00_0_01?,   // halfword read
                   6'b1_00_0_11?,   // word read
                   6'b1_1_00_0_00,  // cache (burst) write
                   6'b0_1_00_0_00,  // single byte write
                   6'b0_1_00_0_01,  // halfword write
                   6'b0_1_00_0_11,  // word write
                   6'b0_1_00_0_10,  // single byte writethru
                   6'b0_1_00_0_11,  // half word writethru
                   6'b0_1_00_0_11,  // word writethru
                   6'b0_0_00_0_00}) // nothing.
else $error (""Illegal memory request (read,write,burst,size,wt)=%0h"", 
             {read, write, burst, size, wt});
","Caption: ""Example of a SystemVerilog assert property statement checking legal signal combinations for a processor-to-memory interface.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p91.jpg,True,"The image contains examples of SystemVerilog code. Here's the code from the image:

1. Example using the special one-sided wildcard comparison operator `==?`:

```systemverilog
if (instruction ==? 4'b0???) opcode = instruction[2:0];
else if ... // decode other valid instructions
else begin
    $display (""ERROR: invalid instruction!"");
    opcode = 3'bxxx;
end
```

2. Example using the SystemVerilog `case()` inside statement:

```systemverilog
always_comb begin
    case (instruction) inside
        4'b0???: opcode = instruction[2:0]; // only test upper bit
        4'b1000: opcode = 3'b001;
        ... // decode other valid instructions
        default: begin
            $display (""ERROR: invalid instruction!"");
            opcode = 3'bxxx;
        end
    endcase
end
```","erilog
if (instruction ==? 4'b0???) opcode = instruction[2:0];
else if ... // decode other valid instructions
else begin
    $display (""ERROR: invalid instruction!"");
    opcode = 3'bxxx;
end

erilog
always_comb begin
    case (instruction) inside
        4'b0???: opcode = instruction[2:0]; // only test upper bit
        4'b1000: opcode = 3'b001;
        ... // decode other valid instructions
        default: begin
            $display (""ERROR: invalid instruction!"");
            opcode = 3'bxxx;
        end
    endcase
end
","""SystemVerilog code examples illustrating solutions for trapping invalid instructions using wildcard comparison operator and case inside statement.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p85.jpg,True,"The image contains snippets of Verilog code. Here is the code extracted from the image:

```verilog
module chip (...)
    ...
    always @ (a or ...) begin // a combinational process
        ...
        b <= 1'b0;                // nonblocking assignment to b
        ...
        case (state1)
            STATE_G: begin
                b <= c ;          // nonblocking assignment to b
                ...
            end
            ...
        endcase
    end

    // many lines of code later...

    always @ (b or ...) begin // another combinational process
        ...
        a <= 1'b0;                // nonblocking assignment to a
        ...
        case (state2)
            STATE_H: begin
                ...
                a <= d;          // nonblocking assignment to a
                ...
            end
            ...
        endcase
    end
endmodule: chip
```

This code is an example from a section discussing RTL (Register Transfer Level) modeling pitfalls in Verilog. The comments in the code indicate that nonblocking assignments are used within combinational logic blocks, a practice that can lead to simulation issues. The text out of the code block explains a bit about Verilog/SystemVerilog event scheduling rules, which are relevant to understanding the code.","
module chip (...)
    ...
    always @ (a or ...) begin // a combinational process
        ...
        b <= 1'b0;                // nonblocking assignment to b
        ...
        case (state1)
            STATE_G: begin
                b <= c ;          // nonblocking assignment to b
                ...
            end
            ...
        endcase
    end

    // many lines of code later...

    always @ (b or ...) begin // another combinational process
        ...
        a <= 1'b0;                // nonblocking assignment to a
        ...
        case (state2)
            STATE_H: begin
                ...
                a <= d;          // nonblocking assignment to a
                ...
            end
            ...
        endcase
    end
endmodule: chip
","Caption: ""Example of Verilog code highlighting the use of nonblocking assignments in combinational logic blocks, and the associated event scheduling rules.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p110.jpg,True,"The image contains snippets of both VHDL and SystemVerilog code.

Here is the VHDL code snippet:

```vhdl
entity cpu is
port (
  a : in std_logic;
  b : in std_logic;
  --);
architecture rtl of cpu is
signal c : std_logic;
begin
  --
end rtl;
```

And here is the SystemVerilog code snippet:

```systemverilog
module cpu_props(input d, e, f);
  assert property (@(posedge d) |-> ##[1:2] f);
  --
endmodule

module sva_wrapper;
bind cpu cpu_props cpu_sva_bind
  (.d(a), .e(b), .f(c));
  // Connect SystemVerilog ports to VHDL ports (a and b)
  // and to the internal signals (c)
endmodule
```

This image is demonstrating the concept of binding a VHDL entity to SystemVerilog Assertions using a module wrapper.","tity cpu is
port (
  a : in std_logic;
  b : in std_logic;
  --);
architecture rtl of cpu is
signal c : std_logic;
begin
  --
end rtl;

erilog
module cpu_props(input d, e, f);
  assert property (@(posedge d) |-> ##[1:2] f);
  --
endmodule

module sva_wrapper;
bind cpu cpu_props cpu_sva_bind
  (.d(a), .e(b), .f(c));
  // Connect SystemVerilog ports to VHDL ports (a and b)
  // and to the internal signals (c)
endmodule
","""Binding VHDL DUT to SystemVerilog Assertions Example""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p426.jpg,True,"The image contains Verilog code defining a Utopia interface. Below is the code from the image:

```verilog
interface Utopia #(IfWidth = 8);

logic [IfWidth-1:0] data;
bit clk_in, clk_out;
bit soc, en, clav, valid, ready, reset, selected;

ATMCellType ATMcell; // union of structures for ATM cells

modport TopReceive (
    input data, soc, clav,
    output clk_in, reset, ready, clk_out, en, ATMcell, valid );

modport TopTransmit (
    input clav,
    inout selected,
    output clk_in, clk_out, ATMcell, data, soc, en, valid,
    reset, ready );

modport CoreReceive (
    input clk_in, data, soc, clav, ready, reset,
    output clk_out, en, ATMcell, valid );

modport CoreTransmit (
    inout clk_in, clav, ATMcell, valid, reset,
    output clk_out, data, soc, en, ready );

clocking cbr @(negedge clk_out);
    input clk_in, clk_out, ATMcell, valid, reset, en, ready;
    output data, soc, clav;
endclocking : cbr

modport TB_Rx (clocking cbr);

clocking cbt @(negedge clk_out);
    input clk_out, clk_in, ATMcell, soc, en, valid, reset, data, ready;
    output clav;
endclocking : cbt

modport TB_Tx (clocking cbt);

endinterface

typedef virtual Utopia vUtopia;
typedef virtual Utopia.TB_Rx vUtopiaRx;
typedef virtual Utopia.TB_Tx vUtopiaTx;
```

This code is a sample snippet from a text discussing how to create an interface in Verilog for ATM Utopia standards. Utopia is a common interface standard used for ATM (Asynchronous Transfer Mode) communications hardware. The code is defining various signals, a user-defined type `ATMCellType`, and modports to specify input and output directions for signals to be used with this interface. There are also `clocking` blocks defining clocking events, and finally, the code includes some `typedef` statements to define types that reference modports of the Utopia interface.","
interface Utopia #(IfWidth = 8);

logic [IfWidth-1:0] data;
bit clk_in, clk_out;
bit soc, en, clav, valid, ready, reset, selected;

ATMCellType ATMcell; // union of structures for ATM cells

modport TopReceive (
    input data, soc, clav,
    output clk_in, reset, ready, clk_out, en, ATMcell, valid );

modport TopTransmit (
    input clav,
    inout selected,
    output clk_in, clk_out, ATMcell, data, soc, en, valid,
    reset, ready );

modport CoreReceive (
    input clk_in, data, soc, clav, ready, reset,
    output clk_out, en, ATMcell, valid );

modport CoreTransmit (
    inout clk_in, clav, ATMcell, valid, reset,
    output clk_out, data, soc, en, ready );

clocking cbr @(negedge clk_out);
    input clk_in, clk_out, ATMcell, valid, reset, en, ready;
    output data, soc, clav;
endclocking : cbr

modport TB_Rx (clocking cbr);

clocking cbt @(negedge clk_out);
    input clk_out, clk_in, ATMcell, soc, en, valid, reset, data, ready;
    output clav;
endclocking : cbt

modport TB_Tx (clocking cbt);

endinterface

typedef virtual Utopia vUtopia;
typedef virtual Utopia.TB_Rx vUtopiaRx;
typedef virtual Utopia.TB_Tx vUtopiaTx;
",Example of a Verilog interface definition for a Utopia ATM cell transmission system.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p340.jpg,True,"The image contains Verilog code, which is a hardware description language used to design and model electronic systems. Here is the code presented in the image:

```verilog
class Driver_cbs_scoreboard extends Driver_cbs;
  Scoreboard scb;

  virtual task pre_tx(ref Transaction tr, ref bit drop);
    // Put transaction in the scoreboard
    scb.save_expected(tr);
  endtask

  function new(input Scoreboard scb);
    this.scb = scb;
  endfunction
endclass

program automatic test;
  Environment env;

  initial begin
    env = new();
    env.gen_cfg();
    env.build();

    begin
      // Create scoreboard callback
      Driver_cbs_scoreboard dcs = new(env.scb);
      env.drv.cbs.push_back(dcs); // Put into driver's Q
    end

    env.run();
    env.wrap_up();
  end
endprogram
```

This code demonstrates the use of callbacks in a Verilog test environment, specifically within the context of a scoreboard which is used to verify that the outputs of a design under test (DUT) match the expected results.","
class Driver_cbs_scoreboard extends Driver_cbs;
  Scoreboard scb;

  virtual task pre_tx(ref Transaction tr, ref bit drop);
    // Put transaction in the scoreboard
    scb.save_expected(tr);
  endtask

  function new(input Scoreboard scb);
    this.scb = scb;
  endfunction
endclass

program automatic test;
  Environment env;

  initial begin
    env = new();
    env.gen_cfg();
    env.build();

    begin
      // Create scoreboard callback
      Driver_cbs_scoreboard dcs = new(env.scb);
      env.drv.cbs.push_back(dcs); // Put into driver's Q
    end

    env.run();
    env.wrap_up();
  end
endprogram
","""Verilog code example demonstrating the use of callbacks with a scoreboard in a testbench environment""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p373.jpg,True,"```c
case TF_RWWMEMSELECT:
    io_printf("" vector value (in hex):\\n"");
    for (i=0; i<info_p->expr_ngroups; i++) {
        io_printf(""    avalbits[%d] = %x\\n"",
                  i, info_p->expr_value_p[i].avalbits);
        io_printf(""    bvalbits[%d] = %x\\n"",
                  i, info_p->expr_value_p[i].bvalbits);
    }
    break;
}
return;
```","TF_RWWMEMSELECT:
    io_printf("" vector value (in hex):\\n"");
    for (i=0; i<info_p->expr_ngroups; i++) {
        io_printf(""    avalbits[%d] = %x\\n"",
                  i, info_p->expr_value_p[i].avalbits);
        io_printf(""    bvalbits[%d] = %x\\n"",
                  i, info_p->expr_value_p[i].bvalbits);
    }
    break;
}
return;
","""Excerpt from a technical document discussing TF routines for reading and writing 4-state logic values in Verilog with code example.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p364.jpg,True,"The image contains Verilog code. Here is the code from the image:

```verilog
typedef bit[0:$clog2(MAX_ACTIVE)] indexType;
typedef struct {
  bit valid;
  tagType activeTag;
  extendedTagType;
} extendedTagType tags[0:MAX_ACTIVE] = '{default: '{1'b0, '0}};
  
function automatic indexType freeIndex;
  for (indexType i=0; i < MAX_ACTIVE; i++)
    if (!tags.valid[i]) return i;
  return MAX_ACTIVE; // no free index
endfunction : freeIndex

function automatic indexType tagIndex (tagType tag);
  for (indexType i=0; i < MAX_ACTIVE; i++)
    if (tags.valid[i] && tags.activeTag[i] == tag)
      return i;
  return MAX_ACTIVE; // tag not found
endfunction : tagIndex

always @(posedge clk)
  if ($(sampled(start)))
    tags[freeIndex] <= '{1'b1, $sampled(tagIn)};
  else if ($(sampled(complete)))
    tags.valid[tagIndex($sampled(tagOut))] <= 1'b0;

a_no_tag_reuse: assert property (
  start
    |-> tagIndex(tagIn) == MAX_ACTIVE // tagIn not found
);
a_comp_tag_ok: assert property (
  complete
    |-> tagIndex(tagOut) < MAX_ACTIVE // tagOut found
);
```
This code snippet demonstrates Verilog structures for managing a tagging protocol within a digital system, using SystemVerilog features like `typedef`, `struct`, `always` block, and property assertions for formal verification.","
typedef bit[0:$clog2(MAX_ACTIVE)] indexType;
typedef struct {
  bit valid;
  tagType activeTag;
  extendedTagType;
} extendedTagType tags[0:MAX_ACTIVE] = '{default: '{1'b0, '0}};
  
function automatic indexType freeIndex;
  for (indexType i=0; i < MAX_ACTIVE; i++)
    if (!tags.valid[i]) return i;
  return MAX_ACTIVE; // no free index
endfunction : freeIndex

function automatic indexType tagIndex (tagType tag);
  for (indexType i=0; i < MAX_ACTIVE; i++)
    if (tags.valid[i] && tags.activeTag[i] == tag)
      return i;
  return MAX_ACTIVE; // tag not found
endfunction : tagIndex

always @(posedge clk)
  if ($(sampled(start)))
    tags[freeIndex] <= '{1'b1, $sampled(tagIn)};
  else if ($(sampled(complete)))
    tags.valid[tagIndex($sampled(tagOut))] <= 1'b0;

a_no_tag_reuse: assert property (
  start
    |-> tagIndex(tagIn) == MAX_ACTIVE // tagIn not found
);
a_comp_tag_ok: assert property (
  complete
    |-> tagIndex(tagOut) < MAX_ACTIVE // tagOut found
);
","Caption: ""Verilog code detailing the implementation of tag protocol operations and assertions for control checks in a transaction system.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p402.jpg,True,"The image contains Verilog code in the form of property and sequence definitions for use in formal verification. Here's the code from the image:

```verilog
property p_ttype_check;
  transType l_ttype;
  (start && (ttype == INV || ttype == PRG), l_ttype = ttype)
  |=> 
  (
    (!1'b1, l_ttype = ttype)
    ##0
    p_no_repeat_ttype(
      .varying_ttype(ttype), .captured_ttype(l_ttype)
    )
  );
endproperty
```

Additionally, the image also describes some questions related to the nonoverlapped followed-by (`##`) operator in SystemVerilog properties and asks to explain the local variable flow in the context of the given `p_ttype_check` property.","
property p_ttype_check;
  transType l_ttype;
  (start && (ttype == INV || ttype == PRG), l_ttype = ttype)
  |=> 
  (
    (!1'b1, l_ttype = ttype)
    ##0
    p_no_repeat_ttype(
      .varying_ttype(ttype), .captured_ttype(l_ttype)
    )
  );
endproperty
","""Exploring the dynamics of local variable flows in SystemVerilog properties and sequences.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p415.jpg,True,"```verilog
reg [15:0] input_vector;

initial
  $read_stimulus(""read_stimulus.pat"", input_vector);
```","
reg [15:0] input_vector;

initial
  $read_stimulus(""read_stimulus.pat"", input_vector);
","""Verilog Simulation Synchronization with Scheduled Callbacks using Misctf Routines""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p401.jpg,True,"The image contains text with instructions and code snippets. Here are the snippets of code depicted:

```c
char *aval_ptr, *bval_ptr;
aval_ptr = node_info.node_value.memoryval_p
         + (word_increment * memory_address);
bval_ptr = aval_ptr + node_info.node_ngruops;
```

```c
int group_num;
group_num = bit_num / 8;
```

```c
int group_bit;
group_bit = bit_num % 8;
```

```c
char mask;
mask = 0x01;
mask = mask << group_bit;
```

The surrounding text explains the process of modifying bits of a Verilog array using these code snippets.","*aval_ptr, *bval_ptr;
aval_ptr = node_info.node_value.memoryval_p
         + (word_increment * memory_address);
bval_ptr = aval_ptr + node_info.node_ngruops;

roup_num;
group_num = bit_num / 8;

roup_bit;
group_bit = bit_num % 8;

mask;
mask = 0x01;
mask = mask << group_bit;
","Caption: ""Instructions for modifying the bits of a Verilog array using a combination of pointers, bitwise operations, and C code routine integration.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p367.jpg,True,"The image includes a snippet of code from a book or document related to Verilog. Here is the code as written in the document:

```c
io_printf(""\n groups = %d\n"",    info_s.expr_ngruops);
io_printf("" vector size = %d\n"", info_s.expr_vec_size);
io_printf("" sign = %d\n"",        info_s.expr_sign);
io_printf("" LHS select = %d\n"",  info_s.expr_lhs_select);
io_printf("" RHS select = %d\n"",  info_s.expr_rhs_select);

switch (info_s.expr_type) {
   case TF_STRING:
      io_print("" string value = %s\n"", info_s.expr_string); break;
   case TF_READONLYREAL:
   case TF_READWRITEREAL:
      io_print("" real value = %f\n"", info_s.real_value); break;

   case TF_READONLY:
   case TF_READWRITE:
   case TF_RWBITSELECT:
   case TF_RWPARTSELECT:
   case TF_RWMEMSELECT:
      val_array = info_s.expr_value.p;
      io_printf("" vector value (in hex):\n"");
      for (i=0; i<info_s.expr_ngruops; i++) {
         io_printf("" avalbits[%d] = %x\n"", i, val_array[i].avalbits);
         io_printf("" bvalbits[%d] = %x\n"", i, val_array[i].bvalbits);
      }
      break;
}

io_printf(""\n\n"");
return(0);
}
```

Please note that there is a typographical error in the document: `info_s.expr_ngruops` should probably be `info_s.expr_ngroups`. Additionally, one instance of `io_print` might be intended to be `io_printf` as it's consistent with other `io_printf` uses in the code.","intf(""\n groups = %d\n"",    info_s.expr_ngruops);
io_printf("" vector size = %d\n"", info_s.expr_vec_size);
io_printf("" sign = %d\n"",        info_s.expr_sign);
io_printf("" LHS select = %d\n"",  info_s.expr_lhs_select);
io_printf("" RHS select = %d\n"",  info_s.expr_rhs_select);

switch (info_s.expr_type) {
   case TF_STRING:
      io_print("" string value = %s\n"", info_s.expr_string); break;
   case TF_READONLYREAL:
   case TF_READWRITEREAL:
      io_print("" real value = %f\n"", info_s.real_value); break;

   case TF_READONLY:
   case TF_READWRITE:
   case TF_RWBITSELECT:
   case TF_RWPARTSELECT:
   case TF_RWMEMSELECT:
      val_array = info_s.expr_value.p;
      io_printf("" vector value (in hex):\n"");
      for (i=0; i<info_s.expr_ngruops; i++) {
         io_printf("" avalbits[%d] = %x\n"", i, val_array[i].avalbits);
         io_printf("" bvalbits[%d] = %x\n"", i, val_array[i].bvalbits);
      }
      break;
}

io_printf(""\n\n"");
return(0);
}
","""Verilog PLI Code Example from a Textbook Chapter on Reading and Writing Values Using TF Routines""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p370.jpg,True,"The image contains Verilog code. Here is the code present in the image:

```verilog
sequence s_start_and_complete;
    tagType tag;
    (start, tag = tagIn)
    ##1 (
        !(start && tagIn == tag)
        throughout
        (complete && tagOut == tag) [-1]
    );
endsequence

property p_start_and_data_checks;
    dataType data;
    (start, data = dataIn)
    |->
    s_start_and_complete
    ##0 dataOut == data;
endproperty

a_start_and_data_checks: assert property (
    p_start_and_data_checks
);

a_complete_check: assert property (
    complete |-> s_start_and_complete.triggered
);
```

Below the code, there is a statement with some context for an additional assertion:

```verilog
a_mutex: assert property (!(start && complete));
```","
sequence s_start_and_complete;
    tagType tag;
    (start, tag = tagIn)
    ##1 (
        !(start && tagIn == tag)
        throughout
        (complete && tagOut == tag) [-1]
    );
endsequence

property p_start_and_data_checks;
    dataType data;
    (start, data = dataIn)
    |->
    s_start_and_complete
    ##0 dataOut == data;
endproperty

a_start_and_data_checks: assert property (
    p_start_and_data_checks
);

a_complete_check: assert property (
    complete |-> s_start_and_complete.triggered
);


a_mutex: assert property (!(start && complete));
","Caption: ""Example of Verilog code defining sequences and properties for tag protocol verification using SystemVerilog assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p441.jpg,True,"Here is the Verilog/SystemVerilog code extracted from the image:

```verilog
// Post-transmit callbacks
foreach (cbsq[i])
    cbsq[i].post_tx(this, c);
end : Tx

gen2drv.get(c); // Remove cell from the mailbox
->drv2gen; // Tell the generator we are done with this cell
end
endtask : run

// send(): Send a cell into the DUT
task Driver::send(input UNI_cell c);
    ATMCellType Pkt;

    c.pack(Pkt);
    $write(""Sending cell: "");
    foreach (Pkt.Mem[i])
        $write(""%x "", Pkt.Mem[i]); $display;

    // Iterate thru bytes of cell
    @(Rx.cbr);
    Rx.cbr.clav <= 1;
    for (int i=0; i<52; i++) begin
        // If not enabled, loop
        while (Rx.cbr.en !== 1'b1) @(Rx.cbr);

        // Assert Start of Cell, assert enable, send byte 0 (i==0)
        Rx.cbr.soc <= (i == 0);
        Rx.cbr.data <= Pkt.Mem[i];
        @(Rx.cbr);
    end
    Rx.cbr.soc <= '1z;
    Rx.cbr.data <= 8'bx;
    Rx.cbr.clav <= 0;
endtask

Sample 11.20 shows the driver callback class which has simple callbacks that are
called before & after a cell is transmitted. This class has empty tasks, which are used
by default. A test case can extend this class to inject new behavior in the driver
without having to change any code in the driver
```

This code is an example of a SystemVerilog testbench that includes tasks for sending data to a device under test (DUT) and handling post-transmission callbacks. Note that this is just a part of a longer code, as an indication from the page number and the text descriptions surrounding the code blocks.","
// Post-transmit callbacks
foreach (cbsq[i])
    cbsq[i].post_tx(this, c);
end : Tx

gen2drv.get(c); // Remove cell from the mailbox
->drv2gen; // Tell the generator we are done with this cell
end
endtask : run

// send(): Send a cell into the DUT
task Driver::send(input UNI_cell c);
    ATMCellType Pkt;

    c.pack(Pkt);
    $write(""Sending cell: "");
    foreach (Pkt.Mem[i])
        $write(""%x "", Pkt.Mem[i]); $display;

    // Iterate thru bytes of cell
    @(Rx.cbr);
    Rx.cbr.clav <= 1;
    for (int i=0; i<52; i++) begin
        // If not enabled, loop
        while (Rx.cbr.en !== 1'b1) @(Rx.cbr);

        // Assert Start of Cell, assert enable, send byte 0 (i==0)
        Rx.cbr.soc <= (i == 0);
        Rx.cbr.data <= Pkt.Mem[i];
        @(Rx.cbr);
    end
    Rx.cbr.soc <= '1z;
    Rx.cbr.data <= 8'bx;
    Rx.cbr.clav <= 0;
endtask

Sample 11.20 shows the driver callback class which has simple callbacks that are
called before & after a cell is transmitted. This class has empty tasks, which are used
by default. A test case can extend this class to inject new behavior in the driver
without having to change any code in the driver
","""Verilog Code Snippet Demonstrating Post-Transmit Callbacks and a Driver Send Task""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p177.jpg,True,"The image contains Verilog code samples. Here's the code presented in the image:

```verilog
sequence ab;
    a ##[1:5] b;
endsequence

sequence cde;
    c ##2 d ##2 e;
endsequence

sequence abcde;
    ab intersect cde;
endsequence

property isect;
    @(posedge clk) |-> abcde;
endproperty
```

Additionally, there's a text snippet that seems to be discussing an alternative or simplified version of the above property `isect`. However, that specific code snippet is obscured by the page content; only a small part of it is visible:

```verilog
@(posedge clk) $rose(Retry) |-> ##[1:4] $rose(dataRead);
```

This snippet seems to use the intersect operation conceptually, but due to the cutoff, the full context and accuracy cannot be confirmed from the image. The text preceding this code snippet discusses the intersect operator in Verilog and how it's used in properties within assertions.","
sequence ab;
    a ##[1:5] b;
endsequence

sequence cde;
    c ##2 d ##2 e;
endsequence

sequence abcde;
    ab intersect cde;
endsequence

property isect;
    @(posedge clk) |-> abcde;
endproperty


@(posedge clk) $rose(Retry) |-> ##[1:4] $rose(dataRead);
","""Verilog code example demonstrating the use of the 'intersect' operator with sequences and corresponding waveform illustrating the passing of a property assertion.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p328.jpg,True,"The image contains snippets of C-like function declarations that are part of a text describing the TF (Task Function) work area, commonly associated with Verilog PLI (Programming Language Interface). Here are the code snippets displayed in the image:

```c
void tf_setworkarea(workarea)
char *workarea
```

```c
char *tf_getworkarea()
char *tfinst
```

```verilog
always @(posedge clock)
    $read_test_vector(""%a.dat"", data_bus);
```

Please note that the function declarations may not represent complete code as they are intended for explanatory purposes in the context of the document. Similarly, the Verilog code snippet is an example of usage within a hardware simulation context.","tf_setworkarea(workarea)
char *workarea

*tf_getworkarea()
char *tfinst


always @(posedge clock)
    $read_test_vector(""%a.dat"", data_bus);
","""Exploring the TF work area in PLI applications for Verilog simulation""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p333.jpg,True,"The image does contain code. Here it is:

Sample 8.22 Base transaction class with copy function
```verilog
class Transaction;

virtual function Transaction copy(input Transaction to=null);
    if (to == null)
        copy = new();        // Construct new object
    else
        copy = to;           // or use existing
        copy.src = this.src; // Copy data fields
        copy.dst = this.dst;
        copy.data = this.data;
        copy.csm = this.csm;
    return copy;
endfunction

endclass
```

Sample 8.23 Extended transaction class with new copy function
```verilog
class BadTr extends Transaction;

virtual function Transaction copy(input Transaction to=null);
    BadTr bad;
    if (to == null)
        bad = new();         // Create a new object
    else
        $cast(bad, to);      // Reuse existing one
        super.copy(bad);     // Copy base data fields
        bad.bad_csm = this.bad_csm; // Copy extended fields
    return bad;
endfunction

endclass : BadTr
```","
class Transaction;

virtual function Transaction copy(input Transaction to=null);
    if (to == null)
        copy = new();        // Construct new object
    else
        copy = to;           // or use existing
        copy.src = this.src; // Copy data fields
        copy.dst = this.dst;
        copy.data = this.data;
        copy.csm = this.csm;
    return copy;
endfunction

endclass


class BadTr extends Transaction;

virtual function Transaction copy(input Transaction to=null);
    BadTr bad;
    if (to == null)
        bad = new();         // Create a new object
    else
        $cast(bad, to);      // Reuse existing one
        super.copy(bad);     // Copy base data fields
        bad.bad_csm = this.bad_csm; // Copy extended fields
    return bad;
endfunction

endclass : BadTr
","Caption: ""Verilog Object-Oriented Programming: Implementing a Custom Copy Function to Specify a Destination Object""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p455.jpg,True,"The image contains text and some pieces of code related to interfacing Verilog with C/C++ using the Direct Programming Interface (DPI). Below are the code snippets from the image:

```c
import ""DPI-C"" function int addmul (input int a, b,
                                    output int sum);
import ""DPI-C"" function void stop_model();
```

```c
int factorial(const int i) {
    if (i<=1) return 1;
    else return i*factorial(i-1);
}
```

These snippets show the usage of the ""DPI-C"" import functionality in Verilog for calling external functions written in C, and a simple C factorial function with a const argument.","t ""DPI-C"" function int addmul (input int a, b,
                                    output int sum);
import ""DPI-C"" function void stop_model();

actorial(const int i) {
    if (i<=1) return 1;
    else return i*factorial(i-1);
}
","""Interfacing SystemVerilog with C/C++ using DPI-C and data type mappings""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p459.jpg,True,"The image contains Verilog code. Here it is:

```verilog
module reggen(input logic busy, clk, rst, output logic req);
  wire idle;
  assign idle = !busy;

  always @(posedge clk or posedge rst) begin
    if (rst) req <= 1'b0;
    else if (busy) req <= 1'b0;
    else req <= 1'b1;
  end

  end_when_idle: assert property (
    @(posedge clk) disable iff (rst) idle |=> req);
endmodule : reggen
```

Additionally, there is a part of text on the image defining an assumption that complements the code above:

`idle_when_not_busy: assume final (idle == !busy);`","
module reggen(input logic busy, clk, rst, output logic req);
  wire idle;
  assign idle = !busy;

  always @(posedge clk or posedge rst) begin
    if (rst) req <= 1'b0;
    else if (busy) req <= 1'b0;
    else req <= 1'b1;
  end

  end_when_idle: assert property (
    @(posedge clk) disable iff (rst) idle |=> req);
endmodule : reggen
","""Verilog Example of a Request Generator Module with Formal Verification Assertions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p466.jpg,True,"```c
handle mod_h, net_h;

mod_h = acc_handle_tﬁarg(1);
net_h = null; /* initialize the target handle to null */
while ( (net_h = acc_next_net(mod_h, net_h)) != null) {
    /* perform desired operations on the net handle */
}

net_h = null; /* initialize the target handle to null */
while ( (net_h = acc_next_port(mod_h, net_h) ) {
    /* perform desired operations on the port handle */
}
```","e mod_h, net_h;

mod_h = acc_handle_tﬁarg(1);
net_h = null; /* initialize the target handle to null */
while ( (net_h = acc_next_net(mod_h, net_h)) != null) {
    /* perform desired operations on the net handle */
}

net_h = null; /* initialize the target handle to null */
while ( (net_h = acc_next_port(mod_h, net_h) ) {
    /* perform desired operations on the port handle */
}
","Caption: ""Programming with the Verilog Programming Language Interface (PLI) and ACC Routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p317.jpg,True,"The image contains two blocks of Verilog code. Here they are:

For Fig. 13.8:
```verilog
a_sync_accept: assert property(
    @(posedge clk)
        sync_accept_on (retry)
        a |=> b
    else $error(""FAIL"");
);
```

For Fig. 13.9:
```verilog
a_sync_accept_reject: assert property(
    @(posedge clk)
        sync_accept_on (retry)
        a |=> sync_reject_on(bad) b[*2]
    else $error(""FAIL"");
);
```","
a_sync_accept: assert property(
    @(posedge clk)
        sync_accept_on (retry)
        a |=> b
    else $error(""FAIL"");
);


a_sync_accept_reject: assert property(
    @(posedge clk)
        sync_accept_on (retry)
        a |=> sync_reject_on(bad) b[*2]
    else $error(""FAIL"");
);
","""Verilog code examples demonstrating concurrent assertions with synchronous aborts in a digital design context.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p300.jpg,True,"The image includes a snippet of Verilog code, which is:

```verilog
always @(posedge clock)
begin
    result <= $pow(x,y);
    ...
end
```

This code is demonstrating the usage of a system function `$pow`, which is presumably integrated into Verilog through the Programming Language Interface (PLI). The `$pow` function is being called within a sequential block that triggers at the positive edge of a clock signal. The result of the `$pow` function (a mathematical power operation) is assigned to a variable `result`. The `...` indicates that there may be additional code within the block that is not shown.","
always @(posedge clock)
begin
    result <= $pow(x,y);
    ...
end
","Caption: ""Integration of C math library functions into Verilog simulation using PLI with an example of a power function.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p303.jpg,True,"```verilog
module m3_v2 (logic a, b, clk1, clk2);
    a13_v2: assert property(
        @(posedge clk1) a |-> @(posedge clk2) nexttime b
    );
endmodule
```","
module m3_v2 (logic a, b, clk1, clk2);
    a13_v2: assert property(
        @(posedge clk1) a |-> @(posedge clk2) nexttime b
    );
endmodule
","Caption: ""Verilog code example demonstrating the use of the 'nexttime' operator in temporal assertions, accompanied by a waveform diagram for signal evaluation.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p314.jpg,True,"```c
int PLIbook_ReadVector_calltf(int user_data)
{
    if (user_data == 1)
        /* read test vectors as binary values */
    else if (user_data == 2)
        /* read test vectors as hex values */
}
```","LIbook_ReadVector_calltf(int user_data)
{
    if (user_data == 1)
        /* read test vectors as binary values */
    else if (user_data == 2)
        /* read test vectors as hex values */
}
",Verilog PLI Handbook excerpt discussing the handling of user_data in PLI calltf routines with an example of a conditional check in C code.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p472.jpg,True,"The image contains two blocks of Verilog code. The first block is a test case for a PLI application, and the second block is a model for a 1-bit adder. Below is the code as presented in the image:

First Block:
```verilog
`timescale 1ns / 1ns
module top;
  reg [2:0] test;
  tri [1:0] results;
  
  addbit i1 (test[0], test[1], test[2], results[0], results[1]);

  initial
    begin
      test = 3'b000;
      #10 test = 3'b001;
      #10 $show_all_nets(top);
      #10 $show_all_nets(i1);
      #10 $stop;
      #10 $finish;
    end
endmodule
```

Second Block:
```verilog
/*** A gate level 1 bit adder model ***/
`timescale 1ns / 1ns
module addbit (a, b, ci, sum, co);
  input  a, b, ci;
  output sum, co;

  wire   a, b, ci, sum, co, n1, n2, n3;

  xor
    (n1, a, b);
  xor #2 (sum, n1, ci);
  and
    (n2, a, b);
  and
    (n3, n1, ci);
  or #2 (co, n2, n3);
endmodule
```","
`timescale 1ns / 1ns
module top;
  reg [2:0] test;
  tri [1:0] results;
  
  addbit i1 (test[0], test[1], test[2], results[0], results[1]);

  initial
    begin
      test = 3'b000;
      #10 test = 3'b001;
      #10 $show_all_nets(top);
      #10 $show_all_nets(i1);
      #10 $stop;
      #10 $finish;
    end
endmodule


/*** A gate level 1 bit adder model ***/
`timescale 1ns / 1ns
module addbit (a, b, ci, sum, co);
  input  a, b, ci;
  output sum, co;

  wire   a, b, ci, sum, co, n1, n2, n3;

  xor
    (n1, a, b);
  xor #2 (sum, n1, ci);
  and
    (n2, a, b);
  and
    (n3, n1, ci);
  or #2 (co, n2, n3);
endmodule
","Caption: ""Excerpt from 'The Verilog PLI Handbook' showing Verilog test cases and a gate-level 1 bit adder module.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p465.jpg,True,"The image contains two code blocks that represent assertions and assumptions in the context of Verilog, which is a hardware description language.

Here are the two pieces of code:

For Block1:

```verilog
assert final (o1 != o2);
```

For Block2:

```verilog
assume final (i1 != i2);
```","
assert final (o1 != o2);


assume final (i1 != i2);
","Caption: ""Diagram representing the Assume-Guarantee Paradigm in Lightweight Formal Verification Flow, alongside Verilog code snippets demonstrating assertions and assumptions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p469.jpg,True,"The image contains Verilog code, as well as a part of a C code example. Here's the Verilog code from the image:

```verilog
c1.count(); // count = 127
if (c1.get() == 127)
    $display(""Successful count"");
else
    $display(""Error: load, expect 127, got %0d"", c1.get());

c1.count(); // count = 0
if (c1.get() == 0)
    $display(""Successful rollover"");
else
    $display(""Error: rollover, exp 127, got %0d"", c1.get());
end
```

And here's the C code from the image:

```c
void fib(svBitVecVal data[20]) {
    int i;
    data[0] = 1;
    data[1] = 1;
    for (i=2; i<20; i++)
        data[i] = data[i-1] + data[i-2];
}
```

The Verilog code snippet demonstrates a test scenario with a conditional check for a counting operation and error messages if the expected values are not met. The C code is a routine to compute the first 20 values in the Fibonacci series.","
c1.count(); // count = 127
if (c1.get() == 127)
    $display(""Successful count"");
else
    $display(""Error: load, expect 127, got %0d"", c1.get());

c1.count(); // count = 0
if (c1.get() == 0)
    $display(""Successful rollover"");
else
    $display(""Error: rollover, exp 127, got %0d"", c1.get());
end

fib(svBitVecVal data[20]) {
    int i;
    data[0] = 1;
    data[1] = 1;
    for (i=2; i<20; i++)
        data[i] = data[i-1] + data[i-2];
}
","Caption: ""Excerpt from a textbook or documentation showing an example of interfacing SystemVerilog with C/C++ for a counter rollover check and computing a Fibonacci series.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p482.jpg,True,"The image contains C code which is used to interface with SystemVerilog for tasks such as reading a command file and calling exported functions. Here is the code from the image:

```c
extern int mem_read(int, int*);
extern int mem_write(int, int);
extern void mem_build(int);

void read_file(const char *fname) {
    char cmd;
    FILE *file;

    file = fopen(fname, ""r"");
    while (!feof(file)) {
        cmd = fgetc(file);
        switch (cmd) {
        case 'M': {
            int hi;
            fscanf(file, ""%d "", &hi);
            mem_build(hi);
            break;
        }
        case 'R': {
            int addr, data, exp;
            fscanf(file, ""%d %d "", &addr, &exp);
            mem_read(addr, &data);
            if (data != exp)
                io_printf(""C: Data=%d, exp=%d\n"", data, exp);
            break;
        }
        case 'W': {
            int addr, data;
            fscanf(file, ""%d %d "", &addr, &data);
            mem_write(addr, data);
            break;
        }
        }
    }
    fclose(file);
}
```

This code snippet demonstrates functions for memory read `mem_read`, memory write `mem_write`, and memory build `mem_build`, which are declared as `extern` indicating they are defined elsewhere, probably in SystemVerilog. The `read_file` function opens a file and reads commands to execute these functions, performing tasks based on the command read ('M', 'R', or 'W').","n int mem_read(int, int*);
extern int mem_write(int, int);
extern void mem_build(int);

void read_file(const char *fname) {
    char cmd;
    FILE *file;

    file = fopen(fname, ""r"");
    while (!feof(file)) {
        cmd = fgetc(file);
        switch (cmd) {
        case 'M': {
            int hi;
            fscanf(file, ""%d "", &hi);
            mem_build(hi);
            break;
        }
        case 'R': {
            int addr, data, exp;
            fscanf(file, ""%d %d "", &addr, &exp);
            mem_read(addr, &data);
            if (data != exp)
                io_printf(""C: Data=%d, exp=%d\n"", data, exp);
            break;
        }
        case 'W': {
            int addr, data;
            fscanf(file, ""%d %d "", &addr, &data);
            mem_write(addr, data);
            break;
        }
        }
    }
    fclose(file);
}
","""Interfacing C with SystemVerilog for memory operations through command file processing.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p499.jpg,True,"The image contains Verilog-related code. Here's the code from the image:

```verilog
int is_bottom_module(handle this_module_h)
{
  if (acc_next_child(this_module_h, null))
    return(0); /* a module instance was found */
  else
    return(1); /* no child module instances */
}

handle first_port_handle;
first_port_handle = acc_next_port(module_handle, null);
```","
int is_bottom_module(handle this_module_h)
{
  if (acc_next_child(this_module_h, null))
    return(0); /* a module instance was found */
  else
    return(1); /* no child module instances */
}

handle first_port_handle;
first_port_handle = acc_next_port(module_handle, null);
","Caption: ""Exploring the Verilog hierarchy with the ACC routine library, demonstrating code snippets to check for bottom modules and to obtain the first port of a module.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p125.jpg,True,"The image contains a partial snippet of Verilog code in an example box titled ""Example 4-1 Over constrained procedural assertion."" Here is the code provided in the image:

```verilog
always @(a or b or c or d) begin
  :
  if (d)
    $assert_one_hot({a,b,c});
end
```

Please note that the code snippet above is incomplete (indicated by the colon ':'), and is intended to demonstrate the use of a procedural assertion in Verilog. The `$assert_one_hot` function is typically used to check that only one of the signals in the given set is high (true) at any one time, ensuring the signals are mutually exclusive.","
always @(a or b or c or d) begin
  :
  if (d)
    $assert_one_hot({a,b,c});
end
","Caption: ""Discussion on the risks of over constraining assertions in procedural code within Verilog, with an example of a procedural assertion using a PLI task.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p101.jpg,True,"The image contains the following Verilog code:

```verilog
initial begin
    rst_n = 1; // initialize to inactive value
    rst_n <= 0; // set to active value using nonblocking assign
    #3ns rst_n = 1;
    ...
```

In addition, there is another snippet of code further down:

```verilog
bit rst_n = 1 // initialize to inactive value
initial begin
    rst_n <= 0; // set to active value using nonblocking assign
    #3ns rst_n = 1;
    ...
``` 

These code excerpts are used in the context of explaining RTL modeling techniques to avoid certain gotchas in Verilog.","
initial begin
    rst_n = 1; // initialize to inactive value
    rst_n <= 0; // set to active value using nonblocking assign
    #3ns rst_n = 1;
    ...


bit rst_n = 1 // initialize to inactive value
initial begin
    rst_n <= 0; // set to active value using nonblocking assign
    #3ns rst_n = 1;
    ...
","""Common RTL Modeling Gotchas and Solutions in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p203.jpg,True,"The image contains two blocks of Verilog code. Here is the transcription of both:

The first block of code:

```verilog
always@(posedge clk)
begin
    #1 DataBus[0] <= 1'b0;
    #2 DataBus[1] <= 1'b1;
    #3 DataBus[2] <= 1'b0; // OutBusReg misses this one.
    #4 DataBus[3] <= 1'b1; // Updated after DataBus[2].
end
```

The second block of code:

```verilog
always@(posedge Clk)
begin
    fork
        #1 DataBus[0] <= 1'b0;
        #2 DataBus[1] <= 1'b1;
        #3 DataBus[2] <= 1'b0;
        #4 DataBus[3] <= 1'b1;
    join
    #1 OutBusReg = DataBus; // Updated after DataBus[3].
end
```","
always@(posedge clk)
begin
    #1 DataBus[0] <= 1'b0;
    #2 DataBus[1] <= 1'b1;
    #3 DataBus[2] <= 1'b0; // OutBusReg misses this one.
    #4 DataBus[3] <= 1'b1; // Updated after DataBus[2].
end


always@(posedge Clk)
begin
    fork
        #1 DataBus[0] <= 1'b0;
        #2 DataBus[1] <= 1'b1;
        #3 DataBus[2] <= 1'b0;
        #4 DataBus[3] <= 1'b1;
    join
    #1 OutBusReg = DataBus; // Updated after DataBus[3].
end
","Caption: ""Understanding the use of fork-join blocks in Verilog for concurrent execution and synchronization of signals to avoid glitches.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p115.jpg,True,"The image contains Verilog code. Here is the code represented in text form:

```verilog
module blk2 (output logic [31:0] d_out,
             input  logic [31:0] c, d,
             input  logic clk, rstn);

import sig_defs::*;

always @*
    result = a | b; // GOTCHA! shared variable

always @(posedge clk or negedge rstn)
    if (!rstn) begin
        pipe <=0;
        d_out <=0;
    end
    else begin
        pipe <= result; // GOTCHA! shared variables
        d_out <= pipe;
    end
endmodule

How to avoid this Gotcha

Shared variables are generally not synthesizable, and should not be used in RTL models. They can easily be avoided by using SystemVerilog’s always_comb, always_ff, always_latch, and continuous assign to assign values to variables. With these processes, it is illegal for a variable to be written to by more than one process, even when these processes are in different modules, interfaces or test programs.
module blk1 (...);

import sig_defs::*;

always_comb
    result = a & b; // ERROR! multiple processes write to result
...
endmodule

module blk2 (...);

import sig_defs::*;

always_comb
    result = a | b; // ERROR! multiple processes write to result
...
endmodule
```

The code is discussing the issue of shared variables in RTL (Register Transfer Level) Verilog models and how to avoid problems associated with them, including non-synthesizability and conflicts between processes. It provides guidance on better practices, such as using constructs like `always_comb`, `always_ff`, `always_latch`, and continuous assignments.","
module blk2 (output logic [31:0] d_out,
             input  logic [31:0] c, d,
             input  logic clk, rstn);

import sig_defs::*;

always @*
    result = a | b; // GOTCHA! shared variable

always @(posedge clk or negedge rstn)
    if (!rstn) begin
        pipe <=0;
        d_out <=0;
    end
    else begin
        pipe <= result; // GOTCHA! shared variables
        d_out <= pipe;
    end
endmodule

How to avoid this Gotcha

Shared variables are generally not synthesizable, and should not be used in RTL models. They can easily be avoided by using SystemVerilog’s always_comb, always_ff, always_latch, and continuous assign to assign values to variables. With these processes, it is illegal for a variable to be written to by more than one process, even when these processes are in different modules, interfaces or test programs.
module blk1 (...);

import sig_defs::*;

always_comb
    result = a & b; // ERROR! multiple processes write to result
...
endmodule

module blk2 (...);

import sig_defs::*;

always_comb
    result = a | b; // ERROR! multiple processes write to result
...
endmodule
","""Common Verilog RTL modeling mistakes involving shared variables and how to avoid them""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p131.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
always @(a or b or c) begin
    if (c)
        $assert_always (a^b);
end
```","
always @(a or b or c) begin
    if (c)
        $assert_always (a^b);
end
","""Verilog code example demonstrating the issue of false firing of procedural assertions across multiple simulation time slots.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p420.jpg,True,"The image contains a snippet of code, which is:

```verilog
define size(x) = if pairp(x) then size(first(x)) + size(rest(x)) + 1
                 else if intp(x) then abs(x) else 0
```

This code defines a function `size` using a pseudo code that resembles the syntax of a functional programming language. The function seems to calculate the size of a data structure `x` by recursively summing up the size of its parts if `x` is a pair, or returning the absolute value if `x` is an integer, otherwise returning 0. 

However, please note this code is not strictly Verilog. Verilog is a hardware description language used for electronic systems, and this example does not conform to Verilog's syntax. The code is likely used conceptually to describe an algorithm or function as part of a theoretical discussion in the document.","
define size(x) = if pairp(x) then size(first(x)) + size(rest(x)) + 1
                 else if intp(x) then abs(x) else 0
","The image depicts an academic paper discussing well-formed sequences of calling contexts and the application of context measures in verifying termination properties of recursive definitions, with a sample Verilog function `size` provided for illustration.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p119.jpg,True,"The image contains Verilog code in an example of a PSL (Property Specification Language) master reset assertion and an OVL (Open Verification Library) master reset assertion. Here's the code:

PSL master reset assertion:
```verilog
assert always ( (rst_n==0) -> !({ad, cbe_n, par})) @ (posedge clk);
```

OVL master reset assertion:
```verilog
assert_always master_reset (clk, !rst_n, !({ad, cbe_n, par}));
```","
assert always ( (rst_n==0) -> !({ad, cbe_n, par})) @ (posedge clk);


assert_always master_reset (clk, !rst_n, !({ad, cbe_n, par}));
","Caption: ""Verilog Assertions for PCI Master Reset Requirement in RTL Properties Documentation""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p188.jpg,True,"```verilog
property tagCheck;
    @(posedge clk) (State == TagCompare) ##1 (TagHit || TagMiss) |-> 
    if (TagHit)
        ##1 (State == mesiCompare)
    else
        ##1 (State == allocRead);
endproperty

baseP: assert property (tagCheck) else gotoFail;
coverP: cover property (tagCheck) gotoPass;
```","
property tagCheck;
    @(posedge clk) (State == TagCompare) ##1 (TagHit || TagMiss) |-> 
    if (TagHit)
        ##1 (State == mesiCompare)
    else
        ##1 (State == allocRead);
endproperty

baseP: assert property (tagCheck) else gotoFail;
coverP: cover property (tagCheck) gotoPass;
","""Example of a Verilog property definition using if...else in SystemVerilog Assertions (SVA)""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p129.jpg,True,"The image contains Verilog code samples. Here is the code transcribed from the image:

```verilog
always_ff @(posedge clock, negedge reset_n)
  if (reset_n)
    fifo_write_ptr = 0;
  else if (!fifo_full)
    fifo_write_ptr++;

always_ff @(posedge clock)
  if (fifo_write_ptr == 15) fifo_full <= 1;  // GOTCHA!
  else                      fifo_full <= 0;

// ...

always_ff @(posedge clock, negedge reset_n)
  if (reset_n)
    fifo_write_ptr = 0;
  else if (!fifo_full)
    fifo_write_ptr <= fifo_write_ptr + 1;
```

These code snippets are examples demonstrating a ""gotcha"" related to increment, decrement, and assignment operations in Verilog/SystemVerilog. The text explains the potential problem of using blocking assignments for increment/decrement operations in RTL models and provides a corrected way to model the behavior to avoid simulation race conditions. The corrected way replaces the blocking assignment `fifo_write_ptr++;` with a nonblocking assignment `fifo_write_ptr <= fifo_write_ptr + 1;`.","
always_ff @(posedge clock, negedge reset_n)
  if (reset_n)
    fifo_write_ptr = 0;
  else if (!fifo_full)
    fifo_write_ptr++;

always_ff @(posedge clock)
  if (fifo_write_ptr == 15) fifo_full <= 1;  // GOTCHA!
  else                      fifo_full <= 0;

// ...

always_ff @(posedge clock, negedge reset_n)
  if (reset_n)
    fifo_write_ptr = 0;
  else if (!fifo_full)
    fifo_write_ptr <= fifo_write_ptr + 1;
","""Discussion on the pitfalls of using increment and decrement operators in Verilog sequential logic blocks, highlighting potential simulation race conditions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p125.jpg,True,"The image contains Verilog code in a section labeled ""Sample 3.27 Time literals and `$timeformat`."" Here is the code presented:

```verilog
module timing;
  timeunit 1ns;
  timeprecision 1ps;
  initial begin
    $timeformat(-9, 3, ""ns"", 8);
    #1    $display(""%t"", $realtime); // 1.000ns
    #2ns  $display(""%t"", $realtime); // 3.000ns
    #0.1ns $display(""%t"", $realtime); // 3.100ns
    #41ps $display(""%t"", $realtime); // 3.141ns
  end
endmodule
```

This code snippet demonstrates how to specify time literals and use the `$timeformat` system task in SystemVerilog.","
module timing;
  timeunit 1ns;
  timeprecision 1ps;
  initial begin
    $timeformat(-9, 3, ""ns"", 8);
    #1    $display(""%t"", $realtime); // 1.000ns
    #2ns  $display(""%t"", $realtime); // 3.000ns
    #0.1ns $display(""%t"", $realtime); // 3.100ns
    #41ps $display(""%t"", $realtime); // 3.141ns
  end
endmodule
",Verilog Time Literals and Time Formatting Example,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p413.jpg,True,"The image contains Verilog code from a document that is describing a simple behavioral model for a PCI Target (Design Under Test, or DUT). Below is the visible code from the image:

```verilog
//De-assert IRDY_
@(negedge clk);
IRDY_ = '1'b1;
$display(""\n"",""tCYCLE COMPLETE"");

end
endmodule

/*******************************************************/
pci_target.v (PCI Target DUT)
/*******************************************************/

/* pci_target.v module
This is a simple behavioral model that drives only a simple 
(canned!) PCI Read Transaction from the target. This is 
-not- a complete PCI target model.
*/

module pci_target (input bit clk, reset_,
                   output logic TRDY_, DEVSEL_, input logic FRAME_, IRDY_,
                   input logic [3:0] C_BE_, input wire [31:0] AD
);

bit AD_enb;
reg [31:0] AD_reg;
assign AD = AD_enb ? AD_reg:32'hz;

initial
begin

    //Keep AD float...until you want to drive data on it
    //You are not yet selected, so keep DEVSEL_ de-asserted
    AD_enb = 1'b0;
    DEVSEL_ = '1'b1;

    //On assertion of IRDY_
    @(negedge IRDY_);

    //Drive DEVSEL_
    //Check 4
`ifdef check4
    DEVSEL_='1'b1;
`else
    DEVSEL_='1'b0;
`endif
    //$display(""\tTARGET selected"");
```

The code snippet includes parts of a Verilog module definition with inputs and outputs for the PCI target, initial block statements, and procedural blocks for driving signals based on events. The actual design might have more code before and after this snippet, and some parts of the code are obscured by the curve of the page, such as comments and potentially some display or procedural statements.","
//De-assert IRDY_
@(negedge clk);
IRDY_ = '1'b1;
$display(""\n"",""tCYCLE COMPLETE"");

end
endmodule

/*******************************************************/
pci_target.v (PCI Target DUT)
/*******************************************************/

/* pci_target.v module
This is a simple behavioral model that drives only a simple 
(canned!) PCI Read Transaction from the target. This is 
-not- a complete PCI target model.
*/

module pci_target (input bit clk, reset_,
                   output logic TRDY_, DEVSEL_, input logic FRAME_, IRDY_,
                   input logic [3:0] C_BE_, input wire [31:0] AD
);

bit AD_enb;
reg [31:0] AD_reg;
assign AD = AD_enb ? AD_reg:32'hz;

initial
begin

    //Keep AD float...until you want to drive data on it
    //You are not yet selected, so keep DEVSEL_ de-asserted
    AD_enb = 1'b0;
    DEVSEL_ = '1'b1;

    //On assertion of IRDY_
    @(negedge IRDY_);

    //Drive DEVSEL_
    //Check 4
`ifdef check4
    DEVSEL_='1'b1;
`else
    DEVSEL_='1'b0;
`endif
    //$display(""\tTARGET selected"");
",Verilog code for a PCI target device module and some SystemVerilog assertions.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p206.jpg,True,"```verilog
module dp_chk(
input logic reset, clk, enable,
input logic [15:0]
d1, d2, d3, ..., d61, d62, d63, d64);
parameter data_file = """";
parameter identity = """";
```","
module dp_chk(
input logic reset, clk, enable,
input logic [15:0]
d1, d2, d3, ..., d61, d62, d63, d64);
parameter data_file = """";
parameter identity = """";
","Caption: ""Verilog code snippet for a data-path verification checker module, along with diagrams illustrating the golden C model output and dynamic pipeline checking process.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p361.jpg,True,"The image contains Verilog code, which is a hardware description language used to model electronic systems. Below is the code extracted from the image:

```verilog
module test;
    default clocking @ clk; endclocking
    default disable iff reset;

    checker test_bMode;
        //directly inherits @ clk and `reset` from the higher-
        level context of module test
    endchecker

    checker test_cMode; //Note this is a new checker
        //Redefines the default blocks. Point is that you can infer/
        inherit or redefine what is
        //inherited
        
        default clocking @ clk1; endclocking //Note that the
        default clocking block is for @ clk1
        default disable iff reset_system; //The default disable
        iff condition is `reset_system`
    endchecker

endmodule

checker ck1(irdy, trdy, frame_, event clk<=$inferred_clock,
    event reset = $inferred_disable);
    default clocking @ clk; endclocking
    default disable iff reset;

    property check1;
        irdy |-> ##2 trdy;
    endproperty
```

This code includes examples of modules and checkers in Verilog. The checkers are used to define properties that can be checked during simulation to verify the behavior of the hardware design. ""test_bMode"" and ""test_cMode"" are example checkers, and ""ck1"" is an example of a nested checker with a defined property ""check1.""","
module test;
    default clocking @ clk; endclocking
    default disable iff reset;

    checker test_bMode;
        //directly inherits @ clk and `reset` from the higher-
        level context of module test
    endchecker

    checker test_cMode; //Note this is a new checker
        //Redefines the default blocks. Point is that you can infer/
        inherit or redefine what is
        //inherited
        
        default clocking @ clk1; endclocking //Note that the
        default clocking block is for @ clk1
        default disable iff reset_system; //The default disable
        iff condition is `reset_system`
    endchecker

endmodule

checker ck1(irdy, trdy, frame_, event clk<=$inferred_clock,
    event reset = $inferred_disable);
    default clocking @ clk; endclocking
    default disable iff reset;

    property check1;
        irdy |-> ##2 trdy;
    endproperty
","""Verilog code example illustrating the use of checkers and the definition of default clocking and disable conditions in a test bench.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p131.jpg,True,"The image contains Verilog code as a part of the text. Here is the code:

```verilog
module arb_with_port (output logic [1:0] grant,
                      input  logic [1:0] request,
                      input  bit rst, clk);

always @(posedge clk or posedge rst) begin
    if (rst)
        grant <= 2'b00;
    else if (request[0]) // High priority
        grant <= 2'b01;
    else if (request[1]) // Low priority
        grant <= 2'b10;
    else
        grant <= '0;
end
endmodule
```

The code snippet is given as ""Sample 4.1 Arbiter model using ports"" and it describes a Verilog module for an arbiter with ports handling signals for requests, reset, and clock, and outputting grant signals.","
module arb_with_port (output logic [1:0] grant,
                      input  logic [1:0] request,
                      input  bit rst, clk);

always @(posedge clk or posedge rst) begin
    if (rst)
        grant <= 2'b00;
    else if (request[0]) // High priority
        grant <= 2'b01;
    else if (request[1]) // Low priority
        grant <= 2'b10;
    else
        grant <= '0;
end
endmodule
","Caption: ""Verilog code example for an arbiter module with port declarations, demonstrating communication between a testbench and RTL block.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p407.jpg,True,"The image contains snippets of Verilog code related to SystemVerilog assertions. Below is the code present in the image:

```verilog
assert property (checkdataValid) else
    $display($stime,,, ""checkdataValid FAIL"");

`endif

/* ---------------------------------------------------
CHECK # 3.
'dack' going high signifies that target have accepted data
and that master
must de-assert 'dValid' the clock after 'dack' goes high.

Note that since data must be valid for minimum 2 cycles,
that 'dack' cannot
go high for at least 1 clock after the transfer starts (i.e.
after the
rising edge of 'dValid') and that it must not remain low
for more than 3
clocks (because data must transfer in max 4 clocks).
------------------------------------------------------*/

`ifdef check3
    property checkdAck;
        @(posedge clk) dValid |-> dValid; //DUMMY - REMOVE
        this line and code
            //correct assertion
    endproperty
    assert property (checkdAck) else $display($stime,,,
        ""checkdAck FAIL"");

`endif

endmodule

********************************************************
test_bus_protocol.v
********************************************************
module test_bus_protocol (output bit clk, reset,
                          input logic dValid, dAck,
                          input logic [7:0] data);

    bus_protocol bp1 (.*);
    bind bus_protocol bus_protocol_property bp1b1 (.*);

    initial begin clk=1; reset=1; end
    always #5 clk=!clk;
```

Please note that the code contains comments that describe certain checks and assertions related to a bus protocol, and also includes a dummy assertion with a comment indicating it should be removed to correct the code.","
assert property (checkdataValid) else
    $display($stime,,, ""checkdataValid FAIL"");

`endif

/* ---------------------------------------------------
CHECK # 3.
'dack' going high signifies that target have accepted data
and that master
must de-assert 'dValid' the clock after 'dack' goes high.

Note that since data must be valid for minimum 2 cycles,
that 'dack' cannot
go high for at least 1 clock after the transfer starts (i.e.
after the
rising edge of 'dValid') and that it must not remain low
for more than 3
clocks (because data must transfer in max 4 clocks).
------------------------------------------------------*/

`ifdef check3
    property checkdAck;
        @(posedge clk) dValid |-> dValid; //DUMMY - REMOVE
        this line and code
            //correct assertion
    endproperty
    assert property (checkdAck) else $display($stime,,,
        ""checkdAck FAIL"");

`endif

endmodule

********************************************************
test_bus_protocol.v
********************************************************
module test_bus_protocol (output bit clk, reset,
                          input logic dValid, dAck,
                          input logic [7:0] data);

    bus_protocol bp1 (.*);
    bind bus_protocol bus_protocol_property bp1b1 (.*);

    initial begin clk=1; reset=1; end
    always #5 clk=!clk;
","Caption: ""SystemVerilog Assertions for Verilog Code Handling Data Transfer Validity and Acknowledgement Signals""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p119.jpg,True,"The image contains Verilog code within a textbook or document. Here is the code that is visible in the image:

```verilog
function automatic void print_csm (const ref bit [31:0] a[], input bit [31:0] low = 0, input int high = -1);
  bit [31:0] checksum = 0;

  if (high == -1 || high >= a.size())
    high = a.size()-1;

  for (int i=low; i<=high; i++)
    checksum ^= a[i];
  $display(""The array checksum is %h"", checksum);
endfunction
```

This Verilog code sample is demonstrating a function with default argument values. The `print_csm` function calculates a checksum for a portion of an array, with the ability to specify the starting and ending indices. If indices are not provided, it will default to the full range of the array.

There is also some usage examples of this function just below the code sample, but they are not part of the code itself, so they are not included in the code transcription above.","
function automatic void print_csm (const ref bit [31:0] a[], input bit [31:0] low = 0, input int high = -1);
  bit [31:0] checksum = 0;

  if (high == -1 || high >= a.size())
    high = a.size()-1;

  for (int i=low; i<=high; i++)
    checksum ^= a[i];
  $display(""The array checksum is %h"", checksum);
endfunction
","Caption: ""Sample Verilog code showing how to define a function with default argument values and how to call it using different argument combinations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p102.jpg,True,"The image contains Verilog code. Here is the code extracted from the image:

```verilog
addbit il (test[0], test[1], test[2], results[0], results[1]);

initial
begin
  test = 3'b000;
  foo = 3.14;
  bar = 0;
  bar[63:60] = 4'hF;
  bar[35:32] = 4'ha;
  bar[31:28] = 4'hC;
  bar[03:00] = 4'hE;

  #1 test = 3'b011;

  #1 $show_all_signals(top);
  #1 $show_all_signals(il);

  #1 $stop;
  #1 $finish;
end
endmodule

/*** An RTL level 1 bit adder model ***/
`timescale 1ns / 1ns
module addbit (a, b, ci, sum, co);
input a, b, ci;
output sum, co;

wire a, b, ci;
reg sum, co;

always @(a or b or ci)
  (co, sum) = a + b + ci;

endmodule
```

This code appears to be an example from a book, demonstrating a basic test bench and a simple one-bit adder module in Verilog.","
addbit il (test[0], test[1], test[2], results[0], results[1]);

initial
begin
  test = 3'b000;
  foo = 3.14;
  bar = 0;
  bar[63:60] = 4'hF;
  bar[35:32] = 4'ha;
  bar[31:28] = 4'hC;
  bar[03:00] = 4'hE;

  #1 test = 3'b011;

  #1 $show_all_signals(top);
  #1 $show_all_signals(il);

  #1 $stop;
  #1 $finish;
end
endmodule

/*** An RTL level 1 bit adder model ***/
`timescale 1ns / 1ns
module addbit (a, b, ci, sum, co);
input a, b, ci;
output sum, co;

wire a, b, ci;
reg sum, co;

always @(a or b or ci)
  (co, sum) = a + b + ci;

endmodule
","Example of a Verilog code snippet for a 1-bit adder module from ""The Verilog PLI Handbook, Part One"".",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p115.jpg,True,"The image contains the following Verilog code:

```verilog
initial begin
  m1: assume property(@(posedge clk) rst);
  a1: assert property(@(posedge clk) !ready);
end
``` 

This snippet illustrates the use of `assume` and `assert` properties in Verilog within an `initial` block, which are aspects of SystemVerilog Assertions (SVA).","
initial begin
  m1: assume property(@(posedge clk) rst);
  a1: assert property(@(posedge clk) !ready);
end
","Caption: ""Educational text explaining the usage of the 'assume' and 'assert' properties in Verilog for checking conditions at the positive edge of a clock cycle, and introducing the 'nexttime' property in SystemVerilog Assertions (SVA).""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p664.jpg,True,"```c
void init_usertfs()
{
    p_tfcell usertf;
    for (usertf = veriusertfs; usertf; usertf++) {
        if (usertf->type == 0)
            return;
        mti_RegisterUserTF(usertf);
    }
}
```","init_usertfs()
{
    p_tfcell usertf;
    for (usertf = veriusertfs; usertf; usertf++) {
        if (usertf->type == 0)
            return;
        mti_RegisterUserTF(usertf);
    }
}
","Caption: ""Excerpt from The Verilog PLI Handbook detailing the initialization of user-defined tasks and functions, and instructions for compiling and running PLI applications with ModelSim on different operating systems.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p349.jpg,True,"The image contains Verilog code, which is a hardware description language used in the design of electronic systems. Here is the code from the image:

First snippet:
```verilog
module example;
  logic r1,r2, r3,r4,clk,clk1;
  always @ (posedge clk) begin :ablock
    r3=r1 & r2;
  end
  always @ (posedge clk1) begin: bblock
    r4=r1 || r2 ;
  end
endmodule
```

Second snippet:
```verilog
module example;
  logic r1,r2, r3,r4,clk,clk1;
  `define exDefLet r1 || r2;
  always @ (posedge clk) begin :ablock
    `define exDefLet r1 & r2;
    r3=`exDefLet;
  end
  always @ (posedge clk1) begin: bblock
    r4=`exDefLet;
  end
endmodule
```

Third snippet:
```verilog
module example;
  logic r1,r2, r3,r4,clk,clk1;
  always @ (posedge clk) begin: ablock
    r3=r1 & r2;
  end
  always @ (posedge clk1) begin: bblock
    r4=r1 & r2;
  end
endmodule
```

The text explains the concept of scope as it pertains to the `let` construct in Verilog, as well as the use of the `define directive. It then shows how the code would change after `define substitutions.","
module example;
  logic r1,r2, r3,r4,clk,clk1;
  always @ (posedge clk) begin :ablock
    r3=r1 & r2;
  end
  always @ (posedge clk1) begin: bblock
    r4=r1 || r2 ;
  end
endmodule


module example;
  logic r1,r2, r3,r4,clk,clk1;
  `define exDefLet r1 || r2;
  always @ (posedge clk) begin :ablock
    `define exDefLet r1 & r2;
    r3=`exDefLet;
  end
  always @ (posedge clk1) begin: bblock
    r4=`exDefLet;
  end
endmodule


module example;
  logic r1,r2, r3,r4,clk,clk1;
  always @ (posedge clk) begin: ablock
    r3=r1 & r2;
  end
  always @ (posedge clk1) begin: bblock
    r4=r1 & r2;
  end
endmodule
","Caption: ""Differences in Verilog local scope handling using always blocks and `define directives, with an example of how code is affected by scope and redefinition of the same variable.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p670.jpg,True,"```c
#include ""veriuser.h""

/* prototypes of the PLI application routines */
extern int PLIbook_ShowVal_checktf(), PLIbook_ShowVal_calltf();
extern int PLIbook_pow_sizetf(), PLIbook_pow_checktf(),
           PLIbook_pow_calltf(), PLIbook_pow_misctf();

/* the veriusertfs table */
s_tfcell veriusertfs[] =
{
    {usertask,
     0, /* user_data value */
     PLIbook_ShowVal_checktf, /* checktf routine */
     0, /* sizetf routine */
     PLIbook_ShowVal_calltf, /* calltf routine */
     0, /* misctf routine */
     ""$show_value"", /* system task/function name */
     1 /* forward reference = true */
    },
    {userfunction,
     0, /* user_data value */
     PLIbook_pow_checktf, /* checktf routine */
     PLIbook_pow_sizetf, /* sizetf routine */
     PLIbook_pow_calltf, /* calltf routine */
     PLIbook_pow_misctf, /* misctf routine */
     ""$pow"", /* system task/function name */
     1 /* forward reference = true */
    },
    {0} /*** final entry must be 0 ***/
};
```","ude ""veriuser.h""

/* prototypes of the PLI application routines */
extern int PLIbook_ShowVal_checktf(), PLIbook_ShowVal_calltf();
extern int PLIbook_pow_sizetf(), PLIbook_pow_checktf(),
           PLIbook_pow_calltf(), PLIbook_pow_misctf();

/* the veriusertfs table */
s_tfcell veriusertfs[] =
{
    {usertask,
     0, /* user_data value */
     PLIbook_ShowVal_checktf, /* checktf routine */
     0, /* sizetf routine */
     PLIbook_ShowVal_calltf, /* calltf routine */
     0, /* misctf routine */
     ""$show_value"", /* system task/function name */
     1 /* forward reference = true */
    },
    {userfunction,
     0, /* user_data value */
     PLIbook_pow_checktf, /* checktf routine */
     PLIbook_pow_sizetf, /* sizetf routine */
     PLIbook_pow_calltf, /* calltf routine */
     PLIbook_pow_misctf, /* misctf routine */
     ""$pow"", /* system task/function name */
     1 /* forward reference = true */
    },
    {0} /*** final entry must be 0 ***/
};
","Caption: ""Sample code for specifying PLI applications in a Verilog simulation environment from The Verilog PLI Handbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p248.jpg,True,"The image contains Verilog code within the text. Here is the code:

```verilog
$display(""Hello Verilog"");
$write(""Hello Verilog\n"");

$display(""t %t b%B d %D h%H o%o s%S s"", $time,h,h,h,h);

// Result of the above display statement is also given as an example output:
t 0 B 0111000001110001 D 28785 H 7071 o 070161 s pq
```

- `$display` and `$write` are SystemVerilog tasks used to print to the console, with `$display` automatically appending a newline character at the end.
- The example demonstrates how to use format specifiers (`%t`, `%B`, `%D`, `%H`, `%o`, `%s`) within `$display` and `$write` statements to print time, binary, decimal, hexadecimal, octal representation and string of signals, respectively.

Note that the format specifiers `%t`, `%B`, `%D`, `%H`, `%o`, and `%s` are placeholders, and in a working example, these would correspond to actual values of variables in the Verilog simulation environment.","
$display(""Hello Verilog"");
$write(""Hello Verilog\n"");

$display(""t %t b%B d %D h%H o%o s%S s"", $time,h,h,h,h);

// Result of the above display statement is also given as an example output:
t 0 B 0111000001110001 D 28785 H 7071 o 070161 s pq
","Caption: ""Overview of Verilog's $display and $write Statements and Formatting Options""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p327.jpg,True,"The image contains a snippet of Verilog code within an example block. Here is the code:

```verilog
assert_frame #(0,2,4) check_req_ack (clk, reset_n, req, ack);
```","
assert_frame #(0,2,4) check_req_ack (clk, reset_n, req, ack);
","Caption: ""Verilog assertion example for checking cycle timing relationships using assert_frame in the Open Verification Library.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p333.jpg,True,"The image contains information about the `assert_change` assertion from the Open Verification Library in Verilog, not actual Verilog code. However, there is a snippet that represents the syntax for how to use `assert_change`:

```
assert_change[#[severity_level, width, num_cks, flag, options, msg]] inst_name (clk, reset_n, start_event, test_expr);
```

Here is an explanation of the parameters used in this syntax:

- `severity_level`: Severity of the failure with a default value of 0.
- `width`: Width of `test_expr` with a default value of 1.
- `num_cks`: The number of clocks for `test_expr` to change its value before an error is triggered after `start_event` is asserted.
- `flag`: A parameter that defines behavior regarding `start_event`; 0 is for default behavior, 1 to restart monitoring on new `start_event`, and 2 to issue an error if `start_event` occurs again.
- `options`: Vendor options; typically follows the format of `options=<value>`.
- `msg`: The error message that will be printed if the assertion fires.
- `inst_name`: The instance name of the assertion monitor.
- `clk`: The triggering clock or event that monitors the assertion.
- `reset_n`: The signal indicating completed initialization.
- `start_event`: The starting event that triggers monitoring of the `test_expr`.
- `test_expr`: The expression being verified at the positive edge of `clk`.

While this provides valuable information on how to construct such an assertion in Verilog, it is not executable Verilog code by itself.","_change[#[severity_level, width, num_cks, flag, options, msg]] inst_name (clk, reset_n, start_event, test_expr);
","""Documentation excerpt explaining the Verilog 'assert_change' construct for assertion-based verification in digital system design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p274.jpg,True,"Sure, this image contains Verilog code. Here is the code as seen in the image:

```verilog
`ifdef SHORT
    `define LIMIT 10
`else // !SHORT
    `define LIMIT 10_000_000
`endif // SHORT

module reverse;
    integer i, j;
    reg [7:0] e0, e1, b;

    initial
    begin
        e0=8'h99;
        e1=8'h99;
        b=8'd0;
        for (i = 0; i < `LIMIT; i = i + 1) begin
            `ifdef METHOD1
                for (j = 0; j < 8; j = j + 1)
                    e0[j] = e0[j] ^ b[7-j];
            `endif // METHOD1
            `ifdef METHOD2
                e1 = e1 ^ {b[7],b[6],b[5],b[4],b[3],b[2],b[1],b[0]};
            `endif // METHOD2
            `ifdef CHECK
                if (e0 != e1) begin
                    $display(""e0!= e1 - %h - %h"",e0,e1);
                    $finish;
                end
            `endif // CHECK
            b = b + 8'd1;
        end
        `ifdef METHOD1
            $display(""e0 =%h"",e0);
        `endif // METHOD1
        `ifdef METHOD2
            $display(""e1 =%h"",e1);
        `endif // METHOD2
        $finish;
    end
endmodule // reverse
```","
`ifdef SHORT
    `define LIMIT 10
`else // !SHORT
    `define LIMIT 10_000_000
`endif // SHORT

module reverse;
    integer i, j;
    reg [7:0] e0, e1, b;

    initial
    begin
        e0=8'h99;
        e1=8'h99;
        b=8'd0;
        for (i = 0; i < `LIMIT; i = i + 1) begin
            `ifdef METHOD1
                for (j = 0; j < 8; j = j + 1)
                    e0[j] = e0[j] ^ b[7-j];
            `endif // METHOD1
            `ifdef METHOD2
                e1 = e1 ^ {b[7],b[6],b[5],b[4],b[3],b[2],b[1],b[0]};
            `endif // METHOD2
            `ifdef CHECK
                if (e0 != e1) begin
                    $display(""e0!= e1 - %h - %h"",e0,e1);
                    $finish;
                end
            `endif // CHECK
            b = b + 8'd1;
        end
        `ifdef METHOD1
            $display(""e0 =%h"",e0);
        `endif // METHOD1
        `ifdef METHOD2
            $display(""e1 =%h"",e1);
        `endif // METHOD2
        $finish;
    end
endmodule // reverse
","Caption: ""Verilog code snippet from a simulation performance test bench that showcases different methods for running simulations with varying definitions and checks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p86.jpg,True,"The image contains Verilog code examples for creating sequences, properties, and assertions. Here are the snippets of Verilog code from the image:

First snippet:
```verilog
sequence sr1;
  req ##2 gnt;
endsequence

property pr1;
  @(posedge clk) cStart |=> sr1;
endproperty

reqGnt: assert property (pr1) $display($stime,,,""\t\t %m PASS""); else $display($stime,,,""\t\t %m FAIL"");
```

Second snippet:
```verilog
sequence sr1;
  req ##2 gnt;
endsequence

property pr1;
  @(posedge clk) cStart |=> sr1;
endproperty

reqGnt: assert property (pr1);
```

Third snippet:
```verilog
sequence sr1;
  req ##2 gnt;
endsequence

property pr1;
  cStart |=> sr1;
endproperty

reqGnt: assert property (@(posedge clk) pr1);
```

These examples illustrate different ways of specifying the clock event (or sampling edge) in Verilog concurrent assertions, either in the sequence, the property, or the assertion itself.","
sequence sr1;
  req ##2 gnt;
endsequence

property pr1;
  @(posedge clk) cStart |=> sr1;
endproperty

reqGnt: assert property (pr1) $display($stime,,,""\t\t %m PASS""); else $display($stime,,,""\t\t %m FAIL"");


sequence sr1;
  req ##2 gnt;
endsequence

property pr1;
  @(posedge clk) cStart |=> sr1;
endproperty

reqGnt: assert property (pr1);


sequence sr1;
  req ##2 gnt;
endsequence

property pr1;
  cStart |=> sr1;
endproperty

reqGnt: assert property (@(posedge clk) pr1);
","""Examples of specifying clocking in Verilog assertions using 'sequence,' 'property,' and 'assert' constructs.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p201.jpg,True,"The image contains text and snippets of code which appear to be examples from a hardware description language, specifically Verilog. Here are the excerpts of the code that are visible:

```
@(posedge clk0) A ##1 @(posedge clk1) B; is identical to
@(posedge clk0) A ##1 @(posedge clk0) B; is identical to
@(posedge clk0) A ##1 B;
```

The code appears to be explaining some aspect of clock edge triggered operations and how they relate to multi-clocking sequences in a Verilog environment. The `##1` notation is typically used to represent a one cycle delay between events in sequence expressions.","dge clk0) A ##1 @(posedge clk1) B; is identical to
@(posedge clk0) A ##1 @(posedge clk0) B; is identical to
@(posedge clk0) A ##1 B;
","""Discussion and examples of legal and illegal multiply clocked sequences in Verilog, focusing on the usage of single-delay and zero-delay concatenation operators.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p290.jpg,True,"The image contains pieces of code in two separate examples related to Property Specification Language (PSL) and SystemVerilog for hardware verification. 

Here is the first snippet of code from Example 8-9:

```verilog
default clock = (posedge clk);

property PendingEventuallyAfter =
  always { (rose(enable)) |-> {transfer [-4] ; rose(pending)} ) ;
assert PendingEventuallyAfter;
```

And here is the second snippet of code from Example 8-10:

```verilog
property PendingImmediatelyAfter;
  @(posedge clk)
    $rose(enable) |-> transfer [-4] ##1 $rose(pending);
endproperty
assert property (PendingImmediatelyAfter);

property PendingEventuallyAfter;
  @(posedge clk)
    $rose(enable) |-> transfer [-4] ##1 $rose(pending);
endproperty
assert property (PendingEventuallyAfter);
``` 

These examples demonstrate how to specify behavior in hardware description and verification using PSL and SystemVerilog assertions.","
default clock = (posedge clk);

property PendingEventuallyAfter =
  always { (rose(enable)) |-> {transfer [-4] ; rose(pending)} ) ;
assert PendingEventuallyAfter;


property PendingImmediatelyAfter;
  @(posedge clk)
    $rose(enable) |-> transfer [-4] ##1 $rose(pending);
endproperty
assert property (PendingImmediatelyAfter);

property PendingEventuallyAfter;
  @(posedge clk)
    $rose(enable) |-> transfer [-4] ##1 $rose(pending);
endproperty
assert property (PendingEventuallyAfter);
",This image shows excerpts from a book or document discussing Property Specification Language (PSL) and SystemVerilog assertions for temporal logic in hardware verification. The shown code examples demonstrate how to specify that a 'pending' event should occur immediately and eventually after a 'transfer' event under certain conditions.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p738.jpg,True,"The image shows a text excerpt from ""The Verilog PLI Handbook, Appendices."" It contains function prototypes and descriptions for certain Verilog Programming Language Interface (PLI) functions, but no executable code. Here are the function prototypes as shown in the image:

```c
int tf_setrealdelay(real delay)
int tf_setrealdelay(real delay, tfinst)

void tf_setworkarea(work area)
void tf_setworkarea(work area, tfinst)

int tf_sizep(n)
int tf_sizep(n, tfinst)

char *tf_spname()
char *tf_spname(tfcell)
```

Descriptions for these functions are provided, explaining their purpose and the parameters they accept, but as these are not complete code examples or implementations, we refer to them as prototypes rather than executable code.","f_setrealdelay(real delay)
int tf_setrealdelay(real delay, tfinst)

void tf_setworkarea(work area)
void tf_setworkarea(work area, tfinst)

int tf_sizep(n)
int tf_sizep(n, tfinst)

char *tf_spname()
char *tf_spname(tfcell)
","Page from ""The Verilog PLI Handbook"" detailing function prototypes for programming language interface (PLI) related to real delays, work areas, sizing, and scope naming in Verilog simulations.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p284.jpg,True,"```verilog
property arb_rotation(N);
    @(posedge clk) (req[N+1] ##1 
        req[N+1] && req[N] && gnt[N] && end_of_trans |=> gnt[N+1]);
endproperty

assert property (arb_rotation(0))
    else $error(""Grant did not switch to next request at end of transaction."");

// Next combination of request(1, 2) and current grant...
assert property (arb_rotation(1))
    else $error(""Grant did not switch to next request at end of transaction."");
```","
property arb_rotation(N);
    @(posedge clk) (req[N+1] ##1 
        req[N+1] && req[N] && gnt[N] && end_of_trans |=> gnt[N+1]);
endproperty

assert property (arb_rotation(0))
    else $error(""Grant did not switch to next request at end of transaction."");

// Next combination of request(1, 2) and current grant...
assert property (arb_rotation(1))
    else $error(""Grant did not switch to next request at end of transaction."");
","""Example of SystemVerilog code for round-robin arbitration assertion ensuring fair access to a shared resource.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p215.jpg,True,"The image contains pieces of Verilog code within it. Here are the code excerpts from the image:

For Figure 11.5:
```verilog
sequence s1;
int x;
(
  (a ##1 b ##[1:2] x=data;) or
  (d ##1 e)
) ##1 (data1=x+1)
endsequence
```

And for Figure 11.6:
```verilog
sequence s1;
int x;
( (1'b1, x=data) ##0
  (a ##1 b) or
  (d ##1 e)
) ##1 (data1=x+1)
endsequence
```

These pieces of code demonstrate examples of using local variables within sequence blocks in Verilog and discuss a correct and incorrect way to assign and use these variables within composite sequences using the ""or"" operator.","
sequence s1;
int x;
(
  (a ##1 b ##[1:2] x=data;) or
  (d ##1 e)
) ##1 (data1=x+1)
endsequence


sequence s1;
int x;
( (1'b1, x=data) ##0
  (a ##1 b) or
  (d ##1 e)
) ##1 (data1=x+1)
endsequence
","""Comparing two approaches to handling local variables in parallel threads with Verilog sequences: illustrating a common error and a correct solution.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p92.jpg,True,"The image contains a snippet of Verilog code showing the concept of a ""default clocking block."" Here is the text of the code as seen in the image:

```
default clocking cb1 @(posedge clk);
endclocking

property checkReqGnt;
    req ##2 gnt;
endproperty

property checkBusGrant;
    bgack |-> not ($isunknown(busgnt));
endproperty

reqGntP: assert property (checkReqGnt);
bgackP: assert property (checkBusGrant);
```

The image describes how these properties and asserts will inherit the clock from the default clocking block cb1.","t clocking cb1 @(posedge clk);
endclocking

property checkReqGnt;
    req ##2 gnt;
endproperty

property checkBusGrant;
    bgack |-> not ($isunknown(busgnt));
endproperty

reqGntP: assert property (checkReqGnt);
bgackP: assert property (checkBusGrant);
","""Overview of Verilog Default Clocking Block and Property Inheritance""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p229.jpg,True,"The image shows some Verilog code that is related to the declaration of recursive properties. Here are the code excerpts from the image:

First code block:
```verilog
property rll1gal;
  disable iff (b) (a and ('true |=> rll1gal));
//^^^^^^^^^^
endproperty
```
This block is annotated to indicate an error because `disable iff` cannot be used inside recursive properties.

Second code block (Solution to the restriction on `disable iff`):
```verilog
property rll1gal;
  disable iff (b) rLegal;
endproperty

property rLegal;
  a and ('true |=> rLegal);
endproperty
```
This code provides a solution for the restriction mentioned above.

Third code block (Recursive property—mutually recursive):
```verilog
`define true 1'b1
property cPhase1;
  c |-> a and ('true |=> cPhase2);
endproperty

property cPhase2;
  d |-> b and ('true |=> cPhase1);
endproperty
```
This code illustrates how recursive properties can be mutually recursive.","
property rll1gal;
  disable iff (b) (a and ('true |=> rll1gal));
//^^^^^^^^^^
endproperty


property rll1gal;
  disable iff (b) rLegal;
endproperty

property rLegal;
  a and ('true |=> rLegal);
endproperty


`define true 1'b1
property cPhase1;
  c |-> a and ('true |=> cPhase2);
endproperty

property cPhase2;
  d |-> b and ('true |=> cPhase1);
endproperty
","""Exploring the intricacies of recursive properties and mutual recursion in Verilog assertions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p77.jpg,True,"The image contains examples of Verilog code. Here are the contents:

Example 4-2:
```verilog
module dff (ck,q,d,rst_,scan_sel,scan_in);
  // parameterized module
  always @(posedge ck)
    if (rst_ == 0)
      q <= 0;
    else if (scan_sel)
      q <= scan_in;
    else
      q <= d;
endmodule // dff
```

Example 4-3:
```verilog
dff #(16) dff_a (ck, r_a, c_a, reset_, scan_sel);
dff #(16) dff_b (ck, r_b, c_b, reset_, scan_sel);
dff #(16) dff_c (ck, r_c, c_c, reset_, scan_sel);
```

Example 4-4:
```verilog
if (rst_ == 1'b0)
  r_a <= 16'h0;
else if (scan_sel)
  r_a <= dff_a.scan_in ;
else
  r_a <= c_a;
if (rst_ == 1'b0)
  r_b <= 16'h0;
else if (scan_sel)
  r_b <= dff_b.scan_in ;
else
  r_b <= c_b;
if (rst_ == 1'b0)
  r_c <= 16'h0;
else if (scan_sel)
  r_c <= dff_c.scan_in ;
else
  r_a <= c_c;
```

The above code snippets illustrate RTL (Register Transfer Level) design and optimization techniques in Verilog.","
module dff (ck,q,d,rst_,scan_sel,scan_in);
  // parameterized module
  always @(posedge ck)
    if (rst_ == 0)
      q <= 0;
    else if (scan_sel)
      q <= scan_in;
    else
      q <= d;
endmodule // dff


dff #(16) dff_a (ck, r_a, c_a, reset_, scan_sel);
dff #(16) dff_b (ck, r_b, c_b, reset_, scan_sel);
dff #(16) dff_c (ck, r_c, c_c, reset_, scan_sel);


if (rst_ == 1'b0)
  r_a <= 16'h0;
else if (scan_sel)
  r_a <= dff_a.scan_in ;
else
  r_a <= c_a;
if (rst_ == 1'b0)
  r_b <= 16'h0;
else if (scan_sel)
  r_b <= dff_b.scan_in ;
else
  r_b <= c_b;
if (rst_ == 1'b0)
  r_c <= 16'h0;
else if (scan_sel)
  r_c <= dff_c.scan_in ;
else
  r_a <= c_c;
","Caption: ""Examples of Verilog code demonstrating state element assignments with conditionals and parameterized module instantiation for RTL methodology.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p253.jpg,True,"The image contains two snippets of Verilog code. Here they are transcribed below:

First snippet (Example 7-30):
```verilog
property onehot_match;
  @(posedge clk) ($countones(set_match[3:0])<=1);
endproperty
assert property (onehot_match);
```

Second snippet (Example 7-31):
```verilog
genvar L, S;
generate for(L=0;L<=7;L= L+ 1)
  generate for (S=0;S<=3;S= S+ 1)
    cover property @(posedge clk)
      (cache_we[L] & write_set[S] & cache_fill);
  endgenerate
endgenerate
```","
property onehot_match;
  @(posedge clk) ($countones(set_match[3:0])<=1);
endproperty
assert property (onehot_match);


genvar L, S;
generate for(L=0;L<=7;L= L+ 1)
  generate for (S=0;S<=3;S= S+ 1)
    cover property @(posedge clk)
      (cache_we[L] & write_set[S] & cache_fill);
  endgenerate
endgenerate
","""Verilog code examples demonstrating assertions and functional coverage for cache operations in system design""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p247.jpg,True,"The image contains Verilog code within two examples, Example 7-22 and Example 7-23.

Here's the code from Example 7-22:

```verilog
property no_invalid_hit;
  @(posedge clk) (!valid[line_sel]) |-> !hit;
endproperty
assert property (no_invalid_hit);
```

And here's the code from Example 7-23:

```verilog
assert always {($rose(invalidate)) |=> (!$valid)};
```","
property no_invalid_hit;
  @(posedge clk) (!valid[line_sel]) |-> !hit;
endproperty
assert property (no_invalid_hit);


assert always {($rose(invalidate)) |=> (!$valid)};
","""Verilog Assertions for Cache Coherency: Ensuring Validity and Invalidation Rules""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p79.jpg,True,"Here is the Verilog code presented in the image:

```verilog
sequence sr1;
  req ##2 gnt;
endsequence

property pr1;
  @(posedge clk) cStart |-> sr1;
endproperty

reqGnt: assert property (pr1) $display($stime,,,""\t\t %% PASS""); else
  begin debugReg = 16'h 000f; end
```

The code snippet is part of a document or book that explains concurrent assertions in Verilog, which are used for formal verification in digital design. The code defines a sequence `sr1`, a property `pr1`, and an assertion `reqGnt` that uses the property. There are also comments regarding how this might be handled in FPGA emulation and different ways in which action blocks can be used with assertions.","
sequence sr1;
  req ##2 gnt;
endsequence

property pr1;
  @(posedge clk) cStart |-> sr1;
endproperty

reqGnt: assert property (pr1) $display($stime,,,""\t\t %% PASS""); else
  begin debugReg = 16'h 000f; end
","""An educational excerpt on Concurrent Assertions in Verilog, focusing on sampling edges and action blocks within assertion properties.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p539.jpg,True,"The image contains text with some code snippets related to Verilog. Here are the code excerpts included in the image:

```verilog
always_latch
    if (c) q = i;

assign q = c ? i : q;

q' <- c' ? i' : q

init q <- 0
```

Keep in mind that the snippets are given in the context of discussing checker modeling with free variables, as well as a summary of the formal verification (FV) model build of a synthesizable checker, as explained in the text surrounding the code.","
always_latch
    if (c) q = i;

assign q = c ? i : q;

q' <- c' ? i' : q

init q <- 0
","""Understanding Latch Behavior and Initialization in Verilog Code with Checker Data Model Concepts""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p170.jpg,True,"The image contains code written in Verilog syntax which is related to verification using SystemVerilog properties. Below is the code extracted from the image:

```verilog
endproperty

c_frame_path1: cover property (p_frame_path1);

property p_frame_path2;
    @(posedge clk)
    ((reset_) && (c_state == GEN_BLK_ADDR) &&
    (${past(c_state == IDLE)}) ) |-> 
    s_trans2 ##0 s_trans3;
endproperty

c_frame_path2: cover property (p_frame_path2);
```

Additionally, it lists state definitions for an FSM (Finite State Machine) represented in binary format:

```verilog
IDLE = 'b00000001
MASTER1 = 'b00000010
IDLE1 = 'b00000100
MASTER2 = 'b00001000
IDLE2 = 'b00010000
MASTER3 = 'b00100000
IDLE3 = 'b01000000
```","
endproperty

c_frame_path1: cover property (p_frame_path1);

property p_frame_path2;
    @(posedge clk)
    ((reset_) && (c_state == GEN_BLK_ADDR) &&
    (${past(c_state == IDLE)}) ) |-> 
    s_trans2 ##0 s_trans3;
endproperty

c_frame_path2: cover property (p_frame_path2);


IDLE = 'b00000001
MASTER1 = 'b00000010
IDLE1 = 'b00000100
MASTER2 = 'b00001000
IDLE2 = 'b00010000
MASTER3 = 'b00100000
IDLE3 = 'b01000000
","Caption: ""Excerpt from a document illustrating Verilog code for property specifications in a finite state machine (FSM) arbitration logic design with state encoding.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p44.jpg,True,"The image contains Verilog code. Here is the code extracted from the image:

```verilog
initial
begin
    #1 Astim = 1'b0;
    #1 Bstim = 1'b0;
    #1 Cstim = 1'b0;
    ... (other stuff) ...
    #50 Dstim = 1'b0;
    #50 $finish;
end
```

Below the code sample, there is also a definition of a Verilog module:

```verilog
module ALU (output[31:0] Z, input[15:0] A, B, input Clock, Ena);
```

Please note that the ""... (other stuff) ..."" line is not actual Verilog code; it is intended as a placeholder for additional code or commands that would be part of the actual initial block in a Verilog testbench.","
initial
begin
    #1 Astim = 1'b0;
    #1 Bstim = 1'b0;
    #1 Cstim = 1'b0;
    ... (other stuff) ...
    #50 Dstim = 1'b0;
    #50 $finish;
end


module ALU (output[31:0] Z, input[15:0] A, B, input Clock, Ena);
","Caption: ""An excerpt from a textbook on Digital VLSI Design focusing on Verilog testbench initial blocks, simulation termination commands, module header conventions, and the distinction between continuous and blocking assignment statements.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p71.jpg,True,"The image contains a snippet of Verilog code, which is as follows:

```verilog
module top();
  logic r, g;
  logic clock = 1'b0;
  always #5 clock <= !clock;
  procrReg dut(r, g, clock);
  test tb(clock, r, g);
endmodule : top
```

The code is a basic structure of a Verilog module named `top` that defines two logic signals `r` and `g`, and a clock signal that toggles every 5 time units. Additionally, there seem to be instances of `procrReg` and `test` which likely represent other modules not shown in the displayed snippet.","
module top();
  logic r, g;
  logic clock = 1'b0;
  always #5 clock <= !clock;
  procrReg dut(r, g, clock);
  test tb(clock, r, g);
endmodule : top
","Caption: Excerpt from a document detailing Verilog code for a `top` module, including a clock signal toggle, and a discussion on signal value changes ordered by regions in simulation.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p253.jpg,True,"The image contains Verilog code, here it is transcribed for you:

```verilog
class Transaction; // simple transaction
rand bit [3:0] src, dst;
endclass

class Transaction_seq;
rand Transaction items[10]; // Array of transaction handles

function new(); // Construct the sequence items
    foreach (items[i])
        items[i] = new();
endfunction // new

constraint c_ascend // Each dst addr is greater than the one before it
{
    foreach (items[i])
        if (i>0)
            items[i].dst > items[i-1].dst;
}
endclass // Transaction_seq

Transaction_seq seq;

initial begin
    seq = new(); // Construct the sequence
    `SV_RAND_CHECK(seq.randomize()); // Randomize it
    foreach (seq.items[i])
        $display(""item[%0d] = %0d"", i, seq.items[i].dst);
end
```

Please note that the `$display` function format strings are correct as per Verilog syntax, even though in some languages the `%0d` might be different (like `%d` in C/C++). The special comment `` `SV_RAND_CHECK(seq.randomize()); `` is likely a macro used within this specific Verilog context to handle errors that may arise from the `randomize` method.","
class Transaction; // simple transaction
rand bit [3:0] src, dst;
endclass

class Transaction_seq;
rand Transaction items[10]; // Array of transaction handles

function new(); // Construct the sequence items
    foreach (items[i])
        items[i] = new();
endfunction // new

constraint c_ascend // Each dst addr is greater than the one before it
{
    foreach (items[i])
        if (i>0)
            items[i].dst > items[i-1].dst;
}
endclass // Transaction_seq

Transaction_seq seq;

initial begin
    seq = new(); // Construct the sequence
    `SV_RAND_CHECK(seq.randomize()); // Randomize it
    foreach (seq.items[i])
        $display(""item[%0d] = %0d"", i, seq.items[i].dst);
end
","Caption: ""Excerpt from a document illustrating Verilog code for generating a sequence of transactions with ascending destination values using random constraints in a SystemVerilog environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p80.jpg,True,"The image contains examples of Verilog code, specifically regarding dynamic arrays in Verilog. Here are the excerpts of code found on the page:

For Sample 2.20:
```verilog
bit [7:0] mask[] = {'8b0000_0000, '8b0000_0001,
                    '8b0000_0011, '8b0000_0111,
                    '8b0000_1111, '8b0001_1111,
                    '8b0011_1111, '8b0111_1111,
                    '8b1111_1111};
```

For Sample 2.21:
```verilog
// A dynamic array of dynamic arrays
int d[][];

initial begin
    // Construct the first or left-most dimension
    d = new[4];

    // Construct the 2nd dimension, each array a different size
    foreach(d[i])
        d[i] = new[i+1];

    // Initialize the elements. d[4][2] = 42;
    foreach(d[i,j])
        d[i][j] = i*10 + j;
end
```","
bit [7:0] mask[] = {'8b0000_0000, '8b0000_0001,
                    '8b0000_0011, '8b0000_0111,
                    '8b0000_1111, '8b0001_1111,
                    '8b0011_1111, '8b0111_1111,
                    '8b1111_1111};


// A dynamic array of dynamic arrays
int d[][];

initial begin
    // Construct the first or left-most dimension
    d = new[4];

    // Construct the 2nd dimension, each array a different size
    foreach(d[i])
        d[i] = new[i+1];

    // Initialize the elements. d[4][2] = 42;
    foreach(d[i,j])
        d[i][j] = i*10 + j;
end
","""Examples of dynamic arrays and multi-dimensional dynamic arrays in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p94.jpg,True,"The image contains Verilog code snippets. Here they are:

Sample 2.40 User-defined array type
```verilog
typedef int fixed_array5_t[5];
fixed_array5_t f5;  // Equivalent to ""int f5[5]""

initial begin
  foreach (f5[i])
    f5[i] = i;
end
```

Sample 2.41 User-defined associative array index
```verilog
typedef bit[63:0] bit64_t;
bit64_t assoc[bit64_t], idx = 1;
```

Sample 2.42 Creating a single pixel type
```verilog
struct {bit [7:0] r, g, b;} pixel;
```","
typedef int fixed_array5_t[5];
fixed_array5_t f5;  // Equivalent to ""int f5[5]""

initial begin
  foreach (f5[i])
    f5[i] = i;
end


typedef bit[63:0] bit64_t;
bit64_t assoc[bit64_t], idx = 1;


struct {bit [7:0] r, g, b;} pixel;
","""Excerpt from a book chapter on Verilog data types, illustrating the definition of user-defined array types, associative array indices, and the creation of user-defined structures such as a pixel data type in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p65.jpg,True,"The image contains the following Verilog code snippets:

1. Nonblocking assignment:
```verilog
allow <= req;
```

2. Continuous assignment statement:
```verilog
assign tmp = allow && gnt1;
```

3. `always` procedure with an event control using the `posedge` (positive edge) keyword:
```verilog
always @(posedge clk) allow <= req;
```","
allow <= req;


assign tmp = allow && gnt1;


always @(posedge clk) allow <= req;
",The image shows a page of a technical document discussing the behavior of events and nonblocking assignments in Verilog code and how they are scheduled in simulation.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p247.jpg,True,"The image includes two samples of Verilog code. Here they are:

**Sample 6.57: Fourth attempt at sum constraint: bad_sum4**
```verilog
class bad_sum4;
    rand bit [9:0] len[]; // 10 bits, unsigned
    constraint c_len {len.sum() < 1024;
                      len.size() inside {[1:8]};}
endclass
```

**Sample 6.59: Simple foreach constraint: good_sum5**
```verilog
class good_sum5;
    rand uint len[];
    constraint c_len {foreach (len[i])
                      len[i] inside {[1:255]};
                      len.sum() < 1024;
                      len.size() inside {[1:8]};}
endclass
```

The text around the code explains issues with constraining array elements and how to appropriately use constraints in SystemVerilog. It also provides an output example for each of the code samples.","
class bad_sum4;
    rand bit [9:0] len[]; // 10 bits, unsigned
    constraint c_len {len.sum() < 1024;
                      len.size() inside {[1:8]};}
endclass


class good_sum5;
    rand uint len[];
    constraint c_len {foreach (len[i])
                      len[i] inside {[1:255]};
                      len.sum() < 1024;
                      len.size() inside {[1:8]};}
endclass
","Explanation and comparison of iterative constraints in Verilog, illustrating the correct way to constrain individual array elements using `foreach`.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p50.jpg,True,"The image contains a page from a digital VLSI design book about Verilog, and there's some code written in it. Here's the code from the examples section:

```verilog
reg[3:0] Nybble; reg[1:0] Bits, NewBits; reg Bit;
Nybble = 4'bxx11;
Bits = 2'b01;
Bit = 1'b0;
...
Nybble = Nybble & Bits & Bit; // --> 4'bxx11 & 4'b0001 & 4'b0000x --> 4'b000x
NewBits = Bit | Nybble; // --> 2'b0x | 2'b11 --> 2'b1x
```

More examples of bitwise operations:

```verilog
reg[3:0] a, b, z; reg y;
a = 4'b1010;
b = 4'b1100;
z = a & b; // --> z = 4'b1000
z = a | b; // --> z = 4'b1110
z = ~a; // --> z = 4'b0101
z = a ^ b; // --> z = 4'b0110
y = a & b; // --> y = 1'b0
y = a | b; // --> y = 1'b1
y = ~a; // --> y = 1'b1
y = a ^ b; // --> y = 1'b1
```","
reg[3:0] Nybble; reg[1:0] Bits, NewBits; reg Bit;
Nybble = 4'bxx11;
Bits = 2'b01;
Bit = 1'b0;
...
Nybble = Nybble & Bits & Bit; // --> 4'bxx11 & 4'b0001 & 4'b0000x --> 4'b000x
NewBits = Bit | Nybble; // --> 2'b0x | 2'b11 --> 2'b1x


reg[3:0] a, b, z; reg y;
a = 4'b1010;
b = 4'b1100;
z = a & b; // --> z = 4'b1000
z = a | b; // --> z = 4'b1110
z = ~a; // --> z = 4'b0101
z = a ^ b; // --> z = 4'b0110
y = a & b; // --> y = 1'b0
y = a | b; // --> y = 1'b1
y = ~a; // --> y = 1'b1
y = a ^ b; // --> y = 1'b1
","Caption: ""Explanation and examples of bitwise operators in Verilog, featuring operators for bitwise AND, OR, XOR, and negation, as well as their use as reduction operators.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p164.jpg,True,"The image contains a snippet of Verilog code. Here it is rewritten for your convenience:

```verilog
if(get_data)
    n_state <= GEN_BLK_ADDR;
else
    n_state <= IDLE;
end

GEN_BLK_ADDR: begin
    enable_cnt <= 1;
    rd <= 1;
    rd_addr <= {blk_cnt, addr_cnt};
    if(addr_cnt == 63) begin
        //enable_dly_cnt <= 1;
        n_state <= WAIT0;
    end
    else begin
        n_state <= GEN_BLK_ADDR;
        //pipeline_cnt <= 0;
    end
end

WAIT0: n_state <= CNTL1;
CNTL1: n_state <= WAIT1;
WAIT1: n_state <= CNT2;
CNT2: n_state <= WAIT2;
WAIT2: n_state <= CNT3;
CNT3: n_state <= WAIT3;
WAIT3: n_state <= CNT4;
CNT4: n_state <= WAIT4;
WAIT4: n_state <= CNT5;
CNT5: n_state <= WAIT5;
WAIT5: n_state <= CNT6;
CNT6: n_state <= DLY;

DLY: begin
    enable_blk_cnt <= 1;
    n_state <= NEXT_BLK;
end

NEXT_BLK: begin
    enable_blk_cnt<=1;
    if (blk_cnt == 4095)
        n_state <= IDLE;
end
```

This code appears to be a part of a finite state machine (FSM) in Verilog, with various states and transitions between them based on conditions. Some parts of the code, such as `//enable_dly_cnt <= 1;` and `//pipeline_cnt <= 0;`, are commented out.","
if(get_data)
    n_state <= GEN_BLK_ADDR;
else
    n_state <= IDLE;
end

GEN_BLK_ADDR: begin
    enable_cnt <= 1;
    rd <= 1;
    rd_addr <= {blk_cnt, addr_cnt};
    if(addr_cnt == 63) begin
        //enable_dly_cnt <= 1;
        n_state <= WAIT0;
    end
    else begin
        n_state <= GEN_BLK_ADDR;
        //pipeline_cnt <= 0;
    end
end

WAIT0: n_state <= CNTL1;
CNTL1: n_state <= WAIT1;
WAIT1: n_state <= CNT2;
CNT2: n_state <= WAIT2;
WAIT2: n_state <= CNT3;
CNT3: n_state <= WAIT3;
WAIT3: n_state <= CNT4;
CNT4: n_state <= WAIT4;
WAIT4: n_state <= CNT5;
CNT5: n_state <= WAIT5;
WAIT5: n_state <= CNT6;
CNT6: n_state <= DLY;

DLY: begin
    enable_blk_cnt <= 1;
    n_state <= NEXT_BLK;
end

NEXT_BLK: begin
    enable_blk_cnt<=1;
    if (blk_cnt == 4095)
        n_state <= IDLE;
end
",Excerpt from a book displaying a finite state machine implementation in Verilog code.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p78.jpg,True,"The image contains snippets of Verilog code. Here are the code excerpts:

Simple D flip-flop:
```verilog
always@(posedge clk1) Q <= D;
```

D flip-flop with asynchronous clear:
```verilog
always@(negedge clk1, posedge clr)
begin
    if (clr == '1'b1)
        Q <= 1'b0;
    else
        Q <= D;
end
```

D flip-flop with asynchronous preset and clear:
```verilog
always@(posedge clk2, negedge pre_n, negedge clr_n)
begin
    if (clr_n == '1'b0) Q <= 1'b0; // clear has priority over preset.
    else if (pre_n == '1'b0) Q <= 1'b1;
    else Q <= D;
end
```

Simple D latch:
```verilog
always@(D) if (enal=='1'b1) Q = D;
```

These code samples show basic implementations of D flip-flops and a D latch in Verilog HDL, including one with asynchronous clear, one with both asynchronous preset and clear, and a simple D latch.","
always@(posedge clk1) Q <= D;


always@(negedge clk1, posedge clr)
begin
    if (clr == '1'b1)
        Q <= 1'b0;
    else
        Q <= D;
end


always@(posedge clk2, negedge pre_n, negedge clr_n)
begin
    if (clr_n == '1'b0) Q <= 1'b0; // clear has priority over preset.
    else if (pre_n == '1'b0) Q <= 1'b1;
    else Q <= D;
end


always@(D) if (enal=='1'b1) Q = D;
","Caption: Examples of Verilog code for D flip-flops and D latches, illustrating different implementation techniques with asynchronous and synchronous controls.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p274.jpg,True,"The image contains Verilog code, which is as follows:

```verilog
`timescale 1ns / 100ps
module scientific_alu(result_out, exception, error,
                      a_in, b_in, opcode_in);
output [63:0] result_out;
output        exception, error;
input  [63:0] a_in, b_in;
input  [3:0]  opcode_in;

wire   [63:0] result_out, result_vector;
wire   [63:0] a_in, a_vector;
wire   [63:0] b_in, b_vector;
wire   [3:0]  opcode_in, opcode_vector;
wire           exception, error;

reg            exception_reg, error_reg;
real           a, b, result; // real variables used in this module
```","
`timescale 1ns / 100ps
module scientific_alu(result_out, exception, error,
                      a_in, b_in, opcode_in);
output [63:0] result_out;
output        exception, error;
input  [63:0] a_in, b_in;
input  [3:0]  opcode_in;

wire   [63:0] result_out, result_vector;
wire   [63:0] a_in, a_vector;
wire   [63:0] b_in, b_vector;
wire   [3:0]  opcode_in, opcode_vector;
wire           exception, error;

reg            exception_reg, error_reg;
real           a, b, result; // real variables used in this module
","""Example page from The Verilog PLI Handbook showing scientific ALU Verilog code with pin-to-pin path delays.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p263.jpg,True,"```verilog
a1: assert property (req ##1 ack[-1] |-> ready);

a2: assert property (
    (req ##1 ack[-1]) intersect [1*1:10] |-> ready);
```
The image also includes a description and discussion related to these Verilog code snippets, focusing on sequence operators in assertions, efficiency tips, and the sequence operator `throughout`.","
a1: assert property (req ##1 ack[-1] |-> ready);

a2: assert property (
    (req ##1 ack[-1]) intersect [1*1:10] |-> ready);
","Educational material on sequence operators in Verilog, featuring explanations and examples of assertions using sequence conjunction.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p59.jpg,True,"```verilog
typedef enum logic {REQ = 1'b1, ACK = 1'b0} dirType;

typedef struct packed {
    dirType rq;
    logic [6:0] id;
    logic [23:0] data;
} packetType;

program test (input logic clk, packetType received,
              output packetType sent);
    logic [6:0] sent_id;
    initial begin
        repeat (100) begin
            @(posedge clk);
            sent_id = $random;
            sent = '{REQ, sent_id, $random};
            @(posedge clk);
            a1: assert final (received.rq == ACK)
                else $error(""Corrupted packet"");
            a2: assert final (received.id == sent_id)
                else $error(""Lost packet"");
        end
    end
endprogram : test

module router (input packetType inpkt, logic clk,
               output packetType outpkt);
...
endmodule : router
module top;
    logic clk = 1'b0;
    initial repeat (400) #5 clk = !clk;
    packetType inpkt, outpkt;
    test t (.(clk(clk), .received(outpkt), .sent(inpkt));
    router r(.*);
endmodule : top
```

This code is written in Verilog, which is a hardware description language used to model electronic systems. The code example shows the use of typedef to create custom types such as an enum for direction type (dirType) and a struct for a packet type (packetType). There are also examples of SystemVerilog constructs like a test program which uses assertions to validate packet reception and a top module that instantiates the test program and a router module with clock signal manipulation. Please note that there is a syntax mistake on the instantiations' port connections in the top module definition.","
typedef enum logic {REQ = 1'b1, ACK = 1'b0} dirType;

typedef struct packed {
    dirType rq;
    logic [6:0] id;
    logic [23:0] data;
} packetType;

program test (input logic clk, packetType received,
              output packetType sent);
    logic [6:0] sent_id;
    initial begin
        repeat (100) begin
            @(posedge clk);
            sent_id = $random;
            sent = '{REQ, sent_id, $random};
            @(posedge clk);
            a1: assert final (received.rq == ACK)
                else $error(""Corrupted packet"");
            a2: assert final (received.id == sent_id)
                else $error(""Lost packet"");
        end
    end
endprogram : test

module router (input packetType inpkt, logic clk,
               output packetType outpkt);
...
endmodule : router
module top;
    logic clk = 1'b0;
    initial repeat (400) #5 clk = !clk;
    packetType inpkt, outpkt;
    test t (.(clk(clk), .received(outpkt), .sent(inpkt));
    router r(.*);
endmodule : top
",Verilog code for packet checking using assertions in a test program and description of packages in Verilog.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p388.jpg,True,"Here is the Verilog code snippet visible in the image:

```verilog
reg Notify;
...
specify
    ...
    $width(posedge Qn, tWMinQn, 0, Notify);
endspecify
// 
always @(Notify) $stop;
```

The rest of the text in the image provides context and instructions regarding the use of the code, specifically relating to simulation and timing checks in Verilog.","
reg Notify;
...
specify
    ...
    $width(posedge Qn, tWMinQn, 0, Notify);
endspecify
// 
always @(Notify) $stop;
","A page from a textbook on Digital VLSI Design with Verilog, explaining simulation steps including setup and hold, width checks, timing violations, and showing a code snippet where an 'always' block is used to terminate a simulation on a timing violation detected by the specify block.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p260.jpg,True,"```c
#include <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard input/output library */
#include ""vpi_user.h"" /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library
                          (using TF routines for simulation control) */
```","ude <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard input/output library */
#include ""vpi_user.h"" /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library
                          (using TF routines for simulation control) */
","A textbook page explaining how to create a sequential logic interface to a C model using VPI callback routine in Verilog, with an example file list for source code reference.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p277.jpg,True,"```verilog
task run_test;
    // ...
endtask : run_test

typedef enum bit [1:0] {NONE, NORMAL, SLOW, FAST} Mode;

program test(input logic clk, ready, pswitch, Mode pmode, ...);
    // ...
    sequence operational;
        @(posedge clk) pswitch && pmode == NORMAL ##1 !pswitch[*]
        ##0 ready;
    endsequence : operational
    
    initial begin
        wait(operational.triggered);
        run_test;
        $display(""Test started"");
        // ...
    end
endprogram : test

wait(command_complete.triggered || intr);
```","
task run_test;
    // ...
endtask : run_test

typedef enum bit [1:0] {NONE, NORMAL, SLOW, FAST} Mode;

program test(input logic clk, ready, pswitch, Mode pmode, ...);
    // ...
    sequence operational;
        @(posedge clk) pswitch && pmode == NORMAL ##1 !pswitch[*]
        ##0 ready;
    endsequence : operational
    
    initial begin
        wait(operational.triggered);
        run_test;
        $display(""Test started"");
        // ...
    end
endprogram : test

wait(command_complete.triggered || intr);
","Caption: ""Excerpt from a document explaining level-sensitive sequence event control in Verilog with code examples.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p71.jpg,True,"```verilog
property p23;
  @(posedge clk) $rose(start) |-> ##2 ((a ##[1:4] b)[*3]) ##2 stop;
endproperty

a23: assert property(p23);
```

This is the Verilog code extracted from the image. The code defines a property `p23` using SystemVerilog assertions (SVA) and an assertion `a23` to check this property within a simulation.","
property p23;
  @(posedge clk) $rose(start) |-> ##2 ((a ##[1:4] b)[*3]) ##2 stop;
endproperty

a23: assert property(p23);
","""Using the consecutive repetition operator in Verilog for sequence checks with a timing window.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p290.jpg,True,"The image contains an excerpt about semaphores in the context of SystemVerilog, including a sample code snippet. Here is the Verilog code from the image:

```verilog
program automatic test(bus_ifc.TB bus);
  semaphore sem; // Create a semaphore

  initial begin
    sem = new(1); // Allocate with 1 key
    fork
      sequencer(); // Spawn two threads that both
      sequencer(); // do bus transactions
    join
  end

  task sequencer();
    repeat($urandom()%10) // Random wait, 0-9 cycles
      @bus.cb;
    sendTrans(); // Execute the transaction
  endtask

  task sendTrans();
    sem.get(1);        // Get the key to the bus
    @bus.cb;           // Drive signals onto bus
    bus.cb.addr <= tr.addr;
    ...
    sem.put(1);        // Put it back when done
  endtask
endprogram
```

This code illustrates the use of semaphores to control access to a shared hardware resource within a test program.","
program automatic test(bus_ifc.TB bus);
  semaphore sem; // Create a semaphore

  initial begin
    sem = new(1); // Allocate with 1 key
    fork
      sequencer(); // Spawn two threads that both
      sequencer(); // do bus transactions
    join
  end

  task sequencer();
    repeat($urandom()%10) // Random wait, 0-9 cycles
      @bus.cb;
    sendTrans(); // Execute the transaction
  endtask

  task sendTrans();
    sem.get(1);        // Get the key to the bus
    @bus.cb;           // Drive signals onto bus
    bus.cb.addr <= tr.addr;
    ...
    sem.put(1);        // Put it back when done
  endtask
endprogram
","Caption: ""Example of Verilog code demonstrating the use of semaphores for controlling access to a shared hardware resource within a SystemVerilog testbench.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p363.jpg,True,"The image contains a page from a textbook discussing Verilog code related to path delay specifications. Here are the code excerpts included in the image:

```verilog
module FullPath (output[2:0] QBus, output Z, input A, B, C, Clock);
    // ... (functionality omitted) ...
    specify
        specparam tAll=10, tR=20, tF=21;
        (A,B,C *> QBus) = tAll;
        (Clock *> QBus) = (tR, tF);
    endspecify
endmodule
// ---------------------------------------------------------
module ParallelPath (output Z, input A, B, C, Clock);
    // ... (functionality omitted) ...
    specify
        specparam tAll=10, tR=20, tF=21;
        (Clock => Z) = tAll;
        (A => Z) = (tR, tF);
        (B => Z) = tAll;
    endspecify
endmodule
```

The text surrounding the code discusses the legality of path delay specifications and the conditions under which they can be used in Verilog, along with information on conditional and edge-dependent delays.","
module FullPath (output[2:0] QBus, output Z, input A, B, C, Clock);
    // ... (functionality omitted) ...
    specify
        specparam tAll=10, tR=20, tF=21;
        (A,B,C *> QBus) = tAll;
        (Clock *> QBus) = (tR, tF);
    endspecify
endmodule
// ---------------------------------------------------------
module ParallelPath (output Z, input A, B, C, Clock);
    // ... (functionality omitted) ...
    specify
        specparam tAll=10, tR=20, tF=21;
        (Clock => Z) = tAll;
        (A => Z) = (tR, tF);
        (B => Z) = tAll;
    endspecify
endmodule
","Caption: ""Verilog code examples for specifying path delays in digital circuits, accompanied by an explanation of path delay assignments and conditional edge-dependent delays.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p284.jpg,True,"```verilog
event e1, e2;
initial begin
    $display(""@%0t: 1: before trigger"", $time);
    -> e1;
    @e2;
    $display(""@%0t: 1: after trigger"", $time);
end

initial begin
    $display(""@%0t: 2: before trigger"", $time);
    -> e2;
    @e1;
    $display(""@%0t: 2: after trigger"", $time);
end
```","
event e1, e2;
initial begin
    $display(""@%0t: 1: before trigger"", $time);
    -> e1;
    @e2;
    $display(""@%0t: 1: after trigger"", $time);
end

initial begin
    $display(""@%0t: 2: before trigger"", $time);
    -> e2;
    @e1;
    $display(""@%0t: 2: after trigger"", $time);
end
","Caption: ""Example of blocking on the edge of an event in Verilog with corresponding output.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p377.jpg,True,"```verilog
$width(poseedge Reset, MinWid, MinWid/10);

$period(poseedge Clk, MinCycle);

$nochange(poseedge Clk, MinCycle);
```","
$width(poseedge Reset, MinWid, MinWid/10);

$period(poseedge Clk, MinCycle);

$nochange(poseedge Clk, MinCycle);
",Verilog timing checks and data check constructs.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p288.jpg,True,"The image contains some Verilog code. Here is the code presented in the image:

```verilog
sequence s1;
    @(posedge clk1) a[x+2] ##1 @(posedge clk2) b;
endsequence

sequence s2;
    @(posedge clk1) a[x+2] ##0 @(posedge clk2) b;
endsequence

sequence s3_illegal;
    @(posedge clk) a[x+2] within @(negedge clk) b[-1:];
endsequence
```

These code snippets showcase the use of Verilog sequence operators to model certain timing and synchronization behaviors within hardware description.","
sequence s1;
    @(posedge clk1) a[x+2] ##1 @(posedge clk2) b;
endsequence

sequence s2;
    @(posedge clk1) a[x+2] ##0 @(posedge clk2) b;
endsequence

sequence s3_illegal;
    @(posedge clk) a[x+2] within @(negedge clk) b[-1:];
endsequence
","Caption: ""Understanding Overlapping Suffix Implication and Synchronizers in Verilog Assertions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p93.jpg,True,"```verilog
module MyModule (output X, Y, rest of sensitivity list);
... local declarations ...
assign #5 X = Xreg; // estimated total delay = 5.
assign #7 Y = Yreg; // estimate = 7.
...
always@(posedge Clock) // A very strange flip-flop!
begin
    x1 = (a & b) ^ c; // was delayed #3
    Xreg = x1 | x2;   // was delayed #2
    Yreg = (y1 + y2); // was delayed #2
end
endmodule
```","
module MyModule (output X, Y, rest of sensitivity list);
... local declarations ...
assign #5 X = Xreg; // estimated total delay = 5.
assign #7 Y = Yreg; // estimate = 7.
...
always@(posedge Clock) // A very strange flip-flop!
begin
    x1 = (a & b) ^ c; // was delayed #3
    Xreg = x1 | x2;   // was delayed #2
    Yreg = (y1 + y2); // was delayed #2
end
endmodule
",Caption: An excerpt from an educational document discussing Verilog coding practices and providing an introduction to Design for Test (DFT) with a focus on scan lab techniques.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p439.jpg,True,"The image contains Verilog code. Here's the code transcribed from the image:

```verilog
First, we declare the following reg's for use by the tasks and by the next-state logic:

reg [Awid-1:0] ReadAr, WriteAr              // Address counter regs.
            , OldReadAr, OldWriteAr         // Saved posedge values.
            , tempAr;                       // For address-wrap compares.

The ReadAr and WriteAr also should be used on the right sides of the usual 
continuous assignments to the corresponding FIFOStateM output ports, ReadAddr and
WriteAddr. The Old* above are to retain state across calls, because we lost the 
sequencing capability which we had with the discarded (@ edge-sensitive) event controls.

After this, we may declare each new always block and its respective task. The tasks
generally have to treat FIFO empty and full states specially. Our new incrRead and
incrWrite blocks are developed first; their purpose is to replace the original and
unsynthesizedable (a proposed clk) statements in the old incrRead and incrWrite of
FIFOStateM.v.

For a register-file read, here is the always block:

always@(posedge StateClock, posedge Reset)
begin : IncrReadBlock
    if (Reset=='b1)
        ReadAr <= 'b0;
    else begin
        if (CurState==emptyS)
            ReadAr <= 'b0;
        else if (ReadCmd=='b1)
            ReadAr <= ReadAr + 1;
    end
end
```

Please note that the text at the beginning is not part of the Verilog code, and I've only transcribed the actual code snippets presented in the image.","
First, we declare the following reg's for use by the tasks and by the next-state logic:

reg [Awid-1:0] ReadAr, WriteAr              // Address counter regs.
            , OldReadAr, OldWriteAr         // Saved posedge values.
            , tempAr;                       // For address-wrap compares.

The ReadAr and WriteAr also should be used on the right sides of the usual 
continuous assignments to the corresponding FIFOStateM output ports, ReadAddr and
WriteAddr. The Old* above are to retain state across calls, because we lost the 
sequencing capability which we had with the discarded (@ edge-sensitive) event controls.

After this, we may declare each new always block and its respective task. The tasks
generally have to treat FIFO empty and full states specially. Our new incrRead and
incrWrite blocks are developed first; their purpose is to replace the original and
unsynthesizedable (a proposed clk) statements in the old incrRead and incrWrite of
FIFOStateM.v.

For a register-file read, here is the always block:

always@(posedge StateClock, posedge Reset)
begin : IncrReadBlock
    if (Reset=='b1)
        ReadAr <= 'b0;
    else begin
        if (CurState==emptyS)
            ReadAr <= 'b0;
        else if (ReadCmd=='b1)
            ReadAr <= ReadAr + 1;
    end
end
","Caption: ""Verilog code example illustrating the use of always blocks for read address state latching and handling of FIFO register empty/full states in Digital VLSI design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p438.jpg,True,"The image contains the following Verilog code:

```verilog
// Added filter:
DEL005 SM_DeGlitcher1 (.Z(StateClock), .I(StateClockRaw));
//
//synopsys dc_tcl_script_begin
// set_dont_touch SM_DeGlitcher1
// set_dont_touch StateClock*
//synopsys dc_tcl_script_end
```

This snippet of code is declaring an instance of a module named ""SM_DeGlitcher1"" with two connections: one output connected to ""StateClock"" and one input connected to ""StateClockRaw"". Additionally, there are some commented synthesis constraints for a tool (possibly Synopsys Design Compiler) to not optimize out the ""SM_DeGlitcher1"" module and not to touch the state clock signal during synthesis.","
// Added filter:
DEL005 SM_DeGlitcher1 (.Z(StateClock), .I(StateClockRaw));
//
//synopsys dc_tcl_script_begin
// set_dont_touch SM_DeGlitcher1
// set_dont_touch StateClock*
//synopsys dc_tcl_script_end
","""Verilog code snippet for glitch filtering using a delay cell, and guidance on synthesizable FIFO address-generating tasks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p289.jpg,True,"The image contains two blocks of Verilog code that define properties using SystemVerilog assertions (SVA). Here they are:

1st block:
```verilog
property p2(event ev1, ev2, bit a, b);
  @(ev1) a[*2] |=>
  (
    !a
    and
    @(ev2) b
  );
endproperty
```

2nd block:
```verilog
a7: assert property (
  @(ev1)
  if (a)
    @(ev2) b[*2]
  else
    @(ev3) c
);
```

And a variation of the second block:
```verilog
a7_v2: assert property (
  @(ev1)
  ( a |-> @(ev2) b[*2] )
  and
  ( !a |-> @(ev3) c )
);
```","
property p2(event ev1, ev2, bit a, b);
  @(ev1) a[*2] |=>
  (
    !a
    and
    @(ev2) b
  );
endproperty


a7: assert property (
  @(ev1)
  if (a)
    @(ev2) b[*2]
  else
    @(ev3) c
);


a7_v2: assert property (
  @(ev1)
  ( a |-> @(ev2) b[*2] )
  and
  ( !a |-> @(ev3) c )
);
","""Exploring logical operators and property assertions in Verilog for synchronized clock domains""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p376.jpg,True,"The image includes two snippets of what seems to be code or command examples related to Verilog timing checks:

1. For the `$recovery` check:
```verilog
$recovery(negedge Clr, posedge Clk, MinClr_Clk);
```
2. For the `$removal` check:
```verilog
$removal(negedge Clr, posedge Clk, MinClk_Clr);
```

Additionally, the text mentions that `$removal` doesn't seem to work in the Silos demo version.","
$recovery(negedge Clr, posedge Clk, MinClr_Clk);


$removal(negedge Clr, posedge Clk, MinClk_Clr);
","Caption: ""Understanding Verilog Timing Checks: setuphold, recovery, and removal constraints""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p285.jpg,True,"The image contains Verilog code. Here is the code from the image:

```verilog
event e1, e2;

initial begin
  $display(""@%0t: 1: before trigger"", $time);
  -> e1;
  wait (e2.triggered);
  $display(""@%0t: 1: after trigger"", $time);
end

initial begin
  $display(""@%0t: 2: before trigger"", $time);
  -> e2;
  wait (e1.triggered);
  $display(""@%0t: 2: after trigger"", $time);
end
```","
event e1, e2;

initial begin
  $display(""@%0t: 1: before trigger"", $time);
  -> e1;
  wait (e2.triggered);
  $display(""@%0t: 1: after trigger"", $time);
end

initial begin
  $display(""@%0t: 2: before trigger"", $time);
  -> e2;
  wait (e1.triggered);
  $display(""@%0t: 2: after trigger"", $time);
end
","Caption: ""Sample Verilog code demonstrating interprocess communication with event triggers and the resulting simulation output.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p92.jpg,True,"Here are the Verilog code blocks from the image:

First code block:
```verilog
always@(posedge Clk)
begin
    #2 X <= '1'b1;
    #2 X <= '1'b0;
    #3 Y = X;  // Ambiguous value of X used.
end
```

Second code block:
```verilog
always@(posedge Clk) #1 X = a;
always@(posedge Clk) #1 X = b;
```

Third code block:
```verilog
always@(posedge Clk)
begin
    #0 Q1 <= a;  // Likely error! Never use #0!
    #0 Q2 <= b;  // Likely error!
    ...
end
```","
always@(posedge Clk)
begin
    #2 X <= '1'b1;
    #2 X <= '1'b0;
    #3 Y = X;  // Ambiguous value of X used.
end


always@(posedge Clk) #1 X = a;
always@(posedge Clk) #1 X = b;


always@(posedge Clk)
begin
    #0 Q1 <= a;  // Likely error! Never use #0!
    #0 Q2 <= b;  // Likely error!
    ...
end
","The image shows a section from a textbook explaining certain aspects of Verilog coding practices, specifically regarding the use of nonblocking assignments to avoid race conditions and the synthesizable subset of the Verilog language.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p86.jpg,True,"```verilog
$display(""Error at time=[%0d]."", $time);
```
If the preceding `$display` is executed at simulator time 531, the displayed message will be,

```
""Error at time = [531].""
```","
$display(""Error at time=[%0d]."", $time);

 at time = [531].""
","""Excerpt from a Digital VLSI Design with Verilog textbook discussing Verilog identifiers, concurrent vs. procedural blocks, and providing an example of simulation time display code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p362.jpg,True,"Here is the Verilog code from the image:

```verilog
module ALU (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);
    ...
    specify
        specparam tRise = 5, tFall = 4;
        ...
        (Clk *> Result) = (tRise, tFall); // A simple full-path delay.
    endspecify
    ...
endmodule

specify
    specparam tRise = 2:3:4, tFall = 1:3:5;
    ...
    // other stuff; maybe complicated
    ...
    (Clk *> Qn) = (tRise, tFall);
endspecify
```

It also mentions that it is illegal in Verilog to reference a `specparam` to define the value of a parameter, but it's ok to reference a parameter to define the value of a `specparam`. Additionally, it describes different types of path delays: full-path (""*>"") and parallel-path (""=>"").","
module ALU (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);
    ...
    specify
        specparam tRise = 5, tFall = 4;
        ...
        (Clk *> Result) = (tRise, tFall); // A simple full-path delay.
    endspecify
    ...
endmodule

specify
    specparam tRise = 2:3:4, tFall = 1:3:5;
    ...
    // other stuff; maybe complicated
    ...
    (Clk *> Qn) = (tRise, tFall);
endspecify
","Caption: ""Excerpt from a textbook on Digital VLSI Design with Verilog discussing path delays, specify blocks, and the use of specparams in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p276.jpg,True,"```verilog
task run_test;
    // ...
endtask : run_test

typedef enum bit [1:0] {NONE, NORMAL, SLOW, FAST} Mode;

program test(input logic clk, ready, pswitch, Mode pmode, ...);
    // ...
    sequence operational;
        @(posedge clk) pswitch && pmode == NORMAL ##1 !pswitch[*]
        ##0 ready;
    endsequence : operational

    initial begin
        @operational;
        run_test;
        $display(""Test started"");
        // ...
    end
endprogram : test
```","
task run_test;
    // ...
endtask : run_test

typedef enum bit [1:0] {NONE, NORMAL, SLOW, FAST} Mode;

program test(input logic clk, ready, pswitch, Mode pmode, ...);
    // ...
    sequence operational;
        @(posedge clk) pswitch && pmode == NORMAL ##1 !pswitch[*]
        ##0 ready;
    endsequence : operational

    initial begin
        @operational;
        run_test;
        $display(""Test started"");
        // ...
    end
endprogram : test
","""Example of using sequence event control in Verilog test programs""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p261.jpg,True,"The image contains text and C code related to interfacing to C models using VPI routines in Verilog. Here is the code presented in the image:

```c
/* prototypes of routines in this PLI application */
int PLIbook_ScientificALU_calltf(), PLIbook_ScientificALU_compiletf();
int PLIbook_ScientificALU_interface();

/**********************************************************************/

/* VPI Registration Data */
void PLIbook_ScientificALU_register()
{
    s_vpi_systf_data tf_data;
    tf_data.type = vpiSysTask;
    tf_data.tfname = ""$scientific_alu"";
    tf_data.calltf = PLIbook_ScientificALU_calltf;
    tf_data.compiletf = PLIbook_ScientificALU_compiletf;
    tf_data.sizetf = NULL;
    tf_data.user_data = NULL;
    vpi_register_systf(&tf_data);
}

/**********************************************************************/

/* Definition for a structure to hold the data to be passed from
   calltf application to the ALU interface. */
typedef struct PLIbook_ScientificALU_data {
    vpiHandle clock_h, a_h, b_h, opcode_h, result_h, excep_h, err_h;
    PLIbook_ALU_data_s, *PLIbook_ALU_data_p;
}

/**********************************************************************/

/* Value change simulation callback routine. Serves as an interface
   between Verilog simulation and the C model. Called whenever the
   C model inputs change value, passes the values to the C model, and
   puts the C model outputs into simulation.
   
   NOTE: The handles for the arguments to scientific_alu were obtained
   in the calltf routine and saved in application-allocated memory. A
   pointer to this memory is passed to this callback via the user_data
   field.
*/
int PLIbook_ScientificALU_interface(p_cb_data cb_data)
{
    double a, b, result;
    int opcode, excep, err;
    s_vpi_value value_s;
    
    PLIbook_ALU_data_p ALUdata;
    
    /* Retrieve pointer to ALU data structure from callback user_data. */
    /* The structure contains the handles for the $scientific_alu args */
    ALUdata = (PLIbook_ALU_data_p)cb_data->user_data;
    
    /* ... [The rest of the code is not visible in the image] */
}
```

The code is incomplete due to the image not showing the entire content, and some comments indicate additional context, functionalities, or subsequent code portions that are expected but not displayed in the image.","ototypes of routines in this PLI application */
int PLIbook_ScientificALU_calltf(), PLIbook_ScientificALU_compiletf();
int PLIbook_ScientificALU_interface();

/**********************************************************************/

/* VPI Registration Data */
void PLIbook_ScientificALU_register()
{
    s_vpi_systf_data tf_data;
    tf_data.type = vpiSysTask;
    tf_data.tfname = ""$scientific_alu"";
    tf_data.calltf = PLIbook_ScientificALU_calltf;
    tf_data.compiletf = PLIbook_ScientificALU_compiletf;
    tf_data.sizetf = NULL;
    tf_data.user_data = NULL;
    vpi_register_systf(&tf_data);
}

/**********************************************************************/

/* Definition for a structure to hold the data to be passed from
   calltf application to the ALU interface. */
typedef struct PLIbook_ScientificALU_data {
    vpiHandle clock_h, a_h, b_h, opcode_h, result_h, excep_h, err_h;
    PLIbook_ALU_data_s, *PLIbook_ALU_data_p;
}

/**********************************************************************/

/* Value change simulation callback routine. Serves as an interface
   between Verilog simulation and the C model. Called whenever the
   C model inputs change value, passes the values to the C model, and
   puts the C model outputs into simulation.
   
   NOTE: The handles for the arguments to scientific_alu were obtained
   in the calltf routine and saved in application-allocated memory. A
   pointer to this memory is passed to this callback via the user_data
   field.
*/
int PLIbook_ScientificALU_interface(p_cb_data cb_data)
{
    double a, b, result;
    int opcode, excep, err;
    s_vpi_value value_s;
    
    PLIbook_ALU_data_p ALUdata;
    
    /* Retrieve pointer to ALU data structure from callback user_data. */
    /* The structure contains the handles for the $scientific_alu args */
    ALUdata = (PLIbook_ALU_data_p)cb_data->user_data;
    
    /* ... [The rest of the code is not visible in the image] */
}
","""Excerpt from a technical document detailing the use of Verilog Procedural Interface (VPI) routines for interfacing C models with Verilog simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p58.jpg,True,"```verilog
interface data (input logic clk);
logic [7:0] a, b;
logic active_a, active_b;
a_active: assert final (!(active_a && active_b))
    else $error(""a and b cannot be active simultaneously"");
endinterface : data
```","
interface data (input logic clk);
logic [7:0] a, b;
logic active_a, active_b;
a_active: assert final (!(active_a && active_b))
    else $error(""a and b cannot be active simultaneously"");
endinterface : data
","""Example of a SystemVerilog assertion in an interface to ensure mutual exclusivity of two signals, and discussion of using assertions in formal verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p70.jpg,True,"```verilog
property p22;
    @(posedge clk) $rose(start) |->
        ##2 ((a ##2 b)[*3]) ##2 stop;
endproperty

a22: assert property(p22);
```","
property p22;
    @(posedge clk) $rose(start) |->
        ##2 ((a ##2 b)[*3]) ##2 stop;
endproperty

a22: assert property(p22);
",Waveform analysis of a SystemVerilog Assertions (SVA) property checking repeated sequence patterns.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p507.jpg,True,"```verilog
module m1 (a);
    input a;
    wire a;
    ...
```

```verilog
module m1 (a);
    input [7:0] a;
    wire [7:0] a;
    ...
```","
module m1 (a);
    input a;
    wire a;
    ...


module m1 (a);
    input [7:0] a;
    wire [7:0] a;
    ...
","This image shows a page from a textbook or technical documentation detailing part of the ACC (access) Routine Library in Verilog, describing different functions for handling port connections and the types of port connections (like scalar and vector) in a hardware description.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p513.jpg,True,"```c
#include ""veriuser.h""               /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""               /* IEEE 1364 PLI ACC routine library */
/***********************************************************************
* Checktf application
***********************************************************************/
int PLIbook_ListCells_checktf()
{
    acc_initialize();
    if (tf_nump() != 1)
        tf_error(""$list_cells must have 1 argument."");
    else if (tf_typep(1) == TF_NULLPARAM)
        tf_error(""$list_cells arg cannot be null."");
    else if (acc_fetch_type(acc_handle_tfarg(1)) != accModule)
        tf_error(""$list_cells arg must be a module instance."");
    acc_close();
    return(0);
}

/***********************************************************************
* Calltf application
***********************************************************************/
int PLIbook_ListCells_calltf()
{
    handle mod_h, cell_h;
    int    cell_cnt = 0;

    acc_initialize();
    acc_configure(accDisplayWarnings, ""true"");

    mod_h = acc_handle_tfarg(1);
    io_printf(""\nCells in Module %s, instance %s:\n"",
        acc_fetch_defname(mod_h), acc_fetch_fullname(mod_h));

    cell_h = null; /* start with null (no cells found yet) */
    while (cell_h = acc_next_cell(mod_h, cell_h))
        io_printf(""  %s (%s)\n"",
            acc_fetch_fullname(cell_h), acc_fetch_defname(cell_h));

    cell_cnt++;
    io_printf(""Total cells in this hierarchy tree = %d\n\n"", cell_cnt);
    acc_close();
    return(0);
}
```","ude ""veriuser.h""               /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""               /* IEEE 1364 PLI ACC routine library */
/***********************************************************************
* Checktf application
***********************************************************************/
int PLIbook_ListCells_checktf()
{
    acc_initialize();
    if (tf_nump() != 1)
        tf_error(""$list_cells must have 1 argument."");
    else if (tf_typep(1) == TF_NULLPARAM)
        tf_error(""$list_cells arg cannot be null."");
    else if (acc_fetch_type(acc_handle_tfarg(1)) != accModule)
        tf_error(""$list_cells arg must be a module instance."");
    acc_close();
    return(0);
}

/***********************************************************************
* Calltf application
***********************************************************************/
int PLIbook_ListCells_calltf()
{
    handle mod_h, cell_h;
    int    cell_cnt = 0;

    acc_initialize();
    acc_configure(accDisplayWarnings, ""true"");

    mod_h = acc_handle_tfarg(1);
    io_printf(""\nCells in Module %s, instance %s:\n"",
        acc_fetch_defname(mod_h), acc_fetch_fullname(mod_h));

    cell_h = null; /* start with null (no cells found yet) */
    while (cell_h = acc_next_cell(mod_h, cell_h))
        io_printf(""  %s (%s)\n"",
            acc_fetch_fullname(cell_h), acc_fetch_defname(cell_h));

    cell_cnt++;
    io_printf(""Total cells in this hierarchy tree = %d\n\n"", cell_cnt);
    acc_close();
    return(0);
}
","""Verilog ACC Routine Library Example for Listing Module Cells""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p79.jpg,True,"The image contains Verilog code related to D latches with asynchronous behavior, which is as follows:

```verilog
always@(D, ena1)
  if (ena1=='b1) Q = D;

D latch with asynchronous clear and with enable asserted low:

always@(D, clr, ena_n)
  begin
    if (clr == 'b0) Q = 'b0;
    else if (ena_n=='b0) Q = D;
  end

D latch with asynchronous preset and clear asserted low:

always@(D, pre_n, clr_n, ena2)
  begin
    if (clr_n == 'b0) Q = 'b0; // clear has priority over preset.
    else if (pre_n == 'b0) Q = 'b1;
    else if (ena2 == 'b1) Q = D;
  end
```

Please note that `'b1` and `'b0` in the code are likely to be typos or incorrectly transcribed bits. In standard Verilog, binary constants are written as `1'b1` for a binary one and `1'b0` for binary zero, where the `1` before `b` specifies the number of bits in the binary constant.","
always@(D, ena1)
  if (ena1=='b1) Q = D;

D latch with asynchronous clear and with enable asserted low:

always@(D, clr, ena_n)
  begin
    if (clr == 'b0) Q = 'b0;
    else if (ena_n=='b0) Q = D;
  end

D latch with asynchronous preset and clear asserted low:

always@(D, pre_n, clr_n, ena2)
  begin
    if (clr_n == 'b0) Q = 'b0; // clear has priority over preset.
    else if (pre_n == 'b0) Q = 'b1;
    else if (ena2 == 'b1) Q = D;
  end
","""Verilog examples of D latch with asynchronous control and schematic of a serial-load shift register.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p64.jpg,True,"```verilog
Property p19;
  @(posedge clk) (c && d) |->
    ($past((a&&b), 2) == 1'b1);
endproperty

a19: assert property(p19);
```","
Property p19;
  @(posedge clk) (c && d) |->
    ($past((a&&b), 2) == 1'b1);
endproperty

a19: assert property(p19);
",Waveform illustration and description of the `$past` construct in SystemVerilog Assertions (SVA) with an example of its usage in verifying signal values from previous clock cycles.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p262.jpg,True,"```verilog
a2: assert property (start_t |=> 
  (start_t throughout (read[=2] ##1 ##1 !read) intersect 
  write[=3] ##1 !write) intersect end_t[-1]);
```
The code provided is a SystemVerilog assertion using the `assert property` construct, which is commonly used in formal verification or dynamic simulation to check if a sequence or property holds true in a design.","
a2: assert property (start_t |=> 
  (start_t throughout (read[=2] ##1 ##1 !read) intersect 
  write[=3] ##1 !write) intersect end_t[-1]);
","""Exploring Advanced Verilog Assertions with Intersect Operator for Sequence Matching""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p275.jpg,True,"```verilog
// convert real numbers to/from 64-bit vector port connections
assign result_vector = $realtobits(result);
always @(a_vector) a = $bitstoreal(a_vector);
always @(b_vector) b = $bitstoreal(b_vector);

//call the PLI application which interfaces to the C model
initial
  $scientific_alu(a, b, opcode_vector,
                  result, exception_reg, error_reg);

specify
  (a_in, b_in *> result_out, exception, error) = (5.6, 4.7);
  (opcode_in *> result_out, exception, error) = (3.4, 3.8);
endspecify

// add buffers to all ports, with nets connected to each buffer
// (this example uses the array of instance syntax in the
//  from the IEEE 1364-1995 Verilog standard
buf result_buf[63:0] (result_out, result_vector);
buf execption_buf    (exception, exception_reg);
buf error_buf        (error, error_reg);
buf a_buf[63:0]      (a_vector, a_in);
buf b_buf[63:0]      (b_vector, b_in);
buf opcode_buf[3:0]  (opcode_vector, opcode_in);

endmodule
```","
// convert real numbers to/from 64-bit vector port connections
assign result_vector = $realtobits(result);
always @(a_vector) a = $bitstoreal(a_vector);
always @(b_vector) b = $bitstoreal(b_vector);

//call the PLI application which interfaces to the C model
initial
  $scientific_alu(a, b, opcode_vector,
                  result, exception_reg, error_reg);

specify
  (a_in, b_in *> result_out, exception, error) = (5.6, 4.7);
  (opcode_in *> result_out, exception, error) = (3.4, 3.8);
endspecify

// add buffers to all ports, with nets connected to each buffer
// (this example uses the array of instance syntax in the
//  from the IEEE 1364-1995 Verilog standard
buf result_buf[63:0] (result_out, result_vector);
buf execption_buf    (exception, exception_reg);
buf error_buf        (error, error_reg);
buf a_buf[63:0]      (a_vector, a_in);
buf b_buf[63:0]      (b_vector, b_in);
buf opcode_buf[3:0]  (opcode_vector, opcode_in);

endmodule
","""Sample Verilog code demonstrating interfacing with C models using VPI routines, and handling real number conversions and buffer instantiation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p246.jpg,True,"The image shows an excerpt from a document discussing randomization in Verilog, with reference to sum constraints. Here are the two code samples displayed:

Sample 6.53:
```verilog
class bad_sum2;
  rand bit [7:0] len[]; // 8 bits unsigned, not byte
  constraint c_len {len.sum() < 1024;
                    len.size() inside {[1:8]};}
endclass
```

Sample 6.55:
```verilog
class bad_sum3;
  rand int len[]; // 32 bits
  constraint c_len {len.sum() < 1024;
                    len.size() inside {[1:8]};}
endclass
```

The rest of the text discusses the issues with the attempts made in the code samples and the results of randomization attempts using these code samples.","
class bad_sum2;
  rand bit [7:0] len[]; // 8 bits unsigned, not byte
  constraint c_len {len.sum() < 1024;
                    len.size() inside {[1:8]};}
endclass


class bad_sum3;
  rand int len[]; // 32 bits
  constraint c_len {len.sum() < 1024;
                    len.size() inside {[1:8]};}
endclass
",Verilog randomization examples with array sum constraints and issues due to integer size limitations.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p64.jpg,True,"The image contains a piece of Verilog code. Here is the code text:

```verilog
module procReq(input logic req, gnt1, gnt2, clk);
    wire tmp, proceed;
    logic allow;

    assign tmp = allow & gnt1;
    assign proceed = tmp & gnt2;
    always @(posedge clk) allow <= req;
    always @(posedge proceed) processData();
endmodule : procReq
```","
module procReq(input logic req, gnt1, gnt2, clk);
    wire tmp, proceed;
    logic allow;

    assign tmp = allow & gnt1;
    assign proceed = tmp & gnt2;
    always @(posedge clk) allow <= req;
    always @(posedge proceed) processData();
endmodule : procReq
","Caption: ""Explanation of the Verilog module 'procReq' with a focus on evaluation order and the concepts of SystemVerilog simulation semantics.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p95.jpg,True,"The image contains Verilog code, which is described below.

First code snippet:
```verilog
typedef struct {bit [7:0] r, g, b;} pixel_s;
pixel_s my_pixel;
```

Second code snippet:
```verilog
initial begin
    typedef struct {int a; byte b; shortint c; int d;} my_struct_s;
    my_struct_s st = '{32'haaaa_aaaa,
                      8'hbb,
                      16'hcccc,
                      32'hdddd_dddd};

    $display(""str = %x %x %x %x"", st.a, st.b, st.c, st.d);
end
```","
typedef struct {bit [7:0] r, g, b;} pixel_s;
pixel_s my_pixel;


initial begin
    typedef struct {int a; byte b; shortint c; int d;} my_struct_s;
    my_struct_s st = '{32'haaaa_aaaa,
                      8'hbb,
                      16'hcccc,
                      32'hdddd_dddd};

    $display(""str = %x %x %x %x"", st.a, st.b, st.c, st.d);
end
","The image displays a textbook page discussing the creation and initialization of user-defined structures in Verilog, including code examples.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p165.jpg,True,"The image does contain a snippet of code that appears to be in the Verilog hardware description language. Here is the text of the code from the image:

```verilog
else
  n_state <= GEN_BLK_ADDR;
end
```

It's a part of an `endcase` statement within a module, typically used in a state machine to assign the next state. However, the snippet is incomplete and only gives a partial view of the entire codebase.","
else
  n_state <= GEN_BLK_ADDR;
end
","""Waveform diagrams illustrating state transitions in a Verilog FSM (Finite State Machine) design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p51.jpg,True,"The image contains code in the context of Verilog, a hardware description language used for electronic design. Here is the code from the image:

```verilog
// Examples of reduction operators
z = ~b; // --> 4'b0000 (1 & 1 & 0 & 0) --> 4'b0000
z = |b; // --> 4'b0000 (1 | 1 | 0 | 0) --> 4'b0001
z = &b; // --> 4'b0000 (1 & 1 & 0 & 0) --> 4'b0000
y = ~b; // --> (1 & 1 & 0 & 0) --> 1'b0

// Assignment statements in initial block with time delays
#5 My48Bits = 'bz;
#5 My48Bits = 'bx;
#5 My48Bits = 'b0;
#5 My48Bits = 'b1;
```

The text also refers to other exercises and deliverables related to Verilog code, but the actual code for those is not shown in the image.","
// Examples of reduction operators
z = ~b; // --> 4'b0000 (1 & 1 & 0 & 0) --> 4'b0000
z = |b; // --> 4'b0000 (1 | 1 | 0 | 0) --> 4'b0001
z = &b; // --> 4'b0000 (1 & 1 & 0 & 0) --> 4'b0000
y = ~b; // --> (1 & 1 & 0 & 0) --> 1'b0

// Assignment statements in initial block with time delays
#5 My48Bits = 'bz;
#5 My48Bits = 'bx;
#5 My48Bits = 'b0;
#5 My48Bits = 'b1;
","""Verilog Operator Lab 2: Instructions on vector exercises and boolean assignments with simulation examples.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p45.jpg,True,"The image contains Verilog code which is written as follows:

```verilog
module And2 (output Z, input A, B);
reg Zreg;
// A continuous assignment connection statement:
assign Z = Zreg;            // Puts the value of Zreg on the output port.
// Procedural statements:
initial
begin
    Zreg = 1'b0;
    #2 Zreg = A && B;
    #5 $finish;
end
endmodule
```

The code snippet is an example of a Verilog module defining a simple And gate. It includes a continuous assignment statement and procedural statements inside an initial block that uses nonblocking assignments to set values over time.","
module And2 (output Z, input A, B);
reg Zreg;
// A continuous assignment connection statement:
assign Z = Zreg;            // Puts the value of Zreg on the output port.
// Procedural statements:
initial
begin
    Zreg = 1'b0;
    #2 Zreg = A && B;
    #5 $finish;
end
endmodule
","Short caption: ""Example of a Verilog module for an AND gate with a simple testbench and an explanation of Verilog operators and literals.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p538.jpg,True,"The image includes snippets of Verilog code. Here are the code excerpts presented in the image:

1.
```verilog
assign v = e;
```

2.
```verilog
assume property (@$global_clock v === e);
```

3.
```verilog
bit c, i;
bit q = 1'b0;
```

4. 
```verilog
always_latch
    if (c) q <= i;
```

5.
Alternatively, a simple latch with a blocking assignment is implied but not explicitly given in a code block. It might look similar to this:
```verilog
always_comb
    if (c) q = i;
```
However, the last example is given as a descriptive text and not formatted as a code block in the image.","
assign v = e;


assume property (@$global_clock v === e);


bit c, i;
bit q = 1'b0;


always_latch
    if (c) q <= i;


always_comb
    if (c) q = i;
","""Exploring Formal Semantics in Verilog for Continuous and Blocking Assignments with Examples.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p81.jpg,True,"Here is the Verilog code present in the image:

```verilog
int j = 1,
q2[$] = {3,4},          // Queue literals do not use '
q[$] = {0,2,3};         // {0,2,3}

initial begin
    q.insert(1, j);      // {0,1,2,3} Insert j before ele #1
    q.delete(1);         // {0,2,3}   Delete element #1

    // These operations are fast
    q.push_front(6);     // {6,0,2,3} Insert at front
    j = q.pop_back;      // {6,0,2}   j = 3
    q.push_back(8);      // {6,0,2,8} Insert at back
    j = q.pop_front;     // {0,2,8}   j = 6
    foreach (q[i])
        $display(q[i]);  //           Print entire queue
    q.delete();          // {}        Delete queue
end
```

This code snippet shows how to use queues in SystemVerilog, including initializing queues with literals, inserting and deleting elements, as well as pushing and popping elements from the front and back of the queue. It also includes an example of iterating over a queue and printing its contents, followed by deleting the entire queue.","
int j = 1,
q2[$] = {3,4},          // Queue literals do not use '
q[$] = {0,2,3};         // {0,2,3}

initial begin
    q.insert(1, j);      // {0,1,2,3} Insert j before ele #1
    q.delete(1);         // {0,2,3}   Delete element #1

    // These operations are fast
    q.push_front(6);     // {6,0,2,3} Insert at front
    j = q.pop_back;      // {6,0,2}   j = 3
    q.push_back(8);      // {6,0,2,8} Insert at back
    j = q.pop_front;     // {0,2,8}   j = 6
    foreach (q[i])
        $display(q[i]);  //           Print entire queue
    q.delete();          // {}        Delete queue
end
","Sample 2.22 from a textbook illustrating queue methods in SystemVerilog showing how to manipulate and interact with queues using insert, delete, and other methods.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p70.jpg,True,"Here is the Verilog/SystemVerilog code displayed in the image:

```verilog
module procReq (input logic req, gnt, clk);
  logic allow;
  wire proceed;
  assign proceed = allow && gnt;
  always @(posedge clk) allow <= req;
  always @(posedge proceed) processData();
  al: assert property(@(posedge clk) req |=> proceed || !gnt);
endmodule : procReq

program test(input logic sync, output logic request, grant);
  logic oldreq = 1'b0;
  assign grant = oldreq;
  initial begin
    request = 1'b0;
    for (int i = 0; i < 50; i++) begin
      @(posedge sync);
      oldreq <= request;
      request <= $random;
    end
  end
endprogram : test
```

The code represents a module `procReq` and a program block `test` in the context of SystemVerilog, illustrating aspects of simulation semantics.","
module procReq (input logic req, gnt, clk);
  logic allow;
  wire proceed;
  assign proceed = allow && gnt;
  always @(posedge clk) allow <= req;
  always @(posedge proceed) processData();
  al: assert property(@(posedge clk) req |=> proceed || !gnt);
endmodule : procReq

program test(input logic sync, output logic request, grant);
  logic oldreq = 1'b0;
  assign grant = oldreq;
  initial begin
    request = 1'b0;
    for (int i = 0; i < 50; i++) begin
      @(posedge sync);
      oldreq <= request;
      request <= $random;
    end
  end
endprogram : test
","""Explanation of Verilog simulation semantics with example code for module and program block execution.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p78.jpg,True,"The image contains Verilog SystemVerilog Assertion (SVA) code. Here's the code from the image:

```verilog
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty

regGnt: assert property (pr1) 
        $display($stime,"" "",,""%m PASS""); 
    else 
        $display($stime,"" "",,""%m FAIL"");
```

The image discusses the basics of concurrent assertions in SVA, which are temporal domain assertions that trigger properties and sequences based on clock edges. The `sequence sr1` defines a sequence that expects `req` to be followed by `gnt` exactly 2 clock cycles later. The `property pr1` defines a property that becomes true when the condition `cStart` is true at the positive edge of `clk` and then the sequence `sr1` must hold.

The last part of the code, labeled `regGnt`, is an assertion that checks the property `pr1`. If `pr1` holds true, it prints ""%m PASS"", and if it fails, it prints ""%m FAIL"", with `%m` representing the hierarchy of module names and `$stime` providing the simulation time.","
sequence sr1;
    req ##2 gnt;
endsequence

property pr1;
    @(posedge clk) cStart |-> sr1;
endproperty

regGnt: assert property (pr1) 
        $display($stime,"" "",,""%m PASS""); 
    else 
        $display($stime,"" "",,""%m FAIL"");
","""Basics of Concurrent Assertions in SystemVerilog with an example property definition and timing diagram""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p246.jpg,True,"```verilog
// for eight cache lines
assert
  forall N in (0:7) :
    always { (cache_fill && cache_we[N] & !invalidate) |=> (valid[N]) }
    @(posedge clk);
```","
// for eight cache lines
assert
  forall N in (0:7) :
    always { (cache_fill && cache_we[N] & !invalidate) |=> (valid[N]) }
    @(posedge clk);
","Caption: ""Verilog Assertions for Cache Memory Operations - Ensuring Cache Line Fill and Validity.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p174.jpg,True,"The image contains an excerpt that discusses the Verilog code, specifically about a primitive gate and a case statement. Here is the code present in the image:

```verilog
bufif1 optional_inst_name(out, in, control);

bufif1 ctlBuf01(outBit_1, inBit_1, ct1_on);

reg[3:0] Sel, xReg;
...
always@(Sel)
begin
    case (Sel[1:0])
        2'b00: xReg = 4'b0001;
        2'b01: xReg = 4'b0010;
        2'b10: xReg = 4'b0100;
        2'b11: xReg = 4'b1000;
        default: xReg = 'bx; // e.g., to handle an 'x' in Sel.
    endcase
end
```

Additionally, the text provides an explanation about the `bufif1` primitive gate and discusses best practices for the Verilog case statement, including the use of default cases to handle unassigned alternatives.","
bufif1 optional_inst_name(out, in, control);

bufif1 ctlBuf01(outBit_1, inBit_1, ct1_on);

reg[3:0] Sel, xReg;
...
always@(Sel)
begin
    case (Sel[1:0])
        2'b00: xReg = 4'b0001;
        2'b01: xReg = 4'b0010;
        2'b10: xReg = 4'b0100;
        2'b11: xReg = 4'b1000;
        default: xReg = 'bx; // e.g., to handle an 'x' in Sel.
    endcase
end
",Verilog case statement example and discussion on the bufif1 primitive gate.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p160.jpg,True,"The image contains a snippet of Verilog code. Here is the code:

```verilog
reg[3:0] CountReg;
...
always@(posedge ClockIn, posedge Clear)
begin
    if (Clear=='b1)
        CountReg <= 0;
    else 
        CountReg <= CountReg + 1;
end
```

This Verilog code defines a 4-bit register `CountReg` and uses an `always` block to describe the behavior of a counter that increments with each positive edge of the `ClockIn` signal unless the `Clear` signal is asserted, in which case the counter is reset to 0. The condition check for the `Clear` signal uses an equality check with the binary constant `'b1` (please note the symbol might be incorrectly captured and should be verified, commonly it should be `1'b1` for a one-bit binary literal with the value of 1).","
reg[3:0] CountReg;
...
always@(posedge ClockIn, posedge Clear)
begin
    if (Clear=='b1)
        CountReg <= 0;
    else 
        CountReg <= CountReg + 1;
end
","Textbook excerpt explaining behavioral modeling of a counter in Verilog, including a code snippet for a synchronous resettable counter.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p252.jpg,True,"The image contains a Verilog code fragment for a high-level set-associative cache. Here is the Verilog code present in the image:

```verilog
parameter ADDRW = 32; // number of address bits
parameter NLINES = 8; // number of lines
parameter LINE = 8; // bytes in a line
parameter logNLINS = 3; // log based 2 of N lines
parameter TAG = ADDRW-6; // address minus 3 index minus 3 offset
parameter NSETS = 4; // number of sets in a line

reg [8*LINE-1:0] cache_line [NSETS*NLINES-1:0];
reg [NSETS*TAG-1:0] cache_tag [NLINES-1:0];
reg [NSETS-1:0] valid [NLINES-1:0], n_valid[NLINES-1:0],
                 set_match, // set matched
                 set_valid, // valid bits of selected line
                 write_set; // write a set
reg [NLINES-1:0] cache_we, // write a line
                 line_sel; // hit line selector
reg hit;                   // request hit in cache
wire cache_fill;           // fill line from mem, mark valid
wire [logNLINS-1:0] fill_sel, // line to fill
                    write_sel; // store request
wire request;               // request to the cache
wire [ADDRW-1:0] addr;      // request address
wire invalidate;            // invalidate the cache

always @ (*) begin
    for (i=0;i<NLINES;i=i+1) n_valid[i] = valid[i];
    case ({write, request, cache_fill, invalidate})
        4'b1100: begin    // write or read request
            // index is a function returns index from addr for line selection
            line_sel = index(addr); // extract index
            set_valid = valid[line_sel];
            // set_hit_detect is a function returns vector for a tag match
            set_match = set_hit_detect(addr, cache_tag[line_sel])
                        & set_valid;
            hit = |set_match;            // compute hit of match
            write_hit = {WIDTH{write}} & set_match; // compute enable
            ...
        4'b0010: begin    // fill (from memory)
            n_valid = valid | cache_we; // setting a new valid
            ...
        4'b0001: begin    // invalidate all valid bits
            for(i=0;i<NLINES;i=i+1) n_valid[i] = {NSETS{1'b0}};
            ...
```

This code defines a high-level model of a cache that can handle a read or write request, fill a cache line from memory, and invalidate all valid bits depending on the control signals provided. The parameters at the top define the size and shape of the cache structure. The `reg` and `wire` declarations define memory storage and signals used in the cache operation, which are later manipulated in the `always` block that models the cache behavior based on the inputs. Please note that the code has ellipses (`...`) indicating that some parts of it have been omitted for brevity.","
parameter ADDRW = 32; // number of address bits
parameter NLINES = 8; // number of lines
parameter LINE = 8; // bytes in a line
parameter logNLINS = 3; // log based 2 of N lines
parameter TAG = ADDRW-6; // address minus 3 index minus 3 offset
parameter NSETS = 4; // number of sets in a line

reg [8*LINE-1:0] cache_line [NSETS*NLINES-1:0];
reg [NSETS*TAG-1:0] cache_tag [NLINES-1:0];
reg [NSETS-1:0] valid [NLINES-1:0], n_valid[NLINES-1:0],
                 set_match, // set matched
                 set_valid, // valid bits of selected line
                 write_set; // write a set
reg [NLINES-1:0] cache_we, // write a line
                 line_sel; // hit line selector
reg hit;                   // request hit in cache
wire cache_fill;           // fill line from mem, mark valid
wire [logNLINS-1:0] fill_sel, // line to fill
                    write_sel; // store request
wire request;               // request to the cache
wire [ADDRW-1:0] addr;      // request address
wire invalidate;            // invalidate the cache

always @ (*) begin
    for (i=0;i<NLINES;i=i+1) n_valid[i] = valid[i];
    case ({write, request, cache_fill, invalidate})
        4'b1100: begin    // write or read request
            // index is a function returns index from addr for line selection
            line_sel = index(addr); // extract index
            set_valid = valid[line_sel];
            // set_hit_detect is a function returns vector for a tag match
            set_match = set_hit_detect(addr, cache_tag[line_sel])
                        & set_valid;
            hit = |set_match;            // compute hit of match
            write_hit = {WIDTH{write}} & set_match; // compute enable
            ...
        4'b0010: begin    // fill (from memory)
            n_valid = valid | cache_we; // setting a new valid
            ...
        4'b0001: begin    // invalidate all valid bits
            for(i=0;i<NLINES;i=i+1) n_valid[i] = {NSETS{1'b0}};
            ...
",Example Verilog code segment for a high-level set-associative cache control logic.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p705.jpg,True,"The image contains explanations about Verilog VPI (Verilog Procedural Interface) tasks and function call objects, not direct code. Here is the information provided, which resembles function signatures and notes rather than executable code:

```
int vpiType           returns vpiTaskCall, vpiFuncCall, vpiSysTaskCall, 
                       vpiSysFuncCall
int vpiSysFuncType    returns true if system task/function is user-defined (a PLI
                       system task or function)
bool vpiUserDefn      returns task if the system task/function is user-defined 
                       (a PLI system task or function)
str vpiName           returns the task/function name
str vpiFile           returns the file name containing the task/function call
int vpiLineNo         returns the file line number containing the task/function call

1. vpi_get_value()    returns the current value of a function call or system function call.
2. vpi_put_value()    writes the return value of a system function call into simulation.
3. vpi_handle(vpiSysTfCall, NULL) accesses the system task/function call which
                       invoked an application.

4. The proposed IEEE 1364-1999 standard changes the names of the constants involved with
task/functions:
    • vpiSysFuncType changes to vpiFuncType — the new property will apply to both
      functions and system functions
    • vpiSysFuncInt changes to vpiIntFunc
    • vpiSysFuncTime changes to vpiTimeFunc
    • vpiSysFuncReal changes to vpiRealFunc
    • vpiSysFuncSized changes to vpiSizedFunc.
```

This text provides information on the Verilog VPI routine library and changes proposed in the IEEE 1364-1999 standard, rather than showing specific Verilog source code.","iType           returns vpiTaskCall, vpiFuncCall, vpiSysTaskCall, 
                       vpiSysFuncCall
int vpiSysFuncType    returns true if system task/function is user-defined (a PLI
                       system task or function)
bool vpiUserDefn      returns task if the system task/function is user-defined 
                       (a PLI system task or function)
str vpiName           returns the task/function name
str vpiFile           returns the file name containing the task/function call
int vpiLineNo         returns the file line number containing the task/function call

1. vpi_get_value()    returns the current value of a function call or system function call.
2. vpi_put_value()    writes the return value of a system function call into simulation.
3. vpi_handle(vpiSysTfCall, NULL) accesses the system task/function call which
                       invoked an application.

4. The proposed IEEE 1364-1999 standard changes the names of the constants involved with
task/functions:
    • vpiSysFuncType changes to vpiFuncType — the new property will apply to both
      functions and system functions
    • vpiSysFuncInt changes to vpiIntFunc
    • vpiSysFuncTime changes to vpiTimeFunc
    • vpiSysFuncReal changes to vpiRealFunc
    • vpiSysFuncSized changes to vpiSizedFunc.
","""Overview of Verilog VPI task/function call objects and routines with proposed IEEE standard changes.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p228.jpg,True,"The image contains two blocks of Verilog code. Here is the transcription of both:

The first code block:
```verilog
property rIllegal4;
  c |->
    a and ( 'true |=> not (rIllegal) );
              // ^^^
endproperty
```

The second code block:
```verilog
property rLegal;
  c |->
    a and ( 'true |-> rLegal);
            // ^^
endproperty
```","
property rIllegal4;
  c |->
    a and ( 'true |=> not (rIllegal) );
              // ^^^
endproperty


property rLegal;
  c |->
    a and ( 'true |-> rLegal);
            // ^^
endproperty
","Caption: ""Exploring Advanced Verilog Concepts on Recursive Properties and Restrictions in Verification""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p214.jpg,True,"The image contains example code written in what appears to be the context of describing scope and visibility of local variables in SystemVerilog or Verilog assertions. Here are the code snippets visible in the image:

First code snippet:
```verilog
sequence L_seq;
  int lv_data;
  (rdc, lv_data=rData);
endsequence

sequence H_seq;
  c ##1 L_seq ##1 (wData == lv_data);
endsequence
```
It is annotated with ""//ERROR :: lv_data is not visible in H_seq"", indicating an error due to the local variable `lv_data` not being visible in the sequence `H_seq`.

Second code snippet:
```verilog
sequence L_seq(Ldata);
  (rdc, Ldata=rData);
endsequence

sequence H_seq;
  int Hdata;
  c ##1 L_seq(Hdata) ##1 (wData == Hdata);
endsequence
```
There are also annotations on the snippet:
- ""NOTE:: local var Ldata is NOT declared here because it is used as a formal argument.""
- ""NOTE:: local var Hdata is declared here.""

This code demonstrates the correct way to use local variables as formal arguments to avoid scope issues.","
sequence L_seq;
  int lv_data;
  (rdc, lv_data=rData);
endsequence

sequence H_seq;
  c ##1 L_seq ##1 (wData == lv_data);
endsequence


sequence L_seq(Ldata);
  (rdc, Ldata=rData);
endsequence

sequence H_seq;
  int Hdata;
  c ##1 L_seq(Hdata) ##1 (wData == Hdata);
endsequence
","""Understanding local variable visibility in Verilog sequences.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p285.jpg,True,"The image contains Verilog code. Here it is:

```verilog
genvar R1, R2;
generate for(R1=0;R1=3;R1= R1+ 1)
  generate for (R2=0;R2=3;R2= R2 + 1)
    cover property @(posedge clk) (gnt[R1]; gnt[R2]);
  endgenerate
endgenerate
```","
genvar R1, R2;
generate for(R1=0;R1=3;R1= R1+ 1)
  generate for (R2=0;R2=3;R2= R2 + 1)
    cover property @(posedge clk) (gnt[R1]; gnt[R2]);
  endgenerate
endgenerate
","""Verilog code snippet demonstrating the use of 'generate' for creating grant transfers between requestors.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p739.jpg,True,"The image contains text related to the IEEE 1364-1995 standard for Verilog, describing certain system tasks/functions for testbench routines in the Verilog hardware description language. Although it includes function prototypes and describes their parameters, there is no executable code. Here's the text content related to these system functions:

```
int tf_strdelputp(n, length, format, value, delay, mode)
int tf_istrdelputp(n, length, format, value, delay, mode, tfinst)
    int             n
    int             length
    int             format
    char            *value
    int             delay
    int             mode
    char            *tfinst

char *tf_strgetp(n, format_char)
char *tf_strgetp(n, format_char, tfinst)
    int             n
    int             format_char
    char            *tfinst

char *tf_strgettime()
```

The descriptions provide details about the arguments these functions accept, their return values, and briefly describes what they do. For example, ""tf_strdelputp"" deposits a value to the argument 'n' of the calling or specific instance of a system task after a delay specified by the 'delay' parameter. The functions ""tf_strgetp"" and ""tf_strgettime"" are for retrieving argument values and simulation time, respectively.","_strdelputp(n, length, format, value, delay, mode)
int tf_istrdelputp(n, length, format, value, delay, mode, tfinst)
    int             n
    int             length
    int             format
    char            *value
    int             delay
    int             mode
    char            *tfinst

char *tf_strgetp(n, format_char)
char *tf_strgetp(n, format_char, tfinst)
    int             n
    int             format_char
    char            *tfinst

char *tf_strgettime()
",IEEE 1364-1995 TF Routine Library reference for Verilog simulation tasks.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p93.jpg,True,"The image contains Verilog code. Here is the written form of the code snippets seen in the image:

```verilog
module top;
  design_clocks design_clocks();
endmodule

module design_clocks;
  bit clk;
  clocking cb1 @(posedge PCL_clk);
    // clocking block contents
  endclocking
  clocking cb2 @(posedge AXI_clk);
    // clocking block contents
  endclocking
endmodule

module busModule(input logic req, gnt, bgack, busgnt, clk);
  default clocking top.design_clocks.cb1;

  property checkReqGnt;
    req ##2 gnt;
  endproperty
  
  property checkBusGrant;
    bgack |-> not ($isunknown(busgnt));
  endproperty

  reqGntP: assert property (checkReqGnt);
  bgackP: assert property (checkBusGrant);
endmodule
```

Please note that some specific contents within the clocking block may be missing as the image includes placeholders like ""// clocking block contents"" instead of the actual contents. Additionally, the actual signal names and other details would be required for this code to be functional and context-specific.","
module top;
  design_clocks design_clocks();
endmodule

module design_clocks;
  bit clk;
  clocking cb1 @(posedge PCL_clk);
    // clocking block contents
  endclocking
  clocking cb2 @(posedge AXI_clk);
    // clocking block contents
  endclocking
endmodule

module busModule(input logic req, gnt, bgack, busgnt, clk);
  default clocking top.design_clocks.cb1;

  property checkReqGnt;
    req ##2 gnt;
  endproperty
  
  property checkBusGrant;
    bgack |-> not ($isunknown(busgnt));
  endproperty

  reqGntP: assert property (checkReqGnt);
  bgackP: assert property (checkBusGrant);
endmodule
","""Exploring Pros and Cons of Default Clocking Blocks in Verilog with Example Code""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p87.jpg,True,"Here is the Verilog code found in the image:

```verilog
module eventtrig;
  event e;
  always @(posedge clk) -> e;
  a1: assert property (@e a |=> b);
endmodule
```

This snippet is demonstrating the use of named events in Verilog, where an event is triggered on the positive edge of a clock signal and is then used in the assertion of a property.","
module eventtrig;
  event e;
  always @(posedge clk) -> e;
  a1: assert property (@e a |=> b);
endmodule
","""Excerpt from a document explaining how assertions in Verilog are evaluated within simulation regions, including a sample Verilog code snippet that uses an event to trigger an assertion.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p291.jpg,True,"```verilog
default clock = (posedge clk);

property HitPendingSel5 =
  always {rose(hit) && ![pending; pending[->1]] |-> {sel5}};
assert HitPendingSel5;
```
The image contains a fragment of code in the Verilog Hardware Description Language (HDL), specifically using Property Specification Language (PSL) constructs for defining properties in HDL code.","
default clock = (posedge clk);

property HitPendingSel5 =
  always {rose(hit) && ![pending; pending[->1]] |-> {sel5}};
assert HitPendingSel5;
","""Explaining Edge-Sensitive Event Specification in PSL (Property Specification Language) for Verilog with example code and timing diagram.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p200.jpg,True,"The image contains the following Verilog code:

```verilog
//ASSUME clk0 is identical to clk1

sequence mclocks;
  @(posedge clk0) A ##1 @(posedge clk1) B;
  //Or @(posedge clk0) A ##1 @(posedge clk0) B;
endsequence
```

Below the code, there's also a notation that says:

```
If both clocks are identical then the clocking event does not change after the ##1 delay and the above sequence is equivalent to

  @(posedge clk0) A ##1 B;
```","
//ASSUME clk0 is identical to clk1

sequence mclocks;
  @(posedge clk0) A ##1 @(posedge clk1) B;
  //Or @(posedge clk0) A ##1 @(posedge clk0) B;
endsequence

h clocks are identical then the clocking event does not change after the ##1 delay and the above sequence is equivalent to

  @(posedge clk0) A ##1 B;
","Caption: ""Exploration of multiply clocked sequences in Verilog and handling of clocking events with identical clocks, including Verilog sequence code example and timing diagram.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p332.jpg,True,"The image contains Verilog code as follows:

```verilog
module division_with_check (clk, reset_n, a, b, start, done);
  input clk, reset_n;
  input [15:0] a, b;
  input start;
  output done;

  wire [15:0] q, r;

  div16 div01 (clk, reset_n, start, a, b, q, r, done);

  assert_win_unchange # (0,16) div_win_unchange_a (clk, reset_n, start, a, done);

endmodule
```","
module division_with_check (clk, reset_n, a, b, start, done);
  input clk, reset_n;
  input [15:0] a, b;
  input start;
  output done;

  wire [15:0] q, r;

  div16 div01 (clk, reset_n, start, a, b, q, r, done);

  assert_win_unchange # (0,16) div_win_unchange_a (clk, reset_n, start, a, done);

endmodule
","Caption: ""An excerpt explaining the use of the assert_win_unchange assertion in Verilog code for ensuring signal stability in multi-cycle operations, with accompanying example Verilog module.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p145.jpg,True,"```verilog
procedure ForceCover(v, w ∈ V)
  let x be the nearest common ancestor of v and w
  let π = (v0, τ0, v1) . . . (vn−1, τn−1, vn) be the unique path from x to v
  let Γ = ψ(x) · (ψ(v1) → ψ(v0)) (vn) . . . (ψ(vn) → ψ(vn−1))
  if Γ has an interpolant: A0, . . . , An+2 then
    for i = 0 . . . n:
      let φ = Ai+1
      if ψ(vi) |= φ then
        remove all pairs ( . , vi) from ≺
        set ψ(vi) ← ψ(vi) ∧ φ
```
This Verilog-style pseudocode is for a procedure titled `ForceCover`, which is part of a broader discussion on ""Lazy Abstraction with Interpolants.""","
procedure ForceCover(v, w ∈ V)
  let x be the nearest common ancestor of v and w
  let π = (v0, τ0, v1) . . . (vn−1, τn−1, vn) be the unique path from x to v
  let Γ = ψ(x) · (ψ(v1) → ψ(v0)) (vn) . . . (ψ(vn) → ψ(vn−1))
  if Γ has an interpolant: A0, . . . , An+2 then
    for i = 0 . . . n:
      let φ = Ai+1
      if ψ(vi) |= φ then
        remove all pairs ( . , vi) from ≺
        set ψ(vi) ← ψ(vi) ∧ φ
","Caption: ""Figure 6 from a technical document depicting the 'ForceCover' procedure written in pseudocode, which is part of an algorithm for lazy abstraction with interpolants in model checking.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p249.jpg,True,"The image contains the following Verilog code excerpts:

Example 9-21:
```
if (severity_level == 0) $finish;
```

Example 9-22:
```
module ck_gen (ck);
  output ck;
  reg ck;
  always #5 ck = ~ck;
  initial ck = 1'b0;
endmodule // ck_gen
```","verity_level == 0) $finish;

 ck_gen (ck);
  output ck;
  reg ck;
  always #5 ck = ~ck;
  initial ck = 1'b0;
endmodule // ck_gen
","Caption: ""Excerpt from a Verilog tutorial showcasing the usage of the $finish command and an example of a clock generator module for testbench design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p326.jpg,True,"```verilog
assert_frame #(severity_level, min_cks, max_cks, flag, options, msg) inst_name (clk, reset_n, start_event, test_expr);
```","
assert_frame #(severity_level, min_cks, max_cks, flag, options, msg) inst_name (clk, reset_n, start_event, test_expr);
","""Documentation excerpt explaining the syntax and usage of the assert_frame assertion in Verilog for synchronization of events in control circuits.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p671.jpg,True,"The image contains one line of code, which is a Unix linker command:

```
ld -o silos_pli_apps.so -dy -G *.o
```","silos_pli_apps.so -dy -G *.o
",Caption: Guide for compiling and linking PLI applications for Verilog simulation on Unix and Windows operating systems.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p100.jpg,True,"The image contains Verilog code. Here is the code excerpt from the image:

```verilog
sequence ack; @(posedge clk) enable ##[1:10] end_ack;
endsequence
a1: assert property (@(posedge clk)
    req |-> busy until ack.triggered)
else $error(""Assertion a1 fails"");

function bit f1(bit arg);
//...
endfunction
always @(posedge e1) begin: B1
    a <= b + c;
    if (c1_enb)
        a2: assert property (f1 (a) ##2 f1(a));
    dout <= f1(a);
end
```

This Verilog code defines a sequence `ack`, an assertion `a1`, and includes a function declaration `f1`, as well as an `always` block with non-blocking assignments and an assertion `a2`.","
sequence ack; @(posedge clk) enable ##[1:10] end_ack;
endsequence
a1: assert property (@(posedge clk)
    req |-> busy until ack.triggered)
else $error(""Assertion a1 fails"");

function bit f1(bit arg);
//...
endfunction
always @(posedge e1) begin: B1
    a <= b + c;
    if (c1_enb)
        a2: assert property (f1 (a) ##2 f1(a));
    dout <= f1(a);
end
","Text describing the use of sequences and assertions in Verilog for hardware verification, with examples of code snippets for defining a sequence and an assertion property.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p117.jpg,True,"Here is the code from the image:

To read a string and use it immediately:
```c
char *string_p;              /* string pointer only, no storage */
string_p = vpi_get_str(vpiName, net_handle);
vpi_printf(""string_p points to %s\n"", string_p);
```

To read a string and copy it to application-allocated storage for later use:
```c
char *string_p;              /* string pointer only, no storage */
char *string_keep;           /* another string pointer only */
string_p = vpi_get_str(vpiName, net_handle);
string_keep = malloc(strlen(string_p)+1);
strcpy(string, string_p);    /* save string for later use */
```","*string_p;              /* string pointer only, no storage */
string_p = vpi_get_str(vpiName, net_handle);
vpi_printf(""string_p points to %s\n"", string_p);

*string_p;              /* string pointer only, no storage */
char *string_keep;           /* another string pointer only */
string_p = vpi_get_str(vpiName, net_handle);
string_keep = malloc(strlen(string_p)+1);
strcpy(string, string_p);    /* save string for later use */
","Caption: ""Excerpt from a book detailing the use of the Verilog Programming Language Interface (VPI) string buffer and including examples of Verilog code for handling strings within PLI applications.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p118.jpg,True,"The image contains Verilog code. Here it is:

```verilog
task automatic bus_read(input logic [31:0] addr,
                        ref    logic [31:0] data);

  // Request bus and drive address
  bus_request <= 1'b1;
  @(posedge bus_grant) bus_addr <= addr;

  // Wait for data from memory
  @(posedge bus_enable) data <= bus_data;
  
  // Release bus and wait for grant
  bus_request <= 1'b0;
  @(negedge bus_grant);
endtask

logic [31:0] addr, data;

initial
  fork
    bus_read(addr, data);
    begin : thread2
      @data;  // Trigger on data change
      $display(""Read %h from bus"", data);
    end
  join
```

This sample Verilog code snippet defines a `bus_read` task, which is used within a parallel `fork ... join` construct to read data from a bus and display the value once it changes.","
task automatic bus_read(input logic [31:0] addr,
                        ref    logic [31:0] data);

  // Request bus and drive address
  bus_request <= 1'b1;
  @(posedge bus_grant) bus_addr <= addr;

  // Wait for data from memory
  @(posedge bus_enable) data <= bus_data;
  
  // Release bus and wait for grant
  bus_request <= 1'b0;
  @(negedge bus_grant);
endtask

logic [31:0] addr, data;

initial
  fork
    bus_read(addr, data);
    begin : thread2
      @data;  // Trigger on data change
      $display(""Read %h from bus"", data);
    end
  join
","The image shows a printed page from a technical document with a section of Verilog code, discussing the use of reference (ref) arguments in tasks to allow different threads to operate on the same data unpredictably in a simulation environment. The example illustrates a task for reading data from a bus system and how triggering on data change can be implemented in Verilog. The explanation emphasizes the difference in behavior when using 'ref' versus 'output' for the data argument in the task.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p348.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
module example;
    logic r1,r2, r3,r4,clk,clk1;
    let exDefLet = r1 || r2;

    always @ (posedge clk) begin: ablock
        let exDefLet = r1 & r2; //exDefLet has a local scope of 'ablock'
        r3=exDefLet;
    end

    always @ (posedge clk1) begin: bblock
        r4=exDefLet; // exDefLet will take the definition from the scope that is visible to it. Here
                    //it is the outer most scope definition of (r1 || r2);
    end
endmodule
```

This code provides an example of how to use the local parameterization feature ""let"" in Verilog to define expressions with a local scope.","
module example;
    logic r1,r2, r3,r4,clk,clk1;
    let exDefLet = r1 || r2;

    always @ (posedge clk) begin: ablock
        let exDefLet = r1 & r2; //exDefLet has a local scope of 'ablock'
        r3=exDefLet;
    end

    always @ (posedge clk1) begin: bblock
        r4=exDefLet; // exDefLet will take the definition from the scope that is visible to it. Here
                    //it is the outer most scope definition of (r1 || r2);
    end
endmodule
","Caption: ""Exploring 'let' declarations in Verilog for local scope parameterization along with an example code snippet.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p360.jpg,True,"The image contains a snippet of Verilog code. Here is the code extracted from the image:

```verilog
module test_checkerM;
    logic dataAck_, outputEn_, bMode;
    logic cycle_start, rst, clk;
    ...........
    
    /*Following block generates a bMode that is Low for 2 consecutive clocks. */
    sequence bMode_Sequence;
        !bMode [*2]
    endsequence
    ....................

    //Now let us call the checker 'checkerM' from a procedural block
    always @(posedge clk or negedge rst) begin
        if (!rst) begin
            dataAck_=1’b0; outputEn_=0;bMode=0;
        end
        else
            checkerM #(8) ck1 (.dack_(dataAck_), .oe_(outputEn_), .bMode(bMode), .bMode_in(bMode_Sequence) .rst(rst));
    endmodule
```

Please note that there seems to be an error in the code on the last line within the parameter list for `checkerM #(8) ck1`:
- It should have a comma after the `.bMode_in(bMode_Sequence)` argument.
- The `endmodule` keyword should be separated from the rest of the code by at least a space or a newline.

Corrected, the last few lines should look like this:

```verilog
        else
            checkerM #(8) ck1 (.dack_(dataAck_), .oe_(outputEn_), .bMode(bMode), .bMode_in(bMode_Sequence), .rst(rst));
endmodule
```

The notes at the bottom of the page discuss how the clock signal `clk` and the reset signal `rst` are handled and imply that signals can be implicitly passed to a checker without explicitly declaring them in the instantiation of the checker.","
module test_checkerM;
    logic dataAck_, outputEn_, bMode;
    logic cycle_start, rst, clk;
    ...........
    
    /*Following block generates a bMode that is Low for 2 consecutive clocks. */
    sequence bMode_Sequence;
        !bMode [*2]
    endsequence
    ....................

    //Now let us call the checker 'checkerM' from a procedural block
    always @(posedge clk or negedge rst) begin
        if (!rst) begin
            dataAck_=1’b0; outputEn_=0;bMode=0;
        end
        else
            checkerM #(8) ck1 (.dack_(dataAck_), .oe_(outputEn_), .bMode(bMode), .bMode_in(bMode_Sequence) .rst(rst));
    endmodule


        else
            checkerM #(8) ck1 (.dack_(dataAck_), .oe_(outputEn_), .bMode(bMode), .bMode_in(bMode_Sequence), .rst(rst));
endmodule
",Verilog testbench module showing the instantiation of a checker module and the usage of sequences.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p406.jpg,True,"The image contains an excerpt of Verilog code for assertion properties. Here is the code as written on the page:

```verilog
module bus_protocol_property (input bit clk, dValid, dAck, reset, input logic [7:0] data );

`ifdef check1
property checkValid;
    @(posedge clk) dValid |-> dValid; //DUMMY - REMOVE this line and code
    //correct assertion
endproperty
    assert property (checkValid) else $display($stime,,,""checkValid FAIL"");
`endif

`ifdef check2
property checkdataValid;
    @(posedge clk) disable iff (reset)
    @(posedge clk) dValid |-> dValid; //DUMMY - REMOVE this line and
    //code correct assertion
endproperty
```

Note that in the actual Verilog code, there are placeholders (""//DUMMY - REMOVE this line and code"" and ""//correct assertion"") indicating where the correct assertion should be coded. These segments are meant to be replaced with the proper assertions according to the checks described above them.","
module bus_protocol_property (input bit clk, dValid, dAck, reset, input logic [7:0] data );

`ifdef check1
property checkValid;
    @(posedge clk) dValid |-> dValid; //DUMMY - REMOVE this line and code
    //correct assertion
endproperty
    assert property (checkValid) else $display($stime,,,""checkValid FAIL"");
`endif

`ifdef check2
property checkdataValid;
    @(posedge clk) disable iff (reset)
    @(posedge clk) dValid |-> dValid; //DUMMY - REMOVE this line and
    //code correct assertion
endproperty
",An image showing a textbook page with questions and Verilog code for checking properties in a bus protocol using assertions.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p186.jpg,True,"The image contains two sections of code, one representing a C program (on the left) and the other its abstraction using predicates (on the right). Here is the code:

C program:

```c
1: int p1,p2,p3,x,y;
2: p1=p2=p3=x=y=5;
3: if(p3<=0) return;
4: if(y<0)
5:   if(x<2){
6:     if(y>10)
7:       if(p2>0){
8:         ERROR;}}
9: if(p1>0) ERROR;
10: if(else){
11:   if(p2>0) x = x+1;
12:   if(p3<=0) x = x+2;
13:   if(p3<0) x = x+3;
14:   if(x>40){
15:     if(p1>0) ERROR;
16:     if(p1>0) ERROR;}}
17: if(p1>0) ERROR;
```

Abstraction of the C program:

```c
1: bool b1,b2,b3;
2: b1=b2=b3=1;
3: if(!b3) return;
4: if(*)
5:   if(*)
6:     if(*)
7:       if(b2){
8:         ERROR;}}
9: if(b1) ERROR;
10: if else {
11:   if(b2)
12:   if(b1)
13:   if(b2)
14:   if(b3)
15:   if(*)
16:     if(b1) ERROR;
17: if(b1) ERROR;
```

The C code contains control flow statements and a label `ERROR` to denote error conditions, while the abstracted code replaces certain condition checks with the `*` character (likely representing an abstracted or non-specific condition) and uses boolean variables `b1`, `b2`, and `b3` corresponding to predicates.","t p1,p2,p3,x,y;
2: p1=p2=p3=x=y=5;
3: if(p3<=0) return;
4: if(y<0)
5:   if(x<2){
6:     if(y>10)
7:       if(p2>0){
8:         ERROR;}}
9: if(p1>0) ERROR;
10: if(else){
11:   if(p2>0) x = x+1;
12:   if(p3<=0) x = x+2;
13:   if(p3<0) x = x+3;
14:   if(x>40){
15:     if(p1>0) ERROR;
16:     if(p1>0) ERROR;}}
17: if(p1>0) ERROR;

ol b1,b2,b3;
2: b1=b2=b3=1;
3: if(!b3) return;
4: if(*)
5:   if(*)
6:     if(*)
7:       if(b2){
8:         ERROR;}}
9: if(b1) ERROR;
10: if else {
11:   if(b2)
12:   if(b1)
13:   if(b2)
14:   if(b3)
15:   if(*)
16:     if(b1) ERROR;
17: if(b1) ERROR;
","""Comparison between a C program and its abstracted version using predicate abstraction for software verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p412.jpg,True,"The image contains Verilog code. Below is the text version of the code:

```verilog
//Start the cycle (and drive Byte Enables)
@(negedge clk);
IRDY_ = 1'b0;
AD_enb=1'b0;
C_BE_ = 4'b 1111;
$display(""\n"",""\tDrive IRDY_ and Byte Enables"");

//Wait for TRDY_ to assert
@(negedge TRDY_);

//Read data received
if (! DEVSEL_) data[0] = AD;
$display(""\n"",""\tData Transfer Phase"");

//Wait for the next TRDY_ to assert
@(negedge TRDY_);

//Read data received
if (! DEVSEL_) data[1] = AD;
$display(""\n"",""\tData Transfer Phase"");

//Insert a wait state from the master
@(negedge clk);
IRDY_ = 1'b1;
$display(""\n"",""\tMaster Wait Mode"");

//Remove wait state
@(negedge clk);
if (! DEVSEL_ && !TRDY_) data[1] = AD;
//check3
`ifdef check3
IRDY_ = 1'b1;
`else
IRDY_ = 1'b0;
`endif
$display(""\n"",""\tData Transfer Phase"");

//De-assert FRAME_
@(negedge clk);
FRAME_ = 1'b1;
$display(""\n"",""\tFRAME_ De-asserted"");

//De-assert C_BE_ just to introduce bug for check#5
`ifdef check5
C_BE_ = 4'b zzzz;
`endif
```","
//Start the cycle (and drive Byte Enables)
@(negedge clk);
IRDY_ = 1'b0;
AD_enb=1'b0;
C_BE_ = 4'b 1111;
$display(""\n"",""\tDrive IRDY_ and Byte Enables"");

//Wait for TRDY_ to assert
@(negedge TRDY_);

//Read data received
if (! DEVSEL_) data[0] = AD;
$display(""\n"",""\tData Transfer Phase"");

//Wait for the next TRDY_ to assert
@(negedge TRDY_);

//Read data received
if (! DEVSEL_) data[1] = AD;
$display(""\n"",""\tData Transfer Phase"");

//Insert a wait state from the master
@(negedge clk);
IRDY_ = 1'b1;
$display(""\n"",""\tMaster Wait Mode"");

//Remove wait state
@(negedge clk);
if (! DEVSEL_ && !TRDY_) data[1] = AD;
//check3
`ifdef check3
IRDY_ = 1'b1;
`else
IRDY_ = 1'b0;
`endif
$display(""\n"",""\tData Transfer Phase"");

//De-assert FRAME_
@(negedge clk);
FRAME_ = 1'b1;
$display(""\n"",""\tFRAME_ De-asserted"");

//De-assert C_BE_ just to introduce bug for check#5
`ifdef check5
C_BE_ = 4'b zzzz;
`endif
","""Verilog simulation code snippet demonstrating a data transfer process with wait states and conditional compilation.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p124.jpg,True,"The image shows text including three pieces of Verilog code. Here is the Verilog code from the image:

1. Buggy version with static initialization bug:
```verilog
program initialization; // Buggy version

task check_bus();
    repeat (5) @(posedge clock);
    if (bus_cmd === READ) begin
        // When is local_addr initialized?
        logic [7:0] local_addr = addr<<2; // Bug
        $display(""Local Addr = %h"", local_addr);
    end
endtask

endprogram
```

2. Static initialization fix using `automatic`:
```verilog
program automatic initialization; // Bug solved
...
endprogram
```

3. Static initialization fix by separating declaration and initialization:
```verilog
logic [7:0] local_addr;
local_addr = addr << 2; // Bug solved
```","
program initialization; // Buggy version

task check_bus();
    repeat (5) @(posedge clock);
    if (bus_cmd === READ) begin
        // When is local_addr initialized?
        logic [7:0] local_addr = addr<<2; // Bug
        $display(""Local Addr = %h"", local_addr);
    end
endtask

endprogram


program automatic initialization; // Bug solved
...
endprogram


logic [7:0] local_addr;
local_addr = addr << 2; // Bug solved
","Caption: ""Exploring a static initialization bug in Verilog and its solution by using the 'automatic' storage class to correctly initialize a variable at runtime.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p207.jpg,True,"Here is the Verilog code present in the image:

```verilog
integer i=0, j=0;
integer blk=0;
integer fd, fdl;

logic [31:0] pix_in_temp;
logic [15:0] local_array[0:63];
logic [15:0] pix_in [0:262143];

// use $fopen construct to open the golden
// results file

initial
begin
  fd = $fopen(data_file, ""r"");
end

// copy design data to a local array

always@(*)
begin
  local_array[0] <= d1;
  local_array[1] <= d2;
  local_array[2] <= d3;
  ...
  local_array[62] <= d63;
  local_array[63] <= d64;
end

// load actual results

always@(negedge enable)
begin
  if(reset)
  $display
  (""\nDATA CHECKING: Block number %0d\n"", blk);
  for(j=0; j<64; j++)
  begin
    fdl = $fscanf(fd, "" %x"", pix_in[j]);
  end
  blk++;
end
```

Please note that there are ellipsis (...) used in the 'copy design data to a local array' always block, which suggests that the lines of code between 'local_array[2] <= d3;' and 'local_array[62] <= d63;' are not displayed and should be a continuation in the same pattern.","
integer i=0, j=0;
integer blk=0;
integer fd, fdl;

logic [31:0] pix_in_temp;
logic [15:0] local_array[0:63];
logic [15:0] pix_in [0:262143];

// use $fopen construct to open the golden
// results file

initial
begin
  fd = $fopen(data_file, ""r"");
end

// copy design data to a local array

always@(*)
begin
  local_array[0] <= d1;
  local_array[1] <= d2;
  local_array[2] <= d3;
  ...
  local_array[62] <= d63;
  local_array[63] <= d64;
end

// load actual results

always@(negedge enable)
begin
  if(reset)
  $display
  (""\nDATA CHECKING: Block number %0d\n"", blk);
  for(j=0; j<64; j++)
  begin
    fdl = $fscanf(fd, "" %x"", pix_in[j]);
  end
  blk++;
end
",Verilog code snippet showing file I/O and array usage for data-intensive design verification.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p128.jpg,True,"The image contains Verilog code associated with a discussion on bit-select and part-select operations in Verilog. Here is the code presented in the image:

```verilog
parameter MSB = 31;

logic signed [MSB:0] a, b; // signed vectors
logic signed [MSB:0] sum1, sum2; // signed vectors
logic signed [ 7:0] sum3; // 8-bit signed vector

assign sum1 = a + b; // OK, signed adder

assign sum2 = a[MSB:0] + b[MSB:0]; // GOTCHA! unsigned adder

assign sum3 = {a[MSB],a[6:0]} + {b[MSB],b[6:0]}; // GOTCHA!
                                                      // unsigned adder
```

And the code for the ""How to avoid this Gotcha"" section:

```verilog
assign sum2 = $signed(a[MSB:0]) + $signed(b[MSB:0]);

assign sum3 = signed'({a[MSB],a[6:0]}) + signed'({b[MSB],b[6:0]});
```

Please note this code is part of a discussion on certain ""gotchas"" in Verilog related to signedness during bit-selection and part-selection operations; the comments accompanying the code express that certain lines result in unsigned addition, which is unintended in this context.","
parameter MSB = 31;

logic signed [MSB:0] a, b; // signed vectors
logic signed [MSB:0] sum1, sum2; // signed vectors
logic signed [ 7:0] sum3; // 8-bit signed vector

assign sum1 = a + b; // OK, signed adder

assign sum2 = a[MSB:0] + b[MSB:0]; // GOTCHA! unsigned adder

assign sum3 = {a[MSB],a[6:0]} + {b[MSB],b[6:0]}; // GOTCHA!
                                                      // unsigned adder


assign sum2 = $signed(a[MSB:0]) + $signed(b[MSB:0]);

assign sum3 = signed'({a[MSB],a[6:0]}) + signed'({b[MSB],b[6:0]});
","""Understanding Verilog's bit-select and part-select operations: caution with signed vectors and potential gotchas""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p189.jpg,True,"```verilog
x ##2 y |-> a ##2 b;

x ##2 y implies a ##2 b;
```

The image contains two lines of code written in Verilog, demonstrating the use of the implication operator `|->` and the `implies` keyword.","
x ##2 y |-> a ##2 b;

x ##2 y implies a ##2 b;
","""Understanding the 'implies' operator in Verilog with examples""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p114.jpg,True,"The image contains Verilog code. Here it is:

```verilog
package sig_defs;
  logic [31:0] result, pipe;
endpackage

module blk1 (output logic [31:0] d_out,
             input  logic [31:0] a, b,
             input  logic        clk, rstn);

  import sig_defs::*;

  always @*
    result = a & b;  // GOTCHA! shared variable

  always @(posedge clk or negedge rstn)
    if (!rstn) begin
      pipe <= 0;
      d_out <= 0;
    end
    else begin
      pipe <= result;  // GOTCHA! shared variables
      d_out <= pipe;
    end
endmodule
```","
package sig_defs;
  logic [31:0] result, pipe;
endpackage

module blk1 (output logic [31:0] d_out,
             input  logic [31:0] a, b,
             input  logic        clk, rstn);

  import sig_defs::*;

  always @*
    result = a & b;  // GOTCHA! shared variable

  always @(posedge clk or negedge rstn)
    if (!rstn) begin
      pipe <= 0;
      d_out <= 0;
    end
    else begin
      pipe <= result;  // GOTCHA! shared variables
      d_out <= pipe;
    end
endmodule
","Caption: ""Discussion of shared variable conflicts in SystemVerilog with an example code snippet highlighting the issue.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p202.jpg,True,"The image contains snippets of Verilog code along with some explanatory text. Here are the code excerpts:

The definition of the `localparam` with different patterns:
```verilog
...
localparam[PadHi:0] pad_00 = 8'b000_00_000;
localparam[PadHi:0] pad_01 = 8'b000_01_000;
localparam[PadHi:0] pad_10 = 8'b000_10_000;
localparam[PadHi:0] pad_11 = 8'b000_11_000;
...
```

The function `checkPad` being called within an `if` statement:
```verilog
...
if (
    checkPad(Stream, pad_11, Offset-(1*PadWid))
    && checkPad(Stream, pad_10, Offset-(3*PadWid))
    && checkPad(Stream, pad_01, Offset-(5*PadWid))
    && checkPad(Stream, pad_00, Offset-(7*PadWid))
)
    FoundPads = 1;
else
    FoundPads = 0;
...
```

Please note that the excerpts might be a part of a larger piece of code and cannot be compiled or used as is. Additionally, the document appears to discuss some concepts regarding Verilog, which is a hardware description language commonly used for designing and modeling electronic systems.","
...
localparam[PadHi:0] pad_00 = 8'b000_00_000;
localparam[PadHi:0] pad_01 = 8'b000_01_000;
localparam[PadHi:0] pad_10 = 8'b000_10_000;
localparam[PadHi:0] pad_11 = 8'b000_11_000;
...


...
if (
    checkPad(Stream, pad_11, Offset-(1*PadWid))
    && checkPad(Stream, pad_10, Offset-(3*PadWid))
    && checkPad(Stream, pad_01, Offset-(5*PadWid))
    && checkPad(Stream, pad_00, Offset-(7*PadWid))
)
    FoundPads = 1;
else
    FoundPads = 0;
...
","Caption: ""Explanation of Verilog function declarations and usage with an example of code for checking pad-byte patterns in a Digital VLSI Design context.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p421.jpg,True,"The image contains a code snippet that defines Ackermann's function. Here is the code from the image:

```verilog
define ack(x, y):
    if (not(intp(x)) or x <= 0) then 1
    else if (not(intp(y)) or y <= 0) then 2
    else ack(ack(x-1, y), y-1)
```

Please note that although the code is given a Verilog syntax highlighting, the actual function definition seems to be pseudo-code or is written in a different programming language, not Verilog. Verilog is a hardware description language used to model electronic systems, and the syntax for Verilog does not match the given code snippet.","
define ack(x, y):
    if (not(intp(x)) or x <= 0) then 1
    else if (not(intp(y)) or y <= 0) then 2
    else ack(ack(x-1, y), y-1)
","Caption: ""Academic document detailing termination analysis concepts, including a Calling Context Graph (CCG) for Ackermann's function, with an associated pseudocode implementation of Ackermann's function in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p34.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
// following declaration is in $unit
typedef enum logic [1:0] {RESET, HOLD, LOAD, READY} states_t;

module chip (...);
...
$unit::states_t state_e, nstate_e; // OK: definition in $unit
```

This code is part of a discussion on single file versus multi-file compilation of $unit declarations in Verilog.","
// following declaration is in $unit
typedef enum logic [1:0] {RESET, HOLD, LOAD, READY} states_t;

module chip (...);
...
$unit::states_t state_e, nstate_e; // OK: definition in $unit
","""Understanding the Gotchas of Single vs Multi-File Compilation of `$unit` Declarations in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p130.jpg,True,"The image contains Verilog code within an instructional text. Here is the code presented in the image:

```verilog
/************************************************/
/* checktf routine to validate arguments       */
/************************************************/
int assert_always_checktf(char *user_data) 
{
    if (tf_nump() != 1)
        tf_error(""$assert_always only 1 argument."");
    else if (tf_sizep(1) != 1)
        tf_error(""$assert_always argument size!=1"");
    return (0);
}

/************************************************/
/* calltf routine to schedule callback          */
/************************************************/
int assert_always_calltf(char *user_data)
{
    tf_rosynchronize();
    return (0);
}

/************************************************/
/* misctf routine to check assertion            */
/************************************************/
int assert_always_misctf(char *user_data, int reason, int paramvc)
{
    if (reason != REASON_ROSYNCH)
        return(0);

    /* read current value */
    if (tf_getp(1) == 0) {
        io_printf(""ASSERT ALWAYS ERROR at %s:%s\n"", 
                  tf_strgettime(), tf_spname());
        tf_dofinish(); /* stop simulation */
    }
    return (0); 
}
```

This code appears to be used as an example to explain implementation details regarding the simulation of Verilog hardware description language (HDL) using procedural interface routines, such as `checktf`, `calltf`, and `misctf`. These routines are part of the programming language interface (PLI) used to customize and extend the capabilities of Verilog simulators.","
/************************************************/
/* checktf routine to validate arguments       */
/************************************************/
int assert_always_checktf(char *user_data) 
{
    if (tf_nump() != 1)
        tf_error(""$assert_always only 1 argument."");
    else if (tf_sizep(1) != 1)
        tf_error(""$assert_always argument size!=1"");
    return (0);
}

/************************************************/
/* calltf routine to schedule callback          */
/************************************************/
int assert_always_calltf(char *user_data)
{
    tf_rosynchronize();
    return (0);
}

/************************************************/
/* misctf routine to check assertion            */
/************************************************/
int assert_always_misctf(char *user_data, int reason, int paramvc)
{
    if (reason != REASON_ROSYNCH)
        return(0);

    /* read current value */
    if (tf_getp(1) == 0) {
        io_printf(""ASSERT ALWAYS ERROR at %s:%s\n"", 
                  tf_strgettime(), tf_spname());
        tf_dofinish(); /* stop simulation */
    }
    return (0); 
}
","""Verilog PLI routine for assertion check with callback scheduling to prevent false positives in simulation""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p498.jpg,True,"```verilog
port_h = null; /* initialize the target handle for null */
while ( port_h = acc_next_port(mod_h, port_h) ) {
    /* perform desired operations on the port handle */
}
```","
port_h = null; /* initialize the target handle for null */
while ( port_h = acc_next_port(mod_h, port_h) ) {
    /* perform desired operations on the port handle */
}
","""Understanding the use of ACC (Access) routines in Verilog PLI for handling objects and traversing module ports.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p216.jpg,True,"Here is the Verilog code present in the image:

```verilog
always@(ReadReq, WriteReq, CurState, Clk) // NOTE: Request, not Register.
if (Clk=='b0) // Only read after a negedge of clock.
    begin
        case (CurState)
            empty: // Combines reset unique conditions 
                // with a simple empty state during operation:
                begin
                if (Reset=='b1)
                    begin
                        // Reset conditions:
                        FullFltFQReg = '1'b0; // Clear full flag.
                        WriteCount  = 'b0;
                        WriteCmdReg = '1'b0;
                        ReadCmdReg  = '1'b0;
                        NextState   = empty;
                    end
                // 
                // Generic empty conditions:
                EmptyFltFQReg = '1'b1; // Set empty flag.
                ReadCmdReg    = '1'b0; // Disable RAM read.
                // One transition rule:
                if (WriteReq=='b1"" && ReadReq=='b0)
                    begin
                        ReadCount   = WriteCount; // Could also init to Adr 0.
                        incrWrite;  // Call task, which blocks on posedge Clk.
                        WriteCmdReg = '1'b1; // Issue a RAM write.
                        EmptyFltFQReg = '1'b0; // Clear empty flag.
                        NextState   = a_empty;
                    end
                else ReadCount = 'bz; // Nowhere.
                end // empty state.
            a_empty: begin
                ...
                end // a_empty state.
            normal: begin
                ...
                end // normal state.
            a_full: begin
                ...
                end // a_full state.
            full: begin
                ...
                end // full state.
            default: NextState = empty; // Always handle the unexpected!
        endcase
    end // always.
```

Please note that the above code might have minor errors or omissions due to the image quality, such as the inconsistent use of quotation marks in `if (WriteReq=='b1"" && ReadReq=='b0)`, which should probably be `if (WriteReq=='b1' && ReadReq=='b0')`. Additionally, the ellipsis (`...`) indicates that the original code was not fully shown in those sections.","
always@(ReadReq, WriteReq, CurState, Clk) // NOTE: Request, not Register.
if (Clk=='b0) // Only read after a negedge of clock.
    begin
        case (CurState)
            empty: // Combines reset unique conditions 
                // with a simple empty state during operation:
                begin
                if (Reset=='b1)
                    begin
                        // Reset conditions:
                        FullFltFQReg = '1'b0; // Clear full flag.
                        WriteCount  = 'b0;
                        WriteCmdReg = '1'b0;
                        ReadCmdReg  = '1'b0;
                        NextState   = empty;
                    end
                // 
                // Generic empty conditions:
                EmptyFltFQReg = '1'b1; // Set empty flag.
                ReadCmdReg    = '1'b0; // Disable RAM read.
                // One transition rule:
                if (WriteReq=='b1"" && ReadReq=='b0)
                    begin
                        ReadCount   = WriteCount; // Could also init to Adr 0.
                        incrWrite;  // Call task, which blocks on posedge Clk.
                        WriteCmdReg = '1'b1; // Issue a RAM write.
                        EmptyFltFQReg = '1'b0; // Clear empty flag.
                        NextState   = a_empty;
                    end
                else ReadCount = 'bz; // Nowhere.
                end // empty state.
            a_empty: begin
                ...
                end // a_empty state.
            normal: begin
                ...
                end // normal state.
            a_full: begin
                ...
                end // a_full state.
            full: begin
                ...
                end // full state.
            default: NextState = empty; // Always handle the unexpected!
        endcase
    end // always.
","Partial Verilog code sample for a state machine, highlighting potential sensitivity list issue.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p100.jpg,True,"The image contains Verilog code. Here is the code transcribed from the image:

```verilog
module chip_tb;
logic clk;               // 4-state type
bit rst_n;               // GOTCHA! 2-state type for reset

initial begin            // clock oscillator
  clk <= 0;
  forever #5ns clk = ~clk;
end

initial begin            // reset stimulus (active low reset)
  rst_n <= 0;            // turn on reset at time zero
  #3ns rst_n = 1;        // turn off reset after 3 nanoseconds
end

chip u1(.rst_n, .clk, ...); // instance of design under test

endmodule: chip_tb

module chip (input bit rst_n, clk, ...); // GOTCHA! 2-state types

enum {HOLD, LOAD, STORE} state_e, nstate_e; // GOTCHA! 2-state

always_ff @(posedge clk, negedge rst_n) // asynchronous reset
  if (!rst_n) state_e <= HOLD;
  else        state_e <= nstate_e;
...
endmodule: chip
```

The code snippet is used to illustrate a ""Gotcha"" with resetting 2-state models in Verilog and SystemVerilog simulations.","
module chip_tb;
logic clk;               // 4-state type
bit rst_n;               // GOTCHA! 2-state type for reset

initial begin            // clock oscillator
  clk <= 0;
  forever #5ns clk = ~clk;
end

initial begin            // reset stimulus (active low reset)
  rst_n <= 0;            // turn on reset at time zero
  #3ns rst_n = 1;        // turn off reset after 3 nanoseconds
end

chip u1(.rst_n, .clk, ...); // instance of design under test

endmodule: chip_tb

module chip (input bit rst_n, clk, ...); // GOTCHA! 2-state types

enum {HOLD, LOAD, STORE} state_e, nstate_e; // GOTCHA! 2-state

always_ff @(posedge clk, negedge rst_n) // asynchronous reset
  if (!rst_n) state_e <= HOLD;
  else        state_e <= nstate_e;
...
endmodule: chip
","Caption: A page from ""Verilog and SystemVerilog Gotchas"" discussing the potential issue with resetting 2-state models in Verilog/SystemVerilog simulations, including code examples.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p468.jpg,True,"The image contains an excerpt of Verilog/SystemVerilog code intermixed with C++ interfacing, as part of a sample testbench for a C++ model. Here is the code present in the image:

```verilog
import ""DPI-C"" function chandle counter7_new();
import ""DPI-C"" function void counter7_count(input chandle inst);
import ""DPI-C"" function void counter7_load(input chandle inst, input bit [6:0] i);
import ""DPI-C"" function void counter7_reset(input chandle inst);
import ""DPI-C"" function int counter7_get(input chandle inst);

// Wrap the static C static wrapper functions with a
// SystemVerilog class to hide the C++ instance handle
class Counter7;
    chandle inst;

    function new();
        inst = counter7_new();
    endfunction

    function void count();
        counter7_count(inst);
    endfunction
    
    function void load(input bit [6:0] val);
        counter7_load(inst, val);
    endfunction
    
    function void reset();
        counter7_reset(inst);
    endfunction
    
    function bit [6:0] get();
        return counter7_get(inst);
    endfunction

endclass : Counter7

program automatic test;
    Counter7 c1;

    initial begin
        c1 = new;
        
        c1.reset();
        $display(""SV: Post reset: counter1=%0d"", c1.get());
        
        c1.load(126);
        if (c1.get() == 126)
            $display(""Successful load"");
        else
            $display(""Error: load, expect 126, got %0d"", c1.get());
```

The code snippet finishes abruptly, and it's not clear if there is more code following what is shown in the image. The code demonstrates using the Direct Programming Interface (DPI) to call C++ functions from SystemVerilog, wrapping them in a SystemVerilog class for easier use within a SystemVerilog testbench.","
import ""DPI-C"" function chandle counter7_new();
import ""DPI-C"" function void counter7_count(input chandle inst);
import ""DPI-C"" function void counter7_load(input chandle inst, input bit [6:0] i);
import ""DPI-C"" function void counter7_reset(input chandle inst);
import ""DPI-C"" function int counter7_get(input chandle inst);

// Wrap the static C static wrapper functions with a
// SystemVerilog class to hide the C++ instance handle
class Counter7;
    chandle inst;

    function new();
        inst = counter7_new();
    endfunction

    function void count();
        counter7_count(inst);
    endfunction
    
    function void load(input bit [6:0] val);
        counter7_load(inst, val);
    endfunction
    
    function void reset();
        counter7_reset(inst);
    endfunction
    
    function bit [6:0] get();
        return counter7_get(inst);
    endfunction

endclass : Counter7

program automatic test;
    Counter7 c1;

    initial begin
        c1 = new;
        
        c1.reset();
        $display(""SV: Post reset: counter1=%0d"", c1.get());
        
        c1.load(126);
        if (c1.get() == 126)
            $display(""Successful load"");
        else
            $display(""Error: load, expect 126, got %0d"", c1.get());
",Verilog code showing a testbench for interfacing with a C++ model using Direct Programming Interface (DPI-C) methods.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p473.jpg,True,"The image contains a snippet of Verilog code in a simulation environment. Here is the code:

```verilog
#10 test = 3'b001;

#10 $show_all_nets(top);
#10 $show_all_nets(t1);

#10 $stop;
#10 $finish;

endmodule
```

This code seems to be a part of a simulation testbench used to show all nets within the specified modules (`top` and `t1`) at respective simulation times, followed by calls to `$stop` and `$finish`, which are used for controlling the simulation run. However, due to the limited context, the functionality of the custom tasks `$show_all_nets`, and the exact design under test, cannot be fully discerned only from this snippet.","
#10 test = 3'b001;

#10 $show_all_nets(top);
#10 $show_all_nets(t1);

#10 $stop;
#10 $finish;

endmodule
","Caption: ""Example of a Verilog simulation using Verilog-XL and an excerpt explaining the handling of register and variable data types in Verilog HDL.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p467.jpg,True,"```c
handle tfarg_handle;
tfarg_handle = acc_handle_tfarg(1);
if (acc_fetch_type(tfarg_handle) != accModule)
    /* report error that argument is not correct */

int acc_fetch_fulltype(object)
handle object; /* handle for an object. */

char *acc_fetch_type_str(type)
int type; /* type or fulltype constant. */

int object_type;
object_type = acc_fetch_type(tfarg_handle);
if (object_type != accModule) {
    tf_error(""tfarg type of %s is illegal.\n"",
             acc_fetch_type_str(object_type));
}
```","e tfarg_handle;
tfarg_handle = acc_handle_tfarg(1);
if (acc_fetch_type(tfarg_handle) != accModule)
    /* report error that argument is not correct */

int acc_fetch_fulltype(object)
handle object; /* handle for an object. */

char *acc_fetch_type_str(type)
int type; /* type or fulltype constant. */

int object_type;
object_type = acc_fetch_type(tfarg_handle);
if (object_type != accModule) {
    tf_error(""tfarg type of %s is illegal.\n"",
             acc_fetch_type_str(object_type));
}
","A page from a technical document describing ACC (Application Compiler Constructs) routines in Verilog, with examples for fetching and reporting object types and fulltypes.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p301.jpg,True,"```verilog
always @(posedge clock)
begin
    result <= $pow(x,y);
    ...
end
```","
always @(posedge clock)
begin
    result <= $pow(x,y);
    ...
end
","Flowchart and tips for using the checktf routine in Verilog simulations to improve performance by verifying arguments only once prior to simulation, shown alongside a snippet of Verilog code utilizing a system task/function.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p316.jpg,True,"```verilog
a_accept_reject: assert property(
    @(posedge clk)
        accept_on (retry)
        a |=> reject_on(bad) b[∗2]
    ) else $error(""FAIL"");
```","
a_accept_reject: assert property(
    @(posedge clk)
        accept_on (retry)
        a |=> reject_on(bad) b[∗2]
    ) else $error(""FAIL"");
","""Example of a concurrent assertion in Verilog using nested asynchronous aborts with corresponding waveform diagram.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p332.jpg,True,"The image contains code from a book or document that describes copying an object in the context of Verilog/SystemVerilog. Here are the two code samples provided:

Sample 8.20:
```verilog
class Transaction;
  rand bit [31:0] src, dst, data[8]; // Variables
  bit [31:0] csm;
  
  virtual function Transaction copy();
    Transaction copy;
    copy = new(); // Construct destination object
    copy.src = this.src; // Copy data fields
    copy.dst = this.dst; // The prefix ""this."" is
    copy.data = this.data; // not needed, but makes code
    copy.csm = this.csm; // more explicit
    return copy; // Return handle to copy
  endfunction
endclass
```

Sample 8.21:
```verilog
class BadTr extends Transaction;
  rand bit bad_csm;
  
  virtual function Transaction copy();
    BadTr bad;
    bad = new(); // Construct extended object
    bad.src = this.src; // Copy data fields
    bad.dst = this.dst;
    bad.data = this.data;
    bad.csm = this.csm;
    bad.bad_csm = this.bad_csm;
    return bad; // Return handle to copy
  endfunction
endclass : BadTr
```

These code excerpts demonstrate virtual functions for copying objects, which are part of object-oriented features available in SystemVerilog for hardware design and verification.","
class Transaction;
  rand bit [31:0] src, dst, data[8]; // Variables
  bit [31:0] csm;
  
  virtual function Transaction copy();
    Transaction copy;
    copy = new(); // Construct destination object
    copy.src = this.src; // Copy data fields
    copy.dst = this.dst; // The prefix ""this."" is
    copy.data = this.data; // not needed, but makes code
    copy.csm = this.csm; // more explicit
    return copy; // Return handle to copy
  endfunction
endclass


class BadTr extends Transaction;
  rand bit bad_csm;
  
  virtual function Transaction copy();
    BadTr bad;
    bad = new(); // Construct extended object
    bad.src = this.src; // Copy data fields
    bad.dst = this.dst;
    bad.data = this.data;
    bad.csm = this.csm;
    bad.bad_csm = this.bad_csm;
    return bad; // Return handle to copy
  endfunction
endclass : BadTr
","""Example of implementing object copy functions in SystemVerilog inheritance""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p329.jpg,True,"The image contains partial code snippets from the ""The Verilog PLI Handbook, Part Two"". Here is the code visible in the image:

```c
/* miscft routine */
PLIbook_ReadVector_miscft(int user_data, int reason)
{
    FILE *in_file;

    ...

    if (reason == REASON_ENDOFCOMPILE) { /* time to open vector file */
        in_file = fopen(tf_getcstringp(1), ""r"");

        tf_setworkarea((char*)in_file); /* save file pointer in workarea */
    }

    ...
}

/* calltf routine */
int PLIbook_ReadVector_calltf() {
    FILE *in_file;

    ...

    in_file = (FILE*)tf_getworkarea(); /* retrieve file pointer */

    /* read next test vector from file */

    ...
}
```

Please note that there are ellipses (...) indicating that some parts of the code have been omitted from this example.","scft routine */
PLIbook_ReadVector_miscft(int user_data, int reason)
{
    FILE *in_file;

    ...

    if (reason == REASON_ENDOFCOMPILE) { /* time to open vector file */
        in_file = fopen(tf_getcstringp(1), ""r"");

        tf_setworkarea((char*)in_file); /* save file pointer in workarea */
    }

    ...
}

/* calltf routine */
int PLIbook_ReadVector_calltf() {
    FILE *in_file;

    ...

    in_file = (FILE*)tf_getworkarea(); /* retrieve file pointer */

    /* read next test vector from file */

    ...
}
","Caption: ""Excerpt from The Verilog PLI Handbook demonstrating the usage of PLI routines for file operations in Verilog simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p162.jpg,True,"The image contains Verilog code in the middle section. Below is the Verilog code present:

```verilog
sequence data_transfer;
    ((dack_==0) && (oe_==0)) [*4];
endsequence

sequence checkbMode;
    (!bMode) throughout data_transfer;
endsequence

property prbuel1;
    @(posedge clk) $fell(bMode) |-> ##[1:2] ((dack_ && oe_)==0) ##0 checkbMode;
endproperty
```","
sequence data_transfer;
    ((dack_==0) && (oe_==0)) [*4];
endsequence

sequence checkbMode;
    (!bMode) throughout data_transfer;
endsequence

property prbuel1;
    @(posedge clk) $fell(bMode) |-> ##[1:2] ((dack_ && oe_)==0) ##0 checkbMode;
endproperty
","Caption: ""Explanation and application of the 'throughout' operator in SystemVerilog for temporal logic assertion, exemplified by waveform diagrams and code snippets.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p454.jpg,True,"```verilog
program automatic test;

// C function has same name as reserved keyword, change it
import ""DPI-C"" \[expect = function int fexpect();
...
if (actual != fexpect()) $display(""ERROR"");
...

// Change name of C function ""stat"" to ""file_exists""
import ""DPI-C"" stat = function int file_exists
    (input string fname, output int buff[1000]);

initial begin
    int buff[1000];
    $display(""file_exists(\""none.such\"") = %0d"",
             file_exists(""none.such"", buff));
end
endprogram
```","
program automatic test;

// C function has same name as reserved keyword, change it
import ""DPI-C"" \[expect = function int fexpect();
...
if (actual != fexpect()) $display(""ERROR"");
...

// Change name of C function ""stat"" to ""file_exists""
import ""DPI-C"" stat = function int file_exists
    (input string fname, output int buff[1000]);

initial begin
    int buff[1000];
    $display(""file_exists(\""none.such\"") = %0d"",
             file_exists(""none.such"", buff));
end
endprogram
","""Importing and renaming C functions in SystemVerilog code to avoid naming conflicts with reserved keywords.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p176.jpg,True,"```verilog
sequence ab;
    a ##[1:5] b;
endsequence

sequence cde;
    c ##2 d ##2 e;
endsequence

sequence abcde;
    ab intersect cde;
endsequence

property isect;
    @(posedge clk) |-> abcde;
endproperty
```","
sequence ab;
    a ##[1:5] b;
endsequence

sequence cde;
    c ##2 d ##2 e;
endsequence

sequence abcde;
    ab intersect cde;
endsequence

property isect;
    @(posedge clk) |-> abcde;
endproperty
","""Verilog Sequence Intersect and Application with Timing Diagrams""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p440.jpg,True,"The image contains Verilog code. Here's the code as displayed:

```verilog
Driver_cbs cbsq[$]; // Queue of callback objects
int PortID;

extern function new(input mailbox gen2dvr,
                    input event drv2gen,
                    input vUtopiaRx Rx,
                    input int PortID);

extern task run();
extern task send (input UNI_cell c);

endclass : Driver

// new(): Construct a driver object
function Driver::new(input mailbox gen2dvr,
                     input event drv2gen,
                     input vUtopiaRx Rx,
                     input int PortID);
    this.gen2dvr = gen2dvr;
    this.drv2gen = drv2gen;
    this.Rx = Rx;
    this.PortID = PortID;
endfunction : new

// run(): Run the driver.
// Get transaction from generator, send into DUT
task Driver::run();
    UNI_cell c;
    bit drop = 0;

    // Initialize ports
    Rx.cbr.data <= 0;
    Rx.cbr.soc <= 0;
    Rx.cbr.clav <= 0;

    forever begin
        // Read the cell at the front of the mailbox
        gen2dvr.peek(c);
    begin: Tx
        // Pre-transmit callbacks
        foreach (cbsq[i]) begin
            cbsq[i].pre_tx(this, c, drop);
            if (drop) disable Tx; // Don't transmit this cell
        end

        c.display($sformatf(""@%0t: Drv%0d: "", $time, PortID));
        send(c);
    end
```

This Verilog code seems to describe a UVM (Universal Verification Methodology) Driver with callback capability to interact with a testbench component. The code includes declarations and implementations of tasks and functions relevant to a Driver class, such as construction, running, and sending data.","
Driver_cbs cbsq[$]; // Queue of callback objects
int PortID;

extern function new(input mailbox gen2dvr,
                    input event drv2gen,
                    input vUtopiaRx Rx,
                    input int PortID);

extern task run();
extern task send (input UNI_cell c);

endclass : Driver

// new(): Construct a driver object
function Driver::new(input mailbox gen2dvr,
                     input event drv2gen,
                     input vUtopiaRx Rx,
                     input int PortID);
    this.gen2dvr = gen2dvr;
    this.drv2gen = drv2gen;
    this.Rx = Rx;
    this.PortID = PortID;
endfunction : new

// run(): Run the driver.
// Get transaction from generator, send into DUT
task Driver::run();
    UNI_cell c;
    bit drop = 0;

    // Initialize ports
    Rx.cbr.data <= 0;
    Rx.cbr.soc <= 0;
    Rx.cbr.clav <= 0;

    forever begin
        // Read the cell at the front of the mailbox
        gen2dvr.peek(c);
    begin: Tx
        // Pre-transmit callbacks
        foreach (cbsq[i]) begin
            cbsq[i].pre_tx(this, c, drop);
            if (drop) disable Tx; // Don't transmit this cell
        end

        c.display($sformatf(""@%0t: Drv%0d: "", $time, PortID));
        send(c);
    end
","Caption: ""Excerpt from a Verilog testbench illustrating the Driver class, including methods for object construction, running the driver, and sending transactions to a device under test.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p326.jpg,True,"The image contains Verilog/SystemVerilog code related to object-oriented programming concepts. Here is the code displayed on the image:

```verilog
class Transaction;
    rand bit [31:0] src, dst, data[8]; // Variables
    bit [31:0] csm;

    virtual function void calc_csm(); // XOR all fields
        csm = src ^ dst ^ data.xor;
    endfunction
endclass : Transaction

class BadTr extends Transaction;
    rand bit bad_csm;
    virtual function void calc_csm();
        super.calc_csm(); // Compute good csm
        if (bad_csm) csm = ~csm; // Corrupt the csm bits
    endfunction
endclass : BadTr

Transaction tr;
BadTr bad;

initial begin
    tr = new();
    tr.calc_csm(); // Calls Transaction::calc_csm

    bad = new();
    bad.calc_csm(); // Calls BadTr::calc_csm

    tr = bad; // Base handle points to ext obj
    tr.calc_csm(); // Calls BadTr::calc_csm
end
```

This code snippet demonstrates inheritance, method overriding, and polymorphism within SystemVerilog classes. The `Transaction` class defines a method `calc_csm()` to calculate a checksum which is overridden in the `BadTr` class, which extends `Transaction`. The override adds extra functionality to corrupt the checksum. The last part of the code illustrates how the type of the handle, rather than the object's dynamic type, determines which method gets called when using polymorphism.","
class Transaction;
    rand bit [31:0] src, dst, data[8]; // Variables
    bit [31:0] csm;

    virtual function void calc_csm(); // XOR all fields
        csm = src ^ dst ^ data.xor;
    endfunction
endclass : Transaction

class BadTr extends Transaction;
    rand bit bad_csm;
    virtual function void calc_csm();
        super.calc_csm(); // Compute good csm
        if (bad_csm) csm = ~csm; // Corrupt the csm bits
    endfunction
endclass : BadTr

Transaction tr;
BadTr bad;

initial begin
    tr = new();
    tr.calc_csm(); // Calls Transaction::calc_csm

    bad = new();
    bad.calc_csm(); // Calls BadTr::calc_csm

    tr = bad; // Base handle points to ext obj
    tr.calc_csm(); // Calls BadTr::calc_csm
end
","Caption: ""Example of Verilog code demonstrating downcasting and the use of virtual methods in Object-Oriented Programming within SystemVerilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p456.jpg,True,"The image contains a snippet of Verilog code, which is a part of Sample 12.6. Here is the code from the image:

```verilog
import ""DPI-C"" function real fabs(input real r);
...
initial $display(""fabs(0)=%f"", fabs(-1.0));
```","
import ""DPI-C"" function real fabs(input real r);
...
initial $display(""fabs(0)=%f"", fabs(-1.0));
","Caption: ""Excerpt from a technical document discussing the integration of C routines with Verilog, including a sample code showing the import of the C math library function fabs into Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p160.jpg,True,"The image contains two examples of Verilog SystemVerilog Assertion (SVA) properties. Here are the properties as they appear in the image:

On the left:
```verilog
property abc;
  @(posedge clk) a |-> b[->2:5] ##1 c;
endproperty
```

On the right:
```verilog
property abc;
  @(posedge clk) a |-> b[=2:5] ##1 c;
endproperty
```

These properties describe temporal relationships between signals `a`, `b`, and `c` with respect to the rising edge of a clock signal `clk`. The syntax `|->` and `##` are used to denote implication and temporal sequence, respectively. The notation `[->2:5]` and `[=2:5]` specifies different repetition requirements for the occurrence of signal `b` after signal `a`.","
property abc;
  @(posedge clk) a |-> b[->2:5] ##1 c;
endproperty


property abc;
  @(posedge clk) a |-> b[=2:5] ##1 c;
endproperty
","""Comparison of Verilog sequence operators showing the difference in behavior for non-consecutive repetition with a pass and fail case.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p330.jpg,True,"```verilog
// Not recommended
class EthMacFrame;
  typedef enum {II, IEEE} kind_e;
  rand kind_e kind;
  rand bit [47:0] da, sa;
  rand bit [15:0] len;
  ...
endclass

class Vlan extends EthMacFrame;
  rand bit [15:0] vlan;
endclass
```","
// Not recommended
class EthMacFrame;
  typedef enum {II, IEEE} kind_e;
  rand kind_e kind;
  rand bit [47:0] da, sa;
  rand bit [15:0] len;
  ...
endclass

class Vlan extends EthMacFrame;
  rand bit [15:0] vlan;
endclass
","""Discussion on issues with inheritance in Verilog code, showcasing an example of an Ethernet frame class with an extending VLAN frame class.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p324.jpg,True,"The image contains text which appears to be discussing concepts related to Verilog or SystemVerilog, specifically regarding downcasting and virtual methods. It includes some example code snippets:

```verilog
class Transaction;
  rand bit [31:0] src;
  virtual function void display(input string prefix="""");
    $display(""%sTransaction: src=%0d"", prefix, src);
  endfunction
endclass

class BadTr extends Transaction;
  bit bad_csm;
  virtual function void display(input string prefix="""");
    $display(""%sBadTr: bad_csm=%b"", prefix, bad_csm);
    super.display(prefix);
  endfunction
endclass

Transaction tr;
BadTr bad;
bad = new();                  // Construct BadTr extended object
tr = bad;                     // Base handle points to extended obj
                              // tr is downcast to point to BadTr type
$display(tr.src);             // Display variable in base class
tr.display;                   // Calls BadTr::display
```

This code exemplifies the usage of base and extended classes in SystemVerilog, demonstrates the use of virtual functions and the mechanism of downcasting by assigning an extended class object to a base class handle.","
class Transaction;
  rand bit [31:0] src;
  virtual function void display(input string prefix="""");
    $display(""%sTransaction: src=%0d"", prefix, src);
  endfunction
endclass

class BadTr extends Transaction;
  bit bad_csm;
  virtual function void display(input string prefix="""");
    $display(""%sBadTr: bad_csm=%b"", prefix, bad_csm);
    super.display(prefix);
  endfunction
endclass

Transaction tr;
BadTr bad;
bad = new();                  // Construct BadTr extended object
tr = bad;                     // Base handle points to extended obj
                              // tr is downcast to point to BadTr type
$display(tr.src);             // Display variable in base class
tr.display;                   // Calls BadTr::display
","""Verilog Inheritance Example: Demonstrating Base Class and Extended Class with a Display Method Override""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p328.jpg,True,"The image contains blocks of Verilog code. Here they are written out:

1.
```verilog
dout <= f_ecap(d1);
end
```

2.
```verilog
always @(posedge e1 or posedge e2) begin
    d1 <= i1 | i2;
    a9: assert property (d1 |=> i3 | i4);
    dout <= f_ecap(d1);
end
```

3.
```verilog
always @(posedge e1 or posedge reset) begin
    if (reset)
        d1 <= 0;
    else begin
        d1 <= i1 | i2;
        a10: assert property (d1 |=> i3 | i4);
    end
    dout <= f_ecap(d1);
end
```","
dout <= f_ecap(d1);
end


always @(posedge e1 or posedge e2) begin
    d1 <= i1 | i2;
    a9: assert property (d1 |=> i3 | i4);
    dout <= f_ecap(d1);
end


always @(posedge e1 or posedge reset) begin
    if (reset)
        d1 <= 0;
    else begin
        d1 <= i1 | i2;
        a10: assert property (d1 |=> i3 | i4);
    end
    dout <= f_ecap(d1);
end
","Caption: Excerpts from a text discussing rules of clock inferencing in Verilog, with examples of Verilog code illustrating the violation and proper use of clock inferencing in procedural blocks.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p459.jpg,True,"The image contains an excerpt from a document, specifically chapter 14 titled ""How to Use the ACC Routines."" It describes the ACC routines in the context of Verilog HDL and how they treat Verilog constructs as objects. There is a segment of code visible in the image. Here is the code present:

```c
#include ""veriusert.h"" /* IEEE 1364 TF PLI library */
#include ""acc_user.h""  /* IEEE 1364 ACC PLI library */
```

This code snippet is an example of how to include the TF and ACC library header files necessary for working with Verilog's Programming Language Interface (PLI).","ude ""veriusert.h"" /* IEEE 1364 TF PLI library */
#include ""acc_user.h""  /* IEEE 1364 ACC PLI library */
",Introduction to ACC Routines and their integration in Verilog simulations with a mention of the TF and ACC header files inclusion.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p442.jpg,True,"The image contains Verilog code from a book or document related to testbench blocks in Verilog. Here is the code transcribed from the image:

```verilog
typedef class Driver;

class Driver_cbs;
    virtual task pre_tx(input Driver drv,
                        input UNI_cell c,
                        inout bit drop);
    endtask : pre_tx

    virtual task post_tx(input Driver drv,
                         input UNI_cell c);
    endtask : post_tx
endclass : Driver_cbs

typedef class Monitor;

class Monitor_cbs;
    virtual task post_rx(input Monitor mon,
                         input UNI_cell c);
    endtask : post_rx
endclass : Monitor_cbs

typedef class Monitor_cbs;

class Monitor;
    vUtopiaTx Tx;                  // Virtual interface with output of DUT
    Monitor_cbs cbsq[$];           // Queue of callback objects
    bit [0:1] PortID;

    extern function new(input vUtopiaTx Tx, input int PortID);
    extern task run();
    extern task receive (output NNI_cell c);
endclass : Monitor

// new(): construct an object
function Monitor::new(input vUtopiaTx Tx, input int PortID);
    this.Tx    = Tx;
```

The code snippets are examples of class definitions and callback mechanisms in a Verilog testbench.","
typedef class Driver;

class Driver_cbs;
    virtual task pre_tx(input Driver drv,
                        input UNI_cell c,
                        inout bit drop);
    endtask : pre_tx

    virtual task post_tx(input Driver drv,
                         input UNI_cell c);
    endtask : post_tx
endclass : Driver_cbs

typedef class Monitor;

class Monitor_cbs;
    virtual task post_rx(input Monitor mon,
                         input UNI_cell c);
    endtask : post_rx
endclass : Monitor_cbs

typedef class Monitor_cbs;

class Monitor;
    vUtopiaTx Tx;                  // Virtual interface with output of DUT
    Monitor_cbs cbsq[$];           // Queue of callback objects
    bit [0:1] PortID;

    extern function new(input vUtopiaTx Tx, input int PortID);
    extern task run();
    extern task receive (output NNI_cell c);
endclass : Monitor

// new(): construct an object
function Monitor::new(input vUtopiaTx Tx, input int PortID);
    this.Tx    = Tx;
",Sample Verilog callback classes and tasks for a testbench including Driver and Monitor classes.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p174.jpg,True,"The image contains Verilog code. Here is the code from the image:

```verilog
sequence ab;
    a ##2 b;
endsequence

sequence cde;
    c ##2 d ##2 e;
endsequence

sequence abcde;
    ab or cde;
endsequence

property ands;
    @(posedge clk) z |-> abcde;
endproperty
```

This code is part of a demonstration possibly explaining the usage of sequences and properties in Verilog assertions, along with related timing diagrams to visualize signal behavior.","
sequence ab;
    a ##2 b;
endsequence

sequence cde;
    c ##2 d ##2 e;
endsequence

sequence abcde;
    ab or cde;
endsequence

property ands;
    @(posedge clk) z |-> abcde;
endproperty
","""Analysis of Verilog sequences and properties with timing diagrams illustrating assertion outcomes""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p471.jpg,True,"```c
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */
/**********************************************************************
 * checktf application
 *********************************************************************/
PLIbook_ShowNets_checktf()
{
   acc_initialize();
   if (tf_nump() != 1)
      tf_error(""$show_all_nets must have 1 argument."");
   else if (tf_typep(1) == TF_NULLPARAM)
      tf_error(""$show_all_nets arg cannot be null."");
   else if (acc_fetch_type(acc_handle_tfarg(1)) != accModule)
      tf_error(""$show_all_nets arg must be a module instance."");
   acc_close();
   return(0);
}

/**********************************************************************
 * calltf application
 *********************************************************************/
int PLIbook_ShowNets_calltf()
{
  handle module_handle, net_handle;
  acc_initialize();
  module_handle = acc_handle_tfarg(1);
  io_printf(""\nAt time %s, nets in module %s (%s):\n"",
            tf_strgettime(),
            acc_fetch_fullname(module_handle),
            acc_fetch_defname(module_handle));
  net_handle = null; /* start with known value for target handle */
  while (net_handle=acc_next_net(module_handle,net_handle)) {
```","ude ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h"" /* IEEE 1364 PLI ACC routine library */
/**********************************************************************
 * checktf application
 *********************************************************************/
PLIbook_ShowNets_checktf()
{
   acc_initialize();
   if (tf_nump() != 1)
      tf_error(""$show_all_nets must have 1 argument."");
   else if (tf_typep(1) == TF_NULLPARAM)
      tf_error(""$show_all_nets arg cannot be null."");
   else if (acc_fetch_type(acc_handle_tfarg(1)) != accModule)
      tf_error(""$show_all_nets arg must be a module instance."");
   acc_close();
   return(0);
}

/**********************************************************************
 * calltf application
 *********************************************************************/
int PLIbook_ShowNets_calltf()
{
  handle module_handle, net_handle;
  acc_initialize();
  module_handle = acc_handle_tfarg(1);
  io_printf(""\nAt time %s, nets in module %s (%s):\n"",
            tf_strgettime(),
            acc_fetch_fullname(module_handle),
            acc_fetch_defname(module_handle));
  net_handle = null; /* start with known value for target handle */
  while (net_handle=acc_next_net(module_handle,net_handle)) {
","Caption: ""Example of Verilog PLI application using ACC routines described in a textbook chapter on ACC routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p317.jpg,True,"```c
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
```","ude ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
","""Excerpt from a technical text describing the use of TF (task/function) routines in conjunction with the ACC and VPI routines in Verilog PLI (Programming Language Interface) applications, referencing the IEEE 1364 PLI standard.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p314.jpg,True,"This image contains two snippets of Verilog code. Here are the contents of both:

First snippet:

```verilog
a_accept: assert property(
    @(posedge clk)
    accept_on(retry)
    a |=> b
) else $error(""FAIL"");
```

Second snippet:

```verilog
a_simple_abort: assert property (
    @(posedge clk)
    start
    |=> 
    accept_on(retry) check_trans_complete
);
``` 

The image discusses various points about abort conditions in assertions within Verilog code.","
a_accept: assert property(
    @(posedge clk)
    accept_on(retry)
    a |=> b
) else $error(""FAIL"");


a_simple_abort: assert property (
    @(posedge clk)
    start
    |=> 
    accept_on(retry) check_trans_complete
);
",A textbook page explaining and demonstrating how to implement simple concurrent assertions with asynchronous aborts in Verilog.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p303.jpg,True,"Here is the Verilog code snippet that appears in the image:

```verilog
always @(posedge clock)
begin
    result <= $pow(x,y);
    ...
end
```

The code describes a part of a Verilog module that triggers on the positive edge of a clock signal. Within this block, `result` is assigned the output of a system function `$pow`, which takes in two arguments `x` and `y`. The `...` indicates that there may be additional code not shown in this snippet.","
always @(posedge clock)
begin
    result <= $pow(x,y);
    ...
end
","Caption: ""Excerpt from a book on Verilog PLI applications showing example code and discussion of the `sizetf` routine callback in Verilog simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p318.jpg,True,"The image contains snippets of code in Verilog/SystemVerilog. Here is the code:

```verilog
// Generator class that uses Transaction objects
// First attempt... too limited
class Generator;
  mailbox #(Transaction) gen2drv; // Carries transactions to driver
  Transaction tr;

  function new(input mailbox #(Transaction) gen2drv);
    this.gen2drv = gen2drv; // this-> class-level var
  endfunction

  virtual task run(input int num_tr = 10);
    repeat (num_tr) begin
      tr = new(); // Construct transaction
      `SV_RAND_CHECK(tr.randomize()); // Randomize it
      gen2drv.put(tr.copy()); // Send copy to driver
    end
  endtask
endclass
```

This Verilog/SystemVerilog code defines a simple generator class intended for a testbench in a hardware verification context. However, the text mentions that there is a limitation with this generator class, which relates to the run task that constructs and randomizes a transaction. It's notable that the `SV_RAND_CHECK` macro is used for checking the success of the `randomize` function call.","
// Generator class that uses Transaction objects
// First attempt... too limited
class Generator;
  mailbox #(Transaction) gen2drv; // Carries transactions to driver
  Transaction tr;

  function new(input mailbox #(Transaction) gen2drv);
    this.gen2drv = gen2drv; // this-> class-level var
  endfunction

  virtual task run(input int num_tr = 10);
    repeat (num_tr) begin
      tr = new(); // Construct transaction
      `SV_RAND_CHECK(tr.randomize()); // Randomize it
      gen2drv.put(tr.copy()); // Send copy to driver
    end
  endtask
endclass
","""Example of a flawed Verilog generator class with a basic inheritance concept in system verification""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p148.jpg,True,"The image contains an excerpt of Verilog code inside a box labeled ""Specification."" Here's the code presented in the image:

```verilog
property StuckState;
  @(posedge clk) disable iff (rst)
    ((currentState != IDLE) && $stable(currentState))[ *32 ] |=> 1'b0;
endproperty
```

This snippet defines a property called `StuckState`, which is apparently used to check that a state machine doesn't get stuck in any state other than `IDLE` for 32 consecutive clock cycles.","
property StuckState;
  @(posedge clk) disable iff (rst)
    ((currentState != IDLE) && $stable(currentState))[ *32 ] |=> 1'b0;
endproperty
","Caption: ""Example of a Verilog assertion property to ensure a state machine does not remain stuck in a state other than 'IDLE'.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p132.jpg,True,"```verilog
always @(a or b or c) begin
    :
    if (c)
        $assert_always_ck (ck, a^b) ;
end
```","
always @(a or b or c) begin
    :
    if (c)
        $assert_always_ck (ck, a^b) ;
end
","""Verilog procedural assertion with a Value Change Link on the sampling clock to prevent false assertions across multiple simulation time steps.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p36.jpg,True,"The image contains Verilog code examples. Here they are:

First code example:
```verilog
package Transaction;
...
endpackage

package Extended_trans extends Transaction;
...
endpackage

initial begin
    Transaction tr = new; // declaration with constructor
    bit status;           // declaration
    status = tr.randomize; // procedural statement
    Extended_trans etr = new; // GOTCHA! declaration after statement
...
end
```

Second code example (How to avoid this Gotcha):
```verilog
initial begin // move all declarations to top of the block
    Transaction tr = new; // declaration with constructor
    Extended_trans etr = new; // OK, declaration before statement
    bit status;               // declaration
    status = tr.randomize;    // procedural statement
...
end
```

Third code example:
```verilog
// The example is not fully visible in the image provided.
```

Unfortunately, the third code example is incomplete and cannot be seen in the provided image, so the full context and syntax cannot be presented here.","
package Transaction;
...
endpackage

package Extended_trans extends Transaction;
...
endpackage

initial begin
    Transaction tr = new; // declaration with constructor
    bit status;           // declaration
    status = tr.randomize; // procedural statement
    Extended_trans etr = new; // GOTCHA! declaration after statement
...
end


initial begin // move all declarations to top of the block
    Transaction tr = new; // declaration with constructor
    Extended_trans etr = new; // OK, declaration before statement
    bit status;               // declaration
    status = tr.randomize;    // procedural statement
...
end


// The example is not fully visible in the image provided.
","Explanation of local variable declarations and best practices in Verilog and SystemVerilog, with examples to avoid common mistakes.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p200.jpg,True,"The image contains the following Verilog code:

```verilog
function [7:0] doCheckSum ( input[63:0] DataArray );
  reg[15:0] temp1, temp2; // Just to illustrate local declarations.
  begin
    temp1 = DataArray[15:0] ^ DataArray[31:16];
    temp2 = DataArray[63:48] ^ DataArray[47:32];
    doCheckSum = temp1[7:0] + temp2[7:0] ^ temp1[15:8] + temp2[15:8];
  end
endfunction
...
#2 CheckSum = doCheckSum(Dbus);
```

This excerpt discusses functions in Verilog and shows an example of a function declaration `doCheckSum` and a function call. The function takes one 64-bit input argument `DataArray` and returns an 8-bit checksum computed from parts of the input array.","
function [7:0] doCheckSum ( input[63:0] DataArray );
  reg[15:0] temp1, temp2; // Just to illustrate local declarations.
  begin
    temp1 = DataArray[15:0] ^ DataArray[31:16];
    temp2 = DataArray[63:48] ^ DataArray[47:32];
    doCheckSum = temp1[7:0] + temp2[7:0] ^ temp1[15:8] + temp2[15:8];
  end
endfunction
...
#2 CheckSum = doCheckSum(Dbus);
","""Excerpt from a Digital VLSI Design with Verilog textbook providing guidelines on Verilog tasks and functions, highlighting a function declaration example and the importance of local variable declarations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p102.jpg,True,"```verilog
module controller (output logic read, write,
                   input instr_t instruction,
                   input logic clock, reset_n);

enum {HOLD, LOAD, STORE} state_e, nstate_e; // 2-state types

always @(posedge clock, negedge reset_n) // state sequencer
    if (!reset_n) state_e <= HOLD;
    else state_e <= nstate_e;

always @(state_e) begin  // GOTCHA! next state decoder
    unique case (state_e)
        HOLD: nstate_e = LOAD;
        LOAD: nstate_e = STORE;
        STORE: nstate_e = HOLD;
    endcase
end

...

endmodule
```","
module controller (output logic read, write,
                   input instr_t instruction,
                   input logic clock, reset_n);

enum {HOLD, LOAD, STORE} state_e, nstate_e; // 2-state types

always @(posedge clock, negedge reset_n) // state sequencer
    if (!reset_n) state_e <= HOLD;
    else state_e <= nstate_e;

always @(state_e) begin  // GOTCHA! next state decoder
    unique case (state_e)
        HOLD: nstate_e = LOAD;
        LOAD: nstate_e = STORE;
        STORE: nstate_e = HOLD;
    endcase
end

...

endmodule
","""Example of a Verilog gotcha involving locked state machines modeled with enumerated types.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p214.jpg,True,"```verilog
task incrRead; // Called while clock is low.
  begin
    @(posedge Clk)
    ReadCount = ReadCount + 1;
  end
endtask
```","
task incrRead; // Called while clock is low.
  begin
    @(posedge Clk)
    ReadCount = ReadCount + 1;
  end
endtask
","Caption: ""Verilog Task for Incrementing a Read Counter in Digital VLSI Design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p481.jpg,True,"Here's the Verilog code extracted from the image:

```verilog
module memory;
  import ""DPI-C"" context task read_file(string fname);
  export ""DPI-C"" task mem_read;
  export ""DPI-C"" task mem_write;
  export ""DPI-C"" function mem_build;

  initial read_file(""mem.dat"");

  int mem[];

  function void mem_build(input int size);
    mem = new[size];
  endfunction

  task mem_read(input int addr, output int data);
    #20 data = mem[addr];
  endtask

  task mem_write(input int addr, input int data);
    #10 mem[addr] = data;
  endtask
endmodule : memory
```","
module memory;
  import ""DPI-C"" context task read_file(string fname);
  export ""DPI-C"" task mem_read;
  export ""DPI-C"" task mem_write;
  export ""DPI-C"" function mem_build;

  initial read_file(""mem.dat"");

  int mem[];

  function void mem_build(input int size);
    mem = new[size];
  endfunction

  task mem_read(input int addr, output int data);
    #20 data = mem[addr];
  endtask

  task mem_write(input int addr, input int data);
    #10 mem[addr] = data;
  endtask
endmodule : memory
","Caption: ""Excerpt from a textbook showing a page with Verilog/SystemVerilog code for a memory module with C interface using DPI-C.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p126.jpg,True,"The image includes an example of a C routine meant for use in Verilog simulations with PLI (Programming Language Interface). The code is a ""checktf"" routine for validating arguments of the `sassert_always` PLI task. Here is the code from the image:

```c
/****************************************
 * checktf routine to validate arguments
 ****************************************/
int assert_always_checktf(char *user_data)
{
    if (tf_nump() != 1)
        tf_error(""$sassert_always only 1 argument."");
    else if (tf_sizep(1) != 1)
        tf_error(""$sassert_always argument size!=1"");
    return(0);
}
```

This routine is designed to ensure that the `sassert_always` task is called with the correct number of arguments and that the first argument has a bit width of 1. If these conditions are not met, the `tf_error` function is called to output an error message and abort the simulation.","************************************
 * checktf routine to validate arguments
 ****************************************/
int assert_always_checktf(char *user_data)
{
    if (tf_nump() != 1)
        tf_error(""$sassert_always only 1 argument."");
    else if (tf_sizep(1) != 1)
        tf_error(""$sassert_always argument size!=1"");
    return(0);
}
","""Example of a Verilog PLI checktf routine for assert_always""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p228.jpg,True,"The image contains the following Verilog code snippet:

```verilog
...
reg x, y, z;

always@(x) z = x;
always@(y) z = y;
...

initial
begin
    z = 1'b0;
    #2 x = 1'b0;
    y = 1'b1;
    #5 $finish;
end
```

Additionally, the image mentions modifying the first always block to include a zero delay:

```verilog
always@(x) #0 z = x;
```

These code examples are discussing how blocking assignments may be affected by `#0` delays in Verilog.","
...
reg x, y, z;

always@(x) z = x;
always@(y) z = y;
...

initial
begin
    z = 1'b0;
    #2 x = 1'b0;
    y = 1'b1;
    #5 $finish;
end


always@(x) #0 z = x;
","""Exploring Delay Expressions and Scheduling in Verilog Code""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p132.jpg,True,"The image contains two pieces of Verilog code.

Here is the code for Sample 4.2:
```verilog
module test_with_port (input logic [1:0] grant,
                       output logic [1:0] request,
                       output bit rst,
                       input bit clk);

initial begin
  @(posedge clk);
  request <= 2'b01;
  $display(""%0t: Drove req=01"", $time);
  repeat (2) @(posedge clk);
  if (grant == 2'b01)
    $display(""%0t: Success: grant == 2'b01"", $time);
  else
    $display(""%0t: Error: grant != 2'b01"", $time);
  $finish;
end
endmodule
```

And here is the code for Sample 4.3:
```verilog
module top;
  logic [1:0] grant, request;
  bit clk;
  always #50 clk = ~clk;

  arb_with_port a1 (grant, request, rst, clk);  // Sample 4-1
  test_with_port t1 (grant, request, rst, clk);  // Sample 4-2
endmodule
```

These code snippets are examples from a book or text about Verilog, specifically discussing connecting a testbench and a design using ports.","
module test_with_port (input logic [1:0] grant,
                       output logic [1:0] request,
                       output bit rst,
                       input bit clk);

initial begin
  @(posedge clk);
  request <= 2'b01;
  $display(""%0t: Drove req=01"", $time);
  repeat (2) @(posedge clk);
  if (grant == 2'b01)
    $display(""%0t: Success: grant == 2'b01"", $time);
  else
    $display(""%0t: Error: grant != 2'b01"", $time);
  $finish;
end
endmodule


module top;
  logic [1:0] grant, request;
  bit clk;
  always #50 clk = ~clk;

  arb_with_port a1 (grant, request, rst, clk);  // Sample 4-1
  test_with_port t1 (grant, request, rst, clk);  // Sample 4-2
endmodule
","Caption: ""Examples of Verilog testbench and top-level module code illustrating the use of ports for connecting a testbench with a Design Under Test (DUT) and highlighting the importance of the interface construct in complex SystemVerilog designs.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p404.jpg,True,"The image contains Verilog code. Here is the transcribed code:

```verilog
`ifdef nobugs
$display(""SCENARIO 4"");
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b0; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b0; data='8'h0; dAck='1'b0;
$display(""\n"");
`else
$display(""SCENARIO 4"");
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b0; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b0; data='8'h0; dAck='1'b0;
$display(""\n"");
`endif

`ifdef nobugs
$display(""SCENARIO 5"");
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b0; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b0; data='8'h0; dAck='1'b0;
$display(""\n"");
`else
$display(""SCENARIO 5"");
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b0; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b0; data='8'h0; dAck='1'b0;
$display(""\n"");
`endif
```

Note: The code utilizes preprocessor directives (`ifdef` and `endif`) to conditionally compile the blocks of code, depending on whether the `nobugs` symbol is defined. It appears to be part of a lab exercise, perhaps instructing a testbench or simulation scenario.","
`ifdef nobugs
$display(""SCENARIO 4"");
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b0; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b0; data='8'h0; dAck='1'b0;
$display(""\n"");
`else
$display(""SCENARIO 4"");
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b0; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b0; data='8'h0; dAck='1'b0;
$display(""\n"");
`endif

`ifdef nobugs
$display(""SCENARIO 5"");
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b0; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b0; data='8'h0; dAck='1'b0;
$display(""\n"");
`else
$display(""SCENARIO 5"");
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b1; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b0; data='8'h0; dAck='1'b0;
@(negedge clk); dValid='1'b0; data='8'h0; dAck='1'b0;
$display(""\n"");
`endif
","""Verilog Code for Data Transfer Protocol Scenarios 4 and 5 with Debug Conditional Compilation""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p129.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
vpiHandle net_handle, bit_handle;

/* add code to obtain handle for a net vector */

bit_handle = vpi_handle_by_index(net_handle, 2);
if (bit_handle == NULL)
    /* process the net bit object */
else
    /* error: terminal not found */
```","
vpiHandle net_handle, bit_handle;

/* add code to obtain handle for a net vector */

bit_handle = vpi_handle_by_index(net_handle, 2);
if (bit_handle == NULL)
    /* process the net bit object */
else
    /* error: terminal not found */
","Caption: ""Excerpt from a technical document explaining the VPI Routine Library in Verilog, including code for obtaining a handle using an index.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p362.jpg,True,"```verilog
property check2;
    $rose(irdy) |=> frame_;
endproperty

checker ck2; //nested checker
    property check1; //Redefinition of check1 within the
    local scope of checker ck2
        $rose(trdy) |-> irdy;
    endproperty

    property check3;
        $fell(irdy) |-> !frame_;
    endproperty

    checkp1: assert property check1; //local to checker ck2
    checkp3: assert property check3; //local to checker ck2
    checkp2: assert property check2; //declared in checker ck1
endchecker : ck2

ck2 ck2i; //instantiate ck2

endchecker : ck1
``` 

The image contains a section of Verilog code detailing properties and a nested checker block.","
property check2;
    $rose(irdy) |=> frame_;
endproperty

checker ck2; //nested checker
    property check1; //Redefinition of check1 within the
    local scope of checker ck2
        $rose(trdy) |-> irdy;
    endproperty

    property check3;
        $fell(irdy) |-> !frame_;
    endproperty

    checkp1: assert property check1; //local to checker ck2
    checkp3: assert property check3; //local to checker ck2
    checkp2: assert property check2; //declared in checker ck1
endchecker : ck2

ck2 ck2i; //instantiate ck2

endchecker : ck1
","""Excerpt from a document discussing nested checkers and property redefinitions in Verilog code.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p376.jpg,True,"The image contains Verilog code. Here it is:

```verilog
module dut(clk, req, gnt);
    input logic clk, req;
    output logic gnt;

    initial
    begin
        gnt1'b0;
    end

    initial
    begin
        @(posedge req);
        @(negedge clk); gnt1'b0;
        @(negedge clk); gnt1'b1;

        @(posedge req);
        @(negedge clk); gnt1'b0;
        @(negedge clk); gnt1'b0;
    end

endmodule
```

Please note: there are some syntax errors in the code presented. For example, `gnt1'b0;` should probably be `gnt = 1'b0;`. The correct code should ensure proper assignment to the `gnt` signal using the assignment operator `=` and specifying the correct bit-width of the literal (which is missing a bit-width declaration, such as `1` in `1'b0` to represent a 1-bit wide binary literal).","
module dut(clk, req, gnt);
    input logic clk, req;
    output logic gnt;

    initial
    begin
        gnt1'b0;
    end

    initial
    begin
        @(posedge req);
        @(negedge clk); gnt1'b0;
        @(negedge clk); gnt1'b1;

        @(posedge req);
        @(negedge clk); gnt1'b0;
        @(negedge clk); gnt1'b0;
    end

endmodule
",Verilog tutorial showing how to bind a Design Under Test (DUT) with its properties and set up a test bench for simulation.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p126.jpg,True,"There is code in the image. Here it is:

```verilog
`timescale 1ns/100ps

module ps;

initial begin
realtime rtdelay = 800ps; // Stored as 0.8 (800ps)
time tddelay = 800ps; // Rounded to 1

$timeformat(-12, 0, ""ps"", 5);
#rtdelay; // Delay of 800ps
$display(""%t"", rtdelay); // ""800ps""
#tddelay; // Delay another 1ns
$display(""%t"", tddelay); // ""1000ps""
end

endmodule
`timescale 1ns/1ns // Reset to default
```","
`timescale 1ns/100ps

module ps;

initial begin
realtime rtdelay = 800ps; // Stored as 0.8 (800ps)
time tddelay = 800ps; // Rounded to 1

$timeformat(-12, 0, ""ps"", 5);
#rtdelay; // Delay of 800ps
$display(""%t"", rtdelay); // ""800ps""
#tddelay; // Delay another 1ns
$display(""%t"", tddelay); // ""1000ps""
end

endmodule
`timescale 1ns/1ns // Reset to default
","Verilog code example demonstrating time variables, rounding, and the difference between $time and $realtime system tasks.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p38.jpg,True,"The image contains Verilog code as follows:

```verilog
module test;

initial begin
    $hello();
    #10 $stop;
    $finish;
end

endmodule
```","
module test;

initial begin
    $hello();
    #10 $stop;
    $finish;
end

endmodule
","""Excerpt from The Verilog PLI Handbook demonstrating the use of a PLI application with the $hello system task in a Verilog simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p288.jpg,True,"The image contains Verilog code. Here is the code:

```verilog
if(`ASSERT_GLOBAL_RESET != 1'b0) begin
`else
if (reset_n != 1'b0) begin // active low reset_n
`endif
  case (r_state)
    WINDOW_START:
      if (start_event == 1'b1) begin
        r_state <= WINDOW_CHECK;
      end
    WINDOW_CHECK:
      begin
        if (end_event == 1'b1) begin
          r_state <= WINDOW_START;
        end
        else if (test_expr != 1'b1) begin
          error_count = error_count + 1;
          `ifdef ASSERT_MAX_REPORT_ERROR
            if (error_count <= `ASSERT_MAX_REPORT_ERROR)
          `endif
          $display(""%s : severity %0d : time %0t: %m"", msg, severity_level, $time);
        if (severity_level == 0) $finish;
        end
      end
  endcase
`else
  r_state <= WINDOW_START;
`end
end // always
`endif
//synopsys translate_on
endmodule // assert_window
```

The above Verilog code appears to be a part of a module that describes some form of assertion window, possibly used in simulation to check for certain conditions during a testbench run in digital design verification. The assertion checks for the start and end of an event and performs some error reporting and potentially terminates the simulation based on severity level.","
if(`ASSERT_GLOBAL_RESET != 1'b0) begin
`else
if (reset_n != 1'b0) begin // active low reset_n
`endif
  case (r_state)
    WINDOW_START:
      if (start_event == 1'b1) begin
        r_state <= WINDOW_CHECK;
      end
    WINDOW_CHECK:
      begin
        if (end_event == 1'b1) begin
          r_state <= WINDOW_START;
        end
        else if (test_expr != 1'b1) begin
          error_count = error_count + 1;
          `ifdef ASSERT_MAX_REPORT_ERROR
            if (error_count <= `ASSERT_MAX_REPORT_ERROR)
          `endif
          $display(""%s : severity %0d : time %0t: %m"", msg, severity_level, $time);
        if (severity_level == 0) $finish;
        end
      end
  endcase
`else
  r_state <= WINDOW_START;
`end
end // always
`endif
//synopsys translate_on
endmodule // assert_window
","""Example of Verilog code implementing an assertion window to ensure correct event timing in a digital design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p102.jpg,True,"The image contains a Verilog code example for a simple RAM module. Here is the code provided in the image:

```verilog
module ram (input logic clk, rst, read, write,
            logic [7:0] addr, logic [15:0] data,
            output logic [15:0] out);

logic [15:0] mem[255:0];

always @(posedge clk or posedge rst) begin
    if (rst) out <= '0;
    else begin
        if (read) out <= mem[addr];
        if (write) mem[addr] <= data;
    end
end

stable_when_write: assert property (disable iff (rst)
    write |-> $stable(out));
endmodule : ram
```

The code defines a simple RAM with basic read and write functionality and includes an assertion to check the stability of the output when a write operation is performed.","
module ram (input logic clk, rst, read, write,
            logic [7:0] addr, logic [15:0] data,
            output logic [15:0] out);

logic [15:0] mem[255:0];

always @(posedge clk or posedge rst) begin
    if (rst) out <= '0;
    else begin
        if (read) out <= mem[addr];
        if (write) mem[addr] <= data;
    end
end

stable_when_write: assert property (disable iff (rst)
    write |-> $stable(out));
endmodule : ram
","Caption: ""Example of a Verilog module for a simple RAM with a discussion on the role of assumptions in formal verification using SystemVerilog Assertions (SVA).""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p239.jpg,True,"The image contains the following Verilog SystemVerilog Assertion (SVA) code:

```systemverilog
property p_wr_rdterminate;
  @(posedge clk) (`s_write || `s_burst_write) ##1 (`s_read || `s_burst_read);
endproperty

c_wr_rdterminate :
  cover property(p_wr_rdterminate);
```

This code describes a property `p_wr_rdterminate` using SystemVerilog assertion constructs and a `cover` statement that attempts to prove the occurrence of the property during simulation.","erilog
property p_wr_rdterminate;
  @(posedge clk) (`s_write || `s_burst_write) ##1 (`s_read || `s_burst_read);
endproperty

c_wr_rdterminate :
  cover property(p_wr_rdterminate);
","""Verilog code example demonstrating the assertion property for write termination by a read command in an SDRAM module.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p667.jpg,True,"Here is the Verilog code from the image:

```verilog
s_tfcell veriusertfs[]=
{
    {usertask,
     0,                          /* type of PLI routine */
     /* user_data value */
     PLIbook_ShowVal_checktf,    /* checktf routine */
     0,                          /* sizetf routine */
     PLIbook_ShowVal_calltf,     /* calltf routine */
     0,                          /* misctf routine */
     ""sshow_value"",              /* system task/function name */
                                 /* forward reference = true */
    },
    {userfunction,
     0,                          /* type of PLI routine */
     /* user_data value */
     PLIbook_pow_checktf,        /* checktf routine */
     PLIbook_pow_sizetf,         /* sizetf routine */
     PLIbook_pow_calltf,         /* calltf routine */
     PLIbook_pow_misctf,         /* misctf routine */
     ""spow"",                     /* system task/function name */
                                 /* forward reference = true */
    },
    {0}                          /* Last entry must be 0 */
};
```

This snippet is an example of a `baseuser.vc` file, which is used to describe a Verilog PLI (Programming Language Interface) application. The structure `s_tfcell` is used to register user-defined system tasks and functions with the Verilog simulator. The example defines two PLI applications: `sshow_value` and `spow`.","
s_tfcell veriusertfs[]=
{
    {usertask,
     0,                          /* type of PLI routine */
     /* user_data value */
     PLIbook_ShowVal_checktf,    /* checktf routine */
     0,                          /* sizetf routine */
     PLIbook_ShowVal_calltf,     /* calltf routine */
     0,                          /* misctf routine */
     ""sshow_value"",              /* system task/function name */
                                 /* forward reference = true */
    },
    {userfunction,
     0,                          /* type of PLI routine */
     /* user_data value */
     PLIbook_pow_checktf,        /* checktf routine */
     PLIbook_pow_sizetf,         /* sizetf routine */
     PLIbook_pow_calltf,         /* calltf routine */
     PLIbook_pow_misctf,         /* misctf routine */
     ""spow"",                     /* system task/function name */
                                 /* forward reference = true */
    },
    {0}                          /* Last entry must be 0 */
};
",Sample code and instructions for linking PLI applications with a Verilog simulator.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p101.jpg,True,"The image contains two snippets of code. The first one is from a C API for interacting with Verilog called the VPI (Verilog Procedural Interface), and the second one is an example of a Verilog test bench. Here are both code snippets:

1. The C API code using VPI:
```c
vpi_get_value(signal_handle, &current_value);
vpi_printf("" reg %-10s value is %s (binary)\n"",
           vpi_get_str(vpiName, signal_handle),
           current_value.value.str);
break;

case vpiIntegerVar:
current_value.format = vpiIntVal;
vpi_get_value(signal_handle, &current_value);
vpi_printf("" integer %-10s value is %d (decimal)\n"",
           vpi_get_str(vpiName, signal_handle),
           current_value.value.integer);
break;

case vpiRealVar:
current_value.format = vpiRealVal;
vpi_get_value(signal_handle, &current_value);
vpi_printf("" real %-10s value is %0.2f\n"",
           vpi_get_str(vpiName, signal_handle),
           current_value.value.real);
break;

case vpiTimeVar:
current_value.format = vpiTimeVal;
vpi_get_value(signal_handle, &current_value);
vpi_printf("" time %-10s value is %x%x\n"",
           vpi_get_str(vpiName, signal_handle),
           current_value.value.time->high,
           current_value.value.time->low);
break;
}
return;
}
```

2. The Verilog test bench example:
```verilog
`timescale 1ns / 1ns
module top;
tri [1:0] results;
integer test;
real foo;
time bar;
```

Please note that the snippets may not represent complete functions or modules, they are excerpts from a larger context.","et_value(signal_handle, &current_value);
vpi_printf("" reg %-10s value is %s (binary)\n"",
           vpi_get_str(vpiName, signal_handle),
           current_value.value.str);
break;

case vpiIntegerVar:
current_value.format = vpiIntVal;
vpi_get_value(signal_handle, &current_value);
vpi_printf("" integer %-10s value is %d (decimal)\n"",
           vpi_get_str(vpiName, signal_handle),
           current_value.value.integer);
break;

case vpiRealVar:
current_value.format = vpiRealVal;
vpi_get_value(signal_handle, &current_value);
vpi_printf("" real %-10s value is %0.2f\n"",
           vpi_get_str(vpiName, signal_handle),
           current_value.value.real);
break;

case vpiTimeVar:
current_value.format = vpiTimeVal;
vpi_get_value(signal_handle, &current_value);
vpi_printf("" time %-10s value is %x%x\n"",
           vpi_get_str(vpiName, signal_handle),
           current_value.value.time->high,
           current_value.value.time->low);
break;
}
return;
}


`timescale 1ns / 1ns
module top;
tri [1:0] results;
integer test;
real foo;
time bar;
","""Example of Verilog VPI Routine Usage and a Test Module for Show_all_signals Function""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p116.jpg,True,"The image contains the following Verilog code snippet:

```verilog
initial a1: assert property(@(posedge clk) nexttime[9] !rst);
```

This is a SystemVerilog assertion checking that the `!rst` (not reset) signal is true at the next 9th rising edge of the clock `clk`.","
initial a1: assert property(@(posedge clk) nexttime[9] !rst);
","Caption: ""Understanding the 'always' property in Verilog through example and discussion on finite versus infinite traces, efficiency tips, and evaluation attempts in temporal logic.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p698.jpg,True,"This image contains text that describes elements related to Verilog, specifically about VPI reg objects. However, there is no actual code present, just explanations of various properties and functions. Here is the explanation provided in text form:

```
int vpiType         returns vpiReg or vpiRegBit
bool vpiScalar      returns true if the reg is scalar
bool vpiVector      returns true if the reg is vector
int vpiSize         returns the bit size of the reg
str vpiName         returns the declaration name of the reg
str vpiFullName     returns the full hierarchical path name of the reg
str vpiFile         returns the file name containing the reg declaration
int vpiLineNo       returns the file line number of the reg declaration
```

The numbered notes below the table:

1. Continuous assignments and primitive terminals can only be accessed from scalar or bit selects of regs, and are accessed across hierarchical boundaries.

2. For `vpiPortInst` and `vpiPort`, if reference handle is a bit, a handle for a port bit is returned; if reference handle is a vector, a handle for the port is returned.

3. For `vpiDriver` and `vpiLoad`, if the reference object is `vpiReg`, scalar and vector drivers and loads are returned. Use a `vpiRegBit` reference to access bit selects of drivers and loads.

4. For `vpiDriver` and `vpiLoad`, only active assigns and forces are returned.

5. The value of a reg is accessed using `vpi_get_value()` and `vpi_put_value()`.","iType         returns vpiReg or vpiRegBit
bool vpiScalar      returns true if the reg is scalar
bool vpiVector      returns true if the reg is vector
int vpiSize         returns the bit size of the reg
str vpiName         returns the declaration name of the reg
str vpiFullName     returns the full hierarchical path name of the reg
str vpiFile         returns the file name containing the reg declaration
int vpiLineNo       returns the file line number of the reg declaration
","""Excerpt from the Verilog PLI Handbook detailing VPI register objects and their attributes with references to page numbers.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p324.jpg,True,"The image contains a fragment of Verilog code. Here's what is written in the image:

```verilog
assert_next # (0,4,1) AB_check (clk, reset_n, A, B);
```","
assert_next # (0,4,1) AB_check (clk, reset_n, A, B);
","Caption: ""Explanation and example of Verilog assertion using assert_next for sequence event verification in Assertion-Based Design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p389.jpg,True,"The image contains a snippet of Verilog code. Here is the text version of the code:

```verilog
    cnt <= cnt - 1;
end
//You cannot read if cnt is empty; so, write only
else if (cnt<1) begin
    fifomem[wr_ptr] <= fifo_data_in;
    wr_ptr <= wr_ptr + 1;
    cnt <= cnt + 1;
end
//else write and read both
else begin
    fifomem[wr_ptr] <= fifo_data_in;
    wr_ptr <= wr_ptr + 1;
    rd_ptr <= rd_ptr + 1;
end
endcase
end

assign fifo_data_out = fifomem[rd_ptr];

endmodule
```

This excerpt of Verilog code appears to be related to a FIFO (First-In-First-Out) buffer module. The specific function of the code is to handle the counters for reading from and writing to the FIFO, adjust pointers accordingly, and manage conditions like when the FIFO is full or empty. 

The image also consists of a section titled ""LAB3: Questions"" with several checks relating to code assertions for a FIFO design, but to maintain focus, I've only provided the actual Verilog code portion above.","
    cnt <= cnt - 1;
end
//You cannot read if cnt is empty; so, write only
else if (cnt<1) begin
    fifomem[wr_ptr] <= fifo_data_in;
    wr_ptr <= wr_ptr + 1;
    cnt <= cnt + 1;
end
//else write and read both
else begin
    fifomem[wr_ptr] <= fifo_data_in;
    wr_ptr <= wr_ptr + 1;
    rd_ptr <= rd_ptr + 1;
end
endcase
end

assign fifo_data_out = fifomem[rd_ptr];

endmodule
","Caption: ""Verilog code snippet for a FIFO buffer with a list of associated assertions to verify FIFO functionality.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p318.jpg,True,"```verilog
module assert_always (clk, reset_n, test_expr);
// synopsys template
parameter severity_level = 0;
parameter options = 0;
parameter msg=""VIOLATION"";
input clk, reset_n, test_expr;

//synopsys translate_off
`ifdef ASSERT_ON
parameter assert_name = ""ASSERT_ALWAYS"";
integer error_count;
initial error_count = 0;

`include ""ovl_task.h""

`ifdef ASSERT_INIT_MSG
    initial
        ovl_init_msg;
`endif

always @ (posedge clk) begin
    `ifdef ASSERT_GLOBAL_RESET
        if (`ASSERT_GLOBAL_RESET != 1'b0) begin
    `else
        if (reset_n != 0) begin // active low reset
    `endif
        if (test_expr != 1'b1) begin
            ovl_error("""");
        end
    end
end
`endif
//synopsys translate_on
endmodule
```","
module assert_always (clk, reset_n, test_expr);
// synopsys template
parameter severity_level = 0;
parameter options = 0;
parameter msg=""VIOLATION"";
input clk, reset_n, test_expr;

//synopsys translate_off
`ifdef ASSERT_ON
parameter assert_name = ""ASSERT_ALWAYS"";
integer error_count;
initial error_count = 0;

`include ""ovl_task.h""

`ifdef ASSERT_INIT_MSG
    initial
        ovl_init_msg;
`endif

always @ (posedge clk) begin
    `ifdef ASSERT_GLOBAL_RESET
        if (`ASSERT_GLOBAL_RESET != 1'b0) begin
    `else
        if (reset_n != 0) begin // active low reset
    `endif
        if (test_expr != 1'b1) begin
            ovl_error("""");
        end
    end
end
`endif
//synopsys translate_on
endmodule
","""Verilog module for OVL assert_always definition used in assertion-based design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p277.jpg,True,"The image contains Verilog code snippets and information regarding module organization, port declarations, register declarations, and functions in Verilog. Here is the text for the code present in the image:

```verilog
module asic8 (port declarations);
    port directions
    port types (“reg” for non-tri-state outputs)
    global reg declarations
    function declarations
    always @(sensitivity_list)
        begin
            procedural statements (combinational logic)
        end
    assign statements (combinational logic)
    tri-state port driving tri statements
    storage element module instances
endmodule //asic8

module asic8 (ck,scan_in,scan_ctl,bdp,scan_out);
    input ck;
    input scan_in;
    input [7:0]scan_ctl;
    inout [1:0]bdp;
    output scan_out;
    reg scan_out;  // declare all non in-state outputs “reg”
                   // if driven by procedural assignments

    reg c_b0_bnk0_busy;  // one bit variable
    reg [7:0] r_p0_10_zone;  //8-bit variable
    reg [1:0] M_valid [0:4095]; //4096x2 memory

function [<bit_range>]function_name;
    inputs
    [local reg declarations]
    begin
        procedural statements
    end
endfunction   //function_name

function csa_s1;
    input x;
    input y;
    input z;
    begin
        csa_s1 = expression;
    end
endfunction   // csa_s1
```

The code provides examples of how to structure a Verilog module with input/output port declarations, register variable declarations, and the template for declaring a function within a module. Note that the actual code is in a plain example format with placeholders like `[<bit_range>]`, `function_name`, `expression`, which need to be replaced with actual code details in a real-world Verilog design.","
module asic8 (port declarations);
    port directions
    port types (“reg” for non-tri-state outputs)
    global reg declarations
    function declarations
    always @(sensitivity_list)
        begin
            procedural statements (combinational logic)
        end
    assign statements (combinational logic)
    tri-state port driving tri statements
    storage element module instances
endmodule //asic8

module asic8 (ck,scan_in,scan_ctl,bdp,scan_out);
    input ck;
    input scan_in;
    input [7:0]scan_ctl;
    inout [1:0]bdp;
    output scan_out;
    reg scan_out;  // declare all non in-state outputs “reg”
                   // if driven by procedural assignments

    reg c_b0_bnk0_busy;  // one bit variable
    reg [7:0] r_p0_10_zone;  //8-bit variable
    reg [1:0] M_valid [0:4095]; //4096x2 memory

function [<bit_range>]function_name;
    inputs
    [local reg declarations]
    begin
        procedural statements
    end
endfunction   //function_name

function csa_s1;
    input x;
    input y;
    input z;
    begin
        csa_s1 = expression;
    end
endfunction   // csa_s1
","Caption: ""A quick reference guide to module organization in Verilog, illustrating port declarations, register declarations and an example of a Verilog function.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p91.jpg,True,"The image contains a snippet of Verilog code, which is as follows:

```verilog
@(posedge clk)
    A=0;
    B=1;
`endif
@(negedge clk)
    $finish(2);
end
endmodule
``` 

This code appears to be part of a larger module context, which is not fully visible in the image. It shows examples of Verilog constructs for triggering actions on positive and negative clock edges and concluding with a `finish` system task.","
@(posedge clk)
    A=0;
    B=1;
`endif
@(negedge clk)
    $finish(2);
end
endmodule
","Caption: ""Extract from a textbook explaining the sampling of variables and expressions in Verilog, with example code demonstrating assertions evaluated at different clock edges.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p287.jpg,True,"The image contains Verilog code in two different examples. Below is the text from both code examples:

Example 8-2 PSL: Specification for immediate next event
```verilog
default clock = (posedge clk);
property CacheSnoopWriteback =
  always {snoop && hit_modified} |=> {writeback};
assert (CacheSnoopWriteback;
```

Example 8-3 SystemVerilog: Specification for immediate next event
```verilog
property CacheSnoopWriteback;
  always @(posedge clk) (snoop && hit_modified) |=> writeback;
endproperty
assert property (CacheSnoopWriteback);
```","
default clock = (posedge clk);
property CacheSnoopWriteback =
  always {snoop && hit_modified} |=> {writeback};
assert (CacheSnoopWriteback;


property CacheSnoopWriteback;
  always @(posedge clk) (snoop && hit_modified) |=> writeback;
endproperty
assert property (CacheSnoopWriteback);
",Educational material explaining temporal ambiguity in specifications with Verilog and PSL code examples for immediate next event scenarios.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p216.jpg,True,"The image contains examples of Verilog code, which I will transcribe for you:

First example:
```verilog
sequence s1;
  int x;
  (
    (a ##1 b, x=data)
    or
    (d ##1 e, x=data)
  )
  ##1 (data1==x)
;
endsequence
```

Second example:
```verilog
sequence s1;
  int x;
  (
    (a ##1 b, x=data)
    or
    (d ##1 e, x=data2)
  )
  ##1 (data1==x)
;
endsequence
```

Third example:
```verilog
sequence s1;
  int x;
  (
    (a ##1 b, x=data)
    and
    (d ##1 e, x=data)
  )
  ##1 (data1==x+1)
;
endsequence
```

Fourth example:
```verilog
sequence s1;
  int x;
  ((1'b1, x=data) ##0
  (
    (a ##1 b)
    and
    (d ##1 e)
  )
  ##1 (data1==x+1);
endsequence
```

This image seems to be discussing the use of local variables within composite sequences in Verilog. Each example has annotations that describe considerations when assigning local data.","
sequence s1;
  int x;
  (
    (a ##1 b, x=data)
    or
    (d ##1 e, x=data)
  )
  ##1 (data1==x)
;
endsequence


sequence s1;
  int x;
  (
    (a ##1 b, x=data)
    or
    (d ##1 e, x=data2)
  )
  ##1 (data1==x)
;
endsequence


sequence s1;
  int x;
  (
    (a ##1 b, x=data)
    and
    (d ##1 e, x=data)
  )
  ##1 (data1==x+1)
;
endsequence


sequence s1;
  int x;
  ((1'b1, x=data) ##0
  (
    (a ##1 b)
    and
    (d ##1 e)
  )
  ##1 (data1==x+1);
endsequence
","""Examples of correctly and incorrectly assigning local data in composite sequences using the Verilog language.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p202.jpg,True,"The image contains examples of Verilog code which discusses legal and illegal clocking sequences in Verilog. Here's the text of the Verilog code examples from the image:

First example:
```verilog
// ILLEGAL
sequence mclocks;
  @(posedge clk0) A ##2 (@posedge clk1) B;
  //        ^^^               ^^^
endsequence
```
Comment: This is illegal because you can't have any other clock delay except ##1 or ##0 between the two subsequences if the clocks are different on each side.

Second example:
```verilog
// ILLEGAL
sequence mclocks;
  @(posedge clk0) A ##2 (@posedge clk0) B;
  //        ^^^               ^^^
endsequence
```
Comment: This is legal because the clocks are SAME on both sides and this is equivalent to
```verilog
sequence mclocks;
  @(posedge clk0) A ##2 B;
endsequence
```

Third group of examples (all labeled as ILLEGAL):
```verilog
// ILLEGAL
@(posedge clk0) A ##2 (@posedge clk1) B;
@(posedge clk0) A intersect (@posedge clk1) B;
@(posedge clk0) A and (@posedge clk1) B;
@(posedge clk0) A or (@posedge clk1) B;
@(posedge clk0) A not (@posedge clk1) B;
```

Note: ""In short, for a 'sequence', the only operator allowed between two subsequences with different clocks is ##1 or ##0""

Property example:
```verilog
property mclocks;
  @(posedge clk1) b and (@posedge clk2) c;
endproperty

baseP: assert property (@(posedge clk0) a |=> mclocks) else gotoFail;
coverP: cover property (@(posedge clk0) a |=> mclocks) gotoPass;
```
Comment: 'B' and 'C' must be true at immediate next posedge of clk1 and clk2 respectively after the posedge of clk0

These code examples are for educational purposes showing the use of multi-clocked sequences in Verilog, specifically what is considered legal and illegal in the context of Verilog's timing and sequence constructs.","
// ILLEGAL
sequence mclocks;
  @(posedge clk0) A ##2 (@posedge clk1) B;
  //        ^^^               ^^^
endsequence


// ILLEGAL
sequence mclocks;
  @(posedge clk0) A ##2 (@posedge clk0) B;
  //        ^^^               ^^^
endsequence


sequence mclocks;
  @(posedge clk0) A ##2 B;
endsequence


// ILLEGAL
@(posedge clk0) A ##2 (@posedge clk1) B;
@(posedge clk0) A intersect (@posedge clk1) B;
@(posedge clk0) A and (@posedge clk1) B;
@(posedge clk0) A or (@posedge clk1) B;
@(posedge clk0) A not (@posedge clk1) B;


property mclocks;
  @(posedge clk1) b and (@posedge clk2) c;
endproperty

baseP: assert property (@(posedge clk0) a |=> mclocks) else gotoFail;
coverP: cover property (@(posedge clk0) a |=> mclocks) gotoPass;
",Verilog code examples demonstrating legal and illegal conditions for multiply clocked sequences and properties.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p293.jpg,True,"The image contains Verilog and PSL (Property Specification Language) code. Here is the code:

PSL code:
```
default clock = (posedge clk);

property ReqAckBusy =
  always { (rose(request) ) |-> 
  {(request & busy & !acknowledge) [*1:$];
   request & busy & acknowledge}};
   
assert ReqAckBusy;
```

SystemVerilog code:
```
property ReqAckBusy;
  @(posedge clk)
    $rose(request) |-> 
    (request & busy)[*1:$] intersect acknowledge [-1:$];
endproperty

assert property(ReqAckBusy);
```

The image also contains a waveform diagram for the signal behavior but not the waveform itself, as well as English text specifying what the code is meant to describe, but there is no machine-readable code associated with those sections.","t clock = (posedge clk);

property ReqAckBusy =
  always { (rose(request) ) |-> 
  {(request & busy & !acknowledge) [*1:$];
   request & busy & acknowledge}};
   
assert ReqAckBusy;

ty ReqAckBusy;
  @(posedge clk)
    $rose(request) |-> 
    (request & busy)[*1:$] intersect acknowledge [-1:$];
endproperty

assert property(ReqAckBusy);
","PSL and SystemVerilog assertions for signaling overlap and sequence between request, busy, and acknowledge signals.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p85.jpg,True,"```verilog
always @(posedge clk) assert property (not (FRAME__#2 IRDY));
```","
always @(posedge clk) assert property (not (FRAME__#2 IRDY));
","""Explanation of clocking basics in Verilog with a focus on concurrent assertions and the recommendation to specify the sampling edge in properties for better reusability.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p189.jpg,True,"The image includes a snippet of Verilog code, which I will transcribe for you:

```verilog
reg[7:0] Nkeeper;  // Stores 4 2-bit nn values.
reg[5:0] i;       // Indexes into a saved 64-bit SerVect vector.
reg[2:0] j;       // Counts which of 4 assumed nn's we are on.
...
FoundPads = 1'b0;
i = starting_value;
for (j=0; j<=3; j=j) // The for j increment is nonfunctional,
begin : While_i     // so, the for does not terminate this loop.
  while (1)         // Control of j will be added below.
  begin
    if ( /* six pad 0's; same as above */ )
    begin
      #1 Nkeeper[2*j+1] = SerVect[i-3]; // MSB of nn.
      #1 Nkeeper[2*j]   = SerVect[i-4]; // LSB.
      j = j + 1;
      #1 i = i - 16; // Jump ahead to the assumed next pad byte.
      #1 disable While_i;
    end // if.
    i = i - 1;
  end // while.
end // While_i block.
```

Please note that this code may be part of a larger Verilog file, and it does not represent a full program on its own. The comments suggest the presence of a larger context, including variable declarations and possibly other procedural code.","
reg[7:0] Nkeeper;  // Stores 4 2-bit nn values.
reg[5:0] i;       // Indexes into a saved 64-bit SerVect vector.
reg[2:0] j;       // Counts which of 4 assumed nn's we are on.
...
FoundPads = 1'b0;
i = starting_value;
for (j=0; j<=3; j=j) // The for j increment is nonfunctional,
begin : While_i     // so, the for does not terminate this loop.
  while (1)         // Control of j will be added below.
  begin
    if ( /* six pad 0's; same as above */ )
    begin
      #1 Nkeeper[2*j+1] = SerVect[i-3]; // MSB of nn.
      #1 Nkeeper[2*j]   = SerVect[i-4]; // LSB.
      j = j + 1;
      #1 i = i - 16; // Jump ahead to the assumed next pad byte.
      #1 disable While_i;
    end // if.
    i = i - 1;
  end // while.
end // While_i block.
",An excerpt from a textbook on Digital VLSI Design with Verilog showing the explanation and a snippet of Verilog code related to vector operations and simulation events.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p713.jpg,True,"The image contains excerpts from a reference manual for the IEEE 1364-1995 VPI (Verilog Procedural Interface) Routine Library. It describes different VPI objects related to simulation callbacks, scheduled events, and simulation time queues respectively. Below are the textual code-like details found in the image:

For VPI simulation callback objects:
```
int vpiType returns vpiCallback
```
1. Information about the callback object is accessed with `vpi_get_cb_info()`.
2. `vpi_iterate(vpiCallback, NULL)` returns an iterator for all active callbacks which have been registered using `vpi_register_cb()`.

For VPI scheduled event objects:
```
int vpiType returns vpiSchedEvent
bool vpiScheduled returns true if the event is still scheduled (it has not transpired)
```
1. A scheduled event handle is returned from `vpi_register_cb()` when the event is registered.
2. `vpi_register_cb()` can cancel a scheduled event if `vpiScheduled` is true.

For VPI simulation time queue objects:
```
int vpiType returns vpiTimeQueue
```
1. The time value of the queue is accessed using `vpi_get_time()`.
2. The time queue objects are returned in increasing order of simulation time.
3. `vpi_iterate()` returns NULL if there is nothing left in the simulation queue.

These are not complete Verilog code examples but part of the VPI interface that is used for interacting with Verilog simulators.","iType returns vpiCallback

iType returns vpiSchedEvent
bool vpiScheduled returns true if the event is still scheduled (it has not transpired)

iType returns vpiTimeQueue
","""Overview of IEEE 1364-1995 VPI Routine Library for Verilog simulation callback, scheduled event, and time queue objects.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p60.jpg,True,"The image contains two code examples written in Verilog or a similar HDL (hardware description language) syntax. Here are the codes from the image:

Example 3-9:
```verilog
ASSERT_EVENTUALLY (err_num, ck, reset_n, ev1_expr, p_expr, ev2_expr, `ASSERT_ERR_NUM);
```

Example 3-10:
```verilog
// rtl_synthesis off
`ifdef ASSERT_ON
assert_eventually err_num (ck, reset_n, ev1_expr, p_expr, ev2_expr, `ASSERT_ERR_NUM);
`endif
// rtl_synthesis on
```

This text is from a publication discussing the use of assertions in the RTL (Register Transfer Level) verification process in hardware design. It offers insights into how macros and pre-processors can be used to simplify the assertion mechanism in the design flow.","
ASSERT_EVENTUALLY (err_num, ck, reset_n, ev1_expr, p_expr, ev2_expr, `ASSERT_ERR_NUM);


// rtl_synthesis off
`ifdef ASSERT_ON
assert_eventually err_num (ck, reset_n, ev1_expr, p_expr, ev2_expr, `ASSERT_ERR_NUM);
`endif
// rtl_synthesis on
","""Verilog Assertion and Synthesis Examples""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p176.jpg,True,"```
...
reg[3:0] CountStim; // An output from this will drive Netter.
...
always@(ClockStim) #10 ClockStim <= ~ClockStim; // The clock.
always@(ClockStim) #1 CountStim <= CountStim + 1; // The counter.
...
```","g[3:0] CountStim; // An output from this will drive Netter.
...
always@(ClockStim) #10 ClockStim <= ~ClockStim; // The clock.
always@(ClockStim) #1 CountStim <= CountStim + 1; // The counter.
...
","""Exploring Verilog net behavior and drive strengths using a four-bit counter and buffers with different contention levels.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p244.jpg,True,"The image contains two snippets of Verilog code. Here they are:

Example 7-18
```verilog
genvar i;
generate for (i=0; i<16; i = i + 1)
    cover property @(posedge clk) ($rose (valid[i]));
endgenerate
```

Example 7-19
```verilog
genvar i;
generate for (i=0; i<=7; i = i + 1)
    cover property @(posedge clk) (flush & valid[i]);
endgenerate
```","
genvar i;
generate for (i=0; i<16; i = i + 1)
    cover property @(posedge clk) ($rose (valid[i]));
endgenerate


genvar i;
generate for (i=0; i<=7; i = i + 1)
    cover property @(posedge clk) (flush & valid[i]);
endgenerate
","""Excerpts from a textbook illustrating examples of SystemVerilog functional coverage for individual elements and stack flushes.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p250.jpg,True,"The image contains Verilog and PSL (Property Specification Language) code. Here's the Verilog code in the image:

```verilog
genvar i;
generate for (i=0; i<=7; i = i + 1)
  cover property (@ (posedge clk) ![cache_fill & write_hit[i]]);
endgenerate
```

Here's the PSL code in the image:

```verilog
// ensure timing between fill and hit of same line is covered (-2..2)
// request is used in the last two coverage specifications, because we
// can't hit when the fill is not done yet
cover {cache_fill; 1; hit && prev(fill_sel, 2) == line_sel};     // 2cycle
cover {cache_fill; hit && prev(fill_sel) == line_sel};            // 1cycle
cover {cache_fill && hit && fill_sel == line_sel};                // 0cycle
cover {cache_fill; hit && prev(line_sel) == fill_sel};            // 1cycle
cover {request; 1; cache_fill &&
       prev(line_sel, 2) == fill_sel};                            // 2cycle
```

These code snippets show examples for specifying functional coverage for cache events using SystemVerilog and PSL.","
genvar i;
generate for (i=0; i<=7; i = i + 1)
  cover property (@ (posedge clk) ![cache_fill & write_hit[i]]);
endgenerate


// ensure timing between fill and hit of same line is covered (-2..2)
// request is used in the last two coverage specifications, because we
// can't hit when the fill is not done yet
cover {cache_fill; 1; hit && prev(fill_sel, 2) == line_sel};     // 2cycle
cover {cache_fill; hit && prev(fill_sel) == line_sel};            // 1cycle
cover {cache_fill && hit && fill_sel == line_sel};                // 0cycle
cover {cache_fill; hit && prev(line_sel) == fill_sel};            // 1cycle
cover {request; 1; cache_fill &&
       prev(line_sel, 2) == fill_sel};                            // 2cycle
","""Examples demonstrating SystemVerilog and PSL functional coverage techniques for cache operation verification""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p278.jpg,True,"The image contains a snippet of SystemVerilog code. Here is the code as shown:

```systemverilog
genvar c, TAG;
generate for (c=1;c<=16;c= c+ 1)
  generate for (TAG=0;TAG<=9;TAG= TAG + 1)
    cover property (@(posedge clk)
    (req && req_tag == TAG ##[c] ack && ack_tag == TAG));
  endgenerate
endgenerate
```","erilog
genvar c, TAG;
generate for (c=1;c<=16;c= c+ 1)
  generate for (TAG=0;TAG<=9;TAG= TAG + 1)
    cover property (@(posedge clk)
    (req && req_tag == TAG ##[c] ack && ack_tag == TAG));
  endgenerate
endgenerate
","Caption: ""Example of SystemVerilog code for specifying functional coverage on timing between multiple requests in a register-to-done scenario.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p53.jpg,True,"The image contains examples of a VCD (Value Change Dump) file and an SDF (Standard Delay Format) file, which are text-based formats used in the context of hardware simulation and timing analysis, respectively. Here is the content from the image:

VCD file example:

```
...
$scope module TestBench $end
...
$var reg 1 * Cstim $end
$var reg 1 $ Dstim $end
$var wire 1 & Xwatch $end
$var wire 1 * C $end
...
#30
0#
#40
05
0*
...
#350
1&
...
```

The VCD example shows various declarations of scope, variables (registers and wires), and value changes at different time instances.

Here is the example of the SDF file in the image:

```
(CELL
  (CELLTYPE ""BUFFD0"")
  (INSTANCE U3)
  (DELAY
    (ABSOLUTE
      (IOPATH I Z (0.064:0.064:0.064) (0.074:0.074:0.074))
    )
  )
)
...
(INTERCONNECT U3/Z U4/A (0.002:0.002:0.002) (0.003:0.003:0.003))
```

The SDF example shows a cell of type ""BUFFD0"" with an instance labeled U3 and a delay specification, as well as an interconnect delay between two instances U3/Z and U4/A. These files are typically used in electronic design automation (EDA) for simulation and timing verification purposes.","cope module TestBench $end
...
$var reg 1 * Cstim $end
$var reg 1 $ Dstim $end
$var wire 1 & Xwatch $end
$var wire 1 * C $end
...
#30
0#
#40
05
0*
...
#350
1&
...

  (CELLTYPE ""BUFFD0"")
  (INSTANCE U3)
  (DELAY
    (ABSOLUTE
      (IOPATH I Z (0.064:0.064:0.064) (0.074:0.074:0.074))
    )
  )
)
...
(INTERCONNECT U3/Z U4/A (0.002:0.002:0.002) (0.003:0.003:0.003))
",Example of a Value Change Dump (VCD) file in Verilog for simulation data capture and Standard Delay Format (SDF) file for specifying delays in digital circuits.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p167.jpg,True,"The image contains a text segment describing some Verilog SystemVerilog Assertions (SVA) for Finite State Machines (FSMs). Two snippets of code are present:

1. A sequence declaration:
```verilog
sequence s_trans3;
  ##1 (c_state == CNT1) ##2 (c_state == CNT2)
  ##2 (c_state == CNT3) ##2 (c_state == CNT4) 
  ##2 (c_state == CNT5) ##2 (c_state == CNT6);
endsequence
```

2. A property declaration:
```verilog
property p_linear_trans;
  @(posedge clk)
    ((reset_) && (c_state == WAIT0)
    && ($past(c_state) == GEN_BLK_ADDR)) |-> s_trans3;
```

These are used for creating assertions in SystemVerilog that help verify the correct behavior of a finite state machine in simulation or formal verification.","
sequence s_trans3;
  ##1 (c_state == CNT1) ##2 (c_state == CNT2)
  ##2 (c_state == CNT3) ##2 (c_state == CNT4) 
  ##2 (c_state == CNT5) ##2 (c_state == CNT6);
endsequence


property p_linear_trans;
  @(posedge clk)
    ((reset_) && (c_state == WAIT0)
    && ($past(c_state) == GEN_BLK_ADDR)) |-> s_trans3;
","Caption: ""Verilog code segment showing a SystemVerilog Assertion (SVA) used to verify the linear transition of states in a Finite State Machine (FSM).""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p539.jpg,True,"The image contains excerpts of text and example code snippets from a book titled ""The Verilog PLI Handbook, Part Two."" Here is the code from the image:

First code snippet:
```c
handle mod_handle;

/* add code to get a module handle */

if (acc_object_of_type(mod_handle, accTopModule))
    /* process top-level modules */
else if (acc_object_of_type(mod_handle, accCellInstance))
    /* process cell-level modules */
```

Second code snippet:
```c
handle net_handle;

static int valid_types[5] = {accWand, accWor, accTriand, accTrior, 0};

/* add code to get a net handle */

if (acc_object_in_typelist(net_handle, valid_types))
    /* process wired-logic nets */
```

These code snippets are written in the C language and are intended for use with the Verilog Programming Language Interface (PLI), specifically for accessing and querying objects in a Verilog model.","e mod_handle;

/* add code to get a module handle */

if (acc_object_of_type(mod_handle, accTopModule))
    /* process top-level modules */
else if (acc_object_of_type(mod_handle, accCellInstance))
    /* process cell-level modules */

e net_handle;

static int valid_types[5] = {accWand, accWor, accTriand, accTrior, 0};

/* add code to get a net handle */

if (acc_object_in_typelist(net_handle, valid_types))
    /* process wired-logic nets */
","""Example usage of Verilog PLI routine acc_object_of_type and acc_object_in_typelist functions for handling objects and properties in Verilog simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p248.jpg,True,"```verilog
a2: assert property (
    (!req || gnt) ##1 req |-> req s_until_with gnt);
```
This is the only block of code present in the image. The rest of the text is discussing Verilog properties and temporal operators.","
a2: assert property (
    (!req || gnt) ##1 req |-> req s_until_with gnt);
","Caption: The image shows a textbook excerpt discussing advanced properties of Verilog, specifically focusing on assertions involving temporal logic operators and the concepts of bounded linear temporal operators such as nexttime.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p97.jpg,True,"The image contains Verilog code examples. Here's the code extracted from the image:

Sample 2.47 Package for ABC bus
```verilog
package ABC;
  parameter int abc_data_width = 32;
  typedef logic [abc_data_width-1:0] abc_data_t;
  parameter time timeout = 100ns;
  string message = ""ABC done"";
endpackage // ABC
```

Sample 2.48 Importing packages
```verilog
module test;
  import ABC::*; // Search ABC for symbols
  
  abc_data_t data; // From package ABC
  string message = ""Test timed out""; // Hides message in ABC
  
  initial begin
    #(timeout); // From package ABC
    $display(""Timeout - %s"", message);
    $finish;
  end
endmodule
```","
package ABC;
  parameter int abc_data_width = 32;
  typedef logic [abc_data_width-1:0] abc_data_t;
  parameter time timeout = 100ns;
  string message = ""ABC done"";
endpackage // ABC


module test;
  import ABC::*; // Search ABC for symbols
  
  abc_data_t data; // From package ABC
  string message = ""Test timed out""; // Hides message in ABC
  
  initial begin
    #(timeout); // From package ABC
    $display(""Timeout - %s"", message);
    $finish;
  end
endmodule
","Caption: ""This image showcases excerpts from a textbook or reference material explaining how to work with packages in SystemVerilog, including the creation and importing of a package containing parameters and types for a bus interface.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p244.jpg,True,"The image contains Verilog code as part of a text explaining a concept of random strobe waveform generation. Here is the code from the image:

```verilog
class StrobePat;
  rand bit strobe[10];
  constraint c_set_four { strobe.sum() == 4'h4; }
endclass

initial begin
  StrobePat sp;
  int count = 0;  // Index into data array

  sp = new();
  `SV_RAND_CHECK(sp.randomize());

  foreach (sp.strobe[i]) begin
    ##1 bus.cb.strobe <= sp.strobe[i];
    // If strobe is enabled, drive out next data word
    if (sp.strobe[i])
      bus.cb.data <= data[count++];
  end
end
```

The code snippet demonstrates the use of constraints to generate random strobe patterns with four bits set in Verilog.","
class StrobePat;
  rand bit strobe[10];
  constraint c_set_four { strobe.sum() == 4'h4; }
endclass

initial begin
  StrobePat sp;
  int count = 0;  // Index into data array

  sp = new();
  `SV_RAND_CHECK(sp.randomize());

  foreach (sp.strobe[i]) begin
    ##1 bus.cb.strobe <= sp.strobe[i];
    // If strobe is enabled, drive out next data word
    if (sp.strobe[i])
      bus.cb.data <= data[count++];
  end
end
","Caption: ""Example of a SystemVerilog class for generating random strobe patterns with constrained randomization.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p250.jpg,True,"The image contains Verilog code, which is a hardware description language used to model electronic systems. Here's the code from the image:

```verilog
class UniqueArray;
    int max_array_size, max_value;
    rand bit [15:0] ua[];
    // Array of unique values
    constraint c_size {ua.size() inside {[1:max_array_size]};}

    function new(input int max_array_size=2, max_value=2);
        this.max_array_size = max_array_size;
        // If max_value is smaller than max array size,
        // array could have duplicates, so adjust max_value
        if (max_value < max_array_size)
            this.max_value = max_array_size;
        else
            this.max_value = max_value;
    endfunction

    // Array a[] allocated in randomize(), fill w/unique vals
    function void post_randomize();
        RandCrange rr;
        rr = new(max_value);
        foreach (ua[i]) begin
            `SV_RAND_CHECK(rr.randomize());
            ua[i] = rr.value;
        end
    endfunction

    function void display();
        $write(""Size: %3d:"", ua.size());
        foreach (ua[i]) $write(""%4d"", ua[i]);
        $display;
    endfunction
endclass

program automatic test;
    UniqueArray ua;
    initial begin
        ua = new(50); // Max array size = 50
        repeat (10) begin
            `SV_RAND_CHECK(ua.randomize()); // Create random array
            ua.display(); // Display values
        end
    end
endprogram
```

This code snippet provides an example of a class (`UniqueArray`) in Verilog designed to generate a random array of unique integers and a test program (`test`) that creates an instance of the class and displays the randomized contents.","
class UniqueArray;
    int max_array_size, max_value;
    rand bit [15:0] ua[];
    // Array of unique values
    constraint c_size {ua.size() inside {[1:max_array_size]};}

    function new(input int max_array_size=2, max_value=2);
        this.max_array_size = max_array_size;
        // If max_value is smaller than max array size,
        // array could have duplicates, so adjust max_value
        if (max_value < max_array_size)
            this.max_value = max_array_size;
        else
            this.max_value = max_value;
    endfunction

    // Array a[] allocated in randomize(), fill w/unique vals
    function void post_randomize();
        RandCrange rr;
        rr = new(max_value);
        foreach (ua[i]) begin
            `SV_RAND_CHECK(rr.randomize());
            ua[i] = rr.value;
        end
    endfunction

    function void display();
        $write(""Size: %3d:"", ua.size());
        foreach (ua[i]) $write(""%4d"", ua[i]);
        $display;
    endfunction
endclass

program automatic test;
    UniqueArray ua;
    initial begin
        ua = new(50); // Max array size = 50
        repeat (10) begin
            `SV_RAND_CHECK(ua.randomize()); // Create random array
            ua.display(); // Display values
        end
    end
endprogram
","""Verilog Class Example for Generating a Random Array of Unique Values""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p72.jpg,True,"```verilog
module procReq(input logic req, gnt, clk);
  logic allow;
  wire proceed;
  assign proceed = allow && gnt;
  always @(posedge clk) allow <= req;
  always @(posedge proceed) processData();
  always @ (property(@(posedge clk) req |=> proceed || !gnt));
endmodule : procReq

program test(output logic request, grant, sync);
  logic oldreq = 1'b0;
  assign grant = oldreq;
  initial begin
    request = 1'b0;
    sync <= 1'b0;
    for (int i = 0; i < 100; i++) begin
      #5 sync <= !sync;
      if (i % 2) begin
        oldreq <= request;
        request <= $random;
      end
    end
  end
endprogram : test

module top();
  logic r, g, c;
  procReq dut(r, g, c);
  test tb(r, g, c);
endmodule : top
```","
module procReq(input logic req, gnt, clk);
  logic allow;
  wire proceed;
  assign proceed = allow && gnt;
  always @(posedge clk) allow <= req;
  always @(posedge proceed) processData();
  always @ (property(@(posedge clk) req |=> proceed || !gnt));
endmodule : procReq

program test(output logic request, grant, sync);
  logic oldreq = 1'b0;
  assign grant = oldreq;
  initial begin
    request = 1'b0;
    sync <= 1'b0;
    for (int i = 0; i < 100; i++) begin
      #5 sync <= !sync;
      if (i % 2) begin
        oldreq <= request;
        request <= $random;
      end
    end
  end
endprogram : test

module top();
  logic r, g, c;
  procReq dut(r, g, c);
  test tb(r, g, c);
endmodule : top
","""Exploring SystemVerilog's Simulation Semantics and Clock Generation in Reactive Regions with Verilog Code Examples""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p83.jpg,True,"The image contains an excerpt of Verilog code related to associative arrays. Here is the code displayed in the image:

```verilog
byte assoc[byte], idx = 1;
initial begin
  // Initialize widely scattered values
  do begin
    assoc[idx] = idx;
    idx = idx << 1;
  end while (idx != 0);

  // Step through all index values with foreach
  foreach (assoc[i])
    $display(""assoc[%h] = %h"", i, assoc[i]);

  // Step through all index values with functions
  if (assoc.first(idx))  // Get first index
    do
      $display(""assoc[%h]=%h"", idx, assoc[idx]);
    while (assoc.next(idx)); // Get next index

  // Find and delete the first element
  void'(assoc.first(idx));
  void'(assoc.delete(idx));
  $display(""The array now has %0d elements"", assoc.num());
end
```

This snippet demonstrates declaring, initializing, and using associative arrays in Verilog. It includes examples of how to initialize values, iterate over elements using a `foreach` loop, access elements using `first` and `next` built-in functions, and delete an element from the associative array. The code also shows how to output the number of elements currently in the associative array using `assoc.num()`.","
byte assoc[byte], idx = 1;
initial begin
  // Initialize widely scattered values
  do begin
    assoc[idx] = idx;
    idx = idx << 1;
  end while (idx != 0);

  // Step through all index values with foreach
  foreach (assoc[i])
    $display(""assoc[%h] = %h"", i, assoc[i]);

  // Step through all index values with functions
  if (assoc.first(idx))  // Get first index
    do
      $display(""assoc[%h]=%h"", idx, assoc[idx]);
    while (assoc.next(idx)); // Get next index

  // Find and delete the first element
  void'(assoc.first(idx));
  void'(assoc.delete(idx));
  $display(""The array now has %0d elements"", assoc.num());
end
","An excerpt from a textbook on Verilog demonstrating the use of associative arrays, including the declaration, initialization, and iteration of such arrays in Verilog code.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p173.jpg,True,"The image contains Verilog code for what appears to be a finite state machine. Here is the code:

```verilog
IDLE:
  if (req1 == 1'b0)
    next <= MASTER1;
  else if (req1 == 1'b1 & req2 == 1'b0)
    next <= MASTER2;
  else if (req3 == 1'b0 & req1 == 1'b1)
    next <= MASTER3;
  else
    next <= IDLE;

MASTER1:
  if (!done)
    next <= MASTER1;
  else
    next <= IDLE1;

IDLE1:
  if (req2 == 1'b0 )
    next <= MASTER2;
  else if (req3 == 1'b0 & req2 == 1'b1)
    next <= MASTER3;
  else if (req3 == 1'b1 & req1 == 1'b0 & req2 == 1'b1)
    next <= MASTER1;
  else
    next <= IDLE1;

MASTER2:
  if (!done)
    next <= MASTER2;
  else
    next <= IDLE2;

IDLE2:
  if (req3 == 1'b0)
    next <= MASTER3;
  else if (req3 == 1'b1 & req1 == 1'b0)
    next <= MASTER1;
  else if (req1 == 1'b1 & req2 == 1'b0)
    next <= MASTER2;
  else
    next <= IDLE2;
```

This code shows various states and transitions based on conditions related to the signals `req1`, `req2`, `req3`, and `done`. The state transitions are determined by the if-else constructs and the binary conditions inside them.","
IDLE:
  if (req1 == 1'b0)
    next <= MASTER1;
  else if (req1 == 1'b1 & req2 == 1'b0)
    next <= MASTER2;
  else if (req3 == 1'b0 & req1 == 1'b1)
    next <= MASTER3;
  else
    next <= IDLE;

MASTER1:
  if (!done)
    next <= MASTER1;
  else
    next <= IDLE1;

IDLE1:
  if (req2 == 1'b0 )
    next <= MASTER2;
  else if (req3 == 1'b0 & req2 == 1'b1)
    next <= MASTER3;
  else if (req3 == 1'b1 & req1 == 1'b0 & req2 == 1'b1)
    next <= MASTER1;
  else
    next <= IDLE1;

MASTER2:
  if (!done)
    next <= MASTER2;
  else
    next <= IDLE2;

IDLE2:
  if (req3 == 1'b0)
    next <= MASTER3;
  else if (req3 == 1'b1 & req1 == 1'b0)
    next <= MASTER1;
  else if (req1 == 1'b1 & req2 == 1'b0)
    next <= MASTER2;
  else
    next <= IDLE2;
","""Example of Verilog state machine code for handling multiple request signals and state transitions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p47.jpg,True,"The image contains Verilog code. Here's the code that is visible:

```verilog
module VectorExamples ( output[7:0] OutHigh, OutLow1, OutLow2
                        , output OutBit, input ClockIn, ...(other inputs)...
                        );
reg[7:0] HighByte, LowByte1, LowByte2;
reg Bit;
// The below continuous assigns go near here.
...
// Other stuff.
HighByte = LowByte1; // Assigns one vector to another.
Bit = LowByte2[7];   // This is called a ""bit select"".
LowByte2[3:0] = LowByte2[7:4]; // Two ""part selects"".
...
// Other stuff.
endmodule

The actual, omitted controlling statements of the above might be as follows:

assign OutHigh = HighByte; // Four continuous assignments shown here.
assign OutLow1 = LowByte1;
assign OutLow2 = LowByte2;
assign OutBit = Bit;
... (various assignments, etc.) ...
always @ (posedge ClockIn) // LowByte1 is not assigned here.
begin
HighByte = LowByte1;
Bit = LowByte2[7];
LowByte2[3:0] = LowByte2[7:4];
end
```

The text also offers a comparison between Verilog and C or C++ data type declarations and some explanations about the 'reg' keyword in Verilog, but only the actual code segments have been provided above.","
module VectorExamples ( output[7:0] OutHigh, OutLow1, OutLow2
                        , output OutBit, input ClockIn, ...(other inputs)...
                        );
reg[7:0] HighByte, LowByte1, LowByte2;
reg Bit;
// The below continuous assigns go near here.
...
// Other stuff.
HighByte = LowByte1; // Assigns one vector to another.
Bit = LowByte2[7];   // This is called a ""bit select"".
LowByte2[3:0] = LowByte2[7:4]; // Two ""part selects"".
...
// Other stuff.
endmodule

The actual, omitted controlling statements of the above might be as follows:

assign OutHigh = HighByte; // Four continuous assignments shown here.
assign OutLow1 = LowByte1;
assign OutLow2 = LowByte2;
assign OutBit = Bit;
... (various assignments, etc.) ...
always @ (posedge ClockIn) // LowByte1 is not assigned here.
begin
HighByte = LowByte1;
Bit = LowByte2[7];
LowByte2[3:0] = LowByte2[7:4];
end
","Verilog code example illustrating the use of reg, wire, continuous assignments, and procedural assignments in digital logic design.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p505.jpg,True,"The image contains a snippet of Verilog code along with some explanatory text about the ACC Routine Library and the traversal of hierarchy across module ports in Verilog. Here is the Verilog code from the image:

```verilog
module_h = acc_handle_tfarg(1);
io_printf(""\nOutput ports with path delays in module %s:\n"",
          acc_fetch_defname(module_h));

modpath_h = pathterm_h = net_h = port_h = null;
while (modpath_h = acc_next_modpath(module_h, modpath_h)) {
    while (pathterm_h = acc_next_output(modpath_h, pathterm_h)) {
        net_h = acc_handle_conn(pathterm_h);
        while (port_h = acc_next_port(net_h, port_h)) {
            io_printf("" Port %s\n"", acc_fetch_name(port_h));
        }
    }
}
acc_close();
return(0);
```

Below the code, there is a Verilog module declaration for explanatory purposes related to the text:

```verilog
module dff (clk, d, q, qb);
input clk, d;
output q, qb;
wire clk, d, q, qb;
...
endmodule
```

And the relevant accompanying text refers to the concept of `loconn` (hierarchically lower connection) and `hiconn` (hierarchically higher connection) in the context of module port connections in Verilog.","
module_h = acc_handle_tfarg(1);
io_printf(""\nOutput ports with path delays in module %s:\n"",
          acc_fetch_defname(module_h));

modpath_h = pathterm_h = net_h = port_h = null;
while (modpath_h = acc_next_modpath(module_h, modpath_h)) {
    while (pathterm_h = acc_next_output(modpath_h, pathterm_h)) {
        net_h = acc_handle_conn(pathterm_h);
        while (port_h = acc_next_port(net_h, port_h)) {
            io_printf("" Port %s\n"", acc_fetch_name(port_h));
        }
    }
}
acc_close();
return(0);


module dff (clk, d, q, qb);
input clk, d;
output q, qb;
wire clk, d, q, qb;
...
endmodule
","""Exploring the ACC Routine Library in Verilog and Understanding Module Port Hierarchies.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p72.jpg,True,"```
a or
(a ##1 a) or
(a ##1 a ##1 a) or
```","a ##1 a) or
(a ##1 a ##1 a) or
",Waveform analysis and discussion of consecutive repetition using SystemVerilog Assertions (SVA).,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p278.jpg,True,"The image contains a code sample written in the context of SystemVerilog, a hardware description and verification language. Here is the code text from the image:

```verilog
Sample 7.14 Using wait fork to wait for child threads

task run_threads();
    ...
    // Create some transactions
    fork
        check_trans(tr1); // Spawn first thread
        check_trans(tr2); // Spawn second thread
        check_trans(tr3); // Spawn third thread
    join_none
    ...
    // Do some other work

// Now wait for the above threads to complete
wait fork;
endtask
``` 

This code snippet is demonstrating the use of `wait fork` to synchronize threads created by the `fork...join_none` construct in SystemVerilog. After spawning three threads that presumably perform checks on transactions (`check_trans`), the process does other work and later uses `wait fork;` to wait for the completion of those threads before the `endtask`.","
Sample 7.14 Using wait fork to wait for child threads

task run_threads();
    ...
    // Create some transactions
    fork
        check_trans(tr1); // Spawn first thread
        check_trans(tr2); // Spawn second thread
        check_trans(tr3); // Spawn third thread
    join_none
    ...
    // Do some other work

// Now wait for the above threads to complete
wait fork;
endtask
","""Example of using fork-join_none and wait fork constructs for thread synchronization in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p263.jpg,True,"```c
ALUData->a_h = vpi_scan(arg_itr); /* 2nd arg is a input */
ALUData->b_h = vpi_scan(arg_itr); /* 3rd arg is b input */
ALUData->opcode_h = vpi_scan(arg_itr); /* 4th arg is opcode input */
ALUData->result_h = vpi_scan(arg_itr); /* 5th arg is result output */
ALUData->excep_h = vpi_scan(arg_itr); /* 6th arg is excep output */
ALUData->err_h = vpi_scan(arg_itr); /* 7th arg is error output */
vpi_free_object(arg_itr); /* free iterator--did not scan to null */

/* setup value change callback options */
time_s.type = vpiSuppressTime;
cb_data_s.reason = cbValueChange;
cb_data_s.cb_rtn = PLIbook_ScientificALU_interface;
cb_data_s.time = &time_s;
cb_data_s.value = &value_s;

/* add value change callbacks to clock input to the C model, */
/* pass pointer to storage for handles as user_data value */
value_s.format = vpiSuppressVal;
cb_data_s.user_data = (char *)ALUData;
cb_data_s.obj = ALUData->clock_h;
vpi_register_cb(&cb_data_s);

return(0);
```
This is the Verilog code snippet displayed in the image. It's a segment of code concerning interfacing to C models using VPI routines in Verilog.","ta->a_h = vpi_scan(arg_itr); /* 2nd arg is a input */
ALUData->b_h = vpi_scan(arg_itr); /* 3rd arg is b input */
ALUData->opcode_h = vpi_scan(arg_itr); /* 4th arg is opcode input */
ALUData->result_h = vpi_scan(arg_itr); /* 5th arg is result output */
ALUData->excep_h = vpi_scan(arg_itr); /* 6th arg is excep output */
ALUData->err_h = vpi_scan(arg_itr); /* 7th arg is error output */
vpi_free_object(arg_itr); /* free iterator--did not scan to null */

/* setup value change callback options */
time_s.type = vpiSuppressTime;
cb_data_s.reason = cbValueChange;
cb_data_s.cb_rtn = PLIbook_ScientificALU_interface;
cb_data_s.time = &time_s;
cb_data_s.value = &value_s;

/* add value change callbacks to clock input to the C model, */
/* pass pointer to storage for handles as user_data value */
value_s.format = vpiSuppressVal;
cb_data_s.user_data = (char *)ALUData;
cb_data_s.obj = ALUData->clock_h;
vpi_register_cb(&cb_data_s);

return(0);
","Caption: ""Example of Verilog code interfacing with C models using VPI routines, illustrating setup for value change callback options and synchronization strategies at the end of a simulation time step.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p274.jpg,True,"The image contains Verilog code. Here it is:

```verilog
checker toggle_check(sequence stop_check, start_check,
                     event clk = $inferred_clock);
  bit rst = 1;
  default clocking @clk; endclocking
  default disable iff rst;
  
  always @clk begin
    if (stop_check.triggered) rst <= 1'b1;
    else if (start_check.triggered) rst <= 1'b0;
  end
  
a1: assert property(...);
// More assertions here ...
endchecker : toggle_check
```

The code is an example of disabling checking assertions in a checker between the match points of sequences `stop_check` and `start_check`.","
checker toggle_check(sequence stop_check, start_check,
                     event clk = $inferred_clock);
  bit rst = 1;
  default clocking @clk; endclocking
  default disable iff rst;
  
  always @clk begin
    if (stop_check.triggered) rst <= 1'b1;
    else if (start_check.triggered) rst <= 1'b0;
  end
  
a1: assert property(...);
// More assertions here ...
endchecker : toggle_check
","Caption: ""Using the triggered method in SystemVerilog for safe checker variable assignments within sequences.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p260.jpg,True,"The image contains Verilog code examples, specifically assertions using SystemVerilog property specification constructs, as follows:

```verilog
a1: assert property(start_t |=> (!end_t throughout (!sent[*] ##1 sent) [*4] ##1 !sent[*]) ##1 end_t);

a2: assert property(start_t |=> (!end_t throughout sent[*-4] ##1 !sent[*]) ##1 end_t);
```

And another example:

```verilog
a3: assert property(
    start_t |=> (!end_t throughout sent[=4]) ##1 end_t);
```

And there's an assertion without the complete context, but it shows an example of how it can be used:

```verilog
a1 assert property(
    start_t |=> (!end_t throughout sent[=2:4]) ##1 end_t);
```

These code snippets are used to demonstrate various use cases of assertions in Verilog for scenarios involving sequences and repetition.","
a1: assert property(start_t |=> (!end_t throughout (!sent[*] ##1 sent) [*4] ##1 !sent[*]) ##1 end_t);

a2: assert property(start_t |=> (!end_t throughout sent[*-4] ##1 !sent[*]) ##1 end_t);


a3: assert property(
    start_t |=> (!end_t throughout sent[=4]) ##1 end_t);


a1 assert property(
    start_t |=> (!end_t throughout sent[=2:4]) ##1 end_t);
","""Verilog code examples demonstrating the use of assertion properties with consecutive and nonconsecutive repetition in sequence expressions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p66.jpg,True,"```verilog
$spast(signal_name, number of clock cycles, gating signal)

Property p20;
@(posedge clk) (c && d) |-> ($past((a&&b), 2, e) == 1'b1);
endproperty

a20: assert property(p20);
```","
$spast(signal_name, number of clock cycles, gating signal)

Property p20;
@(posedge clk) (c && d) |-> ($past((a&&b), 2, e) == 1'b1);
endproperty

a20: assert property(p20);
","""Explanation of the $past construct in SystemVerilog Assertion (SVA) with an example of code and truth table.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p412.jpg,True,"The image contains an excerpt from a book related to ""Digital VLSI Design with Verilog"" and features a snippet of Verilog code. Here is the code provided in the image:

```verilog
module SerialRx(output SerClk, SerData
                input SerLinkIn, ParClk, Reset
                );
assign SerData = SerLinkIn;
// 
PLLTop PLL_RxU1 (.ClockOut(SerClk), .ClockIn(ParClk), .Reset(Reset));
//
endmodule // SerialRx.
``` 

Note: The code snippet seems to have an issue with the syntax. There should be a comma after `SerData` in the module port list before the `input` keyword, and the `input` keyword is missing a colon before it. Here is the corrected version:

```verilog
module SerialRx(output SerClk, SerData,
                input SerLinkIn, ParClk, Reset
                );
assign SerData = SerLinkIn;
// 
PLLTop PLL_RxU1 (.ClockOut(SerClk), .ClockIn(ParClk), .Reset(Reset));
//
endmodule // SerialRx.
```","
module SerialRx(output SerClk, SerData
                input SerLinkIn, ParClk, Reset
                );
assign SerData = SerLinkIn;
// 
PLLTop PLL_RxU1 (.ClockOut(SerClk), .ClockIn(ParClk), .Reset(Reset));
//
endmodule // SerialRx.


module SerialRx(output SerClk, SerData,
                input SerLinkIn, ParClk, Reset
                );
assign SerData = SerLinkIn;
// 
PLLTop PLL_RxU1 (.ClockOut(SerClk), .ClockIn(ParClk), .Reset(Reset));
//
endmodule // SerialRx.
","""Instructions and code snippet from a digital VLSI design course detailing steps to set up a deserializer structure using Verilog, including a code example for a SerialRx module.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p287.jpg,True,"The image contains Verilog code, which I will transcribe below:

```verilog
program automatic test;

class Generator;
    event done;
    function new (input event done); // Pass event from TB
        this.done = done;
    endfunction

    task run();
        fork
            begin
                ...
                -> done; // Tell the test we are done
            end
        join_none
    endtask
endclass

event gen_done;
Generator gen;

initial begin
    gen = new(gen_done); // Instantiate testbench
    gen.run(); // Run transactor
    wait(gen_done.triggered); // Wait for finish
end
endprogram
```

This code snippet appears to show a testbench setup in Verilog where a `Generator` class with an `event` and `run` task is defined. An instance of `Generator` is then created and used to synchronize the end of some process with a `done` event.","
program automatic test;

class Generator;
    event done;
    function new (input event done); // Pass event from TB
        this.done = done;
    endfunction

    task run();
        fork
            begin
                ...
                -> done; // Tell the test we are done
            end
        join_none
    endtask
endclass

event gen_done;
Generator gen;

initial begin
    gen = new(gen_done); // Instantiate testbench
    gen.run(); // Run transactor
    wait(gen_done.triggered); // Wait for finish
end
endprogram
","Caption: ""Verilog example showing how to pass an event into a constructor and use it to signal the completion of a task within a testbench environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p288.jpg,True,"The image contains Verilog code. Here is the text of the code provided in the image:

```verilog
`timescale 1ns / 1ns
module test;
  reg a, b, ci, clk;
  wire sum, co;
  addbit i1 (a, b, ci, sum, co);
  initial
  begin
    clk = 0;
    a = 0;
    b = 0;
    ci = 0;
    #10 a = 1;
    #10 b = 1;

    $show_value(sum);
    $show_value(co);
    $show_value(i1.n3);

    #10 $stop;
    $finish;
  end
endmodule

/*** A gate level 1 bit adder model ***/
`timescale 1ns / 1ns
module addbit (a, b, ci, sum, co);
  input a, b, ci;
  output sum, co;
  wire a, b, ci, sum, co,
```

(Note: The code snippet seems to be cut off at the bottom of the image, so it is incomplete. There would typically be additional lines that define the behavior of the ""addbit"" module.)","
`timescale 1ns / 1ns
module test;
  reg a, b, ci, clk;
  wire sum, co;
  addbit i1 (a, b, ci, sum, co);
  initial
  begin
    clk = 0;
    a = 0;
    b = 0;
    ci = 0;
    #10 a = 1;
    #10 b = 1;

    $show_value(sum);
    $show_value(co);
    $show_value(i1.n3);

    #10 $stop;
    $finish;
  end
endmodule

/*** A gate level 1 bit adder model ***/
`timescale 1ns / 1ns
module addbit (a, b, ci, sum, co);
  input a, b, ci;
  output sum, co;
  wire a, b, ci, sum, co,
","Caption: ""Example of Verilog HDL test case using the $show_value PLI application, demonstrating a 1-bit adder simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p293.jpg,True,"The image contains Verilog code related to system-level modeling for generating and driving transactions using mailboxes in a testbench environment. The following is the code from the image:

**For Sample 7.33: Good generator creates many objects**
```verilog
task generator_good(input int n,
                    input mailbox #(Transaction) mbx);
    Transaction tr;
    repeat (n) begin
        tr = new(); // Create a new transaction
        `SV_RAND_CHECK(tr.randomize());
        $display(""GEN: Sending addr=%h"", tr.addr);
        mbx.put(tr); // Send transaction to driver
    end
endtask
```

**For Sample 7.34: Good driver receives transactions from mailbox**
```verilog
task driver(input mailbox #(Transaction) mbx);
    Transaction tr;
    forever begin
        mbx.get(tr); // Get transaction from mailbox
        $display(""DRV: Received addr=%h"", tr.addr);
        // Drive transaction into DUT
    end
endtask
```

These code samples demonstrate how to properly create and send transactions (objects) to a driver through a mailbox (a construct used for interprocess communication) in SystemVerilog.","
task generator_good(input int n,
                    input mailbox #(Transaction) mbx);
    Transaction tr;
    repeat (n) begin
        tr = new(); // Create a new transaction
        `SV_RAND_CHECK(tr.randomize());
        $display(""GEN: Sending addr=%h"", tr.addr);
        mbx.put(tr); // Send transaction to driver
    end
endtask


task driver(input mailbox #(Transaction) mbx);
    Transaction tr;
    forever begin
        mbx.get(tr); // Get transaction from mailbox
        $display(""DRV: Received addr=%h"", tr.addr);
        // Drive transaction into DUT
    end
endtask
","""Verilog code example illustrating the use of a mailbox in threads and interprocess communication to handle multiple transactions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p406.jpg,True,"The image contains a snippet of Verilog code as follows:

```verilog
`include ""Deserial.inc""
module PLLTopTst;
reg ClockStimIn, ClearStim, SamplePLLr;
wire PLLClockWatch;
// 
always@(ClockStimIn)
  // HalfPeriod32BitBus ClockStimIn <= ~ClockStimIn;
// 
always@(posedge ClockStimIn, posedge ClearStim)
begin : Sampler
  if (ClearStim=='b1)
    SamplePLLr = 'b0';
  else begin
    #50 SamplePLLr = '1'b1;
    #100 SamplePLLr = '1'b0;
  end
end
// 
initial
begin
  #0    ClearStim   = '1'b0; // #0 only required if '1'b1 init.
  #0    ClockStimIn = '1'b0; // ditto.
  #1    ClearStim   = '1'b1;
  #9    ClearStim   = '1'b0;
  #10   ClockStimIn = '1'b1; // Forces a phase change.
  #465  ClearStim   = '1'b1;
  #500  ClearStim   = '1'b0;
  #500  ClearStim   = '1'b1;
  #500  ClearStim   = '1'b0;
  #25000 $finish;
end
// 
PLLTop PLL_u1 ( .ClockOut(PLLClockOut), .ClockIn(ClockStimIn)
              , .Sample(SamplePLLr), .Reset(ClearStim) );
// 
endmodule // PLLTopTst.
```

Please note that the code above includes a filename `Deserial.inc` with backtick-include directive, defines a module `PLLTopTst`, declares some registers and a wire, contains `always` blocks, an `initial` block, and instantiates a module `PLLTop`. It seems to be part of a testbench for simulating a Phase-Locked Loop (PLL) in a Digital VLSI design context.","
`include ""Deserial.inc""
module PLLTopTst;
reg ClockStimIn, ClearStim, SamplePLLr;
wire PLLClockWatch;
// 
always@(ClockStimIn)
  // HalfPeriod32BitBus ClockStimIn <= ~ClockStimIn;
// 
always@(posedge ClockStimIn, posedge ClearStim)
begin : Sampler
  if (ClearStim=='b1)
    SamplePLLr = 'b0';
  else begin
    #50 SamplePLLr = '1'b1;
    #100 SamplePLLr = '1'b0;
  end
end
// 
initial
begin
  #0    ClearStim   = '1'b0; // #0 only required if '1'b1 init.
  #0    ClockStimIn = '1'b0; // ditto.
  #1    ClearStim   = '1'b1;
  #9    ClearStim   = '1'b0;
  #10   ClockStimIn = '1'b1; // Forces a phase change.
  #465  ClearStim   = '1'b1;
  #500  ClearStim   = '1'b0;
  #500  ClearStim   = '1'b1;
  #500  ClearStim   = '1'b0;
  #25000 $finish;
end
// 
PLLTop PLL_u1 ( .ClockOut(PLLClockOut), .ClockIn(ClockStimIn)
              , .Sample(SamplePLLr), .Reset(ClearStim) );
// 
endmodule // PLLTopTst.
","""Example of a Verilog Testbench Module for PLL (Phase-Locked Loop) Simulation""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p99.jpg,True,"The image contains Verilog code examples. Here is the code present in the image:

```verilog
sequence s_multiple_clocks_illegal1;
    @(posedge clk1) a ##0 @(posedge clk2) b;
endsequence

sequence s_multiple_clocks_illegal2;
    @(posedge clk1) a ##2 @(posedge clk2) b;
endsequence

property p_multiple_clocks;
    @(posedge clk1) s1 ##1 @(posedge clk2) s2;
endproperty

property p_multiple_clocks_implied;
    @(posedge clk1) s1 |=> @(posedge clk2) s2;
endproperty
```","
sequence s_multiple_clocks_illegal1;
    @(posedge clk1) a ##0 @(posedge clk2) b;
endsequence

sequence s_multiple_clocks_illegal2;
    @(posedge clk1) a ##2 @(posedge clk2) b;
endsequence

property p_multiple_clocks;
    @(posedge clk1) s1 ##1 @(posedge clk2) s2;
endproperty

property p_multiple_clocks_implied;
    @(posedge clk1) s1 |=> @(posedge clk2) s2;
endproperty
","Caption: ""Constraints on using multiple clocks in Verilog sequences and properties, illustrating illegal examples and explanations of correct usage.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p99.jpg,True,"There is some Verilog code in the image. Here it is:

```verilog
logic [15:0] aA [4], aB[4];
a1: assert property (@(posedge clk) (aA == aB));
```

This snippet defines two 4-element arrays of 16-bit logic vectors `aA` and `aB` and uses a concurrent assertion to check if `aA` is equal to `aB` at the rising edge of the clock signal `clk`.","
logic [15:0] aA [4], aB[4];
a1: assert property (@(posedge clk) (aA == aB));
",Textbook page explaining the constraints on Boolean expressions in concurrent assertions in SystemVerilog.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p199.jpg,True,"```verilog
property p_mutex;
  @(posedge clk) ((reset_) |-> not (done_frame && get_data));
endproperty
a_mutex: assert property(p_mutex);
```","
property p_mutex;
  @(posedge clk) ((reset_) |-> not (done_frame && get_data));
endproperty
a_mutex: assert property(p_mutex);
","Caption: ""Verilog code snippet illustrating a SystemVerilog Assertion (SVA) checker for mutual exclusivity of 'get_data' and 'done_frame' signals in a JPEG design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p349.jpg,True,"The image contains some Verilog code. Here it is transcribed for you:

```verilog
module Wide(output[95:0] OutWide, input[71:0] InWide);
endmodule
module Narrow(output[1:0] OutNarrow, input[1:0] InNarrow);
endmodule
module Bit(output Out, input In);
endmodule
```

And the code for Step 2 is:

```verilog
module Narrow(output[1:0] OutNarrow, input[1:0] InNarrow);
   Bit Bit1( .Out(OutNarrow), .In(InNarrow) );
endmodule
```

Remember that this is part of a lab exercise related to Verilog Hierarchy, specifically for a task to connect signals of different bit-widths in a module hierarchy and dealing with synchronization across clock domains.","
module Wide(output[95:0] OutWide, input[71:0] InWide);
endmodule
module Narrow(output[1:0] OutNarrow, input[1:0] InNarrow);
endmodule
module Bit(output Out, input In);
endmodule


module Narrow(output[1:0] OutNarrow, input[1:0] InNarrow);
   Bit Bit1( .Out(OutNarrow), .In(InNarrow) );
endmodule
","Excerpt from a digital design textbook or lab manual discussing the concepts of bus routing in hierarchical Verilog modules and addressing synchronization issues across different clock domains, including an example Verilog code snippet defining simple modules.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p98.jpg,True,"The image contains Verilog code. Here is the code:

```verilog
module reggen(input logic busy, clk, rst, output logic req);
  wire idle;
  assign idle = !busy;

  always @(posedge clk or posedge rst) begin
    if (rst) req <= '0';
    else req <= !busy;
  end

  req_when_idle: assert property (
    @(posedge clk) disable iff (rst) idle |=> req)
    $display(""req_when_idle completed"");
  endmodule : reggen
```

This Verilog module is demonstrating an example of `disable iff`. It describes a hardware component named `reggen` with input signals `busy`, `clk`, and `rst`, and an output signal `req`. The module includes a process block that updates `req` on positive edges of `clk` or `rst` depending on the state of the reset signal `rst` and the `busy` signal. Furthermore, there's an assertion named `req_when_idle` that checks a property related to the `idle` and `req` signals whenever the clock signal rises, but the assertion is disabled if reset (`rst`) is high. The action block within the assertion (`$display(""req_when_idle completed"");`) would execute to display a message upon the successful completion of the property check.","
module reggen(input logic busy, clk, rst, output logic req);
  wire idle;
  assign idle = !busy;

  always @(posedge clk or posedge rst) begin
    if (rst) req <= '0';
    else req <= !busy;
  end

  req_when_idle: assert property (
    @(posedge clk) disable iff (rst) idle |=> req)
    $display(""req_when_idle completed"");
  endmodule : reggen
","Caption: ""Verilog code for a regenerative module with a disable iff assertion, accompanied by timing diagrams demonstrating assertion with reset.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p114.jpg,True,"The image contains Verilog code. Here are the two snippets shown in the image:

Original RTL logic:
```verilog
always @(a) begin
  case ( a )
    3’h0 : z = 3’h3;
    3’h3 : z = 3’h6;
    3’h6 : z = 3’h0;
    default : z = 3’h7;
  endcase
end

assign w = (c == 1’b0) ? z : a;
always @(a or b or w) begin
  case ( b )
    4’h0 : d = w;
    default : d = a;
  endcase
end
```

After branch partitioning:
```verilog
always @(a or b or c)
  case (b)
    4’h0: begin
      if (c != 1’b0) begin
        case (a)
          3’h0 : z = 3’h3;
          3’h3 : z = 3’h6;
          3’h6 : z = 3’h0;
          default : z = 3’h7;
        endcase
        w = z;
      end else
        w = a;
    end
    else
      w = a;
    d = w;
  endcase
```

This code appears to be an example used in a technical document or book about digital design with Verilog, discussing optimization techniques like branch partitioning.","
always @(a) begin
  case ( a )
    3’h0 : z = 3’h3;
    3’h3 : z = 3’h6;
    3’h6 : z = 3’h0;
    default : z = 3’h7;
  endcase
end

assign w = (c == 1’b0) ? z : a;
always @(a or b or w) begin
  case ( b )
    4’h0 : d = w;
    default : d = a;
  endcase
end


always @(a or b or c)
  case (b)
    4’h0: begin
      if (c != 1’b0) begin
        case (a)
          3’h0 : z = 3’h3;
          3’h3 : z = 3’h6;
          3’h6 : z = 3’h0;
          default : z = 3’h7;
        endcase
        w = z;
      end else
        w = a;
    end
    else
      w = a;
    d = w;
  endcase
","Caption: ""Comparing original RTL logic to optimized logic with branch partitioning in Verilog code, and an explanation on clock partitioning in digital design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p361.jpg,True,"The image includes a snippet of text that defines what a `specparam` is in Verilog, and it includes an example of a `specparam` declaration. Here is the code from the image:

```verilog
specparam Name = (x, y, z);
```

In this context, `x`, `y`, and `z` are numbers or timing triplets representing delays.","
specparam Name = (x, y, z);
","Caption: ""Educational content explaining the rules and best practices for using specify blocks and specparams in Verilog for hardware description.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p292.jpg,True,"The image contains a snippet of Verilog code. Here is the code transcription from the image:

```verilog
Sample 7.31 Mailbox declarations

mailbox #(Transaction) mbx_tr; // Parameterized: recommended
mailbox mbx_untyped;           // Unspecialized: avoid

Sample 7.32 Bad generator creates only one object

task generator_bad(input int n,
                   input mailbox #(Transaction) mbx);
    Transaction tr;
    tr = new();                  // Create just one transaction
    repeat (n) begin
        `SV_RAND_CHECK(tr.randomize());
        $display(""GEN: Sending addr=%h"", tr.addr);
        mbx.put(tr);             // Send transaction to driver
    end
endtask
```

The text explains how mailboxes work in the context of Verilog/SystemVerilog and discusses a common bug involving mailbox usage. The code given is a demonstration of the bad practice described.","
Sample 7.31 Mailbox declarations

mailbox #(Transaction) mbx_tr; // Parameterized: recommended
mailbox mbx_untyped;           // Unspecialized: avoid

Sample 7.32 Bad generator creates only one object

task generator_bad(input int n,
                   input mailbox #(Transaction) mbx);
    Transaction tr;
    tr = new();                  // Create just one transaction
    repeat (n) begin
        `SV_RAND_CHECK(tr.randomize());
        $display(""GEN: Sending addr=%h"", tr.addr);
        mbx.put(tr);             // Send transaction to driver
    end
endtask
","""Verilog Mailboxes and the Issue of Generating Multiple Object Handles in a Loop""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p289.jpg,True,"The image contains Verilog code, which appears to be a snippet of a hardware description used in digital circuit design. Here's the text of the Verilog code in the image:

```verilog
n1, n2, n3;
xor      (n1, a, b);
xor #2   (sum, n1, ci);
and      (n2, a, b);
and      (n3, n1, ci);
or #2    (co, n2, n3);
endmodule
```

Please note that this code is likely to be part of a larger module; it is missing the module declaration and other contextual information necessary to understand the complete functionality.","
n1, n2, n3;
xor      (n1, a, b);
xor #2   (sum, n1, ci);
and      (n2, a, b);
and      (n3, n1, ci);
or #2    (co, n2, n3);
endmodule
","""Example of a Verilog code snippet demonstrating the use of xor, and, or operators and a screenshot of its simulation results in Cadence Verilog-XL.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p85.jpg,True,"Here is the code from the image:

```verilog
wire ToSubDir, In01, In02;
wor SelTwo;
...
assign SelTwo = In01;
assign SelTwo = In02; // Thus, SelTwo evaluates (In01 or In02).
assign ToSubDir = SelTwo;
...
// Much more common, and more efficient, would be this:
assign ToSubDir = In01 | In02; // = In01 || In02; also is OK.
```

Additionally, the image discusses various elements of Verilog including net types such as wire, tri, wand, and wor, and elaborates on the use of constants and parameter values in Verilog code.","
wire ToSubDir, In01, In02;
wor SelTwo;
...
assign SelTwo = In01;
assign SelTwo = In02; // Thus, SelTwo evaluates (In01 or In02).
assign ToSubDir = SelTwo;
...
// Much more common, and more efficient, would be this:
assign ToSubDir = In01 | In02; // = In01 || In02; also is OK.
","Caption: ""Educational text explaining Verilog net types, wired logic, and constants with examples of Verilog code snippets.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p98.jpg,True,"The image contains code written in Verilog/SystemVerilog Assertion (SVA) language. Here is the code from the image:

```verilog
property p_if_else_leaf1;
  @(posedge clk)
    ($fell(start) ##1 a) |-> 
    (c[-:2] ##1 e);
endproperty

a_if_else_leaf1:
  assert property(p_if_else_leaf1);

property p_if_else_leaf2;
  @(posedge clk)
    ($fell(start) ##1 b) |-> 
    (d[-:2] ##1 f);
endproperty

a_if_else_leaf2:
  assert property(p_if_else_leaf2);

property p_if_else_leaf3;
  @(posedge clk)
    ($fell(start) ##1 (a &&b)) |-> 
    (c[-:2] ##1 e);
endproperty

a_if_else_leaf3:
  assert property(p_if_else_leaf3);

sequence s_multiple_clocks;
  @(posedge clk1) a ##1 @(posedge clk2) b;
```

This code appears to be discussing the use of properties and sequences in SystemVerilog Assertions for hardware description and verification. It includes examples of properties with if-else branches, edge detection, and handling multiple clock domains within a sequence.","
property p_if_else_leaf1;
  @(posedge clk)
    ($fell(start) ##1 a) |-> 
    (c[-:2] ##1 e);
endproperty

a_if_else_leaf1:
  assert property(p_if_else_leaf1);

property p_if_else_leaf2;
  @(posedge clk)
    ($fell(start) ##1 b) |-> 
    (d[-:2] ##1 f);
endproperty

a_if_else_leaf2:
  assert property(p_if_else_leaf2);

property p_if_else_leaf3;
  @(posedge clk)
    ($fell(start) ##1 (a &&b)) |-> 
    (c[-:2] ##1 e);
endproperty

a_if_else_leaf3:
  assert property(p_if_else_leaf3);

sequence s_multiple_clocks;
  @(posedge clk1) a ##1 @(posedge clk2) b;
",Examples of SystemVerilog Assertions (SVA) properties for if-else constructs and multiple clock definitions in SVA code.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p91.jpg,True,"The image contains Verilog code. Here it is:

```verilog
always@(posedge Clk, negedge Preset_n, negedge Clear_n)
    if (Preset_n=='0')
        Q <= 'b1';
    else if (Clear_n=='0')
        Q <= 'b0';
    else Q <= D;
```","
always@(posedge Clk, negedge Preset_n, negedge Clear_n)
    if (Preset_n=='0')
        Q <= 'b1';
    else if (Clear_n=='0')
        Q <= 'b0';
    else Q <= D;
","Caption: ""Verilog code illustrating asynchronous controls in flip-flops, highlighting the implications of preset and clear priorities and the potential issues in simulation and synthesis.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p230.jpg,True,"The image contains a snippet of text that includes a fragment that appears to be pseudo-code or a high-level description of some logic related to property specification or automated verification. The segment that looks like code is as follows:

```
(1[∗kn−1] ##1 τ=τa)[∗0:∗] ##1 1 1−> ((1[∗kn−1] ##1 τ=τa) or (Rnext intersects Rtiles in ν))
```

Please note that the actual meaning and usage of this fragment would depend on the context of the document it's from and the specific syntax and semantics of the language or formalism being used, which is not explicitly Verilog in this case.","−1] ##1 τ=τa)[∗0:∗] ##1 1 1−> ((1[∗kn−1] ##1 τ=τa) or (Rnext intersects Rtiles in ν))
",Academic text discussing the complexity of system verification and a section of Verilog code related to property specification.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p286.jpg,True,"The image contains two samples of Verilog code.

Here is the first sample of code:

```verilog
// Sample 7.24 Waiting on event causes a zero delay loop

forever begin
    // This is a zero delay loop!
    wait(handshake.triggered);
    $display(""Received next event"");
    process_in_zero_time();
end
```

And here is the second sample:

```verilog
// Sample 7.25 Waiting for an edge on an event

forever begin
    // This prevents a zero delay loop!
    @handshake;
    $display(""Received next event"");
    process_in_zero_time();
end
```

These code snippets illustrate different methods of handling events in Verilog to either create or prevent zero delay loops.","
// Sample 7.24 Waiting on event causes a zero delay loop

forever begin
    // This is a zero delay loop!
    wait(handshake.triggered);
    $display(""Received next event"");
    process_in_zero_time();
end


// Sample 7.25 Waiting for an edge on an event

forever begin
    // This prevents a zero delay loop!
    @handshake;
    $display(""Received next event"");
    process_in_zero_time();
end
",Sample Verilog code depicting the use of event triggers to prevent zero delay loops in a simulation.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p261.jpg,True,"The image includes Verilog code. Here it is:

```verilog
a1: assert property (
    start_t ##1 (end_t throughout sent[0:1]) ##1 end_t
    |-> shortt );

...

a1: assert property (
    command |-> 
    write_complete[-1] intersect read_complete[-2] );

...

a1: assert property (start_t |-> 
    read[=2] intersect write[=3] intersect end_t[-1]);
```

These code segments are examples of SystemVerilog assertions using the `assert property` construct and sequence operators like `throughout`, `##` (delay operator), and `intersect`.","
a1: assert property (
    start_t ##1 (end_t throughout sent[0:1]) ##1 end_t
    |-> shortt );

...

a1: assert property (
    command |-> 
    write_complete[-1] intersect read_complete[-2] );

...

a1: assert property (start_t |-> 
    read[=2] intersect write[=3] intersect end_t[-1]);
","Caption: ""Excerpt from a technical document illustrating the use of the `intersect` sequence operator in Verilog assertions for simultaneous sequence matching and formal verification efficiency tips.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p510.jpg,True,"The image includes a page from a book with a segment of Verilog PLI (Programming Language Interface) code. Here is the code transcribed from the image:

```c
switch ( acc_fetch_direction(port_h) ) {
    case accInput:
        io_printf(""input "");
        break;
    case accOutput:
        io_printf(""output "");
        break;
    case accInOut:
        io_printf(""inout "");
        break;
    case accMixedIo:
        io_printf(""mixed input/output "");
        break;
    default:
        io_printf(""unknown direction "");
}

if ( acc_object_of_type(port_h, accExpandedVector))
    io_printf("" Expanded=true "");
else
    io_printf("" Expanded=false "");
if ( acc_object_of_type(port_h, accUnExpandedVector))
    io_printf("" Unexpanded=true\n"");
else
    io_printf("" Unexpanded=false\n"");

loconn_h = acc_handle_loconn(port_h);
io_printf("" Loconn type = %s\n"", acc_fetch_type_str(acc_fetch_fulltype(loconn_h)));
hiconn_h = acc_handle_hiconn(port_h);
if (hiconn_h)
    io_printf("" Hiconn type = %s\n\n"", acc_fetch_type_str(acc_fetch_fulltype(hiconn_h)));
else
    io_printf("" Hiconn type = none\n\n"");
/* end of next port_h loop */
acc_close();
return;
}
```

This code snippet uses the Verilog Procedural Interface to gather information about ports, their direction, and whether they are expanded or unexpanded vectors. It also retrieves the low and high connectivity details of the ports.","h ( acc_fetch_direction(port_h) ) {
    case accInput:
        io_printf(""input "");
        break;
    case accOutput:
        io_printf(""output "");
        break;
    case accInOut:
        io_printf(""inout "");
        break;
    case accMixedIo:
        io_printf(""mixed input/output "");
        break;
    default:
        io_printf(""unknown direction "");
}

if ( acc_object_of_type(port_h, accExpandedVector))
    io_printf("" Expanded=true "");
else
    io_printf("" Expanded=false "");
if ( acc_object_of_type(port_h, accUnExpandedVector))
    io_printf("" Unexpanded=true\n"");
else
    io_printf("" Unexpanded=false\n"");

loconn_h = acc_handle_loconn(port_h);
io_printf("" Loconn type = %s\n"", acc_fetch_type_str(acc_fetch_fulltype(loconn_h)));
hiconn_h = acc_handle_hiconn(port_h);
if (hiconn_h)
    io_printf("" Hiconn type = %s\n\n"", acc_fetch_type_str(acc_fetch_fulltype(hiconn_h)));
else
    io_printf("" Hiconn type = none\n\n"");
/* end of next port_h loop */
acc_close();
return;
}
","""Example of Verilog PLI code for fetching port direction and type information.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p507.jpg,True,"The image contains text but no code in the context of programming syntax or source code. The text includes logical expressions and definitions related to Verilog, a hardware description language used in electronic design automation. The text details formal semantics and expressions for describing behavior in Verilog but these are not direct snippets of Verilog source code.

However, for the purpose of textual description and understanding, I'll transcribe the logical/mathematical expressions presented, which are used to describe concepts in Verilog. Here they are:

1. Nonoverlapping implication as a shortcut:
```
(s |=> p) ≡ (s ##1 1 |-> p).
```

2. Definition of the formal semantics of followed-by:
```
w |= s #-# p iff for some i ≥ 0, w0,i |= s and wi |= p.
```

3. Dual operations for followed-by and suffix implication:
```
(s #-# p) ≡ (not (s |-> not p)).
```

4. Nonoverlapping followed-by as a shortcut:
```
(s #=# p) ≡ (s ##1 1 #=# p).
```

The text also refers to various clauses like `C1`, `C2`, and `C3`, which are conditions or rules defining formal semantics related to clocks, but these are not executable code."," p) ≡ (s ##1 1 |-> p).

 #-# p iff for some i ≥ 0, w0,i |= s and wi |= p.

 p) ≡ (not (s |-> not p)).

 p) ≡ (s ##1 1 #=# p).
","""Exploration of nonoverlapping implication and followed-by constructs in Verilog for formal semantics of clocks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p67.jpg,True,"The image contains examples of SystemVerilog Assertions (SVA) code. Here is the code written in the image:

```verilog
@(posedge clk) $rose(start) |-> ##1 a ##1 a ##1 a ##1 stop
```

Consecutive repetition syntax:
```verilog
signal or sequence [*n]
```

Examples for consecutive repetition:
```verilog
a [*3]         // expands to: a ##1 a ##1 a

(a ##1 b) [*3] // expands to: (a ##1 b) ##1 (a ##1 b) ##1 (a ##1 b)
```

Go to repetition syntax:
```verilog
signal [->n]
```","
@(posedge clk) $rose(start) |-> ##1 a ##1 a ##1 a ##1 stop


signal or sequence [*n]


a [*3]         // expands to: a ##1 a ##1 a

(a ##1 b) [*3] // expands to: (a ##1 b) ##1 (a ##1 b) ##1 (a ##1 b)


signal [->n]
","""Introduction to SystemVerilog Assertions and Repetition Operators with code examples""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p73.jpg,True,"Here is the code from the image:

```verilog
Property p24;
    @(posedge clk) $rose(start) |->
    ##2 (a[*1:$]) ##1 stop;
endproperty

a24: assert property(p24);
```","
Property p24;
    @(posedge clk) $rose(start) |->
    ##2 (a[*1:$]) ##1 stop;
endproperty

a24: assert property(p24);
","Caption: ""Example of a Verilog property (p24) for finite checking with an unbounded repeat window, demonstrating simulation failure and success cases.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p504.jpg,True,"The image contains a snippet of code from a book related to Verilog and PLI (Programming Language Interface). The code provided is in C language intended to interact with Verilog designs. Here is the transcribed code from the image:

```c
#include ""veriuser.h""   /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""   /* IEEE 1364 PLI ACC routine library */
/*************************************************************
 * checktf application
 *************************************************************/
int PLIbook_ListPorts_checktf()
{
    acc_initialize();
    if (tf_nump() != 1)
        tf_error(""$list_pathout_ports must have 1 argument."");
    else if (tf_typep(1) == TF_NULLPARAM)
        tf_error(""$list_pathout_ports arg cannot be null."");
    else if (acc_fetch_type(acc_handle_tfarg(1)) != accModule)
        tf_error(""$list_pathout_ports arg must be a module instance."");
    acc_close();
    return(0);
}

/*************************************************************

 * calltf application
 *************************************************************/
int PLIbook_ListPorts_calltf()
{
    handle module_h, modpath_h, pathterm_h, net_h, port_h;
    acc_initialize();
```

The code appears to be incomplete, however, as it seems to cut off towards the bottom of the page. This code is likely part of a larger example explaining how to use the Verilog PLI to traverse through Verilog module instances, paths, and ports using the C programming language. The actual usage within a Verilog environment would require additional context provided elsewhere in the source material.","ude ""veriuser.h""   /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""   /* IEEE 1364 PLI ACC routine library */
/*************************************************************
 * checktf application
 *************************************************************/
int PLIbook_ListPorts_checktf()
{
    acc_initialize();
    if (tf_nump() != 1)
        tf_error(""$list_pathout_ports must have 1 argument."");
    else if (tf_typep(1) == TF_NULLPARAM)
        tf_error(""$list_pathout_ports arg cannot be null."");
    else if (acc_fetch_type(acc_handle_tfarg(1)) != accModule)
        tf_error(""$list_pathout_ports arg must be a module instance."");
    acc_close();
    return(0);
}

/*************************************************************

 * calltf application
 *************************************************************/
int PLIbook_ListPorts_calltf()
{
    handle module_h, modpath_h, pathterm_h, net_h, port_h;
    acc_initialize();
","Caption: ""Example of a Verilog Procedural Interface (PLI) application for traversing module hierarchy to list output ports.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p275.jpg,True,"The image contains text related to Verilog, a hardware description language used commonly for defining and modeling electronic systems. It does include a snippet of code, which is part of Verilog language syntax. Here is the code extracted from the image:

```verilog
sequence s1;
s ##1 1;
endsequence
```

Note that there may be other small snippets or references to code within the text of the image, but the above lines are the explicitly written complete lines of code visible.","
sequence s1;
s ##1 1;
endsequence
","""Introduction to the concept of sequences as events in Verilog, including the syntax and application for testbench execution control.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p262.jpg,True,"The image shows a segment of code written in C that appears to interact with a Verilog simulation environment through the Verilog Procedural Interface (VPI). Here's the visible code extracted from the image:

```c
/* Read current values of C model inputs from Verilog simulation */
value_s.format = vpiRealVal;
vpi_get_value(AIUdata->a_h, &value_s);
a = value_s.value.real;

vpi_get_value(AIUdata->b_h, &value_s);
b = value_s.value.real;

value_s.format = vpiIntVal;
vpi_get_value(AIUdata->opcode_h, &value_s);
opcode = value_s.value.integer;

/****** Call the C model ******/
PLIBook_ScientificALU_C_model(&result, &execp, &err, a, b, opcode);

/* Write the C model outputs onto the Verilog signals */
value_s.format = vpiRealVal;
value_s.value.real = result;
vpi_put_value(AIUdata->result_h, &value_s, NULL, vpiNoDelay);

value_s.format = vpiIntVal;
value_s.value.integer = execp;
vpi_put_value(AIUdata->execp_h, &value_s, NULL, vpiNoDelay);

value_s.value.integer = err;
vpi_put_value(AIUdata->err_h, &value_s, NULL, vpiNoDelay);

return (0);
}

/**************************************************************************
 * calltf routine: Registers a callback to the C model interface
 * whenever any input to the C model changes value
 **************************************************************************/
int PLIBook_ScientificALU_calltf(char *user_data)
{
    vpiHandle instance_h, arg_itr;
    s_vpi_value value_s;
    s_vpi_time time_s;
    s_cb_data cb_data_s;

    PLIbook_ALU_data_p AIUdata;

    /* allocate storage to hold scientific_alu argument handles */
    AIUdata = (PLIbook_ALU_data_p)malloc(sizeof(PLIbook_ALU_data_s));

    /* obtain a handle to the system task instance */
    instance_h = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handles to system task arguments */
    /* compiletf has already verified arguments are correct */
    arg_itr = vpi_iterate(vpiArgument, instance_h);
    AIUdata->clock_h = vpi_scan(arg_itr); /* 1st arg is clock input */
```

This code segment showcases how a C model interacts with Verilog simulation, where the model reads inputs from a Verilog simulation, computes results within a C model function (`PLIBook_ScientificALU_C_model`), and then writes these results back to the Verilog simulation. Additionally, the code at the bottom appears to set up a callback mechanism to detect when inputs to the C model change within the Verilog simulation.","ad current values of C model inputs from Verilog simulation */
value_s.format = vpiRealVal;
vpi_get_value(AIUdata->a_h, &value_s);
a = value_s.value.real;

vpi_get_value(AIUdata->b_h, &value_s);
b = value_s.value.real;

value_s.format = vpiIntVal;
vpi_get_value(AIUdata->opcode_h, &value_s);
opcode = value_s.value.integer;

/****** Call the C model ******/
PLIBook_ScientificALU_C_model(&result, &execp, &err, a, b, opcode);

/* Write the C model outputs onto the Verilog signals */
value_s.format = vpiRealVal;
value_s.value.real = result;
vpi_put_value(AIUdata->result_h, &value_s, NULL, vpiNoDelay);

value_s.format = vpiIntVal;
value_s.value.integer = execp;
vpi_put_value(AIUdata->execp_h, &value_s, NULL, vpiNoDelay);

value_s.value.integer = err;
vpi_put_value(AIUdata->err_h, &value_s, NULL, vpiNoDelay);

return (0);
}

/**************************************************************************
 * calltf routine: Registers a callback to the C model interface
 * whenever any input to the C model changes value
 **************************************************************************/
int PLIBook_ScientificALU_calltf(char *user_data)
{
    vpiHandle instance_h, arg_itr;
    s_vpi_value value_s;
    s_vpi_time time_s;
    s_cb_data cb_data_s;

    PLIbook_ALU_data_p AIUdata;

    /* allocate storage to hold scientific_alu argument handles */
    AIUdata = (PLIbook_ALU_data_p)malloc(sizeof(PLIbook_ALU_data_s));

    /* obtain a handle to the system task instance */
    instance_h = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handles to system task arguments */
    /* compiletf has already verified arguments are correct */
    arg_itr = vpi_iterate(vpiArgument, instance_h);
    AIUdata->clock_h = vpi_scan(arg_itr); /* 1st arg is clock input */
","Caption: ""Example of Verilog PLI (Programming Language Interface) code for interfacing a Verilog simulation with a C model.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p279.jpg,True,"The image contains code written in SystemVerilog. Here is the code that is visible in the image:

```verilog
program automatic bug;

class Buggy;
    int data[10];
    task transmit();
        fork
            for (i=0; i<10; i++) // i is not declared here
                send(data[i]);
        join_none
    endtask
endclass

int i;                          // Program-level i, shared
Buggy b;
event receive;

initial begin
    b = new();
    for (i=0; i<10; i++)        // i is not declared here
        b.data[i] = i;
    b.transmit();

    for (i=0; i<10; i++)        // i is not declared here
        @(receive) $display(b.data[i]);
    end
endprogram
```

The code is demonstrating a bug using a shared program variable introduced in a concurrency scenario within SystemVerilog.","
program automatic bug;

class Buggy;
    int data[10];
    task transmit();
        fork
            for (i=0; i<10; i++) // i is not declared here
                send(data[i]);
        join_none
    endtask
endclass

int i;                          // Program-level i, shared
Buggy b;
event receive;

initial begin
    b = new();
    for (i=0; i<10; i++)        // i is not declared here
        b.data[i] = i;
    b.transmit();

    for (i=0; i<10; i++)        // i is not declared here
        @(receive) $display(b.data[i]);
    end
endprogram
","""Example of a bug caused by using a shared variable in Verilog code with incorrect variable scoping.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p82.jpg,True,"```verilog
int j = 1,
q2[$] = {3,4},        // Queue literals do not use '
q[$] = {0,2,5};      // {0,2,5}

initial begin         // Result
q = {q[0], j, q[1:$]}; // {0,1,2,5} Insert 1 before 2
q = {q[0:2], q2, q[3:$]}; // {0,1,2,3,4,5} Insert queue in q
q = {q[0], q[2:$]};    // {0,2,3,4,5} Delete elem. #1

// These operations are fast 
q = {6, q};             // {6,0,2,3,4,5} Insert at front
j = q[$];               // j = 5            pop_back
q = q[0:$-1];           // {6,0,2,3,4}   equivalent
q = {q, 8};             // {6,0,2,3,4,8} Insert at back
j = q[0];               // j = 6            pop_front
q = q[1:$];             // {0,2,3,4,8}   equivalent

q = {};                 // {} Delete contents
end
```","
int j = 1,
q2[$] = {3,4},        // Queue literals do not use '
q[$] = {0,2,5};      // {0,2,5}

initial begin         // Result
q = {q[0], j, q[1:$]}; // {0,1,2,5} Insert 1 before 2
q = {q[0:2], q2, q[3:$]}; // {0,1,2,3,4,5} Insert queue in q
q = {q[0], q[2:$]};    // {0,2,3,4,5} Delete elem. #1

// These operations are fast 
q = {6, q};             // {6,0,2,3,4,5} Insert at front
j = q[$];               // j = 5            pop_back
q = q[0:$-1];           // {6,0,2,3,4}   equivalent
q = {q, 8};             // {6,0,2,3,4,8} Insert at back
j = q[0];               // j = 6            pop_front
q = q[1:$];             // {0,2,3,4,8}   equivalent

q = {};                 // {} Delete contents
end
","""Explaining Queue Operations with Examples in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p73.jpg,True,"The image contains two pieces of Verilog code. Here they are transcribed:

First piece of code (Example 3.9):
```verilog
module m(...);
  timeunit 1ns;
  ...
endmodule : m
```

Second piece of code (Example 3.10):
```verilog
program test(output logic request, grant, sync);
  logic oldreq = 1'b0;
  assign grant = oldreq;
  initial begin
    request = 1'b0;
    sync = 1'b0;
    for (int i = 0; i < 100; i++) begin
      #5 sync <= !sync;
      if (i & 2) begin
        oldreq <= request;
        request <= $random;
      end
    end
  end
endprogram : test
```","
module m(...);
  timeunit 1ns;
  ...
endmodule : m


program test(output logic request, grant, sync);
  logic oldreq = 1'b0;
  assign grant = oldreq;
  initial begin
    request = 1'b0;
    sync = 1'b0;
    for (int i = 0; i < 100; i++) begin
      #5 sync <= !sync;
      if (i & 2) begin
        oldreq <= request;
        request <= $random;
      end
    end
  end
endprogram : test
","Caption: ""Explaining Time Slots and Event Scheduling in Verilog Simulation""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p251.jpg,True,"The image contains Verilog code. Here is the code extract:

```verilog
parameter MAX_SIZE = 10;

class RandStuff;
  rand bit [31:0] value;
endclass

class RandArray;
  rand RandStuff array[]; // Don't forget rand!

  constraint c {array.size() inside {[1:MAX_SIZE]}; }

  function new();
    array = new[MAX_SIZE]; // Allocate maximum size
    foreach (array[i])
      array[i] = new();
  endfunction;
endclass

RandArray ra;
initial begin
  ra = new();                       // Construct array and all objects
  `SV_RAND_CHECK(ra.randomize());   // Randomize array
  foreach (ra.array[i])
    $display(ra.array[i].value);
end
```","
parameter MAX_SIZE = 10;

class RandStuff;
  rand bit [31:0] value;
endclass

class RandArray;
  rand RandStuff array[]; // Don't forget rand!

  constraint c {array.size() inside {[1:MAX_SIZE]}; }

  function new();
    array = new[MAX_SIZE]; // Allocate maximum size
    foreach (array[i])
      array[i] = new();
  endfunction;
endclass

RandArray ra;
initial begin
  ra = new();                       // Construct array and all objects
  `SV_RAND_CHECK(ra.randomize());   // Randomize array
  foreach (ra.array[i])
    $display(ra.array[i].value);
end
",Caption: Example of Verilog code demonstrating how to randomize an array of handles (objects) in a simulation environment.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p46.jpg,True,"The image contains an example of Verilog code. Here it is:

```verilog
Intro_Top Topper01 ( .X(Xwatch), .Y(Ywatch), .Z(Zwatch)
                   , .A(Astim), .B(Bstim), .C(Cstim), .D(Dstim)
                   );
```

This code snippet shows how to instantiate a Verilog module with instance name `Topper01` of module `Intro_Top`. The port mapping connects module ports to wires/signals defined outside of the module (`Xwatch`, `Ywatch`, `Zwatch`, `Astim`, `Bstim`, `Cstim`, `Dstim`).","
Intro_Top Topper01 ( .X(Xwatch), .Y(Ywatch), .Z(Zwatch)
                   , .A(Astim), .B(Bstim), .C(Cstim), .D(Dstim)
                   );
","Caption: ""An excerpt from 'Digital VLSI Design with Verilog' detailing the concepts of delays, component instantiation, port mapping, and vector notation in Verilog HDL.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p172.jpg,True,"The image contains Verilog code as part of an example for an FSM2 (Finite State Machine). Here is the code from the image:

```verilog
module bus_arbiter(clk, reset, frame, irdy, req1, req2, req3, gnt1, gnt2, gnt3);

input logic clk, reset, frame, irdy;
input logic req1, req2, req3;

output gnt1, gnt2, gnt3;

enum bit [6:0] {IDLE = 7'b0000001,
                MASTER1 = 7'b0000010,
                IDLE1 = 7'b0000100,
                MASTER2 = 7'b0001000,
                IDLE2 = 7'b0010000,
                MASTER3 = 7'b0100000,
                IDLE3 = 7'b1000000} next, state;

logic done, gnt1, gnt2, gnt3;

/* define glue signals */

assign done = frame && irdy;

/* state register code */

always@(posedge clk or negedge reset)
begin
    if(!reset)
        state <= IDLE;
    else
        state <= next;
end

/* next state combinational logic */
always@(*)
begin
    next = IDLE;
    case(state)
```

The code above defines a Verilog module called `bus_arbiter` that appears to be used for arbitrating bus requests between several masters. The code specifies the inputs and outputs, declares an enumerated type for the state encoding, provides some logic for state transitions, and begins to define the state transition logic. However, the code snippet is incomplete as it ends with the beginning of a `case` statement for the state transitions.","
module bus_arbiter(clk, reset, frame, irdy, req1, req2, req3, gnt1, gnt2, gnt3);

input logic clk, reset, frame, irdy;
input logic req1, req2, req3;

output gnt1, gnt2, gnt3;

enum bit [6:0] {IDLE = 7'b0000001,
                MASTER1 = 7'b0000010,
                IDLE1 = 7'b0000100,
                MASTER2 = 7'b0001000,
                IDLE2 = 7'b0010000,
                MASTER3 = 7'b0100000,
                IDLE3 = 7'b1000000} next, state;

logic done, gnt1, gnt2, gnt3;

/* define glue signals */

assign done = frame && irdy;

/* state register code */

always@(posedge clk or negedge reset)
begin
    if(!reset)
        state <= IDLE;
    else
        state <= next;
end

/* next state combinational logic */
always@(*)
begin
    next = IDLE;
    case(state)
",Verilog code snippet of a bus arbiter with a finite state machine for request handling.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p538.jpg,True,"The image contains a snippet of code written in C that interfaces with Verilog hardware description language using the ACC (Application Control Components) library. The code is as follows:

```c
int object_type;
object_type = acc_fetch_type(tfarg_handle);
if (object_type != accModule) {
    tf_error(""tfarg type of %s is illegal.\n"",
             acc_fetch_type_str(object_type));
}
```

This code snippet is used to fetch and check the type of a Verilog object that's been accessed from within a PLI application. It uses ACC routines to interact with Verilog objects. If the fetched type isn't a module, it prints an error message using `tf_error`, incorporating a string representation of the object type, which is obtained by calling `acc_fetch_type_str(object_type)`.","bject_type;
object_type = acc_fetch_type(tfarg_handle);
if (object_type != accModule) {
    tf_error(""tfarg type of %s is illegal.\n"",
             acc_fetch_type_str(object_type));
}
","Caption: ""Extract from Verilog PLI documentation on ACC routine usage for reading fulltype properties and type string conversion.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p166.jpg,True,"The image contains Verilog code related to the verification of a finite state machine (FSM) using SystemVerilog Assertions (SVA). Here is the code extracted from the image:

```verilog
property p_onehot;
    @(posedge clk) (reset_) |->
        ($countones(n_state) == 1);
endproperty

a_onehot: assert property(p_onehot);
c_onehot: cover property(p_onehot);

sequence s_trans1;
    (c_state == IDLE) ##1
        ((c_state == GEN_BLK_ADDR) [*64]) ##1
        (c_state == WAIT0);
endsequence

property p_trans;
    @(posedge clk)
    (reset_ && $rose(get_data)) |->
        (reset_) throughout (s_trans1);
endproperty

a_trans: assert property (p_trans);
c_trans: assert property (p_trans);
```

This code is defining properties to check if the FSM stays one-hot and if it transitions correctly between states, as well as sequences to describe the transitions.","
property p_onehot;
    @(posedge clk) (reset_) |->
        ($countones(n_state) == 1);
endproperty

a_onehot: assert property(p_onehot);
c_onehot: cover property(p_onehot);

sequence s_trans1;
    (c_state == IDLE) ##1
        ((c_state == GEN_BLK_ADDR) [*64]) ##1
        (c_state == WAIT0);
endsequence

property p_trans;
    @(posedge clk)
    (reset_ && $rose(get_data)) |->
        (reset_) throughout (s_trans1);
endproperty

a_trans: assert property (p_trans);
c_trans: assert property (p_trans);
","Caption: ""Verilog code snippets for checking one-hot state encoding in FSM and asserting state transitions with SystemVerilog Assertions (SVA).""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p67.jpg,True,"There is Verilog code in the image. Here are the code segments:

Example 3.4:
```verilog
wire a, b, c, d;
...
assign a = b & c;
assign b = d;
```

Example 3.5:
```verilog
wire a, b, c;
...
assign a = b | c;
```","
wire a, b, c, d;
...
assign a = b & c;
assign b = d;


wire a, b, c;
...
assign a = b | c;
","""Explaining Determinism and Nondeterminism in Verilog Simulations with Continuous Assignments Example""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p245.jpg,True,"```verilog
class bad_sum1;
  rand byte len[ ];
  constraint c_len {len.sum() < 1024;
                    len.size() inside {[1:8]};}

  function void display();
    $write(""sum=%4d, val="", len.sum());
    foreach(len[i]) $write(""%4d "", len[i]);
    $display;
  endfunction
endclass

program automatic test;
  bad_sum1 c;
  initial begin
    c = new();
    repeat (5) begin
      `SV_RAND_CHECK(c.randomize());
      c.display();
    end
  end
endprogram
```","
class bad_sum1;
  rand byte len[ ];
  constraint c_len {len.sum() < 1024;
                    len.size() inside {[1:8]};}

  function void display();
    $write(""sum=%4d, val="", len.sum());
    foreach(len[i]) $write(""%4d "", len[i]);
    $display;
  endfunction
endclass

program automatic test;
  bad_sum1 c;
  initial begin
    c = new();
    repeat (5) begin
      `SV_RAND_CHECK(c.randomize());
      c.display();
    end
  end
endprogram
","""Exploring issues with array constraints in Verilog and demonstrating a faulty sum constraint example in code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p249.jpg,True,"The image contains several code snippets within the context of discussing bounded linear temporal operators in Verilog. Here are the code excerpts shown:

```verilog
initial a: assert property(
    nexttime[0] s_eventually e);
```

```verilog
initial a: assert property(
    s_nexttime[0] always e);
```

```verilog
initial a: assert property(
    rst ##1 !rst |-> s_nexttime [2] s_eventually p);
```

```verilog
a1: assert property (req and nexttime !req);
```

```verilog
a2: assert property (req implies nexttime !req);
```","
initial a: assert property(
    nexttime[0] s_eventually e);


initial a: assert property(
    s_nexttime[0] always e);


initial a: assert property(
    rst ##1 !rst |-> s_nexttime [2] s_eventually p);


a1: assert property (req and nexttime !req);


a2: assert property (req implies nexttime !req);
","""Exploration of Bounded Linear Temporal Operators in Verilog Assertions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p96.jpg,True,"The image contains two code samples written in Verilog. Here are the code excerpts from the image:

Sample 2.45:
```verilog
typedef union { bit [31:0] b; int i; } num_u;
num_u un;
un.i = -1; // set value using signed integer
```

Sample 2.46:
```verilog
typedef struct packed {bit [7:0] r, g, b;} pixel_p_s;
pixel_p_s my_pixel;
```

The first sample shows the definition of a union using `typedef`, with the union being able to represent a 32-bit bit vector or an integer. A variable `un` of type `num_u` is declared and initialized with a value using a signed integer.

The second sample demonstrates the definition of a packed structure, which optimizes the use of memory by packing the bits without unused space. A `typedef` creates `pixel_p_s` as a packed structure with three 8-bit fields representing color values, and a variable `my_pixel` of type `pixel_p_s` is declared.","
typedef union { bit [31:0] b; int i; } num_u;
num_u un;
un.i = -1; // set value using signed integer


typedef struct packed {bit [7:0] r, g, b;} pixel_p_s;
pixel_p_s my_pixel;
","This image contains an excerpt from a document explaining data types in Verilog, with examples of how to use `typedef` to create unions and packed structures for efficient memory usage.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p279.jpg,True,"The image contains two snippets of Verilog code. Here is the first snippet, which is an example of a Verilog fragment for a memory module interface:

```verilog
module memory_device (ce_n, rd_n, we_n, addr, wdata, data, clk);
input       ce_n,  // chip select ( --_n == active low )
            rd_n,  // read enable
            we_n,  // write enable
            clk;   // the clock
input  [11:0] addr; // the address for the device
input   [7:0] wdata; // write data for writes
output  [7:0] data;  // read data being returned.
```

And here is the second snippet, which is an example of a SystemVerilog check for illegal control signals:

```systemverilog
assert property (@(posedge clk) not $isunknown(ce_n, rd_n, we_n))
else $error(""Unknown control signals present (%0b)."", {ce_n, rd_n, we_n});
```

These are used to illustrate how to define a memory module interface and how to assert conditions in SystemVerilog to check for unknown control signals, respectively.","
module memory_device (ce_n, rd_n, we_n, addr, wdata, data, clk);
input       ce_n,  // chip select ( --_n == active low )
            rd_n,  // read enable
            we_n,  // write enable
            clk;   // the clock
input  [11:0] addr; // the address for the device
input   [7:0] wdata; // write data for writes
output  [7:0] data;  // read data being returned.

erilog
assert property (@(posedge clk) not $isunknown(ce_n, rd_n, we_n))
else $error(""Unknown control signals present (%0b)."", {ce_n, rd_n, we_n});
","""Example of a Verilog module for a memory interface and a SystemVerilog assertion for detecting illegal control signals.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p47.jpg,True,"The image contains two segments of Verilog code. Here is the first part:

```verilog
`include ""std_ovl_defines.h""
module ovl_always (clock, reset, enable, test_expr);
  input        clock, reset, enable;
  input        test_expr;

  parameter assert_name = ""OVL_ALWAYS"";

  property ASSERT_ALWAYS_P;
    @(posedge clk)
    disable iff (`OVL_RESET_SIGNAL != '1'b1)
      !($isunknown(test_expr)) |-> test_expr;
  endproperty
endmodule
```

And here's the second part:

```verilog
`include ""std_ovl/ovl_always.v""
module regTest (
  input clk, reset, enable;
  output logic [2:0] fire;
  output logic [31:0] error = 32'h0;
)

  logic [7:0] reg_a = 8'h0, reg_b=8'h10;
  always @(posedge clk) begin
    reg_a <= reg_a + 8'h1;
  end

  ovl_always reg_a_lt_reg_b (
    clk,
    reset,
    enable,
    reg_a < reg_b);  //This is the test expression
endmodule
```","
`include ""std_ovl_defines.h""
module ovl_always (clock, reset, enable, test_expr);
  input        clock, reset, enable;
  input        test_expr;

  parameter assert_name = ""OVL_ALWAYS"";

  property ASSERT_ALWAYS_P;
    @(posedge clk)
    disable iff (`OVL_RESET_SIGNAL != '1'b1)
      !($isunknown(test_expr)) |-> test_expr;
  endproperty
endmodule


`include ""std_ovl/ovl_always.v""
module regTest (
  input clk, reset, enable;
  output logic [2:0] fire;
  output logic [31:0] error = 32'h0;
)

  logic [7:0] reg_a = 8'h0, reg_b=8'h10;
  always @(posedge clk) begin
    reg_a <= reg_a + 8'h1;
  end

  ovl_always reg_a_lt_reg_b (
    clk,
    reset,
    enable,
    reg_a < reg_b);  //This is the test expression
endmodule
","Caption: ""Excerpt from a document explaining assertion synthesis with a sample Verilog code module using the OVL (Open Verification Library) for hardware design verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p245.jpg,True,"The image contains a Verilog code fragment for a high-level direct mapped cache. Here is the code present in the image:

```verilog
parameter ADDRW = 32; // number of address bits
parameter NLINES = 8; // number of lines 
parameter LINE = 9; // bytes in a line 
parameter logNLINS = 3; // log based 2 of N lines
parameter TAG = ADDRW-3; // address minus 3 index minus 3 offset

reg [8*LINE-1:0] cache_line [NLINES-1:0];
reg [TAG-1:0] cache_tag; // tag set
reg [NLINES-1:0] valid, n_valid, match;
reg [NLINES-1:0] cache_we; // write data [line]
reg [logNLINS-1:0] line_sel; // hit line selector
reg hit; // request hit in cache
wire hit; // hit
wire cache_fill; // fill line from mem, mark valid
wire write; // store request
wire request; // request to the cache
wire [ADDRW-1:0] addr; // request address
wire invalidate; // invalidate the cache

always @(*) begin
    case ({write, request, cache_fill, invalidate})
    4'b1100, begin
        // write or read request
        // index is a function returns index from the addr to select a line
        line_sel = index(addr); // extract index
        // hit_detect is a function returns vector for tag match
        match = hit_detect(addr, cache_tag) & valid;
        hit = match; // compute hit of match
        write_hit = {NLINES{write}} & match; // compute write enable
        ...
        4'b0010: begin // fill (from memory)
            n_valid = valid | cache_we; // setting a new valid
        ...
        4'b0001: begin // invalidate
            n_valid = {NLINES{1'b0}}; // clear all valids
        ...
    endcase
end
```

Please note that the image includes ellipsis (""..."") to indicate that the code has been truncated and there may be more code that is not included in the image.","
parameter ADDRW = 32; // number of address bits
parameter NLINES = 8; // number of lines 
parameter LINE = 9; // bytes in a line 
parameter logNLINS = 3; // log based 2 of N lines
parameter TAG = ADDRW-3; // address minus 3 index minus 3 offset

reg [8*LINE-1:0] cache_line [NLINES-1:0];
reg [TAG-1:0] cache_tag; // tag set
reg [NLINES-1:0] valid, n_valid, match;
reg [NLINES-1:0] cache_we; // write data [line]
reg [logNLINS-1:0] line_sel; // hit line selector
reg hit; // request hit in cache
wire hit; // hit
wire cache_fill; // fill line from mem, mark valid
wire write; // store request
wire request; // request to the cache
wire [ADDRW-1:0] addr; // request address
wire invalidate; // invalidate the cache

always @(*) begin
    case ({write, request, cache_fill, invalidate})
    4'b1100, begin
        // write or read request
        // index is a function returns index from the addr to select a line
        line_sel = index(addr); // extract index
        // hit_detect is a function returns vector for tag match
        match = hit_detect(addr, cache_tag) & valid;
        hit = match; // compute hit of match
        write_hit = {NLINES{write}} & match; // compute write enable
        ...
        4'b0010: begin // fill (from memory)
            n_valid = valid | cache_we; // setting a new valid
        ...
        4'b0001: begin // invalidate
            n_valid = {NLINES{1'b0}}; // clear all valids
        ...
    endcase
end
",Verilog code snippet for a direct mapped cache controller implementation.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p188.jpg,True,"The image contains a snippet of Verilog code. Here is the code transcribed from the image:

```verilog
// Assume SerVect is a saved, serial 64-bit vector:
reg[5:0] i;               // i traverses the serial stream (64-bit vector).
reg nBit1, n2Bit;         // Two 1-bit regs to hold the expected nn pad count.
...
FoundPads = 1'b0;
begin : While_i       // Name the block to exit it.
while(1)
begin
  if (   SerVect[i+1]==1'b0 && SerVect[i]==1'b0 && SerVect[i-1]==1'b0
      && SerVect[i-5]==1'b0 && SerVect[i-6]==1'b0 && SerVect[i-7]==1'b0
      )
  begin
    #1 FoundPads = 1'b1;   // 1 means true here, for later use.
    #1 nBit1 = SerVect[i-4]; // Save the padded nn = {n2, n1} value.
    #1 n2Bit = SerVect[i-3];
    disable While_i;       // Exit the while block, if found.
  end // if.
  ...
  i = i - 1;
end // While_i statement.
end // While_i named block.
```
Please note that the lines beginning with ""..."" indicate that there has been some code omitted in order to present a specific fragment, and ""..."" at the end of the `if` statement suggests that there are additional conditions or code that are not shown in the image.","
// Assume SerVect is a saved, serial 64-bit vector:
reg[5:0] i;               // i traverses the serial stream (64-bit vector).
reg nBit1, n2Bit;         // Two 1-bit regs to hold the expected nn pad count.
...
FoundPads = 1'b0;
begin : While_i       // Name the block to exit it.
while(1)
begin
  if (   SerVect[i+1]==1'b0 && SerVect[i]==1'b0 && SerVect[i-1]==1'b0
      && SerVect[i-5]==1'b0 && SerVect[i-6]==1'b0 && SerVect[i-7]==1'b0
      )
  begin
    #1 FoundPads = 1'b1;   // 1 means true here, for later use.
    #1 nBit1 = SerVect[i-4]; // Save the padded nn = {n2, n1} value.
    #1 n2Bit = SerVect[i-3];
    disable While_i;       // Exit the while block, if found.
  end // if.
  ...
  i = i - 1;
end // While_i statement.
end // While_i named block.
",An example of Verilog code performing a pattern search within a 64-bit serial vector.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p706.jpg,True,"The image contains no actual Verilog code, but it does include information about the Verilog Procedural Interface (VPI) related to procedural objects and their type mappings. The text provides return value descriptions for the VPI according to the type of procedural object being queried or manipulated. Below is the text that appears at the bottom of the image regarding the return types:

```
int vpiType
for procedure, returns vpiInitial or vpiAlways
for procedural block, returns vpiBegin, vpiNamedBegin, vpiFork, vpiNamedFork
for procedural statement, returns vpiAssignment, vpiDelayControl, vpiEventControl, vpiWhile, vpiRepeat, vpiWait, vpiFor, vpiForever, vpiIf, vpiIfElse, vpiCase, vpiAssignStmt, vpiDeassign, vpiForce, vpiRelease, vpiDisable, vpiEventStmt, vpiFuncCall, vpiTaskCall, vpiNullStmt

str vpiFile
returns the file name containing the object

int vpiLineNo
returns the file line number containing the object
```

These details are likely to be used for reference when writing or analyzing VPI-related code in Verilog.","iType
for procedure, returns vpiInitial or vpiAlways
for procedural block, returns vpiBegin, vpiNamedBegin, vpiFork, vpiNamedFork
for procedural statement, returns vpiAssignment, vpiDelayControl, vpiEventControl, vpiWhile, vpiRepeat, vpiWait, vpiFor, vpiForever, vpiIf, vpiIfElse, vpiCase, vpiAssignStmt, vpiDeassign, vpiForce, vpiRelease, vpiDisable, vpiEventStmt, vpiFuncCall, vpiTaskCall, vpiNullStmt

str vpiFile
returns the file name containing the object

int vpiLineNo
returns the file line number containing the object
","Caption: ""Hierarchy diagram and descriptions of Verilog Procedural Interface (VPI) procedures, procedural blocks, and procedural statement objects.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p292.jpg,True,"The image contains three code examples in the context of describing specifications for digital design events using both SystemVerilog and Property Specification Language (PSL). Here are the code examples provided:

Example 8-13 SystemVerilog:

```verilog
property HitPendingSel5;
    @(posedge clk)
    $rose(hit) && !pending ##1 pending[->1] |-> sel5;
endproperty

assert property (HitPendingSel5);
```

Example 8-14 doesn't contain code, it's an English language specification for context.

Example 8-15 PSL:

```verilog
default clock = (posedge clk);

property ReqAckBusy =
    always {rose(request)} |-> {busy[1:*]; acknowledge};
    
assert ReqAckBusy;
```","
property HitPendingSel5;
    @(posedge clk)
    $rose(hit) && !pending ##1 pending[->1] |-> sel5;
endproperty

assert property (HitPendingSel5);


default clock = (posedge clk);

property ReqAckBusy =
    always {rose(request)} |-> {busy[1:*]; acknowledge};
    
assert ReqAckBusy;
",Caption: Examples of temporal property specifications in SystemVerilog and PSL (Property Specification Language) for edge-sensitive events and non-overlapping conditions.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p203.jpg,True,"The image shows text discussing Verilog properties related to multiply clocked systems. It includes a snippet of Verilog code related to the topic. The code on the page is as follows:

```verilog
property mclocks;
    @(posedge clk1) b and @(posedge clk1) c;
endproperty

baseP: assert property(@(posedge clk0) a |-> mclocks) else gotoFail;
coverP: cover property(@(posedge clk0) a |=> mclocks) gotoPass;
```

It's important to note that the ""baseP"" and ""coverP"" lines contain pseudo-code or illustrative text (""gotoFail"", ""gotoPass"") which might not compile in a real Verilog environment without further context or definition of the ""gotoFail"" and ""gotoPass"" labels.","
property mclocks;
    @(posedge clk1) b and @(posedge clk1) c;
endproperty

baseP: assert property(@(posedge clk0) a |-> mclocks) else gotoFail;
coverP: cover property(@(posedge clk0) a |=> mclocks) gotoPass;
","""Exploring 'and' operator in Verilog for multiply clocked properties.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p84.jpg,True,"The image contains Verilog code examples. Here are the code snippets:

For the OVERLAPPING OPERATOR:
```verilog
property pr1;
    @(posedge clk) cStart |-> ##1 (req ##2 gnt);
endproperty

baseP: assert property (pr1);
```

For the NON-OVERLAPPING OPERATOR:
```verilog
property pr1;
    @(posedge clk) cStart |=> (req ##2 gnt);
endproperty

baseP: assert property (pr1);
```

These code snippets showcase the use of overlapping (`|->`) and non-overlapping (`|=>`) implication operators in property specification within SystemVerilog assertions (SVA).","
property pr1;
    @(posedge clk) cStart |-> ##1 (req ##2 gnt);
endproperty

baseP: assert property (pr1);


property pr1;
    @(posedge clk) cStart |=> (req ##2 gnt);
endproperty

baseP: assert property (pr1);
",Equivalence between overlapping and nonoverlapping implication operators in Verilog assertions,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p90.jpg,True,"The image contains Verilog code, which is shown below:

```verilog
module assert1;
reg A, B, C, D, clk;

property ab;
  @(posedge clk) !A |-> B;
endproperty

aba: assert property (ab) else $display ($stime,,, ""ab FAIL"");
abc: cover property (ab) $display($stime,,, ""ab PASS"");

initial begin
  clk=0; A=0; B=0; //Note: A and B are equal to '0' at time 0.
  forever #10 clk=! clk;
end

initial begin
`ifdef PASS

/* Following sequence of events will cause property 'ab' to
   PASS because even though A=0 and B=1 change simultaneously
   they had settled down because of #1 before posedge clk. Hence
   when @(posedge clk) samples A, B; A=0 and B=1 are sampled.
   The property antecedent '!\A' is evaluated to be true and at
   that same time (overlapping operator) B==1. Hence the prop-
   erty passes */

A=0;
B=1;
#1;
@(posedge clk)

`else

/* Following sequence of events will cause property 'ab' to
   FAIL. Here’s the story. A=0 and B=1 change at the same time
   as posedge clk. This causes the sampled value of B to be
   equal to '0' and not '1' because the sampling edge (posedge
   clk) samples the variable values in the preponed region and
   B was equal to '0' in the preponed region. Note that A was
   equal to '0' in the preponed region because of its initial-
   ization in the 'initial' block above. So, now you have both
   'A' and 'B' == 0. Since A is 0, !A is true, and the property
   evaluation takes place. Property expects B==1 the same time
   (overlapping operator) that !A is true. However, 'B’s sam-
   pled value is '0' and the property fails. */
```

This code is part of a tutorial or documentation discussing concurrent assertions in Verilog, specifically detailing how properties are evaluated in certain scenarios with edge conditions and timing considerations.","
module assert1;
reg A, B, C, D, clk;

property ab;
  @(posedge clk) !A |-> B;
endproperty

aba: assert property (ab) else $display ($stime,,, ""ab FAIL"");
abc: cover property (ab) $display($stime,,, ""ab PASS"");

initial begin
  clk=0; A=0; B=0; //Note: A and B are equal to '0' at time 0.
  forever #10 clk=! clk;
end

initial begin
`ifdef PASS

/* Following sequence of events will cause property 'ab' to
   PASS because even though A=0 and B=1 change simultaneously
   they had settled down because of #1 before posedge clk. Hence
   when @(posedge clk) samples A, B; A=0 and B=1 are sampled.
   The property antecedent '!\A' is evaluated to be true and at
   that same time (overlapping operator) B==1. Hence the prop-
   erty passes */

A=0;
B=1;
#1;
@(posedge clk)

`else

/* Following sequence of events will cause property 'ab' to
   FAIL. Here’s the story. A=0 and B=1 change at the same time
   as posedge clk. This causes the sampled value of B to be
   equal to '0' and not '1' because the sampling edge (posedge
   clk) samples the variable values in the preponed region and
   B was equal to '0' in the preponed region. Note that A was
   equal to '0' in the preponed region because of its initial-
   ization in the 'initial' block above. So, now you have both
   'A' and 'B' == 0. Since A is 0, !A is true, and the property
   evaluation takes place. Property expects B==1 the same time
   (overlapping operator) that !A is true. However, 'B’s sam-
   pled value is '0' and the property fails. */
","""Example of Verilog code demonstrating concurrent assertions with sequence operator '->' and the usage of 'assert' and 'cover' properties.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p217.jpg,True,"The image contains Verilog/SystemVerilog code. Here it is:

```verilog
sequence s1;
int x;
(
  (a ##1 b,x=data)
  and
  (d ##1 e)
  ##1 (data1==x+1)
);
endsequence

sequence rdC;
##[1:5] b;
endsequence

sequence dSeq;
##2 d ##2 e;
endsequence

sequence dataCheck;
int ldata1, ldata2;
(rdc, ldata1=rData, ldata2=retryData) ##5
(dSeq, ldata2 = (ldata2+'hff)) ##0
// (wData == ldata1, wretryData==ldata2);
(wData == ldata1) ##0
(wretryData == ldata2);
endsequence

baseP: assert property (@(posedge clk) a |=> dataCheck) else gotoFail;
```

The image shows examples of how to use local variables within Verilog/SystemVerilog sequences, as well as providing some additional commentary on the correct ways to use them in expressions and sequences.","
sequence s1;
int x;
(
  (a ##1 b,x=data)
  and
  (d ##1 e)
  ##1 (data1==x+1)
);
endsequence

sequence rdC;
##[1:5] b;
endsequence

sequence dSeq;
##2 d ##2 e;
endsequence

sequence dataCheck;
int ldata1, ldata2;
(rdc, ldata1=rData, ldata2=retryData) ##5
(dSeq, ldata2 = (ldata2+'hff)) ##0
// (wData == ldata1, wretryData==ldata2);
(wData == ldata1) ##0
(wretryData == ldata2);
endsequence

baseP: assert property (@(posedge clk) a |=> dataCheck) else gotoFail;
","Caption: ""Exploring local variable use in Verilog sequences with an emphasis on best practices for assigning and checking values.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p319.jpg,True,"The image contains a snippet of Verilog code. Here's the code:

```verilog
module counter_0_to_8(reset_n, clk, inc, dec);
input reset_n, clk, inc, dec;
reg [3:0] count;

always @ (posedge clk) begin
    if (reset_n) count = 4'b0;
    else count = count + inc - dec;
end
// OVL check for valid range
assert_never # (0, 0, 0, ""range 0-8 error"")
    valid_count (clk, reset_n, (count > 4'b1000));
endmodule
```

Please note that this code is used as an example for monitoring a legal range for a `count` variable using an `assert_never` check from the Open Verification Library (OVL). The comment ""// OVL check for valid range"" precedes the actual assertion check which ensures that the `count` variable never exceeds 8 (the binary representation of 8 being `4'b1000`).","
module counter_0_to_8(reset_n, clk, inc, dec);
input reset_n, clk, inc, dec;
reg [3:0] count;

always @ (posedge clk) begin
    if (reset_n) count = 4'b0;
    else count = count + inc - dec;
end
// OVL check for valid range
assert_never # (0, 0, 0, ""range 0-8 error"")
    valid_count (clk, reset_n, (count > 4'b1000));
endmodule
",Verilog module demonstrating the use of OVL assert_never to monitor count variable within a valid range.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p388.jpg,True,"The image contains Verilog code, which seems to be part of a larger document or book. Here is the code transcribed from the image:

```verilog
`ifndef check1
    fifo_empty <= 1;
`endif
    fifo_full <= 0;
end
else begin
    case ((fifo_write, fifo_read))
        2'b00: ; // everyone's sleeping!
        2'b01: begin // read
            if (cnt>0) begin
                rd_ptr <= rd_ptr + 1;
                cnt <= cnt - 1;
            end
`ifdef check2
            if (cnt==0) fifo_empty <= 1;
`else
`ifdef check5
            if (cnt==1) fifo_empty <= 1;
                rd_ptr <= rd_ptr+1;
            else 
                if (cnt==1) fifo_empty <= 1;
`endif
`endif
            fifo_full <= 0;
        end
        2'b10: begin // write
            if (cnt< fifo_depth) begin
                fifomem[wr_ptr] <= fifo_data_in;
                wr_ptr <= wr_ptr + 1;
                cnt <= cnt + 1;
            end
`ifdef check3
            if (cnt>(fifo_depth - 1)) fifo_full <= 1;
`else
`ifdef check4
            if (cnt>(fifo_depth - 1)) fifo_full <= 1;
                wr_ptr <= wr_ptr+1;
            else 
                if (cnt>(fifo_depth - 1)) fifo_full <= 1;
`endif
`endif
            fifo_empty <= 0;
        end
        2'b11: // write && read
        //You cannot write if cnt is full; so, read only
            if (cnt>(fifo_depth - 1)) begin
                rd_ptr <= rd_ptr + 1;
```

The code is incomplete as the image has a cut-off at the bottom, which means some part of the code is missing. It describes the behavior of a finite state machine, likely controlling a FIFO (first-in-first-out) buffer. It uses pre-compiler directives like `ifdef` to conditionally compile parts of the code.","
`ifndef check1
    fifo_empty <= 1;
`endif
    fifo_full <= 0;
end
else begin
    case ((fifo_write, fifo_read))
        2'b00: ; // everyone's sleeping!
        2'b01: begin // read
            if (cnt>0) begin
                rd_ptr <= rd_ptr + 1;
                cnt <= cnt - 1;
            end
`ifdef check2
            if (cnt==0) fifo_empty <= 1;
`else
`ifdef check5
            if (cnt==1) fifo_empty <= 1;
                rd_ptr <= rd_ptr+1;
            else 
                if (cnt==1) fifo_empty <= 1;
`endif
`endif
            fifo_full <= 0;
        end
        2'b10: begin // write
            if (cnt< fifo_depth) begin
                fifomem[wr_ptr] <= fifo_data_in;
                wr_ptr <= wr_ptr + 1;
                cnt <= cnt + 1;
            end
`ifdef check3
            if (cnt>(fifo_depth - 1)) fifo_full <= 1;
`else
`ifdef check4
            if (cnt>(fifo_depth - 1)) fifo_full <= 1;
                wr_ptr <= wr_ptr+1;
            else 
                if (cnt>(fifo_depth - 1)) fifo_full <= 1;
`endif
`endif
            fifo_empty <= 0;
        end
        2'b11: // write && read
        //You cannot write if cnt is full; so, read only
            if (cnt>(fifo_depth - 1)) begin
                rd_ptr <= rd_ptr + 1;
","This image shows a snippet of Verilog code for simulating the operations of a FIFO (First-In-First-Out) buffer, with conditional compilation blocks to toggle functionality.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p699.jpg,True,"The image contains text describing Verilog VPI (Verilog Procedural Interface) routines related to memory objects. There is no executable code in this image, just explanatory text regarding VPI function calls and properties. The text includes function prototypes and explanations of what they return or represent. Here is the text from the image:

```
int vpiType                     returns vpiMemory, vpiMemoryWord
int vpiSize                     for a memory, returns the number of words in the memory; for a
                                 memory word, returns the number of bits in a word
str vpiName                     returns the name of a memory or memory word
str vpiFullName                returns the full hierarchical path name of a memory or memory
                                 word
str vpiFile                     returns the file name containing the memory declaration
int vpiLineNo                  returns file line number of the memory declaration

1. A memory is a 1-dimensional array of reg (e.g.: reg [7:0] RAM [0:1023];.

2. For a memory object, vpiLeftRange and vpiRightRange refer to the starting and
   ending address of a memory declaration.

3. For a memory word object, vpiLeftRange and vpiRightRange refer to the MSB and
   LSB of the word.

4. The value of a memory word is accessed using vpi_get_value() and
   vpi_put_value().
```

This text outlines the API for interacting with memory objects in a Verilog simulation environment through VPI calls.","iType                     returns vpiMemory, vpiMemoryWord
int vpiSize                     for a memory, returns the number of words in the memory; for a
                                 memory word, returns the number of bits in a word
str vpiName                     returns the name of a memory or memory word
str vpiFullName                returns the full hierarchical path name of a memory or memory
                                 word
str vpiFile                     returns the file name containing the memory declaration
int vpiLineNo                  returns file line number of the memory declaration

1. A memory is a 1-dimensional array of reg (e.g.: reg [7:0] RAM [0:1023];.

2. For a memory object, vpiLeftRange and vpiRightRange refer to the starting and
   ending address of a memory declaration.

3. For a memory word object, vpiLeftRange and vpiRightRange refer to the MSB and
   LSB of the word.

4. The value of a memory word is accessed using vpi_get_value() and
   vpi_put_value().
","""Excerpt from the IEEE 1364-1995 VPI Routine Library documentation detailing VPI memory objects in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p76.jpg,True,"The image contains Verilog code, specifically related to PSL (Property Specification Language) assertions. Here is the code present in the image:

```verilog
// constrain the error_injection to all zeroes, or a one-hot value
assume always ((error_injection & (error_injection - 1)) == 1'b0);

// assert that the data_in equals the data_out for single bit errors.
assert always (data_in == data_out);
```

The comments describe the constraints and assertions being made for an error detection and correction mechanism using an ECC (Error-Correcting Code) check block.","
// constrain the error_injection to all zeroes, or a one-hot value
assume always ((error_injection & (error_injection - 1)) == 1'b0);

// assert that the data_in equals the data_out for single bit errors.
assert always (data_in == data_out);
","Caption: ""An excerpt from a document explaining PSL (Property Specification Language) assertions in Verilog for verifying that an ECC (Error Correcting Code) check block detects and corrects single-bit errors.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p331.jpg,True,"```verilog
module processor (clk, reset_n, ..., rd, rd_ack, ... ) ;
  input clk;
  input reset_n;

  output rd
  input rd_ack;

  inout [31:0] data_bus;

  ...

  assert_win_change # (0,32) sync_bus_with_rd
    (clk, reset_n, rd, data_bus, rd_ack) ;

endmodule
```","
module processor (clk, reset_n, ..., rd, rd_ack, ... ) ;
  input clk;
  input reset_n;

  output rd
  input rd_ack;

  inout [31:0] data_bus;

  ...

  assert_win_change # (0,32) sync_bus_with_rd
    (clk, reset_n, rd, data_bus, rd_ack) ;

endmodule
","""Excerpt from a document detailing the use of Verilog assertions, with an example Verilog module implementing the assert_win_change function.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p238.jpg,True,"The image contains a waveform diagram for a ""Burst write to Burst terminate command"" and some Verilog code. Here is the Verilog code from the image:

```verilog
property p_rd_burstterminate;
    @(posedge clk) (s_burstterminate) |-> 
    $past ((`s_burst_read || `s_read),
           1);
endproperty

c_rd_burstterminate:
    cover property(p_rd_burstterminate);
```

This piece of code is defining a property `p_rd_burstterminate` for use in formal verification or assertions inside the design. It is then used in a `cover` statement, which is typically used in verification to ensure that this scenario is covered in the testing process.","
property p_rd_burstterminate;
    @(posedge clk) (s_burstterminate) |-> 
    $past ((`s_burst_read || `s_read),
           1);
endproperty

c_rd_burstterminate:
    cover property(p_rd_burstterminate);
","""Verilog code example demonstrating the assertion for read termination by burst terminate in SDRAM operations""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p117.jpg,True,"The image contains text related to Verilog assertions, but it also includes two snippets of Verilog code:

1. The first snippet of Verilog code:
```verilog
a1: assert property (@clk p);
```

2. The second snippet of Verilog code:
```verilog
initial a2: assert property (@clk always p);
```","
a1: assert property (@clk p);


initial a2: assert property (@clk always p);
","Caption: Discussion and examples of Verilog assertion properties utilizing 'always' and 'nexttime' operators, along with an example of the implicit 'always' operator in verification contexts.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p100.jpg,True,"Here is the code from the image:

```verilog
/* obtain handle to system task argument
 * compiletf has already verified only 1 arg with correct type */
arg_iterator = vpi_iterate(vpiArgument, systf_handle);
module_handle = vpi_scan(arg_iterator);
vpi_free_object(arg_iterator); /* free iterator memory */

/* read current simulation time */
current_time.type = vpiScaledRealTime;
vpi_get_time(systf_handle, &current_time);

vpi_printf(""\nAt time %2.2f, signals in module %s (%s):\n"",
           current_time.real,
           vpi_get_str(vpiFullName, module_handle),
           vpi_get_str(vpiDefName, module_handle));

/* obtain handles to nets in module and read current value */
signal_iterator = vpi_iterate(vpiNet, module_handle);
if (signal_iterator != NULL)
    PLIbook_PrintSignalValues(signal_iterator);

/* obtain handles to regs in module and read current value */
signal_iterator = vpi_iterate(vpiReg, module_handle);
if (signal_iterator != NULL)
    PLIbook_PrintSignalValues(signal_iterator);

/* obtain handles to variables in module and read current value */
signal_iterator = vpi_iterate(vpiVariables, module_handle);
if (signal_iterator != NULL)
    PLIbook_PrintSignalValues(signal_iterator);

vpi_printf(""\n""); /* add some white space to output */
return(0);
}

void PLIbook_PrintSignalValues(vpiHandle signal_iterator)
{
    vpiHandle signal_handle;
    int signal_type;
    s_vpi_value current_value;

    while ( (signal_handle = vpi_scan(signal_iterator)) != NULL ) {
        signal_type = vpi_get(vpiType, signal_handle);
        switch (signal_type) {
            case vpiNet:
                current_value.format = vpiBinStrVal;
                vpi_get_value(signal_handle, &current_value);
                vpi_printf("" net %8-10s value is %s (binary)\n"",
                           vpi_get_str(vpiName, signal_handle),
                           current_value.value.str);
                break;

            case vpiReg:
                current_value.format = vpiBinStrVal;
```
Please note that the code snippet is incomplete as it ends abruptly and there might be more code following this section that is not visible in the image provided.","
/* obtain handle to system task argument
 * compiletf has already verified only 1 arg with correct type */
arg_iterator = vpi_iterate(vpiArgument, systf_handle);
module_handle = vpi_scan(arg_iterator);
vpi_free_object(arg_iterator); /* free iterator memory */

/* read current simulation time */
current_time.type = vpiScaledRealTime;
vpi_get_time(systf_handle, &current_time);

vpi_printf(""\nAt time %2.2f, signals in module %s (%s):\n"",
           current_time.real,
           vpi_get_str(vpiFullName, module_handle),
           vpi_get_str(vpiDefName, module_handle));

/* obtain handles to nets in module and read current value */
signal_iterator = vpi_iterate(vpiNet, module_handle);
if (signal_iterator != NULL)
    PLIbook_PrintSignalValues(signal_iterator);

/* obtain handles to regs in module and read current value */
signal_iterator = vpi_iterate(vpiReg, module_handle);
if (signal_iterator != NULL)
    PLIbook_PrintSignalValues(signal_iterator);

/* obtain handles to variables in module and read current value */
signal_iterator = vpi_iterate(vpiVariables, module_handle);
if (signal_iterator != NULL)
    PLIbook_PrintSignalValues(signal_iterator);

vpi_printf(""\n""); /* add some white space to output */
return(0);
}

void PLIbook_PrintSignalValues(vpiHandle signal_iterator)
{
    vpiHandle signal_handle;
    int signal_type;
    s_vpi_value current_value;

    while ( (signal_handle = vpi_scan(signal_iterator)) != NULL ) {
        signal_type = vpi_get(vpiType, signal_handle);
        switch (signal_type) {
            case vpiNet:
                current_value.format = vpiBinStrVal;
                vpi_get_value(signal_handle, &current_value);
                vpi_printf("" net %8-10s value is %s (binary)\n"",
                           vpi_get_str(vpiName, signal_handle),
                           current_value.value.str);
                break;

            case vpiReg:
                current_value.format = vpiBinStrVal;
",Excerpt from a Verilog Procedural Interface (VPI) example demonstrating how to extract and print simulation signal values.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p103.jpg,True,"The image contains two snippets of code in the context of Verilog assumptions. Here they are:

```verilog
mutex: assume final (rst || $onehot0({read, write}))
else $error(""read/write contention"");
```

Or alternately as a concurrent assumption:

```verilog
mutex: assume property (@(posedge clk) disable iff (rst)
$onehot0({read, write})) else $error(""read/write contention"");
```

These snippets describe how to define mutual exclusion for the `read` and `write` signals in a hardware design using the SystemVerilog language. The first example uses `assume final` for an immediate assumption, and the second example shows a concurrent assumption using `assume property`.","
mutex: assume final (rst || $onehot0({read, write}))
else $error(""read/write contention"");


mutex: assume property (@(posedge clk) disable iff (rst)
$onehot0({read, write})) else $error(""read/write contention"");
","""Document excerpt describing the use of assumptions in Verilog to specify mutual exclusivity of read and write signals using `assume` and `assert`.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p672.jpg,True,"The image contains two segments of code: one is a sample PLI definitions file for the Silos III simulator, and the other is a sample Visual C++ make file for the same simulator.

Here is the first code excerpt from Example A-13:

```plaintext
LIBRARY
EXPORTS
veriusertfs
PLIbook_ShowVal_checktf
PLIbook_ShowVal_calltf
PLIbook_pow_sizetf
PLIbook_pow_checktf
PLIbook_pow_calltf
PLIbook_pow_misctf
```

And here is the second code excerpt from Example A-14:

```plaintext
SILOS_INST_DIR=c:/progra~1/silos3

# 
# SRCS set this to the list of source files for the PLI application
#
SRCS = pow_acc.c \
       show_values_acc.c \
       PLIbook_veriuser.c

#
# DEFS set this to the list of definition files for the PLI application
#
DEFS = silos_pli.def

OBJS = $(SRCS:.c=.obj)
CFLAGS = -DMSC -DWIN32 -I$(SILOS_INST_DIR)/pli -MD -O2

.c.obj:
    $(CC) $(CFLAGS) -c $<

silos_pli.dll: $(OBJS)
    link -dll /out:$@ -def:$(DEFS) $(OBJS) $(SILOS_INST_DIR)/sse.lib
```

The provided code demonstrates how to define a library with exports in a PLI definitions file and how to construct a Makefile for compiling PLI application source files into a dynamic link library (DLL) for the Silos III Verilog simulator.","xt
LIBRARY
EXPORTS
veriusertfs
PLIbook_ShowVal_checktf
PLIbook_ShowVal_calltf
PLIbook_pow_sizetf
PLIbook_pow_checktf
PLIbook_pow_calltf
PLIbook_pow_misctf

xt
SILOS_INST_DIR=c:/progra~1/silos3

# 
# SRCS set this to the list of source files for the PLI application
#
SRCS = pow_acc.c \
       show_values_acc.c \
       PLIbook_veriuser.c

#
# DEFS set this to the list of definition files for the PLI application
#
DEFS = silos_pli.def

OBJS = $(SRCS:.c=.obj)
CFLAGS = -DMSC -DWIN32 -I$(SILOS_INST_DIR)/pli -MD -O2

.c.obj:
    $(CC) $(CFLAGS) -c $<

silos_pli.dll: $(OBJS)
    link -dll /out:$@ -def:$(DEFS) $(OBJS) $(SILOS_INST_DIR)/sse.lib
","A textbook page showing appendices from ""The Verilog PLI Handbook,"" displaying example code snippets for PLI definitions and a makefile for the Silos III simulator.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p377.jpg,True,"The image shows a page with Verilog code. Here is the code:

```verilog
module dut_property(pclk, preq, pGnt);
    input pclk, preq, pGnt;

`ifdef no_implication
    property pr1;
        @(posedge pclk) preq ##2 pGnt;
    endproperty

    preqGnt: assert property (pr1) $display($stime,,,""t\t %m PASS"");
        else $display($stime,,,""t\t %m FAIL"");

`elsif implication
    property pr1;
        @(posedge pclk) preq |-> ##2 pGnt;
    endproperty

    preqGnt: assert property (pr1) $display($stime,,,""t\t %m PASS"");
        else $display($stime,,,""t\t %m FAIL"");

`elsif implication_novac
    property pr1;
        @(posedge pclk) preq |-> ##2 pGnt;
    endproperty

    preqGnt: assert property (pr1) else $display($stime,,,""t\t %m FAIL"");

    property pr2;
        @(posedge pclk) preq ##2 pGnt;
    endproperty

    cpreqGnt: cover property (pr2) $display($stime,,,""t\t % and PASS"");
`endif

endmodule
```

This code is a SystemVerilog module that defines properties for assertions using different conditions based on preprocessor directives (like `no_implication`, `implication`, and `implication_novac`). Depending on the compilation flags, the code within the corresponding `ifdef...endif` blocks will be included. The properties define temporal relationships between signals `preq` and `pGnt` with respect to the rising edge of `pclk`. The `assert` and `cover` statements are used along with `$display` system tasks to print simulation time and a PASS/FAIL message based on the result of the property evaluation.","
module dut_property(pclk, preq, pGnt);
    input pclk, preq, pGnt;

`ifdef no_implication
    property pr1;
        @(posedge pclk) preq ##2 pGnt;
    endproperty

    preqGnt: assert property (pr1) $display($stime,,,""t\t %m PASS"");
        else $display($stime,,,""t\t %m FAIL"");

`elsif implication
    property pr1;
        @(posedge pclk) preq |-> ##2 pGnt;
    endproperty

    preqGnt: assert property (pr1) $display($stime,,,""t\t %m PASS"");
        else $display($stime,,,""t\t %m FAIL"");

`elsif implication_novac
    property pr1;
        @(posedge pclk) preq |-> ##2 pGnt;
    endproperty

    preqGnt: assert property (pr1) else $display($stime,,,""t\t %m FAIL"");

    property pr2;
        @(posedge pclk) preq ##2 pGnt;
    endproperty

    cpreqGnt: cover property (pr2) $display($stime,,,""t\t % and PASS"");
`endif

endmodule
",Sample Verilog code demonstrating SystemVerilog assertions (SVAs) with conditional compilation for different property implications.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p411.jpg,True,"The image contains Verilog code. Here is the code from the image:

```verilog
// pci_master.v module
// This is a simple behavioral model that drives only a
// simple (canned!) PCI Read Transaction from the master.
// This is -not- a complete PCI master model.

module pci_master (input bit clk, reset_,
                   input logic TRDY_, DEVSEL_,
                   output logic FRAME_, IRDY_,
                   output logic [3:0] C_BE_,
                   inout wire [31:0] AD
);
  
reg [31:0] data [0:7];

bit AD_enb;
reg [31:0] AD_reg;
assign AD = AD_enb ? AD_reg:32'hZ;

initial
begin
  //de-assert control signals
  FRAME_ = 1'b1; IRDY_ = 1'b1;
  
  //Don't drive AD - yet.
  AD_enb = 1'b0;
  
  //On de-assertion of reset_
  @(posedge reset_);
  
  //Drive FRAME_, AD and C_BE_ (for a memory read)
  @(negedge clk);
  FRAME_ = 1'b0;

  // check1
  `ifdef check1
    AD_reg = 32'h 0000_1234;
  `else
    AD_reg = 32'h 0000_1234; AD_enb = 1'b1;
  `endif
  C_BE_ = 4'b 0110;
  $display(""\n"",""\\tDrive FRAME_, AD and Read Command"");
```

The code snippet is part of a Verilog module that describes a simple behavioral model for a PCI Master Device Under Test (DUT). It includes the module declaration, input and output ports, registers, control signals, conditional compilation block (`ifdef`, `else`, `endif`), and some initial block code for simulating a PCI read transaction.","
// pci_master.v module
// This is a simple behavioral model that drives only a
// simple (canned!) PCI Read Transaction from the master.
// This is -not- a complete PCI master model.

module pci_master (input bit clk, reset_,
                   input logic TRDY_, DEVSEL_,
                   output logic FRAME_, IRDY_,
                   output logic [3:0] C_BE_,
                   inout wire [31:0] AD
);
  
reg [31:0] data [0:7];

bit AD_enb;
reg [31:0] AD_reg;
assign AD = AD_enb ? AD_reg:32'hZ;

initial
begin
  //de-assert control signals
  FRAME_ = 1'b1; IRDY_ = 1'b1;
  
  //Don't drive AD - yet.
  AD_enb = 1'b0;
  
  //On de-assertion of reset_
  @(posedge reset_);
  
  //Drive FRAME_, AD and C_BE_ (for a memory read)
  @(negedge clk);
  FRAME_ = 1'b0;

  // check1
  `ifdef check1
    AD_reg = 32'h 0000_1234;
  `else
    AD_reg = 32'h 0000_1234; AD_enb = 1'b1;
  `endif
  C_BE_ = 4'b 0110;
  $display(""\n"",""\\tDrive FRAME_, AD and Read Command"");
",Verilog code snippet for a simplified PCI master behavioral model that performs a canned PCI read transaction.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p289.jpg,True,"```verilog
module assert_frame (ck, reset_n, start_event, test_expr);
    parameter severity_level=0;
    parameter min_cks=-1;
    parameter max_cks=1;
    parameter flag=0;
    parameter msg=""ASSERT FRAME VIOLATION"";
    input ck;
    input reset_n;
    input start_event;
```

This code snippet defines a Verilog module named `assert_frame` with parameters for severity level, minimum clock cycles, maximum clock cycles, a flag, an error message, and input ports for a clock signal `ck`, a reset signal `reset_n`, and a start event signal `start_event`. The purpose of the module is described in the text but not fully shown in the image. The `test_expr` input is mentioned in the function definition but not in the list that defines all other inputs and parameters, which suggests that this image is cropped and there may be more code or information beyond what is displayed.","
module assert_frame (ck, reset_n, start_event, test_expr);
    parameter severity_level=0;
    parameter min_cks=-1;
    parameter max_cks=1;
    parameter flag=0;
    parameter msg=""ASSERT FRAME VIOLATION"";
    input ck;
    input reset_n;
    input start_event;
",Verilog code for an assertion monitor module with parameters explained in a table and usage cases.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p39.jpg,True,"```
`timescale 1ns / 1ns
module test;

initial
begin
    $hello;
    #10 $stop;
    $finish;
end

endmodule
```","cale 1ns / 1ns
module test;

initial
begin
    $hello;
    #10 $stop;
    $finish;
end

endmodule
","Caption: ""Example of a Verilog simulation using the Programming Language Interface (PLI) to display 'Hello World!' in the output.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p127.jpg,True,"```verilog
int new_address1, new_address2;
bit clk;
initial begin
    fork
        my_task2(21, new_address1);
        my_task2(20, new_address2);
    join
    $display(""new_address1 = %0d"", new_address1);
    $display(""new_address2 = %0d"", new_address2);
end

initial
    forever #50 clk = !clk;

task my_task2(input int address, output int new_address);
    @(clk);
    new_address = address;
endtask
```","
int new_address1, new_address2;
bit clk;
initial begin
    fork
        my_task2(21, new_address1);
        my_task2(20, new_address2);
    join
    $display(""new_address1 = %0d"", new_address1);
    $display(""new_address2 = %0d"", new_address2);
end

initial
    forever #50 clk = !clk;

task my_task2(input int address, output int new_address);
    @(clk);
    new_address = address;
endtask
",Exercise on SystemVerilog tasks and procedural concurrency in a simulation environment.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p128.jpg,True,"The image contains a snippet of code related to the Verilog Programming Language Interface (PLI). Here's the code presented:

```c
char prim_name[64];
vpiHandle prim_handle;
double new_delay;

fscanf(file_p, ""%s %f"", prim_name, &new_delay);
prim_handle = vpi_handle_by_name(prim_name, NULL);
if (prim_handle != NULL)
    /* add new delay value to the primitive object */
else
    /* error: primitive not found */
```

This code snippet is to be used in a context where `file_p` is a file pointer to a file that contains names of primitive instances and corresponding delay values. It updates the delay value of a Verilog primitive using the Verilog PLI.","prim_name[64];
vpiHandle prim_handle;
double new_delay;

fscanf(file_p, ""%s %f"", prim_name, &new_delay);
prim_handle = vpi_handle_by_name(prim_name, NULL);
if (prim_handle != NULL)
    /* add new delay value to the primitive object */
else
    /* error: primitive not found */
","""Excerpt from The Verilog PLI Handbook showing documentation and example code for accessing Verilog objects by name using the VPI library.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p405.jpg,True,"The image contains code written in Verilog, a hardware description language used to model electronic systems. Here is the code from the image:

```verilog
`ifdef nobugs
    $display(""SCENARIO 6"");
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b1;
    @(negedge clk); dValid='b0; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b0; data=8'h0; dAck=1'b0;
    $display(""\n"");
`else
    $display(""SCENARIO 6"");
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b0; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b0; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b0; data=8'h0; dAck=1'b0;
    $display(""\n"");
`endif

`ifdef nobugs
    $display(""SCENARIO 7"");
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b1;
    @(negedge clk); dValid='b0; data=8'h0; dAck=1'b0;
    $display(""\n"");
`else
    $display(""SCENARIO 7"");
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'hx; dAck=1'b1;
    @(negedge clk); dValid='b0; data=8'h0; dAck=1'b0;

    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'h1; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b1;
    @(negedge clk); dValid='b0; data=8'h0; dAck=1'b0;
    $display(""\n"");
`endif

@(negedge clk);

$finish(2);
end
endmodule
```

The Verilog code seems to be snippets from a testbench or simulation module, where certain scenarios are being tested depending on whether a `nobugs` directive is defined. The `dValid`, `data`, and `dAck` signals are samples at the negative edge of the clock (`clk`). The `$display` function is used to print messages during simulation. The `$finish` function is to terminate the simulation after a specified time delay (2 simulation time units in this case).","
`ifdef nobugs
    $display(""SCENARIO 6"");
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b1;
    @(negedge clk); dValid='b0; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b0; data=8'h0; dAck=1'b0;
    $display(""\n"");
`else
    $display(""SCENARIO 6"");
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b0; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b0; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b0; data=8'h0; dAck=1'b0;
    $display(""\n"");
`endif

`ifdef nobugs
    $display(""SCENARIO 7"");
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b1;
    @(negedge clk); dValid='b0; data=8'h0; dAck=1'b0;
    $display(""\n"");
`else
    $display(""SCENARIO 7"");
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'hx; dAck=1'b1;
    @(negedge clk); dValid='b0; data=8'h0; dAck=1'b0;

    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'h1; dAck=1'b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck=1'b1;
    @(negedge clk); dValid='b0; data=8'h0; dAck=1'b0;
    $display(""\n"");
`endif

@(negedge clk);

$finish(2);
end
endmodule
","Caption: ""Verilog simulation for different scenarios involving clock edge triggers and signal assignments, with conditional compilation using `ifdef` directives for debugging purposes.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p133.jpg,True,"The image contains an excerpt of text about the ""Interface Construct"" in Verilog and includes a block diagram and a sample interface code. Here is the Verilog code presented in the image:

```verilog
interface arb_if(input bit clk);
    logic [1:0] grant, request;
    bit rst;
endinterface
```

This sample interface, labeled as ""Sample 4.4,"" is described as a simple interface for an arbiter with a clock input (`clk`), two 2-bit logic signals (`grant` and `request`), and a reset signal (`rst`).","
interface arb_if(input bit clk);
    logic [1:0] grant, request;
    bit rst;
endinterface
","""An excerpt from a textbook explaining the use of interfaces in Verilog to simplify connections between design blocks, along with an example of a simple interface definition.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p229.jpg,True,"```verilog
x <= '1'b1;
y <= '1'b0; // z gets the old value of x (not shown).
z <= x;     // x gets the '1'b1 originally scheduled.
```

```verilog
#2 x <= '1'b1;
#2 x <= '1'b0; // x will be scheduled for '1'bz
#2 x <= '1'bz; // at 2 time units from current time.
```","
x <= '1'b1;
y <= '1'b0; // z gets the old value of x (not shown).
z <= x;     // x gets the '1'b1 originally scheduled.


#2 x <= '1'b1;
#2 x <= '1'b0; // x will be scheduled for '1'bz
#2 x <= '1'bz; // at 2 time units from current time.
","""Understanding nonblocking and blocking assignments in Verilog simulation and the implications for event scheduling.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p215.jpg,True,"The image contains snippets of Verilog code. Here they are:

```verilog
reg[2:0] CurState;
// Don't allow any other module to affect the state encoding
// in our 3-bit CurState counter; so, use localparams:
//
localparam empty = 3'b000, // all 0 = empty.
           a_empty = 3'b010, // LSB = 0 close to empty.
           normal = 3'b011, // a_empty < normal < a_full.
           a_full = 3'b101, // MSB = 1 close to full.
           full = 3'b111; // all 1 = full.

// The clocked sequential block controlling state transitions:
//
always@(posedge Clk, posedge Reset)
    if (Reset=='b1)
        CurState <= empty;
    else
        CurState <= NextState;
// End sequential state transition block.
```

The code shows the definition of a state machine using a 3-bit register `CurState` and a localparam declaration for various states. Also, there's an always block that handles the state transitions, with sensitivity to the positive edge of a clock signal `Clk` and a reset signal `Reset`. When `Reset` is asserted, `CurState` is set to `empty`; otherwise, `CurState` transitions to `NextState`.","
reg[2:0] CurState;
// Don't allow any other module to affect the state encoding
// in our 3-bit CurState counter; so, use localparams:
//
localparam empty = 3'b000, // all 0 = empty.
           a_empty = 3'b010, // LSB = 0 close to empty.
           normal = 3'b011, // a_empty < normal < a_full.
           a_full = 3'b101, // MSB = 1 close to full.
           full = 3'b111; // all 1 = full.

// The clocked sequential block controlling state transitions:
//
always@(posedge Clk, posedge Reset)
    if (Reset=='b1)
        CurState <= empty;
    else
        CurState <= NextState;
// End sequential state transition block.
",Verilog code showing state encoding and a sequential state transition block.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p103.jpg,True,"The image contains Verilog code snippets. Here they are transcribed below:

```verilog
// 4-state types
enum logic [1:0] {HOLD, LOAD, STORE} state_e, nstate_e;

enum bit [2:0] {HOLD = 3'b001,
                LOAD = 3'b010,
                STORE = 3'b100} state_e, nstate_e;
```

These snippets define enumerated data types with specific states for use in a state machine within a Verilog or SystemVerilog design.","
// 4-state types
enum logic [1:0] {HOLD, LOAD, STORE} state_e, nstate_e;

enum bit [2:0] {HOLD = 3'b001,
                LOAD = 3'b010,
                STORE = 3'b100} state_e, nstate_e;
","""Recommended practices to avoid common RTL modeling pitfalls in Verilog code, showcasing the use of SystemVerilog `always_comb` and enum types.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p23.jpg,True,"```c
if (day=15) /* GOTCHA! assigns value of 15 to day, then */
do_mid_month_payroll; /* if day is non-zero, do a payroll */
```

The code above is an example from the C programming language that is mentioned in the context of common errors or ""gotchas"" that can be made while coding. This is intended to illustrate a type of error that can also occur in Verilog or SystemVerilog, which are the main subjects of the text.","ay=15) /* GOTCHA! assigns value of 15 to day, then */
do_mid_month_payroll; /* if day is non-zero, do a payroll */
","Caption: ""Understanding Programming 'Gotchas' in Verilog and SystemVerilog - Importance of Correct Syntax and Semantics to Prevent Unexpected Behavior in Hardware Design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p127.jpg,True,"```c
/**********************************************
 * calltf routine to check assertions         *
 **********************************************/

int assert_always_calltf (char *user_data)
{
    /* read current value */
    if (tf_getp(1) == 0) {
        io_printf(""ASSERT ALWAYS ERROR at %s:%s\n"", 
                  tf_strgettime(), tf_spname());
        tf_dofinish (); /* stop simulation */
    }
    return(0);
}
```","******************************************
 * calltf routine to check assertions         *
 **********************************************/

int assert_always_calltf (char *user_data)
{
    /* read current value */
    if (tf_getp(1) == 0) {
        io_printf(""ASSERT ALWAYS ERROR at %s:%s\n"", 
                  tf_strgettime(), tf_spname());
        tf_dofinish (); /* stop simulation */
    }
    return(0);
}
",Verilog PLI calltf routine for the $assert_always assertion check with explanations of specific PLI routines used within.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p480.jpg,True,"The image contains two snippets of code, with the first snippet written in C and the second in SystemVerilog. Here's the C code from the image:

```c
#include <svdpi.h>
#include <stdio.h>
extern void mem_build(int);

void read_file(char *fname){
    char cmd;
    FILE *file;

    file = fopen(fname, ""r"");
    while (!feof(file)) {
        cmd = fgetc(file);
        switch (cmd)
        {
            case 'M': {
                int hi;
                fscanf(file, ""%d"", &hi);
                mem_build(hi);
                break;
            }
        }
    }
    fclose(file);
}
```

And the SystemVerilog code from the image:

```verilog
module memory;
    import ""DPI-C"" context function void read_file(string fname);
    export ""DPI-C"" function mem_build; // No type or args

    initial
        read_file(""mem.dat"");

    int mem[];

    function void mem_build(input int size);
        mem = new[size]; // Allocate dynamic memory elements
    endfunction

endmodule : memory
```","ude <svdpi.h>
#include <stdio.h>
extern void mem_build(int);

void read_file(char *fname){
    char cmd;
    FILE *file;

    file = fopen(fname, ""r"");
    while (!feof(file)) {
        cmd = fgetc(file);
        switch (cmd)
        {
            case 'M': {
                int hi;
                fscanf(file, ""%d"", &hi);
                mem_build(hi);
                break;
            }
        }
    }
    fclose(file);
}


module memory;
    import ""DPI-C"" context function void read_file(string fname);
    export ""DPI-C"" function mem_build; // No type or args

    initial
        read_file(""mem.dat"");

    int mem[];

    function void mem_build(input int size);
        mem = new[size]; // Allocate dynamic memory elements
    endfunction

endmodule : memory
","Fragment of a book or document discussing communication from C to SystemVerilog, showing sample code for reading a file in C and calling a function in SystemVerilog.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p422.jpg,True,"The image contains snippets of pseudocode or mathematical functions that are not written in Verilog or any other specific programming language. These snippets are part of an academic paper or book discussing abstract concepts related to computer science, particularly related to function definitions and call context merging.

However, I will write out the function-like pseudocode from the image for you:

For the altered version of the function defined in Figure 6:
```plaintext
define g(x) = f(x+1)
define h(x) = f(x-1)
define f(x) =
  if not(intp(x)) or x=0
    then 0
  else if x < 0
    then g(x)
  else h(x)
```

For the example of the abstraction inherent in the infinite CCM relation in Figure 7:
```plaintext
define f(x) =
  if not(intp(x))
    or x ≤ 1
    then 0
  else if x mod 2 = 1
    then f(x+1)
  else 1 + f(x/2)
```

These are not executable code but logical representations of recursive functions. They are being used to illustrate points in the surrounding text concerning program analysis, termination analysis, and context merging.","xt
define g(x) = f(x+1)
define h(x) = f(x-1)
define f(x) =
  if not(intp(x)) or x=0
    then 0
  else if x < 0
    then g(x)
  else h(x)

xt
define f(x) =
  if not(intp(x))
    or x ≤ 1
    then 0
  else if x mod 2 = 1
    then f(x+1)
  else 1 + f(x/2)
","""Analyzing recursive function behavior and termination through context merging in a computational model""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p37.jpg,True,"The image contains a snippet of Verilog code. Here is the code as shown in the image:

```verilog
initial begin
    Transaction tr = new; // declaration with constructor
    bit status;          // declaration
    status = tr.randomize; // procedural statement
    begin
        Extended_trans etr = new; // OK, local declaration
        ...
    end
    ...
end
```","
initial begin
    Transaction tr = new; // declaration with constructor
    bit status;          // declaration
    status = tr.randomize; // procedural statement
    begin
        Extended_trans etr = new; // OK, local declaration
        ...
    end
    ...
end
","""Example of Verilog/SystemVerilog code demonstrating the declaration of objects and procedural statements with initialization and randomization.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p201.jpg,True,"The image contains a snippet of Verilog code which defines a function called `checkPad`. Below is the code presented in the image:

```verilog
function // 64-bit vector        8-bit pad pattern   offset in the stream
checkPad(input[VecHi:0] Stream, input[PadHi:0] pad, input[AdrHi:0] ix );
  reg OK;   // Flags pattern match.
  integer i;  // i is the data stream offset.
  integer j;  // j is the pad-byte pattern offset.
  begin
    i = ix;  // Init to stream MSB to be searched.
    OK = 0;  // Init to failed state.
    for (j=PadHi; j>=0; j = j-1)
    begin
      if (Stream[i]==pad[j])
        OK = 1;
      else begin
        OK = 0;
        disable For; // Break the for loop.
      end
      i = i - 1;
    end // for loop.
  end // For.
  checkPad = OK;
end
endfunction
```

The comment in the code explains that the `disable For;` statement is used to break the for loop inside the named block, which is the function `checkPad`. Additionally, the last statement inside the function (`checkPad = OK;`) assigns the result of the pattern match to the function's return value.","
function // 64-bit vector        8-bit pad pattern   offset in the stream
checkPad(input[VecHi:0] Stream, input[PadHi:0] pad, input[AdrHi:0] ix );
  reg OK;   // Flags pattern match.
  integer i;  // i is the data stream offset.
  integer j;  // j is the pad-byte pattern offset.
  begin
    i = ix;  // Init to stream MSB to be searched.
    OK = 0;  // Init to failed state.
    for (j=PadHi; j>=0; j = j-1)
    begin
      if (Stream[i]==pad[j])
        OK = 1;
      else begin
        OK = 0;
        disable For; // Break the for loop.
      end
      i = i - 1;
    end // for loop.
  end // For.
  checkPad = OK;
end
endfunction
",Educational material explaining tasks and functions in Verilog with an example Verilog function for checking a data stream pattern.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p473.jpg,True,"The image contains a snippet of Verilog code. The code is:

```verilog
module m(input logic i, c, output o);
    wire a = i;
    always @(posedge c)
        o <= a;
endmodule : m
```","
module m(input logic i, c, output o);
    wire a = i;
    always @(posedge c)
        o <= a;
endmodule : m
","Caption: ""A textbook excerpt discussing the formal verification model of a simple Verilog module, including its state transition graph and code implementation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p464.jpg,True,"```verilog
always @(posedge clock)\
    $show_all_nets(top.il);
```

```c
handle tfarg_handle;
tfarg_handle = acc_handle_tfarg(1);
```","
always @(posedge clock)\
    $show_all_nets(top.il);

e tfarg_handle;
tfarg_handle = acc_handle_tfarg(1);
","Caption: ""Excerpt from the Verilog PLI Handbook detailing the usage of ACC (Access Routines) routines in Verilog PLI applications, including an example of how to obtain a handle to a module instance using the acc_handle_tfarg function.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p149.jpg,True,"The image contains Verilog code along with explanations. Here is the code transcribed from the image:

```verilog
module state_transition;
    int readStartState, readIDState, readDataState, readEndState;
    logic clk, read_enb;

    `define readStart (read_enb ##1 readStartState)
    `define readID (readStartState ##1 readIDState)
    `define readData (readIDState ##1 readDataState)
    `define readEnd (readDataState ##1 readEndState)

    property checkReadStates;
    @(posedge clk)
        `readStart
        ##1 `readID
        [*1:$] ##1 `readData
        [*1:$] ##1 `readEnd;
    endproperty

    sCheck: assert property (checkReadStates) else $display($stime,, ""FAIL"");
    cCheck: cover property (checkReadStates) $display($stime,, ""PASS"");
endmodule
```

This code fragment is defining a module `state_transition` that uses Verilog's property specification language (PSL) with `define` macros and properties for checking the state transitions in some sort of state machine. The macros serve as shorthand for the conditions that specify the start, ID reading, data reading, and end states. The `property` block named `checkReadStates` specifies the sequence of events that ought to occur at the positive edge of the clock signal. There are also assertions and cover points to check the correct behavior and to verify the coverage of these properties respectively.","
module state_transition;
    int readStartState, readIDState, readDataState, readEndState;
    logic clk, read_enb;

    `define readStart (read_enb ##1 readStartState)
    `define readID (readStartState ##1 readIDState)
    `define readData (readIDState ##1 readDataState)
    `define readEnd (readDataState ##1 readEndState)

    property checkReadStates;
    @(posedge clk)
        `readStart
        ##1 `readID
        [*1:$] ##1 `readData
        [*1:$] ##1 `readEnd;
    endproperty

    sCheck: assert property (checkReadStates) else $display($stime,, ""FAIL"");
    cCheck: cover property (checkReadStates) $display($stime,, ""PASS"");
endmodule
","""Verilog code example illustrating the use of the consecutive repetition range operator in sequence properties for state transition verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p467.jpg,True,"In the image, there is a piece of code written within an exercise question. Here is the code:

```verilog
cover property (@(posedge clk) disable iff (rst)
shift_reg == 8'b10000000 && ##1 8'b00000010);
```","
cover property (@(posedge clk) disable iff (rst)
shift_reg == 8'b10000000 && ##1 8'b00000010);
","Caption: ""An illustration of the hybrid verification process in Verilog, combining simulation and formal verification (FV) techniques to detect bugs in digital designs.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p470.jpg,True,"```c
io_printf("" net %s value is %s\n"",
    acc_fetch_name(net_h),
    acc_fetch_value(net_h, ""%b"", null));
```","intf("" net %s value is %s\n"",
    acc_fetch_name(net_h),
    acc_fetch_value(net_h, ""%b"", null));
","""Extracting and printing Verilog logic values using the ACC routine `acc_fetch_value` in C as documented in The Verilog PLI Handbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p301.jpg,True,"The image includes two pieces of Verilog code. Here are the code snippets written out:

First snippet:
```verilog
a12: assert property (
a or @(ev1) b and nexttime @(ev2) c
);
```

Second snippet:
```verilog
module m3 (logic a, b, clk1, clk2);
a13: assert property (
@(posedge clk1) a |-> nexttime @(posedge clk2) b
);
a14: assert property (
@(posedge clk1) a |-> ##1 @(posedge clk2) b
);
endmodule
```","
a12: assert property (
a or @(ev1) b and nexttime @(ev2) c
);


module m3 (logic a, b, clk1, clk2);
a13: assert property (
@(posedge clk1) a |-> nexttime @(posedge clk2) b
);
a14: assert property (
@(posedge clk1) a |-> ##1 @(posedge clk2) b
);
endmodule
",An educational excerpt explaining the concept of semantic leading clocks and clocking LTL operators in Verilog assertions.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p329.jpg,True,"The image contains two code examples written in Verilog. Here they are:

Example 14.11:
```verilog
always @(posedge e1) begin
    d1 <= i1 | i2 ;
    @(posedge e2) egl <= sL & sL1;
    a11: assert property (d1 |=> i3 | i4);
    dout <= f_ecap(d1);
end
```

Example 14.12:
```verilog
always @(posedge e1) begin
    d1 <= i1 | i2 ;
    #6;
    a12: assert property (d1 |=> i3 | i4);
    dout <= f_ecap(d1);
end
```","
always @(posedge e1) begin
    d1 <= i1 | i2 ;
    @(posedge e2) egl <= sL & sL1;
    a11: assert property (d1 |=> i3 | i4);
    dout <= f_ecap(d1);
end


always @(posedge e1) begin
    d1 <= i1 | i2 ;
    #6;
    a12: assert property (d1 |=> i3 | i4);
    dout <= f_ecap(d1);
end
","""Explaining the rules for clock inferencing in Verilog procedural concurrent assertions with examples.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p325.jpg,True,"The image contains examples of Verilog code. Here is the code present in the image:

```verilog
// Sample 8.13 Copying a base handle to an extended handle

tr = new();                 // Construct base object
bad = tr;                   // ERROR: WILL NOT COMPILE
$display(bad.bad_csm);      // bad_csm is only in extended object

// Sample 8.14 Using $cast to copy handles

Transaction tr;
BadTr bad, bad2;

bad = new();                // Construct BadTr extended object
tr = bad;                   // Base handle points to extended object

// Check the object type & copy. Simulation error if mismatch
// If successful, bad2 points to the object referenced by tr
$cast(bad2, tr);

// Check for type mismatch, no simulation error
if($cast(bad2, tr))
    $display(bad2.bad_csm); // bad_csm exists in original object
else
    $display(""ERROR: cannot assign tr to bad2"");
```

These snippets show how to correctly cast a base handle to an extended handle in Verilog, using the `$cast` system task/function to perform the operation safely.","
// Sample 8.13 Copying a base handle to an extended handle

tr = new();                 // Construct base object
bad = tr;                   // ERROR: WILL NOT COMPILE
$display(bad.bad_csm);      // bad_csm is only in extended object

// Sample 8.14 Using $cast to copy handles

Transaction tr;
BadTr bad, bad2;

bad = new();                // Construct BadTr extended object
tr = bad;                   // Base handle points to extended object

// Check the object type & copy. Simulation error if mismatch
// If successful, bad2 points to the object referenced by tr
$cast(bad2, tr);

// Check for type mismatch, no simulation error
if($cast(bad2, tr))
    $display(bad2.bad_csm); // bad_csm exists in original object
else
    $display(""ERROR: cannot assign tr to bad2"");
","""Understanding object type casting in SystemVerilog with examples of correct and incorrect handle assignments.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p175.jpg,True,"The image contains several code snippets in Verilog. Here are the ones visible:

1. The first code snippet:
```verilog
sequence ab;
  a ##[1:5] b;
endsequence

sequence cde;
  c ##2 d ##2 e;
endsequence

sequence abcde;
  ab or cde;
endsequence

property ors;
  @(posedge clk) |-> abcde;
endproperty
```

2. The second code snippet:
```verilog
property abcde;
  @(posedge clk) |-> (a==b) or (c==d);
endproperty
```

3. The third code snippet:
```verilog
property BurstLengthRestrict;
  @(posedge clk) disable iff (lrst)
  ((blength==2) |->
  (rwlen==1) or (rwlen==3) or (rwlen==7) or (rwlen==15) );
endproperty
ap: assert property(BurstLengthRestrict);
```

These code blocks are examples of SystemVerilog assertions and properties used for formal verification or simulation of digital circuit designs. The accompanying text and waveforms serve to explain how these assertions work within the context of clock cycles and signal changes.","
sequence ab;
  a ##[1:5] b;
endsequence

sequence cde;
  c ##2 d ##2 e;
endsequence

sequence abcde;
  ab or cde;
endsequence

property ors;
  @(posedge clk) |-> abcde;
endproperty


property abcde;
  @(posedge clk) |-> (a==b) or (c==d);
endproperty


property BurstLengthRestrict;
  @(posedge clk) disable iff (lrst)
  ((blength==2) |->
  (rwlen==1) or (rwlen==3) or (rwlen==7) or (rwlen==15) );
endproperty
ap: assert property(BurstLengthRestrict);
","Caption: Examples of Verilog code showing sequence declarations, property definitions, and timing diagrams illustrating the application of the or operator in SystemVerilog assertions.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p443.jpg,True,"The image contains a snippet of Verilog code, which is part of a SystemVerilog testbench. Below is the text version of the code in the image:

```verilog
this.PortID = PortID;
endfunction : new

// run(): Run the monitor
task Monitor::run();
  NNI_cell c;

  forever begin
    receive(c);
    foreach (cbsq[i])
      cbsq[i].post_rx(this, c); // Post-receive callback
  end
endtask : run

// receive(): Read cell from the DUT, pack into a NNI cell
task Monitor::receive(output NNI_cell cell);
  ATMCellType Pkt;

  Tx.cbt.clav <= 1;
  while (Tx.cbt.soc != 1'b1 && Tx.cbt.en != 1'b0)
    @(Tx.cbt);
  for (int i=0; i<=52; i++) begin
    // If not enabled, loop
    while (Tx.cbt.en != 1'b0) @(Tx.cbt);

    Pkt.Mem[i] = Tx.cbt.data;
    @(Tx.cbt);
  end

  Tx.cbt.clav <= 0;

  c = new();
  c.unpack(Pkt);
  c.display($sformatf(""@%0t: Mon%0d: "", $time, PortID));
endtask : receive
```

This code appears to include methods for a monitor in a verification environment. The `new` function sets the `PortID`, the `run` task continuously calls `receive` and then triggers post-receive callbacks. The `receive` task reads data from the Device Under Test (DUT), packages it into a cell, and then processes it.","
this.PortID = PortID;
endfunction : new

// run(): Run the monitor
task Monitor::run();
  NNI_cell c;

  forever begin
    receive(c);
    foreach (cbsq[i])
      cbsq[i].post_rx(this, c); // Post-receive callback
  end
endtask : run

// receive(): Read cell from the DUT, pack into a NNI cell
task Monitor::receive(output NNI_cell cell);
  ATMCellType Pkt;

  Tx.cbt.clav <= 1;
  while (Tx.cbt.soc != 1'b1 && Tx.cbt.en != 1'b0)
    @(Tx.cbt);
  for (int i=0; i<=52; i++) begin
    // If not enabled, loop
    while (Tx.cbt.en != 1'b0) @(Tx.cbt);

    Pkt.Mem[i] = Tx.cbt.data;
    @(Tx.cbt);
  end

  Tx.cbt.clav <= 0;

  c = new();
  c.unpack(Pkt);
  c.display($sformatf(""@%0t: Mon%0d: "", $time, PortID));
endtask : receive
","""Excerpt from a textbook showcasing Monitor tasks in a SystemVerilog testbench""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p458.jpg,True,"The image contains two snippets of code that are examples of system task calls in Verilog:

1. ```verilog
$show_all_nets(<module_instance_name>);
```

2. ```verilog
$show_all_signals(<module_instance_name>);
```","
$show_all_nets(<module_instance_name>);


$show_all_signals(<module_instance_name>);
","Caption: ""Excerpt from The Verilog PLI Handbook, discussing the usage of $show_all_nets and $show_all_signals PLI applications in Verilog for accessing and displaying signal information in simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p161.jpg,True,"The image contains a snippet of code involving SystemVerilog properties for assertions using the SystemVerilog Assertion (SVA) language. Here is the code from the image:

```systemverilog
property ReqAckCheck;
  @(posedge clk) $rose(req) |=> ack[-1] ##1 !ack;
endproperty

ap: assert property (reqAckCheck);
```

The code describes a property `ReqAckCheck` for checking a protocol where after a rising edge of a request signal (`req`), there should be at least one cycle where an acknowledge signal (`ack`) is asserted (indicated by `ack[-1]`) followed by a cycle where the acknowledge is not asserted (indicated by `!ack`). The assertion `ap` uses this property to verify that the protocol is followed during simulation.","erilog
property ReqAckCheck;
  @(posedge clk) $rose(req) |=> ack[-1] ##1 !ack;
endproperty

ap: assert property (reqAckCheck);
","""Verilog SystemVerilog Assertion Example with 'throughout' Operator""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p457.jpg,True,"The image contains a code snippet written in C for interfacing with SystemVerilog (not in Verilog itself). The code defines a counter using a static variable. Here is the code from the image:

```c
#include <svdpi.h>

void counter7(svBitVecVal *o,
              const svBitVecVal *i,
              const svBit reset,
              const svBit load) {
    static unsigned char count = 0; // Static count storage

    if (reset) count = 0;           // Reset
    else if (load) count = *i;      // Load value
    else count++;                   // Count
    count &= 0x7f;                  // Mask off upper bit

    *o = count;
}
```

This code is a C routine meant to be called from SystemVerilog using the DPI (Direct Programming Interface). The routine models a 7-bit counter that can be reset, loaded with a value, or incremented. The count is stored in a static `unsigned char` variable and the upper bit is masked off to ensure the counter does not exceed 7 bits. The result is passed back to SystemVerilog using the output pointer `o`.","ude <svdpi.h>

void counter7(svBitVecVal *o,
              const svBitVecVal *i,
              const svBit reset,
              const svBit load) {
    static unsigned char count = 0; // Static count storage

    if (reset) count = 0;           // Reset
    else if (load) count = *i;      // Load value
    else count++;                   // Count
    count &= 0x7f;                  // Mask off upper bit

    *o = count;
}
","Caption: ""C code example of a 7-bit counter with static variable storage for interfacing with SystemVerilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p331.jpg,True,"The image contains a snippet of Verilog SystemVerilog code that defines a class for an Ethernet MAC frame with certain constraints. Here is the code presented in the image:

```verilog
class eth_mac_frame;
  typedef enum {II, IEEE} kind_e;
  rand kind_e kind;
  rand bit [47:0] da, sa;
  rand bit [15:0] len, vlan;
  rand bit [ 7:0] data[];

  ...

  constraint eth_mac_frame_II {
    if (kind == II) {
      data.size() inside { [46:1500] };
      len == data.size();
    }
  }

  constraint eth_mac_frame_ieee {
    if (kind == IEEE) {
      data.size() inside { [46:1500] };
      len == 1522;
    }
  }
endclass
```

This class includes an enumerated type `kind_e`, random variables representing different fields of an Ethernet frame, and two constraints `eth_mac_frame_II` and `eth_mac_frame_ieee` for setting conditions on the `data.size()` and `len` based on the `kind` of the Ethernet frame.","
class eth_mac_frame;
  typedef enum {II, IEEE} kind_e;
  rand kind_e kind;
  rand bit [47:0] da, sa;
  rand bit [15:0] len, vlan;
  rand bit [ 7:0] data[];

  ...

  constraint eth_mac_frame_II {
    if (kind == II) {
      data.size() inside { [46:1500] };
      len == data.size();
    }
  }

  constraint eth_mac_frame_ieee {
    if (kind == IEEE) {
      data.size() inside { [46:1500] };
      len == 1522;
    }
  }
endclass
","""Example of a Verilog class for Ethernet MAC Frame construction with type and length constraints""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p309.jpg,True,"The image contains Verilog code. Here's the code written out for you:

```verilog
initial begin
  fork
    transmit(1);
    transmit(2);
  join_none

  fork: receive_fork
    receive(1);
    receive(2);
  join_none

  // What is the output with/without a wait fork here?

  #15ns disable receive_fork;
  $display(""%0t: Done"", $time);
end

task transmit(int index);
  #10ns;
  $display(""%0t: Transmit is done for index = %0d"",
           $time, index);
endtask

task receive(int index);
  #(index * 10ns);
  $display(""%0t: Receive is done for index = %0d"",
           $time, index);
endtask
```

The comment in the code asks ""What is the output with/without a wait fork here?"" indicating that the reader should consider the difference in output when a `wait fork` is used at the indicated location. The `#15ns disable receive_fork;` line disables the `receive_fork` block after 15 nanoseconds.","
initial begin
  fork
    transmit(1);
    transmit(2);
  join_none

  fork: receive_fork
    receive(1);
    receive(2);
  join_none

  // What is the output with/without a wait fork here?

  #15ns disable receive_fork;
  $display(""%0t: Done"", $time);
end

task transmit(int index);
  #10ns;
  $display(""%0t: Transmit is done for index = %0d"",
           $time, index);
endtask

task receive(int index);
  #(index * 10ns);
  $display(""%0t: Receive is done for index = %0d"",
           $time, index);
endtask
",Example of Verilog code illustrating parallel task execution and disabling a forked process.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p305.jpg,True,"The image includes a portion of a textbook or document discussing clocks in Verilog with a focus on sequence methods. The following Verilog code is shown in the image:

```verilog
module m6 (logic a, b, event ev1, ev2);
  a15: assert property((@(ev1) a) |-> (@(ev2) b));
  a18: assert property((@(ev1) a) |-> b);
endmodule

module m7;
  logic A,B;
  event EV;
  ...
  m6 m6_inst(.a(A), .b(B), .ev1(EV), .ev2(EV));
endmodule
```

The text below the code explains how the instance of module `m6` within module `m7` connects the same event trigger `EV` to both of the ports `ev1` and `ev2`. Therefore, `ev1` and `ev2` are equivalent in this instance, and as such the assertions `a15` and `a18` behave identically.","
module m6 (logic a, b, event ev1, ev2);
  a15: assert property((@(ev1) a) |-> (@(ev2) b));
  a18: assert property((@(ev1) a) |-> b);
endmodule

module m7;
  logic A,B;
  event EV;
  ...
  m6 m6_inst(.a(A), .b(B), .ev1(EV), .ev2(EV));
endmodule
","""Verilog code and text discussing the use of 'assert property' to connect events and the explanation of sequence methods in SystemVerilog.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p312.jpg,True,"The image does contain a snippet of code related to the Verilog Programming Language Interface (PLI). Below is the code extracted from the image:

```c
/* prototypes for the PLI application routines */
extern int PLIbook_ShowVal_checktf(), PLIbook_ShowVal_calltf();
extern int PLIbook_pow_checktf(), PLIbook_pow_sizetf(), PLIbook_pow_calltf(), PLIbook_pow_misctf();

/* the veriusertfs array */
s_tfcell veriusertfs[] = 
{
    { usertask,
      0,                         /* user_data value */
      PLIbook_ShowVal_checktf,   /* checktf routine */
      0,                         /* sizetf routine */
      PLIbook_ShowVal_calltf,    /* calltf routine */
      0,                         /* misctf routine */
      ""$show_value"",             /* system task/function name */
      1                          /* forward reference = true */
    },
    /* ... other user tasks/functions would be listed here ... */
}
```

Please note that the actual code may contain more items in the `veriusertfs[]` array, but the image only includes one entry as an example.","ototypes for the PLI application routines */
extern int PLIbook_ShowVal_checktf(), PLIbook_ShowVal_calltf();
extern int PLIbook_pow_checktf(), PLIbook_pow_sizetf(), PLIbook_pow_calltf(), PLIbook_pow_misctf();

/* the veriusertfs array */
s_tfcell veriusertfs[] = 
{
    { usertask,
      0,                         /* user_data value */
      PLIbook_ShowVal_checktf,   /* checktf routine */
      0,                         /* sizetf routine */
      PLIbook_ShowVal_calltf,    /* calltf routine */
      0,                         /* misctf routine */
      ""$show_value"",             /* system task/function name */
      1                          /* forward reference = true */
    },
    /* ... other user tasks/functions would be listed here ... */
}
","A page from ""The Verilog PLI Handbook"" showing a table of Verilog 'veriusertfs' fields with definitions and an example Verilog code snippet for a veriusertfs array.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p474.jpg,True,"Here is the Verilog code from the image:

```verilog
handle mod_h, net_h;

static int wired_nets[5] = {accWand, accWor, accTriand, accTrior, 0};

/* add code to get a module handle */

net_h = null; /* initialize the target handle to null */
while (net_h = acc_next(wired_nets, mod_h, port_h) ) {
    /* perform desired operations on the net handle */
}
```

This code snippet related to the Verilog Programming Language Interface (PLI) shows an example of how to use the `acc_next()` function to iterate over wires of specific types in a Verilog module.","
handle mod_h, net_h;

static int wired_nets[5] = {accWand, accWor, accTriand, accTrior, 0};

/* add code to get a module handle */

net_h = null; /* initialize the target handle to null */
while (net_h = acc_next(wired_nets, mod_h, port_h) ) {
    /* perform desired operations on the net handle */
}
","Excerpt from ""The Verilog PLI Handbook,"" showing the usage of the `acc_next()` function in Verilog for obtaining object handles with an example code snippet.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p159.jpg,True,"The image contains a snippet of Verilog code. Here is the code:

```verilog
property ab;
    @(posedge clk) a |=> b [-> 2] ##1 c;
endproperty
```","
property ab;
    @(posedge clk) a |=> b [-> 2] ##1 c;
endproperty
",An example of Verilog assertions illustrating the difference between non-consecutive and consecutive clock event repetition in system verilog property specifications.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p306.jpg,True,"The image includes a snippet of code as part of the text. It’s a casting example in the C programming language, related to the Verilog Programming Language Interface (PLI). Here's the code that's visible:

```c
(int (*)())pliBook_PowCalltf
```

This C code is casting a function named `pliBook_PowCalltf` to a pointer to a function that returns an `int` and takes no parameters. The text mentions that some C compilers might not accept this cast.","(*)())pliBook_PowCalltf
","""Defining Verilog PLI System Function $pow with checktf, calltf, sizetf, and misctf routines""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p339.jpg,True,"The image contains Verilog code. Here is the code extracted from the image:

```verilog
program prg();
  integer i;
  initial
    for (i=0; i<8 ; i++) begin
      mod.v11= 1;
      #5;
      mod.v11 = 0;
    end
endprogram

module mod(input bit sig2,clk);
  bit v11,r11,r12;
  wire v12;
  assign v12 = sig2;
  always @(posedge v11 or posedge v12) begin: B1
    r11 = v11 | r12;
    a24: assert property (@(posedge clk) v11 |=> v12);
    r12 = v11 & v12;
    if (v11 && !$sampled(v11) && v12 && !$sampled(v2))
      disable a24;
  end
endmodule
```

The code shows an example of a program and a module in Verilog, including a for loop, continuous assignment, procedural assignments, always block, assertions, and a disable statement to conditionally disable an assertion `a24`.","
program prg();
  integer i;
  initial
    for (i=0; i<8 ; i++) begin
      mod.v11= 1;
      #5;
      mod.v11 = 0;
    end
endprogram

module mod(input bit sig2,clk);
  bit v11,r11,r12;
  wire v12;
  assign v12 = sig2;
  always @(posedge v11 or posedge v12) begin: B1
    r11 = v11 | r12;
    a24: assert property (@(posedge clk) v11 |=> v12);
    r12 = v11 & v12;
    if (v11 && !$sampled(v11) && v12 && !$sampled(v2))
      disable a24;
  end
endmodule
","Caption: ""Example of a Verilog code that illustrates the use of a `disable` statement to prevent redundant assertion evaluations.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p335.jpg,True,"The image contains Verilog code. Here is the code written out for you:

```verilog
class Transaction extends BaseTr;
    rand bit [31:0] src, dst, csm, data[8];

    extern function new();
    extern virtual function bit compare(input BaseTr to);
    extern virtual function BaseTr copy(input BaseTr to=null);
    extern virtual function void display(input string prefix="""");
endclass

function Transaction::new();
    super.new();
endfunction : new

function bit Transaction::compare(input BaseTr to);
    Transaction tr;
    if(!$cast(tr, to))  // Check if 'to' is correct type
        $finish;
    return ((this.src == tr.src) &&
            (this.dst == tr.dst) &&
            (this.csm == tr.csm) &&
            (this.data == tr.data));
endfunction : compare

function BaseTr Transaction::copy(input BaseTr to=null);
    Transaction cp;
    if (to == null) cp = new();
    else            $cast(cp, to);
    cp.src = this.src;             // Copy the data fields
    cp.dst = this.dst;
    cp.data = this.data;
    cp.csm = this.csm;
    return cp;
endfunction : copy

function void Transaction::display(input string prefix="""");
    $display(""%sTransaction %0d src=%h, dst=%x, csm=%x"",
             prefix, id, src, dst, csm);
endfunction : display
```

Please note that the code is written in SystemVerilog, which is an extension of the Verilog hardware description language designed to accommodate the needs of high-level system design and verification constructs.","
class Transaction extends BaseTr;
    rand bit [31:0] src, dst, csm, data[8];

    extern function new();
    extern virtual function bit compare(input BaseTr to);
    extern virtual function BaseTr copy(input BaseTr to=null);
    extern virtual function void display(input string prefix="""");
endclass

function Transaction::new();
    super.new();
endfunction : new

function bit Transaction::compare(input BaseTr to);
    Transaction tr;
    if(!$cast(tr, to))  // Check if 'to' is correct type
        $finish;
    return ((this.src == tr.src) &&
            (this.dst == tr.dst) &&
            (this.csm == tr.csm) &&
            (this.data == tr.data));
endfunction : compare

function BaseTr Transaction::copy(input BaseTr to=null);
    Transaction cp;
    if (to == null) cp = new();
    else            $cast(cp, to);
    cp.src = this.src;             // Copy the data fields
    cp.dst = this.dst;
    cp.data = this.data;
    cp.csm = this.csm;
    return cp;
endfunction : copy

function void Transaction::display(input string prefix="""");
    $display(""%sTransaction %0d src=%h, dst=%x, csm=%x"",
             prefix, id, src, dst, csm);
endfunction : display
","Caption: ""Example of a Transaction class in Verilog, illustrating object-oriented programming extensions for testbench development.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p453.jpg,True,"The image contains examples of both SystemVerilog and C code. Here they are:

SystemVerilog code calling C factorial routine:
```verilog
import ""DPI-C"" function int factorial(input int i);

program automatic test;
  initial begin
    for (int i=1; i<=10; i++)
      $display(""%0d! = %0d"", i, factorial(i));
  end
endprogram
```

C factorial function:
```c
int factorial(int i) {
  if (i<=1) return 1;
  else return i*factorial(i-1);
}
```","
import ""DPI-C"" function int factorial(input int i);

program automatic test;
  initial begin
    for (int i=1; i<=10; i++)
      $display(""%0d! = %0d"", i, factorial(i));
  end
endprogram

actorial(int i) {
  if (i<=1) return 1;
  else return i*factorial(i-1);
}
","Caption: ""Interfacing SystemVerilog with C: Passing Integer Values and Using the Import Declaration""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p165.jpg,True,"The image contains text related to the Verilog SystemVerilog language, discussing the application of the 'within' operator for sequences. Here is the text extract that seems to resemble code:

```
$fell(bMode) |=>stack within smtrx;
```

This line appears to be a SystemVerilog assertion property defining that when `bMode` falls (`$fell(bMode)`), the sequence `stack` must occur within the sequence `smtrx`. The `|=>` is a non-overlapping implication operator, which means that the consequent (`stack within smtrx`) is evaluated starting on the next clock cycle after the antecedent (`$fell(bMode)`) becomes true.","bMode) |=>stack within smtrx;
","""Explaining the 'seq1 within seq2' construct in Verilog for sequence matching within specified intervals of clock ticks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p448.jpg,True,"The image contains a snippet of C code that appears to be used in interfacing with Verilog models. Here is the code presented:

```c
#include <stdio.h>  /* ANSI C standard I/O library */
#include ""veriuser.h""  /* IEEE 1364 PLI TF routine library */
/**********************************************************************
* calltf routine: turns on asynchronous callbacks to the misctf
* routine whenever an argument to the system task changes value
**********************************************************************/
int PLIbook_ScientificALU_calltf()
{
    tf_asynchon();
    tf_setworkarea(NULL); /* set work area to null */
    return(0);
}

/**********************************************************************
* misctf routine: Serves as an interface between Verilog simulation
* and the C model. The misctf routine performs different operations
* depending on the reason it is called:
* - For a value change callback: schedules a callback to the misctf
*   application synchronization to the end of a time step. Only schedules
*   one callback for a time step.
* - For a synchronize callback: reads the input values, and passes
*   the values to the C model, and writes the C model outputs into
*   simulation.
**********************************************************************/
```
This code is designed to interface C models with Verilog simulations using the Task-Function (TF) routines defined by the IEEE 1364 PLI standard. The `calltf` function sets up asynchronous callbacks for a Verilog system task, while the `misctf` routine (not shown in the snippet) implements the actual interfacing logic.","ude <stdio.h>  /* ANSI C standard I/O library */
#include ""veriuser.h""  /* IEEE 1364 PLI TF routine library */
/**********************************************************************
* calltf routine: turns on asynchronous callbacks to the misctf
* routine whenever an argument to the system task changes value
**********************************************************************/
int PLIbook_ScientificALU_calltf()
{
    tf_asynchon();
    tf_setworkarea(NULL); /* set work area to null */
    return(0);
}

/**********************************************************************
* misctf routine: Serves as an interface between Verilog simulation
* and the C model. The misctf routine performs different operations
* depending on the reason it is called:
* - For a value change callback: schedules a callback to the misctf
*   application synchronization to the end of a time step. Only schedules
*   one callback for a time step.
* - For a synchronize callback: reads the input values, and passes
*   the values to the C model, and writes the C model outputs into
*   simulation.
**********************************************************************/
","""Excerpt from a textbook on Verilog, highlighting interfacing C models with Verilog using TF routines, along with an example of C model interface code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p447.jpg,True,"The image contains Verilog code, which is a hardware description language used to model electronic systems. Here's the code from the image:

```verilog
class CPU_driver;
    vCPU_T mif;
    CellCfgType lookup [255:0]; // copy of look-up table
    Config cfg;
    bit [NumTx-1:0] fwd;

    extern function new(vCPU_T mif, Config cfg);
    extern task Initialize_Host ();
    extern task HostWrite (int a, CellCfgType d); // configure
    extern task HostRead (int a, output CellCfgType d);
    extern task run();
endclass : CPU_driver

function CPU_driver::new(input vCPU_T mif, Config cfg);
    this.mif = mif;
    this.cfg = cfg;
endfunction : new

task CPU_driver::Initialize_Host();
    mif.BusMode <= 1;
    mif.Addr <= 0;
    mif.DataIn <= 0;
    mif.Sel <= 1;
    mif.Rd_DS <= 1;
    mif.Wr_RW <= 1;
endtask : Initialize_Host

task CPU_driver::HostWrite (int a, CellCfgType d); // configure
    #10 mif.Addr <= a; mif.DataIn <= d; mif.Sel <= 0;
    #10 mif.Wr_RW <= 0;
    while (mif.Rdy_Dtack!==0) #10;
    #10 mif.Wr_RW <= 1; mif.Sel <= 1;
    while (mif.Rdy_Dtack!==0) #10;
endtask : HostWrite

task CPU_driver::HostRead (input int a, output CellCfgType d);
    #10 mif.Addr <= a; mif.Sel <= 0;
    #10 mif.Rd_DS <= 0;
    while (mif.Rdy_Dtack!==0) #10;
    d = mif.DataOut; mif.Rd_DS <= 1; mif.Sel <= 1;
endtask : HostRead
```

This code snippet is a partial representation of a `CPU_driver` class in SystemVerilog which includes methods to initialize the host, write to a host, and read from a host, as well as a constructor for the class. Please note that the methods `run()` provided in the class interface, and other parts of the class's definition, may continue beyond the image and are not shown here. Additionally, some dependencies and definitions (like `vCPU_T` or `CellCfgType`) are not included in the snippet, as they would be defined elsewhere in the full source code.","
class CPU_driver;
    vCPU_T mif;
    CellCfgType lookup [255:0]; // copy of look-up table
    Config cfg;
    bit [NumTx-1:0] fwd;

    extern function new(vCPU_T mif, Config cfg);
    extern task Initialize_Host ();
    extern task HostWrite (int a, CellCfgType d); // configure
    extern task HostRead (int a, output CellCfgType d);
    extern task run();
endclass : CPU_driver

function CPU_driver::new(input vCPU_T mif, Config cfg);
    this.mif = mif;
    this.cfg = cfg;
endfunction : new

task CPU_driver::Initialize_Host();
    mif.BusMode <= 1;
    mif.Addr <= 0;
    mif.DataIn <= 0;
    mif.Sel <= 1;
    mif.Rd_DS <= 1;
    mif.Wr_RW <= 1;
endtask : Initialize_Host

task CPU_driver::HostWrite (int a, CellCfgType d); // configure
    #10 mif.Addr <= a; mif.DataIn <= d; mif.Sel <= 0;
    #10 mif.Wr_RW <= 0;
    while (mif.Rdy_Dtack!==0) #10;
    #10 mif.Wr_RW <= 1; mif.Sel <= 1;
    while (mif.Rdy_Dtack!==0) #10;
endtask : HostWrite

task CPU_driver::HostRead (input int a, output CellCfgType d);
    #10 mif.Addr <= a; mif.Sel <= 0;
    #10 mif.Rd_DS <= 0;
    while (mif.Rdy_Dtack!==0) #10;
    d = mif.DataOut; mif.Rd_DS <= 1; mif.Sel <= 1;
endtask : HostRead
","""Excerpt from a textbook showing the definition of a Verilog 'CPU_driver' class with tasks for initializing, reading, and writing to a CPU interface.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p171.jpg,True,"The image contains Verilog code in the context of sequence and property definition. Here's the code that is readable from the image:

```verilog
sequence ab;
   a ##[1:5] b;
endsequence

sequence cde;
   c ##2 d ##2 e;
endsequence

sequence ab_cde;
   ab and cde;
endsequence

property ands;
   @(posedge clk) z |-> ab_cde;
endproperty
```

There's code at the bottom part of the image as well:
```verilog
property ands;
   @(posedge clk) z |-> (a==b) and (c==d);
endproperty
```

In the accompanying text, there's also a comment block resembling test output or simulation log, but it's not executable code:
```
# run -all
#
# 5 CLK # 1 :: clk=1 z=0 a=0 b=0 c=0 d=0
# CLK # 2 :: clk=1 z=0 a=0 b=0 c=0 d=0
# CLK # 3 :: clk=1 z=1 a=1 b=1 c=0 d=0
# 25 property ands PASS
# 
# 35 CLK # 4 :: clk=1 z=0 a=0 b=0 c=1 d=1
# CLK # 5 :: clk=1 z=1 a=1 b=1 c=1 d=1
# 45 property ands PASS
#
# 55 CLK # 6 :: clk=1 z=0 a=0 b=1 c=0 d=1
# 65 CLK # 7 :: clk=1 z=1 a=1 b=0 c=1 d=1
# 65 property ands FAIL
#
# 75 CLK # 8 :: clk=1 z=1 a=1 b=1 c=0 d=1
# 75 property ands FAIL
```

The image shows how these sequences and properties can be used in verification environments to check the correctness of specific conditions in hardware designs using temporal logic. There are also timing diagrams illustrating the sequences and how the `ands` property is evaluated in those scenarios.","
sequence ab;
   a ##[1:5] b;
endsequence

sequence cde;
   c ##2 d ##2 e;
endsequence

sequence ab_cde;
   ab and cde;
endsequence

property ands;
   @(posedge clk) z |-> ab_cde;
endproperty


property ands;
   @(posedge clk) z |-> (a==b) and (c==d);
endproperty

-all
#
# 5 CLK # 1 :: clk=1 z=0 a=0 b=0 c=0 d=0
# CLK # 2 :: clk=1 z=0 a=0 b=0 c=0 d=0
# CLK # 3 :: clk=1 z=1 a=1 b=1 c=0 d=0
# 25 property ands PASS
# 
# 35 CLK # 4 :: clk=1 z=0 a=0 b=0 c=1 d=1
# CLK # 5 :: clk=1 z=1 a=1 b=1 c=1 d=1
# 45 property ands PASS
#
# 55 CLK # 6 :: clk=1 z=0 a=0 b=1 c=0 d=1
# 65 CLK # 7 :: clk=1 z=1 a=1 b=0 c=1 d=1
# 65 property ands FAIL
#
# 75 CLK # 8 :: clk=1 z=1 a=1 b=1 c=0 d=1
# 75 property ands FAIL
","""Exploration of Verilog sequences and properties using 'and' operator with timing diagrams and simulation results.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p321.jpg,True,"The image contains Verilog code, specifically for creating a testbench environment and a simple test program. Here is the code as presented in the image:

```verilog
// Testbench environment class
class Environment;
    Generator gen;
    Driver drv;
    mailbox #(Transaction) gen2drv;

    virtual function void build();     // Build the environment by
        gen2drv = new();               // constructing the mailbox,
        gen = new(gen2drv);            // the generator,
        drv = new(gen2drv);            // and driver
    endfunction

    virtual task run();
        fork
            gen.run();
            drv.run();
        join
    endtask

    virtual task wrap_up();
        // Empty for now - call scoreboard for report
    endtask
endclass
```

```verilog
// A Simple Testbench
program automatic test;

    Environment env;
    initial begin
        env = new();            // Construct the environment
        env.build();            // Build testbench objects
        env.run();              // Run the test
        env.wrap_up();          // Clean up afterwards
    end
endprogram
```

The code outlines the structure of an `Environment` class used in a testbench scenario, along with declarations of a generator, driver, and a mailbox that carries `Transaction` objects. Additionally, it contains methods `build`, `run`, and `wrap_up`, which perform different tasks associated with the testbench operation. Following the class definition is a simple test program that makes use of the `Environment` class.","
// Testbench environment class
class Environment;
    Generator gen;
    Driver drv;
    mailbox #(Transaction) gen2drv;

    virtual function void build();     // Build the environment by
        gen2drv = new();               // constructing the mailbox,
        gen = new(gen2drv);            // the generator,
        drv = new(gen2drv);            // and driver
    endfunction

    virtual task run();
        fork
            gen.run();
            drv.run();
        join
    endtask

    virtual task wrap_up();
        // Empty for now - call scoreboard for report
    endtask
endclass


// A Simple Testbench
program automatic test;

    Environment env;
    initial begin
        env = new();            // Construct the environment
        env.build();            // Build testbench objects
        env.run();              // Run the test
        env.wrap_up();          // Clean up afterwards
    end
endprogram
",Verilog code for a testbench environment class and a simple test program setup.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p239.jpg,True,"The image contains Verilog code. Here is the code that is written on the page:

```verilog
initial
begin
    Y <= 1'b0;
    # 0 X <= 1'b1;
    # 0 Y <= 1'b1;
    # 0 Z <= 1'b1;
    Z <= 1'b0;
    $display(""display: %0d: Y=%1b Z=%1b"", $time, Y, Z);
    $strobe (""strobe: %0d: Y=%1b Z=%1b"", $time, Y, Z);
    $finish;
end
```

And then, another part of the code:

```verilog
module EventCtlPart(output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = xReg;
    assign yPart = yReg;
    always @(a, b)
    begin: PartList
        xReg <= a & b & c;
        yReg <= (b | c) ^a;
    end
endmodule // EventCtlPart.
```

These code snippets are part of a Verilog digital design example discussed in the context of the text on the page.","
initial
begin
    Y <= 1'b0;
    # 0 X <= 1'b1;
    # 0 Y <= 1'b1;
    # 0 Z <= 1'b1;
    Z <= 1'b0;
    $display(""display: %0d: Y=%1b Z=%1b"", $time, Y, Z);
    $strobe (""strobe: %0d: Y=%1b Z=%1b"", $time, Y, Z);
    $finish;
end


module EventCtlPart(output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = xReg;
    assign yPart = yReg;
    always @(a, b)
    begin: PartList
        xReg <= a & b & c;
        yReg <= (b | c) ^a;
    end
endmodule // EventCtlPart.
","Caption: ""Exploration of intraassignment and regular delay in Verilog and examining the functionality of nonblocking assignments in simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p33.jpg,True,"The image contains Verilog code. Here it is:

```verilog
module top_level
(output logic [7:0] out, // 8-bit port
input logic [7:0] a, b, c, d // 8-bit ports
);
mux4 m1 (.y(out), .*); // ERROR: no net declared for sel port
endmodule

module mux4
(input logic [1:0] sel, // 2-bit input port
input logic [7:0] a, b, c, d, // 8-bit input ports
output logic [7:0] y // 8-bit output port
);
```

The code snippet demonstrates a Verilog coding issue related to implicit port connections using the dot-star notation and the importance of declaring all internal signals explicitly to avoid size mismatches in port connections.","
module top_level
(output logic [7:0] out, // 8-bit port
input logic [7:0] a, b, c, d // 8-bit ports
);
mux4 m1 (.y(out), .*); // ERROR: no net declared for sel port
endmodule

module mux4
(input logic [1:0] sel, // 2-bit input port
input logic [7:0] a, b, c, d, // 8-bit input ports
output logic [7:0] y // 8-bit output port
);
","""Common pitfall in Verilog coding: Mismatch in port sizes leading to unintentional errors in netlists.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p137.jpg,True,"The image contains two snippets of Verilog code. I will provide the two excerpts as they appear in the image:

Code snippet from Example 4-9:

```verilog
always @(a or b or c) begin : my_block
    $assert_delete ();
    :
    if (c)
    $assert_always_ck (ck, `a^b);
end
```

Code snippet from Example 4-10:

```verilog
reg test_assertion;
always @(a or b or c) begin
    test_assertion = 1'b1;
    if (c) test_assertion = a^b;
end
assert_always ovl_assert (ck, reset_n, test_assertion);
```

These code snippets define procedural blocks and assertions in Verilog related to hardware description and verification.","
always @(a or b or c) begin : my_block
    $assert_delete ();
    :
    if (c)
    $assert_always_ck (ck, `a^b);
end


reg test_assertion;
always @(a or b or c) begin
    test_assertion = 1'b1;
    if (c) test_assertion = a^b;
end
assert_always ovl_assert (ck, reset_n, test_assertion);
","""Examples of procedural assertions in Verilog using Value Change Link (VCL) for clock monitoring and signal testing within assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p484.jpg,True,"The image contains Verilog code, which is as follows:

```verilog
module memory;
import ""DPI-C"" context task read_file(string fname);
import ""DPI-C"" task mem_read;
export ""DPI-C"" task mem_write;
export ""DPI-C"" function mem_build;

initial read_file(""mem.dat""); // Call C code to read file

class Memory;
  int mem[];
  
  function new(input int size);
    mem = new[size];
  endfunction
  
  task mem_read(input int addr, output int data);
    #20 data = mem[addr];
  endtask
  
  task mem_write(input int addr, input int data);
    #10 mem[addr] = data;
  endtask
endclass : Memory

Memory memq[$]; // Queue of Memory objects

// Construct a new memory instance & push on the queue
function void mem_build(input int size);
  Memory m;
  m = new(size);
  memq.push_back(m);
endfunction

// idx is the index of the memory handle in memq
task mem_read(input int idx, input int addr, output int data);
  memq[idx].mem_read(addr, data);
endtask

task mem_write(input int idx, input int addr, input int data);
  memq[idx].mem_write(addr, data);
endtask

endmodule : memory
``` 

This code snippet appears to be from a textbook or a guide, discussing the integration between C and SystemVerilog for memory models. The code includes the SystemVerilog module for memory with a class definition and methods to read and write memory, import and export directives for DPI-C, and queue management for memory instances.","
module memory;
import ""DPI-C"" context task read_file(string fname);
import ""DPI-C"" task mem_read;
export ""DPI-C"" task mem_write;
export ""DPI-C"" function mem_build;

initial read_file(""mem.dat""); // Call C code to read file

class Memory;
  int mem[];
  
  function new(input int size);
    mem = new[size];
  endfunction
  
  task mem_read(input int addr, output int data);
    #20 data = mem[addr];
  endtask
  
  task mem_write(input int addr, input int data);
    #10 mem[addr] = data;
  endtask
endclass : Memory

Memory memq[$]; // Queue of Memory objects

// Construct a new memory instance & push on the queue
function void mem_build(input int size);
  Memory m;
  m = new(size);
  memq.push_back(m);
endfunction

// idx is the index of the memory handle in memq
task mem_read(input int idx, input int addr, output int data);
  memq[idx].mem_read(addr, data);
endtask

task mem_write(input int idx, input int addr, input int data);
  memq[idx].mem_write(addr, data);
endtask

endmodule : memory
",Verilog code sample illustrating communication between C and SystemVerilog for memory operations.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p27.jpg,True,"```verilog
module FSM (...);

enum logic [1:0] {WAIT, LOAD, READY} State, nState;
...
always_comb begin
    case (state) // GOTCHA!
        WAIT: nState = LOAD; // GOTCHA!
        LOAD: nState = READY; // GOTCHA!
        READY: nState = wait; // GOTCHA!
    endcase
end
endmodule: FSM
```

The image contains a snippet of Verilog code which illustrates case sensitivity issues in Verilog/SystemVerilog coding. It highlights various ""gotchas"" where the cases of the enumerated labels and variables' names may lead to confusion or errors due to Verilog/SystemVerilog being case sensitive.","
module FSM (...);

enum logic [1:0] {WAIT, LOAD, READY} State, nState;
...
always_comb begin
    case (state) // GOTCHA!
        WAIT: nState = LOAD; // GOTCHA!
        LOAD: nState = READY; // GOTCHA!
        READY: nState = wait; // GOTCHA!
    endcase
end
endmodule: FSM
","Caption: ""An excerpt from a Verilog/SystemVerilog reference highlighting case sensitivity gotchas in Verilog code, illustrating the importance of consistent capitalization and identifier naming to avoid compilation errors and functional issues in hardware description code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p676.jpg,True,"The image contains some Verilog-related code within a conditional compilation block. Here is the code from the image:

```verilog
#ifdef vcs
#include vcsuser.h /* VCS proprietary TF routine library */
#include acc_user.h /* VCS proprietary ACC routine lib. */
#else
#include veriuser.h /* IEEE 1364 TF routine library */
#include acc_user.h /* IEEE 1364 ACC routine library */
#endif
```

This is using preprocessor directives to include different header files depending on whether the `vcs` macro is defined. If `vcs` is defined, it includes VCS-specific proprietary libraries; if not, it includes IEEE standard 1364 libraries.","
#ifdef vcs
#include vcsuser.h /* VCS proprietary TF routine library */
#include acc_user.h /* VCS proprietary ACC routine lib. */
#else
#include veriuser.h /* IEEE 1364 TF routine library */
#include acc_user.h /* IEEE 1364 ACC routine library */
#endif
","Caption: ""Configuring the Verilog Programming Language Interface (PLI) with proprietary VCS libraries for optimized simulation performance.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p228.jpg,True,"The image contains Verilog code. Here it is:

```verilog
property p_tRC_not;
  @(posedge clk)
    `s_active |-> 
    not ##[1: (tRC - 1)] `s_active;
endproperty

property p_tRC;
  @(posedge clk)
    `s_active |-> 
    ##[tRC:12000] `s_active;
endproperty

a_tRC_not: assert property (p_tRC_not);
a_tRC: assert property (p_tRC);
c_tRC_not: cover property (p_tRC_not);
c_tRC: cover property (p_tRC);
```

This code displays two properties (`p_tRC_not` and `p_tRC`) and their assertions and cover checks related to timing constraints for SDRAM control signals, specifically active to active command timing (tRC).","
property p_tRC_not;
  @(posedge clk)
    `s_active |-> 
    not ##[1: (tRC - 1)] `s_active;
endproperty

property p_tRC;
  @(posedge clk)
    `s_active |-> 
    ##[tRC:12000] `s_active;
endproperty

a_tRC_not: assert property (p_tRC_not);
a_tRC: assert property (p_tRC);
c_tRC_not: cover property (p_tRC_not);
c_tRC: cover property (p_tRC);
",Verilog code snippet demonstrating assertions and properties for SDRAM timing constraint verification (tRC) using SystemVerilog.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p110.jpg,True,"The image does contain code. Here is the Verilog code available in the image:

```c
#include <stdlib.h>  /* ANSI C standard library */
#include <stdio.h>   /* ANSI C standard input/output library */
#include ""vpi_user.h""/* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h""/* IEEE 1364 PLI TF routine library */
                        /* using TF routines for simulation control */

/* prototypes of the PLI application routines */
int PLIbook_ShowSignals_compiletf(), PLIbook_ShowSignals_calltf();
void PLIbook_PrintSignalValues(), PLIbook_GetAllSignals();

/**********************************************************************
* show_all_signals Registration Data
* (add this function name to the vlog_startup_routines array)
**********************************************************************/
void PLIbook_ShowSignals_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type        = vpiSysTask;
    tf_data.tfname      = ""$show_all_signals"";
    tf_data.calltf      = PLIbook_ShowSignals_calltf;
    tf_data.compiletf   = PLIbook_ShowSignals_compiletf;
    tf_data.sizetf      = NULL;
    vpi_register_systf(&tf_data);
    return;
}

/**********************************************************************
* compiletf routine
**********************************************************************/
int PLIbook_ShowSignals_compiletf(char *user_data)
{
    vpiHandle systf_handle, arg_iterator, arg_handle;
    int       tfarg_type, tfarg_num=0;

    /* obtain a handle to the system task instance */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handles to system task arguments */
    arg_iterator = vpi_iterate(vpiArgument, systf_handle);
    if (arg_iterator == NULL) {
        return(0); /* no arguments OK; skip remaining checks */
    }
```

Please note that this appears to be only a portion of the code and the function definitions and logic are incomplete in the image provided. The comments within the code provide some context on how the functions and registrations correspond to system tasks in the PLI library.","ude <stdlib.h>  /* ANSI C standard library */
#include <stdio.h>   /* ANSI C standard input/output library */
#include ""vpi_user.h""/* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h""/* IEEE 1364 PLI TF routine library */
                        /* using TF routines for simulation control */

/* prototypes of the PLI application routines */
int PLIbook_ShowSignals_compiletf(), PLIbook_ShowSignals_calltf();
void PLIbook_PrintSignalValues(), PLIbook_GetAllSignals();

/**********************************************************************
* show_all_signals Registration Data
* (add this function name to the vlog_startup_routines array)
**********************************************************************/
void PLIbook_ShowSignals_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type        = vpiSysTask;
    tf_data.tfname      = ""$show_all_signals"";
    tf_data.calltf      = PLIbook_ShowSignals_calltf;
    tf_data.compiletf   = PLIbook_ShowSignals_compiletf;
    tf_data.sizetf      = NULL;
    vpi_register_systf(&tf_data);
    return;
}

/**********************************************************************
* compiletf routine
**********************************************************************/
int PLIbook_ShowSignals_compiletf(char *user_data)
{
    vpiHandle systf_handle, arg_iterator, arg_handle;
    int       tfarg_type, tfarg_num=0;

    /* obtain a handle to the system task instance */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handles to system task arguments */
    arg_iterator = vpi_iterate(vpiArgument, systf_handle);
    if (arg_iterator == NULL) {
        return(0); /* no arguments OK; skip remaining checks */
    }
",An excerpt from 'The Verilog PLI Handbook' showing code for registering a system task with Verilog PLI using VPI routines.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p107.jpg,True,"The image contains excerpts of Verilog code within the text. The specific code examples given are coverage statements for simple RAM as follows:

```verilog
read_asserted: cover property(@(posedge clk) disable iff (rst) read);
write_asserted: cover property(@(posedge clk) disable iff (rst) write);
rw_deasserted: cover property(@(posedge clk) disable iff (rst) !(read || write));
```","
read_asserted: cover property(@(posedge clk) disable iff (rst) read);
write_asserted: cover property(@(posedge clk) disable iff (rst) write);
rw_deasserted: cover property(@(posedge clk) disable iff (rst) !(read || write));
","""Understanding Coverage in Verilog: Functional coverage examples with cover property statements for simple RAM scenarios.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p99.jpg,True,"The image contains examples of PSL (Property Specification Language) code. Here is the code presented in the examples:

Example 3-24:
```
{req[*1:4] : {grant}}
```

Example 3-25:
```
always ({A} |=> {B,C,D})
```

Example 3-26:
```
always ({A,B,C} |=> {D})
```","1:4] : {grant}}

 ({A} |=> {B,C,D})

 ({A,B,C} |=> {D})
","""Understanding Sequence Operators and Sequence Implications in PSL and Verilog for RTL Properties""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p429.jpg,True,"The image contains Verilog code. Here it is:

```verilog
// -----------------------------------
// 7. Write a property to Warn on read from an empty fifo
//    This property will give Warning with all simulations
// -----------------------------------

`ifdef check7
property read_on_empty_fifo;
  @(posedge clk) disable iff (!rst_)
    fifo_empty |-> !fifo_read;
endproperty

read_on_empty_fifoP: assert property (read_on_empty_fifo)
  else $display($stime,""\t WARNING:read_on_empty_fifo condition\n"");
`endif
```

This Verilog code defines a property for simulation purposes to warn when there is an attempt to read from an empty FIFO (First In, First Out) buffer. If the `check7` macro is defined, then the `read_on_empty_fifo` property is checked at every positive edge of the clock, as long as the reset (`rst_`) is not active. If the FIFO is empty and there is a read attempt (signaled by `fifo_read`), a warning message is displayed.","
// -----------------------------------
// 7. Write a property to Warn on read from an empty fifo
//    This property will give Warning with all simulations
// -----------------------------------

`ifdef check7
property read_on_empty_fifo;
  @(posedge clk) disable iff (!rst_)
    fifo_empty |-> !fifo_read;
endproperty

read_on_empty_fifoP: assert property (read_on_empty_fifo)
  else $display($stime,""\t WARNING:read_on_empty_fifo condition\n"");
`endif
","""Verilog code snippet displaying a property for warning when reading from an empty FIFO queue""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p104.jpg,True,"The image contains two snippets of Verilog code. Here they are:

First snippet:
```verilog
module top;
    ...
    always @(posedge clock)
    begin: local
        integer i;
        reg local_bus;
        ...
        $show_all_signals;
    end
endmodule
```

Second snippet:
```verilog
module top;
    ...
    addbit i1 (a, b, ci, sum, co); // instance of an adder
    ...
    always @(sum or co)
        $show_all_signals;         // list signals in this module
    always @(posedge clock)
    begin: local
        integer i;
        reg local_bus;
        ...
        $show_all_signals;         // list signals in this block
    end
endmodule
```

These code blocks are examples showing the usage of `$show_all_signals`, which appears to be a system task in the Verilog Programming Language Interface (PLI).","
module top;
    ...
    always @(posedge clock)
    begin: local
        integer i;
        reg local_bus;
        ...
        $show_all_signals;
    end
endmodule


module top;
    ...
    addbit i1 (a, b, ci, sum, co); // instance of an adder
    ...
    always @(sum or co)
        $show_all_signals;         // list signals in this module
    always @(posedge clock)
    begin: local
        integer i;
        reg local_bus;
        ...
        $show_all_signals;         // list signals in this block
    end
endmodule
","Excerpt from ""The Verilog PLI Handbook"" demonstrating the use of `$show_all_signals` in Verilog modules.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p367.jpg,True,"Here is the Verilog code from the image:

```verilog
module myMod;
    assert #0 (rdy); //This is a deferred assert in a module.
                     //The current value of 'rdy' is used
endmodule

checker myCheck (rdy);
    assert #0 (rdy) //In the checker, sampled value of 'rdy' is used.
endchecker

From LRM (2012):

checker check(logic a, b, c, clk, rst);
    logic x, y, z, v, t;

    assign x = a; // current value of a
    
    always_ff @(posedge clk or negedge rst) // current values of clk and rst
    begin
        a1: assert (b); // sampled value of b
            if (rst) // current value of rst
                z <= b; // sampled value of b
            else z <= !c; // sampled value of c
    end
    
    always_comb begin
        a2: assert (b); // current value of b
            if (a) // current value of a
                v = b; // current value of b
            else v = !b; // current value of b
    end
    
    always_latch begin
        a3: assert (b); // current value of b
            if (clk) // current value of clk
                t <= b; // current value of b
    end
    // ...
endchecker : check
```

This code snippet appears to demonstrate the use of Verilog assertion constructs as well as always_ff, always_comb, and always_latch procedural blocks, which are commonly used in hardware description and verification.","
module myMod;
    assert #0 (rdy); //This is a deferred assert in a module.
                     //The current value of 'rdy' is used
endmodule

checker myCheck (rdy);
    assert #0 (rdy) //In the checker, sampled value of 'rdy' is used.
endchecker

From LRM (2012):

checker check(logic a, b, c, clk, rst);
    logic x, y, z, v, t;

    assign x = a; // current value of a
    
    always_ff @(posedge clk or negedge rst) // current values of clk and rst
    begin
        a1: assert (b); // sampled value of b
            if (rst) // current value of rst
                z <= b; // sampled value of b
            else z <= !c; // sampled value of c
    end
    
    always_comb begin
        a2: assert (b); // current value of b
            if (a) // current value of a
                v = b; // current value of b
            else v = !b; // current value of b
    end
    
    always_latch begin
        a3: assert (b); // current value of b
            if (clk) // current value of clk
                t <= b; // current value of b
    end
    // ...
endchecker : check
",Example of Verilog checkers and assertions for synthesis and simulation.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p137.jpg,True,"The image contains the following Verilog code:

```verilog
module top;
    logic [1:0] grant, request;
    bit clk;
    always #50 clk = ~clk;

    arb_if          arbif(clk);             // Sample 4-10
    arb_with_mp     a1(arbif.DUT);          // Sample 4-11
    test_with_mp    t1(arbif.TEST);         // Sample 4-12
endmodule
```

This code is from a textbook or document that discusses the usage of interfaces and modports in Verilog. The module `top` includes an example of instantiating other modules with different interface modports.","
module top;
    logic [1:0] grant, request;
    bit clk;
    always #50 clk = ~clk;

    arb_if          arbif(clk);             // Sample 4-10
    arb_with_mp     a1(arbif.DUT);          // Sample 4-11
    test_with_mp    t1(arbif.TEST);         // Sample 4-12
endmodule
","""Example of a Verilog top-level module using modports to specify signal direction in interfaces, from a digital design textbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p138.jpg,True,"The image contains two snippets of Verilog code along with associated comments and a diagram related to Verilog PLI (Programming Language Interface). Here is the Verilog code from the image:

```verilog
module chip (clock, in1, out1, out2);
    ...
    dff u1 (clock, in1, out1, out2);
endmodule

module dff (clk, d, q, qb);
    ...
endmodule
```

The diagram and the surrounding text give context about the Verilog PLI, discussing how module ports (`vpiPort`) and module instance ports (`vpiPortInst`) are accessed in the PLI context.

Please note that the ellipsis (`...`) is used to represent omitted sections of the code that are not visible in the image.","
module chip (clock, in1, out1, out2);
    ...
    dff u1 (clock, in1, out1, out2);
endmodule

module dff (clk, d, q, qb);
    ...
endmodule
","Caption: ""Illustrating Verilog module instantiation and port access, with an object diagram for nets showing the use of VPI (Verilog Procedural Interface).""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p123.jpg,True,"The image contains a snippet of Verilog code within the text. Here is the code:

```verilog
program automatic test();
    task wait_for_bus(input logic [31:0] addr, expect_data,
                      output logic success);
        while (bus_addr !== addr)
            @(bus_addr);
        success = (bus_data == expect_data);
    endtask
endprogram
```

This code defines a SystemVerilog program block with automatic storage class, which includes a task `wait_for_bus` designed to monitor when data are written into memory.","
program automatic test();
    task wait_for_bus(input logic [31:0] addr, expect_data,
                      output logic success);
        while (bus_addr !== addr)
            @(bus_addr);
        success = (bus_data == expect_data);
    endtask
endprogram
","Caption: ""Explanation and example of using automatic storage in Verilog tasks to ensure separate storage for local variables when tasks are called concurrently.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p415.jpg,True,"Here is the code from the image:

```verilog
module pci_protocol_property (input logic clk, reset_, TRDY_,
                              DESEL_, FRAME_, IRDY_,
                              input logic [3:0] C_BE_,
                              input logic [31:0] AD
);

// CHECK # 1. On falling edge of FRAME_, AD or C_BE_
//            cannot be unknown.

`ifdef check1
property checkPCI_AD_CBE;
    @(posedge clk) disable iff (!reset_)
    FRAME_ |-> 'b1; //DUMMY –REMOVE this line and
                     //code correct
                     //assertion
endproperty

assert property (checkPCI_AD_CBE) else $display($stime,,
            ""CHECK1:checkPCI_AD_CBE FAIL\n"");
`endif

// CHECK # 2. When IRDY_ and TRDY_ are asserted (low) AD
//            or C_BE_ cannot be unknown.

`ifdef check2
property checkPCI_DataPhase;
    @(posedge clk) disable iff (!reset_)
    FRAME_ |-> 'b1; // DUMMY – REMOVE this line and
                     // code correct
                     // assertion
endproperty

assert property (checkPCI_DataPhase) else $display($stime,,
            ""CHECK2:checkPCI_DataPhase FAIL\n"");
`endif

// CHECK # 3. FRAME_ can go High only if IRDY_ is asserted.
//            In other words, master can signify end of cycle
//            only if IRDY_ is asserted.
```

This code is intended for checking PCI protocol properties using SystemVerilog Assertions (SVA). There are placeholders marked as ""DUMMY –REMOVE this line and code correct"" where proper assertion code should be written. The comments provide guidelines on which protocols should be checked in the assertions.","
module pci_protocol_property (input logic clk, reset_, TRDY_,
                              DESEL_, FRAME_, IRDY_,
                              input logic [3:0] C_BE_,
                              input logic [31:0] AD
);

// CHECK # 1. On falling edge of FRAME_, AD or C_BE_
//            cannot be unknown.

`ifdef check1
property checkPCI_AD_CBE;
    @(posedge clk) disable iff (!reset_)
    FRAME_ |-> 'b1; //DUMMY –REMOVE this line and
                     //code correct
                     //assertion
endproperty

assert property (checkPCI_AD_CBE) else $display($stime,,
            ""CHECK1:checkPCI_AD_CBE FAIL\n"");
`endif

// CHECK # 2. When IRDY_ and TRDY_ are asserted (low) AD
//            or C_BE_ cannot be unknown.

`ifdef check2
property checkPCI_DataPhase;
    @(posedge clk) disable iff (!reset_)
    FRAME_ |-> 'b1; // DUMMY – REMOVE this line and
                     // code correct
                     // assertion
endproperty

assert property (checkPCI_DataPhase) else $display($stime,,
            ""CHECK2:checkPCI_DataPhase FAIL\n"");
`endif

// CHECK # 3. FRAME_ can go High only if IRDY_ is asserted.
//            In other words, master can signify end of cycle
//            only if IRDY_ is asserted.
","""Excerpt from a document showing SystemVerilog assertions for checking PCI protocol properties in a Verilog module.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p373.jpg,True,"The image contains Verilog code. Here it is:

```verilog
module PCI (irdy, trdy, clk) ;
  import project_library::*;
  irdy_trdy (irdy, trdy, posedge clk)
endmodule : PCI
```

Additionally, there are a couple of points to note mentioned in the image, plus an alternative way of importing only specific elements from the library:

- The statement `project_library::*;` makes the entire content of the package visible to module PCI.
- You could have imported only the checker of interest rather than importing the entire package, as in:

```verilog
import project_library::irdy_trdy;
```","
module PCI (irdy, trdy, clk) ;
  import project_library::*;
  irdy_trdy (irdy, trdy, posedge clk)
endmodule : PCI


import project_library::irdy_trdy;
","""Importing a Verilog package into a module to make all its contents available within the scope of that module.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p200.jpg,True,"The image contains Verilog code within a text book or document. Here's the code transcribed from the image:

```verilog
sequence s_read;
  (rd_addr == $past (rd_addr)+1) [*0:$] ##1
  $fell (rd);
endsequence

property p_read;
  @(posedge clk)
  (($rose (rd) && reset_) |-> 
    s_read);
endproperty

a_read: assert property(p_read);
```

This code chunk represents a SystemVerilog assertion to check that a read address `rd_addr` is incremented correctly in a design testbench or verification environment.","
sequence s_read;
  (rd_addr == $past (rd_addr)+1) [*0:$] ##1
  $fell (rd);
endsequence

property p_read;
  @(posedge clk)
  (($rose (rd) && reset_) |-> 
    s_read);
endproperty

a_read: assert property(p_read);
","Caption: ""Verilog code snippet demonstrating a SystemVerilog assertion for checking data read operations with an accompanying waveform diagram.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p398.jpg,True,"The image contains Verilog code snippets primarily focused on property definitions and assertions within conditional compilation blocks (`ifdef...`   `endif`). Here is the Verilog code from the image:

```verilog
`ifdef check1
property counter_reset;
    @(posedge clk) data_in |=> data_out; // DUMMY - REMOVE this line and code
    // correct assertion
endproperty

counter_reset_check: assert property(counter_reset)
else $display($stime,,, ""\t\tCOUNTER RESET CHECK FAIL:: rst_ = %b data_out=%0d \n"",
rst_,data_out);
`endif

// CHECK # 2.Check that if ld_cnt_ is de-asserted (==1) and count_enb is not
// enabled (==0) that data_out HOLDS its previous value.
// Disable this property 'iff (!rst)'

`ifdef check2
property counter_hold;
    @(posedge clk) data_in |=> data_out; // DUMMY - REMOVE this line and code
    // correct assertion
endproperty

counter_hold_check: assert property(counter_hold)
else $display($stime,,, ""\t\tCOUNTER HOLD CHECK FAIL:: counter HOLD \n"");
`endif

// CHECK # 3. Check that if ld_cnt_ is de-asserted (==1) and count_enb is 
// enabled (==1) that if updwn_cnt==1 the count goes UP and if updwn_cnt==0 the count goes DOWN.
// Disable this property 'iff (!rst)'

`ifdef check3
property counter_count;
    @(posedge clk) data_in |=> data_out; // DUMMY - REMOVE this line and code

endproperty
```

Note that the lines with the comments ""// DUMMY - REMOVE this line and code"" indicate that these lines are placeholder code and should be removed or replaced with correct assertions according to the surrounding comments and context.","
`ifdef check1
property counter_reset;
    @(posedge clk) data_in |=> data_out; // DUMMY - REMOVE this line and code
    // correct assertion
endproperty

counter_reset_check: assert property(counter_reset)
else $display($stime,,, ""\t\tCOUNTER RESET CHECK FAIL:: rst_ = %b data_out=%0d \n"",
rst_,data_out);
`endif

// CHECK # 2.Check that if ld_cnt_ is de-asserted (==1) and count_enb is not
// enabled (==0) that data_out HOLDS its previous value.
// Disable this property 'iff (!rst)'

`ifdef check2
property counter_hold;
    @(posedge clk) data_in |=> data_out; // DUMMY - REMOVE this line and code
    // correct assertion
endproperty

counter_hold_check: assert property(counter_hold)
else $display($stime,,, ""\t\tCOUNTER HOLD CHECK FAIL:: counter HOLD \n"");
`endif

// CHECK # 3. Check that if ld_cnt_ is de-asserted (==1) and count_enb is 
// enabled (==1) that if updwn_cnt==1 the count goes UP and if updwn_cnt==0 the count goes DOWN.
// Disable this property 'iff (!rst)'

`ifdef check3
property counter_count;
    @(posedge clk) data_in |=> data_out; // DUMMY - REMOVE this line and code

endproperty
","""Verilog Assertions for Checking Counter Behavior in a Digital Design""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p142.jpg,True,"The image contains pseudo-code related to an algorithm or computational procedure, but it is not Verilog code specifically. Here is the pseudo-code:

```plaintext
global variables: V a set, E ⊆ V × V, ϕ: V → wff

procedure Expand(v ∈ V):
  if v is an uncovered leaf then
    for all actions (M(v), T, m) ∈ Δ
      add a new vertex u to V and a new edge (v, u) to E;
      set Mv(u) = m and ψ(u) = True;
      set Mϵ(v, u) ← T

procedure Refine(ϵ ∈ V):
  if Mϵ(v) = ⊥ and ψ(v) ≠ False then
    let u = (v0, v1... vi... vn-1, vn) be the unique path from ϵ to v
    if U(π) has an interpolant A0, ..., An then
      for i = 0 ... n:
        let ϕ = Ai
        let ψ(vi) = Ai−ϕ
        if ψ(vi) ≠ ϕ then
          remove all pairs (., vi) from ρ
          set ψ(vi) ← ψ(vi) ∧ ϕ
        else abort (program is unsafe)

procedure Cover(x, u ∈ V):
  if v is uncovered and Mv(v) = Mu(v) and v ≠ u then
    if ψ(v) ⇒ ψ(u) then
      add (v, u) to ρ;
      delete all (z, y) ∈ ρ, s.t. v ∈ y;
```

This code seems to be written in pseudo-code form, describing an algorithm that operates on certain variables and structures, and contains procedures named `Expand`, `Refine`, and `Cover`. It is meant to illustrate some logic related to computer science or formal methods for system verification.","xt
global variables: V a set, E ⊆ V × V, ϕ: V → wff

procedure Expand(v ∈ V):
  if v is an uncovered leaf then
    for all actions (M(v), T, m) ∈ Δ
      add a new vertex u to V and a new edge (v, u) to E;
      set Mv(u) = m and ψ(u) = True;
      set Mϵ(v, u) ← T

procedure Refine(ϵ ∈ V):
  if Mϵ(v) = ⊥ and ψ(v) ≠ False then
    let u = (v0, v1... vi... vn-1, vn) be the unique path from ϵ to v
    if U(π) has an interpolant A0, ..., An then
      for i = 0 ... n:
        let ϕ = Ai
        let ψ(vi) = Ai−ϕ
        if ψ(vi) ≠ ϕ then
          remove all pairs (., vi) from ρ
          set ψ(vi) ← ψ(vi) ∧ ϕ
        else abort (program is unsafe)

procedure Cover(x, u ∈ V):
  if v is uncovered and Mv(v) = Mu(v) and v ≠ u then
    if ψ(v) ⇒ ψ(u) then
      add (v, u) to ρ;
      delete all (z, y) ∈ ρ, s.t. v ∈ y;
","Figure illustrating algorithmic steps in formal verification involving graph unwinding, with accompanying pseudocode for procedures Expand, Refine, and Cover in the context of a verification framework.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p156.jpg,True,"```c
int x = 200, y = 200;
while (x !=0) { x = x - 1; y = y - 1; }
assert (y==0);
``` 

The code snippet in the image is written in what appears to be C, not Verilog. It initializes two integer variables (`x` and `y`) to 200 and then decrements both in a loop until `x` reaches 0. After the loop, it asserts that `y` should also be 0, which should be true given the loop's logic."," = 200, y = 200;
while (x !=0) { x = x - 1; y = y - 1; }
assert (y==0);
","Academic paper excerpt discussing control flow graph analysis and transition relation strengthening in the context of formal verification, featuring an example of C-like pseudo-code for illustrating the concept.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p321.jpg,True,"The image contains an example of Verilog code related to assertion syntax. Here's the code from the image:

```verilog
assert_zero_one_hot #(
  0, 3) wr_mode (clk, reset_n,
  {fsm_1=='WR_MODE,
   fsm_2=='WR_MODE,
   fsm_3=='WR_MODE});
```

This code snippet is an example of using the `assert_zero_one_hot` assertion from the Open Verification Library to ensure that only one of the finite state machines (fsm_1, fsm_2, fsm_3) is in 'WR_MODE' at a time.","
assert_zero_one_hot #(
  0, 3) wr_mode (clk, reset_n,
  {fsm_1=='WR_MODE,
   fsm_2=='WR_MODE,
   fsm_3=='WR_MODE});
","""Excerpt from the Open Verification Library detailing the syntax and usage of the assert_zero_one_hot assertion in Verilog for checking the mutual exclusivity of finite-state machines.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p71.jpg,True,"The image contains Verilog code. Here's the code excerpt from the image:

```verilog
`ifdef RTL
    assign perr = `in; //calculate parity on `in`
`else
    wire t1, t2, t3;
    XOR3 u1 (t1, in[0], in[1], in[2]);
    XOR3 u2 (t2, in[3], in[4], in[5]);
    XOR3 u3 (t3, in[6], in[7], in[8]);
    XOR3 u4 (perr, t1, t2, t3);
`endif
```

This code snippet shows an example of conditional compilation in Verilog using `ifdef...else...endif` to define different behavior or implementation based on the compilation flag (`RTL`).","
`ifdef RTL
    assign perr = `in; //calculate parity on `in`
`else
    wire t1, t2, t3;
    XOR3 u1 (t1, in[0], in[1], in[2]);
    XOR3 u2 (t2, in[3], in[4], in[5]);
    XOR3 u3 (t3, in[6], in[7], in[8]);
    XOR3 u4 (perr, t1, t2, t3);
`endif
","""Example of conditional compilation in Verilog using `ifdef` for RTL behavior specification and macro cell instance implementation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p716.jpg,True,"The image contains C-like declarations and comments associated with Verilog. Here is the code from the image:

```c
void vpi_get_cb_info(object, data)
vpiHandle object                      handle for an object.
p_cb_data data                        pointer to an application-allocated s_cb_data structure to
                                      receive callback information.

Retrieves information about a simulation callback and places in an s_cb_data structure.

typedef struct t_cb_data {
  int reason;                 /* callback reason */
  int (*cb_rtn)();            /* call routine name */
  vpiHandle obj;              /* trigger object */
  p_vpi_time *time;           /* callback time */
  p_vpi_value *value;         /* trigger object value */
  int index;                  /* index of memory word or var
                                 select that changed value */
  char *user_data;            /* */
} s_cb_data, *p_cb_data;

void vpi_get_delays(object, delay)
vpiHandle object                      handle for an object.
p_vpi_delay delay                     pointer to an application-allocated s_vpi_delay structure to
                                      receive delay information.

Retrieves an object’s delays or pulse control values into an s_vpi_delay structure.
The append_flag and pulserse_flag are ignored.

typedef struct t_vpi_delay {
  struct t_vpi_time *da;       /* ptr to user allocated
                                  array of delay values */
  int no_of_delays;            /* number of delay transitions */
  int time_type;               /* vpiScaledRealTime, vpiSimTime,
                                  or vpiSuppressTime */
  int mtm_flag;                /* true if using min:typ:max
                                  delay value sets */
  int append_flag;             /* true to append delays,
                                  false to replace delays */
  int pulserse_flag;           /* true to set pulserse values */
} s_vpi_delay, *p_vpi_delay;

typedef struct t_vpi_time {
  int type;                    /* not used by vpi_get_delays() */
  unsigned int high;           /* when using vpiSimTime */
  unsigned int low;            /* when using vpiSimTime */
  double real;                 /* when using vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;
```

Note that the code appears to be incomplete, and some of the comments might be cut off in the image. The code is defining data structures and function prototypes for use with the Verilog Programming Language Interface (PLI).","vpi_get_cb_info(object, data)
vpiHandle object                      handle for an object.
p_cb_data data                        pointer to an application-allocated s_cb_data structure to
                                      receive callback information.

Retrieves information about a simulation callback and places in an s_cb_data structure.

typedef struct t_cb_data {
  int reason;                 /* callback reason */
  int (*cb_rtn)();            /* call routine name */
  vpiHandle obj;              /* trigger object */
  p_vpi_time *time;           /* callback time */
  p_vpi_value *value;         /* trigger object value */
  int index;                  /* index of memory word or var
                                 select that changed value */
  char *user_data;            /* */
} s_cb_data, *p_cb_data;

void vpi_get_delays(object, delay)
vpiHandle object                      handle for an object.
p_vpi_delay delay                     pointer to an application-allocated s_vpi_delay structure to
                                      receive delay information.

Retrieves an object’s delays or pulse control values into an s_vpi_delay structure.
The append_flag and pulserse_flag are ignored.

typedef struct t_vpi_delay {
  struct t_vpi_time *da;       /* ptr to user allocated
                                  array of delay values */
  int no_of_delays;            /* number of delay transitions */
  int time_type;               /* vpiScaledRealTime, vpiSimTime,
                                  or vpiSuppressTime */
  int mtm_flag;                /* true if using min:typ:max
                                  delay value sets */
  int append_flag;             /* true to append delays,
                                  false to replace delays */
  int pulserse_flag;           /* true to set pulserse values */
} s_vpi_delay, *p_vpi_delay;

typedef struct t_vpi_time {
  int type;                    /* not used by vpi_get_delays() */
  unsigned int high;           /* when using vpiSimTime */
  unsigned int low;            /* when using vpiSimTime */
  double real;                 /* when using vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;
","Caption: Extract from ""The Verilog PLI Handbook"" detailing Verilog Procedural Interface (VPI) callback and delay-related functions and data structures.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p282.jpg,True,"The image contains two fragments of code. One is a Verilog fragment, and the other one is a SystemVerilog assertion. Here are the code snippets:

Verilog fragment for simple arbiter interface:
```verilog
module simple_arb(
input [3:0] req;    // Request vector.
input [3:0] hpri;   // High priority flags.
output [3:0] gnt;   // Grant vector.

// Grant is asserted two cycles (minimum)
// after request is asserted.
...
```

System Verilog req receives a grant within N cycles:
```verilog
assert property (@(posedge clk) $rose(req) |-> ##[2:50] grant)
else $error(""Request did not receive grant within timeout limit."");
```","
module simple_arb(
input [3:0] req;    // Request vector.
input [3:0] hpri;   // High priority flags.
output [3:0] gnt;   // Grant vector.

// Grant is asserted two cycles (minimum)
// after request is asserted.
...


assert property (@(posedge clk) $rose(req) |-> ##[2:50] grant)
else $error(""Request did not receive grant within timeout limit."");
","Caption: ""Educational material illustrating a Verilog code fragment for a simple arbiter interface along with a discussion on request timeout assertions in SystemVerilog.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p213.jpg,True,"The image contains examples of Verilog code. Here they are:

```verilog
sequence dataCheck;
    int local_data;
    (rdc, local_data=rData) ##1 ( wData == (local_data+'hff));
endsequence

property dataCheck;
    int local_data;
    (rdc, local_data=rData) |=> ( wData == (local_data+'hff));
endproperty

sequence L_seq(Ldata);
    int Ldata;
    (rdc, Ldata=rData);
endsequence
```

The image also includes a comment on the bottom sequence, saying ""ERROR: local var Ldata cannot be declared here because it is used as a formal argument.""","
sequence dataCheck;
    int local_data;
    (rdc, local_data=rData) ##1 ( wData == (local_data+'hff));
endsequence

property dataCheck;
    int local_data;
    (rdc, local_data=rData) |=> ( wData == (local_data+'hff));
endproperty

sequence L_seq(Ldata);
    int Ldata;
    (rdc, Ldata=rData);
endsequence
",A textbook page explaining local variables in Verilog with example code for sequences and properties.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p94.jpg,True,"Here is the Verilog code from the image:

```verilog
module default_explicit_clocking;

default clocking negedgeClock @(negedge clk1); endclocking
clocking posedgeClock @(posedge clk2); endclocking

d2: assert property (x |-> y); //will inherit default clock - negedgeClock
d3: assert property (z [-2] |-> a); //will inherit default clock - negedgeClock
nd1: assert property (@(posedgeClock b |=> c); //will use non-default clocking posedgeClock

endmodule
```

```verilog
module default_explicit_clocking;

default clocking negedgeClock @(negedge clk1); endclocking

d2: assert property (x |-> y); //will inherit default clock - negedgeClock
d3: assert property (z [-2] |-> a); //will inherit default clock - negedgeClock
nd1: assert property (@(posedge clk2) b |=> c); //explicit declaration of clock - clk2

endmodule
```

```verilog
module default_explicit_clocking;

default clocking negedgeClock @(negedge clk1); endclocking

property nclk; @(posedge clk2) b |=> c; endproperty

endmodule
```

Please note that there appears to be a syntax error in the image with the `assert` statement which is missing a closing parenthesis. Here is the corrected line from the first code block:

```verilog
nd1: assert property (@(posedgeClock b |=> c)); //will use non-default clocking posedgeClock
```","
module default_explicit_clocking;

default clocking negedgeClock @(negedge clk1); endclocking
clocking posedgeClock @(posedge clk2); endclocking

d2: assert property (x |-> y); //will inherit default clock - negedgeClock
d3: assert property (z [-2] |-> a); //will inherit default clock - negedgeClock
nd1: assert property (@(posedgeClock b |=> c); //will use non-default clocking posedgeClock

endmodule


module default_explicit_clocking;

default clocking negedgeClock @(negedge clk1); endclocking

d2: assert property (x |-> y); //will inherit default clock - negedgeClock
d3: assert property (z [-2] |-> a); //will inherit default clock - negedgeClock
nd1: assert property (@(posedge clk2) b |=> c); //explicit declaration of clock - clk2

endmodule


module default_explicit_clocking;

default clocking negedgeClock @(negedge clk1); endclocking

property nclk; @(posedge clk2) b |=> c; endproperty

endmodule


nd1: assert property (@(posedgeClock b |=> c)); //will use non-default clocking posedgeClock
",Example of using default and explicit clocking in Verilog assertions.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p80.jpg,True,"Here is the Verilog code from the image:

```verilog
sequence sr1;
  req ##2 (gnt==1 && req==0);
endsequence

property pr1;
  @(posedge clk) cStart |-> sr1;
endproperty

reqGnt: assert property (pr1) $display($stime,,""\t %m PASS"");
  else $display($stime,,""\t %m FAIL"");
```

The code snippet demonstrates the use of sequences and properties within system Verilog assertions where `sr1` is a defined sequence and `pr1` is a property that uses this sequence. The assertion `reqGnt` checks the property and conditionally displays a message indicating pass or fail based on whether the property holds.","
sequence sr1;
  req ##2 (gnt==1 && req==0);
endsequence

property pr1;
  @(posedge clk) cStart |-> sr1;
endproperty

reqGnt: assert property (pr1) $display($stime,,""\t %m PASS"");
  else $display($stime,,""\t %m FAIL"");
","""Exploring the Structure of Concurrent Assertions in Verilog with Antecedents and Consequents""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p296.jpg,True,"The image contains Verilog code within a book or document page. Here's the Verilog code from the image:

```verilog
property LastReadRelatedToWrite;
    reg [15:0] last_data;
    @(posedge clk)
        $rose(write), last_data=data_in
        ##1 (!write throughout read [->1]) |-> 
        data_out==last_data;
endproperty
assert property (LastReadRelatedToWrite);
```

This code defines a property named `LastReadRelatedToWrite` for assertion-based verification in SystemVerilog. It captures the last data written during a write command and checks it against the data output on the next read command.","
property LastReadRelatedToWrite;
    reg [15:0] last_data;
    @(posedge clk)
        $rose(write), last_data=data_in
        ##1 (!write throughout read [->1]) |-> 
        data_out==last_data;
endproperty
assert property (LastReadRelatedToWrite);
","Caption: ""Extract from a technical document illustrating a waveform timing diagram for a write operation and providing a SystemVerilog property example for specifying the behavior of the last data read related to a write operation.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p59.jpg,True,"The image contains a portion of Verilog code as follows:

```verilog
if (TOP.dv_initialization_complete) // Check for reset done
    if(event_exp) //Check for event
        $display(""EVENT:%0d:%0d:%0m"", EVENT_NUM, $time);
```
This snippet shows examples used to illustrate a strategy for monitoring events or assertions after a design has been initialized.","
if (TOP.dv_initialization_complete) // Check for reset done
    if(event_exp) //Check for event
        $display(""EVENT:%0d:%0d:%0m"", EVENT_NUM, $time);
","""Verilog code snippet for event monitoring after design initialization""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p269.jpg,True,"The image contains two snippets of SystemVerilog code. Here they are:

Snippet 1:

```verilog
valid_encoder_input: assert property
    (@(posedge clk) $onehot(control_state));
```

Snippet 2:

```verilog
genvar N;
generate for (N=0;N<3;N= N+ 1)
    cover property @(posedge clk) (encode2 == N);
endgenerate
```","
valid_encoder_input: assert property
    (@(posedge clk) $onehot(control_state));


genvar N;
generate for (N=0;N<3;N= N+ 1)
    cover property @(posedge clk) (encode2 == N);
endgenerate
","""Excerpt from a text on Assertion-Based Design featuring SystemVerilog assertion and functional coverage code examples for verifying encoder input values.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p241.jpg,True,"The image contains SystemVerilog code. Here are the snippets visible:

Example 7-14 SystemVerilog pipeline data is zero until pipeline is flushed
```verilog
// related to Example 7-11
property flushed_depth;
    @(posedge clk) ($fell(flush) |-> 
    !data_out throughout !stall [->DEPTH]);
endproperty

assert property (flushed_depth);
```

Example 7-15 SystemVerilog functional coverage of flushed data
```verilog
// report occurrence of no stall and valid data followed 
// within 1 or 2 cycles a flush
property cov_flushed;
    @(posedge clk)
    (!stall & data ##[1:2] flush);
endproperty

cover (cov_flushed);
```","
// related to Example 7-11
property flushed_depth;
    @(posedge clk) ($fell(flush) |-> 
    !data_out throughout !stall [->DEPTH]);
endproperty

assert property (flushed_depth);


// report occurrence of no stall and valid data followed 
// within 1 or 2 cycles a flush
property cov_flushed;
    @(posedge clk)
    (!stall & data ##[1:2] flush);
endproperty

cover (cov_flushed);
",Example of SystemVerilog assertions for verifying pipeline flush operations.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p173.jpg,True,"Here is the Verilog code snippet from the image:

```verilog
Xbus[15:0] <= {Abus[4:1], 6{1'bZ, 1'b0}};
```

This line demonstrates the use of the replication operator in Verilog to set bits of the `Xbus` to an alternating pattern of 'Z' and '0'.","
Xbus[15:0] <= {Abus[4:1], 6{1'bZ, 1'b0}};
","Page from a textbook discussing Verilog replication operator and operator precedence, including a table of operators according to their precedence levels, followed by an introduction to digital basics covering three-state buffers.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p43.jpg,True,"The image contains Verilog code for a simple bus protocol. Please find the code below:

```verilog
always @(posedge FRAME_)
begin:ldpcheck
  @(posedge clk);
  fork
    begin
      @(negedge LDP_) disable ldpcheck;
    end
    begin
      repeat (2) @(posedge clk); $display(""ldpcheck FAIL"");
      disable ldpcheck;
    end
  join
end
```","
always @(posedge FRAME_)
begin:ldpcheck
  @(posedge clk);
  fork
    begin
      @(negedge LDP_) disable ldpcheck;
    end
    begin
      repeat (2) @(posedge clk); $display(""ldpcheck FAIL"");
      disable ldpcheck;
    end
  join
end
",Verilog code example showing a simple bus protocol checker using fork-join to monitor conditions.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p255.jpg,True,"There are two blocks of Verilog code in the image. Here they are transcribed:

Example 7-33
```
genvar L, S;
generate for (L=0;L<=7; L= L+ 1)
    generate for (S=0;S<=3; S= S+ 1)
        cover property @(posedge clk)
        (!cache_fill & cache_we[L] & write_set[S] & set_valid[S]);
    endgenerate
endgenerate
```

Example 7-34
```
genvar L, S;
generate for (L=0;L<=7; L= L+ 1)
    generate for (S=0;S<=3; S= S+ 1)
        cover property @(posedge clk)
        (cache_fill & cache_we[L] & write_set[S] & set_valid[S]);
    endgenerate
endgenerate
```"," L, S;
generate for (L=0;L<=7; L= L+ 1)
    generate for (S=0;S<=3; S= S+ 1)
        cover property @(posedge clk)
        (!cache_fill & cache_we[L] & write_set[S] & set_valid[S]);
    endgenerate
endgenerate

 L, S;
generate for (L=0;L<=7; L= L+ 1)
    generate for (S=0;S<=3; S= S+ 1)
        cover property @(posedge clk)
        (cache_fill & cache_we[L] & write_set[S] & set_valid[S]);
    endgenerate
endgenerate
",Example text of SystemVerilog code for functional coverage in a cache memory context.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p266.jpg,True,"The image contains a snippet of code written in C programming language for interfacing with Verilog simulations using the Verilog Procedural Interface (VPI). The full code snippet is as follows:

```c
cb_data_s.time = $time_s;
cb_data_s.value = NULL;
vpi_register_cb(&cb_data_s);
}
return(0);
}

/*********************************************************************
* Read-write synchronize simulation callback routine: Serves as an
* interface between Verilog simulation and the C model. Passes the
* values to the C model, and puts the C model outputs into simulation.
*
* NOTE: The handles for the arguments to scientific_alu were obtained
* in the calltf routine and saved in application-allocated memory. A
* pointer to this memory is passed to this callback via the user_data
* field.
*********************************************************************/

int PLIbook_EndOfTimeStep_callback(p_cb_data cb_data)
{
    double a, b, result;
    int opcode, excep, err;
    s_vpi_value value_s;

    PLIbook_ALU_data_p ALUdata;

    /* Retrieve pointer to ALU data structure from callback user_data. */
    /* The structure contains the handles for the sscientific_alu args */
    ALUdata = (PLIbook_ALU_data_p) cb_data->user_data;

    /* Set the sync_flag to 0 to indicate that this callback has been */
    /* processed */
    ALUdata->sync_flag = 0;

    /* Read current values of C model inputs from Verilog simulation */
    value_s.format = vpiRealVal;
    vpi_get_value(ALUdata->a_h, &value_s);
    a = value_s.value.real;

    vpi_get_value(ALUdata->b_h, &value_s);
    b = value_s.value.real;

    value_s.format = vpiIntVal;
    vpi_get_value(ALUdata->opcode_h, &value_s);
    opcode = value_s.value.integer;

    /****** Call the C model ******/
    PLIbook_ScientificALU_c_model(&result, &excep, &err, a, b, opcode);

    /* Write the C model outputs onto the Verilog signals */
    value_s.format = vpiRealVal;
    value_s.value.real = result;
    vpi_put_value(ALUdata->result_h, &value_s, NULL, vpiNoDelay);
```

This code demonstrates the use of VPI functions such as `vpi_register_cb`, `vpi_get_value`, and `vpi_put_value` to transfer data between the Verilog simulation and a C-based computational model. The callback function `PLIbook_EndOfTimeStep_callback` reads values from the Verilog simulation, processes them through a C model, and then writes the result back into the Verilog simulation. The code handles data types like real and integer and caters to a synchronization mechanism with `sync_flag`.","ta_s.time = $time_s;
cb_data_s.value = NULL;
vpi_register_cb(&cb_data_s);
}
return(0);
}

/*********************************************************************
* Read-write synchronize simulation callback routine: Serves as an
* interface between Verilog simulation and the C model. Passes the
* values to the C model, and puts the C model outputs into simulation.
*
* NOTE: The handles for the arguments to scientific_alu were obtained
* in the calltf routine and saved in application-allocated memory. A
* pointer to this memory is passed to this callback via the user_data
* field.
*********************************************************************/

int PLIbook_EndOfTimeStep_callback(p_cb_data cb_data)
{
    double a, b, result;
    int opcode, excep, err;
    s_vpi_value value_s;

    PLIbook_ALU_data_p ALUdata;

    /* Retrieve pointer to ALU data structure from callback user_data. */
    /* The structure contains the handles for the sscientific_alu args */
    ALUdata = (PLIbook_ALU_data_p) cb_data->user_data;

    /* Set the sync_flag to 0 to indicate that this callback has been */
    /* processed */
    ALUdata->sync_flag = 0;

    /* Read current values of C model inputs from Verilog simulation */
    value_s.format = vpiRealVal;
    vpi_get_value(ALUdata->a_h, &value_s);
    a = value_s.value.real;

    vpi_get_value(ALUdata->b_h, &value_s);
    b = value_s.value.real;

    value_s.format = vpiIntVal;
    vpi_get_value(ALUdata->opcode_h, &value_s);
    opcode = value_s.value.integer;

    /****** Call the C model ******/
    PLIbook_ScientificALU_c_model(&result, &excep, &err, a, b, opcode);

    /* Write the C model outputs onto the Verilog signals */
    value_s.format = vpiRealVal;
    value_s.value.real = result;
    vpi_put_value(ALUdata->result_h, &value_s, NULL, vpiNoDelay);
","""Example of a Verilog PLI callback function to synchronize C model inputs and outputs with Verilog simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p517.jpg,True,"Here is the code from the image:

```verilog
property p1;
    a and nexttime p2 (p2 (p3)) ;
endproperty

property p2(property p)
    eventually[0:1] p;
endproperty

property p3;
    b and nexttime p1;
endproperty
```

The image contains Verilog code for property declarations, which are being used to illustrate the formal semantics of recursive properties in the context of a learning resource or textbook.","
property p1;
    a and nexttime p2 (p2 (p3)) ;
endproperty

property p2(property p)
    eventually[0:1] p;
endproperty

property p3;
    b and nexttime p1;
endproperty
","""Understanding Verilog recursive properties through dependency digraphs and k-fold approximations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p500.jpg,True,"The image contains a snippet of Verilog code. Here is the code written on the page:

```verilog
module dff (clk, d, q, qb);
    input clk, d;
    output q, qb;

    ff_prim g1 (q, d, clk,);
    not g2 (qb, q);

    specify
        (d => q) = 2.5;
    endspecify
endmodule
```

This appears to be a definition for a D flip-flop module in Verilog, which includes inputs, outputs, and some timing specifications.","
module dff (clk, d, q, qb);
    input clk, d;
    output q, qb;

    ff_prim g1 (q, d, clk,);
    not g2 (qb, q);

    specify
        (d => q) = 2.5;
    endspecify
endmodule
","Caption: ""Excerpt from The Verilog PLI Handbook showing the D flip-flop module code with specified delay and ACC object diagram for Verilog modules.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p77.jpg,True,"The image contains Verilog code that defines sequences and a property using the ""and"" operator. Here's the code:

```verilog
sequence s27a;
    @(posedge clk) a##[1:2] b;
endsequence

sequence s27b;
    @(posedge clk) c##[2:3] d;
endsequence

property p27;
    @(posedge clk) s27a and s27b;
endproperty

a27: assert property(p27);
```","
sequence s27a;
    @(posedge clk) a##[1:2] b;
endsequence

sequence s27b;
    @(posedge clk) c##[2:3] d;
endsequence

property p27;
    @(posedge clk) s27a and s27b;
endproperty

a27: assert property(p27);
","Caption: Example of Verilog code demonstrating the usage of the ""and"" construct with sequences and properties for assertion-based verification.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p63.jpg,True,"```verilog
`define true 1

sequence s18a;
    @(posedge clk) a ##1 b;
endsequence

sequence s18a_ext;
    @(posedge clk) a ##1 b ##1 `true;
endsequence

sequence s18b;
    @(posedge clk) c ##1 d;
endsequence

property p18
    @(posedge clk) s18a.ended |-> ##2 s18b.ended;
endproperty

property p18_ext
    @(posedge clk) s18a_ext.ended |=> s18b.ended;
endproperty

a18: assert property(p18);
a18_ext: assert property(p18_ext);
```","
`define true 1

sequence s18a;
    @(posedge clk) a ##1 b;
endsequence

sequence s18a_ext;
    @(posedge clk) a ##1 b ##1 `true;
endsequence

sequence s18b;
    @(posedge clk) c ##1 d;
endsequence

property p18
    @(posedge clk) s18a.ended |-> ##2 s18b.ended;
endproperty

property p18_ext
    @(posedge clk) s18a_ext.ended |=> s18b.ended;
endproperty

a18: assert property(p18);
a18_ext: assert property(p18_ext);
",Excerpt from a document explaining temporal properties in Verilog assertions and showing related code examples.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p272.jpg,True,"```c
vpi_get_value(ALUdata->b_h, &value_s);
b = value_s.value.real;

value_s.format = vpiIntVal;
vpi_get_value(ALUdata->opcode_h, &value_s);
opcode = value_s.value.integer;

vpi_get_value(ALUdata->enable_h, &value_s);
enable = value_s.value.integer;

/****** Call the C model ******/
PLIbook_ScientificALU_C_model(&result, &excep, &err, a, b, opcode,
                              enable, &ALUdata->LatchedOutputs);

/* Write the C model outputs onto the Verilog signals */
value_s.format = vpiRealVal;
value_s.value.real = result;
vpi_put_value(ALUdata->result_h, &value_s, NULL, vpiNoDelay);

value_s.format = vpiIntVal;
value_s.value.integer = excep;
vpi_put_value(ALUdata->excep_h, &value_s, NULL, vpiNoDelay);

value_s.value.integer = err;
vpi_put_value(ALUdata->err_h, &value_s, NULL, vpiNoDelay);

return(0);
}

/***********************************************************************
 * calltf routine: Registers a callback to the C model interface
 * whenever any input to the C model changes value
 ***********************************************************************/
int PLIbook_ScientificALU_calltf(char *user_data)
{
    vpiHandle instance_h, arg_itr;
    s_vpi_value value_s;
    s_vpi_time time_s;
    s_cb_data cb_data_s;
    PLIbook_ALU_data_p ALUdata;

    /* allocate storage to hold $scientific_alu argument handles */
    ALUdata = (PLIbook_ALU_data_p)malloc(sizeof(PLIbook_ALU_data_s));

    /* obtain a handle to the system task instance */
    instance_h = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handles to system task arguments */
    /* compiletf has already verified arguments are correct */
    arg_itr = vpi_iterate(vpiArgument, instance_h);
    ALUdata->enable_h = vpi_scan(arg_itr); /* 1st arg is enable input */
    ALUdata->a_h = vpi_scan(arg_itr); /* 2nd arg is a input */
```","et_value(ALUdata->b_h, &value_s);
b = value_s.value.real;

value_s.format = vpiIntVal;
vpi_get_value(ALUdata->opcode_h, &value_s);
opcode = value_s.value.integer;

vpi_get_value(ALUdata->enable_h, &value_s);
enable = value_s.value.integer;

/****** Call the C model ******/
PLIbook_ScientificALU_C_model(&result, &excep, &err, a, b, opcode,
                              enable, &ALUdata->LatchedOutputs);

/* Write the C model outputs onto the Verilog signals */
value_s.format = vpiRealVal;
value_s.value.real = result;
vpi_put_value(ALUdata->result_h, &value_s, NULL, vpiNoDelay);

value_s.format = vpiIntVal;
value_s.value.integer = excep;
vpi_put_value(ALUdata->excep_h, &value_s, NULL, vpiNoDelay);

value_s.value.integer = err;
vpi_put_value(ALUdata->err_h, &value_s, NULL, vpiNoDelay);

return(0);
}

/***********************************************************************
 * calltf routine: Registers a callback to the C model interface
 * whenever any input to the C model changes value
 ***********************************************************************/
int PLIbook_ScientificALU_calltf(char *user_data)
{
    vpiHandle instance_h, arg_itr;
    s_vpi_value value_s;
    s_vpi_time time_s;
    s_cb_data cb_data_s;
    PLIbook_ALU_data_p ALUdata;

    /* allocate storage to hold $scientific_alu argument handles */
    ALUdata = (PLIbook_ALU_data_p)malloc(sizeof(PLIbook_ALU_data_s));

    /* obtain a handle to the system task instance */
    instance_h = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handles to system task arguments */
    /* compiletf has already verified arguments are correct */
    arg_itr = vpi_iterate(vpiArgument, instance_h);
    ALUdata->enable_h = vpi_scan(arg_itr); /* 1st arg is enable input */
    ALUdata->a_h = vpi_scan(arg_itr); /* 2nd arg is a input */
","""Example of Verilog Procedural Interface (VPI) code integrating C model with Verilog simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p265.jpg,True,"The image contains descriptions and examples related to sequence containment using SystemVerilog assertion properties. Here are the code snippets present in the image:

```verilog
a1: assert property (write |=> (read ##1 1) within write[-$1]);
```

```verilog
assert property (
    start_t |-> not strong(write[*2] within end_t[-$1]));
```

```verilog
!b[*] ##1 a ##0 !b[*] ##1 b
```

These snippets are examples demonstrating how to use sequence operators and temporal logic in SystemVerilog assertions for formal verification.","
a1: assert property (write |=> (read ##1 1) within write[-$1]);


assert property (
    start_t |-> not strong(write[*2] within end_t[-$1]));


!b[*] ##1 a ##0 !b[*] ##1 b
","""Explanation of the Verilog 'within' sequence operator with code examples and an efficiency tip.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p241.jpg,True,"The image contains three sections of Verilog code. Here are the codes as they appear in the image:

Sample 6.43:
```verilog
class signedVars;
  rand byte pkt1_len, pkt2_len;
  constraint total_len {
    pkt1_len + pkt2_len == 64;
  }
endclass
```

Sample 6.44:
```verilog
class Vars32;
  rand bit [31:0] pkt1_len, pkt2_len; // unsigned type
  constraint total_len {
    pkt1_len + pkt2_len == 64;
  }
endclass
```

Sample 6.45:
```verilog
class Vars8;
  rand bit [7:0] pkt1_len, pkt2_len; // 8-bits wide
  constraint total_len {
    pkt1_len + pkt2_len == 9'd64; // 9-bit sum
  }
endclass
```

These snippets demonstrate how to use signed and unsigned variables in Verilog with considerations for randomization.","
class signedVars;
  rand byte pkt1_len, pkt2_len;
  constraint total_len {
    pkt1_len + pkt2_len == 64;
  }
endclass


class Vars32;
  rand bit [31:0] pkt1_len, pkt2_len; // unsigned type
  constraint total_len {
    pkt1_len + pkt2_len == 64;
  }
endclass


class Vars8;
  rand bit [7:0] pkt1_len, pkt2_len; // 8-bits wide
  constraint total_len {
    pkt1_len + pkt2_len == 9'd64; // 9-bit sum
  }
endclass
","""Verilog code examples demonstrating the use of signed and unsigned variables in randomization and constraints to achieve a specific sum.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p162.jpg,True,"The image contains a segment of Verilog code. Here is the code as displayed in the image:

```verilog
module fsm (get_data, reset_, clk, rd, rd_addr, data, done_frame, latch_en, sipo_en, dp1_en, dp2_en, dp3_en, dp4_en, wr);

input get_data;
input reset_;
input clk;
input [7:0] data;

output rd;
output logic sipo_en, latch_en;
output logic dp1_en, dp2_en, dp3_en, dp4_en, wr;
output logic done_frame;
output [17:0] rd_addr;

logic [5:0] addr_cnt;
logic [11:0] blk_cnt;
logic [3:0] pipeline_cnt;
logic rd;
logic [17:0] rd_addr;
logic enable_cnt, enable_dly_cnt, enable_blk_cnt;

assign done_frame = (blk_cnt == 4095);
assign sipo_en = rd;

enum bit[15:0] {IDLE = 16'd1,
                GEN_BLK_ADDR = 16'd2,
                DLY = 16'd4,
                NEXT_BLK = 16'd8,
                WAIT0 = 16'd16,
                CNT1 = 16'd32,
                WAIT1 = 16'd64,
                CNT2 = 16'd128,
                WAIT2 = 16'd256,
                CNT3 = 16'd512,
                WAIT3 = 16'd1024,
                CNT4 = 16'd2048,
                WAIT4 = 16'd4096,
                CNT5 = 16'd8192,
                WAIT5 = 16'd16384,
                CNT6 = 16'd32768} n_state, c_state;
```

Please note that this is not the complete code, but rather a snippet extracted from what is visible in the image. Some context and additional code necessary for full functionality might be missing.","
module fsm (get_data, reset_, clk, rd, rd_addr, data, done_frame, latch_en, sipo_en, dp1_en, dp2_en, dp3_en, dp4_en, wr);

input get_data;
input reset_;
input clk;
input [7:0] data;

output rd;
output logic sipo_en, latch_en;
output logic dp1_en, dp2_en, dp3_en, dp4_en, wr;
output logic done_frame;
output [17:0] rd_addr;

logic [5:0] addr_cnt;
logic [11:0] blk_cnt;
logic [3:0] pipeline_cnt;
logic rd;
logic [17:0] rd_addr;
logic enable_cnt, enable_dly_cnt, enable_blk_cnt;

assign done_frame = (blk_cnt == 4095);
assign sipo_en = rd;

enum bit[15:0] {IDLE = 16'd1,
                GEN_BLK_ADDR = 16'd2,
                DLY = 16'd4,
                NEXT_BLK = 16'd8,
                WAIT0 = 16'd16,
                CNT1 = 16'd32,
                WAIT1 = 16'd64,
                CNT2 = 16'd128,
                WAIT2 = 16'd256,
                CNT3 = 16'd512,
                WAIT3 = 16'd1024,
                CNT4 = 16'd2048,
                WAIT4 = 16'd4096,
                CNT5 = 16'd8192,
                WAIT5 = 16'd16384,
                CNT6 = 16'd32768} n_state, c_state;
",Example of a Finite State Machine (FSM) in Verilog.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p528.jpg,True,"```c
PLIbook_NetData_p net_data;
int i;

acc_initialize();
acc_configure(accDisplayWarnings, ""true"");

net_data = (PLIbook_NetData_p)tf_getworkarea();

io_printf(""\nAt time %s, nets in module %s (%s):\n"",
          tf_strgettime(),
          acc_fetch_fullname(net_data->module_h),
          acc_fetch_defname(net_data->module_h));
for (i=0; i<net_data->net_count; i++) {
    io_printf("" %-13s value is %s (hex)\n"",
              acc_fetch_name(net_data->net_array[i]),
              acc_fetch_value(net_data->net_array[i], ""%h"", null));
}
acc_close();
return(0);
}
```

The image contains a snippet of code that appears to be written in the C programming language as part of Verilog PLI (Programming Language Interface) functions. The code makes use of the ACC (access) routines from the Verilog PLI library to print out information about nets within a Verilog module. It includes functions for initialization, configuration, getting the working area, printing formatted data, fetching names and values, and closing the ACC routines.","ok_NetData_p net_data;
int i;

acc_initialize();
acc_configure(accDisplayWarnings, ""true"");

net_data = (PLIbook_NetData_p)tf_getworkarea();

io_printf(""\nAt time %s, nets in module %s (%s):\n"",
          tf_strgettime(),
          acc_fetch_fullname(net_data->module_h),
          acc_fetch_defname(net_data->module_h));
for (i=0; i<net_data->net_count; i++) {
    io_printf("" %-13s value is %s (hex)\n"",
              acc_fetch_name(net_data->net_array[i]),
              acc_fetch_value(net_data->net_array[i], ""%h"", null));
}
acc_close();
return(0);
}
","""Excerpt from 'The Verilog PLI Handbook' showing Verilog code using ACC routines to interact with simulation data.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p176.jpg,True,"The image contains two snippets of Verilog code related to specifying properties for an FSM (Finite State Machine) check in formal verification. Here are the code snippets transcribed from the image:

1. For checking FSM2 should always behave as a one-hot state machine:
```verilog
property p_fsm2_encoding;
    @(posedge clk) $onehot(state);
endproperty

a_fsm2_encoding:
    assert property (p_fsm2_encoding);

c_fsm2_encoding:
    cover property (p_fsm2_encoding);
```

2. For checking that from IDLE state the FSM cannot go to IDLE1, IDLE2, or IDLE3 states:
```verilog
property p_forbid_trans1;
    @(posedge clk)
        (( (state == IDLE1) || (state == IDLE2) || (state == IDLE3) ) && reset) |-> 
            $past ( (state == IDLE) == 0);
endproperty

a_forbid_trans1:
    assert property (p_forbid_trans1);
```

These properties are used within a formal verification environment to create assertions and coverage points ensuring that certain conditions hold for the behavior of FSM2.","
property p_fsm2_encoding;
    @(posedge clk) $onehot(state);
endproperty

a_fsm2_encoding:
    assert property (p_fsm2_encoding);

c_fsm2_encoding:
    cover property (p_fsm2_encoding);


property p_forbid_trans1;
    @(posedge clk)
        (( (state == IDLE1) || (state == IDLE2) || (state == IDLE3) ) && reset) |-> 
            $past ( (state == IDLE) == 0);
endproperty

a_forbid_trans1:
    assert property (p_forbid_trans1);
",Verilog code snippets for verifying FSM (Finite State Machine) properties using SystemVerilog assertions.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p255.jpg,True,"The image contains Verilog code. Here are the code excerpts from the image:

Sample 6.70:

```verilog
initial begin
  bit [15:0] len;
  randcase
    1: len = $urandom_range(0, 2); // 10%: 0, 1, or 2
    8: len = $urandom_range(3, 5); // 80%: 3, 4, or 5
    1: len = $urandom_range(6, 7); // 10%: 6 or 7
  endcase
  
  $display(""len=%0d"", len);
end
```

Sample 6.71:

```verilog
class LenDist;
  rand bit [15:0] len;
  constraint c {len dist { [0:2] := 1, [3:5] := 8, [6:7] := 1; } }
endclass

initial begin
  LenDist lenD;
  lenD = new();
  `SV_RAND_CHECK(lenD.randomize());
  $display(""len=%0d"", lenD.len);
end
```

These code snippets demonstrate the use of randomization in Verilog to create random control flows and variable lengths.","
initial begin
  bit [15:0] len;
  randcase
    1: len = $urandom_range(0, 2); // 10%: 0, 1, or 2
    8: len = $urandom_range(3, 5); // 80%: 3, 4, or 5
    1: len = $urandom_range(6, 7); // 10%: 6 or 7
  endcase
  
  $display(""len=%0d"", len);
end


class LenDist;
  rand bit [15:0] len;
  constraint c {len dist { [0:2] := 1, [3:5] := 8, [6:7] := 1; } }
endclass

initial begin
  LenDist lenD;
  lenD = new();
  `SV_RAND_CHECK(lenD.randomize());
  $display(""len=%0d"", lenD.len);
end
","Caption: ""Verilog code snippet demonstrating the use of random control with 'randcase' and '$urandom_range' functions to generate weighted random choices in SystemVerilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p259.jpg,True,"The image contains a block of Verilog code. Here it is:

```verilog
property strong_next_occurrence(e, property p);
    e[->1] #-# p;
endproperty
```

Additionally, there is another assertion using Verilog below the property definition:

```verilog
assert property (a ##1 b[->1] |=> c);
```","
property strong_next_occurrence(e, property p);
    e[->1] #-# p;
endproperty


assert property (a ##1 b[->1] |=> c);
","""Understanding Next Occurrence in SystemVerilog Assertions with Timing Diagram and Code Example""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p86.jpg,True,"The image contains sample Verilog code from a book or document. Here is the code as it appears in the image:

```verilog
// Declare and initialize associative array with 7 elements
int aa[int] = '{0:1, 5:2, 10:4, 15:8, 20:16, 25:32, 30:64};
int idx, element, count;

element = $urandom_range(aa.size()-1);
foreach(aa[i])
    if (count++ == element) begin
        idx = i;                // Save the associative array index
        break;                  // and quit
    end

$display(""element#%0d aa[%0d] = %0d"",
           element, idx, aa[idx]);
```

And another code excerpt is:

```verilog
int f[6] = '{1,6,2,6,8,6};        // Fixed-size array
int d[] = '{2,4,6,8,10};          // Dynamic array
int q[$] = '{1,3,5,7};            // Queue
q[$] tq;                          // Temporary queue for result

tq = q.min();                     // {1}
tq = d.max();                     // {10}
tq = f.unique();                  // {1,6,2,8}
```

These snippets demonstrate how to pick a random element from an associative array and use array locator methods such as `min`, `max`, and `unique` in SystemVerilog. The comments provide additional context for what each part of the code is intended to do.","
// Declare and initialize associative array with 7 elements
int aa[int] = '{0:1, 5:2, 10:4, 15:8, 20:16, 25:32, 30:64};
int idx, element, count;

element = $urandom_range(aa.size()-1);
foreach(aa[i])
    if (count++ == element) begin
        idx = i;                // Save the associative array index
        break;                  // and quit
    end

$display(""element#%0d aa[%0d] = %0d"",
           element, idx, aa[idx]);


int f[6] = '{1,6,2,6,8,6};        // Fixed-size array
int d[] = '{2,4,6,8,10};          // Dynamic array
int q[$] = '{1,3,5,7};            // Queue
q[$] tq;                          // Temporary queue for result

tq = q.min();                     // {1}
tq = d.max();                     // {10}
tq = f.unique();                  // {1,6,2,8}
","""Excerpt from a textbook showing examples of Verilog code, focusing on picking a random element from an associative array and explaining array locator methods such as min, max, and unique.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p189.jpg,True,"The image includes a mathematical definition of an 8x8 matrix for the Walsh-Hadamard Transform (WHT) algorithm, but it does not contain any Verilog code. The matrix given is as follows:

```
WHT[8][8] =
{
  {1, 1, 1, 1, 1, 1, 1, 1},
  {1, 1, 1, 1,-1,-1,-1,-1},
  {1, 1,-1,-1, 1, 1,-1,-1},
  {1, 1,-1,-1,-1,-1, 1, 1},
  {1,-1, 1,-1, 1,-1, 1,-1},
  {1,-1, 1,-1,-1, 1,-1, 1},
  {1,-1,-1, 1,-1, 1, 1,-1},
  {1,-1,-1, 1, 1,-1,-1, 1}
}
```

This matrix represents the values used in the WHT operation, wherein each element is either +1 or -1. The document seems to be discussing the verification of an arithmetic unit that involves the WHT as part of a larger system, likely in the context of digital signal processing. However, as stated, this isn't Verilog code, but it might be related to the theoretical or design aspect of a Verilog implementation.","[8] =
{
  {1, 1, 1, 1, 1, 1, 1, 1},
  {1, 1, 1, 1,-1,-1,-1,-1},
  {1, 1,-1,-1, 1, 1,-1,-1},
  {1, 1,-1,-1,-1,-1, 1, 1},
  {1,-1, 1,-1, 1,-1, 1,-1},
  {1,-1, 1,-1,-1, 1,-1, 1},
  {1,-1,-1, 1,-1, 1, 1,-1},
  {1,-1,-1, 1, 1,-1,-1, 1}
}
","""Excerpt from a document on Verilog for data intensive designs, featuring a waveform diagram for a multiplier checker and a section about the Walsh-Hadamard Transform (WHT) for an arithmetic unit.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p359.jpg,True,"Here is the Verilog code from the image:

```verilog
module FourFlopsStruct #(parameter DClk = 2, DBuf = 1)
                        (output[3:0] Q, input[3:0] D, input Ena, Clk);

    wire[3:0] QWire;
    //
    DFF #( .DClk(DClk)) DReg[0:3]( .Q(QWire) , .D(D) , .Clk(Clk)) ;
    assign #DBuf Q = (Ena=='b1) ? QWire : 'bz;
endmodule // FourFlopsStruct.
//-------------------------------------------
module DFF #(parameter DClk = 2) (output Q, input D, Clk);
    reg QReg;
    always @(posedge Clk) QReg <= D;
    assign #DClk Q = QReg;
endmodule // DFF.
```

```verilog
module FourFlopsStructL #(parameter DClk = 2, DBuf = 1)
                         (output[3:0] Q, input[3:0] D, input Ena, Clk);

    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    //
    DFF DReg[3:0] ( .Q(QWire), .D(D) , .Clk(Clk)) ;
    assign #(DTot Q = (Ena=='b1) ? QWire : 'bz;
endmodule // FourFlopsStructL.
//-------------------------------------------
module DFF(output Q, input D, Clk);
    reg QReg;
    always @(posedge Clk) QReg <= D;
    assign Q = QReg;
endmodule // DFF.
```

Please note that there's a minor typo near the end of the second `FourFlopsStructL` module, where there's a missing parenthesis in the assign statement. It should likely be:

```verilog
assign #(DTot) Q = (Ena=='b1) ? QWire : 'bz;
```","
module FourFlopsStruct #(parameter DClk = 2, DBuf = 1)
                        (output[3:0] Q, input[3:0] D, input Ena, Clk);

    wire[3:0] QWire;
    //
    DFF #( .DClk(DClk)) DReg[0:3]( .Q(QWire) , .D(D) , .Clk(Clk)) ;
    assign #DBuf Q = (Ena=='b1) ? QWire : 'bz;
endmodule // FourFlopsStruct.
//-------------------------------------------
module DFF #(parameter DClk = 2) (output Q, input D, Clk);
    reg QReg;
    always @(posedge Clk) QReg <= D;
    assign #DClk Q = QReg;
endmodule // DFF.


module FourFlopsStructL #(parameter DClk = 2, DBuf = 1)
                         (output[3:0] Q, input[3:0] D, input Ena, Clk);

    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    //
    DFF DReg[3:0] ( .Q(QWire), .D(D) , .Clk(Clk)) ;
    assign #(DTot Q = (Ena=='b1) ? QWire : 'bz;
endmodule // FourFlopsStructL.
//-------------------------------------------
module DFF(output Q, input D, Clk);
    reg QReg;
    always @(posedge Clk) QReg <= D;
    assign Q = QReg;
endmodule // DFF.


assign #(DTot) Q = (Ena=='b1) ? QWire : 'bz;
","""Verilog code snippets demonstrating structs with delay parameters and a discussion on distributed and lumped delay models in digital design.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p88.jpg,True,"The image contains a snippet of Verilog code. Here it is written out for you:

```verilog
function bit check3bits (bit [2:0] expr, value);
    a2: assert #0 (expr > value) else
        $error(""a2 failure: expr = %b, value = %b"", expr, value);
    return (expr > value);
endfunction : check3bits

assign combined = v && check3bits(x, 3'b1);
```

The text explains certain behaviors in Verilog code, referencing the use of `always_comb` and the effects of short-circuiting in deferred assertions, specifically in relation to the code provided.","
function bit check3bits (bit [2:0] expr, value);
    a2: assert #0 (expr > value) else
        $error(""a2 failure: expr = %b, value = %b"", expr, value);
    return (expr > value);
endfunction : check3bits

assign combined = v && check3bits(x, 3'b1);
","Caption: ""Exploration of short-circuiting effects in deferred assertions within Verilog functions and assignment statements.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p79.jpg,True,"```verilog
int dyn[], d2[]; // Declare dynamic arrays

initial begin
    dyn = new[5];    // A: Allocate 5 elements
    foreach (dyn[i]) dyn[i] = i; // B: Initialize the elements
    d2 = dyn;        // C: Copy a dynamic array
    d2[0] = 5;       // D: Modify the copy
    $display(dyn[0],d2[0]); // E: See both values (0 & 5)
    dyn = new[20](dyn); // F: Allocate 20 ints & copy
    dyn = new[100];     // G: Allocate 100 new ints
                        // Old values are lost
    dyn.delete();       // H: Delete all elements
end
```","
int dyn[], d2[]; // Declare dynamic arrays

initial begin
    dyn = new[5];    // A: Allocate 5 elements
    foreach (dyn[i]) dyn[i] = i; // B: Initialize the elements
    d2 = dyn;        // C: Copy a dynamic array
    d2[0] = 5;       // D: Modify the copy
    $display(dyn[0],d2[0]); // E: See both values (0 & 5)
    dyn = new[20](dyn); // F: Allocate 20 ints & copy
    dyn = new[100];     // G: Allocate 100 new ints
                        // Old values are lost
    dyn.delete();       // H: Delete all elements
end
","""An excerpt from a textbook explaining and demonstrating the use of dynamic arrays in SystemVerilog, with sample code illustrating the allocation and manipulation of dynamic arrays.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p282.jpg,True,"The image contains two snippets of Verilog code.

Here's the first code snippet:

```verilog
initial begin
    check_trans(tr0);         // thread 0
    fork
        begin : threads_inner
            check_trans(tr1); // thread 1
            check_trans(tr2); // thread 2
            check_trans(tr3); // thread 3
        end

        // Stop threads 2 & 3, but leave 0 alone
        #(TIME_OUT/10) disable threads_inner;
    join
end
```

And the second code snippet is as follows:

```verilog
task wait_for_time_out(input int id);
    if (id == 0)
        fork
            begin
                #2ns;
                $display(""%0t: disable wait_for_time_out"", $time);
                disable wait_for_time_out;
            end
        join_none

    fork : just_a_little
        begin
            $display(""%0t: %m: %0d entering thread"", $time, id);
            #TIME_OUT;
            $display(""%0t: %m: %0d done"", $time, id);
        end
    join_none
endtask
```

These examples illustrate how to use the `disable` keyword in Verilog for disabling threads and tasks.","
initial begin
    check_trans(tr0);         // thread 0
    fork
        begin : threads_inner
            check_trans(tr1); // thread 1
            check_trans(tr2); // thread 2
            check_trans(tr3); // thread 3
        end

        // Stop threads 2 & 3, but leave 0 alone
        #(TIME_OUT/10) disable threads_inner;
    join
end


task wait_for_time_out(input int id);
    if (id == 0)
        fork
            begin
                #2ns;
                $display(""%0t: disable wait_for_time_out"", $time);
                disable wait_for_time_out;
            end
        join_none

    fork : just_a_little
        begin
            $display(""%0t: %m: %0d entering thread"", $time, id);
            #TIME_OUT;
            $display(""%0t: %m: %0d done"", $time, id);
        end
    join_none
endtask
","""Verilog code examples demonstrating how to use the 'disable' label to stop threads and tasks within a simulation environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p88.jpg,True,"The image contains text but no actual code from a programming language. Here is the text pertaining to built-in system functions in Verilog:

```
1.28 Built-in system functions

SVA provides several built-in functions to check for some of the most common design conditions.

$onehot(expression) – checks that the expression is one-hot, in other words, only one bit of the expression can be high on any given clock edge.

$onehot0(expression) – checks that the expression is zero one-hot, in other words, only one bit of the expression can be high or none of the bits can be high on any given clock edge.
```

Please note that these are descriptions of built-in system functions in SystemVerilog Assertions (SVA), and not the actual code implementing these functions.","uilt-in system functions

SVA provides several built-in functions to check for some of the most common design conditions.

$onehot(expression) – checks that the expression is one-hot, in other words, only one bit of the expression can be high on any given clock edge.

$onehot0(expression) – checks that the expression is zero one-hot, in other words, only one bit of the expression can be high or none of the bits can be high on any given clock edge.
","Waveform analysis of SystemVerilog Assertions (SVA) using ""within"" construct, demonstrating successful and incomplete checks.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p81.jpg,True,"The image contains Verilog code. Here is the text from the image:

```verilog
always@(posedge ShiftClock)
begin
    Qreg[0] <= Din;
    Qreg[1] <= Qreg[0];
    Qreg[2] <= Qreg[1];
    Qreg[3] <= Qreg[2];
    Qreg[4] <= Qreg[3];
end

always@(posedge ShiftClock)
begin
    Qreg[0] <= (ShiftEna=='b1)? Din : Qreg[0];
    Qreg[1] <= (ShiftEna=='b1)? Qreg[0] : Qreg[1];
    Qreg[2] <= (ShiftEna=='b1)? Qreg[1] : Qreg[2];
    Qreg[3] <= (ShiftEna=='b1)? Qreg[2] : Qreg[3];
    Qreg[4] <= (ShiftEna=='b1)? Qreg[3] : Qreg[4];
end
```

The Verilog code shown implements a shift register with a parallel load feature, as described in the text accompanying the image. The first block of code is a procedural model for serial-load shift operation, and the second block of code shows the use of conditional expressions to handle the case of enabling the shift operation.","
always@(posedge ShiftClock)
begin
    Qreg[0] <= Din;
    Qreg[1] <= Qreg[0];
    Qreg[2] <= Qreg[1];
    Qreg[3] <= Qreg[2];
    Qreg[4] <= Qreg[3];
end

always@(posedge ShiftClock)
begin
    Qreg[0] <= (ShiftEna=='b1)? Din : Qreg[0];
    Qreg[1] <= (ShiftEna=='b1)? Qreg[0] : Qreg[1];
    Qreg[2] <= (ShiftEna=='b1)? Qreg[1] : Qreg[2];
    Qreg[3] <= (ShiftEna=='b1)? Qreg[2] : Qreg[3];
    Qreg[4] <= (ShiftEna=='b1)? Qreg[3] : Qreg[4];
end
","""Diagram and Verilog code for a shift register with parallel load capability.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p138.jpg,True,"Here are the fragments of code visible in the image:

```verilog
module Top(...);
    case(...)
    if(...)
    dff_f3_o(q0,q1,q2,..);
```

```verilog
module dff_f3(...);
wire [0:3] q; reg [0:3] q;
always @(posedge clk)
    if(reset)
        q <= 0;
    else if(s_scan)
        q <= d;
```

Please note that these code snippets are incomplete and out of context, as they are part of a discussion on RTL formal verification in a document or book. The text explains the process of hierarchical-to-flat name mapping in equivalence checking but does not provide full code examples.","
module Top(...);
    case(...)
    if(...)
    dff_f3_o(q0,q1,q2,..);


module dff_f3(...);
wire [0:3] q; reg [0:3] q;
always @(posedge clk)
    if(reset)
        q <= 0;
    else if(s_scan)
        q <= d;
","""Exploration of Hierarchical-to-Flat Name Mapping in Verilog for RTL Formal Verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p365.jpg,True,"```
specify
    (clk *> q1, q2) = t_clkrTog; // Delay when q1 | q2 goes opposite clk.
    (clk +*> q1, q2) = t_clkReg;  // Delay when q1 | q2 goes same way as clk.
endspecify
```","y
    (clk *> q1, q2) = t_clkrTog; // Delay when q1 | q2 goes opposite clk.
    (clk +*> q1, q2) = t_clkReg;  // Delay when q1 | q2 goes same way as clk.
endspecify
","Caption: ""Text excerpt discussing Verilog specify blocks and delay assignments used in switch-level modeling with example code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p296.jpg,True,"```verilog
// Consumer thread
repeat(4) begin
    int j;
    #1ns mbx.get(j);
    $display(""Consumer: after get(%0d)"", j);
end
join
end
endprogram
```","
// Consumer thread
repeat(4) begin
    int j;
    #1ns mbx.get(j);
    $display(""Consumer: after get(%0d)"", j);
end
join
end
endprogram
","Caption: ""Example of a consumer thread in Verilog using a mailbox to receive messages, demonstrating inter-thread communication in a simulation environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p402.jpg,True,"The image includes a section of text regarding Verilog code with an example of a wrapper module for portability. The verbatim code from the image is as follows:

```verilog
// ------------------------------------------------
// This wrapper renames the MyModule ports as required:
module MyModule (output[31:0] DataBus
                 ...
                 , input Clock
                );
    MyModule_WrapperU1 ( .OutBus(DataBus), ...  // (I-to-I wiring)
                         , .ClockIn(Clock) );
endmodule
// ------------------------------------------------
// Begin original MyModule design (notice the underscore in the name):
// ------------------------------------------------
module MyModule_ (output[31:0] OutBus, ..., input ClockIn);
    ... (valuable, tested functionality) ...
endmodule
```

The ellipsis (`...`) signifies that some code has been omitted for brevity.","
// ------------------------------------------------
// This wrapper renames the MyModule ports as required:
module MyModule (output[31:0] DataBus
                 ...
                 , input Clock
                );
    MyModule_WrapperU1 ( .OutBus(DataBus), ...  // (I-to-I wiring)
                         , .ClockIn(Clock) );
endmodule
// ------------------------------------------------
// Begin original MyModule design (notice the underscore in the name):
// ------------------------------------------------
module MyModule_ (output[31:0] OutBus, ..., input ClockIn);
    ... (valuable, tested functionality) ...
endmodule
","Caption: ""An example of using a Verilog wrapper module for portability and interfacing.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p80.jpg,True,"Here's the Verilog code that appears in the image:

```verilog
always@(sel, in1, in2)
  if (sel=='b0)
    outbit = in1;
  else outbit = in2;

assign outbitWire = (sel=='b0') ? in1 : in2;
```","
always@(sel, in1, in2)
  if (sel=='b0)
    outbit = in1;
  else outbit = in2;

assign outbitWire = (sel=='b0') ? in1 : in2;
","""Excerpt from a digital VLSI design textbook showing a multiplexer (mux) schematic with example Verilog code for a 2-input mux.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p297.jpg,True,"The image contains Verilog code, which is as follows:

```verilog
program automatic unsynchronized;

mailbox #(int) mbx;

class Producer;
    task run();
        for (int i=1; i<4; i++) begin
            $display(""Producer: before put(%0d)"", i);
            mbx.put(i);
        end
    endtask
endclass

class Consumer;
    task run();
        int i;
        repeat (3) begin
            mbx.get(i);  // Get integer from mbx
            $display(""Consumer: after get(%0d)"", i);
        end
    endtask
endclass

Producer p;
Consumer c;

initial begin
    // Construct mailbox, producer, consumer
    mbx = new();    // Unbounded
    p = new();
    c = new();

    // Run the producer and consumer in parallel
    fork
        p.run();
        c.run();
    join
end
endprogram
```

The text explains that this is an example of a producer-consumer interaction where the producer puts integers into a mailbox, and the consumer retrieves them. However, there is no explicit synchronization between the producer and consumer in this example.","
program automatic unsynchronized;

mailbox #(int) mbx;

class Producer;
    task run();
        for (int i=1; i<4; i++) begin
            $display(""Producer: before put(%0d)"", i);
            mbx.put(i);
        end
    endtask
endclass

class Consumer;
    task run();
        int i;
        repeat (3) begin
            mbx.get(i);  // Get integer from mbx
            $display(""Consumer: after get(%0d)"", i);
        end
    endtask
endclass

Producer p;
Consumer c;

initial begin
    // Construct mailbox, producer, consumer
    mbx = new();    // Unbounded
    p = new();
    c = new();

    // Run the producer and consumer in parallel
    fork
        p.run();
        c.run();
    join
end
endprogram
","""Example of unsynchronized producer-consumer implementation in Verilog using a mailbox.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p364.jpg,True,"The image contains snippets of Verilog code. Here are the extracts of the code from the image:

```verilog
// output[3:0] Z, input[3:0] A, input Clk, Clear are declared ports.
...
specify
    specparam ClkR=2, ClkF=3, ClearRF=1, ΔThruR=4, ΔThruF=5;
    // 
    if ((Clk && !Clear) (A => Z))
        = (ΔThruR, ΔThruF);
    if (A[0] && A[3]) (A[1], A[2] *> Z)
        = ΔThruR; // Lists are OK
    if (A[1] && & A[2]) (A[0], A[3] *> Z)
        = ΔThruF;
    if (!Clear)
        (negedge Clk *> Z) = ClearRF;
    if (!(1:Clear))
        (posedge Clk *> Z) = (ClkR, ClkF);
        (posedge Clear *> Z) = ClearRF;
endspecify

specify
    if (!(1:Clr) (posedge Clk *> Q_On) = (3, 4);
    if (Clr)
        (A, B *> Qn) = (5, 5);
    ...
    ifnone (A, B *> Qn) = (1, 2); // For Clr asserted.
endspecify

...
specify
    specparam tR_Q = 5, tF_Q = 6.5;
    ...
    (posedge Clk => (Q1 +:D) ) = (tR_Q, tF_Q);
    (posedge Clk => (Q2 -:D) ) = (tR_Q, tF_Q);
endspecify
```

Please note that in some places Greek letters like ""Delta"" (Δ) are used, for these I've used the symbol Δ to represent it in the transcription. Symbols like `*>` and `+:` or `-:` are Verilog operators. The character sequences depicting timing, such as `(3, 4);` and `(5, 5);` represent rise and fall delays respectively. 

This code is part of a `specify` block, which is used in Verilog to specify path delays for timing analysis.","
// output[3:0] Z, input[3:0] A, input Clk, Clear are declared ports.
...
specify
    specparam ClkR=2, ClkF=3, ClearRF=1, ΔThruR=4, ΔThruF=5;
    // 
    if ((Clk && !Clear) (A => Z))
        = (ΔThruR, ΔThruF);
    if (A[0] && A[3]) (A[1], A[2] *> Z)
        = ΔThruR; // Lists are OK
    if (A[1] && & A[2]) (A[0], A[3] *> Z)
        = ΔThruF;
    if (!Clear)
        (negedge Clk *> Z) = ClearRF;
    if (!(1:Clear))
        (posedge Clk *> Z) = (ClkR, ClkF);
        (posedge Clear *> Z) = ClearRF;
endspecify

specify
    if (!(1:Clr) (posedge Clk *> Q_On) = (3, 4);
    if (Clr)
        (A, B *> Qn) = (5, 5);
    ...
    ifnone (A, B *> Qn) = (1, 2); // For Clr asserted.
endspecify

...
specify
    specparam tR_Q = 5, tF_Q = 6.5;
    ...
    (posedge Clk => (Q1 +:D) ) = (tR_Q, tF_Q);
    (posedge Clk => (Q2 -:D) ) = (tR_Q, tF_Q);
endspecify
","Caption: ""An excerpt from a digital VLSI design textbook showing examples of Verilog specify blocks for timing specification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p298.jpg,True,"The image contains a snippet of Verilog code. Here is the code:

```verilog
always @(posedge clock)
    result <= $pow(x,y);
``` 

This example shows the usage of a PLI (Programming Language Interface) routine within a Verilog `always` block, where the function `$pow(x,y)` is presumably a user-defined PLI routine that calculates x raised to the power of y.","
always @(posedge clock)
    result <= $pow(x,y);
","Caption: Excerpt from ""The Verilog PLI Handbook"" describing how PLI applications work in Verilog, including an example of invoking a user-defined PLI routine within a Verilog code block.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p283.jpg,True,"```verilog
initial begin
    wait_for_time_out(0); // Spawn thread 0
    wait_for_time_out(1); // Spawn thread 1
    wait_for_time_out(2); // Spawn thread 2
    #(`TIME_OUT*2) $display(""%0t: All done"", $time);
end
```","
initial begin
    wait_for_time_out(0); // Spawn thread 0
    wait_for_time_out(1); // Spawn thread 1
    wait_for_time_out(2); // Spawn thread 2
    #(`TIME_OUT*2) $display(""%0t: All done"", $time);
end
","Caption: ""Understanding Threads and Interprocess Communication in SystemVerilog with a code snippet and theoretical explanation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p89.jpg,True,"The image contains Verilog code that defines several `assert` statements using SystemVerilog Assertions (SVA). The provided code is as follows:

```verilog
a33a: assert
  property(@(posedge clk) $onehot(state));
a33b: assert
  property(@(posedge clk) $onehot0(state));
a33c: assert
  property(@(posedge clk) $isunknown(bus));
a33d: assert
  property(@(posedge clk) $countones(bus) > 1);
```","
a33a: assert
  property(@(posedge clk) $onehot(state));
a33b: assert
  property(@(posedge clk) $onehot0(state));
a33c: assert
  property(@(posedge clk) $isunknown(bus));
a33d: assert
  property(@(posedge clk) $countones(bus) > 1);
","Caption: ""Example of SystemVerilog Assertions (SVA) for checking one-hot encoding and signal integrity using built-in functions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p416.jpg,True,"The image contains some text related to Verilog coding instructions, but there is no complete block of code provided. However, there is a partial code snippet shown:

```verilog
always@(negedge SerClock, posedge Reset)
begin
  Shift1;
  Decode4;
  Unload32;
end
```

This snippet is an example of an `always` block in Verilog, which is sensitive to the negative edge of a signal `SerClock` and the positive edge of a signal `Reset`. Within the block, the procedural tasks `Shift1`, `Decode4`, and `Unload32` are called in sequence.","
always@(negedge SerClock, posedge Reset)
begin
  Shift1;
  Decode4;
  Unload32;
end
","The image shows a textbook page discussing modifications and best practices in Verilog coding, specifically for the deserialization decoder in digital VLSI design.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p188.jpg,True,"The image contains Verilog code. Here is the code transcribed from the image:

```verilog
input logic sel,
output logic [15:0] d
);

logic [15:0] e;
logic [15:0] sel_h, sel_l;

// Resource sharing architecture

always_comb
begin
    if(sel) e = b; else e = c;
    d = multiply(a, e);
end

// Functional sva checker

always@(a, b, c, sel)
begin
    sel_h = a*b;
    sel_l = a*c;

    if(sel)
        sel_high : assert (sel_h == d);
    if (!sel)
        sel_low : assert (sel_l == d);

end
endmodule
```

Note: The code snippet seems to be a part of a larger codebase or discussion since it ends and begins abruptly. It discusses a resource sharing architecture and includes a functional assertion-based verification component using SystemVerilog assertions (`assert`).","
input logic sel,
output logic [15:0] d
);

logic [15:0] e;
logic [15:0] sel_h, sel_l;

// Resource sharing architecture

always_comb
begin
    if(sel) e = b; else e = c;
    d = multiply(a, e);
end

// Functional sva checker

always@(a, b, c, sel)
begin
    sel_h = a*b;
    sel_l = a*c;

    if(sel)
        sel_high : assert (sel_h == d);
    if (!sel)
        sel_low : assert (sel_l == d);

end
endmodule
","Caption: ""Excerpt from a textbook illustrating Verilog code for a simple conditional multiplier with functional SystemVerilog assertion checkers.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p78.jpg,True,"```verilog
bit [3:0] [7:0] barray [5]; // 5 elements: packed 4-bytes
bit [31:0] lw = 32'h0123_4567; // Word
bit [7:0] [3:0] nibbles; // Packed array of nibbles
barray[0] = lw;
barray[0][3] = 8'h01;
barray[1][6] = 1'b1;
nibbles = barray[2]; // Copy packed values
```","
bit [3:0] [7:0] barray [5]; // 5 elements: packed 4-bytes
bit [31:0] lw = 32'h0123_4567; // Word
bit [7:0] [3:0] nibbles; // Packed array of nibbles
barray[0] = lw;
barray[0][3] = 8'h01;
barray[1][6] = 1'b1;
nibbles = barray[2]; // Copy packed values
","Explanation and illustration of mixed packed and unpacked arrays in Verilog, showcasing memory representation and code for manipulation of array elements.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p89.jpg,True,"The image does contain Verilog code. Here's the code extracted from the image:

```verilog
concurrent_assertion_body ::= 
  [clocking_event] [disable iff (reset)] property

Example 4.4. The following concurrent assertion

a1: assert property (@(posedge clk)
disable iff (rst) a |-> nexttime[2] b);

initial a2: assert property (@(posedge clk) !ready);

a3: assert property (@(posedge clk) ok);

always @(posedge clk) begin
  a4: assert property (d1 |=> i3 | i4);
  dout <= f_ecap(d1);
end
``` 

This text is an excerpt from a book or a document about concurrent assertions in Verilog, explaining the syntax and use of such assertions in Verilog HDL (Hardware Description Language).","
concurrent_assertion_body ::= 
  [clocking_event] [disable iff (reset)] property

Example 4.4. The following concurrent assertion

a1: assert property (@(posedge clk)
disable iff (rst) a |-> nexttime[2] b);

initial a2: assert property (@(posedge clk) !ready);

a3: assert property (@(posedge clk) ok);

always @(posedge clk) begin
  a4: assert property (d1 |=> i3 | i4);
  dout <= f_ecap(d1);
end
","""Understanding Concurrent Assertions in Verilog with Examples""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p358.jpg,True,"The image contains several blocks of Verilog code. Here they are:

First block:
```verilog
module DistributedDelay (output Z, input A, B);
  wire Node;
  assign #1 Z = Node; // Output port delay.
  and #(2,3) (Node, A, B); // Pin delay.
endmodule
//
module LumpedDelay (output Z, input A, B);
  wire Node;
  assign #(3,4) Z = Node; // Total delay lumped on output port.
  and (Node, A, B);
endmodule
```

Second block:
```verilog
`timescale 1ns/100ps
module FourFlopsRTL #(parameter DClk = 2, DBuf = 1)
                     (output[3:0] Q, input[3:0] D, input Ena, Clk);

  reg[3:0] Qreg;
  wire[3:0] Qwire; // Not used yet.
  //
  always@(posedge Clk)
    assign #DClk Qreg <= D;
  //
  assign #DBuf Q = (Ena=='b1) ? Qreg : 'bz;
  //
endmodule
```
","
module DistributedDelay (output Z, input A, B);
  wire Node;
  assign #1 Z = Node; // Output port delay.
  and #(2,3) (Node, A, B); // Pin delay.
endmodule
//
module LumpedDelay (output Z, input A, B);
  wire Node;
  assign #(3,4) Z = Node; // Total delay lumped on output port.
  and (Node, A, B);
endmodule


`timescale 1ns/100ps
module FourFlopsRTL #(parameter DClk = 2, DBuf = 1)
                     (output[3:0] Q, input[3:0] D, input Ena, Clk);

  reg[3:0] Qreg;
  wire[3:0] Qwire; // Not used yet.
  //
  always@(posedge Clk)
    assign #DClk Qreg <= D;
  //
  assign #DBuf Q = (Ena=='b1) ? Qreg : 'bz;
  //
endmodule
",A textbook page explaining the concept of distributed versus lumped delays in Verilog with example code for each.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p111.jpg,True,"The image contains examples of Verilog code related to the topics of concatenation and expression simplification. Here is the Verilog code displayed in the image:

For concatenation optimization:
Before:
```
c_b[3:0] = c_b0;
c_b[7:4] = c_b1;
c_b[11:8] = c_b2;
```
After:
```
c_b = {c_b2, c_b1, c_b0};
```
And the example that the Verilog simulator would have to do looks like:
```
c_b = {c_b [11:4], c_b0};
c_b = {c_b[3:0], c_b1, c_b[11:8]};
c_b = {c_b2, c_b[7:0]};
```
For expression simplification optimization:
Before:
```
c_c [7:0] = c_a [7:0];
c_c [15:8] = c_a [15:8];
c_c [23:16] = c_a [23:16];
```
After:
```
c_c = c_a;
```

These code snippets demonstrate optimization techniques in RTL simulation, where the Verilog compiler can simplify code for more efficient simulation performance by minimizing slice and concatenation operations.","0] = c_b0;
c_b[7:4] = c_b1;
c_b[11:8] = c_b2;

{c_b2, c_b1, c_b0};

{c_b [11:4], c_b0};
c_b = {c_b[3:0], c_b1, c_b[11:8]};
c_b = {c_b2, c_b[7:0]};

:0] = c_a [7:0];
c_c [15:8] = c_a [15:8];
c_c [23:16] = c_a [23:16];

c_a;
","""Exploring Verilog Code Optimizations: Concatenation and Expression Simplification""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p43.jpg,True,"The image contains a snippet of Verilog code. Here's the code from the image:

```verilog
module And2 (output z, input A, B);
    assign #1 z = A & B;
endmodule
```

This code defines a simple Verilog module named `And2` which performs a logical AND operation on two inputs `A` and `B`, with a one-time unit delay, and then assigns the result to the output `z`.","
module And2 (output z, input A, B);
    assign #1 z = A & B;
endmodule
","""Introduction to Verilog modules and syntax, featuring an example of a simple AND logic gate module.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p529.jpg,True,"The image contains text and a portion of a function signature in the context of Verilog and the ACC (Application Control Constructs) Routine Library. Here is the function signature presented in the image:

```c
handle acc_handle_object(obj_name)
char *obj_name;  // name of an object.
```

The function `acc_handle_object` appears to be used to obtain a handle to a Verilog object within a given scope. The text describes how it functions in relation to the Verilog PLI (Programming Language Interface).","e acc_handle_object(obj_name)
char *obj_name;  // name of an object.
","The image displays a portion of a textbook that explains the details of the ACC Routine Library in Verilog, including descriptions and usage of the acc_handle_by_name() and acc_handle_object() routines, as well as a table listing objects supported by acc_handle_by_name().",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p258.jpg,True,"The image contains Verilog code, which is a hardware description language used to model electronic systems. Here's the code from the image:

```verilog
a1_redundant: assert property (start_ev |=> strong(next[->2:$]) );

a2: assert property (start_ev |=> strong(next[->2]) );

initial a1: assert property (strong(e[->2]));

initial a2: assert property (e[->2] |=# always !e);

initial a3: assert property (e[->2] |=> always !e);

a1: assert property (en ##0 e[->1] |-> p);

property next_occurrence(e, property p);
e[->1] |-> p;
endproperty

a2: assert property (en |-> next_occurrence(e, p) );
```

These code snippets are examples of SystemVerilog assertions (SVA) used for formally verifying properties of hardware designs. The `assert property` construct is used to create an assertion, which is a statement that checks if a certain property holds during simulation. The operator `|=>` is a non-overlapping implication, and `|->` is an overlapping implication. The `strong` function is used to indicate that the sequence must occur without any gaps. The `next` operator refers to the next occurrence of an event, and `##` specifies a delay. The ""e[->1]"" syntax is a way to indicate one or more occurrences of an event `e`.","
a1_redundant: assert property (start_ev |=> strong(next[->2:$]) );

a2: assert property (start_ev |=> strong(next[->2]) );

initial a1: assert property (strong(e[->2]));

initial a2: assert property (e[->2] |=# always !e);

initial a3: assert property (e[->2] |=> always !e);

a1: assert property (en ##0 e[->1] |-> p);

property next_occurrence(e, property p);
e[->1] |-> p;
endproperty

a2: assert property (en |-> next_occurrence(e, p) );
","""Examples of Verilog Assertions Using Eventuality and Next Occurrence Properties""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p87.jpg,True,"The image contains Verilog code. Here it is:

Sample 2.30 Array locator methods: find

```verilog
int d[] = '{9,1,8,3,4,4}, tq[$];

// Find all elements greater than 3
tq = d.find with (item > 3);      // {9,8,4,4}
// Equivalent code
tq.delete();
foreach (d[i])
    if (d[i] > 3)
        tq.push_back(d[i]);

tq = d.find_index with (item > 3);        // {0,2,4,5}
tq = d.find_first with (item > 99);       // {} - none found
tq = d.find_first_index with (item==8);   // {2} d[2]=8
tq = d.find_last with (item==4);          // {4}
tq = d.find_last_index with (item==4);    // {5} d[5]=4
```

In a with clause, the name `item` is called the iterator argument and represents a single element of the array. You can specify your own name by putting it in the argument list of the array method as shown in Sample 2.31.

Sample 2.31 Declaring the iterator argument

```verilog
tq = d.find_first with (item==4);      // These
tq = d.find_first() with (item==4);    // are
tq = d.find_first(item) with (item==4);  // all
tq = d.find_first(x) with (x==4);        // equivalent
```

Sample 2.32 Array locator methods

```verilog
int count, total, d[] = '{9,1,8,3,4,4};

count = d.sum(x) with (x > 7);         // 2=sum{1,0,1,0,0,0}
total = d.sum(x) with ((x > 7) * x);   // 17=sum{9,0,8,0,0,0}
count = d.sum(x) with (x < 8);         // 4=sum{0,1,0,1,1,1}
total = d.sum(x) with (x < 8 ? x : 0); // 12=sum{0,1,0,3,4,4}
count = d.sum(x) with (x == 4);        // 2=sum{0,0,0,0,1,1}
```

When you combine an array reduction such as sum using the with clause, the results may surprise you. In Sample 2.32, the sum operator totals the number of results.","
int d[] = '{9,1,8,3,4,4}, tq[$];

// Find all elements greater than 3
tq = d.find with (item > 3);      // {9,8,4,4}
// Equivalent code
tq.delete();
foreach (d[i])
    if (d[i] > 3)
        tq.push_back(d[i]);

tq = d.find_index with (item > 3);        // {0,2,4,5}
tq = d.find_first with (item > 99);       // {} - none found
tq = d.find_first_index with (item==8);   // {2} d[2]=8
tq = d.find_last with (item==4);          // {4}
tq = d.find_last_index with (item==4);    // {5} d[5]=4


tq = d.find_first with (item==4);      // These
tq = d.find_first() with (item==4);    // are
tq = d.find_first(item) with (item==4);  // all
tq = d.find_first(x) with (x==4);        // equivalent


int count, total, d[] = '{9,1,8,3,4,4};

count = d.sum(x) with (x > 7);         // 2=sum{1,0,1,0,0,0}
total = d.sum(x) with ((x > 7) * x);   // 17=sum{9,0,8,0,0,0}
count = d.sum(x) with (x < 8);         // 4=sum{0,1,0,1,1,1}
total = d.sum(x) with (x < 8 ? x : 0); // 12=sum{0,1,0,3,4,4}
count = d.sum(x) with (x == 4);        // 2=sum{0,0,0,0,1,1}
","""Verilog Array Methods and Their Usage Examples""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p254.jpg,True,"The image contains Verilog code. Here it is:

```verilog
initial begin
    for (int i=0; i<15; i++) begin
        randsequence (stream)
        stream : cfg_read := 1 | io_read := 2 | mem_read := 5;
        
        cfg_read : { cfg_read_task(); } |
                   { cfg_read_task(); } cfg_read;
                   
        mem_read : { mem_read_task(); } |
                   { mem_read_task(); } mem_read;
                   
        io_read  : { io_read_task(); } |
                   { io_read_task(); } io_read;
        endsequence
    end // for
end
task cfg_read_task();
    ...
endtask
```

This snippet demonstrates the usage of the `randsequence` construct in SystemVerilog for generating a random sequence of tasks, with each task having different probabilities of being selected.","
initial begin
    for (int i=0; i<15; i++) begin
        randsequence (stream)
        stream : cfg_read := 1 | io_read := 2 | mem_read := 5;
        
        cfg_read : { cfg_read_task(); } |
                   { cfg_read_task(); } cfg_read;
                   
        mem_read : { mem_read_task(); } |
                   { mem_read_task(); } mem_read;
                   
        io_read  : { io_read_task(); } |
                   { io_read_task(); } io_read;
        endsequence
    end // for
end
task cfg_read_task();
    ...
endtask
","Caption: ""Example of a command generator using SystemVerilog's randsequence construct for weighted randomization of tasks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p62.jpg,True,"```verilog
module m(input logic a, b, c, output logic o);
    if (a) o = b;
    else o = c;
endmodule : m

module m (input logic a, b, clk);
    clocking mycbkl @(posedge clk);
        property p; a |=> b; endproperty
        a1: assert property (p);
    endclocking
    a2: assert property (p);
endmodule : m
```

The above text shows two snippets of Verilog code related to questions about how to correct illegal code and identifying illegal code in provided snippets.","
module m(input logic a, b, c, output logic o);
    if (a) o = b;
    else o = c;
endmodule : m

module m (input logic a, b, clk);
    clocking mycbkl @(posedge clk);
        property p; a |=> b; endproperty
        a1: assert property (p);
    endclocking
    a2: assert property (p);
endmodule : m
","""Examples of SystemVerilog Code and Questions on its Syntax and Design Elements""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p240.jpg,True,"```verilog
// test.sv
program automatic test;
`include ""packet.sv""
    constraint Packet::c_external {length == 1;}
    ...
endprogram
```

The image contains a snippet of Verilog code, shown above.","
// test.sv
program automatic test;
`include ""packet.sv""
    constraint Packet::c_external {length == 1;}
    ...
endprogram
","""Example of defining an external constraint in Verilog for randomized testing""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p93.jpg,True,"The image contains Verilog and SystemVerilog code examples. Here they are:

Sample 2.37 - User-defined type-macro in Verilog (Old Verilog style)
```verilog
`define OPSIZE 8
`define OPREG reg [`OPSIZE-1:0]
`OPREG op_a, op_b;
```

Sample 2.38 - User-defined type in SystemVerilog (New SystemVerilog style)
```verilog
parameter OPSIZE = 8;
typedef logic [OPSIZE-1:0] opreg_t;
opreg_t op_a, op_b;
```

Sample 2.39 - Definition of uint
```verilog
typedef bit [31:0] uint; // 32-bit unsigned 2-state
typedef int unsigned uint; // Equivalent definition
```

These are the code samples visible in the image.","
`define OPSIZE 8
`define OPREG reg [`OPSIZE-1:0]
`OPREG op_a, op_b;


parameter OPSIZE = 8;
typedef logic [OPSIZE-1:0] opreg_t;
opreg_t op_a, op_b;


typedef bit [31:0] uint; // 32-bit unsigned 2-state
typedef int unsigned uint; // Equivalent definition
","""Examples of Defining New Data Types in Verilog and SystemVerilog using `typedef`""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p163.jpg,True,"The image shows a page from a book or document with Verilog code on it. Here is the code as displayed:

```verilog
// assign the different control signals

assign latch_en = (c_state == CNT1);
assign dp1_en = (c_state == CNT2);
assign dp2_en = (c_state == CNT3);
assign dp3_en = (c_state == CNT4);
assign dp4_en = (c_state == CNT5);
assign wr = (c_state == CNT6);

// 64bit counter to generate read address

always_ff @(posedge clk)
if (!reset_ || !enable_cnt)
    addr_cnt <= 0;
else if (enable_cnt)
    addr_cnt <= addr_cnt + 1;
else
    addr_cnt <= addr_cnt;

// 4096 bit counter

always_ff @(posedge clk)
if (!reset_)
    blk_cnt <= 0;
else if ((c_state == NEXT_BLK) && enable_blk_cnt)
    blk_cnt <= blk_cnt + 1;
else
    blk_cnt <= blk_cnt;

always_ff @(posedge clk)
if (!reset_)
    c_state <= IDLE;
else
    c_state <= n_state;

always @(*)
begin
    rd <= 0;
    enable_cnt <= 0;
    //enable_dly_cnt <= 0;
    case (c_state)
        IDLE: begin
            enable_blk_cnt <= 0;
```

Please note that the code snippet may contain syntax specific to SystemVerilog (indicated by the ""always_ff"" keyword, for example). The code seems to be providing examples of state machine control signal assignments and counter implementations in a hardware description context. However, the image only shows a partial view of the entire code, as the last segment is cut off and would continue onto the next page or later in the document.","
// assign the different control signals

assign latch_en = (c_state == CNT1);
assign dp1_en = (c_state == CNT2);
assign dp2_en = (c_state == CNT3);
assign dp3_en = (c_state == CNT4);
assign dp4_en = (c_state == CNT5);
assign wr = (c_state == CNT6);

// 64bit counter to generate read address

always_ff @(posedge clk)
if (!reset_ || !enable_cnt)
    addr_cnt <= 0;
else if (enable_cnt)
    addr_cnt <= addr_cnt + 1;
else
    addr_cnt <= addr_cnt;

// 4096 bit counter

always_ff @(posedge clk)
if (!reset_)
    blk_cnt <= 0;
else if ((c_state == NEXT_BLK) && enable_blk_cnt)
    blk_cnt <= blk_cnt + 1;
else
    blk_cnt <= blk_cnt;

always_ff @(posedge clk)
if (!reset_)
    c_state <= IDLE;
else
    c_state <= n_state;

always @(*)
begin
    rd <= 0;
    enable_cnt <= 0;
    //enable_dly_cnt <= 0;
    case (c_state)
        IDLE: begin
            enable_blk_cnt <= 0;
","""Verilog code for finite state machine control signals and counter logic.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p57.jpg,True,"The image contains a snippet of Verilog code describing the traditional module header format. Here is the code:

```verilog
module module_name
( names of outputN, inputN, inoutN ); // Port names alone.
output1 width_if_not_1 port_name; // Type, width, and name of port.
output2 width_if_not_1 port_name; // ""    ""    ""    ""    ""
. . .
input1 width_if_not_1 port_name; // ""    ""    ""    ""    ""
input2 width_if_not_1 port_name; // ""    ""    ""    ""    ""
. . .
inout1 width_if_not_1 port_name; // ""    ""    ""    ""    ""
inout2 width_if_not_1 port_name; // ""    ""    ""    ""    ""
. . .
reg width_if_not_1 reg_name; // Could be anywhere in the module.
...
endmodule
```

Please note that `width_if_not_1`, `outputN`, `inputN`, `inoutN`, `port_name`, and `reg_name` are placeholders and should be replaced with actual identifiers and values when writing a real Verilog module.","
module module_name
( names of outputN, inputN, inoutN ); // Port names alone.
output1 width_if_not_1 port_name; // Type, width, and name of port.
output2 width_if_not_1 port_name; // ""    ""    ""    ""    ""
. . .
input1 width_if_not_1 port_name; // ""    ""    ""    ""    ""
input2 width_if_not_1 port_name; // ""    ""    ""    ""    ""
. . .
inout1 width_if_not_1 port_name; // ""    ""    ""    ""    ""
inout2 width_if_not_1 port_name; // ""    ""    ""    ""    ""
. . .
reg width_if_not_1 reg_name; // Could be anywhere in the module.
...
endmodule
",Educational material illustrating traditional and modern Verilog module header formats.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p264.jpg,True,"```verilog
a1: assert property (start_t ##1 (end_t1[-1] and end_t2[-1]) |-> ready);
```","
a1: assert property (start_t ##1 (end_t1[-1] and end_t2[-1]) |-> ready);
",A snapshot from a textbook discussing advanced sequences in Verilog and explaining the difference between sequence conjunction and property conjunction with relevant code examples.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p273.jpg,True,"The image contains a snippet of code that appears to be part of a technical document explaining how to interface to C models using Verilog Procedural Interface (VPI) routines. The code is written in C and pertains to VPI function calls and callback registration in a Verilog simulation environment. Here is the code from the image:

```c
ALUData->b_h = vpi_scan(arg_itr); /* 3rd arg is b input */
ALUData->opcode_h = vpi_scan(arg_itr); /* 4th arg is opcode input */
ALUData->result_h = vpi_scan(arg_itr); /* 5th arg is result output */
ALUData->excep_h = vpi_scan(arg_itr); /* 6th arg is excep output */
ALUData->err_h = vpi_scan(arg_itr); /* 7th arg is error output */
vpi_free_object(arg_itr); /* free iterator--did not scan to null */

/* setup value change callback options */
time_s.type = vpiSuppressTime;
cb_data_s.reason = cbValueChange;
cb_data_s.cb_rtn = PLIbook_ScientificALU_interface;
cb_data_s.time = &time_s;
cb_data_s.value = &value_s;

/* add value change callbacks to all signals which are inputs to */
/* pass pointer to storage for handles as user_data value */
cb_data_s.user_data = (char *)ALUData;
value_s.format = vpiRealVal;
cb_data_s.obj = ALUData->a_h;
vpi_register_cb(&cb_data_s);

cb_data_s.obj = ALUData->b_h;
vpi_register_cb(&cb_data_s);

cb_data_s.obj = ALUData->opcode_h;
value_s.format = vpiIntVal;
vpi_register_cb(&cb_data_s);

cb_data_s.obj = ALUData->enable_h;
vpi_register_cb(&cb_data_s);

return(0);
}
```

The code performs the following tasks:
- Retrieves handles to Verilog signals using `vpi_scan`.
- Sets up callback data structures to monitor value changes on specific signals.
- Registers the callbacks with the `vpi_register_cb` function.
- Returns 0, which typically indicates successful completion of a function in C.

The accompanying text mentions two different techniques for representing propagation delays in a C model:
- Using delays in the PLI interface.
- Using delays in the Verilog shell module.","ta->b_h = vpi_scan(arg_itr); /* 3rd arg is b input */
ALUData->opcode_h = vpi_scan(arg_itr); /* 4th arg is opcode input */
ALUData->result_h = vpi_scan(arg_itr); /* 5th arg is result output */
ALUData->excep_h = vpi_scan(arg_itr); /* 6th arg is excep output */
ALUData->err_h = vpi_scan(arg_itr); /* 7th arg is error output */
vpi_free_object(arg_itr); /* free iterator--did not scan to null */

/* setup value change callback options */
time_s.type = vpiSuppressTime;
cb_data_s.reason = cbValueChange;
cb_data_s.cb_rtn = PLIbook_ScientificALU_interface;
cb_data_s.time = &time_s;
cb_data_s.value = &value_s;

/* add value change callbacks to all signals which are inputs to */
/* pass pointer to storage for handles as user_data value */
cb_data_s.user_data = (char *)ALUData;
value_s.format = vpiRealVal;
cb_data_s.obj = ALUData->a_h;
vpi_register_cb(&cb_data_s);

cb_data_s.obj = ALUData->b_h;
vpi_register_cb(&cb_data_s);

cb_data_s.obj = ALUData->opcode_h;
value_s.format = vpiIntVal;
vpi_register_cb(&cb_data_s);

cb_data_s.obj = ALUData->enable_h;
vpi_register_cb(&cb_data_s);

return(0);
}
","""An excerpt from a technical document showcasing the use of Verilog Procedural Interface (VPI) routines for interfacing Verilog with C models.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p270.jpg,True,"The image contains a snippet of Verilog code. Here is the code written out:

```verilog
sequence ack;
  !rst throughout enable ##[1:10] end_ack;
endsequence
``` 

This code defines a Verilog sequence named `ack` that is checking for a condition involving the signals `!rst`, `enable`, and `end_ack` across a range of time steps.","
sequence ack;
  !rst throughout enable ##[1:10] end_ack;
endsequence
","""Excerpt from a textbook on Advanced Verilog sequences, outlining past temporal operators and demonstrating their properties with code snippets and timing diagrams.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p267.jpg,True,"This image contains code which is related to interfacing to C models using VPI routines in Verilog. Here is the code present in the image:

```verilog
value_s.format = vpiIntVal;
value_s.value.integer = excep;
vpi_put_value(ALUdata->excep_h, &value_s, NULL, vpiNoDelay);

value_s.value.integer = err;
vpi_put_value(ALUdata->err_h, &value_s, NULL, vpiNoDelay);

return(0);
}

/***********************************************************************
 * callback routine: Registers a callback to the C model interface
 * whenever any input to the C model changes value
 ***********************************************************************/
int PLIbook_ScientificALU_calltf(char *user_data)
{
  vpiHandle instance_h, arg_itr;
  s_vpi_value value_s;
  s_vpi_time time_s;
  s_cb_data cb_data_s;
  
  PLIbook_ALU_data_p ALUdata;

  /* allocate storage to hold $scientific_alu argument handles */
  ALUdata = (PLIbook_ALU_data_p)malloc(sizeof(PLIbook_ALU_data_s));

  /* obtain a handle to system task instance */
  instance_h = vpi_handle(vpiSysTfCall, NULL);

  /* obtain handles to system task arguments */
  /* compiler has already verified arguments are correct */
  arg_itr = vpi_iterate(vpiArgument, instance_h);
  ALUdata->a_h       = vpi_scan(arg_itr); /* 1st arg is a input */
  ALUdata->b_h       = vpi_scan(arg_itr); /* 2nd arg is b input */
  ALUdata->opcode_h  = vpi_scan(arg_itr); /* 3rd arg is opcode input */
  ALUdata->result_h  = vpi_scan(arg_itr); /* 4th arg is result output */
  ALUdata->excep_h   = vpi_scan(arg_itr); /* 5th arg is excep output */
  ALUdata->err_h     = vpi_scan(arg_itr); /* 6th arg is error output */
  vpi_free_object(arg_itr);  /* free iterator--did not scan to null */

  /* setup value change callback options */
  time_s.type        = vpiSuppressTime;
  cb_data_s.reason   = cbValueChange;
  cb_data_s.cb_rtn   = PLIbook_ScientificALU_interface;
  cb_data_s.time     = &time_s;
  cb_data_s.value    = &value_s;

  /* add value change callbacks to all signals which are inputs to */
  /* pass pointer to storage for handles as user_data value */
  cb_data_s.user_data = (char *)ALUdata;
  value_s.format = vpiRealVal;
  cb_data_s.obj = ALUdata->a_h;
  vpi_register_cb(&cb_data_s);
```

Please note that the image shows only a part of a larger code and that it contains functions and comments describing the operations related to the Verilog Procedural Interface (VPI).","
value_s.format = vpiIntVal;
value_s.value.integer = excep;
vpi_put_value(ALUdata->excep_h, &value_s, NULL, vpiNoDelay);

value_s.value.integer = err;
vpi_put_value(ALUdata->err_h, &value_s, NULL, vpiNoDelay);

return(0);
}

/***********************************************************************
 * callback routine: Registers a callback to the C model interface
 * whenever any input to the C model changes value
 ***********************************************************************/
int PLIbook_ScientificALU_calltf(char *user_data)
{
  vpiHandle instance_h, arg_itr;
  s_vpi_value value_s;
  s_vpi_time time_s;
  s_cb_data cb_data_s;
  
  PLIbook_ALU_data_p ALUdata;

  /* allocate storage to hold $scientific_alu argument handles */
  ALUdata = (PLIbook_ALU_data_p)malloc(sizeof(PLIbook_ALU_data_s));

  /* obtain a handle to system task instance */
  instance_h = vpi_handle(vpiSysTfCall, NULL);

  /* obtain handles to system task arguments */
  /* compiler has already verified arguments are correct */
  arg_itr = vpi_iterate(vpiArgument, instance_h);
  ALUdata->a_h       = vpi_scan(arg_itr); /* 1st arg is a input */
  ALUdata->b_h       = vpi_scan(arg_itr); /* 2nd arg is b input */
  ALUdata->opcode_h  = vpi_scan(arg_itr); /* 3rd arg is opcode input */
  ALUdata->result_h  = vpi_scan(arg_itr); /* 4th arg is result output */
  ALUdata->excep_h   = vpi_scan(arg_itr); /* 5th arg is excep output */
  ALUdata->err_h     = vpi_scan(arg_itr); /* 6th arg is error output */
  vpi_free_object(arg_itr);  /* free iterator--did not scan to null */

  /* setup value change callback options */
  time_s.type        = vpiSuppressTime;
  cb_data_s.reason   = cbValueChange;
  cb_data_s.cb_rtn   = PLIbook_ScientificALU_interface;
  cb_data_s.time     = &time_s;
  cb_data_s.value    = &value_s;

  /* add value change callbacks to all signals which are inputs to */
  /* pass pointer to storage for handles as user_data value */
  cb_data_s.user_data = (char *)ALUdata;
  value_s.format = vpiRealVal;
  cb_data_s.obj = ALUdata->a_h;
  vpi_register_cb(&cb_data_s);
","Caption: ""Example of Verilog code utilizing VPI (Verilog Procedural Interface) routines for interfacing with C models, demonstrating callback registration and handling in a system-level verification environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p76.jpg,True,"```
##2 (a[=3]) ##1 stop ##1 !stop;
```

```verilog
a26: assert property(p26);
```","[=3]) ##1 stop ##1 !stop;


a26: assert property(p26);
","""Waveform and description of a SystemVerilog Assertions (SVA) checker with non-consecutive repetition operator in action, exhibiting two successful checks and one incomplete check.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p501.jpg,True,"Here is the code from the image:

```c
modpath_h = pathterm_h = null;
while (modpath_h=acc_next_modpath(module_h, modpath_h)) {
    while (pathterm_h=acc_next_output(modpath_h,pathterm_h)) {
        /* continue traversing to port driven by this output */
    }
}
```","th_h = pathterm_h = null;
while (modpath_h=acc_next_modpath(module_h, modpath_h)) {
    while (pathterm_h=acc_next_output(modpath_h,pathterm_h)) {
        /* continue traversing to port driven by this output */
    }
}
",Chapter excerpt on ACC (Application Control Constructs) Routine Library in Verilog with an ACC object diagram for module paths and a code snippet to traverse outputs in a module path.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p166.jpg,True,"The image contains a table of Verilog strengths and some example Verilog code snippets. Here is the code transcribed from the image:

```verilog
wire OutWire;
...
and (strong1, weak0) and01(OutWire, in1, in2, in3);
nor (pull1, pull0) nor31(OutWire, in1, in2, in3);
trireg (large) LargeCapOnNet;
wire (supply1, supply0) TiedTo1 = 1'b1;
// ---
wire UpClock;
...
assign (strong1, weak0) UpClock = ClockIn;
```

This Verilog code provides examples of how to declare wires and use strengths when defining logic gates and when assigning logic level to a wire.","
wire OutWire;
...
and (strong1, weak0) and01(OutWire, in1, in2, in3);
nor (pull1, pull0) nor31(OutWire, in1, in2, in3);
trireg (large) LargeCapOnNet;
wire (supply1, supply0) TiedTo1 = 1'b1;
// ---
wire UpClock;
...
assign (strong1, weak0) UpClock = ClockIn;
",Verilog Signal Strength Levels and Examples of Usage in Code,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p42.jpg,True,"The image contains a piece of SystemVerilog Assertion (SVA) code. Here is the code as presented in the image:

```verilog
property ldpcheck;
    @(posedge clk) $rose(FRAME_) |-> ##[1:2] $fell(LDP_);
endproperty
aP: assert property (ldpcheck) else $display(""ldpcheck FAIL"");
cP: cover property (ldpcheck) $display(""ldpcheck PASS"");
```

This piece of code defines a property called `ldpcheck` that asserts a specific temporal relationship between the signals `FRAME_` and `LDP_` within a clock-driven system. If the property is violated, an assertion failure message is displayed, and if the property is covered, a success message is displayed.","
property ldpcheck;
    @(posedge clk) $rose(FRAME_) |-> ##[1:2] $fell(LDP_);
endproperty
aP: assert property (ldpcheck) else $display(""ldpcheck FAIL"");
cP: cover property (ldpcheck) $display(""ldpcheck PASS"");
","""Explaining Assertions in SystemVerilog with an Example of LDP Check Property""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p254.jpg,True,"There is code in the image. Here it is:

```verilog
genvar L, S;
generate for(L=0;L<=7;L= L+ 1)
    generate for (S=0;S<=3;S= S+ 1)
        cover property @(posedge clk)
            (L == line_sel & set_match[S] & hit);
    endgenerate
endgenerate
```","
genvar L, S;
generate for(L=0;L<=7;L= L+ 1)
    generate for (S=0;S<=3;S= S+ 1)
        cover property @(posedge clk)
            (L == line_sel & set_match[S] & hit);
    endgenerate
endgenerate
",A textbook page showing Verilog code for generating functional coverage for cache set hits within a SystemVerilog environment.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p240.jpg,True,"The image contains two snippets of SystemVerilog code.

The first snippet is:

```verilog
// related to Example 7-11
property good_pipedata;
    reg [WIDTH-1:0] x;                    // to save the incoming data
    // define a sequence that captures data for comparison
    @(posedge clk) disable if (flush)
        !stall, x=data_in |=>
        !stall |=>
        ##[0:$] x==data_out;              // now check against the output
endproperty

assert property (good_pipedata);
```

The second snippet is:

```verilog
// related to Example 7-11
property flushed_pipe;
    @(posedge clk) $rose (flush) |=> pipeline=={$[1:$0]};
endproperty

assert property (flushed_pipe);
```","
// related to Example 7-11
property good_pipedata;
    reg [WIDTH-1:0] x;                    // to save the incoming data
    // define a sequence that captures data for comparison
    @(posedge clk) disable if (flush)
        !stall, x=data_in |=>
        !stall |=>
        ##[0:$] x==data_out;              // now check against the output
endproperty

assert property (good_pipedata);


// related to Example 7-11
property flushed_pipe;
    @(posedge clk) $rose (flush) |=> pipeline=={$[1:$0]};
endproperty

assert property (flushed_pipe);
","""SystemVerilog Assertions for Pipeline Data Consistency and Flush Operations""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p268.jpg,True,"```verilog
always @ (control_state)
// Convert the decoded input to encoded form.
case(1'b1)
    control_state[0]: encode2 = 2'd0;
    control_state[1]: encode2 = 2'd1;
    control_state[2]: encode2 = 2'd2;
    control_state[3]: encode2 = 2'd3;
endcase
```","
always @ (control_state)
// Convert the decoded input to encoded form.
case(1'b1)
    control_state[0]: encode2 = 2'd0;
    control_state[1]: encode2 = 2'd1;
    control_state[2]: encode2 = 2'd2;
    control_state[3]: encode2 = 2'd3;
endcase
",Verilog code example for a two-bit encoder using case statement.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p206.jpg,True,"The image contains several pieces of Verilog code. Here are the snippets:

First code block:
```verilog
property mclocks;
    @(posedge clk0) a ##1 (b ##1 @(posedge clk1) c) |=> D;
endproperty
```

Second code block:
```verilog
sequence s1;
    @(posedge clk0) b ##1 c;
endsequence

sequence s2;
    @(posedge clk1) d ##1 e;
endsequence

sequence s;
    @(posedge clk) a ##1 s1 ##1 s2 ##1 f;
endsequence
```

Third code block:
```verilog
property mclocks;
    @(posedge clk1) @(posedge clk0) a |-> @(posedge clk0) b;
endproperty
```

Fourth code block:
```verilog
property mclocks;
    @(posedge clk0) a |-> @(posedge clk0) b;
endproperty
```","
property mclocks;
    @(posedge clk0) a ##1 (b ##1 @(posedge clk1) c) |=> D;
endproperty


sequence s1;
    @(posedge clk0) b ##1 c;
endsequence

sequence s2;
    @(posedge clk1) d ##1 e;
endsequence

sequence s;
    @(posedge clk) a ##1 s1 ##1 s2 ##1 f;
endsequence


property mclocks;
    @(posedge clk1) @(posedge clk0) a |-> @(posedge clk0) b;
endproperty


property mclocks;
    @(posedge clk0) a |-> @(posedge clk0) b;
endproperty
","""Examples and explanations of multiply clocked properties in Verilog for clock resolution, showing code and the scope of clocking events.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p212.jpg,True,"The image has several blocks of Verilog code, illustrating the proper use of local variables within a sequence construct in Verilog. Here are the code blocks present in the image:

1.
```verilog
sequence rdc;
##[1:5] b;
endsequence
```

2.
```verilog
sequence dataCheck;
int local_data = 0;
(rdc, local_data=rData) ##5 (wData == (local_data+'hff));
endsequence
```

3.
```verilog
sequence dataCheck;
int local_data;
(local_data=rData) ##5
(rdc, wData == (local_data+'hff));
endsequence
```

4.
```verilog
sequence dataCheck;
int local_data;
(1'b1, local_data=rData) ##5 (rdc) ##0 (wData == (local_data+'hff));
endsequence
```

These pieces of code are examples used to show the correct and incorrect ways of using local variables in the context of Verilog sequences.","
sequence rdc;
##[1:5] b;
endsequence


sequence dataCheck;
int local_data = 0;
(rdc, local_data=rData) ##5 (wData == (local_data+'hff));
endsequence


sequence dataCheck;
int local_data;
(local_data=rData) ##5
(rdc, wData == (local_data+'hff));
endsequence


sequence dataCheck;
int local_data;
(1'b1, local_data=rData) ##5 (rdc) ##0 (wData == (local_data+'hff));
endsequence
","""Correct and incorrect use of local variables in Verilog code sequences""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p283.jpg,True,"The image contains an excerpt from a book or a document discussing high priority request patterns in the context of assertion-based design, specifically relating to Verilog code. The page includes a Verilog code example, which is shown below:

```verilog
// Property to detect a high priority request and then expect
// the next grant change to be for this requestor.
property hipri_grant(N)
    @(posedge clk) ($rose(req[N] && hipri[N])
        |=> ($stable(grant) [*1:50] ##1 grant[N]))
endproperty

// Generate an assertion for each requestor.
genvar i;
generate for (i=0; i<4; i = i + 1)
    assert property (hipri_grant(i))
        else $error(""Grant [%d] for hi priority not next or timeout."", i);
endgenerate
```

This Verilog example defines a property `hipri_grant(N)` using SystemVerilog syntax, which detects a high priority request. It then generates an assertion for each requestor within a generate loop. The assertion ensures that once a high priority request is observed, the next grant change is for the high priority requestor within 50 clock cycles, and no other requestor receives the grant during this interval. If the property is not met, an error message is output.","
// Property to detect a high priority request and then expect
// the next grant change to be for this requestor.
property hipri_grant(N)
    @(posedge clk) ($rose(req[N] && hipri[N])
        |=> ($stable(grant) [*1:50] ##1 grant[N]))
endproperty

// Generate an assertion for each requestor.
genvar i;
generate for (i=0; i<4; i = i + 1)
    assert property (hipri_grant(i))
        else $error(""Grant [%d] for hi priority not next or timeout."", i);
endgenerate
","Short caption: ""Example of a SystemVerilog assertion for detecting high priority request grants in arbitration schemes.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p95.jpg,True,"The image contains code related to Verilog/SystemVerilog assertions and clocking blocks. Here is the code extracted from the image:

```verilog
d2: assert property (x |-> y); //will inherit default clock - negedgeClock
d3: assert property (z[2] |->
a); //will inherit default clock - negedgeClock
nd1: assert property (nClk); //explicit declaration of clock - clk2

endmodule

property q1;
  $rose(a) |->
    ##[1:5] b;
endproperty

property q2;
  @(posedge clk) q1;
endproperty

default clocking posedge_clk @(posedge clk);

property q3;
  $fell(c) |->
    q1; // legal: q1 has no clocking event
endproperty

property q4;
  $fell(c) |->
    q2; // legal: q2 has clocking event identical to that of the clocking block
endproperty

sequence s1;
  @(posedge clk) b[*3]; // illegal: explicit clocking event in clocking block
endsequence

endclocking
```

This code demonstrates the use of assertions with default and explicit clocks, as well as the declaration of properties and sequences. It also includes comments indicating legal and illegal uses within a `default clocking` block, according to SystemVerilog LRM (Language Reference Manual).","
d2: assert property (x |-> y); //will inherit default clock - negedgeClock
d3: assert property (z[2] |->
a); //will inherit default clock - negedgeClock
nd1: assert property (nClk); //explicit declaration of clock - clk2

endmodule

property q1;
  $rose(a) |->
    ##[1:5] b;
endproperty

property q2;
  @(posedge clk) q1;
endproperty

default clocking posedge_clk @(posedge clk);

property q3;
  $fell(c) |->
    q1; // legal: q1 has no clocking event
endproperty

property q4;
  $fell(c) |->
    q2; // legal: q2 has clocking event identical to that of the clocking block
endproperty

sequence s1;
  @(posedge clk) b[*3]; // illegal: explicit clocking event in clocking block
endsequence

endclocking
",Excerpt from a document outlining rules and examples for default clocking blocks in Verilog/SystemVerilog.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p199.jpg,True,"The image contains an example of a task declaration in Verilog. Here is the code excerpt:

```verilog
task SwizzleIt (output[3:0] SwizOut, input[3:0] SwizIn, input Ena);
    begin
        if (Ena=='b1)
            #7 SwizOut = { SwizIn[2], SwizIn[3], SwizIn[0], SwizIn[1] };
        else #5 SwizOut = SwizIn;
    end
endtask
```

This code shows a task named `SwizzleIt` that takes a 4-bit output `SwizOut`, a 4-bit input `SwizIn`, and a single bit input `Ena`. In the task, if `Ena` is high (`'b1`), it performs a bit swizzling operation with a delay of 7 time units; otherwise, it assigns the input directly to the output with a delay of 5 time units.","
task SwizzleIt (output[3:0] SwizOut, input[3:0] SwizIn, input Ena);
    begin
        if (Ena=='b1)
            #7 SwizOut = { SwizIn[2], SwizIn[3], SwizIn[0], SwizIn[1] };
        else #5 SwizOut = SwizIn;
    end
endtask
","""Explanation about the difference between tasks and functions in Verilog with an example of task declaration and call.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p717.jpg,True,"This image displays documented information regarding a subset of the Verilog Procedural Interface (VPI) routines from the IEEE 1364-1995 VPI Routine Library. The text includes function prototypes and data structures for interacting with Verilog simulations. Here's the code excerpt shown in the image:

```c
char *vpi_get_str(property, object)
int property; // constant representing an object property.
vpiHandle object; // handle for an object.

void vpi_get_systf_info(object, data)
vpiHandle object; // handle for an object.
p_vpi_systf_data data; // pointer to an application-allocated s_vpi_systf_data structure to receive data information.

// The struct below is partially visible on the page with some text truncated. I'll provide the visible part:
typedef struct t_vpi_systf_data {
    int type; // * vpiSysTask, vpiSysFunc */
    int subtype; // vpiSysFuncInt, vpiSysFuncReal, vpiSysFuncTime, vpiSysFuncSized */
    char *tfname; // quoted task/function name,
    // (Truncated text follows, not showing complete field descriptions or types.)
    int (*calltf)();
    int (*compiletf)();
    int (*sizetf)();
    // (Truncated text follows.)
    char *user_data;
    s_vpi_systf_data *p_systf_data; // returned with callback */
} s_vpi_systf_data, *p_vpi_systf_data;

// Note about changes proposed in IEEE 1364-1999 standard
(Note: The proposed IEEE 1364-1999 standard changes the names of the constants 
involved with task/functions: vpiSysFuncInt changes to vpiIntFunc,
vpiSysFuncTime changes to vpiTimeFunc, vpiSysFuncReal changes to vpiRealFunc,
and vpiSysFuncSized changes to vpiSizedFunc.)

void vpi_get_time(object, time)
vpiHandle object; // handle for an object.
p_vpi_time time; // pointer to an application-allocated s_vpi_time structure to receive time information.

// The struct below is partially visible on the page with some text truncated. I'll provide the visible part:
typedef struct t_vpi_time {
    int type; // vpiScaledRealTime, vpiSimTime, vpiSuppressTime */
    unsigned int high; // when using vpiSimTime */
    unsigned int low; // when using vpiSimTime */
    double real; // when using vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;
```

Please note that some text is cut off and thus the representation may not be complete.","*vpi_get_str(property, object)
int property; // constant representing an object property.
vpiHandle object; // handle for an object.

void vpi_get_systf_info(object, data)
vpiHandle object; // handle for an object.
p_vpi_systf_data data; // pointer to an application-allocated s_vpi_systf_data structure to receive data information.

// The struct below is partially visible on the page with some text truncated. I'll provide the visible part:
typedef struct t_vpi_systf_data {
    int type; // * vpiSysTask, vpiSysFunc */
    int subtype; // vpiSysFuncInt, vpiSysFuncReal, vpiSysFuncTime, vpiSysFuncSized */
    char *tfname; // quoted task/function name,
    // (Truncated text follows, not showing complete field descriptions or types.)
    int (*calltf)();
    int (*compiletf)();
    int (*sizetf)();
    // (Truncated text follows.)
    char *user_data;
    s_vpi_systf_data *p_systf_data; // returned with callback */
} s_vpi_systf_data, *p_vpi_systf_data;

// Note about changes proposed in IEEE 1364-1999 standard
(Note: The proposed IEEE 1364-1999 standard changes the names of the constants 
involved with task/functions: vpiSysFuncInt changes to vpiIntFunc,
vpiSysFuncTime changes to vpiTimeFunc, vpiSysFuncReal changes to vpiRealFunc,
and vpiSysFuncSized changes to vpiSizedFunc.)

void vpi_get_time(object, time)
vpiHandle object; // handle for an object.
p_vpi_time time; // pointer to an application-allocated s_vpi_time structure to receive time information.

// The struct below is partially visible on the page with some text truncated. I'll provide the visible part:
typedef struct t_vpi_time {
    int type; // vpiScaledRealTime, vpiSimTime, vpiSuppressTime */
    unsigned int high; // when using vpiSimTime */
    unsigned int low; // when using vpiSimTime */
    double real; // when using vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;
","""IEEE 1364-1995 VPI Routine Library documentation with Verilog PLI system task/function callback details.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p320.jpg,True,"Here is the Verilog code from the Example A-5 shown in the image:

```verilog
module pass_mux (clk, reset_n, cntrl, in, out) ;
input clk, reset_n;
input [3:0] cntrl;
input [3:0] in;
output out;
reg out;
always @(posedge clk) begin
    case (cntrl)
        4’b0001: out <= in[0];
        4’b0010: out <= in[1];
        4’b0100: out <= in[2];
        4’b1000: out <= in[3];
    endcase
end
// check for zero or one-hot values for cntrl
assert_always valid_cntrl (clk, reset_n, ((cntrl & (cntrl-1)) == 4'b0) ) ;
endmodule
```

Additionally, the OVL assertion from Example A-6 is as follows:

```verilog
assert_zero_one_hot # (0, 4) valid_cntrl (clk, reset_n, cntrl) ;
```","
module pass_mux (clk, reset_n, cntrl, in, out) ;
input clk, reset_n;
input [3:0] cntrl;
input [3:0] in;
output out;
reg out;
always @(posedge clk) begin
    case (cntrl)
        4’b0001: out <= in[0];
        4’b0010: out <= in[1];
        4’b0100: out <= in[2];
        4’b1000: out <= in[3];
    endcase
end
// check for zero or one-hot values for cntrl
assert_always valid_cntrl (clk, reset_n, ((cntrl & (cntrl-1)) == 4'b0) ) ;
endmodule


assert_zero_one_hot # (0, 4) valid_cntrl (clk, reset_n, cntrl) ;
","""Using assert_zero_one_hot in Verilog for checking one-hot conditions on control signals""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p334.jpg,True,"```verilog
module synchronizer_with_bug (clk, reset_n, sync, count_max, out);

  input clk, reset_n, sync;
  input [3:0] count_max;
  output out;

  reg out;
  reg [3:0] count;

  always @ (posedge clk) begin
    if (reset_n == 0) begin
      out <= 0;
      count <= 0;
    end
    else if (count != 0) begin
      count <= count - 1;
      if (count == 1) out <= 1;
    end
    else if (sync == 1) count <= count_max;
    else if (out == 1) out <= 0;
  end

  // out must change values 3 cycles after sync
  assert_change #(0,1,3,0) synch_test (clk,reset_n,(sync == 1), out);
endmodule
```","
module synchronizer_with_bug (clk, reset_n, sync, count_max, out);

  input clk, reset_n, sync;
  input [3:0] count_max;
  output out;

  reg out;
  reg [3:0] count;

  always @ (posedge clk) begin
    if (reset_n == 0) begin
      out <= 0;
      count <= 0;
    end
    else if (count != 0) begin
      count <= count - 1;
      if (count == 1) out <= 1;
    end
    else if (sync == 1) count <= count_max;
    else if (out == 1) out <= 0;
  end

  // out must change values 3 cycles after sync
  assert_change #(0,1,3,0) synch_test (clk,reset_n,(sync == 1), out);
endmodule
","Caption: ""Verilog code example illustrating the use of an assertion to verify that a signal changes values within a specific number of clock cycles.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p399.jpg,True,"The image contains the following Verilog code:

```verilog
//correct assertion
endproperty

counter_count_check: assert property(counter_count)
else $display($stime,,
""\t\tCOUNTER COUNT CHECK FAIL:: UPDOWN COUNT
using $past \n"");

`endif

endmodule

*******************************************************
test_counter.sv
*******************************************************

module test_counter;

logic clk, rst_, ld_cnt_, updn_cnt, count_enb;
logic [7:0] data_in;
wire [7:0] data_out;

int seed1;
counter upc (
    clk, rst_, ld_cnt_, updn_cnt, count_enb,
    data_in,
    data_out
);

bind counter counter_property bind_inst (
    clk, rst_, ld_cnt_, updn_cnt, count_enb,
    data_in,
    data_out
);

initial
begin
    clk=1'b0;
    counter_init;
    count_up(100,10);
    repeat (2) @(posedge clk);
    count_down(100,10);
    repeat (2) @(posedge clk);
    @(posedge clk); $finish(2);
end
```

This code appears to be a testbench for a Verilog module named `counter` (referred to as `upc` when instantiated), and the end contains the initial block to set up the simulation environment. The `assert property` statement is used for dynamic assertion checking in the SystemVerilog assertion framework.","
//correct assertion
endproperty

counter_count_check: assert property(counter_count)
else $display($stime,,
""\t\tCOUNTER COUNT CHECK FAIL:: UPDOWN COUNT
using $past \n"");

`endif

endmodule

*******************************************************
test_counter.sv
*******************************************************

module test_counter;

logic clk, rst_, ld_cnt_, updn_cnt, count_enb;
logic [7:0] data_in;
wire [7:0] data_out;

int seed1;
counter upc (
    clk, rst_, ld_cnt_, updn_cnt, count_enb,
    data_in,
    data_out
);

bind counter counter_property bind_inst (
    clk, rst_, ld_cnt_, updn_cnt, count_enb,
    data_in,
    data_out
);

initial
begin
    clk=1'b0;
    counter_init;
    count_up(100,10);
    repeat (2) @(posedge clk);
    count_down(100,10);
    repeat (2) @(posedge clk);
    @(posedge clk); $finish(2);
end
",Verilog Testbench Code for Validating a Counter with SystemVerilog Assertions,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p414.jpg,True,"The image contains a snippet of Verilog code. Here is the code as written on the page:

```verilog
//Drive TRDY_ and data
@(negedge clk);
    TRDY_ = 1'b0;

//For Check2
`ifdef check2
    AD_reg = 32'h CAFE_CAFE;
`else
    AD_reg = 32'h CAFE_CAFE; AD_enb = 1'b1;
`endif

//Insert a WAIT state
@(negedge clk);
    TRDY_ = 1'b1;
    AD_enb = 1'b0;
$display(""\n"",""TARGET Wait Mode"");

//Drive TRDY_ and second data
@(negedge clk);
    TRDY_ = 1'b0;

//For Check2
`ifdef check2
    AD_enb = 1'b0;
`else
    AD_reg = 32'h FACE_FACE; AD_enb = 1'b1;
`endif

//Drive TRDY_ and third data
@(negedge clk);
    TRDY_ = 1'b0;

//For Check2
`ifdef check2
    AD_enb = 1'b0;
`else
    AD_reg = 32'h CAFE_FACE; AD_enb = 1'b1;
`endif

@(negedge clk);
//De-assert TRDY_ and DEVSEL_
@(negedge clk);
    TRDY_ = 1'b1;
    DEVSEL_ = 1'b1;
    AD_enb = 1'b0;

end
endmodule
```

Please note that the actual Verilog code syntax might require a closer examination, as there are possible line breaks due to the image quality, and the source code may continue beyond what is visible. Additionally, 'end' might be a misprint or a snippet error, as it usually should be either 'end' followed by something like 'endfunction' or 'endmodule' to denote the end of a definition.","
//Drive TRDY_ and data
@(negedge clk);
    TRDY_ = 1'b0;

//For Check2
`ifdef check2
    AD_reg = 32'h CAFE_CAFE;
`else
    AD_reg = 32'h CAFE_CAFE; AD_enb = 1'b1;
`endif

//Insert a WAIT state
@(negedge clk);
    TRDY_ = 1'b1;
    AD_enb = 1'b0;
$display(""\n"",""TARGET Wait Mode"");

//Drive TRDY_ and second data
@(negedge clk);
    TRDY_ = 1'b0;

//For Check2
`ifdef check2
    AD_enb = 1'b0;
`else
    AD_reg = 32'h FACE_FACE; AD_enb = 1'b1;
`endif

//Drive TRDY_ and third data
@(negedge clk);
    TRDY_ = 1'b0;

//For Check2
`ifdef check2
    AD_enb = 1'b0;
`else
    AD_reg = 32'h CAFE_FACE; AD_enb = 1'b1;
`endif

@(negedge clk);
//De-assert TRDY_ and DEVSEL_
@(negedge clk);
    TRDY_ = 1'b1;
    DEVSEL_ = 1'b1;
    AD_enb = 1'b0;

end
endmodule
","Verilog code snippet showing conditional compilation, wait state insertion, and signal driving.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p122.jpg,True,"```verilog
typedef int fixed_array5_t[5];
fixed_array5_t f5;

function fixed_array5_t init(input int start);
    foreach (init[i])
        init[i] = i + start;
endfunction

initial begin
    f5 = init(5);
    foreach (f5[i])
        $display(""f5[%0d] = %0d"", i, f5[i]);
end
```

```verilog
function automatic void init(ref int f[5], input int start);
    foreach (f[i])
        f[i] = i + start;
endfunction

int fa[5];
initial begin
    init(fa, 5);
    foreach (fa[i])
        $display(""fa[%0d] = %0d"", i, fa[i]);
end
```","
typedef int fixed_array5_t[5];
fixed_array5_t f5;

function fixed_array5_t init(input int start);
    foreach (init[i])
        init[i] = i + start;
endfunction

initial begin
    f5 = init(5);
    foreach (f5[i])
        $display(""f5[%0d] = %0d"", i, f5[i]);
end


function automatic void init(ref int f[5], input int start);
    foreach (f[i])
        f[i] = i + start;
endfunction

int fa[5];
initial begin
    init(fa, 5);
    foreach (fa[i])
        $display(""fa[%0d] = %0d"", i, fa[i]);
end
","Caption: ""Examples of Verilog functions for initializing arrays and considerations for performance when returning arrays from functions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p139.jpg,True,"Here is the code from the image:

```c
int PLIbook_ListPort_calltf(char *user_data)
{
    vpiHandle module_handle, systf_h, arg_itr,
    path_itr, path_handle,
    term_itr, term_handle,
    port_itr, port_handle,
    net_handle;

    /* get module handle from first system task argument. Assume the */
    /* compiletf routine has already verified correct argument type. */
    systf_h = vpi_handle(vpiSysTfCall, NULL);
    if (systf_h == NULL) {
        vpi_printf(""ERROR: list_pathout_ports could not obtain handle to systf call\n"");
        return(0);
    }
    arg_itr = vpi_iterate(vpiArgument, systf_h);
    if (arg_itr == NULL) {
        vpi_printf(""ERROR: list_pathout_ports could not obtain iterator to systf args\n"");
        return(0);
    }
    module_handle = vpi_scan(arg_itr);
    vpi_free_object(arg_itr); /* free itr since did not scan until null */

    vpi_printf(""\nModule %s\n"", vpi_get_str(vpiDefName, module_handle));

    path_itr = vpi_iterate(vpiModPath, module_handle);
    if (path_itr == NULL) {
        vpi_printf("" No module paths found\n"");
        return(0);
    }
    while (path_handle = vpi_scan(path_itr)) {
        term_itr = vpi_iterate(vpiModPathOut, path_handle);
        if (term_itr == NULL) {
            vpi_printf("" No path output terminal found\n"");
            break; /* go to next path */
        }
        while (term_handle = vpi_scan(term_itr)) {
            net_handle = vpi_handle(vpiExpr, term_handle);
            port_itr = vpi_iterate(vpiPort, net_handle);
            if (port_itr == NULL) {
                vpi_printf("" No port connected to terminal\n"");
                break; /* go to next terminal */
            }
            while (port_handle = vpi_scan(port_itr)) {
                vpi_printf(""  %s\n"", vpi_get_str(vpiName, port_handle));
            }
            vpi_free_object(port_itr);
        }
        vpi_free_object(term_itr);
    }
}
```

This is a C function interfacing with Verilog through the Verilog Procedural Interface (VPI). The function is meant to be called from within a Verilog simulation environment, and it demonstrates how to traverse the Verilog hierarchy to list ports.","LIbook_ListPort_calltf(char *user_data)
{
    vpiHandle module_handle, systf_h, arg_itr,
    path_itr, path_handle,
    term_itr, term_handle,
    port_itr, port_handle,
    net_handle;

    /* get module handle from first system task argument. Assume the */
    /* compiletf routine has already verified correct argument type. */
    systf_h = vpi_handle(vpiSysTfCall, NULL);
    if (systf_h == NULL) {
        vpi_printf(""ERROR: list_pathout_ports could not obtain handle to systf call\n"");
        return(0);
    }
    arg_itr = vpi_iterate(vpiArgument, systf_h);
    if (arg_itr == NULL) {
        vpi_printf(""ERROR: list_pathout_ports could not obtain iterator to systf args\n"");
        return(0);
    }
    module_handle = vpi_scan(arg_itr);
    vpi_free_object(arg_itr); /* free itr since did not scan until null */

    vpi_printf(""\nModule %s\n"", vpi_get_str(vpiDefName, module_handle));

    path_itr = vpi_iterate(vpiModPath, module_handle);
    if (path_itr == NULL) {
        vpi_printf("" No module paths found\n"");
        return(0);
    }
    while (path_handle = vpi_scan(path_itr)) {
        term_itr = vpi_iterate(vpiModPathOut, path_handle);
        if (term_itr == NULL) {
            vpi_printf("" No path output terminal found\n"");
            break; /* go to next path */
        }
        while (term_handle = vpi_scan(term_itr)) {
            net_handle = vpi_handle(vpiExpr, term_handle);
            port_itr = vpi_iterate(vpiPort, net_handle);
            if (port_itr == NULL) {
                vpi_printf("" No port connected to terminal\n"");
                break; /* go to next terminal */
            }
            while (port_handle = vpi_scan(port_itr)) {
                vpi_printf(""  %s\n"", vpi_get_str(vpiName, port_handle));
            }
            vpi_free_object(port_itr);
        }
        vpi_free_object(term_itr);
    }
}
","""Verilog VPI Routine Example for Traversing Hierarchical Paths and Ports""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p201.jpg,True,"```verilog
sequence s_datafeeder;
    sipo_en[*64] ##1 $fell (sipo_en) ##1
    latch_en ##1 !latch_en;
endsequence

property p_datafeeder;
    @(posedge clk) ($rose (sipo_en) && reset_) |-> 
    s_datafeeder;
endproperty

a_datafeeder: assert property(p_datafeeder);
```","
sequence s_datafeeder;
    sipo_en[*64] ##1 $fell (sipo_en) ##1
    latch_en ##1 !latch_en;
endsequence

property p_datafeeder;
    @(posedge clk) ($rose (sipo_en) && reset_) |-> 
    s_datafeeder;
endproperty

a_datafeeder: assert property(p_datafeeder);
","Caption: ""Excerpt from a technical document detailing SVA (SystemVerilog Assertions) for data intensive design verification, including a waveform for a JPEG checker and the corresponding SVA code.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p372.jpg,True,"The image contains code in the SystemVerilog hardware description language. Here is the code snippet from the image:

```verilog
package project_library;
    checker irdy_trdy (irdy, trdy, event clk = $inferred_clock);
        a1: assert property (@clk) irdy |=> trdy;
    endchecker : irdy_trdy
endpackage: project_library
```

This code demonstrates the definition of a checker named `irdy_trdy` inside a SystemVerilog package named `project_library`. The checker verifies that whenever the `irdy` signal is true, the `trdy` signal will eventually also be true, synchronized to the clock signal `clk`.","
package project_library;
    checker irdy_trdy (irdy, trdy, event clk = $inferred_clock);
        a1: assert property (@clk) irdy |=> trdy;
    endchecker : irdy_trdy
endpackage: project_library
","""Guidelines for Verilog checker declaration within a SystemVerilog package with example code snippet.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p366.jpg,True,"```verilog
checker myCheck(a, b);
  bit a, b;

  initial begin
    @(posedge clk);
    a = returnAvalue;
  end

  function (bit a) returnAvalue;
    return a+1;
  endfunction

endchecker
```","
checker myCheck(a, b);
  bit a, b;

  initial begin
    @(posedge clk);
    a = returnAvalue;
  end

  function (bit a) returnAvalue;
    return a+1;
  endfunction

endchecker
","""Guidelines and example for using functions within checkers in Verilog to adhere to variable assignment restrictions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p400.jpg,True,"The image contains Verilog code, which seems to be part of a digital design lab exercise. Here is the Verilog code extracted from the image:

```verilog
always @ (posedge clk)
    $display($stime,,,""rst_=%b clk=%b count_enb=%b ld_cnt_=%b updn_cnt_=%b DIN=%0d DOUT=%0d"",
    rst_, clk, count_enb, ld_cnt_, updn_cnt, data_in, data_out);
    
always #5 clk=!clk;

task counter_init;
    rst_='1'b1; ld_cnt_='1'b1; count_enb='1'b0; updn_cnt='1'b1;
    @ (negedge clk); rst_='1'b0;
    @ (negedge clk);
    @ (negedge clk); rst_='1'b1;
    @ (negedge clk); data_in='8'b0; ld_cnt_='1'b0;
    @ (negedge clk);
endtask

task count_up;
    input logic [7:0] din;
    input int count;
    @ (negedge clk); data_in=din; ld_cnt_='1'b0;
    @ (negedge clk); ld_cnt_='1'b1; count_enb='1'b1; updn_cnt='1'b1;
    repeat (count-1) @ (negedge clk);
    @ (negedge clk); count_enb='1'b0;
endtask

task count_down;
    input logic [7:0] din;
    input int count;
    @ (negedge clk); data_in=din; ld_cnt_='1'b0;
    @ (negedge clk); ld_cnt_='1'b1; count_enb='1'b1; updn_cnt='1'b0;
    repeat (count-1) @ (negedge clk);
    @ (negedge clk); count_enb='1'b0;
endtask

endmodule
```

The code comprises an `always` block for displaying certain signal values on the positive edge of the clock, another `always` block that toggles the clock every 5 time units, and three tasks: `counter_init`, `count_up`, and `count_down`, which appear to be used for initializing a counter and then counting up or down based on input parameters.","
always @ (posedge clk)
    $display($stime,,,""rst_=%b clk=%b count_enb=%b ld_cnt_=%b updn_cnt_=%b DIN=%0d DOUT=%0d"",
    rst_, clk, count_enb, ld_cnt_, updn_cnt, data_in, data_out);
    
always #5 clk=!clk;

task counter_init;
    rst_='1'b1; ld_cnt_='1'b1; count_enb='1'b0; updn_cnt='1'b1;
    @ (negedge clk); rst_='1'b0;
    @ (negedge clk);
    @ (negedge clk); rst_='1'b1;
    @ (negedge clk); data_in='8'b0; ld_cnt_='1'b0;
    @ (negedge clk);
endtask

task count_up;
    input logic [7:0] din;
    input int count;
    @ (negedge clk); data_in=din; ld_cnt_='1'b0;
    @ (negedge clk); ld_cnt_='1'b1; count_enb='1'b1; updn_cnt='1'b1;
    repeat (count-1) @ (negedge clk);
    @ (negedge clk); count_enb='1'b0;
endtask

task count_down;
    input logic [7:0] din;
    input int count;
    @ (negedge clk); data_in=din; ld_cnt_='1'b0;
    @ (negedge clk); ld_cnt_='1'b1; count_enb='1'b1; updn_cnt='1'b0;
    repeat (count-1) @ (negedge clk);
    @ (negedge clk); count_enb='1'b0;
endtask

endmodule
","Verilog code for a synchronous system with tasks for initialization, counting up, and counting down.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p136.jpg,True,"```verilog
interface arb_if(input bit clk);
  logic [1:0] grant, request;
  bit rst;

  modport TEST (output request, rst,
                input grant, clk);

  modport DUT (input request, rst, clk,
               output grant);

  modport MONITOR (input request, grant, rst, clk);

endinterface

module arb_with_mp (arb_if.DUT arbif);
  ...
endmodule

module test_with_mp (arb_if.TEST arbif);
  ...
endmodule
```","
interface arb_if(input bit clk);
  logic [1:0] grant, request;
  bit rst;

  modport TEST (output request, rst,
                input grant, clk);

  modport DUT (input request, rst, clk,
               output grant);

  modport MONITOR (input request, grant, rst, clk);

endinterface

module arb_with_mp (arb_if.DUT arbif);
  ...
endmodule

module test_with_mp (arb_if.TEST arbif);
  ...
endmodule
","Caption: ""Verilog interface example with modports defining signal directions for different modules.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p105.jpg,True,"The image contains a small snippet of Verilog code and some C code related to Verilog PLI (Programming Language Interface) applications. Here is the Verilog code snippet:

```verilog
module addbit (a, b, ci, sum, co);
    ...
    always @(sum or co)
        $show_all_signals(); // list signals in this instance
endmodule
```

Now, here is the visible C code used for Verilog PLI:

```c
#include <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard input/output library */
#include <vpi_user.h> /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
/* using TF routines for simulation control */

/* prototypes of the PLI application routines */
int PLIbook_ShowSignals_compiletf(), PLIbook_ShowSignals_calltf();
void PLIbook_PrintSignalValues();

/*******************************************************
 * Show_all_signals Registration Data
 * (add this function name to the vlog_startup_routines array)
 *******************************************************/
```

The rest of the C code and the descriptions of what the code is supposed to do are cut off and not fully visible in the image.","
module addbit (a, b, ci, sum, co);
    ...
    always @(sum or co)
        $show_all_signals(); // list signals in this instance
endmodule

ude <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard input/output library */
#include <vpi_user.h> /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library */
/* using TF routines for simulation control */

/* prototypes of the PLI application routines */
int PLIbook_ShowSignals_compiletf(), PLIbook_ShowSignals_calltf();
void PLIbook_PrintSignalValues();

/*******************************************************
 * Show_all_signals Registration Data
 * (add this function name to the vlog_startup_routines array)
 *******************************************************/
","Caption: ""Excerpt from a technical book explaining the usage of VPI routines in Verilog with an example module and associated C code for the PLI application, demonstrating the integration of system tasks and functions in a simulation environment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p428.jpg,True,"The image contains snippets of code written in SystemVerilog (a hardware description and verification language), which is used for defining properties and assertions on a FIFO (First-In-First-Out) memory buffer. Here is the Verilog code from the image:

```verilog
`ifdef check4
property fifo_full_write_stable_wrptr;
  @(posedge clk) disable iff (!rst_)
    (fifo_full && fifo_write && !fifo_read) |=> $stable(`wr_ptr);
endproperty
fifo_full_write_stable_wrptr: assert property (fifo_full_write_stable_wrptr)
  else $display($stime,""\t\t FAIL::fifo_full_write_stable_wrptr condition\n"");
`endif

`ifdef check5
property fifo_empty_read_stable_rdptr;
  @(posedge clk) disable iff (!rst_)
    (fifo_empty && !fifo_write && fifo_read) |=> $stable(`rd_ptr);
endproperty
fifo_empty_read_stable_rdptr: assert property (fifo_empty_read_stable_rdptr)
  else $display($stime,""\t\t FAIL::fifo_empty_read_stable_rdptr condition\n"");
`endif

`ifdef check6
property write_on_full_fifo;
  @(posedge clk) disable iff (!rst_)
    fifo_full |-!> fifo_write;
endproperty
write_on_full_fifo: assert property (write_on_full_fifo)
  else $display($stime,""\t\t WARNING:write_on_full_fifo\n"");
`endif
```

These code snippets define properties for checking the conditions of a FIFO such as whether the write pointer remains stable when the FIFO is full and a write attempt is made (`fifo_full_write_stable_wrptr`), whether the read pointer remains stable when the FIFO is empty and a read attempt is made (`fifo_empty_read_stable_rdptr`), and whether writing on a full FIFO raises a warning (`write_on_full_fifo`). Each property is associated with an assertion to verify the intended behavior during simulation. The `$display` statements are used for debugging purposes, to print messages at specific simulation times when the conditions fail. The use of `ifdef` directives (e.g., `ifdef check4`) suggests that these checks can be conditionally compiled based on whether certain flags are defined.","
`ifdef check4
property fifo_full_write_stable_wrptr;
  @(posedge clk) disable iff (!rst_)
    (fifo_full && fifo_write && !fifo_read) |=> $stable(`wr_ptr);
endproperty
fifo_full_write_stable_wrptr: assert property (fifo_full_write_stable_wrptr)
  else $display($stime,""\t\t FAIL::fifo_full_write_stable_wrptr condition\n"");
`endif

`ifdef check5
property fifo_empty_read_stable_rdptr;
  @(posedge clk) disable iff (!rst_)
    (fifo_empty && !fifo_write && fifo_read) |=> $stable(`rd_ptr);
endproperty
fifo_empty_read_stable_rdptr: assert property (fifo_empty_read_stable_rdptr)
  else $display($stime,""\t\t FAIL::fifo_empty_read_stable_rdptr condition\n"");
`endif

`ifdef check6
property write_on_full_fifo;
  @(posedge clk) disable iff (!rst_)
    fifo_full |-!> fifo_write;
endproperty
write_on_full_fifo: assert property (write_on_full_fifo)
  else $display($stime,""\t\t WARNING:write_on_full_fifo\n"");
`endif
","""SystemVerilog Assertions for FIFO Operations Checking""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p663.jpg,True,"The image contains Verilog-related code. Here it is:

```c
void init_usertfs()
{
    p_tfcell usertf;

    for (usertf = veriusertfs; usertf; usertf++) {
        if (usertf->type == 0)
            return;
        mti_RegisterUserTF(usertf);
    }
}
```

Example A-9 (continued from the image):

```c
#include ""veriuser.h""

/* prototypes of the PLI application routines */
extern int PLIbook_ShowVal_checktf(), PLIbook_ShowVal_calltf();
extern int PLIbook_pow_sizetf(), PLIbook_pow_checktf(),
           PLIbook_pow_calltf(), PLIbook_pow_misctf();

/* the veriusertfs table */
s_tfcell veriusertfs[] =
{
    {
        usertask,
        0,                          /* user_data value */
        PLIbook_ShowVal_checktf,    /* checktf routine */
        0,                          /* sizetf routine */
        PLIbook_ShowVal_calltf,     /* calltf routine */
        0,                          /* misctf routine */
        ""show_value"",               /* system task/function name */
        1                           /* forward reference = true */
    },
    {
        userfunction,
        0,                          /* user_data value */
        PLIbook_pow_checktf,        /* checktf routine */
        PLIbook_pow_sizetf,         /* sizetf routine */
        PLIbook_pow_calltf,         /* calltf routine */
        PLIbook_pow_misctf,         /* misctf routine */
        ""$pow"",                     /* system task/function name */
        1                           /* forward reference = true */
    },
    {0} /*** final entry must be 0 ***/
};
```

This is example code showing how to set up PLI (Programming Language Interface) callbacks for user-defined tasks and functions in Verilog simulation. The `init_usertfs` function registers the user-defined tasks and functions with the simulator, and `veriusertfs` is an array of `s_tfcell` structures containing information about each PLI application.","init_usertfs()
{
    p_tfcell usertf;

    for (usertf = veriusertfs; usertf; usertf++) {
        if (usertf->type == 0)
            return;
        mti_RegisterUserTF(usertf);
    }
}

ude ""veriuser.h""

/* prototypes of the PLI application routines */
extern int PLIbook_ShowVal_checktf(), PLIbook_ShowVal_calltf();
extern int PLIbook_pow_sizetf(), PLIbook_pow_checktf(),
           PLIbook_pow_calltf(), PLIbook_pow_misctf();

/* the veriusertfs table */
s_tfcell veriusertfs[] =
{
    {
        usertask,
        0,                          /* user_data value */
        PLIbook_ShowVal_checktf,    /* checktf routine */
        0,                          /* sizetf routine */
        PLIbook_ShowVal_calltf,     /* calltf routine */
        0,                          /* misctf routine */
        ""show_value"",               /* system task/function name */
        1                           /* forward reference = true */
    },
    {
        userfunction,
        0,                          /* user_data value */
        PLIbook_pow_checktf,        /* checktf routine */
        PLIbook_pow_sizetf,         /* sizetf routine */
        PLIbook_pow_calltf,         /* calltf routine */
        PLIbook_pow_misctf,         /* misctf routine */
        ""$pow"",                     /* system task/function name */
        1                           /* forward reference = true */
    },
    {0} /*** final entry must be 0 ***/
};
","Caption: ""Example of C code for initializing Verilog Programming Language Interface (PLI) applications and registering them with a ModelSim simulator.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p229.jpg,True,"The image includes Verilog code defining SystemVerilog Assertions (SVA) properties. Here is the code provided:

```verilog
property p_tRFC_not;
    @(posedge clk)
        's_autorefresh |-> not ##[1: (tRFC-1)] 's_autorefresh;
endproperty

property p_tRFC;
    @(posedge clk)
        's_autorefresh |-> ##[tRFC:12000] 's_autorefresh;
endproperty

a_tRFC_not: assert property (p_tRFC_not);
a_tRFC: assert property (p_tRFC);

c_tRFC_not: cover property (p_tRFC_not);
c_tRFC: cover property (p_tRFC);
```

These properties and assertions/coverage points are related to the timing between auto-refresh commands in an SDRAM (Synchronous Dynamic RAM) system. The code likely aims to check that the auto-refresh commands are issued with a proper time interval between them.","
property p_tRFC_not;
    @(posedge clk)
        's_autorefresh |-> not ##[1: (tRFC-1)] 's_autorefresh;
endproperty

property p_tRFC;
    @(posedge clk)
        's_autorefresh |-> ##[tRFC:12000] 's_autorefresh;
endproperty

a_tRFC_not: assert property (p_tRFC_not);
a_tRFC: assert property (p_tRFC);

c_tRFC_not: cover property (p_tRFC_not);
c_tRFC: cover property (p_tRFC);
","Caption: ""Example of SystemVerilog Assertions (SVA) for verifying the timing between auto-refresh commands in SDRAM, including Verilog code and timing diagram.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p677.jpg,True,"The image contains an explanation of a format rather than actual code, but it does show a generic format for specifying information in a PLI (Programming Language Interface) table file used by the VCS (Verilog Compilation System). The format shown is:

```
$<system_task_function_name> <PLI_spec> <ACC_spec>
```

This is not executable code but instead a template for defining system tasks or functions within the VCS environment. It also includes a table describing various PLI specification options, but no actual code is written in Verilog or another programming language.","em_task_function_name> <PLI_spec> <ACC_spec>
","Caption: ""Guidelines and specifications for linking PLI applications with Verilog simulators, featuring information on the VCS PLI table file format.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p98.jpg,True,"The image contains several pieces of code written for Property Specification Language (PSL), which is used for specifying properties of hardware systems, particularly for verification purposes. The code examples provided are as follows:

Example 3-20 PSL repetition operator
```verilog
assert always ({req; ack; !halt} |-> 1; grant[2]);
```

Example 3-21 PSL suffix implication with next operator
```verilog
assert always ({req; ack; !halt} |-> next {grant[2]});
```

Example 3-22 PSL suffix next implication
```verilog
assert always ({req; ack; !halt} |=>
               {grant[2]});
```

Example 3-23 PSL sequence declaration
```verilog
sequence req_ack (req, ack) = {req; [*0:2]; ack};
```","
assert always ({req; ack; !halt} |-> 1; grant[2]);


assert always ({req; ack; !halt} |-> next {grant[2]});


assert always ({req; ack; !halt} |=>
               {grant[2]});


sequence req_ack (req, ack) = {req; [*0:2]; ack};
","Caption: ""Examples of PSL (Property Specification Language) operators and sequence declarations for assertion-based design in Verilog.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p106.jpg,True,"The image contains Verilog code with examples of assumptions and restrictions in the context of formal verification. Here are the code snippets present:

First code snippet:
```verilog
m1: assume property (@(clk opcode == OP_ADD);
```

Second code snippet:
```verilog
r1: restrict property (@(clk opcode == OP_ADD);
```

Please note that both code snippets seem to be incomplete as they are missing closing brackets for the `@(clk ...)` event expressions and the `property` constructs. The correct version for these lines should have an additional closing parenthesis at the end of each line:
```verilog
m1: assume property (@(clk opcode == OP_ADD));

r1: restrict property (@(clk opcode == OP_ADD));
```","
m1: assume property (@(clk opcode == OP_ADD);


r1: restrict property (@(clk opcode == OP_ADD);


m1: assume property (@(clk opcode == OP_ADD));

r1: restrict property (@(clk opcode == OP_ADD));
","""Understanding Verilog Assertions, Assumptions, and Restrictions with ALU Example""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p111.jpg,True,"The image contains text and source code written in C for interacting with Verilog hardware description language through the Verilog Programming Interface (VPI). Below is the code that's visible in the image:

```c
/* check each argument */
while ( (arg_handle = vpi_scan(arg_iterator)) != NULL ) {
    tfarg_num++;

    /* check the type of object in system task arguments */
    tfarg_type = vpi_get(vpiType, arg_handle);
    switch (tfarg_type) {
        case vpiModule:
        case vpiTask:
        case vpiFunction:
        case vpiNamedBegin:
        case vpiNamedFork:
            break; /* arg is a scope instance; continue to next check */
        case vpiOperation:
            if (vpi_get(vpiOpType, arg_handle) == vpiNullOp) {
                break; /* null argument OK; continue to next check */
            }
        default:
            /* wrong type specified for an argument */
            vpi_printf(""ERROR: $show_all_signals arg %d"", tfarg_num);
            vpi_printf("" must be a scope instance or null\n"");
            vpi_free_object(arg_iterator); /* free iterator memory */
            tf_dofinish(); /* abort simulation */
            return(0);
    }
}
return(0);
}

/********************************************************************************/
/* calltf routine
********************************************************************************/
int PLIbook_ShowSignals_calltf(char *user_data)
{
    vpiHandle  sysf_handle, arg_iterator, scope_handle;
    int        format;
    s_vpi_time current_time;

    /* obtain a handle to the system task instance */
    sysf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* read current simulation time */
    current_time.type = vpiScaledRealTime;
    vpi_get_time(sysf_handle, &current_time);

    /* obtain handle to system task argument */
    arg_iterator = vpi_iterate(vpiArgument, sysf_handle);
    if (arg_iterator == NULL) {
        /* no arguments -- use scope that called this application */
        scope_handle = vpi_handle(vpiScope, sysf_handle);
```

This code appears to be part of a manual or guidebook discussing the usage of VPI routines in the context of Verilog simulation and synthesis. The `calltf` routine specifically is used to define a task or function that can be called during simulation.","eck each argument */
while ( (arg_handle = vpi_scan(arg_iterator)) != NULL ) {
    tfarg_num++;

    /* check the type of object in system task arguments */
    tfarg_type = vpi_get(vpiType, arg_handle);
    switch (tfarg_type) {
        case vpiModule:
        case vpiTask:
        case vpiFunction:
        case vpiNamedBegin:
        case vpiNamedFork:
            break; /* arg is a scope instance; continue to next check */
        case vpiOperation:
            if (vpi_get(vpiOpType, arg_handle) == vpiNullOp) {
                break; /* null argument OK; continue to next check */
            }
        default:
            /* wrong type specified for an argument */
            vpi_printf(""ERROR: $show_all_signals arg %d"", tfarg_num);
            vpi_printf("" must be a scope instance or null\n"");
            vpi_free_object(arg_iterator); /* free iterator memory */
            tf_dofinish(); /* abort simulation */
            return(0);
    }
}
return(0);
}

/********************************************************************************/
/* calltf routine
********************************************************************************/
int PLIbook_ShowSignals_calltf(char *user_data)
{
    vpiHandle  sysf_handle, arg_iterator, scope_handle;
    int        format;
    s_vpi_time current_time;

    /* obtain a handle to the system task instance */
    sysf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* read current simulation time */
    current_time.type = vpiScaledRealTime;
    vpi_get_time(sysf_handle, &current_time);

    /* obtain handle to system task argument */
    arg_iterator = vpi_iterate(vpiArgument, sysf_handle);
    if (arg_iterator == NULL) {
        /* no arguments -- use scope that called this application */
        scope_handle = vpi_handle(vpiScope, sysf_handle);
","""Example of Verilog Procedural Interface (VPI) routines usage in Verilog simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p122.jpg,True,"The image contains Verilog code. Here's the code transcription:

```verilog
`define data_complete ((trdy_n || !stop_n) && !irdy_n && !devsel_n)
`define end_of_transaction (data_complete && frame_n)
`define adr_turn_around (trdy_n && !irdy_n)
`define data_transfer ((trdy_n && !irdy_n && !devsel_n) && !frame_n)
`define wait_state ((trdy_n || irdy_n) && !devsel_n)
`define cbe_stable (cbe_n==preserv(cbe_n))
`define read_cmd ((cbe_n == `IO_READ) || \
                 (cbe_n == `MEM_READ) || \
                 (cbe_n == `CONFIG_RD) || \
                 (cbe_n == `MEM_RD_MULTI) || \
                 (cbe_n == `MEM_RD_LINE))

sequence SERE_RD_ADDR_PHASE = {frame_n; !frame_n && read_cmd;}
sequence SERE_TURN_AROUND = {adr_turn_around};
sequence SERE_DATA_TRANSFER = {{wait_state [*] ; data_transfer} [1:inf]}
sequence SERE_END_OF_TRANSFER = (data_complete && frame_n);
sequence SERE_DATA_PHASE =
{
    { {SERE_DATA_TRANSFER}; {SERE_END_OF_TRANSFER}} && (cbe_stable)
};

property PCI_READ_TRANSACTION =
    always { {SERE_RD_ADDR_PHASE} |=> 
    {SERE_TURN_AROUND; SERE_DATA_PHASE}} @ (posedge clk)
    abort !rst_n;

assert PCI_READ_TRANSACTION;
```

This code appears to define signals and sequences for a PSL (Property Specification Language) PCI (Peripheral Component Interconnect) basic read transaction, and it assigns an assertion based on those sequences.","
`define data_complete ((trdy_n || !stop_n) && !irdy_n && !devsel_n)
`define end_of_transaction (data_complete && frame_n)
`define adr_turn_around (trdy_n && !irdy_n)
`define data_transfer ((trdy_n && !irdy_n && !devsel_n) && !frame_n)
`define wait_state ((trdy_n || irdy_n) && !devsel_n)
`define cbe_stable (cbe_n==preserv(cbe_n))
`define read_cmd ((cbe_n == `IO_READ) || \
                 (cbe_n == `MEM_READ) || \
                 (cbe_n == `CONFIG_RD) || \
                 (cbe_n == `MEM_RD_MULTI) || \
                 (cbe_n == `MEM_RD_LINE))

sequence SERE_RD_ADDR_PHASE = {frame_n; !frame_n && read_cmd;}
sequence SERE_TURN_AROUND = {adr_turn_around};
sequence SERE_DATA_TRANSFER = {{wait_state [*] ; data_transfer} [1:inf]}
sequence SERE_END_OF_TRANSFER = (data_complete && frame_n);
sequence SERE_DATA_PHASE =
{
    { {SERE_DATA_TRANSFER}; {SERE_END_OF_TRANSFER}} && (cbe_stable)
};

property PCI_READ_TRANSACTION =
    always { {SERE_RD_ADDR_PHASE} |=> 
    {SERE_TURN_AROUND; SERE_DATA_PHASE}} @ (posedge clk)
    abort !rst_n;

assert PCI_READ_TRANSACTION;
","Caption: ""Excerpt from a textbook demonstrating a Property Specification Language (PSL) example for a basic PCI read transaction in Verilog.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p485.jpg,True,"The image contains a snippet of C code that is interfacing with Verilog tasks. Here's the code transcribed from the image:

```c
extern int mem_read(int, int, int*);
extern int mem_write(int, int, int);
extern void mem_build(int);

void read_file(char *fname) {
    char cmd;
    int idx;
    FILE *file;

    file = fopen(fname, ""r"");
    while (!feof(file)) {
        cmd = fgetc(file);
        fscanf(file, ""%d "", &idx);
        switch (cmd) {
        case 'M': {
            int hi;
            fscanf(file, ""%d "", &hi);
            mem_build(hi);
            break;
        }
        case 'R': {
            int addr, data, exp;
            fscanf(file, ""%d %d "", &addr, &exp);
            mem_read(idx, addr, &data);
            if (data != exp)
                io_printf(""C: Error Data=%d, exp=%d\n"", data, exp);
            break;
        }
        case 'W': {
            int addr, data;
            fscanf(file, ""%d %d "", &addr, &data);
            mem_write(idx, addr, data);
            break;
        }
        }
    }
    fclose(file);
}
```

Please note that this code is interfacing with Verilog tasks (as indicated by the `extern` declarations at the beginning) that are likely used for memory operations within a simulated hardware environment. The `read_file` function reads commands from a file and executes memory build, read, or write operations based on the commands.","n int mem_read(int, int, int*);
extern int mem_write(int, int, int);
extern void mem_build(int);

void read_file(char *fname) {
    char cmd;
    int idx;
    FILE *file;

    file = fopen(fname, ""r"");
    while (!feof(file)) {
        cmd = fgetc(file);
        fscanf(file, ""%d "", &idx);
        switch (cmd) {
        case 'M': {
            int hi;
            fscanf(file, ""%d "", &hi);
            mem_build(hi);
            break;
        }
        case 'R': {
            int addr, data, exp;
            fscanf(file, ""%d %d "", &addr, &exp);
            mem_read(idx, addr, &data);
            if (data != exp)
                io_printf(""C: Error Data=%d, exp=%d\n"", data, exp);
            break;
        }
        case 'W': {
            int addr, data;
            fscanf(file, ""%d %d "", &addr, &data);
            mem_write(idx, addr, data);
            break;
        }
        }
    }
    fclose(file);
}
",C code to interface with Verilog exported tasks for memory operations.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p106.jpg,True,"The image contains a section of a document titled ""Verilog and SystemVerilog Gotchas"" and discusses ""Gotcha 39: Hidden design problems using 2-state types."" There are two code examples in Verilog shown in the image. Here is the transcription of the code examples:

```verilog
bit [31:0] data_reg;  // 2-state variable

always_ff @(posedge clock, negedge reset_n)  // data register
    if (!reset_n) data_reg <= 0;             // reset to zero
    else           data_reg <= data_in;
```

The above is a small code snippet that shows a 2-state variable called `data_reg`, which is a 32-bit register. This register is updated on the positive edge of `clock` or the negative edge of `reset_n`. If `reset_n` is low (`!reset_n` evaluates to true), then `data_reg` is set to zero. Otherwise, `data_reg` gets the value of `data_in`.

The second code example is the following:

```verilog
module comparator (output bit eq,  // 2-state output
                   input bit a, b); // 2-state inputs

assign eq = (a == b);

endmodule
```

This code defines a Verilog module called `comparator` which has one output `eq` and two inputs `a` and `b`. The output `eq` is set by a single assignment statement that compares `a` and `b` for equality (using the `==` operator).

The text in the image discusses potential issues when using 2-state logic in design modeling and verification, where certain design errors might not be obvious due to the limitations of 2-state logic compared to 4-state logic.","
bit [31:0] data_reg;  // 2-state variable

always_ff @(posedge clock, negedge reset_n)  // data register
    if (!reset_n) data_reg <= 0;             // reset to zero
    else           data_reg <= data_in;


module comparator (output bit eq,  // 2-state output
                   input bit a, b); // 2-state inputs

assign eq = (a == b);

endmodule
","""Exploring hidden design issues with 2-state types in Verilog code examples.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p112.jpg,True,"The image contains an example of Verilog code. Here is the code provided in the image:

```verilog
module chip (output logic [31:0] result,  // local variable
             input logic [31:0] a, b, c, d);

always @(a or b)
    result = a & b;  // this process writes to result

// dozens of lines of code later...

always @(c or d)
    result = c | d;  // GOTCHA: this process also writes to result
endmodule
```

The code provided is a demonstration of a gotcha in Verilog and SystemVerilog related to the undetected shared variables in modules.","
module chip (output logic [31:0] result,  // local variable
             input logic [31:0] a, b, c, d);

always @(a or b)
    result = a & b;  // this process writes to result

// dozens of lines of code later...

always @(c or d)
    result = c | d;  // GOTCHA: this process also writes to result
endmodule
","""Exploring the challenge of undetected shared variables in Verilog modules with example code snippets highlighting potential conflicts in concurrent procedural blocks.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p32.jpg,True,"The image contains Verilog code snippets. Here is the code provided in the image:

```verilog
module top_level
(output [7:0] out,  // 8-bit port, no data type declared
 input [7:0] a, b, c, d  // 8-bit ports, no data type declared
);

mux4 m1 (.y(out),       // out infers an 8-bit wire type
         .a(a),         // a, b, c, d infer 8-bit wires
         .b(b),
         .c(c),
         .d(d),
         .sel(select) ); // GOTCHA! select infers 1-bit wire

...
endmodule

module mux4
(input  logic [1:0] sel,  // 2-bit input port
 input  logic [7:0] a, b, c, d,  // 8-bit input ports
 output logic [7:0] y    // 8-bit output port
);
...
endmodule
```

These snippets demonstrate an issue with implicit net type inference in Verilog when dealing with vector ports and 1-bit internal nets.","
module top_level
(output [7:0] out,  // 8-bit port, no data type declared
 input [7:0] a, b, c, d  // 8-bit ports, no data type declared
);

mux4 m1 (.y(out),       // out infers an 8-bit wire type
         .a(a),         // a, b, c, d infer 8-bit wires
         .b(b),
         .c(c),
         .d(d),
         .sel(select) ); // GOTCHA! select infers 1-bit wire

...
endmodule

module mux4
(input  logic [1:0] sel,  // 2-bit input port
 input  logic [7:0] a, b, c, d,  // 8-bit input ports
 output logic [7:0] y    // 8-bit output port
);
...
endmodule
","Excerpt from a textbook discussing a common pitfall in Verilog related to the default 1-bit width of implicit internal nets, with an example of a module declaration highlighting the issue.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p238.jpg,True,"The image contains Verilog code, and here it is:

```verilog
module SchedDelayC;
    wire a;
    reg b, c, d;
    initial
    begin
        #0 b = 1'b0;
           c = 1'b1;
           d = 1'b1;
        #5 d = 1'b0;
        #10 c = 1'b1
        #20 $finish;
    end
    //
    assign #(1,3,5) a = c;
    assign #(2,3,4) a = d;
    //
endmodule // SchedDelayC.
```

Please note that there appears to be a typo or formatting issue at the line `#10 c = 1'b1` where the semicolon (;) at the end of the statement is missing. In Verilog, each statement should end with a semicolon.","
module SchedDelayC;
    wire a;
    reg b, c, d;
    initial
    begin
        #0 b = 1'b0;
           c = 1'b1;
           d = 1'b1;
        #5 d = 1'b0;
        #10 c = 1'b1
        #20 $finish;
    end
    //
    assign #(1,3,5) a = c;
    assign #(2,3,4) a = d;
    //
endmodule // SchedDelayC.
",Verilog code example demonstrating scheduling and timing with a simulation waveform result displayed below.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p170.jpg,True,"The image contains examples of Verilog code. Here is the code extracted from the image:

```verilog
sequence ab;
  a ##2 b;
endsequence

sequence cde;
  c ##2 d ##2 e;
endsequence

sequence abcde;
  ab and cde;
endsequence

property ands;
  @(posedge clk) z |-> abcde;
endproperty
```

This code represents sequences and properties in Verilog using the ""and"" operator to combine events or conditions in a temporal logic context. The code is meant to be used in assertions for formal verification or simulation of digital designs.","
sequence ab;
  a ##2 b;
endsequence

sequence cde;
  c ##2 d ##2 e;
endsequence

sequence abcde;
  ab and cde;
endsequence

property ands;
  @(posedge clk) z |-> abcde;
endproperty
","Application of the ""and"" operator in Verilog for simultaneous sequence detection.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p446.jpg,True,"The image contains Verilog code. Here is the code from the image:

```verilog
// Print the contents of the scoreboard, mainly for debugging
function void Scoreboard::display(input string prefix);
    $display(""%@t: %m so far %0d expected cells, %0d actual
rcvd"", $time, iexpect, iactual);
    foreach (expect_cells[i]) begin
        $display(""Tx[%0d]: exp=%0d, act=%0d"",
i, expect_cells[i].iexpect, expect_cells[i].iactual);
        foreach (expect_cells[i].q[j])
            expect_cells[i].q[j].display(
                $sformatf(""%$Scoreboard: Tx%0d: "", prefix, i));
    end
endfunction : display

Sample 11.24 shows the class used to gather functional coverage. Since the cov-
erage only looks at data in a single class, the cover group is defined and instantiated
inside the Coverage class. The data values are read by the class’s sample() method,
then the cover group’s sample() method is called to record the values.

Sample 11.24 Functional coverage class

class Coverage;
    bit [1:0] src;
    bit [NumTx-1:0] fwd;

    covergroup CG_Forward;
        coverpoint src
            {bins src[] = {[0:3]}; 
             option.weight = 0;}
        coverpoint fwd
            {bins fwd[] = {[1:15]}; // Ignore fwd==0
             option.weight = 0;}
        cross src, fwd;
    endgroup : CG_Forward

    function new();
        CG_Forward = new; // Instantiate the covergroup
    endfunction : new

    // Sample input data
    function void sample(input bit [1:0] src,
                         input bit [NumTx-1:0] fwd);
        $display(""@%0t: Coverage: src=%d. FWD=%0b"", $time, src, fwd);
        this.src = src;
        this.fwd = fwd;
        CG_Forward.sample();
    endfunction : sample
endclass : Coverage
```

This code is from a textbook explaining how to use Verilog for designing and debugging hardware systems, focusing on testbench blocks and functional coverage in this section.","
// Print the contents of the scoreboard, mainly for debugging
function void Scoreboard::display(input string prefix);
    $display(""%@t: %m so far %0d expected cells, %0d actual
rcvd"", $time, iexpect, iactual);
    foreach (expect_cells[i]) begin
        $display(""Tx[%0d]: exp=%0d, act=%0d"",
i, expect_cells[i].iexpect, expect_cells[i].iactual);
        foreach (expect_cells[i].q[j])
            expect_cells[i].q[j].display(
                $sformatf(""%$Scoreboard: Tx%0d: "", prefix, i));
    end
endfunction : display

Sample 11.24 shows the class used to gather functional coverage. Since the cov-
erage only looks at data in a single class, the cover group is defined and instantiated
inside the Coverage class. The data values are read by the class’s sample() method,
then the cover group’s sample() method is called to record the values.

Sample 11.24 Functional coverage class

class Coverage;
    bit [1:0] src;
    bit [NumTx-1:0] fwd;

    covergroup CG_Forward;
        coverpoint src
            {bins src[] = {[0:3]}; 
             option.weight = 0;}
        coverpoint fwd
            {bins fwd[] = {[1:15]}; // Ignore fwd==0
             option.weight = 0;}
        cross src, fwd;
    endgroup : CG_Forward

    function new();
        CG_Forward = new; // Instantiate the covergroup
    endfunction : new

    // Sample input data
    function void sample(input bit [1:0] src,
                         input bit [NumTx-1:0] fwd);
        $display(""@%0t: Coverage: src=%d. FWD=%0b"", $time, src, fwd);
        this.src = src;
        this.fwd = fwd;
        CG_Forward.sample();
    endfunction : sample
endclass : Coverage
","Caption: ""Excerpt from a book detailing Verilog testbench blocks and functional coverage class implementation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p320.jpg,True,"The image contains Verilog code. Here is the text version of it:

```verilog
class Generator;
  mailbox#(Transaction) gen2drv;
  Transaction blueprint;
  
  function new(input mailbox#(Transaction) gen2drv);
    this.gen2drv = gen2drv;
    blueprint = new();
  endfunction
  
  virtual task run(input int num_tr = 10);
    repeat(num_tr) begin
      'SV_RAND_CHECK(blueprint.randomize);
      gen2drv.put(blueprint.copy()); // Send copy to the driver
    end
  endtask
endclass
```","
class Generator;
  mailbox#(Transaction) gen2drv;
  Transaction blueprint;
  
  function new(input mailbox#(Transaction) gen2drv);
    this.gen2drv = gen2drv;
    blueprint = new();
  endfunction
  
  virtual task run(input int num_tr = 10);
    repeat(num_tr) begin
      'SV_RAND_CHECK(blueprint.randomize);
      gen2drv.put(blueprint.copy()); // Send copy to the driver
    end
  endtask
endclass
","""Verilog Generator Class Example Using the Blueprint Pattern""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p382.jpg,True,"The image contains a snippet of source code from a document. Here is the text version of the code from Figure 6 in the image:

```c
133 NTSTATUS
134 PptDispatchClose(PDEVICE_OBJECT DevObj, PIRP Irp) {
135   PDEVICE_EXTENSION pdx = DevObj->DeviceExtension;
136   if (pdx->parallelPortAllocated) {
137     PptFreePort(pdx->PortInfo);
138     pdx->parallelPortAllocated = FALSE;
139   }
140   else
141     return PptDispatchClose(DevObj, Irp);
```

Please note that this code is part of a discussion about a buggy Windows parallel port device driver, and the provided snippet may include an intentional code problem as part of the case study.","TSTATUS
134 PptDispatchClose(PDEVICE_OBJECT DevObj, PIRP Irp) {
135   PDEVICE_EXTENSION pdx = DevObj->DeviceExtension;
136   if (pdx->parallelPortAllocated) {
137     PptFreePort(pdx->PortInfo);
138     pdx->parallelPortAllocated = FALSE;
139   }
140   else
141     return PptDispatchClose(DevObj, Irp);
","Caption: Excerpt from an academic paper discussing the detection and repair of a bug in the Windows Parallel Port Device Driver, featuring a code snippet from the close dispatch routine in C language.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p334.jpg,True,"```verilog
virtual class BaseTr;
  static int count;             // Number of instance created
  int id;                       // Unique transaction id

  function new();
    id = count++;               // Give each object a unique ID
  endfunction

  pure virtual function bit compare(input BaseTr to);
  pure virtual function BaseTr copy(input BaseTr to=null);
  pure virtual function void display(input string prefix="""");
endclass : BaseTr
```","
virtual class BaseTr;
  static int count;             // Number of instance created
  int id;                       // Unique transaction id

  function new();
    id = count++;               // Give each object a unique ID
  endfunction

  pure virtual function bit compare(input BaseTr to);
  pure virtual function BaseTr copy(input BaseTr to=null);
  pure virtual function void display(input string prefix="""");
endclass : BaseTr
","Caption: ""Excerpt from a book discussing abstract classes and pure virtual methods in SystemVerilog, including a code sample of an abstract class with pure virtual methods.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p338.jpg,True,"The image shows a textbook or document page that includes Verilog code. Here is the code from the image:

```verilog
a22_non_proc: assert property (
  @(posedge e1) 1 |-> 
  @(posedge clk) d1 |=> (i3 || i4)
);

program prg();
  integer i;
  initial 
    for (i=0; i<8; i++) begin
      mod.vl1 = 1; #5;
      mod.vl1 = 0;
    end
endprogram

module mod(input sig2,clk);
  bit vl1,r11,r12;
  wire vl2;
  assign vl2 = sig2;
  always @(posedge vl1 or posedge vl2) begin: B1
    r11 = vl1 | vl2;
    a23: assert property (@(posedge clk) vl1 |=> vl2);
    r12 = vl1 & vl2;
  end
endmodule
```

This code is a small example of SystemVerilog, a hardware description and verification language used to model, design, simulate, test, and implement electronic systems.","
a22_non_proc: assert property (
  @(posedge e1) 1 |-> 
  @(posedge clk) d1 |=> (i3 || i4)
);

program prg();
  integer i;
  initial 
    for (i=0; i<8; i++) begin
      mod.vl1 = 1; #5;
      mod.vl1 = 0;
    end
endprogram

module mod(input sig2,clk);
  bit vl1,r11,r12;
  wire vl2;
  assign vl2 = sig2;
  always @(posedge vl1 or posedge vl2) begin: B1
    r11 = vl1 | vl2;
    a23: assert property (@(posedge clk) vl1 |=> vl2);
    r12 = vl1 & vl2;
  end
endmodule
","Caption: ""Excerpt from a textbook discussing evaluation considerations for assertions in Verilog HDL, showcasing example code fragments involving procedural assertions and signal triggering within a reactive region.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p449.jpg,True,"```c
int PLIbook_ScientificALU_misctf(int user_data, int reason, int paramvc)
{
    #define ALU_A        1 /* system task arg 1 is ALU A input */
    #define ALU_B        2 /* system task arg 2 is ALU B input */
    #define ALU_OP       3 /* system task arg 3 is ALU opcode input */
    #define ALU_RESULT   4 /* system task arg 4 is ALU result output */
    #define ALU_EXCEPT   5 /* system task arg 5 is ALU exception output */
    #define ALU_ERROR    6 /* system task arg 6 is ALU error output */

    double a, b, result;
    int opcode, excep, err;

    /* check if misctf was called for a task argument value change */
    if (reason == REASON_PARAMVC) {
        /* abort if task argument that changed was a model output */
        if (paramvc > ALU_OP) /* model outputs are after model inputs */
            return(0);
    }

    /* If the TF work area is null, then no misctf synchronize */
    /* callback has been scheduled for this time step (the work area */
    /* is set to non-null by this routine, and is set to null by the */
    /* misctf after a synchronize callback is processed. */
    if (tf_getworkarea() == NULL) {
        /* Schedule a synchronize callback to misctf for this instance */
        tf_synchronize();
        tf_setworkarea(""1""); /* set work area to non-null */
    }
    return(0);
}


/* check if misctf was called for end-of-time step synchronize */
if (reason == REASON_SYNCH) {
    /* Read current values of C model inputs from Verilog simulation */
    a = tf_getrealp(ALU_A);
    b = tf_getrealp(ALU_B);
    opcode = tf_getp(ALU_OP);

    /****** Call C model *******/
    PLIbook_ScientificALU_C_model(a, b, opcode, &result, &excep, &err);

    /* Write the C model outputs onto the Verilog signals */
    tf_putrealp(ALU_RESULT, result);
    tf_putp    (ALU_EXCEPT, excep);
    tf_putp    (ALU_ERROR, err);
    tf_setworkarea(NULL); /* set work area to null */
}
return(0);
}
```","LIbook_ScientificALU_misctf(int user_data, int reason, int paramvc)
{
    #define ALU_A        1 /* system task arg 1 is ALU A input */
    #define ALU_B        2 /* system task arg 2 is ALU B input */
    #define ALU_OP       3 /* system task arg 3 is ALU opcode input */
    #define ALU_RESULT   4 /* system task arg 4 is ALU result output */
    #define ALU_EXCEPT   5 /* system task arg 5 is ALU exception output */
    #define ALU_ERROR    6 /* system task arg 6 is ALU error output */

    double a, b, result;
    int opcode, excep, err;

    /* check if misctf was called for a task argument value change */
    if (reason == REASON_PARAMVC) {
        /* abort if task argument that changed was a model output */
        if (paramvc > ALU_OP) /* model outputs are after model inputs */
            return(0);
    }

    /* If the TF work area is null, then no misctf synchronize */
    /* callback has been scheduled for this time step (the work area */
    /* is set to non-null by this routine, and is set to null by the */
    /* misctf after a synchronize callback is processed. */
    if (tf_getworkarea() == NULL) {
        /* Schedule a synchronize callback to misctf for this instance */
        tf_synchronize();
        tf_setworkarea(""1""); /* set work area to non-null */
    }
    return(0);
}


/* check if misctf was called for end-of-time step synchronize */
if (reason == REASON_SYNCH) {
    /* Read current values of C model inputs from Verilog simulation */
    a = tf_getrealp(ALU_A);
    b = tf_getrealp(ALU_B);
    opcode = tf_getp(ALU_OP);

    /****** Call C model *******/
    PLIbook_ScientificALU_C_model(a, b, opcode, &result, &excep, &err);

    /* Write the C model outputs onto the Verilog signals */
    tf_putrealp(ALU_RESULT, result);
    tf_putp    (ALU_EXCEPT, excep);
    tf_putp    (ALU_ERROR, err);
    tf_setworkarea(NULL); /* set work area to null */
}
return(0);
}
",Example of a Verilog PLI code that interfaces with a C model for a scientific arithmetic logic unit (ALU).,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p164.jpg,True,"The image contains Verilog code in the form of SystemVerilog assertions. Here is the code extracted from the image:

```verilog
Frame_to_IRDY: assert property (
    Frame_ |=> ![Frame_throughout IRDY_ [- > 1]
);
```

```verilog
Frame_check: assert property (frame_start) |=> 
    (!frame_end throughout (packet_sent [->16] ##1 !packet_sent)) ##1 frame_end;
```

These snippets are part of a larger context that discusses best practices in writing assertions and the use of certain operators in SystemVerilog assertions.","
Frame_to_IRDY: assert property (
    Frame_ |=> ![Frame_throughout IRDY_ [- > 1]
);


Frame_check: assert property (frame_start) |=> 
    (!frame_end throughout (packet_sent [->16] ##1 !packet_sent)) ##1 frame_end;
",Verilog Assertion Properties and Operators: Demonstrating the use of 'assert property' with 'throughout' operator in SystemVerilog for frame transmission checks.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p461.jpg,True,"The image contains Verilog code. Here it is:

```verilog
module test;
  reg [1:0] test_in;
  wire [1:0] test_out;
  buf2 u1 (test_in, test_out);
  initial
    begin
      test_in = 3;
      #50 $display(""in=%d, out=%d"", test_in, test_out);
    end
endmodule

module buf2 (in, out);
  input [1:0] in;
  output [1:0] out;
  wire [1:0] in, out;
  buf #5 n0 (out[0], in[0]);
  buf #7 n1 (out[1], in[1]);
endmodule
```","
module test;
  reg [1:0] test_in;
  wire [1:0] test_out;
  buf2 u1 (test_in, test_out);
  initial
    begin
      test_in = 3;
      #50 $display(""in=%d, out=%d"", test_in, test_out);
    end
endmodule

module buf2 (in, out);
  input [1:0] in;
  output [1:0] out;
  wire [1:0] in, out;
  buf #5 n0 (out[0], in[0]);
  buf #7 n1 (out[1], in[1]);
endmodule
",Chapter excerpt on ACC routines in Verilog and sample Verilog code for simulation.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p307.jpg,True,"The image contains excerpts of code which appear to be part of the descriptions of PLI (Programming Language Interface) routines used in Verilog simulations. Below is the code as presented in the image:

```c
#include ""veriuser.h""                    /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""                    /* IEEE 1364 PLI ACC routine library */
/**********************************************************************
* $pow application
**********************************************************************/
int PLIbook_pow_sizetf()
{
    return(32); /* $pow returns 32-bit values */
}

/**********************************************************************
* Checktf application
**********************************************************************/
int PLIbook_pow_checktf()
{
    static int valid_types[4] = {accReg, accIntegerVar, accConstant, 0};
    handle arg_handle;

    if (tf_nump() != 2) 
        tf_error(""$pow must have 2 arguments.\n"");
    else if (tf_typep(1) == tf_nullparam) 
        tf_error(""$pow arg 1 cannot be null.\n"");
    else if (tf_typep(2) == tf_nullparam) 
        tf_error(""$pow arg 2 cannot be null.\n"");
    else {
        arg_handle = acc_handle_tfarg(1);
        if (!acc_object_in_typelist(arg_handle, valid_types))
            tf_error(""$pow arg1 must be number, variable or net.\n"");
    }
}
```

This code includes two functions, `PLIbook_pow_sizetf` and `PLIbook_pow_checktf`, which are likely used to define a custom system function `$pow` for a Verilog HDL simulation, and ensure that the correct number and type of arguments are provided to the function. The comments and `#include` directives suggest that the code uses the IEEE 1364 PLI TF and ACC libraries.","ude ""veriuser.h""                    /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""                    /* IEEE 1364 PLI ACC routine library */
/**********************************************************************
* $pow application
**********************************************************************/
int PLIbook_pow_sizetf()
{
    return(32); /* $pow returns 32-bit values */
}

/**********************************************************************
* Checktf application
**********************************************************************/
int PLIbook_pow_checktf()
{
    static int valid_types[4] = {accReg, accIntegerVar, accConstant, 0};
    handle arg_handle;

    if (tf_nump() != 2) 
        tf_error(""$pow must have 2 arguments.\n"");
    else if (tf_typep(1) == tf_nullparam) 
        tf_error(""$pow arg 1 cannot be null.\n"");
    else if (tf_typep(2) == tf_nullparam) 
        tf_error(""$pow arg 2 cannot be null.\n"");
    else {
        arg_handle = acc_handle_tfarg(1);
        if (!acc_object_in_typelist(arg_handle, valid_types))
            tf_error(""$pow arg1 must be number, variable or net.\n"");
    }
}
","""Extract from a technical book detailing the interfacing of TF/ACC based PLI applications with Verilog simulators, including example Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p310.jpg,True,"The image includes some Verilog code. Here it is:

```verilog
a_disable: assert property(
    disable iff (reset)
    @(posedge clk) a |=> b
) else $error(""FAIL"");
```

This code is a simple concurrent assertion with a disable clause in Verilog.","
a_disable: assert property(
    disable iff (reset)
    @(posedge clk) a |=> b
) else $error(""FAIL"");
","""Example of a Verilog SystemVerilog Assertion (SVA) with a Disable Clause""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p313.jpg,True,"The image contains segments of code related to Verilog PLI (Programming Language Interface). Here's the code extracted from the image:

```verilog
{userfunction,
 /* type of PLI routine */
 0,
 /* user_data value */
 PLIbook_pow_checktf,
 /* checktf routine */
 PLIbook_pow_sizetf,
 /* sizetf routine */
 PLIbook_pow_calltf,
 /* calltf routine */
 PLIbook_pow_miscft,
 /* miscft routine */
 ""$pow"",
 /* system task/function name */
 1
 /* forward reference = true */
},

{0} /*** final entry must be 0 ***/
;

s_tfcell veriusertfs[] =
{
  {
    usertask,
    /* type of PLI routine */
    1,
    /* user_data value */
    0,
    /* checktf routine */
    PLIbook_ReadVector_calltf,
    /* calltf routine */
    0,
    /* miscft routine */
    ""$read_test_vector_bin"",
    /* system task/function name */
    1
    /* forward reference = true */
  },

  {usertask,
   /* type of PLI routine */
   2,
   /* user_data value */
   0,
   /* checktf routine */
   PLIbook_ReadVector_calltf,
   /* calltf routine */
   0,
   /* miscft routine */
   ""$read_test_vector_hex"",
   /* system task/function name */
   1
   /* forward reference = true */
  },
};
```

The code provided shows the structure defining user functions and tasks for interfacing with Verilog simulators using the PLI. The specific functions like `PLIbook_pow_checktf`, `PLIbook_pow_sizetf`, etc. are presumably defined elsewhere in the PLI application code.","
{userfunction,
 /* type of PLI routine */
 0,
 /* user_data value */
 PLIbook_pow_checktf,
 /* checktf routine */
 PLIbook_pow_sizetf,
 /* sizetf routine */
 PLIbook_pow_calltf,
 /* calltf routine */
 PLIbook_pow_miscft,
 /* miscft routine */
 ""$pow"",
 /* system task/function name */
 1
 /* forward reference = true */
},

{0} /*** final entry must be 0 ***/
;

s_tfcell veriusertfs[] =
{
  {
    usertask,
    /* type of PLI routine */
    1,
    /* user_data value */
    0,
    /* checktf routine */
    PLIbook_ReadVector_calltf,
    /* calltf routine */
    0,
    /* miscft routine */
    ""$read_test_vector_bin"",
    /* system task/function name */
    1
    /* forward reference = true */
  },

  {usertask,
   /* type of PLI routine */
   2,
   /* user_data value */
   0,
   /* checktf routine */
   PLIbook_ReadVector_calltf,
   /* calltf routine */
   0,
   /* miscft routine */
   ""$read_test_vector_hex"",
   /* system task/function name */
   1
   /* forward reference = true */
  },
};
","Caption: ""Example of Verilog PLI routine registration process highlighting the use of the user_data field.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p304.jpg,True,"The image contains Verilog code within the text. Here is the code provided in the image:

First example:
```verilog
module m4 (logic a, b, c, event ev1, ev2);
  a15: assert property(((a @ ev1) a) |-> ((a @ ev2) b));
  a16: assert property(((a @ ev1) b) or (a @ ev1) c));
endmodule
```

Second example:
```verilog
module m5 (logic a, b, event ev1, ev2);
  a17_illegal: assert property(
    ((a @ ev1) a) |-> ##2 ((a @ ev2) b)
  );
endmodule
```

Please note there seems to be a minor inconsistency in the provided code. The symbol @ is typically not used in this context in Verilog to denote event triggering. It is likely that this is an error in the representation of the code within the document. The correct symbol would be a single '@' sign for specifying an event control or '##' for specifying a cycle delay.","
module m4 (logic a, b, c, event ev1, ev2);
  a15: assert property(((a @ ev1) a) |-> ((a @ ev2) b));
  a16: assert property(((a @ ev1) b) or (a @ ev1) c));
endmodule


module m5 (logic a, b, event ev1, ev2);
  a17_illegal: assert property(
    ((a @ ev1) a) |-> ##2 ((a @ ev2) b)
  );
endmodule
","The image is a textbook page discussing details of clocks in Verilog, with specific focus on unclocked synchronizers and logical operators in Verilog assertions. It includes examples of Verilog code for asserting properties with events as clocks, and explains the legal and illegal usage of these constructions.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p308.jpg,True,"The image contains Verilog code. Here is the code written in the image:

```verilog
initial begin
  $display(""%0t: start fork...join example"", $time);
  fork
    begin
      #20 $display(""%0t: sequential A after #20"", $time);
      #20 $display(""%0t: sequential B after #20"", $time);
    end
    $display(""%0t: parallel start"", $time);
    #50 $display(""%0t: parallel after #50"", $time);
    begin
      #30 $display(""%0t: sequential after #30"", $time);
      #10 $display(""%0t: sequential after #10"", $time);
    end
  join // or join_any or join_none
  $display(""%0t: after join"", $time);
  #80 $display(""%0t: finish after #80"", $time);
end
```

The exercise involves determining the order and time of execution for each statement depending on whether a `join`, `join_none`, or `join_any` is used. Each branching behavior will affect the way the code after the `fork` is executed in Verilog simulation.","
initial begin
  $display(""%0t: start fork...join example"", $time);
  fork
    begin
      #20 $display(""%0t: sequential A after #20"", $time);
      #20 $display(""%0t: sequential B after #20"", $time);
    end
    $display(""%0t: parallel start"", $time);
    #50 $display(""%0t: parallel after #50"", $time);
    begin
      #30 $display(""%0t: sequential after #30"", $time);
      #10 $display(""%0t: sequential after #10"", $time);
    end
  join // or join_any or join_none
  $display(""%0t: after join"", $time);
  #80 $display(""%0t: finish after #80"", $time);
end
","""Verilog Exercise Demonstrating fork...join Construct Timing""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p158.jpg,True,"The image contains a snippet of Verilog code, which is part of a larger discussion on the non-consecutive goTo repetition operator in Verilog. Here is the code as shown:

```verilog
property abc;
    @(posedge clk) a |=> b [- > 2];
endproperty
```

The comments and annotations in the image provide context about the behavior of the [- > m] repetition operator and how it differs from the [= m] repetition operator. Furthermore, there is a log of some simulation results presented in a comment-style format, but this is not executable code.","
property abc;
    @(posedge clk) a |=> b [- > 2];
endproperty
","""Overview of the Non-consecutive GoTo Repetition Operator in Verilog with example code snippets and result logs""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p312.jpg,True,"The image contains two code snippets written in Verilog. Here are the contents of both:

First Code Snippet:
```verilog
1 property p_disable;
2   disable iff (reset) a |=> b;
3 endproperty
4 a_disable: assert property(
5   @(posedge clk) p_disable
6 ) else $error(""FAIL"");
```

Second Code Snippet:
```verilog
1 module m_default_disable(logic reset, a, b, clk);
2   default disable_iff reset;
3   a_disable: assert property(
4     @(posedge clk) a |=> b
5   ) else $error(""FAIL"");
6   a_override: assert property(
7     disable iff (1'b0)
8     @(posedge clk) reset |=> !reset
9   );
10 endmodule
```

These snippets demonstrate how to specify default disable conditions and override them in the Verilog hardware description language.","
1 property p_disable;
2   disable iff (reset) a |=> b;
3 endproperty
4 a_disable: assert property(
5   @(posedge clk) p_disable
6 ) else $error(""FAIL"");


1 module m_default_disable(logic reset, a, b, clk);
2   default disable_iff reset;
3   a_disable: assert property(
4     @(posedge clk) a |=> b
5   ) else $error(""FAIL"");
6   a_override: assert property(
7     disable iff (1'b0)
8     @(posedge clk) reset |=> !reset
9   );
10 endmodule
","""Excerpt from a document on Verilog discussing default disable conditions and presenting examples of Verilog code for assertions with disable clauses.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p478.jpg,True,"```verilog
import ""DPI-C"" pure function int factorial(input int i);
import ""DPI-C"" pure function real sin(input real in);

import ""DPI-C"" context task call_sv(bit [31:0] data);
```","
import ""DPI-C"" pure function int factorial(input int i);
import ""DPI-C"" pure function real sin(input real in);

import ""DPI-C"" context task call_sv(bit [31:0] data);
","""Importing C functions and context tasks into SystemVerilog using DPI-C""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p463.jpg,True,"The image contains some text and a snippet of Verilog code. Here's the code excerpt from the image:

```verilog
always @(posedge clock)
$read_test_vector(""vectors.pat"", input_bus);
```
This code is an example that demonstrates a system task within a Verilog block, which is always triggered at the positive edge of a clock signal. The system task `$read_test_vector` is being passed two arguments, a file name as a string (""vectors.pat"") and a signal (`input_bus`).","
always @(posedge clock)
$read_test_vector(""vectors.pat"", input_bus);
","""Guide to Using ACC Routines in Verilog with Code Example for Accessing Module Signals""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p474.jpg,True,"The image contains a snippet of Verilog code, which is provided below:

```verilog
module m(input logic i, c, output o);
  wire a = !i;
  global clocking @(posedge c); endclocking
```","
module m(input logic i, c, output o);
  wire a = !i;
  global clocking @(posedge c); endclocking
","""Verilog code snippet for global clocking in formal verification model""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p477.jpg,True,"Here is the Verilog code extracted from the image:

```verilog
`timescale 1ns / 1ns
module top;
    integer test;
    tri [1:0] results;

    addbit i1 (test[0], test[1], test[2], results[0], results[1]);

    initial
    begin
        test = 3'b000;
        #10 test = 3'b001;

        #10 $show_all_signals1(top);
        #10 $show_all_signals1(i1);

        #10 $stop;
        #10 $finish;
    end
endmodule

/*** An RTL level 1 bit adder model ***/
`timescale 1ns / 1ns
module addbit (a, b, ci, sum, co);
    input a, b, ci;
    output sum, co;

    wire a, b, ci;
    reg sum, co;

    always @(a or b or ci)
        {co, sum} = a + b + ci;

endmodule
``` 

This Verilog code consists of two modules: `top` and `addbit`. The `top` module appears to instantiate the `addbit` module and includes a test sequence within an `initial` block. The `addbit` module represents an RTL level 1-bit adder model.","
`timescale 1ns / 1ns
module top;
    integer test;
    tri [1:0] results;

    addbit i1 (test[0], test[1], test[2], results[0], results[1]);

    initial
    begin
        test = 3'b000;
        #10 test = 3'b001;

        #10 $show_all_signals1(top);
        #10 $show_all_signals1(i1);

        #10 $stop;
        #10 $finish;
    end
endmodule

/*** An RTL level 1 bit adder model ***/
`timescale 1ns / 1ns
module addbit (a, b, ci, sum, co);
    input a, b, ci;
    output sum, co;

    wire a, b, ci;
    reg sum, co;

    always @(a or b or ci)
        {co, sum} = a + b + ci;

endmodule
","Caption: ""Verilog Test Case and RTL Adder Model Example from a Textbook""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p460.jpg,True,"The image contains Verilog code. Here is the code that is visible in the image:

```verilog
always_busy: assume final (busy);

always_idle: assume final (idle);

m1: assume property (@(posedge clk) a |-> c);
m2: assume property (@(posedge clk) b |=> !c);
m3: assume property (@(posedge clk) a && b);
```

This code includes assumptions for a formal verification environment written in SystemVerilog, which is an extension of the Verilog hardware description language commonly used for formal verification in the design and verification of digital systems.","
always_busy: assume final (busy);

always_idle: assume final (idle);

m1: assume property (@(posedge clk) a |-> c);
m2: assume property (@(posedge clk) b |=> !c);
m3: assume property (@(posedge clk) a && b);
",The image contains a text excerpt discussing underapproximation and overconstraining in the context of Assertion-Based Formal Verification (FV) with examples of Verilog code illustrating contradictory assumptions.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p306.jpg,True,"```verilog
sequence s_reg_ack(event ev);
    @(ev) req ##1 ack;
endsequence
a_matched: assert property(
    @(posedge dclk)
    dvalid |-> 
    s_reg_ack(posedge rclk).matched
);
```
The image contains Verilog code related to sequence and property declaration in the context of hardware design using Verilog. The code snippet defines a sequence named `s_reg_ack` that detects a pattern where a request signal `req` is followed by an acknowledge signal `ack` one clock cycle later, triggered by an event `ev`. Then it defines an assertion `a_matched` that checks if, at the positive edge of `dclk` when `dvalid` is true, the sequence `s_reg_ack` occurs at the positive edge of `rclk`.","
sequence s_reg_ack(event ev);
    @(ev) req ##1 ack;
endsequence
a_matched: assert property(
    @(posedge dclk)
    dvalid |-> 
    s_reg_ack(posedge rclk).matched
);
","Caption: ""Example of Verilog assertion code and waveform for sequence matching in a system-level verification context.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p311.jpg,True,"The image contains a snippet of code defining a C struct that is likely to be used in the context of Verilog PLI (Programming Language Interface) applications. Here is the code excerpt from the image:

```c
typedef struct t_tfcell {
    short type;               /* one of the constants: usertask,
                                 userfunction, userrealfuntion */
    short data;               /* data passed to user routine */
    int (*checktf)();         /* pointer to the checktf routine */
    int (*sizetf)();          /* pointer to the sizetf routine */
    int (*calltf)();          /* pointer to the calltf routine */
    int (*misctf)();          /* pointer to the misctf routine */
    char *tfname;             /* name of the system task/function */
    int forwref;              /* usually set to 1 */
    char *tfveritool;         /* usually ignored */
    char *tferrmessage;       /* usually ignored */
} s_tfcell, *p_tfcell;
```

This typedef defines a structure `t_tfcell` which is most likely used to register user-defined tasks and functions with the Verilog simulator using the Verilog PLI. The commented sections provide a brief explanation of what each member of the struct should represent.","ef struct t_tfcell {
    short type;               /* one of the constants: usertask,
                                 userfunction, userrealfuntion */
    short data;               /* data passed to user routine */
    int (*checktf)();         /* pointer to the checktf routine */
    int (*sizetf)();          /* pointer to the sizetf routine */
    int (*calltf)();          /* pointer to the calltf routine */
    int (*misctf)();          /* pointer to the misctf routine */
    char *tfname;             /* name of the system task/function */
    int forwref;              /* usually set to 1 */
    char *tfveritool;         /* usually ignored */
    char *tferrmessage;       /* usually ignored */
} s_tfcell, *p_tfcell;
","""Verilog PLI Data Structure Definition and Field Descriptions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p322.jpg,True,"The image contains Verilog code in the text. Here is the code from the image:

```verilog
program automatic test;

Environment env;
initial begin
    env = new();
    env.build();    // Construct generator, etc.
    begin
        BadTr bad = new();     // Replace blueprint with
        env.gen.blueprint = bad; // the ""bad"" one
    end
    env.run();       // Run the test with BadTr
    env.wrap_up();   // Clean up afterwards
end
endprogram
```","
program automatic test;

Environment env;
initial begin
    env = new();
    env.build();    // Construct generator, etc.
    begin
        BadTr bad = new();     // Replace blueprint with
        env.gen.blueprint = bad; // the ""bad"" one
    end
    env.run();       // Run the test with BadTr
    env.wrap_up();   // Clean up afterwards
end
endprogram
","Caption: ""Example showing how to inject an extended transaction into a testbench in Verilog.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p339.jpg,True,"The image contains descriptions of C function prototypes which are likely used in conjunction with Verilog PLI (Programming Language Interface). However, the actual content of the functions is not provided, only the function signatures and their descriptions. Here are the function prototypes:

```c
void tf_multiply_long(low1, high1, low2, high2)
int *low1  // pointer to lower 32 bits of first operand.
int *high1 // pointer to upper 32 bits of first operand.
int low2   // lower 32 bits of second operand
int high2  // upper 32 bits of second operand

// The tf_multiply_long() routine multiplies two 64-bit values, and deposits the result back into the first operand.

void tf_divide_long(low1, high1, low2, high2)
int *low1  // pointer to lower 32 bits of first operand.
int *high1 // pointer to upper 32 bits of first operand.
int low2   // lower 32 bits of second operand
int high2  // upper 32 bits of second operand

// The tf_divide_long() routine divides two 64-bit values, and deposits the result into the first operand.

void tf_long_to_real(low, high, real)
int low    // lower (right-most) 32-bits of a 64-bit integer.
int high   // upper (left-most) 32-bits of a 64-bit integer.
double *real // pointer to a double precision variable.

// This routine converts a 64-bit value stored as a pair of C integers to a C double precision value.

void tf_real_to_long(real, low, high)
double real  // a double precision variable.
int *low     // pointer to a variable to receive the lower (right-most) 32-bits of a 64-bit integer.
int *high    // pointer to a variable to receive the upper (left-most) 32-bits of a 64-bit integer.

// The tf_real_to_long() routine converts a C double precision value to a 64-bit value stored in a pair of C integers.
```

Note that `tf_multiply_long`, `tf_divide_long`, `tf_long_to_real`, and `tf_real_to_long` are the name of the functions and they seem to be part of the Verilog PLI API which allows Verilog to interact with C functions.","tf_multiply_long(low1, high1, low2, high2)
int *low1  // pointer to lower 32 bits of first operand.
int *high1 // pointer to upper 32 bits of first operand.
int low2   // lower 32 bits of second operand
int high2  // upper 32 bits of second operand

// The tf_multiply_long() routine multiplies two 64-bit values, and deposits the result back into the first operand.

void tf_divide_long(low1, high1, low2, high2)
int *low1  // pointer to lower 32 bits of first operand.
int *high1 // pointer to upper 32 bits of first operand.
int low2   // lower 32 bits of second operand
int high2  // upper 32 bits of second operand

// The tf_divide_long() routine divides two 64-bit values, and deposits the result into the first operand.

void tf_long_to_real(low, high, real)
int low    // lower (right-most) 32-bits of a 64-bit integer.
int high   // upper (left-most) 32-bits of a 64-bit integer.
double *real // pointer to a double precision variable.

// This routine converts a 64-bit value stored as a pair of C integers to a C double precision value.

void tf_real_to_long(real, low, high)
double real  // a double precision variable.
int *low     // pointer to a variable to receive the lower (right-most) 32-bits of a 64-bit integer.
int *high    // pointer to a variable to receive the upper (left-most) 32-bits of a 64-bit integer.

// The tf_real_to_long() routine converts a C double precision value to a 64-bit value stored in a pair of C integers.
","Extract from 'The Verilog PLI Handbook': C routine prototypes for Verilog PLI to handle 64-bit multiplications, divisions, and type conversions between integer pairs and double-precision values.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p444.jpg,True,"The image contains Verilog SystemVerilog code related to a Scoreboard class used in testbench development. Here is the code from the image:

```verilog
class Expect_cells;
  NNI_cell q[$];
  int iexpect, iactual;
endclass : Expect_cells

class Scoreboard;
  Config cfg;
  Expect_cells expect_cells[];
  NNI_cell cellq[$];
  int iexpect, iactual;

  extern function new(Config cfg);
  extern virtual function void wrap_up();
  extern function void save_expected(UNI_cell ucell);
  extern function void check_actual(input NNI_cell c, input int portn);
  extern function void display(string prefix="""");
endclass : Scoreboard

function Scoreboard::new(input Config cfg);
  this.cfg = cfg;
  expect_cells = new[NumTx];
  foreach (expect_cells[i])
    expect_cells[i] = new();
endfunction : Scoreboard

function void Scoreboard::save_expected(input UNI_cell ucell);
  NNI_cell ncell = ucell.to_NNI;
  CellCfgType CellCfg = top.squat.lut.read(ncell.VPI);

  $display(""%0t: Scb save: VPI=%0x, Forward=%0b"",
    $time, ncell.VPI, CellCfg.FWD);
  ncell.display($sformatf(""%0t: Scb save: "", $time));

  // Find all Tx ports where this cell will be forwarded
  for (int i=0; i<NumTx; i++)
    if (CellCfg.FWD[i]) begin
      expect_cells[i].q.push_back(ncell); // Save cell in this q
      expect_cells[i].iexpect++;
      iexpect++;
    end
endfunction : save_expected
```

This code appears to be part of a testbench Scoreboard for tracking expected and actual values in a hardware verification setup. The Scoreboard class is used for comparing expected results with those that are actually observed during simulation. 

Please note, there might be some typos or contextual gaps as the image has been used as a reference for recapturing the code, and also there could be additional code that is not visible in the image provided.","
class Expect_cells;
  NNI_cell q[$];
  int iexpect, iactual;
endclass : Expect_cells

class Scoreboard;
  Config cfg;
  Expect_cells expect_cells[];
  NNI_cell cellq[$];
  int iexpect, iactual;

  extern function new(Config cfg);
  extern virtual function void wrap_up();
  extern function void save_expected(UNI_cell ucell);
  extern function void check_actual(input NNI_cell c, input int portn);
  extern function void display(string prefix="""");
endclass : Scoreboard

function Scoreboard::new(input Config cfg);
  this.cfg = cfg;
  expect_cells = new[NumTx];
  foreach (expect_cells[i])
    expect_cells[i] = new();
endfunction : Scoreboard

function void Scoreboard::save_expected(input UNI_cell ucell);
  NNI_cell ncell = ucell.to_NNI;
  CellCfgType CellCfg = top.squat.lut.read(ncell.VPI);

  $display(""%0t: Scb save: VPI=%0x, Forward=%0b"",
    $time, ncell.VPI, CellCfg.FWD);
  ncell.display($sformatf(""%0t: Scb save: "", $time));

  // Find all Tx ports where this cell will be forwarded
  for (int i=0; i<NumTx; i++)
    if (CellCfg.FWD[i]) begin
      expect_cells[i].q.push_back(ncell); // Save cell in this q
      expect_cells[i].iexpect++;
      iexpect++;
    end
endfunction : save_expected
","The image displays a textbook page with a section on ""Testbench Blocks"" showcasing a sample code of the Scoreboard class in Verilog, used for verification in digital design.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p450.jpg,True,"The image contains Verilog code. Here it is:

```verilog
program automatic test
#(parameter int NumRx = 4, parameter int NumTx = 4)
(Utopia.TB_Rx Rx[0:NumRx-1],
 Utopia.TB_Tx Tx[0:NumTx-1],
 cpu_ifc.Test_mif,
 input logic reset, clk);

`include ""environment.sv""
Environment env;

class Driver_cbs_drop extends Driver_cbs;
  virtual task pre_tx(input ATM_cell cell, ref bit drop);
    // Randomly drop 1 out of every 100 transactions
    drop = ($urandom_range(0,99) == 0);
  endtask
endclass

initial begin
  env = new(Rx, Tx, NumRx, NumTx, mif);
  env.gen_cfg();
  env.build();

  begin  // Create error injection callback
    Driver_cbs_drop dcd = new();
    env.drv.cbs.push_back(dcd); // Put into driver's Q
  end

  env.run();
  env.wrap_up();
end

endprogram // test
``` 

This snippet of code is meant to represent a test program in Verilog, which is likely part of a testbench for verification of hardware designs. The code shows the instantiation of an environment and the use of a callback to simulate errors, such as random drops in a communication link, to test the robustness of the hardware design.","
program automatic test
#(parameter int NumRx = 4, parameter int NumTx = 4)
(Utopia.TB_Rx Rx[0:NumRx-1],
 Utopia.TB_Tx Tx[0:NumTx-1],
 cpu_ifc.Test_mif,
 input logic reset, clk);

`include ""environment.sv""
Environment env;

class Driver_cbs_drop extends Driver_cbs;
  virtual task pre_tx(input ATM_cell cell, ref bit drop);
    // Randomly drop 1 out of every 100 transactions
    drop = ($urandom_range(0,99) == 0);
  endtask
endclass

initial begin
  env = new(Rx, Tx, NumRx, NumTx, mif);
  env.gen_cfg();
  env.build();

  begin  // Create error injection callback
    Driver_cbs_drop dcd = new();
    env.drv.cbs.push_back(dcd); // Put into driver's Q
  end

  env.run();
  env.wrap_up();
end

endprogram // test
","Caption: ""Example of a Verilog test program implementing a driver callback to randomly drop cells in an ATM switch simulation for test and verification purposes.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p166.jpg,True,"The image contains Verilog code, which is written in the context of SystemVerilog Assertions (SVA). Here is the code presented in the image:

```verilog
sequence stack;
    $fell(tack) ##0 ltack[*7];
endsequence

sequence smtrx;
    $fell (mtrx) ##0 (lmtrx[*9]) ;
endsequence

property pwin;
    @(posedge clk) $fell(bMode) |=> stack within smtrx;
endproperty
```

These snippets define sequences and a property for use in hardware verification, specifically for checking certain conditions in a clocked digital system.","
sequence stack;
    $fell(tack) ##0 ltack[*7];
endsequence

sequence smtrx;
    $fell (mtrx) ##0 (lmtrx[*9]) ;
endsequence

property pwin;
    @(posedge clk) $fell(bMode) |=> stack within smtrx;
endproperty
","Caption: ""Figure illustrating the `within` operator application in Verilog assertions with an example of protocol timing constraints for burst mode transactions.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p336.jpg,True,"The image displays a book page discussing ""Callbacks"" in the context of verification environments, likely related to hardware verification using a Hardware Description Language like SystemVerilog. Here is the code snippet found on the page:

```verilog
task Driver::run;
  forever begin
    ...
    <pre_callback>
    transmit(tr);
    <post_callback>
    ...
  end
endtask

task pre_callback;
  ...
endtask

task post_callback;
  ...
endtask
```

The code example illustrates the concept of inserting callback tasks (pre_callback and post_callback) around a transmit task (transmit(tr)) within an endless loop inside a run task of a Driver class. These placeholders represent points where additional functionality can be inserted without changing the main transmission logic.","
task Driver::run;
  forever begin
    ...
    <pre_callback>
    transmit(tr);
    <post_callback>
    ...
  end
endtask

task pre_callback;
  ...
endtask

task post_callback;
  ...
endtask
","Caption: ""Understanding Callbacks in a Verification Environment with Verilog Code Illustrations""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p138.jpg,True,"The image contains code written in SystemVerilog. Here it is:

```verilog
program automatic test;
    initial begin
        int count, a[] = '{9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
        count = a.sum with (item > 7);  // GOTCHA: expect 17, get 2
        $display(""\""a.sum with(item > 7)\"" returns %0d"", count);
    end
endprogram
```

And two ways to avoid the gotcha mentioned:

```verilog
count = a.sum with ((item > 7) ? item : 0 );
count = a.sum with ((item > 7) * item );
```","
program automatic test;
    initial begin
        int count, a[] = '{9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
        count = a.sum with (item > 7);  // GOTCHA: expect 17, get 2
        $display(""\""a.sum with(item > 7)\"" returns %0d"", count);
    end
endprogram


count = a.sum with ((item > 7) ? item : 0 );
count = a.sum with ((item > 7) * item );
","""An explanation of a common pitfall with the `.sum with()` method in Verilog for summing specific array elements.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p199.jpg,True,"The image contains a snippet of Verilog code. Here it is:

```verilog
sequence mclocks;
  @(posedge clk0) A ##1 @(posedge clk1) B;
  //  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
endsequence
```

This code snippet defines a sequence named `mclocks` which captures a pattern where event `A` is sampled at the rising edge of `clk0`, followed by event `B` being sampled at the next rising edge of `clk1`. The `##1` is a delay operator used in sequence expressions in SystemVerilog that specifies the number of clock cycles or time units between events in a temporal sequence, but in a multiply clocked domain, according to the note, it does not necessarily mean a delay of one clock cycle, it means a match of `A` at `posedge clk0`, and then the sequence ends at the nearest strictly subsequent `posedge clk1` with a match of `B`.","
sequence mclocks;
  @(posedge clk0) A ##1 @(posedge clk1) B;
  //  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
endsequence
","""Explanation of multiply clocked sequences in Verilog with a code example and timing diagram.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p108.jpg,True,"The image contains Verilog code. Here are the code excerpts written out for you:

For Example 3-38 SystemVerilog assertion for mutex write_en & read_en:
```verilog
property mutex (clk, reset_n, a, b);
    @(posedge clk) disable iff (reset_n) (!(a & b));
endproperty

assert_mutex: assert property (mutex(clk_a, master_rst_n, write_en, read_en));
```

For Example 3-39 SystemVerilog simple concurrent assertions:
```verilog
assert_mutex: assert property @(posedge clk_a)
    disable iff (master_reset_n) (!(write_n & read_en));
```

And for Example 3-40 SystemVerilog sequence expression with fixed delay:
```verilog
req ##3 ack
```","
property mutex (clk, reset_n, a, b);
    @(posedge clk) disable iff (reset_n) (!(a & b));
endproperty

assert_mutex: assert property (mutex(clk_a, master_rst_n, write_en, read_en));


assert_mutex: assert property @(posedge clk_a)
    disable iff (master_reset_n) (!(write_n & read_en));


req ##3 ack
","Caption: ""Excerpts from a text showing examples of SystemVerilog assertions and a SystemVerilog sequence with fixed delay syntax.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p104.jpg,True,"```verilog
always_comb begin
    if(sel) y = a; // 2-to-1 MUX
    else y = b;
end
```","
always_comb begin
    if(sel) y = a; // 2-to-1 MUX
    else y = b;
end
","Caption: ""Discussion on hidden design issues in Verilog due to 4-state logic and the challenges of X propagation in simulations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p487.jpg,True,"Here is the code extracted from the image:

```c
extern void sv_display();
svScope my_scope;

void save_my_scope() {
    my_scope = svGetScope();
}

void c_display() {
    // Print the current scope
    io_printf(""\nC: c_display called from scope %s\n"", svGetNameFromScope(svGetScope()));

    // Set a new scope
    svSetScope(my_scope);
    io_printf(""C: calling %s.sv_display\n"", svGetNameFromScope(svGetScope()));

    sv_display();
}
```

The code snippets are written in C with specific functions that appear to interact with SystemVerilog for simulation purposes, such as `svGetScope`, `svGetNameFromScope`, and `svSetScope`. These functions are used to manipulate and retrieve information about the scope of the functions within a simulation.","n void sv_display();
svScope my_scope;

void save_my_scope() {
    my_scope = svGetScope();
}

void c_display() {
    // Print the current scope
    io_printf(""\nC: c_display called from scope %s\n"", svGetNameFromScope(svGetScope()));

    // Set a new scope
    svSetScope(my_scope);
    io_printf(""C: calling %s.sv_display\n"", svGetNameFromScope(svGetScope()));

    sv_display();
}
","Caption: ""Example of C code interfacing with SystemVerilog to manipulate the scope context for imported routines.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p120.jpg,True,"```verilog
`define mem_cmd ((cbe_n == `MEM_READ)  || \
                 (cbe_n == `MEM_WRITE) || \
                 (cbe_n == `MEM_RD_MULTP) || \
                 (cbd_n == `MEM_RD_LINE) || \
                 (cbd_n == `MEM_WR_AND_INV))

sequence SERE_MEM_ADDR_PHASE = {frame_n; !frame_n && mem_cmd;};

property PCI_VALID_MEM_BURST_ENCODING =
  always ({SERE_MEM_ADDR_PHASE} |-> (!ad[0])) @ (posedge clk)
  abort !rst_n ;

assert PCI_VALID_MEM_BURST_ENCODING;
```
The code above is a Property Specification Language (PSL) assertion which is used for formal verification of hardware designs in Verilog. The assertion ensures that the memory command for a PCI bus is following the correct burst order encoding.","
`define mem_cmd ((cbe_n == `MEM_READ)  || \
                 (cbe_n == `MEM_WRITE) || \
                 (cbe_n == `MEM_RD_MULTP) || \
                 (cbd_n == `MEM_RD_LINE) || \
                 (cbd_n == `MEM_WR_AND_INV))

sequence SERE_MEM_ADDR_PHASE = {frame_n; !frame_n && mem_cmd;};

property PCI_VALID_MEM_BURST_ENCODING =
  always ({SERE_MEM_ADDR_PHASE} |-> (!ad[0])) @ (posedge clk)
  abort !rst_n ;

assert PCI_VALID_MEM_BURST_ENCODING;
","Caption: ""Verilog code defining a PSL assertion for PCI memory burst order with accompanying explanation of the assertion's functionality and PCI basic read transaction phases.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p134.jpg,True,"```verilog
typedef struct always_t {
    int active;
    handle clk_handle;
    char *instance;
    int clk;
} Always;

/****************************************
 * checktf routine to validate arguments
 ****************************************/
int assert_always_ck_checktf(char *user_data)
{
    if (tf_nump() != 1)
        tf_error(""$assert_always_ck only 1 argument;"");
    else if (tf_sizep(1) != 1)
        tf_error(""$assert_always_ck argument size!=1;"");
    return(0);
}

/***************************************
 * calltf routine with VCL for clock
 ***************************************/
int assert_always_ck_calltf(char *user_data)
{
    struct always_t *assertion;
    
    acc_initialize();
    assertion = (Always *) tf_getworkarea();
    
    if (assertion == NULL) {
        assertion = (Always *) calloc(1, sizeof(Always));
        assertion->clk_handle = acc_handle_tfarg(1);
        assertion->instance = tf_getinstance();
        assertion->active = 0;
    }
    
    assertion->clk = tf_getp(1) & 1;
    tf_setworkarea((char *) assertion);
    if (assertion->active == 0) {
        assertion->active = 1;
        acc_vcl_add(assertion->clk_handle, assert_always_ck_consumer,
                    char *) vcl_verilog_logic);
    }
}
```","
typedef struct always_t {
    int active;
    handle clk_handle;
    char *instance;
    int clk;
} Always;

/****************************************
 * checktf routine to validate arguments
 ****************************************/
int assert_always_ck_checktf(char *user_data)
{
    if (tf_nump() != 1)
        tf_error(""$assert_always_ck only 1 argument;"");
    else if (tf_sizep(1) != 1)
        tf_error(""$assert_always_ck argument size!=1;"");
    return(0);
}

/***************************************
 * calltf routine with VCL for clock
 ***************************************/
int assert_always_ck_calltf(char *user_data)
{
    struct always_t *assertion;
    
    acc_initialize();
    assertion = (Always *) tf_getworkarea();
    
    if (assertion == NULL) {
        assertion = (Always *) calloc(1, sizeof(Always));
        assertion->clk_handle = acc_handle_tfarg(1);
        assertion->instance = tf_getinstance();
        assertion->active = 0;
    }
    
    assertion->clk = tf_getp(1) & 1;
    tf_setworkarea((char *) assertion);
    if (assertion->active == 0) {
        assertion->active = 1;
        acc_vcl_add(assertion->clk_handle, assert_always_ck_consumer,
                    char *) vcl_verilog_logic);
    }
}
","""Verilog code example showing implementation of a callback mechanism with assertions for clock checking in Verilog designs.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p488.jpg,True,"This image contains text describing the use of certain functions within Verilog Programming Language Interface (PLI), specifically for the ACC (Access) library. It also includes a function prototype for configuring the ACC environment. Here is the information displayed in terms of code:

```c
bool acc_configure(config_param, value)
int config_param // One of the constants listed in table 15-1.
char *value      // configuration value as a character string.
```

The above snippet shows the function prototype for the `acc_configure` function in C language syntax, intended for use in Verilog PLI applications. The `config_param` is an integer that should correspond to one of the predefined constants and `value` is a pointer to a character string representing the configuration value.","acc_configure(config_param, value)
int config_param // One of the constants listed in table 15-1.
char *value      // configuration value as a character string.
","""Guidelines and configurations for using the ACC (Access) library in Verilog PLI (Programming Language Interface) applications.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p110.jpg,True,"Here is the Verilog code snippet from the image:

```verilog
typedef enum bit [2:0] {HOLD = 3'b001,   // 2-state type
                        LOAD = 3'b010,
                        STORE = 3'b100} states_t;

states_t state_e, nstate_e; // two enumerated variables
```","
typedef enum bit [2:0] {HOLD = 3'b001,   // 2-state type
                        LOAD = 3'b010,
                        STORE = 3'b100} states_t;

states_t state_e, nstate_e; // two enumerated variables
","Caption: ""Explanation of out-of-bounds assignments in Verilog enumerated types and potential issues with unitialized variables and type casting.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p661.jpg,True,"The image contains excerpts from a document, some of which include code snippets related to building Verilog PLI applications. Here are those snippets:

```
VPI_OBJECTS=show_value_vpi.o pow_vpi.o
```

```
VERIUSER_C=$(INCA_DIR)/src/veriuser.c
VERIUSER_O=$(TARGETDIR)/veriuser.o
```

```
PLI_OBJECTS=
```

There are placeholders (...) indicating omitted content and some instructions on how to add PLI objects that need to be compiled. There is also explanatory text on how to run NC-Verilog with PLI applications and details about dynamic and static linking of PLI applications to the simulation.","JECTS=show_value_vpi.o pow_vpi.o

ER_C=$(INCA_DIR)/src/veriuser.c
VERIUSER_O=$(TARGETDIR)/veriuser.o

JECTS=
","""Document detailing the process of linking PLI applications to Verilog simulators and steps to run NC-Verilog with PLI applications.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p107.jpg,True,"The image shows a textbook page discussing ""How to Use the VPI Routines"" which is likely a part of documentation or a book on Verilog Programming Interface (VPI) routines. The page contains code. Here's the code as shown in the image:

```c
/* check that there is only 1 system task argument */
arg_handle = vpi_scan(arg_iterator);
if (arg_handle != NULL) {
    vpi_printf(""ERROR: $show_all_signals can only have 1 argument\n"");
    vpi_free_object(arg_iterator); /* free iterator memory */
    tf_dofinish(); /* abort simulation */
    return(0);
}
return(0);
}

/*******************************************************************
* calltf routine
*******************************************************************/
int PLIbook_ShowSignals_calltf(char *user_data)
{
vpiHandle systf_handle, arg_iterator, scope_handle,
          signal_iterator;
int       format;
s_vpi_time current_time;

/* obtain a handle to the system task instance */
systf_handle = vpi_handle(vpiSysTfCall, NULL);

/* obtain handle to system task argument */
arg_iterator = vpi_iterate(vpiArgument, systf_handle);
if (arg_iterator == NULL) {
    /* no arguments -- use scope that called this application */
    scope_handle = vpi_handle(vpiScope, systf_handle);
}
else {
    /* compiletf has already verified arg is scope instance or null */
    scope_handle = vpi_scan(arg_iterator);
    vpi_free_object(arg_iterator); /* free iterator memory */
    if (vpi_get(vpiType, scope_handle) != vpiModule)
        /* arg isn't a module instance; assume it is null */
        scope_handle = vpi_handle(vpiScope, systf_handle);
}

/* read current simulation time */
current_time.type = vpiScaledRealTime;
vpi_get_time(systf_handle, &current_time);

vpi_printf(""\nAt time %2.2f, signals in scope %s:\n"",
           current_time.real,
           vpi_get_str(vpiFullName, scope_handle));

/* obtain handles to nets in module and read current value */
/* nets can only exist if scope is a module */
if (vpi_get(vpiType, scope_handle) == vpiModule) {
    signal_iterator = vpi_iterate(vpiNet, scope_handle);
    if (signal_iterator != NULL)
```

This code snippet is incomplete; it ends abruptly without including the entire routine. The code shown is for a function that is intended to be registered as a Verilog PLI calltf routine, used for interaction with Verilog simulations through the VPI interface.","eck that there is only 1 system task argument */
arg_handle = vpi_scan(arg_iterator);
if (arg_handle != NULL) {
    vpi_printf(""ERROR: $show_all_signals can only have 1 argument\n"");
    vpi_free_object(arg_iterator); /* free iterator memory */
    tf_dofinish(); /* abort simulation */
    return(0);
}
return(0);
}

/*******************************************************************
* calltf routine
*******************************************************************/
int PLIbook_ShowSignals_calltf(char *user_data)
{
vpiHandle systf_handle, arg_iterator, scope_handle,
          signal_iterator;
int       format;
s_vpi_time current_time;

/* obtain a handle to the system task instance */
systf_handle = vpi_handle(vpiSysTfCall, NULL);

/* obtain handle to system task argument */
arg_iterator = vpi_iterate(vpiArgument, systf_handle);
if (arg_iterator == NULL) {
    /* no arguments -- use scope that called this application */
    scope_handle = vpi_handle(vpiScope, systf_handle);
}
else {
    /* compiletf has already verified arg is scope instance or null */
    scope_handle = vpi_scan(arg_iterator);
    vpi_free_object(arg_iterator); /* free iterator memory */
    if (vpi_get(vpiType, scope_handle) != vpiModule)
        /* arg isn't a module instance; assume it is null */
        scope_handle = vpi_handle(vpiScope, systf_handle);
}

/* read current simulation time */
current_time.type = vpiScaledRealTime;
vpi_get_time(systf_handle, &current_time);

vpi_printf(""\nAt time %2.2f, signals in scope %s:\n"",
           current_time.real,
           vpi_get_str(vpiFullName, scope_handle));

/* obtain handles to nets in module and read current value */
/* nets can only exist if scope is a module */
if (vpi_get(vpiType, scope_handle) == vpiModule) {
    signal_iterator = vpi_iterate(vpiNet, scope_handle);
    if (signal_iterator != NULL)
","Caption: Excerpt from a textbook showing example usage of the Verilog Procedural Interface (VPI) routines, focusing on handling system task arguments and reading simulation time within a Verilog HDL environment.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p113.jpg,True,"The image contains a snippet of Verilog code, which is associated with the use of VPI routines. Here is the code transcribed from the image:

```verilog
s_vpi_value current_value;

while ( (signal_handle = vpi_scan(signal_iterator)) != NULL ) {
  signal_type = vpi_get(vpiType, signal_handle);
  switch (signal_type) {
    case vpiNet:
      current_value.format = vpiBinStrVal;
      vpi_get_value(signal_handle, &current_value);
      vpi_printf("" net %-10s value is %s (binary)\n"",
                 vpi_get_str(vpiName, signal_handle),
                 current_value.value.str);
      break;

    case vpiReg:
      current_value.format = vpiBinStrVal;
      vpi_get_value(signal_handle, &current_value);
      vpi_printf("" reg %-10s value is %s (binary)\n"",
                 vpi_get_str(vpiName, signal_handle),
                 current_value.value.str);
      break;

    case vpiIntegerVar:
      current_value.format = vpiIntVal;
      vpi_get_value(signal_handle, &current_value);
      vpi_printf("" integer %-10s value is %d (decimal)\n"",
                 vpi_get_str(vpiName, signal_handle),
                 current_value.value.integer);
      break;

    case vpiRealVar:
      current_value.format = vpiRealVal;
      vpi_get_value(signal_handle, &current_value);
      vpi_printf("" real %-10s value is %0.2f\n"",
                 vpi_get_str(vpiName, signal_handle),
                 current_value.value.real);
      break;

    case vpiTimeVar:
      current_value.format = vpiTimeVal;
      vpi_get_value(signal_handle, &current_value);
      vpi_printf("" time %-10s value is %x%x\n"",
                 vpi_get_str(vpiName, signal_handle),
                 current_value.value.time->high,
                 current_value.value.time->low);
      break;
  }
}
return;
```

This code shows how to use the VPI (Verilog Programming Interface) to retrieve information about different types of signals in a Verilog simulation environment.","
s_vpi_value current_value;

while ( (signal_handle = vpi_scan(signal_iterator)) != NULL ) {
  signal_type = vpi_get(vpiType, signal_handle);
  switch (signal_type) {
    case vpiNet:
      current_value.format = vpiBinStrVal;
      vpi_get_value(signal_handle, &current_value);
      vpi_printf("" net %-10s value is %s (binary)\n"",
                 vpi_get_str(vpiName, signal_handle),
                 current_value.value.str);
      break;

    case vpiReg:
      current_value.format = vpiBinStrVal;
      vpi_get_value(signal_handle, &current_value);
      vpi_printf("" reg %-10s value is %s (binary)\n"",
                 vpi_get_str(vpiName, signal_handle),
                 current_value.value.str);
      break;

    case vpiIntegerVar:
      current_value.format = vpiIntVal;
      vpi_get_value(signal_handle, &current_value);
      vpi_printf("" integer %-10s value is %d (decimal)\n"",
                 vpi_get_str(vpiName, signal_handle),
                 current_value.value.integer);
      break;

    case vpiRealVar:
      current_value.format = vpiRealVal;
      vpi_get_value(signal_handle, &current_value);
      vpi_printf("" real %-10s value is %0.2f\n"",
                 vpi_get_str(vpiName, signal_handle),
                 current_value.value.real);
      break;

    case vpiTimeVar:
      current_value.format = vpiTimeVal;
      vpi_get_value(signal_handle, &current_value);
      vpi_printf("" time %-10s value is %x%x\n"",
                 vpi_get_str(vpiName, signal_handle),
                 current_value.value.time->high,
                 current_value.value.time->low);
      break;
  }
}
return;
","""Excerpt from a guide on How to Use the VPI Routines in Verilog with example code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p104.jpg,True,"The image contains snippets of code within a textual explanation of assertions in Verilog. Here are the code snippets:

```verilog
function int quotient(int dividend, divisor);
    assume (divisor != 0) else $fatal(""Division by zero"");
    quotient = dividend / divisor;
endfunction
```

This is labeled as ""Fig. 4.14 Immediate assumption.""

And two other code snippets:

```verilog
mutex: assume final ((somehot0({read, write})))
    else $error(""read/write contention"");
```

This is an example of a ""Deferred Assumption.""

```verilog
stable_input: assume property ((@posedge clk) disable iff (rst)
    trig |=> $stable(sig))
    else $error(""sig is not stable"");
```

This is an example of a ""Concurrent Assumption.""","
function int quotient(int dividend, divisor);
    assume (divisor != 0) else $fatal(""Division by zero"");
    quotient = dividend / divisor;
endfunction


mutex: assume final ((somehot0({read, write})))
    else $error(""read/write contention"");


stable_input: assume property ((@posedge clk) disable iff (rst)
    trig |=> $stable(sig))
    else $error(""sig is not stable"");
","""Exploring Immediate, Deferred, and Concurrent Assumptions in Verilog Code for Hardware Design Verification""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p108.jpg,True,"The image contains two code samples that are part of Verilog exercises. Here is the transcription of both code samples:

### The first code sample:
```verilog
byte my_byte;
integer my_integer;
int my_int;
bit [15:0] my_bit;
shortint my_short_int1;
shortint my_short_int2;

my_integer = 32'b000_1111_xxxx_zzzz;
my_int = my_integer;
my_bit = 16'h8000;
my_short_int1 = my_bit;
my_short_int2 = my_short_int1-1;
```

Exercise questions for the first code sample:
a. What is the range of values my_byte can take?
b. What is the value of my_int in hex?
c. What is the value of my_bit in decimal?
d. What is the value of my_short_int1 in decimal?
e. What is the value of my_short_int2 in decimal?

### The second code sample:
```verilog
bit [7:0] my_mem[3];
logic [3:0] my_logicmem[4];
logic [3:0] my_logic;

my_mem = '{default:8'ha5};
my_logicmem = '{0,1,2,3};
my_logic = 4'hF;

// Evaluate the following statements in the given order and give the result for each assignment
a. my_mem[2] = my_logicmem[4];
b. my_logic = my_logicmem[4];
c. my_logicmem[3] = my_mem[3];
d. my_mem[3] = my_logic;
e. my_logic = my_logicmem[1];
f. my_logic = my_mem[1];
g. my_logic = my_logicmem[my_logicmem[4]];
```

Exercise questions for the second code sample instruct to evaluate assignments a through g in the given order and determine the results for each.","
byte my_byte;
integer my_integer;
int my_int;
bit [15:0] my_bit;
shortint my_short_int1;
shortint my_short_int2;

my_integer = 32'b000_1111_xxxx_zzzz;
my_int = my_integer;
my_bit = 16'h8000;
my_short_int1 = my_bit;
my_short_int2 = my_short_int1-1;


bit [7:0] my_mem[3];
logic [3:0] my_logicmem[4];
logic [3:0] my_logic;

my_mem = '{default:8'ha5};
my_logicmem = '{0,1,2,3};
my_logic = 4'hF;

// Evaluate the following statements in the given order and give the result for each assignment
a. my_mem[2] = my_logicmem[4];
b. my_logic = my_logicmem[4];
c. my_logicmem[3] = my_mem[3];
d. my_mem[3] = my_logic;
e. my_logic = my_logicmem[1];
f. my_logic = my_mem[1];
g. my_logic = my_logicmem[my_logicmem[4]];
","""Verilog Data Types and Variable Assignments Exercise Questions""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p358.jpg,True,"The image contains Verilog code which appears to be part of a document explaining a module for checking a simple bus protocol. Here's the Verilog code text extracted from the image:

```verilog
sequence data_transfer;
    ##2 ((dack__n==0) && (oe__n==0)) [*burstSize];
endsequence

sequence checkbMode;
    (!bMode) throughout data_transfer;
endsequence

property pbrule1;
    @(posedge clk) disable iff (rst) bMode_in |-> checkbMode;
endproperty
checkBurst: assert property(pbrule1) else $display($stime,,"" Burst Rule Violated"");
endmodule

module test_checkerModule;
    logic dataAck_, outputEn_, bMode, bMode_send, rst, clk;
    .............

    always @(posedge clk or negedge rst) begin
        if (!rst) begin
            dataAck_=1’b0; outputEn_=0; bMode=0;
        end

    /*Following block generates a 'bMode' that is Low for 2 clocks consecutively. If so, we send `bMode_send` to the checkerModule module. */
    always @(posedge clk && rst) begin
        if (!bMode) begin
            @(posedge clk);
            If (!bMode) bMode_send=bMode;
        end
    end
end
```

Please note there could be some minor typographical errors due to the OCR-like interpretation of the image. For instance, there may be differences in the use of upper and lower case (e.g., `If` vs. `if`), or the use of a character that is similar in appearance to another one (e.g., an apostrophe `'` instead of a backtick ``` ` ```). Always refer to the source material for the most accurate code.","
sequence data_transfer;
    ##2 ((dack__n==0) && (oe__n==0)) [*burstSize];
endsequence

sequence checkbMode;
    (!bMode) throughout data_transfer;
endsequence

property pbrule1;
    @(posedge clk) disable iff (rst) bMode_in |-> checkbMode;
endproperty
checkBurst: assert property(pbrule1) else $display($stime,,"" Burst Rule Violated"");
endmodule

module test_checkerModule;
    logic dataAck_, outputEn_, bMode, bMode_send, rst, clk;
    .............

    always @(posedge clk or negedge rst) begin
        if (!rst) begin
            dataAck_=1’b0; outputEn_=0; bMode=0;
        end

    /*Following block generates a 'bMode' that is Low for 2 clocks consecutively. If so, we send `bMode_send` to the checkerModule module. */
    always @(posedge clk && rst) begin
        if (!bMode) begin
            @(posedge clk);
            If (!bMode) bMode_send=bMode;
        end
    end
end

","Caption: ""Example Verilog code showcasing a SystemVerilog sequence, property, and testbench for a simple bus protocol checker module designed for PCI bus.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p370.jpg,True,"The image contains Verilog code. Here's the text from the code snippets visible in the image:

```verilog
`define MAX_SUM 256
checker c1 (logic[7:0] a, b);
logic [7:0] add;
always @ (posedge clk) begin
    add <= a + 1'b1;
end

p1: assert property (@ (posedge clk) add < `MAX_SUM);
p2: assert property (@ (posedge clk) clk a != b);

endchecker

module m(input logic rst, clk, logic en, logic[7:0] in1, in2, in_array [20:0]);
c1 check_outside(in1, in2); //Concurrent (static) instantiation of 'c1' checker

always @ (posedge clk) begin
    automatic logic [7:0] v1=0;
    if (en) begin
        c1 check_inside(in1, v1); //Procedural instantiation of 'c1'
    end
    for (int i = 0; i < 4; i++) begin
        v1 = v1+5;
        if (i != 2) begin
            c1 check_loop (in1, in_array[v1]); //Procedural (Loop) instantiation of 'c1'
        end
    end
end

endmodule: m
```

Please note that there may be some errors or missing context as this is just the visible code excerpt from the image.","
`define MAX_SUM 256
checker c1 (logic[7:0] a, b);
logic [7:0] add;
always @ (posedge clk) begin
    add <= a + 1'b1;
end

p1: assert property (@ (posedge clk) add < `MAX_SUM);
p2: assert property (@ (posedge clk) clk a != b);

endchecker

module m(input logic rst, clk, logic en, logic[7:0] in1, in2, in_array [20:0]);
c1 check_outside(in1, in2); //Concurrent (static) instantiation of 'c1' checker

always @ (posedge clk) begin
    automatic logic [7:0] v1=0;
    if (en) begin
        c1 check_inside(in1, v1); //Procedural instantiation of 'c1'
    end
    for (int i = 0; i < 4; i++) begin
        v1 = v1+5;
        if (i != 2) begin
            c1 check_loop (in1, in_array[v1]); //Procedural (Loop) instantiation of 'c1'
        end
    end
end

endmodule: m
","Caption: ""Excerpt from a technical document illustrating the rules for instantiating checkers in Verilog, along with example code demonstrating concurrent and procedural instantiation within a module.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p203.jpg,True,"The image contains excerpts from a document discussing SystemVerilog Assertions (SVA) for data intensive designs. There is Verilog code in the image, which is as follows:

```verilog
property p_control_all;
  @(posedge clk) ($rose (sipo_en) && reset_) |-> s_datafeeder ##1 s_control;
endproperty

property p_block;
  @(posedge clk)
  $fell (get_data) && $rose(done_frame) |-> (block == 4095);
endproperty

a_control_all: assert property(p_control_all);
c_control_all:
  cover property(p_control_all)block++;
  
a_block: assert property(p_block);
```

These code snippets define properties for assertions and coverage points in SystemVerilog meant to be interpreted by a hardware description and verification language for use in electronic system design and verification.","
property p_control_all;
  @(posedge clk) ($rose (sipo_en) && reset_) |-> s_datafeeder ##1 s_control;
endproperty

property p_block;
  @(posedge clk)
  $fell (get_data) && $rose(done_frame) |-> (block == 4095);
endproperty

a_control_all: assert property(p_control_all);
c_control_all:
  cover property(p_control_all)block++;
  
a_block: assert property(p_block);
","""Verilog code demonstrating the use of SystemVerilog assertions (SVA) for verifying data processing sequences in hardware designs.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p120.jpg,True,"The image contains Verilog code snippets. Here they are written out for you:

Sample 3.15:
```verilog
task many (input int a=1, b=2, c=3, d=4) ;
    $display(""%0d %0d %0d %0d"", a, b, c, d);
endtask

initial begin
    // a  b  c  d
    many(6, 7, 8, 9);  // 6  7  8  9  Specify all values
    many();            // 1  2  3  4  Use defaults
    many(.c(5));       // 1  2  5  4  Only specify c
    many(, 6, .d(8));  // 1  6  3  8  Mix styles
end
```

Sample 3.16:
```verilog
task sticky(int a, b);
```

Sample 3.17:
```verilog
task automatic sticky(ref int array[50],
                      int a, b); // What direction are these?
```

Sample 3.18:
```verilog
task automatic sticky(ref int array[50],
                      input int a, b); // Be explicit
```

These snippets demonstrate how to define tasks in Verilog, including passing arguments by name and handling common mistakes related to argument direction in task definitions.","
task many (input int a=1, b=2, c=3, d=4) ;
    $display(""%0d %0d %0d %0d"", a, b, c, d);
endtask

initial begin
    // a  b  c  d
    many(6, 7, 8, 9);  // 6  7  8  9  Specify all values
    many();            // 1  2  3  4  Use defaults
    many(.c(5));       // 1  2  5  4  Only specify c
    many(, 6, .d(8));  // 1  6  3  8  Mix styles
end


task sticky(int a, b);


task automatic sticky(ref int array[50],
                      int a, b); // What direction are these?


task automatic sticky(ref int array[50],
                      input int a, b); // Be explicit
",Verilog code examples demonstrating the use of default task arguments and common coding errors related to argument passing.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p416.jpg,True,"The image contains Verilog code, which is a hardware description language used to model electronic systems. Here is the code from the image:

```verilog
`ifdef check3
property checkPCI_Frame_Irdy;
    @(posedge clk) disable iff (!reset_)
        FRAME_I -> 'b1; // DUMMY - REMOVE this line and code correct
                      //assertion

endproperty

assert property (checkPCI_Frame_Irdy) else $display($stime,, ""CHECK3:checkPCI_frmIrdy FAIL\n"");
`endif

/* --------------------------------------------------------------

CHECK # 4. TRDY_ can be asserted (low) only if DEVSEL_
           is asserted (low)

-------------------------------------------------------------- */

`ifdef check4
property checkPCI_trdyDevsel;
    @(posedge clk) disable iff (!reset_)
        FRAME_I -> 'b1; // DUMMY - REMOVE this line and code correct
                      //assertion

endproperty

assert property (checkPCI_trdyDevsel) else $display($stime,, ""CHECK4:checkPCI_trdyDevsel FAIL\n"");
`endif

/* --------------------------------------------------------------

CHECK # 5. Once the cycle starts (i.e. at FRAME_ assertion)
           C_BE_ should not float until FRAME_ is de-asserted

-------------------------------------------------------------- */

`ifdef check5
property checkPCI_CBE_during_trx;
    @(posedge clk) disable iff (!reset_)
        FRAME_I -> 'b1; // DUMMY - REMOVE this line and code correct
                      //assertion

endproperty

assert property (checkPCI_CBE_during_trx) else $display($stime,, ""CHECK5:checkPCI_CBE_during_trx FAIL\n"");
`endif
endmodule
```

This code snippet shows that there are conditional compilation blocks (with `ifdef...endif`) that define properties and assertions most likely to be used for formal verification or simulation. It includes dummy lines with a comment indicating they need to be removed and the correct code added. Each property is intended to check different conditions likely associated with the PCI (Peripheral Component Interconnect) protocol, and the assertions verify that these properties hold true during simulation; if not, a fail message is displayed.","
`ifdef check3
property checkPCI_Frame_Irdy;
    @(posedge clk) disable iff (!reset_)
        FRAME_I -> 'b1; // DUMMY - REMOVE this line and code correct
                      //assertion

endproperty

assert property (checkPCI_Frame_Irdy) else $display($stime,, ""CHECK3:checkPCI_frmIrdy FAIL\n"");
`endif

/* --------------------------------------------------------------

CHECK # 4. TRDY_ can be asserted (low) only if DEVSEL_
           is asserted (low)

-------------------------------------------------------------- */

`ifdef check4
property checkPCI_trdyDevsel;
    @(posedge clk) disable iff (!reset_)
        FRAME_I -> 'b1; // DUMMY - REMOVE this line and code correct
                      //assertion

endproperty

assert property (checkPCI_trdyDevsel) else $display($stime,, ""CHECK4:checkPCI_trdyDevsel FAIL\n"");
`endif

/* --------------------------------------------------------------

CHECK # 5. Once the cycle starts (i.e. at FRAME_ assertion)
           C_BE_ should not float until FRAME_ is de-asserted

-------------------------------------------------------------- */

`ifdef check5
property checkPCI_CBE_during_trx;
    @(posedge clk) disable iff (!reset_)
        FRAME_I -> 'b1; // DUMMY - REMOVE this line and code correct
                      //assertion

endproperty

assert property (checkPCI_CBE_during_trx) else $display($stime,, ""CHECK5:checkPCI_CBE_during_trx FAIL\n"");
`endif
endmodule
","Verilog assertions for checking PCI frame ready, target ready and command/byte enable signals.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p134.jpg,True,"The image contains Verilog code which is spread across three samples (4.5, 4.6, and 4.7). Here is the code:

---

**Sample 4.5 - Arbiter using a simple interface**
```verilog
module arb_with_ifc (arb_if arbif);
always @(posedge arbif.clk or posedge arbif.rst)
    begin
        if (arbif.rst)
            arbif.grant <= '0';
        else if (arbif.request[0])         // High priority
            arbif.grant <= 2'b01;
        else if (arbif.request[1])         // Low priority
            arbif.grant <= 2'b10;
        else
            arbif.grant <= '0';
    end
endmodule
```

**Sample 4.6 - Testbench using a simple arbiter interface**
```verilog
module test_with_ifc (arb_if arbif);
initial begin
    @(posedge arbif.clk);
    arbif.request <= 2'b01;
    $display(""%0t: Drove req=01"", $time);
    repeat (2) @(posedge arbif.clk);
    if (arbif.grant != 2'b01)
        $display(""%0t: Error: grant != 2'b01"", $time);
    $finish;
end
endmodule
```

**Sample 4.7 - Top module with a simple arbiter interface**
```verilog
module top;
bit clk;
always #50 clk = ~clk;

arb_if arbif(clk);                    // From Sample 4-4
arb_with_ifc a1 (arbif);              // From Sample 4-5
test_with_ifc t1(arbif);              // From Sample 4-6
endmodule : top
```

--- 

These code samples demonstrate how to connect a testbench and a design using a simple arbiter interface in Verilog. The interface (`arb_if`) is not shown in the image but is referenced in the code.","
module arb_with_ifc (arb_if arbif);
always @(posedge arbif.clk or posedge arbif.rst)
    begin
        if (arbif.rst)
            arbif.grant <= '0';
        else if (arbif.request[0])         // High priority
            arbif.grant <= 2'b01;
        else if (arbif.request[1])         // Low priority
            arbif.grant <= 2'b10;
        else
            arbif.grant <= '0';
    end
endmodule


module test_with_ifc (arb_if arbif);
initial begin
    @(posedge arbif.clk);
    arbif.request <= 2'b01;
    $display(""%0t: Drove req=01"", $time);
    repeat (2) @(posedge arbif.clk);
    if (arbif.grant != 2'b01)
        $display(""%0t: Error: grant != 2'b01"", $time);
    $finish;
end
endmodule


module top;
bit clk;
always #50 clk = ~clk;

arb_if arbif(clk);                    // From Sample 4-4
arb_with_ifc a1 (arbif);              // From Sample 4-5
test_with_ifc t1(arbif);              // From Sample 4-6
endmodule : top
","""Examples of Verilog code demonstrating an arbiter module, a testbench, and a top module with a simple arbiter interface.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p138.jpg,True,"The image includes Verilog assertion code examples. Here they are:

First code example:
```verilog
a1: assert property (@(posedge clk) req |=> s_eventually gnt);
```

Second code example:
```verilog
a1: assert property (@(posedge clk) req |-> !data_ready_until_with_ack);
```","
a1: assert property (@(posedge clk) req |=> s_eventually gnt);


a1: assert property (@(posedge clk) req |-> !data_ready_until_with_ack);
","""Exploring Assertions and Implications in Verilog for Hardware Verification""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p364.jpg,True,"```verilog
checker myCheck;
    bit myBit;
    initial begin myBit=1'b1; // 'initial' assignment to a variable is ILLEGAL
    end
endchecker

checker myCheck;
    bit myBit=1'b1; //This is Legal
endchecker

checker myCheck (a, b, c);
    bit myBit;
    ....
endchecker

module myMod;
    ...
    mycheck mck1(a, b, c);
    $display(mck1.myBit); //Hierarchical reference to checker variable is ILLEGAL
endmodule
```","
checker myCheck;
    bit myBit;
    initial begin myBit=1'b1; // 'initial' assignment to a variable is ILLEGAL
    end
endchecker

checker myCheck;
    bit myBit=1'b1; //This is Legal
endchecker

checker myCheck (a, b, c);
    bit myBit;
    ....
endchecker

module myMod;
    ...
    mycheck mck1(a, b, c);
    $display(mck1.myBit); //Hierarchical reference to checker variable is ILLEGAL
endmodule
","Caption: ""Verilog code examples illustrating illegal and legal usages of checker constructs in hardware design verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p322.jpg,True,"The image contains some explanation about the `assert_range` assertion in Verilog and an example piece of Verilog code. Below is the code from the image:

```verilog
module counter_1_to_9 (reset_n, clk, inc, dec) ;
  input reset_n, clk, inc, dec;
  reg [3:0] count;

  always @ (posedge clk) begin
    if (reset_n) count = 4'b1;
    else count = count + inc - dec;
  end
  // OVL check for valid range 1 thru 9
  assert_range # (0,4,1,9) count_range_check (clk, reset_n, count);
endmodule
```","
module counter_1_to_9 (reset_n, clk, inc, dec) ;
  input reset_n, clk, inc, dec;
  reg [3:0] count;

  always @ (posedge clk) begin
    if (reset_n) count = 4'b1;
    else count = count + inc - dec;
  end
  // OVL check for valid range 1 thru 9
  assert_range # (0,4,1,9) count_range_check (clk, reset_n, count);
endmodule
","""Verilog code example demonstrating the use of assert_range to monitor a counter's range.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p336.jpg,True,"The image contains a code snippet which is written in Verilog. Here is the code excerpt from the image:

```verilog
module division_with_check (clk, reset_n, a, b, start, done);
    input clk, reset_n;
    input [15:0] a, b;
    input start;
    output done;

    wire [15:0] q, r;

    div16 #(16) div01 (clk, reset_n, start, a, b, q, r, done);

    assert_unchange #(0,16,16) div_unchange_a (clk, reset_n, start == 1, a);
endmodule
```

The code defines a Verilog module named `division_with_check` and includes an instantiation of a `div16` module with an instance name `div01`, as well as an `assert_unchange` instance named `div_unchange_a`.","
module division_with_check (clk, reset_n, a, b, start, done);
    input clk, reset_n;
    input [15:0] a, b;
    input start;
    output done;

    wire [15:0] q, r;

    div16 #(16) div01 (clk, reset_n, start, a, b, q, r, done);

    assert_unchange #(0,16,16) div_unchange_a (clk, reset_n, start == 1, a);
endmodule
","""Verilog example demonstrating assert_unchange and a reference to OVL assert_no_transition for state transition checking.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p715.jpg,True,"The image contains segments of text describing certain Verilog VPI (Verilog Programming Interface) routine definitions. The passage starts with the declaration of a function `vpi_chk_error` and a C `struct` definition `t_vpi_error_info`. Here's the code extracted from the image:

```c
int vpi_chk_error(info)
p_vpi_error_info info

typedef struct t_vpi_error_info {
    int state;    /* vpiCompile, vpiPLI, vpiRun */
    int level;    /* vpiNotice, vpiWarning, vpiError, 
                     vpiSystem, vpiInternal */
    char *message;
    char *product;
    char *code;
    char *file;
    int line;
} s_vpi_error_info, *p_vpi_error_info;
```

The image also contains definitions for `vpi_compare_objects`, `vpi_free_object`, and `vpi_get` functions, but their corresponding function prototypes or signatures are partially visible. 

Please note that the code I've provided may need some context to fully understand, as it seems that these are just examples of how the functions and data structures are defined in a Verilog VPI application and are part of larger documentation.","pi_chk_error(info)
p_vpi_error_info info

typedef struct t_vpi_error_info {
    int state;    /* vpiCompile, vpiPLI, vpiRun */
    int level;    /* vpiNotice, vpiWarning, vpiError, 
                     vpiSystem, vpiInternal */
    char *message;
    char *product;
    char *code;
    char *file;
    int line;
} s_vpi_error_info, *p_vpi_error_info;
",Documentation of VPI routine definitions from the IEEE 1364-1995 Verilog standard.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p238.jpg,True,"The image contains several snippets of Verilog code. Here they are:

```verilog
sequence IRDY;
    IRDY_start ##2 IRDY_end;
endsequence

sequence Frame_;
    Frame_start ##[1:16] Frame_end;
endsequence

busyPr: assert property (@(posedge clk)
    IRDY |-> !Tabort until Frame_.triggered);

logic x, y, z;
//...
Xillegal: assert property (@(posedge clk)
    z |-> (x ## 3).triggered ); //ILLEGAL

sequence clk1Seq;
    @(posedge clk1) x ##2 y;
endsequence

Zillegal:assertproperty(@(posedgeclk) z|->clk1Seq.triggered); //ILLEGAL

default clocking @(posedge clk); endclocking

sequence ab;
    a ##2 b;
endsequence

sequence cd;
    c ##2 d;
endsequence
```

These code snippets are examples of system verilog assertions and sequences. The comments ""//ILLEGAL"" in the code indicate that these specific assertions or their usage are not valid according to the SystemVerilog standard.","
sequence IRDY;
    IRDY_start ##2 IRDY_end;
endsequence

sequence Frame_;
    Frame_start ##[1:16] Frame_end;
endsequence

busyPr: assert property (@(posedge clk)
    IRDY |-> !Tabort until Frame_.triggered);

logic x, y, z;
//...
Xillegal: assert property (@(posedge clk)
    z |-> (x ## 3).triggered ); //ILLEGAL

sequence clk1Seq;
    @(posedge clk1) x ##2 y;
endsequence

Zillegal:assertproperty(@(posedgeclk) z|->clk1Seq.triggered); //ILLEGAL

default clocking @(posedge clk); endclocking

sequence ab;
    a ##2 b;
endsequence

sequence cd;
    c ##2 d;
endsequence
","Caption: ""Examples and explanations of legal and illegal uses of the `.triggered` method in Verilog Assertions (SVA).""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p72.jpg,True,"The image contains a snippet of code related to Verilog, a hardware description language. Here is the code from the image:

```verilog
// Example of less efficient code:
r_b[15:8]<=8'h00;

// Example of more efficient code:
r_b <= r_b & 24'hff00ff;
``` 

The examples are showing different styles of assigning values to parts of a bus in Verilog and are recommending the use of bitwise operations for efficiency in simulation code.","
// Example of less efficient code:
r_b[15:8]<=8'h00;

// Example of more efficient code:
r_b <= r_b & 24'hff00ff;
","""Chapter excerpt on Verilog linter error, warning, and advisory messages with examples of code practices for efficient simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p204.jpg,True,"The image contains Verilog code. Here are the code excerpts:

For the ""or"" operator:

```verilog
property mclocks;
    @(posedge clk1) b or @(posedge clk2) c;
endproperty

baseP: assert property (@(posedge clk0) a |=> mclocks) else gotoFail;
coverP: cover property (@(posedge clk0) a |=> mclocks) gotoPass;
```

For the ""not"" operator:

```verilog
property mclocks;
    @(posedge clk1) b and (not(@(posedge clk2) c));
endproperty

baseP: assert property (@(posedge clk0) a |=> mclocks) else gotoFail;
coverP: cover property (@(posedge clk0) a |=> mclocks) gotoPass;
```","
property mclocks;
    @(posedge clk1) b or @(posedge clk2) c;
endproperty

baseP: assert property (@(posedge clk0) a |=> mclocks) else gotoFail;
coverP: cover property (@(posedge clk0) a |=> mclocks) gotoPass;


property mclocks;
    @(posedge clk1) b and (not(@(posedge clk2) c));
endproperty

baseP: assert property (@(posedge clk0) a |=> mclocks) else gotoFail;
coverP: cover property (@(posedge clk0) a |=> mclocks) gotoPass;
","""Examples of using 'or' and 'not' operators in multiply clocked properties in Verilog for system verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p295.jpg,True,"Here are the code snippets from the image:

PSL (Property Specification Language) code from Example 8-22:
```verilog
property DifferentAddr =
  always (write_valid -> next (addr != prev(addr)));
assert DifferentAddr;
```

SystemVerilog code from Example 8-23:
```verilog
property DifferentAddr;
  reg [15:0] last_addr;
  @(posedge clk) write_valid, last_addr=addr
    |=> write_valid[-1] ##0 addr != last_addr;
endproperty
assert property (DifferentAddr);
```

These snippets provide two examples of how to specify a property that two consecutive writes cannot be to the same address, using PSL and SystemVerilog.","
property DifferentAddr =
  always (write_valid -> next (addr != prev(addr)));
assert DifferentAddr;


property DifferentAddr;
  reg [15:0] last_addr;
  @(posedge clk) write_valid, last_addr=addr
    |=> write_valid[-1] ##0 addr != last_addr;
endproperty
assert property (DifferentAddr);
","Caption: ""Examples of Property Specification Language (PSL) and SystemVerilog assertions for ensuring two consecutive write operations do not target the same memory address in a hardware design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p729.jpg,True,"The image contains a snippet of text that includes a piece of code related to Verilog, particularly from the IEEE 1364-1995 TF Routine Library. Here is the code from the image:

```c
typedef struct t_vecval {
    int avalbits; /* aval/bval encoding: 0/0 == 0, */
    int bvalbits; /* 1/0 == 1, 0/1 == Z, 1/1 == X */
} s_vecval, *p_vecval;
```

Moreover, the image includes function prototype descriptions for Verilog PLI (Programming Language Interface) routines, such as `tf_getcstringp`, `tf_getinstance`, `tf_getlongp`, and `tf_getlongtime`, although their actual function implementations are not displayed. These routines are used for getting specific information within Verilog simulations, such as string arguments, instance pointers, 64-bit integer values, and simulation times.","ef struct t_vecval {
    int avalbits; /* aval/bval encoding: 0/0 == 0, */
    int bvalbits; /* 1/0 == 1, 0/1 == Z, 1/1 == X */
} s_vecval, *p_vecval;
","Caption: ""Excerpt from the IEEE 1364-1995 Standard defining TF routine library functions in Verilog for accessing simulation time and argument values.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p83.jpg,True,"The image contains Verilog code. Here are the code snippets:

For the Overlapping Operator:

```verilog
property pr1;
    @(posedge clk) cStart |-> (req ##2 gnt);
endproperty

baseP: assert property (pr1);
```

For the Non-Overlapping Operator:

```verilog
property pr1;
    @(posedge clk) cStart |=> (req ##2 gnt);
endproperty

baseP: assert property (pr1);
```","
property pr1;
    @(posedge clk) cStart |-> (req ##2 gnt);
endproperty

baseP: assert property (pr1);


property pr1;
    @(posedge clk) cStart |=> (req ##2 gnt);
endproperty

baseP: assert property (pr1);
",Verilog assertion properties using overlapping and non-overlapping implication operators.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p97.jpg,True,"The image provided contains the following Verilog code:

```verilog
assign clkstart = clk && cGate;

sequence sr1;
  req ##2 gnt;
endsequence

property pr1;
  @(posedge clkstart) start |-> sr1;
endproperty

reqGnt: assert property (pr1);
```

This code snippet appears to be related to gated clocking and concurrent assertions in SystemVerilog.","
assign clkstart = clk && cGate;

sequence sr1;
  req ##2 gnt;
endsequence

property pr1;
  @(posedge clkstart) start |-> sr1;
endproperty

reqGnt: assert property (pr1);
",Caption: Excerpt from a technical document illustrating a gated clock signal and its use in Verilog assertions for modeling asynchronous events.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p281.jpg,True,"The image contains two examples of SystemVerilog assertion properties. Here are the code excerpts from the image:

Example 7-72:
```verilog
property not_storedata_unknown;
    @(posedge clk) not (~ce_n & ~we_n) ##0 $isunknown(wdata));
endproperty
assert property (not_storedata_unknown)
    else $error(""Unknown write data presented for operation."");
```

Example 7-73:
```verilog
property not_readdata_unknown;
    @(posedge clk) not (~ce_n & ~rd_n) ##0 $isunknown(data));
endproperty
assert property (not_readdata_unknown)
    else $error(""Unknown data returned for read operation."");
```

These properties are meant to ensure that unknown data (`'X'` values in digital logic, which represent an indeterminate state) are not written to or read from memory, which is essential for avoiding unpredictable behavior in hardware designs.","
property not_storedata_unknown;
    @(posedge clk) not (~ce_n & ~we_n) ##0 $isunknown(wdata));
endproperty
assert property (not_storedata_unknown)
    else $error(""Unknown write data presented for operation."");


property not_readdata_unknown;
    @(posedge clk) not (~ce_n & ~rd_n) ##0 $isunknown(data));
endproperty
assert property (not_readdata_unknown)
    else $error(""Unknown data returned for read operation."");
","""SystemVerilog Assertions for Handling Unknown Data in Memory Operations""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p170.jpg,True,"The image contains Verilog code. Here is the code extracted from the image:

```verilog
initial
  begin
    Reset = 1'b0;
    #0 Reset = 1'b1;
    ...
  end
always@(ClockIn, Reset)
  if (Reset==1'b0)
    Abus <= 1'b0;
  else Abus <= Inbus;
```","
initial
  begin
    Reset = 1'b0;
    #0 Reset = 1'b1;
    ...
  end
always@(ClockIn, Reset)
  if (Reset==1'b0)
    Abus <= 1'b0;
  else Abus <= Inbus;
","Caption: ""Understanding race conditions in Verilog initial and always blocks and the impact on synthesis and simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p242.jpg,True,"The image contains Verilog code for a simple stack. Here is the code transcribed from the image:

```verilog
// use a valid vector to indicate entries that are filled (valid)
// as data is pushed in, we shift the stack data and add the new data.
parameter DEPTH = 16; // 16 entry stack.
parameter WIDTH = 8;  // 8 bits wide.
parameter STKWIDTH = WIDTH*DEPTH;
reg [DEPTH-1:0]    valid;
wire [WIDTH-1:0]   data_in;
reg [STKWIDTH-1:0] stack_data;
wire [WIDTH-1:0]   top_of_stack = stack_data [WIDTH-1:0];

always @(posedge clk or negedge rst_n) begin
  case ({push, pop, flush})
    3'b100: begin
      valid <= {valid[DEPTH-2:0], 1'b1}; // shift in another entry.
      stack_data <= {stack_data[STKWIDTH-WIDTH-1:0], data_in};
    end
    3'b010: begin
      valid <= {[DEPTH{1'b0}};
      stack_data <= {[STKWIDTH{1'b0}};
    end
    3'b001: begin
      valid <= {1'b0, valid[DEPTH-1: 1]}; // pop it out.
      stack_data <= {[WIDTH{1'b0}}, stack_data [STKWIDTH-1:WIDTH]];
    end
  endcase
  ...
```

The code snippet defines a stack with a parameterized depth and width, includes registers and wires for the stack data and the valid vector, and specifies the behavior for push, pop, and flush operations using a case statement inside an always block triggered by the positive edge of a clock signal or the negative edge of a reset signal.","
// use a valid vector to indicate entries that are filled (valid)
// as data is pushed in, we shift the stack data and add the new data.
parameter DEPTH = 16; // 16 entry stack.
parameter WIDTH = 8;  // 8 bits wide.
parameter STKWIDTH = WIDTH*DEPTH;
reg [DEPTH-1:0]    valid;
wire [WIDTH-1:0]   data_in;
reg [STKWIDTH-1:0] stack_data;
wire [WIDTH-1:0]   top_of_stack = stack_data [WIDTH-1:0];

always @(posedge clk or negedge rst_n) begin
  case ({push, pop, flush})
    3'b100: begin
      valid <= {valid[DEPTH-2:0], 1'b1}; // shift in another entry.
      stack_data <= {stack_data[STKWIDTH-WIDTH-1:0], data_in};
    end
    3'b010: begin
      valid <= {[DEPTH{1'b0}};
      stack_data <= {[STKWIDTH{1'b0}};
    end
    3'b001: begin
      valid <= {1'b0, valid[DEPTH-1: 1]}; // pop it out.
      stack_data <= {[WIDTH{1'b0}}, stack_data [STKWIDTH-1:WIDTH]];
    end
  endcase
  ...
","Caption: Verilog code for implementing a simple stack with push, pop, and flush functionality, and an explanation of assertions related to a stack's push and pop operations.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p271.jpg,True,"```verilog
void PLIbook_ScientificALU_register()
{
    s_vpi_systf_data tf_data;
    tf_data.type        = vpiSysTask;
    tf_data.tfname      = ""$scientific_alu"";
    tf_data.calltf      = PLIbook_ScientificALU_calltf;
    tf_data.compiletf   = PLIbook_ScientificALU_compiletf;
    tf_data.sizetf      = NULL;
    tf_data.user_data   = NULL;
    vpi_register_systf(&tf_data);
}

typedef struct PLIbook_ScientificALU_data {
    vpiHandle enable_h, a_h, b_h, opcode_h, result_h, excep_h, err_h;
    PLIbook_ALU_outputs_s LatchedOutputs; /* storage for outputs */
} PLIbook_ALU_data_s, *PLIbook_ALU_data_p;

int PLIbook_ScientificALU_interface(p_cb_data cb_data)
{
    double a, b, result;
    int opcode, excep, err, enable;
    s_vpi_value value_s;
    
    PLIbook_ALU_data_p ALUdata;
    
    /* Retrieve pointer to ALU data structure from callback user_data. */
    /* The structure contains the handles for the $scientific_alu args */
    ALUdata = (PLIbook_ALU_data_p)cb_data->user_data;
    
    /* Read current values of C model inputs from Verilog simulation */
    value_s.format = vpiRealVal;
    vpi_get_value(ALUdata->a_h, &value_s);
    a = value_s.value.real;
```

The image contains code snippets related to interfacing C models with Verilog code using VPI routines. The actual content of the snippets has been transcribed above.","
void PLIbook_ScientificALU_register()
{
    s_vpi_systf_data tf_data;
    tf_data.type        = vpiSysTask;
    tf_data.tfname      = ""$scientific_alu"";
    tf_data.calltf      = PLIbook_ScientificALU_calltf;
    tf_data.compiletf   = PLIbook_ScientificALU_compiletf;
    tf_data.sizetf      = NULL;
    tf_data.user_data   = NULL;
    vpi_register_systf(&tf_data);
}

typedef struct PLIbook_ScientificALU_data {
    vpiHandle enable_h, a_h, b_h, opcode_h, result_h, excep_h, err_h;
    PLIbook_ALU_outputs_s LatchedOutputs; /* storage for outputs */
} PLIbook_ALU_data_s, *PLIbook_ALU_data_p;

int PLIbook_ScientificALU_interface(p_cb_data cb_data)
{
    double a, b, result;
    int opcode, excep, err, enable;
    s_vpi_value value_s;
    
    PLIbook_ALU_data_p ALUdata;
    
    /* Retrieve pointer to ALU data structure from callback user_data. */
    /* The structure contains the handles for the $scientific_alu args */
    ALUdata = (PLIbook_ALU_data_p)cb_data->user_data;
    
    /* Read current values of C model inputs from Verilog simulation */
    value_s.format = vpiRealVal;
    vpi_get_value(ALUdata->a_h, &value_s);
    a = value_s.value.real;
","""Verilog VPI Interface Code Example for Interfacing with C Models""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p266.jpg,True,"The image contains several lines of code written in the Verilog hardware description language. Here are the excerpts of code from the image:

1.
```verilog
a1: assert property(first_match(req ##[+] data) |-> ack);
```

2.
```verilog
a2: assert property(req ##1 data[-1] |-> ack);
```

3.
```verilog
a3: assert property(first_match(req ##[+] data[*2]) |-> ack);
```

4.
```verilog
a4: assert property(req ##1 data[-1] ##1 data |-> ack);
```

5.
```verilog
a |-> b ##1 first_match(c[*] ##1 d)
```

These pieces of code are illustrating the use of the `first_match` operator and other concepts in sequence and property specification within SystemVerilog assertions (SVA).","
a1: assert property(first_match(req ##[+] data) |-> ack);


a2: assert property(req ##1 data[-1] |-> ack);


a3: assert property(first_match(req ##[+] data[*2]) |-> ack);


a4: assert property(req ##1 data[-1] ##1 data |-> ack);


a |-> b ##1 first_match(c[*] ##1 d)
","Caption: ""Understanding the 'first_match' operator in Verilog for sequence matching and its application in assertions for efficient hardware verification.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p399.jpg,True,"The image contains Verilog code snippets. Here is the code from the image:

```verilog
reg FastClock;
wire[`NumElems:0] WireD;
//
generate
genvar i;
for (i=0; i<`NumElems; i = i+1)
begin : DelayLine
DEL005 Delay85ps ( .Z(WireD[i+1]), .I(WireD[i]) );
end
endgenerate
//
always@(Reset, WireD)
begin : FastClockGen
if (Reset=='b1')
FastClock = 1'b0;
else // The free-running clock gets the output of the delay line:
FastClock = WireD[`NumElems];
end
// The instantiated inverter:
INV00 Inv75ps ( .ZN(WireD[0]), .I(FastClock) );
```

```
Our TSMC library DEL005 component provides a delay of about 85 ps. The new inverter, INV00, lacks decision logic but is slightly faster. The required don't-touch directives are omitted for brevity.
```

```verilog
always@(posedge ClockIn, posedge Reset) //ClockIn delayed for setup.
begin : FreqAdj
if (Reset=='b1)
DivideFactor <= `InitialCount;
else begin
case (AdjustFreq)
2'b00: // Adjust f down (delay up):
if (DivideFactor < DivideHiLim)
DivideFactor <= DivideFactor + `VFO_Delta;
2'b11: // Adjust f up (delay down):
if (DivideFactor > DivideLoLim)
DivideFactor <= DivideFactor - `VFO_Delta;
endcase // Default: leave DivideFactor alone.
end 
end // FreqAdj.
```

The following explanatory text is also in the image but is not part of the Verilog code:

```
With the sampling setup delay element in the containing PLL module, the synthesizable VFO adjustment is as above:

The `InitialCount is set to half of the maximum count in the FastClock-created programmable counter.
```","
reg FastClock;
wire[`NumElems:0] WireD;
//
generate
genvar i;
for (i=0; i<`NumElems; i = i+1)
begin : DelayLine
DEL005 Delay85ps ( .Z(WireD[i+1]), .I(WireD[i]) );
end
endgenerate
//
always@(Reset, WireD)
begin : FastClockGen
if (Reset=='b1')
FastClock = 1'b0;
else // The free-running clock gets the output of the delay line:
FastClock = WireD[`NumElems];
end
// The instantiated inverter:
INV00 Inv75ps ( .ZN(WireD[0]), .I(FastClock) );

MC library DEL005 component provides a delay of about 85 ps. The new inverter, INV00, lacks decision logic but is slightly faster. The required don't-touch directives are omitted for brevity.


always@(posedge ClockIn, posedge Reset) //ClockIn delayed for setup.
begin : FreqAdj
if (Reset=='b1)
DivideFactor <= `InitialCount;
else begin
case (AdjustFreq)
2'b00: // Adjust f down (delay up):
if (DivideFactor < DivideHiLim)
DivideFactor <= DivideFactor + `VFO_Delta;
2'b11: // Adjust f up (delay down):
if (DivideFactor > DivideLoLim)
DivideFactor <= DivideFactor - `VFO_Delta;
endcase // Default: leave DivideFactor alone.
end 
end // FreqAdj.

he sampling setup delay element in the containing PLL module, the synthesizable VFO adjustment is as above:

The `InitialCount is set to half of the maximum count in the FastClock-created programmable counter.
",Verilog code snippet demonstrating a FastClock generator and frequency adjustment logic within a PLL module.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p60.jpg,True,"Yes, the image contains Verilog code. Here is the code written out for you:

```verilog
module generic_chk (input logic a, b, clk);

parameter delay = 1;

property p16;
  @(posedge clk) a |-> ##delay b;
endproperty

a16: assert property(p16);

endmodule

// call checker from the top level module

module top(....);
  logic clk, a, b, c, d;
  .
  .
  generic_chk #(.delay(2)) i1 (a, b, clk);
  generic_chk i2 (c, d, clk);
  .
  .
endmodule
```

The code shows an example of using parameters in SystemVerilog Assertions (SVAs), which is part of Verilog.","
module generic_chk (input logic a, b, clk);

parameter delay = 1;

property p16;
  @(posedge clk) a |-> ##delay b;
endproperty

a16: assert property(p16);

endmodule

// call checker from the top level module

module top(....);
  logic clk, a, b, c, d;
  .
  .
  generic_chk #(.delay(2)) i1 (a, b, clk);
  generic_chk i2 (c, d, clk);
  .
  .
endmodule
",Example of a SystemVerilog Assertion (SVA) checker with parameterization for reusability in a Verilog design.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p517.jpg,True,"The image contains examples of Verilog code for specifying module path delays:

Module path delay with single inputs and outputs:
```verilog
module path
  (in *> out) = (5, 3);
```

Module path delay with multiple inputs and outputs:
```verilog
module path
  (a, b, c *> d, e) = (5, 3);
```

Edge sensitive module path delay:
```verilog
module path
  (posedge clock *> (q +: d)) = (5, 3);
```","
module path
  (in *> out) = (5, 3);


module path
  (a, b, c *> d, e) = (5, 3);


module path
  (posedge clock *> (q +: d)) = (5, 3);
","""Examples of Verilog code demonstrating module path delays with single and multiple inputs and outputs, as well as an edge sensitive module path delay.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p149.jpg,True,"The image contains Verilog code, which appears to be a part of a textbook or educational material about using SystemVerilog for functional coverage. Here is the code present in the image:

```verilog
if(m2_t0_w == 3) m2_t0_w_flag = 1'b1;

c_m3t1r: cover property(p_m3t1r)
begin
    m3_t1_r++;
    if(m3_t1_r == 3) m3_t1_r_flag = 1'b1;
end

c_m3t1w: cover property(p_m3t1w)
begin
    m3_t1_w++;
    if(m3_t1_w == 3) m3_t1_w_flag = 1'b1;
end

c_m3t0r: cover property(p_m3t0r)
begin
    m3_t0_r++;
    if(m3_t0_r == 3) m3_t0_r_flag = 1'b1;
end

c_m3t0w: cover property(p_m3t0w)
begin
    m3_t0_w++;
    if(m3_t0_w == 3) m3_t0_w_flag = 1'b1;
end
```

Additionally, the text below the code speaks about the conditions to terminate a simulation, and it contains a partial block of Verilog code:

```verilog
always@(posedge clk)
begin
    if(creq1_flag && creq2_flag && creq3_flag &&
       creq12_flag && creq23_flag && creq31_flag &&
```

The second code block is incomplete. The `&&` at the end implies there is more code following this that is not shown in the image.","
if(m2_t0_w == 3) m2_t0_w_flag = 1'b1;

c_m3t1r: cover property(p_m3t1r)
begin
    m3_t1_r++;
    if(m3_t1_r == 3) m3_t1_r_flag = 1'b1;
end

c_m3t1w: cover property(p_m3t1w)
begin
    m3_t1_w++;
    if(m3_t1_w == 3) m3_t1_w_flag = 1'b1;
end

c_m3t0r: cover property(p_m3t0r)
begin
    m3_t0_r++;
    if(m3_t0_r == 3) m3_t0_r_flag = 1'b1;
end

c_m3t0w: cover property(p_m3t0w)
begin
    m3_t0_w++;
    if(m3_t0_w == 3) m3_t0_w_flag = 1'b1;
end


always@(posedge clk)
begin
    if(creq1_flag && creq2_flag && creq3_flag &&
       creq12_flag && creq23_flag && creq31_flag &&
",The image shows a textbook or document page containing explanations and snippets of Verilog code related to simulation coverage and termination conditions in hardware verification environments.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p503.jpg,True,"The image contains Verilog code which is as follows:

```verilog
module chip (clock, in1, out1, out2);
    wire out1, out2;
    dff u1 (clock, in1, out1, out2);
endmodule

module dff (clk, d, q, qb);
    ...
endmodule
```

The rest of the text in the image describes how port connections are accessed in Verilog using ACC routines, and explains a distinction between two types of port object connections.","
module chip (clock, in1, out1, out2);
    wire out1, out2;
    dff u1 (clock, in1, out1, out2);
endmodule

module dff (clk, d, q, qb);
    ...
endmodule
","""Chapter excerpt on ACC Routine Library for Verilog showing an object diagram and code illustrating port object access differences.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p74.jpg,True,"```verilog
property p25;
  @(posedge clk) $rose(start) |-> ##2 (a[*3]) ##1 stop;
endproperty

a25: assert property(p25);
```","
property p25;
  @(posedge clk) $rose(start) |-> ##2 (a[*3]) ##1 stop;
endproperty

a25: assert property(p25);
",Waveform and Verilog code demonstrating the use of SystemVerilog Assertions (SVA) with 'Go to repetition operator' to check signal sequence and timing.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p265.jpg,True,"The image contains code related to Verilog, specifically for interfacing to C models using VPI (Verilog Procedural Interface) routines. Here's the code presented in the image:

```c
/******************************************************************************
 * VPI Registration Data
 *****************************************************************************/
void PLIbook_ScientificALU_register()
{
    s_vpi_systf_data tf_data;
    tf_data.type        = vpiSysTask;
    tf_data.tfname      = ""$scientific_alu"";
    tf_data.calltf      = PLIbook_ScientificALU_calltf;
    tf_data.compiletf   = PLIbook_ScientificALU_compiletf;
    tf_data.sizetf      = NULL;
    tf_data.user_data   = NULL;
    vpi_register_systf(&tf_data);
}

/******************************************************************************
 * Definition for a structure to hold the data to be passed from
 * calltf application to the ALU interface.
 ******************************************************************************/
typedef struct PLIbook_ScientificALU_data {
    vpiHandle     clock_h, a_h, b_h, opcode_h, result_h, excep_h, err_h;
    short int     sync_flag;
    PLIbook_ALU_data_s *PLIbook_ALU_data_p;
} PLIbook_ScientificALU_data;

/******************************************************************************
 * Value change simulation callback routine: Schedules a read-write
 * synchronize simulation callback at the end of the current time step.
 * Only schedules one callback for a time step.
 ******************************************************************************/
int PLIbook_ScientificALU_interface(p_cb_data cb_data)
{
    s_cb_data            cb_data_s;
    s_vpi_time           time_s;
    PLIbook_ALU_data_p   ALUdata;

    /* Retrieve pointer to ALU data structure from VCL user_data field */
    /* The structure contains a flag indicating if a synchronize */
    /* callback has already been scheduled */
    ALUdata = (PLIbook_ALU_data_p)cb_data->user_data;

    /* If the sync_flag is 0, then no read-write synchronize callback */
    /* has been scheduled for this time step (the sync_flag is set to */
    /* 1 by this routine, and set to 0 by the read-write synchronize */
    /* callback after a callback is processed. */

    if (!ALUdata->sync_flag) {
        /* Schedule a synchronize simulation callback for this instance */
        ALUdata->sync_flag = 1; /* set sync_flag */
        time_s.type        = vpiSuppressTime;
        cb_data_s.reason   = cbReadWriteSynch;
        cb_data_s.user_data = (char *)ALUdata;
        cb_data_s.cb_rtn   = PLIbook_EndOfTimeStep_callback;
        cb_data_s.obj      = NULL;
    }
}
```

The code shows how to register a system task using VPI and how to set up a callback mechanism within a simulation. Please note that the actual callback functions `PLIbook_ScientificALU_calltf`, `PLIbook_ScientificALU_compiletf`, and `PLIbook_EndOfTimeStep_callback` would need to be defined elsewhere in the codebase.","**************************************************************************
 * VPI Registration Data
 *****************************************************************************/
void PLIbook_ScientificALU_register()
{
    s_vpi_systf_data tf_data;
    tf_data.type        = vpiSysTask;
    tf_data.tfname      = ""$scientific_alu"";
    tf_data.calltf      = PLIbook_ScientificALU_calltf;
    tf_data.compiletf   = PLIbook_ScientificALU_compiletf;
    tf_data.sizetf      = NULL;
    tf_data.user_data   = NULL;
    vpi_register_systf(&tf_data);
}

/******************************************************************************
 * Definition for a structure to hold the data to be passed from
 * calltf application to the ALU interface.
 ******************************************************************************/
typedef struct PLIbook_ScientificALU_data {
    vpiHandle     clock_h, a_h, b_h, opcode_h, result_h, excep_h, err_h;
    short int     sync_flag;
    PLIbook_ALU_data_s *PLIbook_ALU_data_p;
} PLIbook_ScientificALU_data;

/******************************************************************************
 * Value change simulation callback routine: Schedules a read-write
 * synchronize simulation callback at the end of the current time step.
 * Only schedules one callback for a time step.
 ******************************************************************************/
int PLIbook_ScientificALU_interface(p_cb_data cb_data)
{
    s_cb_data            cb_data_s;
    s_vpi_time           time_s;
    PLIbook_ALU_data_p   ALUdata;

    /* Retrieve pointer to ALU data structure from VCL user_data field */
    /* The structure contains a flag indicating if a synchronize */
    /* callback has already been scheduled */
    ALUdata = (PLIbook_ALU_data_p)cb_data->user_data;

    /* If the sync_flag is 0, then no read-write synchronize callback */
    /* has been scheduled for this time step (the sync_flag is set to */
    /* 1 by this routine, and set to 0 by the read-write synchronize */
    /* callback after a callback is processed. */

    if (!ALUdata->sync_flag) {
        /* Schedule a synchronize simulation callback for this instance */
        ALUdata->sync_flag = 1; /* set sync_flag */
        time_s.type        = vpiSuppressTime;
        cb_data_s.reason   = cbReadWriteSynch;
        cb_data_s.user_data = (char *)ALUdata;
        cb_data_s.cb_rtn   = PLIbook_EndOfTimeStep_callback;
        cb_data_s.obj      = NULL;
    }
}
",A page from a book displaying a section on interfacing to C models using VPI routines in Verilog with code examples for VPI registration data and a callback interface function.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p272.jpg,True,"The image contains Verilog code examples related to defining sequences and properties for use with assertions:

```verilog
sequence seq_previously(e);
    e ##1 1;
endsequence : seq_previously
property previously(e);
    seq_previously(e).triggered;
endproperty : previously

sequence seq_not_first;
    ##1 1;
endsequence : seq_not_first
property first;
    !seq_not_first.triggered;
endproperty : first

sequence seq_once(e);
    e ##[1*] 1;
endsequence : seq_once
property once(e);
    seq_once(e).triggered;
endproperty : once

property sofar(e);
    !seq_once(e).triggered;
endproperty : sofar

sequence seq_since(e1, e2);
    e2 ##1 e1[1*];
endsequence : seq_since
property since(e1, e2);
    seq_since(e1, e2).triggered;
endproperty : since
```

Additionally, there is a small snippet of an example containing an assign statement:

```verilog
assign a = s.triggered || b;
```

These snippets are meant to illustrate past temporal properties and demonstrate the usage of the `.triggered` keyword with sequences in Verilog.
","
sequence seq_previously(e);
    e ##1 1;
endsequence : seq_previously
property previously(e);
    seq_previously(e).triggered;
endproperty : previously

sequence seq_not_first;
    ##1 1;
endsequence : seq_not_first
property first;
    !seq_not_first.triggered;
endproperty : first

sequence seq_once(e);
    e ##[1*] 1;
endsequence : seq_once
property once(e);
    seq_once(e).triggered;
endproperty : once

property sofar(e);
    !seq_once(e).triggered;
endproperty : sofar

sequence seq_since(e1, e2);
    e2 ##1 e1[1*];
endsequence : seq_since
property since(e1, e2);
    seq_since(e1, e2).triggered;
endproperty : since


assign a = s.triggered || b;
","Caption: ""Examples of Verilog temporal properties and a discussion on triggered sequences in RTL.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p256.jpg,True,"The image contains Verilog code. Here it is:

```verilog
initial begin
  // Level 1
  randcase
    one_write_wt: do_one_write();
    one_read_wt: do_one_read();
    seq_write_wt: do_seq_write();
    seq_read_wt: do_seq_read();
  endcase
end

// Level 2
task do_one_write();
  randcase
    mem_write_wt: do_mem_write();
    io_write_wt: do_io_write();
    cfg_write_wt: do_cfg_write();
  endcase
endtask

task do_one_read();
  randcase
    mem_read_wt: do_mem_read();
    io_read_wt: do_io_read();
    cfg_read_wt: do_cfg_read();
  endcase
endtask
```

This code snippet demonstrates the use of `randcase` to create a decision tree with random case selection in Verilog.","
initial begin
  // Level 1
  randcase
    one_write_wt: do_one_write();
    one_read_wt: do_one_read();
    seq_write_wt: do_seq_write();
    seq_read_wt: do_seq_read();
  endcase
end

// Level 2
task do_one_write();
  randcase
    mem_write_wt: do_mem_write();
    io_write_wt: do_io_write();
    cfg_write_wt: do_cfg_write();
  endcase
endtask

task do_one_read();
  randcase
    mem_read_wt: do_mem_read();
    io_read_wt: do_io_read();
    cfg_read_wt: do_cfg_read();
  endcase
endtask
","""Example of a decision tree in Verilog using randcase statement.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p85.jpg,True,"The image contains Verilog code. Here it is:

```verilog
int power_of_2[int] = '{0:1, 1:2, 2:4};
initial begin
    for (int i=3; i<5; i++)
        power_of_2[i] = 1 << i;
    $display(""%p"", power_of_2); // '{0:1, 1:2, 2:4, 3:8, 4:16}
end
```

This code sample demonstrates initializing and printing associative arrays in Verilog.","
int power_of_2[int] = '{0:1, 1:2, 2:4};
initial begin
    for (int i=3; i<5; i++)
        power_of_2[i] = 1 << i;
    $display(""%p"", power_of_2); // '{0:1, 1:2, 2:4, 3:8, 4:16}
end
","""Excerpt from a document explaining associative arrays and array methods in Verilog with code examples for initialization and array reduction operations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p528.jpg,True,"The image shows a page from a textbook or article related to Verilog code within the context of formal verification, specifically discussing checkers in formal verification and the behavior of free variables in a coverage context. There are two examples of Verilog code present:

The first example:

```verilog
checker check(bit a);
  default clocking @($global_clock); endclocking
  rand bit v;
  c1: cover property ((a && v) [*2]);
  c2: cover property ((a || v) [*2]);
endchecker: check
```

The second example:

```verilog
checker check;
  default clocking @($global_clock); endclocking
  rand bit v;
  m1: assume property ($steady_gclk(v));
  c1: cover property (v ##1 !v);
endchecker: check
```

The text discusses the semantics and constraints of these checkers, how free variables function within them, and when a cover statement is considered to be satisfied within the context of formal semantics.","
checker check(bit a);
  default clocking @($global_clock); endclocking
  rand bit v;
  c1: cover property ((a && v) [*2]);
  c2: cover property ((a || v) [*2]);
endchecker: check


checker check;
  default clocking @($global_clock); endclocking
  rand bit v;
  m1: assume property ($steady_gclk(v));
  c1: cover property (v ##1 !v);
endchecker: check
","""Understanding the Use of Free Variables in Verilog Cover Properties and Checkers""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p259.jpg,True,"The image shows a page from a document or a book with code for interfacing to C models using VPI routines in Verilog. Here's the text of the code present in the image:

```c
arg_h = vpi_scan(arg_itr); /* 3rd arg is opcode input */
if (vpi_get(vpiType, arg_h) != vpiNet) {
    vpi_printf(""%%scientific_alu arg 3 (opcode) must be a net\n"");
    err = 1;
}
else if (vpi_get(vpiSize, arg_h) != 4) {
    vpi_printf(""%%scientific_alu arg 3 (opcode) must be 4-bit vector\n"");
    err = 1;
}

arg_h = vpi_scan(arg_itr); /* 4th arg is result output */
if (vpi_get(vpiType, arg_h) != vpiRealVar) {
    vpi_printf(""%%scientific_alu arg 4 (result) must be a real var.\n"");
    err = 1;
}

arg_h = vpi_scan(arg_itr); /* 5th arg is exception output */
if (vpi_get(vpiType, arg_h) != vpiReg) {
    vpi_printf(""%%scientific_alu arg 5 (exception) must be a reg\n"");
    err = 1;
}
else if (vpi_get(vpiSize, arg_h) != 1) {
    vpi_printf(""%%scientific_alu arg 5 (exception) must be scalar\n"");
    err = 1;
}

arg_h = vpi_scan(arg_itr); /* 6th arg is error output */
if (vpi_get(vpiType, arg_h) != vpiReg) {
    vpi_printf(""%%scientific_alu arg 6 (error) must be a reg\n"");
    err = 1;
}
else if (vpi_get(vpiSize, arg_h) != 1) {
    vpi_printf(""%%scientific_alu arg 6 (error) must be scalar\n"");
    err = 1;
}

if (vpi_scan(arg_itr) != NULL) { /* should not be any more args */
    vpi_printf(""ERROR: %scientific_alu requires only 6 arguments\n"");
    vpi_free_object(arg_itr);
    err = 1;
}

if (err) {
    tf_dofinish();
    return(0);
}
```

This snippet appears to be used for validating arguments passed to a Verilog PLI (Programming Language Interface) task or function named ""scientific_alu"". It performs checks on the type and size of these arguments, setting an error flag if any of the checks fail. If an error occurs, the `tf_dofinish()` function is called, and the code returns `0`."," = vpi_scan(arg_itr); /* 3rd arg is opcode input */
if (vpi_get(vpiType, arg_h) != vpiNet) {
    vpi_printf(""%%scientific_alu arg 3 (opcode) must be a net\n"");
    err = 1;
}
else if (vpi_get(vpiSize, arg_h) != 4) {
    vpi_printf(""%%scientific_alu arg 3 (opcode) must be 4-bit vector\n"");
    err = 1;
}

arg_h = vpi_scan(arg_itr); /* 4th arg is result output */
if (vpi_get(vpiType, arg_h) != vpiRealVar) {
    vpi_printf(""%%scientific_alu arg 4 (result) must be a real var.\n"");
    err = 1;
}

arg_h = vpi_scan(arg_itr); /* 5th arg is exception output */
if (vpi_get(vpiType, arg_h) != vpiReg) {
    vpi_printf(""%%scientific_alu arg 5 (exception) must be a reg\n"");
    err = 1;
}
else if (vpi_get(vpiSize, arg_h) != 1) {
    vpi_printf(""%%scientific_alu arg 5 (exception) must be scalar\n"");
    err = 1;
}

arg_h = vpi_scan(arg_itr); /* 6th arg is error output */
if (vpi_get(vpiType, arg_h) != vpiReg) {
    vpi_printf(""%%scientific_alu arg 6 (error) must be a reg\n"");
    err = 1;
}
else if (vpi_get(vpiSize, arg_h) != 1) {
    vpi_printf(""%%scientific_alu arg 6 (error) must be scalar\n"");
    err = 1;
}

if (vpi_scan(arg_itr) != NULL) { /* should not be any more args */
    vpi_printf(""ERROR: %scientific_alu requires only 6 arguments\n"");
    vpi_free_object(arg_itr);
    err = 1;
}

if (err) {
    tf_dofinish();
    return(0);
}
",Verilog VPI Routine Example: Type and Size Checking for ALU Model Arguments,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p60.jpg,True,"Here is the Verilog code from the image:

```verilog
package common_props;

    let one_cold(sig) = $onehot(~sig);

    property req_granted (sequence req, property gnt);
        req |-> gnt;
    endproperty : req_granted
...
endpackage : common_props
```

There is also another piece of code:

```verilog
module m (input logic rq, done, clk, ...);
    wire [7:0] data;
    ...
    a1: assert final (common_props::one_cold(data));
    ...
    a2: assert property (@(posedge clk)
        common_props::req_granted(rq, done));
...
endmodule : m
```

And finally:

```verilog
module m (input logic rq, done, clk, ...);
    import common_props::one_cold, common_props::req_granted;
    wire [7:0] data;
    ...
    a1: assert final (one_cold(data));
...
endmodule
```

This text provides examples of Verilog code that demonstrates how to define and use packages for common properties, sequences, and checkers within a SystemVerilog-based project.","
package common_props;

    let one_cold(sig) = $onehot(~sig);

    property req_granted (sequence req, property gnt);
        req |-> gnt;
    endproperty : req_granted
...
endpackage : common_props


module m (input logic rq, done, clk, ...);
    wire [7:0] data;
    ...
    a1: assert final (common_props::one_cold(data));
    ...
    a2: assert property (@(posedge clk)
        common_props::req_granted(rq, done));
...
endmodule : m


module m (input logic rq, done, clk, ...);
    import common_props::one_cold, common_props::req_granted;
    wire [7:0] data;
    ...
    a1: assert final (one_cold(data));
...
endmodule
","Caption: ""Excerpt from a textbook showing examples of SystemVerilog package usage and importing declarations within a verification environment.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p242.jpg,True,"The image contains textual information relevant to Verilog and two sample code snippets. Here are the code snippets:

Sample 6.46:
```verilog
rand bit [31:0] addr;
constraint slow_near_page_boundary {
  addr % 4096 inside {[0:20], [4075:4095]};
}
```

Sample 6.47:
```verilog
rand bit [31:0] addr;
constraint near_page_boundary {
  addr[11:0] inside {[0:20], [4075:4095]};
}
```

These snippets of code exemplify how to write constraints in Verilog to generate random addresses near a page boundary, discussing efficient and less efficient methods.","
rand bit [31:0] addr;
constraint slow_near_page_boundary {
  addr % 4096 inside {[0:20], [4075:4095]};
}


rand bit [31:0] addr;
constraint near_page_boundary {
  addr[11:0] inside {[0:20], [4075:4095]};
}
","Caption: ""Guidance on optimizing Verilog code performance, highlighting the impact of arithmetic operators on solver efficiency and demonstrating Verilog constraints to generate random addresses near a page boundary.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p107.jpg,True,"The image contains examples of Verilog code. Here is the code transcribed from the image:

Example 5-2:
```verilog
always @(b or c) begin
    d = b ^ c;
    e = a ^ d;
    // Only one evaluation in rank-ordered simulation
    if ($time > 0) $display("" e = %b"",e);
end
```

Example 5-3:

a) Original Verilog:
```verilog
assign c = a;
assign g = f;
always @(c or d) begin
    case (c)
        2’h0 : f = d;
        2’h1 : f = !d;
        default : f = 1’b1;
    endcase
end
assign d = b;
```

b) Rank-ordered Verilog:
```verilog
always @(a or b or c) begin
    c = a;
    d = b;
    case (c)
        2’h0 : f = d;
        2’h1 : f = !d;
        default : f = 1’b1;
    endcase
    g = f;
end
```
Please note that there might be transcription errors due to the quality of the image and the font used, so it's always good to double-check with the original source if precision is necessary.","
always @(b or c) begin
    d = b ^ c;
    e = a ^ d;
    // Only one evaluation in rank-ordered simulation
    if ($time > 0) $display("" e = %b"",e);
end


assign c = a;
assign g = f;
always @(c or d) begin
    case (c)
        2’h0 : f = d;
        2’h1 : f = !d;
        default : f = 1’b1;
    endcase
end
assign d = b;


always @(a or b or c) begin
    c = a;
    d = b;
    case (c)
        2’h0 : f = d;
        2’h1 : f = !d;
        default : f = 1’b1;
    endcase
    g = f;
end
","""Comparison of standard and rank-ordered Verilog code for RTL simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p299.jpg,True,"This image contains a single line of code written in the context of Verilog:

```verilog
c1: cover property (a ##1 b);
```

The rest of the text discusses rules regarding the propagation of semantic leading clocks in properties and sequences, using a mathematical notation to describe the logic, but it does not represent conventional lines of code.","
c1: cover property (a ##1 b);
",Text on Verilog semantic leading clocks and a cover property example in SystemVerilog.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p295.jpg,True,"The image contains Verilog code. Here is the code present in the image:

```verilog
mailbox #(Transaction) mbx; // Mailbox connecting gen & drv
Generator gen;
Driver drv;
int count;

initial begin
  mbx = new();                     // Construct the mailbox
  gen = new(mbx);                  // Construct the generator
  drv = new(mbx);                  // Construct the driver
  count = $urandom_range(50);      // Run up to 50 transactions
  
  fork
    gen.run(count);                // Spawn the generator
    drv.run(count);                // Spawn the driver
  join                             // Wait for both to finish
end
endprogram

program automatic bounded;
mailbox #(int) mbx;

initial begin
  mbx = new(1); // Mailbox size = 1
  fork
    // Producer thread
    for (int i=1; i<4; i++) begin
      $display(""Producer: before put(%0d)"", i);
      mbx.put(i);
      $display(""Producer: after put(%0d)"", i);
    end
```","
mailbox #(Transaction) mbx; // Mailbox connecting gen & drv
Generator gen;
Driver drv;
int count;

initial begin
  mbx = new();                     // Construct the mailbox
  gen = new(mbx);                  // Construct the generator
  drv = new(mbx);                  // Construct the driver
  count = $urandom_range(50);      // Run up to 50 transactions
  
  fork
    gen.run(count);                // Spawn the generator
    drv.run(count);                // Spawn the driver
  join                             // Wait for both to finish
end
endprogram

program automatic bounded;
mailbox #(int) mbx;

initial begin
  mbx = new(1); // Mailbox size = 1
  fork
    // Producer thread
    for (int i=1; i<4; i++) begin
      $display(""Producer: before put(%0d)"", i);
      mbx.put(i);
      $display(""Producer: after put(%0d)"", i);
    end
","""Sample Verilog code demonstrating the use of mailboxes for interprocess communication and synchronization, including examples of a general mailbox and a bounded mailbox.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p400.jpg,True,"```verilog
always@(posedge PLLClock, posedge Reset) //The delayed PLL ClockIn.
begin : EdgeComparator
    if (Reset=='b1) AdjustFreq = 2'b01;
    else
        case (ClockInN) // Count from the PLL external input clock.
            2'b00: case (PLLClockN) // Count from the VFO output clock.
                2'b00: AdjustFreq = 2'b01; // No change.
                2'b01: AdjustFreq = 2'b00; // Slow the counter.
                2'b10: AdjustFreq = 2'b00; // Slow the counter.
                2'b11: AdjustFreq = 2'b00; // Slow the counter.
                default: AdjustFreq = 2'b01; // No change.
                endcase
            2'b01: case (PLLClockN)
                2'b00: AdjustFreq = 2'b11; // Speed up the counter.
                2'b01: AdjustFreq = 2'b01; // No change.
                2'b10: AdjustFreq = 2'b00; // Slow the counter.
                2'b11: AdjustFreq = 2'b00; // Slow the counter.
                default: AdjustFreq = 2'b01; // No change.
                endcase
            2'b10: case (PLLClockN)
                2'b00: AdjustFreq = 2'b11; // Speed up the counter.
                2'b01: AdjustFreq = 2'b11; // Speed up the counter.
                2'b10: AdjustFreq = 2'b10; // No change.
                2'b11: AdjustFreq = 2'b00; // Slow the counter.
                default: AdjustFreq = 2'b10; // No change.
                endcase
            2'b11: case (PLLClockN)
                2'b00: AdjustFreq = 2'b11; // Speed up the counter.
                2'b01: AdjustFreq = 2'b11; // Speed up the counter.
                2'b10: AdjustFreq = 2'b11; // Speed up the counter.
                2'b11: AdjustFreq = 2'b10; // No change.
                default: AdjustFreq = 2'b10; // No change.
                endcase
            default: AdjustFreq = 2'b10; // No change; allows initialization.
            endcase
end
```","
always@(posedge PLLClock, posedge Reset) //The delayed PLL ClockIn.
begin : EdgeComparator
    if (Reset=='b1) AdjustFreq = 2'b01;
    else
        case (ClockInN) // Count from the PLL external input clock.
            2'b00: case (PLLClockN) // Count from the VFO output clock.
                2'b00: AdjustFreq = 2'b01; // No change.
                2'b01: AdjustFreq = 2'b00; // Slow the counter.
                2'b10: AdjustFreq = 2'b00; // Slow the counter.
                2'b11: AdjustFreq = 2'b00; // Slow the counter.
                default: AdjustFreq = 2'b01; // No change.
                endcase
            2'b01: case (PLLClockN)
                2'b00: AdjustFreq = 2'b11; // Speed up the counter.
                2'b01: AdjustFreq = 2'b01; // No change.
                2'b10: AdjustFreq = 2'b00; // Slow the counter.
                2'b11: AdjustFreq = 2'b00; // Slow the counter.
                default: AdjustFreq = 2'b01; // No change.
                endcase
            2'b10: case (PLLClockN)
                2'b00: AdjustFreq = 2'b11; // Speed up the counter.
                2'b01: AdjustFreq = 2'b11; // Speed up the counter.
                2'b10: AdjustFreq = 2'b10; // No change.
                2'b11: AdjustFreq = 2'b00; // Slow the counter.
                default: AdjustFreq = 2'b10; // No change.
                endcase
            2'b11: case (PLLClockN)
                2'b00: AdjustFreq = 2'b11; // Speed up the counter.
                2'b01: AdjustFreq = 2'b11; // Speed up the counter.
                2'b10: AdjustFreq = 2'b11; // Speed up the counter.
                2'b11: AdjustFreq = 2'b10; // No change.
                default: AdjustFreq = 2'b10; // No change.
                endcase
            default: AdjustFreq = 2'b10; // No change; allows initialization.
            endcase
end
",Verilog code snippet showing a decision logic for adjusting frequency in a PLL design.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p414.jpg,True,"The image contains Verilog code snippets. Here is the code visible in the image:

```verilog
module Deserializer
  ...
  // --------------------------------------------------
  // Structure:
  //
  FIFO_Top # ( .AWid(AWid), .DWid(DWid) )
  FIFO_U1
  (
    .Dout(), .Din()
    .ReadIn(), .WriteIn()
    .Full(), .Empty()
    .Clocker(), .Reseter(Reset)
  );
  //
  DesDecoder # ( .DWid(DWid) )
  DesDecoder_U1
  (
    .ParOut(), .ParValid()
    .ParClk(), .SerClk()
    .SerIn(), .SerValid(), .Reset(Reset)
  );
  //
  SerialRx
  SerialRx_U1
  (
    .SerClk(), .SerData()
    .SerLinkIn(), .ParClk()
    .Reset(Reset)
  );
  //
endmodule // Deserializer

Then, compose the module wiring declarations by including them (illegally) in the
instance port maps, using ANSI format. For example, in the code above, you might next
change the above FIFO_Top .Din() to output [DWid-1:0] .Din(DecodeToFIFO), and the
DesDecoder .ParOut() to output [DWid-1:0] .ParOut(DecodeToFIFO).

Do this any way you want, but developing some sort of systematic way to define
module ports and declarations top-down is an important skill in VLSI design.
One idea would be to start by declaring modules where instances will be wired. For
example, to instantiate the FIFO in Deserializer.v, start by cut-and-pasting this into
your Deserializer.v file:

module FIFO_Top #(parameter AWid = 5 // FIFO depth = 2**AWid.
                  DWid = 32 // Default width.
                  )
  (
    output [DWid-1:0] Dout(wire [DWid-1:0] FIFO_Out)
    input [DWid-1:0] Din(wire [DWid-1:0] DecodeToFIFO)
    output Full(wire FIFOfull), Empty(wire FIFOempty)
    ...
  );
```

This excerpt is discussing the structure of a Verilog module for deserialization and includes examples of module instantiations with parameterization. Note that there are ellipsis points ""..."" indicating some parts of the code are intentionally omitted or are placeholders for the developer to complete with specific details.","
module Deserializer
  ...
  // --------------------------------------------------
  // Structure:
  //
  FIFO_Top # ( .AWid(AWid), .DWid(DWid) )
  FIFO_U1
  (
    .Dout(), .Din()
    .ReadIn(), .WriteIn()
    .Full(), .Empty()
    .Clocker(), .Reseter(Reset)
  );
  //
  DesDecoder # ( .DWid(DWid) )
  DesDecoder_U1
  (
    .ParOut(), .ParValid()
    .ParClk(), .SerClk()
    .SerIn(), .SerValid(), .Reset(Reset)
  );
  //
  SerialRx
  SerialRx_U1
  (
    .SerClk(), .SerData()
    .SerLinkIn(), .ParClk()
    .Reset(Reset)
  );
  //
endmodule // Deserializer

Then, compose the module wiring declarations by including them (illegally) in the
instance port maps, using ANSI format. For example, in the code above, you might next
change the above FIFO_Top .Din() to output [DWid-1:0] .Din(DecodeToFIFO), and the
DesDecoder .ParOut() to output [DWid-1:0] .ParOut(DecodeToFIFO).

Do this any way you want, but developing some sort of systematic way to define
module ports and declarations top-down is an important skill in VLSI design.
One idea would be to start by declaring modules where instances will be wired. For
example, to instantiate the FIFO in Deserializer.v, start by cut-and-pasting this into
your Deserializer.v file:

module FIFO_Top #(parameter AWid = 5 // FIFO depth = 2**AWid.
                  DWid = 32 // Default width.
                  )
  (
    output [DWid-1:0] Dout(wire [DWid-1:0] FIFO_Out)
    input [DWid-1:0] Din(wire [DWid-1:0] DecodeToFIFO)
    output Full(wire FIFOfull), Empty(wire FIFOempty)
    ...
  );
","""Excerpt from a textbook on Digital VLSI Design showing a snippet of Verilog code for a Deserializer module and guidelines on composing module wiring declarations.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p281.jpg,True,"The image contains Verilog code. Here it is:

```verilog
initial begin
    check_trans(tr0); // thread 0

    // Create a thread to limit scope of disable
    fork                             // thread 1
        begin
            check_trans(tr1);        // thread 2
            fork                     // thread 3
                check_trans(tr2);    // thread 4
            join
        end
        // Stop threads 2-4, but leave 0 alone
        #(TIME_OUT/10) disable fork;
    join
end
```

This code snippet demonstrates how to limit the scope of a `disable fork` statement in Verilog. It shows the creation of threads and how to selectively disable some of them while allowing others to continue execution.","
initial begin
    check_trans(tr0); // thread 0

    // Create a thread to limit scope of disable
    fork                             // thread 1
        begin
            check_trans(tr1);        // thread 2
            fork                     // thread 3
                check_trans(tr2);    // thread 4
            join
        end
        // Stop threads 2-4, but leave 0 alone
        #(TIME_OUT/10) disable fork;
    join
end
","""Understanding fork-join and thread management in Verilog with an example of limiting the scope of a disable fork statement.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p415.jpg,True,"```verilog
FIFO_Top # ( .AWid(AWid), .DWid(DWid) )
FIFO_Top_U1
    ( .Dout(FIFO_Out)           // pin-out (= port map).
      , .Din(DecodeToFFIFO)
      , .Full(FIFOFull), .Empty(FIFOEmpty)
    ...
);

always@(posedge ParOutClk, posedge Reset)
begin : OutputBuffer
    if (Reset=='b1)
        ParBuf <= 'b0; // To be wired to the ParOut port.
    else
        ParBuf <= FIFO_Out;
end
``` 

The above code snippets are written in Verilog, a hardware description language used for designing electronic systems.","
FIFO_Top # ( .AWid(AWid), .DWid(DWid) )
FIFO_Top_U1
    ( .Dout(FIFO_Out)           // pin-out (= port map).
      , .Din(DecodeToFFIFO)
      , .Full(FIFOFull), .Empty(FIFOEmpty)
    ...
);

always@(posedge ParOutClk, posedge Reset)
begin : OutputBuffer
    if (Reset=='b1)
        ParBuf <= 'b0; // To be wired to the ParOut port.
    else
        ParBuf <= FIFO_Out;
end
",Page from a textbook explaining steps for writing Verilog code with an example code snippet for an output buffer using a synchronous reset.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p97.jpg,True,"The image contains text that describes steps for modifying a Verilog design, but the actual Verilog code snippet is very small. Here is the code:

```verilog
module Intro_Top (
  output x, y, z, input A, B, C, D
  output ScanOut
  input ScanMode, ScanIn, ScanClk, ScanClr,
  );
```

Please note that this code may not be complete or entirely accurate as there are typical commas missing at the end of the output and input lines, and the last comma is not necessary before the closing parenthesis. The correct syntax for a Verilog module port list should look like this:

```verilog
module Intro_Top (
  output x, y, z,
  input A, B, C, D,
  output ScanOut,
  input ScanMode, ScanIn, ScanClk, ScanClr
);
```","
module Intro_Top (
  output x, y, z, input A, B, C, D
  output ScanOut
  input ScanMode, ScanIn, ScanClk, ScanClr,
  );


module Intro_Top (
  output x, y, z,
  input A, B, C, D,
  output ScanOut,
  input ScanMode, ScanIn, ScanClk, ScanClr
);
","The image shows a text document with instructions for modifying a Verilog design to insert a scan chain, including the addition of JTAG ports and D flip-flops, for the purpose of testing and maintenance.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p280.jpg,True,"The image contains Verilog code in a section titled ""7.2.1 Disabling a Single Thread."" The code is as follows:

```verilog
parameter TIME_OUT = 1000ns;

task check_trans(input Transaction tr);
  fork
    begin
    // Wait for response, or some maximum delay
      fork : timeout_block
        begin
          wait (bus.cb.data == tr.data);
          $display(""%0t: data match %d"", $time, tr.data);
        end
        #TIME_OUT $display(""%0t: Error: timeout"", $time);
      join_any
      disable timeout_block;
    end

    join_none // Spawn thread, don't block
  endtask
```","
parameter TIME_OUT = 1000ns;

task check_trans(input Transaction tr);
  fork
    begin
    // Wait for response, or some maximum delay
      fork : timeout_block
        begin
          wait (bus.cb.data == tr.data);
          $display(""%0t: data match %d"", $time, tr.data);
        end
        #TIME_OUT $display(""%0t: Error: timeout"", $time);
      join_any
      disable timeout_block;
    end

    join_none // Spawn thread, don't block
  endtask
","""Verilog code snippet for disabling a single thread with timeout functionality using fork-join_any construct.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p294.jpg,True,"The image contains Verilog code. Here it is:

```verilog
program automatic mailbox_example(bus_ifc.TB bus);

class Generator;
  Transaction tr;
  mailbox # (Transaction) mbx;

  function new(input mailbox # (Transaction) mbx);
    this.mbx = mbx;
  endfunction

  task run(input int count);
    repeat (count) begin
      tr = new();
      `SV_RAND_CHECK(tr.randomize);
      mbx.put(tr);  // Send out transaction
    end
  endtask
endclass

class Driver;
  Transaction tr;
  mailbox # (Transaction) mbx;

  function new(input mailbox # (Transaction) mbx);
    this.mbx = mbx;
  endfunction

  task run(input int count);
    repeat (count) begin
      mbx.get(tr);  // Fetch next transaction
      // Drive transaction here
    end
  endtask
endclass
```","
program automatic mailbox_example(bus_ifc.TB bus);

class Generator;
  Transaction tr;
  mailbox # (Transaction) mbx;

  function new(input mailbox # (Transaction) mbx);
    this.mbx = mbx;
  endfunction

  task run(input int count);
    repeat (count) begin
      tr = new();
      `SV_RAND_CHECK(tr.randomize);
      mbx.put(tr);  // Send out transaction
    end
  endtask
endclass

class Driver;
  Transaction tr;
  mailbox # (Transaction) mbx;

  function new(input mailbox # (Transaction) mbx);
    this.mbx = mbx;
  endfunction

  task run(input int count);
    repeat (count) begin
      mbx.get(tr);  // Fetch next transaction
      // Drive transaction here
    end
  endtask
endclass
","""Verilog Mailboxes Usage Example for Transaction-Based Communication in a Testbench""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p298.jpg,True,"The image contains two excerpts of Verilog code. Below are the transcriptions of the code sections.

The first excerpt:

```verilog
module m1 (logic a, b, c, d, event ev1, ev2);
  default clocking EV1 @(ev1); endclocking
  sequence s4; b ##1 @(ev2) c; endsequence
  a1: assert property(a ##1 s4 |=> d);
endmodule
```

The second excerpt:

```verilog
module m2 (logic a, b, event ev1);
  a11_illegal: assert property(
    @(ev1) a implies b
  );
endmodule
```

These excerpts are used to explain concepts related to clocking in Verilog properties and assertions.","
module m1 (logic a, b, c, d, event ev1, ev2);
  default clocking EV1 @(ev1); endclocking
  sequence s4; b ##1 @(ev2) c; endsequence
  a1: assert property(a ##1 s4 |=> d);
endmodule


module m2 (logic a, b, event ev1);
  a11_illegal: assert property(
    @(ev1) a implies b
  );
endmodule
","Caption: ""Discussion and example of clock flow analysis in Verilog property specification with corresponding module definitions and assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p429.jpg,True,"The image contains Verilog code, as follows:

```verilog
assign ClockR = (ChipEna=='b1) ? ClkR : 1'b0;
assign ClockW = (ChipEna=='b1) ? ClkW : 1'b0;
```

Please note that in the actual code shared there might be a typographical error. It looks like the single quote in the condition `ChipEna=='b1` should be before the equal sign. The corrected code line should be as follows if this is a typo:

```verilog
assign ClockR = (ChipEna=='1b) ? ClkR : 1'b0;
assign ClockW = (ChipEna=='1b) ? ClkW : 1'b0;
```

This code represents two conditional continuous assignments in Verilog using ternary operators. It assigns values to `ClockR` and `ClockW` based on the value of `ChipEna`. If `ChipEna` is high ('1'), `ClockR` will be assigned the value of `ClkR` and `ClockW` will be assigned the value of `ClkW`. If `ChipEna` is low ('0'), both `ClockR` and `ClockW` are assigned a low value ('0').","
assign ClockR = (ChipEna=='b1) ? ClkR : 1'b0;
assign ClockW = (ChipEna=='b1) ? ClkW : 1'b0;


assign ClockR = (ChipEna=='1b) ? ClkR : 1'b0;
assign ClockW = (ChipEna=='1b) ? ClkW : 1'b0;
",Page from a textbook showing a figure and Verilog code for clock gating logic used in digital VLSI design.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p112.jpg,True,"The image contains snippets of Verilog code. Here is the code that is visible in the image:

```
in_p0.misc.rl.dsel = ( ~ i_scan ) & ( ~ reset );
in_p1.misc.rl.dsel = ( ~ i_scan ) & ( ~ reset );
in_p2.misc.rl.dsel = ( ~ i_scan ) & ( ~ reset );
in_p3.misc.rl.dsel = ( ~ i_scan ) & ( ~ reset );

Then, after optimization, there is only one statement to simulate.

in_p0.misc.rl.dsel = ( ~ i_scan ) & ( ~ reset );
```

The text explains an optimization process where multiple similar expressions are consolidated into a single expression to improve the efficiency of the simulation.","misc.rl.dsel = ( ~ i_scan ) & ( ~ reset );
in_p1.misc.rl.dsel = ( ~ i_scan ) & ( ~ reset );
in_p2.misc.rl.dsel = ( ~ i_scan ) & ( ~ reset );
in_p3.misc.rl.dsel = ( ~ i_scan ) & ( ~ reset );

Then, after optimization, there is only one statement to simulate.

in_p0.misc.rl.dsel = ( ~ i_scan ) & ( ~ reset );
","Caption: ""Excerpt from a document on Verilog optimization techniques, discussing common sub-expression consolidation to improve RTL compiler efficiency.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p106.jpg,True,"```verilog
module x;
    reg a,b,c;
    reg d,e;
    always @ (b or c)
        d = ~b & c;
    // Extra evaluation in event-driven simulation
    always @ (a or d)
    begin
        e = a ^ d;
        if ($time > 0) $display("" e = %b"",e);
    end
    initial
    begin
        {a,b,c} = 3'b000;
        #1;
        a = 1'b1;
        b = 1'b1;
        #1;
        $finish;
    end
endmodule // x
```","
module x;
    reg a,b,c;
    reg d,e;
    always @ (b or c)
        d = ~b & c;
    // Extra evaluation in event-driven simulation
    always @ (a or d)
    begin
        e = a ^ d;
        if ($time > 0) $display("" e = %b"",e);
    end
    initial
    begin
        {a,b,c} = 3'b000;
        #1;
        a = 1'b1;
        b = 1'b1;
        #1;
        $finish;
    end
endmodule // x
",Example of event-driven simulation using Verilog code with conditional display and initialization blocks.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p160.jpg,True,"The image contains the following Verilog code which defines the states of a finite state machine (FSM) using one-hot encoding:

```verilog
IDLE = 16'd1
GEN_BLK_ADDR = 16'd2
WAIT6 = 16'd4
NEXT_BLK = 16'd8
WAIT0 = 16'd16
CNT1 = 16'd32
WAIT1 = 16'd64
CNT2 = 16'd128
WAIT2 = 16'd256
CNT3 = 16'd512
WAIT3 = 16'd1024
CNT4 = 16'd2048
WAIT4 = 16'd4096
CNT5 = 16'd8192
WAIT5 = 16'd16384
CNT6 = 16'd32768
```

Please note that the text in the image also describes the behavior of the FSM coded with these states, such as moving to the IDLE state upon reset and generating control signals in a linear sequential fashion.","
IDLE = 16'd1
GEN_BLK_ADDR = 16'd2
WAIT6 = 16'd4
NEXT_BLK = 16'd8
WAIT0 = 16'd16
CNT1 = 16'd32
WAIT1 = 16'd64
CNT2 = 16'd128
WAIT2 = 16'd256
CNT3 = 16'd512
WAIT3 = 16'd1024
CNT4 = 16'd2048
WAIT4 = 16'd4096
CNT5 = 16'd8192
WAIT5 = 16'd16384
CNT6 = 16'd32768
","Caption: ""Excerpt from a document explaining a linear Finite State Machine (FSM) design coded with a one-hot encoding style in Verilog, including state declarations and operational overview.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p529.jpg,True,"The image contains Verilog code. Here is the code presented in the image:

First example:
```verilog
checker check1;
rand bit rst = 1’b1;
bit a = 1’b0;
bit b = 1’b0;

default clocking @($global_clock); endclocking
default disable iff rst;

always_ff @($global_clock)
    a <= 1’b1;

a1: assert property (a);
a2: assert property (b);
endchecker : check1
```

Second example:
```verilog
checker check2 (event clk);
rand bit rst = 1’b1;
bit a = 1’b0;
bit b = 1’b0;

default clocking @clk; endclocking
default disable iff rst;

always_ff @clk a <= 1’b1;

a1: assert property (a);
a2: assert property (b);
endchecker : check2
```

Please note that in the `rand bit rst` declarations and the `always_ff` assignments, there might be a typographical error where `1’b1` and `1’b0` should respectively be `1'b1` and `1'b0` with a single quote `(')` instead of an apostrophe `(’)`, to represent binary literals in Verilog correctly.","
checker check1;
rand bit rst = 1’b1;
bit a = 1’b0;
bit b = 1’b0;

default clocking @($global_clock); endclocking
default disable iff rst;

always_ff @($global_clock)
    a <= 1’b1;

a1: assert property (a);
a2: assert property (b);
endchecker : check1


checker check2 (event clk);
rand bit rst = 1’b1;
bit a = 1’b0;
bit b = 1’b0;

default clocking @clk; endclocking
default disable iff rst;

always_ff @clk a <= 1’b1;

a1: assert property (a);
a2: assert property (b);
endchecker : check2
",Excerpt from a technical document on Verilog illustrating free variable initialization and checker modeling with different clocking scenarios.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p49.jpg,True,"```verilog
property p10;
    @(posedge clk) a |-> ##2 b;
endproperty

a10 : assert property(p10);
``` 

This is the Verilog code that defines a property named `p10` and an assertion `a10` to check that property.","
property p10;
    @(posedge clk) a |-> ##2 b;
endproperty

a10 : assert property(p10);
",Verilog Assertion and Waveform for Property p10 Verification,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p243.jpg,True,"The image includes a snippet of Verilog code. Here is the code as shown in the image:

```verilog
class dyn_size;
  rand bit [31:0] d[];
  constraint d_size {d.size() inside {[1:10]}; }
endclass
```","
class dyn_size;
  rand bit [31:0] d[];
  constraint d_size {d.size() inside {[1:10]}; }
endclass
","Caption: ""Understanding Iterative and Array Constraints in Verilog, including an example of a size constraint for dynamic array size.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p61.jpg,True,"The image contains Verilog code. Here is the code as it appears in the image:

```verilog
module m (input logic rq, done, clk, ...);
  import common_props::*;
  wire [7:0] data;
  ...
  a1: assert final (one_cold(data));
  ...
  a2: assert property (@(posedge clk) req_granted(rq, done));
  ...
endmodule : m
```

```verilog
`define a 3 + 5
module m (...);
  let b = 3 + 5;
  wire [`a * 4] x;
  wire [b * 4] y;
  ...
endmodule : m
```

```verilog
module m (input logic a, b, c, clk, output logic x, y, z);
  initial begin
    y = 1'b0;
    z = 1'b0;
  end

  always_comb x = a & b;
  always_latch y = a | c;
  always_ff @(posedge clk) begin
    if (y) x <= a;
    @(posedge clk) x <= x & b;
  end

  final @(posedge clk) z <= x | y;
endmodule : m
```","
module m (input logic rq, done, clk, ...);
  import common_props::*;
  wire [7:0] data;
  ...
  a1: assert final (one_cold(data));
  ...
  a2: assert property (@(posedge clk) req_granted(rq, done));
  ...
endmodule : m


`define a 3 + 5
module m (...);
  let b = 3 + 5;
  wire [`a * 4] x;
  wire [b * 4] y;
  ...
endmodule : m


module m (input logic a, b, c, clk, output logic x, y, z);
  initial begin
    y = 1'b0;
    z = 1'b0;
  end

  always_comb x = a & b;
  always_latch y = a | c;
  always_ff @(posedge clk) begin
    if (y) x <= a;
    @(posedge clk) x <= x & b;
  end

  final @(posedge clk) z <= x | y;
endmodule : m
","Caption: ""Example page from a Verilog tutorial showing how to use packages, wild card imports, and various Verilog coding exercises.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p258.jpg,True,"The image contains Verilog code related to the Programming Language Interface (PLI) of Verilog. Here is the code as shown in the image:

```verilog
/* setup value change callback options */
time_s.type = vpiSuppressTime;
cb_data_s.reason = cbValueChange;
cb_data_s.cb_rtn = PLIbook_ScientificALU_interface;
cb_data_s.time = &time_s;
cb_data_s.value = &value_s;

/* add value change callbacks to all signals which are inputs to */
/* pass pointer to storage for handles as user_data value */
cb_data_s.user_data = (char *)ALUdata;
value_s.format = vpiRealVal;
cb_data_s.obj = ALUdata->a_h;
vpi_register_cb(&cb_data_s);

cb_data_s.obj = ALUdata->b_h;
vpi_register_cb(&cb_data_s);

value_s.format = vpiIntVal;
cb_data_s.obj = ALUdata->opcode_h;
vpi_register_cb(&cb_data_s);

return(0);
}

/***********************************************************************
* compiletf routine: Verifies that scientific_alu() is used correctly
* Note: For simplicity, only limited data types are allowed for
* task arguments. Could add checks to allow other data types.
***********************************************************************/

int PLIbook_ScientificALU_compiletf(char *user_data)
{
vpiHandle systf_h, arg_itr, arg_h;
int err = 0;

systf_h = vpi_handle(vpiSysTfCall, NULL);
arg_itr = vpi_iterate(vpiArgument, systf_h);
if (arg_itr == NULL) {
    vpi_printf(""ERROR: scientific_alu requires 6 arguments\n"");
    tf_dofinish();
    return(0);
}

arg_h = vpi_scan(arg_itr); /* 1st arg is a input */
if (vpi_get(vpiType, arg_h) != vpiRealVar) {
    vpi_printf(""scientific_alu arg 1 (a) must be a real variable\n"");
    err = 1;
}

arg_h = vpi_scan(arg_itr); /* 2nd arg is b input */
if (vpi_get(vpiType, arg_h) != vpiRealVar) {
    vpi_printf(""scientific_alu arg 2 (b) must be a real variable\n"");
    err = 1;
}
```

This code segment appears to deal with setting up callback options for value changes and verifying the use of `scientific_alu()` for its proper application. It leverages Verilog PLI functions like `vpi_register_cb`, `vpi_handle`, `vpi_iterate`, `vpi_scan`, and `vpi_get` for interaction with the simulation kernel and to ensure arguments passed to tasks are of expected types.","
/* setup value change callback options */
time_s.type = vpiSuppressTime;
cb_data_s.reason = cbValueChange;
cb_data_s.cb_rtn = PLIbook_ScientificALU_interface;
cb_data_s.time = &time_s;
cb_data_s.value = &value_s;

/* add value change callbacks to all signals which are inputs to */
/* pass pointer to storage for handles as user_data value */
cb_data_s.user_data = (char *)ALUdata;
value_s.format = vpiRealVal;
cb_data_s.obj = ALUdata->a_h;
vpi_register_cb(&cb_data_s);

cb_data_s.obj = ALUdata->b_h;
vpi_register_cb(&cb_data_s);

value_s.format = vpiIntVal;
cb_data_s.obj = ALUdata->opcode_h;
vpi_register_cb(&cb_data_s);

return(0);
}

/***********************************************************************
* compiletf routine: Verifies that scientific_alu() is used correctly
* Note: For simplicity, only limited data types are allowed for
* task arguments. Could add checks to allow other data types.
***********************************************************************/

int PLIbook_ScientificALU_compiletf(char *user_data)
{
vpiHandle systf_h, arg_itr, arg_h;
int err = 0;

systf_h = vpi_handle(vpiSysTfCall, NULL);
arg_itr = vpi_iterate(vpiArgument, systf_h);
if (arg_itr == NULL) {
    vpi_printf(""ERROR: scientific_alu requires 6 arguments\n"");
    tf_dofinish();
    return(0);
}

arg_h = vpi_scan(arg_itr); /* 1st arg is a input */
if (vpi_get(vpiType, arg_h) != vpiRealVar) {
    vpi_printf(""scientific_alu arg 1 (a) must be a real variable\n"");
    err = 1;
}

arg_h = vpi_scan(arg_itr); /* 2nd arg is b input */
if (vpi_get(vpiType, arg_h) != vpiRealVar) {
    vpi_printf(""scientific_alu arg 2 (b) must be a real variable\n"");
    err = 1;
}
","""Example of Verilog PLI code for setting up callback options and verifying correct usage of a scientific ALU function.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p84.jpg,True,"The image contains code from a document which appears to be discussing associative arrays in the context of Verilog or SystemVerilog. Here's the code snippet from the image:

```verilog
// Input file contains:
// 42 min_address
// 1492 max_address

int switch[string], min_address, max_address, i, file;
initial begin
  string s;
  file = $fopen(""switch.txt"", ""r"");
  while (! $feof(file)) begin
    $fscanf(file, ""%d %s"", i, s);
    switch[s] = i;
  end
  $fclose(file);

  // Get the min address
  // If string not found, use default value of 0 for int array
  min_address = switch[""min_address""];

  // Get the max address.
  // Use 1000 if max_address does not exist
  if (switch.exists(""max_address""))
    max_address = switch[""max_address""];
  else
    max_address = 1000;

  // Print all switches
  foreach (switch[s])
    $display(""switch['%s']=%0d"", s, switch[s]);
end
```

This code is meant to demonstrate how to work with associative arrays in SystemVerilog, including reading from a file, checking if an element exists in an associative array and iterating through the associative array.","
// Input file contains:
// 42 min_address
// 1492 max_address

int switch[string], min_address, max_address, i, file;
initial begin
  string s;
  file = $fopen(""switch.txt"", ""r"");
  while (! $feof(file)) begin
    $fscanf(file, ""%d %s"", i, s);
    switch[s] = i;
  end
  $fclose(file);

  // Get the min address
  // If string not found, use default value of 0 for int array
  min_address = switch[""min_address""];

  // Get the max address.
  // Use 1000 if max_address does not exist
  if (switch.exists(""max_address""))
    max_address = switch[""max_address""];
  else
    max_address = 1000;

  // Print all switches
  foreach (switch[s])
    $display(""switch['%s']=%0d"", s, switch[s]);
end
","Caption: ""Example of using an associative array with string keys in Verilog to read and process input from a file.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p257.jpg,True,"The image includes a snippet of Verilog code. Here is the code extracted from the image:

```verilog
bit [31:0] state = 32'h12345678;
function bit [31:0] my_random();
    bit [63:0] s64;
    s64 = state * state;
    state = (s64 >> 16) + state;
    return state;
endfunction
```","
bit [31:0] state = 32'h12345678;
function bit [31:0] my_random();
    bit [63:0] s64;
    s64 = state * state;
    state = (s64 >> 16) + state;
    return state;
endfunction
",The image displays text and an example of a simple pseudorandom number generator code written in Verilog.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p75.jpg,True,"The image contains Verilog code. Here is the code transcribed from the image:

```verilog
module m (input logic in, clk);
    wire w, not_w, w_or_not_w;
    logic next_w, v, not_v, v_or_not_v, next_v;
    logic onew = 1'b1, onew = 1'b1;

    assign w = in;
    assign not_w = !in;
    assign w_or_not_w = w || not_w;

    always @(posedge clk) begin
        next_w <= w;
        onew <= v_or_not_v;
        onew <= w_or_not_w;
    end

    always_comb begin
        v = in;
        not_v = !in;
        v_or_not_v = v || not_v;
    end

    a1: assert property (@(posedge clk) w_or_not_w);
    a2: assert property (@(posedge clk) v_or_not_v);
endmodule : m
```

Please note that the second declaration of `logic onew` seems to have a typo where it says `onew = 1'b1;` twice, which would likely cause a compile error. Verilog does not allow multiple declarations of the same variable with different initial values in the same scope.","
module m (input logic in, clk);
    wire w, not_w, w_or_not_w;
    logic next_w, v, not_v, v_or_not_v, next_v;
    logic onew = 1'b1, onew = 1'b1;

    assign w = in;
    assign not_w = !in;
    assign w_or_not_w = w || not_w;

    always @(posedge clk) begin
        next_w <= w;
        onew <= v_or_not_v;
        onew <= w_or_not_w;
    end

    always_comb begin
        v = in;
        not_v = !in;
        v_or_not_v = v || not_v;
    end

    a1: assert property (@(posedge clk) w_or_not_w);
    a2: assert property (@(posedge clk) v_or_not_v);
endmodule : m
","""Verilog code example and exercises focused on simulation semantics, identifying glitches, races, and understanding assertion clocks in SystemVerilog.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p174.jpg,True,"The image contains a snippet of Verilog code. Here it is transcribed:

```verilog
next <= IDLE2;
MASTER3:
if (!done)
    next <= MASTER3;
else
    next <= IDLE3;

IDLE3:
if (req1 == 1'b0)
    next <= MASTER1;
else if ((req1 == 1'b1 & req2 == 1'b0)
    next <= MASTER2;
else if ((req2 == 1'b1 & req3 == 1'b0)
    next <= MASTER3;
else
    next <= IDLE3;
endcase

end

/* output generating statements */

assign gnt1 = ((state == MASTER1)) ? 0 : 1;
assign gnt2 = ((state == MASTER2)) ? 0 : 1;
assign gnt3 = ((state == MASTER3)) ? 0 : 1;

endmodule
```

Note: Be aware that the snippet seems incomplete, and there may have been preceding text that is not included here, also the `endcase` appears without a matching `case` statement due to the same reason. Additional context from outside of this snippet would be required to fully understand or utilize this code.","
next <= IDLE2;
MASTER3:
if (!done)
    next <= MASTER3;
else
    next <= IDLE3;

IDLE3:
if (req1 == 1'b0)
    next <= MASTER1;
else if ((req1 == 1'b1 & req2 == 1'b0)
    next <= MASTER2;
else if ((req2 == 1'b1 & req3 == 1'b0)
    next <= MASTER3;
else
    next <= IDLE3;
endcase

end

/* output generating statements */

assign gnt1 = ((state == MASTER1)) ? 0 : 1;
assign gnt2 = ((state == MASTER2)) ? 0 : 1;
assign gnt3 = ((state == MASTER3)) ? 0 : 1;

endmodule
","""Verilog code snippet of a finite state machine (FSM) logic for bus arbitration and corresponding output generating statements.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p75.jpg,True,"```verilog
Property p26;
@(posedge clk) $rose(start) |-> 
```

The rest of the code is not visible in the image.","
Property p26;
@(posedge clk) $rose(start) |-> 
","""Waveform and explanation of an SVA checker using SystemVerilog repetition operators.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p273.jpg,True,"```verilog
module m(input logic clk, a, b, ...);
  logic c;
  sequence ab;
    @(posedge clk) a ##1 b;
  endsequence
  always @(posedge clk) begin
    c <= ab.triggered;
    //...
  end
  //...
endmodule : m
```

These are the lines of Verilog code shown in the image. The code is an example given in the context of Sequence Methods in Verilog.","
module m(input logic clk, a, b, ...);
  logic c;
  sequence ab;
    @(posedge clk) a ##1 b;
  endsequence
  always @(posedge clk) begin
    c <= ab.triggered;
    //...
  end
  //...
endmodule : m
","""Exploring Sequence Methods and Triggered Mechanisms in Verilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p264.jpg,True,"The image contains a section of text related to Verilog PLI (Programming Language Interface) with a specific focus on callback routines and synchronization with the end of a simulation time step. There is also a snippet of code provided at the bottom of the image. Here is the code from the image:

```c
#include <stdlib.h>  /* ANSI C standard library */
#include <stdio.h>   /* ANSI C standard input/output library */
#include ""vpi_user.h"" /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library 
                        (using TF routines for simulation control) */

/* prototypes of routines in this PLI application */
int PLIbook_ScientificALU_calltf(), PLIbook_ScientificALU_compiletf();
int PLIbook_ScientificALU_interface();
int PLIbook_EndOfTimeStep_callback();
```

This code is a C header portion for setting up a Verilog PLI interface, which includes the prototypes of the routines that are presumably implemented elsewhere in the application's source files. These functions are typically used to define PLI applications which interact with Verilog simulators.","ude <stdlib.h>  /* ANSI C standard library */
#include <stdio.h>   /* ANSI C standard input/output library */
#include ""vpi_user.h"" /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h"" /* IEEE 1364 PLI TF routine library 
                        (using TF routines for simulation control) */

/* prototypes of routines in this PLI application */
int PLIbook_ScientificALU_calltf(), PLIbook_ScientificALU_compiletf();
int PLIbook_ScientificALU_interface();
int PLIbook_EndOfTimeStep_callback();
","The image contains an excerpt from ""The Verilog PLI Handbook"" discussing the implementation of a C model interface synchronized with the end of a simulation time step in Verilog, including a list of source code files related to the example.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p398.jpg,True,"The image contains Verilog code, and here it is:

```verilog
case (ClockIn_EdgeCount) // The external ClockIn edges.
    2'b00: case (VFO_EdgeCount) // The MultiCounter overflow edges.
        2'b00: AdjustFreq = 2'b01; // No change.
        default: AdjustFreq = 2'b00; // Slow the counter.
    endcase
    2'b01: case (VFO_EdgeCount)
        2'b00: AdjustFreq = 2'b11; // Speed up the counter.
        2'b01: AdjustFreq = 2'b01; // No change.
        default: AdjustFreq = 2'b00; // Slow the counter.
    endcase
    2'b10: case (VFO_EdgeCount)
        2'b00: AdjustFreq = 2'b10; // No change.
        2'b11: AdjustFreq = 2'b00; // Slow the counter.
        default: AdjustFreq = 2'b11; // Speed up the counter.
    endcase
    default: case (VFO_EdgeCount) // Includes 2'b11 for initialization:
        2'b11: AdjustFreq = 2'b10; // No change.
        default: AdjustFreq = 2'b11; // Speed up the counter.
    endcase
endcase
```

This code is showing how different cases for `ClockIn_EdgeCount` and `VFO_EdgeCount` affect the variable `AdjustFreq`, likely within a digital phase-locked loop (PLL) or similar digital signal processing system.","
case (ClockIn_EdgeCount) // The external ClockIn edges.
    2'b00: case (VFO_EdgeCount) // The MultiCounter overflow edges.
        2'b00: AdjustFreq = 2'b01; // No change.
        default: AdjustFreq = 2'b00; // Slow the counter.
    endcase
    2'b01: case (VFO_EdgeCount)
        2'b00: AdjustFreq = 2'b11; // Speed up the counter.
        2'b01: AdjustFreq = 2'b01; // No change.
        default: AdjustFreq = 2'b00; // Slow the counter.
    endcase
    2'b10: case (VFO_EdgeCount)
        2'b00: AdjustFreq = 2'b10; // No change.
        2'b11: AdjustFreq = 2'b00; // Slow the counter.
        default: AdjustFreq = 2'b11; // Speed up the counter.
    endcase
    default: case (VFO_EdgeCount) // Includes 2'b11 for initialization:
        2'b11: AdjustFreq = 2'b10; // No change.
        default: AdjustFreq = 2'b11; // Speed up the counter.
    endcase
endcase
","""Excerpt from a Digital VLSI Design with Verilog textbook showing a case statement in Verilog code for PLL frequency adjustment.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p267.jpg,True,"The image contains text about Verilog sequence methods and includes two examples of Verilog code. Here are the code snippets:

1.
```verilog
a |-> b ##1 first_match(c[*] ##1 d) ##1 e and
a |-> b ##1 c[*] ##1 d ##1 e.
```

2.
```verilog
a ##1 first_match(b[*] ##1 c) |-> d and
a ##1 b[*] ##1 c |-> d.
```

The text explains the efficiency considerations when using the `first_match` operator and differentiates between sequence operators and sequence methods.","
a |-> b ##1 first_match(c[*] ##1 d) ##1 e and
a |-> b ##1 c[*] ##1 d ##1 e.


a ##1 first_match(b[*] ##1 c) |-> d and
a ##1 b[*] ##1 c |-> d.
","""Exploring Verilog sequence methods and efficiency tips, with focus on the `triggered` method for detecting end points in sequences.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p270.jpg,True,"The image contains code from ""The Verilog PLI Handbook, Part One."" Here's the code excerpt from the image:

```c
int *err,            /* output; set if input is out of range */
double a;            /* input */
double b;            /* input */
int opcode,          /* input */
int enable,          /* input; 0 = latched */
PLIbook_ALU_outputs_p LatchedOutputs) /* input */
{
    if (enable) { /* ALU is not latched, calculate outputs and store */
        switch (opcode) {
            case 0x0: LatchedOutputs->result = pow (a, b); break;
            case 0x1: LatchedOutputs->result = sqrt (a); break;
            case 0x2: LatchedOutputs->result = exp (a); break;
            case 0x3: LatchedOutputs->result = ldexp (a, (int)b); break;
            case 0x4: LatchedOutputs->result = fabs (a); break;
            case 0x5: LatchedOutputs->result = fmod (a, b); break;
            case 0x6: LatchedOutputs->result = ceil (a); break;
            case 0x7: LatchedOutputs->result = floor (a); break;
            case 0x8: LatchedOutputs->result = log (a); break;
            case 0x9: LatchedOutputs->result = log10 (a); break;
            case 0xA: LatchedOutputs->result = sin (a); break;
            case 0xB: LatchedOutputs->result = cos (a); break;
            case 0xC: LatchedOutputs->result = tan (a); break;
            case 0xD: LatchedOutputs->result = asin (a); break;
            case 0xE: LatchedOutputs->result = acos (a); break;
            case 0xF: LatchedOutputs->result = atan (a); break;
        }
        LatchedOutputs->err = (errno == EDOM); /* arg out of range */
        LatchedOutputs->excep = (errno == ERANGE);/* result out of range */
        errno = 0;                             /* clear the error flag */
        if (LatchedOutputs->err) LatchedOutputs->result = 0.0;
    }

    /* return the values stored in the C model */
    *result = LatchedOutputs->result;
    *err = LatchedOutputs->err;
    *excep = LatchedOutputs->excep;

    return;
}
```

Below the code, there is a description for an example that reads:
```
Example 7-7: combinational logic interface to the latched scientific ALU C model
```

Followed by a list of include directives and function prototypes:
```c
#include <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard input/output library */
#include <""vpi_user.h""> /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h""  /* IEEE 1364 PLI TF routine library */
                     /* (using TF routines for simulation control) */

/* prototypes of routines in this PLI application */
int PLIbook_ScientificALU_calltf(), PLIbook_ScientificALU_compiletf();
int PLIbook_ScientificALU_interface();
```

Please note there is a typographical error in the `#include` directive, where the angle brackets `<>` are used incorrectly with quotation marks. It should either be `#include <vpi_user.h>` or `#include ""vpi_user.h""`.","err,            /* output; set if input is out of range */
double a;            /* input */
double b;            /* input */
int opcode,          /* input */
int enable,          /* input; 0 = latched */
PLIbook_ALU_outputs_p LatchedOutputs) /* input */
{
    if (enable) { /* ALU is not latched, calculate outputs and store */
        switch (opcode) {
            case 0x0: LatchedOutputs->result = pow (a, b); break;
            case 0x1: LatchedOutputs->result = sqrt (a); break;
            case 0x2: LatchedOutputs->result = exp (a); break;
            case 0x3: LatchedOutputs->result = ldexp (a, (int)b); break;
            case 0x4: LatchedOutputs->result = fabs (a); break;
            case 0x5: LatchedOutputs->result = fmod (a, b); break;
            case 0x6: LatchedOutputs->result = ceil (a); break;
            case 0x7: LatchedOutputs->result = floor (a); break;
            case 0x8: LatchedOutputs->result = log (a); break;
            case 0x9: LatchedOutputs->result = log10 (a); break;
            case 0xA: LatchedOutputs->result = sin (a); break;
            case 0xB: LatchedOutputs->result = cos (a); break;
            case 0xC: LatchedOutputs->result = tan (a); break;
            case 0xD: LatchedOutputs->result = asin (a); break;
            case 0xE: LatchedOutputs->result = acos (a); break;
            case 0xF: LatchedOutputs->result = atan (a); break;
        }
        LatchedOutputs->err = (errno == EDOM); /* arg out of range */
        LatchedOutputs->excep = (errno == ERANGE);/* result out of range */
        errno = 0;                             /* clear the error flag */
        if (LatchedOutputs->err) LatchedOutputs->result = 0.0;
    }

    /* return the values stored in the C model */
    *result = LatchedOutputs->result;
    *err = LatchedOutputs->err;
    *excep = LatchedOutputs->excep;

    return;
}

e 7-7: combinational logic interface to the latched scientific ALU C model

ude <stdlib.h> /* ANSI C standard library */
#include <stdio.h>  /* ANSI C standard input/output library */
#include <""vpi_user.h""> /* IEEE 1364 PLI VPI routine library */
#include ""veriuser.h""  /* IEEE 1364 PLI TF routine library */
                     /* (using TF routines for simulation control) */

/* prototypes of routines in this PLI application */
int PLIbook_ScientificALU_calltf(), PLIbook_ScientificALU_compiletf();
int PLIbook_ScientificALU_interface();
","Caption: ""Example of a Verilog Programming Language Interface (PLI) code snippet showing the integration of C with Verilog for an Arithmetic Logic Unit (ALU) simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p148.jpg,True,"The image contains Verilog code related to SVA (SystemVerilog Assertions) simulation methodology within a document. Here is the code extracted from the image:

```verilog
ml_t1_r++;
if(ml_t1_r == 3) ml_t1_r_flag = 1'b1;
end

c_mlt1w: cover property(p_mlt1w)
begin
ml_t1_w++;
if(ml_t1_w == 3) ml_t1_w_flag = 1'b1;
end

c_mlt0r: cover property(p_mlt0r)
begin
ml_t0_r++;
if(ml_t0_r == 3) ml_t0_r_flag = 1'b1;
end

c_mlt0w: cover property(p_mlt0w)
begin
ml_t0_w++;
if(ml_t0_w == 3) ml_t0_w_flag = 1'b1;
end

c_m2t1r: cover property(p_m2t1r)
begin
m2_t1_r++;
if(m2_t1_r == 3) m2_t1_r_flag = 1'b1;
end

c_m2t1w: cover property(p_m2t1w)
begin
m2_t1_w++;
if(m2_t1_w == 3) m2_t1_w_flag = 1'b1;
end

c_m2t0r: cover property(p_m2t0r)
begin
m2_t0_r++;
if(m2_t0_r == 3) m2_t0_r_flag = 1'b1;
end

c_m2t0w: cover property(p_m2t0w)
begin
m2_t0_w++;
```

Please note that some of the code statements are not complete and may have missing 'end' keywords or other parts. Also, the code appears to be part of a larger document or book, discussing simulation methodology using SystemVerilog Assertions.","
ml_t1_r++;
if(ml_t1_r == 3) ml_t1_r_flag = 1'b1;
end

c_mlt1w: cover property(p_mlt1w)
begin
ml_t1_w++;
if(ml_t1_w == 3) ml_t1_w_flag = 1'b1;
end

c_mlt0r: cover property(p_mlt0r)
begin
ml_t0_r++;
if(ml_t0_r == 3) ml_t0_r_flag = 1'b1;
end

c_mlt0w: cover property(p_mlt0w)
begin
ml_t0_w++;
if(ml_t0_w == 3) ml_t0_w_flag = 1'b1;
end

c_m2t1r: cover property(p_m2t1r)
begin
m2_t1_r++;
if(m2_t1_r == 3) m2_t1_r_flag = 1'b1;
end

c_m2t1w: cover property(p_m2t1w)
begin
m2_t1_w++;
if(m2_t1_w == 3) m2_t1_w_flag = 1'b1;
end

c_m2t0r: cover property(p_m2t0r)
begin
m2_t0_r++;
if(m2_t0_r == 3) m2_t0_r_flag = 1'b1;
end

c_m2t0w: cover property(p_m2t0w)
begin
m2_t0_w++;
",A page from a document showing the SVA (SystemVerilog Assertions) simulation methodology with multiple cover property blocks for verification purposes.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p61.jpg,True,"```verilog
property p17;
    @(posedge clk) c ? d == a : d == b;
endproperty

a17: assert property(p17);
```","
property p17;
    @(posedge clk) c ? d == a : d == b;
endproperty

a17: assert property(p17);
","Caption: ""Verilog waveform illustration and SystemVerilog Assertion (SVA) using a select operator for signal verification in digital design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/JohnWilliams-Digital VLSI Design with Verilog_p171.jpg,True,"This image contains Verilog code. Here it is:

```verilog
reg[3:0] A, B;
...
A = 4'b01x1;
B = 4'b0011;
if (A > B)
    x = 1'b1;
else x = 1'b0;

if (A == A)
    x = 1'b1;
else x = 1'b0;

case (A)
    4'b0000: x = 1'b0;
    4'b0011: x = 1'b0;
    4'b01x1: x = 1'b1;
    default: x = 1'bx;
endcase
``` 

As explained in the image, when using relational expressions in Verilog, values that are not explicitly '1' or '0', like 'x', will cause the expression to evaluate as false. Additionally, there is an example using a case statement to handle all four Verilog logic levels.","
reg[3:0] A, B;
...
A = 4'b01x1;
B = 4'b0011;
if (A > B)
    x = 1'b1;
else x = 1'b0;

if (A == A)
    x = 1'b1;
else x = 1'b0;

case (A)
    4'b0000: x = 1'b0;
    4'b0011: x = 1'b0;
    4'b01x1: x = 1'b1;
    default: x = 1'bx;
endcase
","Caption: ""Handling of unknowns 'x' in relational expressions and four-state logic in Verilog code.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p243.jpg,True,"Yes, there is code in the image. Here is the Verilog code provided:

```verilog
// for a push and a pop, then on the next cycle the top of the
// stack must equal what was previously pushed onto the stack
// and the stack depth is the same
property push_and_pop_good;
    @(posedge clk)
        (push & pop) |=> ($past(data_in) == top_of_stack && $stable(valid));
endproperty
assert property (push_and_pop_good);
```","
// for a push and a pop, then on the next cycle the top of the
// stack must equal what was previously pushed onto the stack
// and the stack depth is the same
property push_and_pop_good;
    @(posedge clk)
        (push & pop) |=> ($past(data_in) == top_of_stack && $stable(valid));
endproperty
assert property (push_and_pop_good);
",An example of a SystemVerilog assertion to verify correct push and pop operations of a stack.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p257.jpg,True,"The image contains two blocks of code written in SystemVerilog. Here's the first:

```verilog
property legal_states;
    @(posedge clk) disable iff !rst_n
        state inside {`IDLE, `READ, `READ1, `REFRESH, `STALL};
endproperty
assert property (legal_states);
```

And here's the second:

```verilog
property illegal_input; // wrong time for input
    @(posedge clk) not ((state inside {`READ, `READ1}) & (req | abort));
endproperty
assert property (illegal_input);
```

These code excerpts define properties for legal states and illegal inputs within a finite state machine (FSM) to be used for assertion-based verification.","
property legal_states;
    @(posedge clk) disable iff !rst_n
        state inside {`IDLE, `READ, `READ1, `REFRESH, `STALL};
endproperty
assert property (legal_states);


property illegal_input; // wrong time for input
    @(posedge clk) not ((state inside {`READ, `READ1}) & (req | abort));
endproperty
assert property (illegal_input);
","""Excerpt from a technical book showcasing SystemVerilog code for state machine verification using assertions.""
",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p69.jpg,True,"The image does include a snippet of Verilog code. Here is the code:

```verilog
always @(posedge clk)
begin
    if (a)
    begin
        @(posedge d);
        bORc: assert (b || c) $display(""\n"", $stime, , ,"" %m assert passed\n"");
        else //This 'else' is for the 'assert'; not for the 'if (a)'
        $fatal(""\n"", $stime, , ,"" %m assert failed \n"");
    end
end
```

This snippet illustrates an example of an immediate assertion in a Verilog procedural block.","
always @(posedge clk)
begin
    if (a)
    begin
        @(posedge d);
        bORc: assert (b || c) $display(""\n"", $stime, , ,"" %m assert passed\n"");
        else //This 'else' is for the 'assert'; not for the 'if (a)'
        $fatal(""\n"", $stime, , ,"" %m assert failed \n"");
    end
end
","Caption: ""Explanation and example of an immediate assertion in Verilog, demonstrating how it is used within procedural code to check non-temporal expressions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p96.jpg,True,"The image contains Verilog code which is related to concurrent assertions. Here is the transcription of the Verilog code:

```verilog
module examples_NO_default (input logic a, b, c, clk);
  property q1;
    $rose(a) |-> ##[1:5] b;
  endproperty

  property q5;
    @(negedge clk) b[*3] |=> |b;
  endproperty

  property q6;
    q1 and q5;
  endproperty

  a5: assert property (q6); // illegal: no leading clocking event
  a6: assert property ($fell(c) |=> q6); // illegal: no leading clocking event

  sequence s2;
    $rose(a) ##[1:5] b;
  endsequence

  c1: cover property (s2); // illegal: no leading clocking event
  c2: cover property (@(negedge clk) s2); // legal: explicit leading clocking event,
                                          // @(negedge clk) determined from
                                          // declaration of s3

  sequence s3;
    @(negedge clk) s2;
  endsequence

  c3: cover property (s3); // legal: leading clocking event, @(negedge clk), determined from
                           // declaration of s3

endmodule
```

This code snippet shows several examples of properties and sequences that either conform to or violate rules about leading clocking events in concurrent assertions within Verilog.","
module examples_NO_default (input logic a, b, c, clk);
  property q1;
    $rose(a) |-> ##[1:5] b;
  endproperty

  property q5;
    @(negedge clk) b[*3] |=> |b;
  endproperty

  property q6;
    q1 and q5;
  endproperty

  a5: assert property (q6); // illegal: no leading clocking event
  a6: assert property ($fell(c) |=> q6); // illegal: no leading clocking event

  sequence s2;
    $rose(a) ##[1:5] b;
  endsequence

  c1: cover property (s2); // illegal: no leading clocking event
  c2: cover property (@(negedge clk) s2); // legal: explicit leading clocking event,
                                          // @(negedge clk) determined from
                                          // declaration of s3

  sequence s3;
    @(negedge clk) s2;
  endsequence

  c3: cover property (s3); // legal: leading clocking event, @(negedge clk), determined from
                           // declaration of s3

endmodule
","""Excerpt from a textbook or document discussing legal and illegal conditions in concurrent assertions in Verilog with code examples.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p211.jpg,True,"The image does contain Verilog code. Here it is:

```verilog
application
  sequence rdc;
    ##[1:5] rdDone;
  endsequence

  sequence dataCheck;
    int local_data;
    (rdc, local_data=rData) ##5 (wData == (local_data+'hff));
  endsequence

  baseP: assert property (@(posedge clk) RdWr |->
    dataCheck) else gotoFail;
```

The code appears to be part of an example explaining the usage of local variables in SystemVerilog Assertions (SVA).","
application
  sequence rdc;
    ##[1:5] rdDone;
  endsequence

  sequence dataCheck;
    int local_data;
    (rdc, local_data=rData) ##5 (wData == (local_data+'hff));
  endsequence

  baseP: assert property (@(posedge clk) RdWr |->
    dataCheck) else gotoFail;
","""Explaining the use of local variables in SystemVerilog Assertions (SVA) for checking pipelined behavior in digital design.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p280.jpg,True,"```verilog
property forbidden_sequence;
  @(posedge clk)
    not (~ce_n & (~rd_n | ~we_n) ##0 $isunknown(addr));
endproperty

assert property (forbidden_sequence)
  else $error(""Unknown address during memory request."");
```","
property forbidden_sequence;
  @(posedge clk)
    not (~ce_n & (~rd_n | ~we_n) ##0 $isunknown(addr));
endproperty

assert property (forbidden_sequence)
  else $error(""Unknown address during memory request."");
","Caption: ""Excerpt from a SystemVerilog reference guide detailing the problem of unknown addresses in RTL models and providing a solution with an example assertion for detecting forbidden sequences in memory addressing.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p728.jpg,True,"The image you've provided contains a text description of several functions related to the Verilog Programming Language Interface (PLI), along with a structure definition in the C programming language. This is not Verilog HDL code, but rather the C interface to interact with Verilog simulators. Here is the text from the image:

```
void tf_dostop()
Executes the same functionality as the Verilog $stop task.

void tf_error(format, arg1,...arg5)
char *format              quoted character string of formatted message.
arg1...arg5               arguments to formatted message string.
Prints a formatted message to the simulator’s output channel and output log file.
Uses formatting controls similar to C printf, with a maximum of 5 arguments.

void tf_evaluatep(n)
void tf_ievaluatep(n, tfinst)
int        n               index number of a system task/function argument.
char       *tfinst         pointer to an instance of a system task/function.
Evaluates the value of argument n of the calling or specific instance of a system
task/function and places it into an application-allocated s_tfexprinfo structure. The
tf_exprinfo() routine must have been previously called to setup the structure.

p_tfexprinfo tf_exprinfo(n, info)
p_tfexprinfo tf_iexprinfo(n, info, tfinst)
int         n               index number of a system task/function argument.
p_tfexprinfo *info          pointer to application-allocated s_tfexprinfo structure to
                            receive the expression information.
char        *tfinst         pointer to an instance of a system task/function.
Retrieves expression information about argument n of the calling or specific
instance of a system task/function argument and places the information into an
s_tfexprinfo structure pointed to by info. Returns the value of info if successful and
0 if an error occurred.

typedef struct t_tfexprinfo {
    short expr_type;    /* tf_nullparam, tf_string, tf_readonly,
                           tf_readonlyreal, tf_readwrite, tf_readwritereal,
                           tf_mwbitselect, tf_mwpartselect, tf_mwmemselect */
    short padding;
    struct t_vecval *expr_value_p;
    double real_value;
    char   *expr_string;
    int    expr_ngroups;
    int    expr_vec_size;
    int    expr_sign;
    int    expr_lhs_select;
    int    expr_rhs_select;
} s_tfexprinfo, *p_tfexprinfo;
```

These descriptions and declarations are part of the C interface for interacting with Verilog simulators using the PLI.","f_dostop()
Executes the same functionality as the Verilog $stop task.

void tf_error(format, arg1,...arg5)
char *format              quoted character string of formatted message.
arg1...arg5               arguments to formatted message string.
Prints a formatted message to the simulator’s output channel and output log file.
Uses formatting controls similar to C printf, with a maximum of 5 arguments.

void tf_evaluatep(n)
void tf_ievaluatep(n, tfinst)
int        n               index number of a system task/function argument.
char       *tfinst         pointer to an instance of a system task/function.
Evaluates the value of argument n of the calling or specific instance of a system
task/function and places it into an application-allocated s_tfexprinfo structure. The
tf_exprinfo() routine must have been previously called to setup the structure.

p_tfexprinfo tf_exprinfo(n, info)
p_tfexprinfo tf_iexprinfo(n, info, tfinst)
int         n               index number of a system task/function argument.
p_tfexprinfo *info          pointer to application-allocated s_tfexprinfo structure to
                            receive the expression information.
char        *tfinst         pointer to an instance of a system task/function.
Retrieves expression information about argument n of the calling or specific
instance of a system task/function argument and places the information into an
s_tfexprinfo structure pointed to by info. Returns the value of info if successful and
0 if an error occurred.

typedef struct t_tfexprinfo {
    short expr_type;    /* tf_nullparam, tf_string, tf_readonly,
                           tf_readonlyreal, tf_readwrite, tf_readwritereal,
                           tf_mwbitselect, tf_mwpartselect, tf_mwmemselect */
    short padding;
    struct t_vecval *expr_value_p;
    double real_value;
    char   *expr_string;
    int    expr_ngroups;
    int    expr_vec_size;
    int    expr_sign;
    int    expr_lhs_select;
    int    expr_rhs_select;
} s_tfexprinfo, *p_tfexprinfo;
","The image shows a page from ""The Verilog PLI Handbook"" with descriptions of various Verilog Programming Language Interface (PLI) routines.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p294.jpg,True,"The image contains two pieces of code written in Property Specification Language (PSL) and SystemVerilog respectively. Here they are transcribed:

PSL code:

```verilog
default clock = (posedge clk);

property EvenOddAddr =
  always { (rose(write)) |->
           {{transfer[-1] ##1 !addr[0];
             transfer[-1] ##1 addr[0] [*1];
             fell(write)
           }};
assert EvenOddAddr;
```

SystemVerilog code:

```verilog
property EvenOddAddr =
  @(posedge clk)
    $rose(write) |->
      (transfer[-1] ##1 !addr[0] &&
       ##1 transfer[-1] ##1 addr[0] [*1] &&
       ##1 $fell(write));
endproperty

assert property (EvenOddAddr);
```","
default clock = (posedge clk);

property EvenOddAddr =
  always { (rose(write)) |->
           {{transfer[-1] ##1 !addr[0];
             transfer[-1] ##1 addr[0] [*1];
             fell(write)
           }};
assert EvenOddAddr;


property EvenOddAddr =
  @(posedge clk)
    $rose(write) |->
      (transfer[-1] ##1 !addr[0] &&
       ##1 transfer[-1] ##1 addr[0] [*1] &&
       ##1 $fell(write));
endproperty

assert property (EvenOddAddr);
","Caption: ""Examples of Property Specification Language (PSL) and SystemVerilog assertions for verifying even and odd memory write addresses.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p205.jpg,True,"The image displays four blocks of code referencing property definitions in Verilog's system-level verification language, SystemVerilog. Here are the code snippets provided:

1. First code block:
```verilog
property mclocks;
  @(posedge clk0) A |->
    if (D) @(posedge clk0) B;
endproperty
```
This is followed by a statement suggesting an equivalent shorthand for this property:
```verilog
// This is equivalent to
// @(posedge clk0) A |->
//   if (D) B else (-B) ;
```

2. Second code block:
```verilog
property mclocks;
  @(posedge clk0) A |->
    if (D) @(posedge clk0) B
    else @(posedge clk0) (-B);
endproperty
```
Again, an equivalent shorthand is suggested:
```verilog
// This is equivalent to
// @(posedge clk0) A |->
//   if (D) B else (-B) ;
```

3. Third code block:
```verilog
property mclocks;
  @(posedge clk0) A |->
    if (D) @(posedge clk0) B
    ##1 @(posedge clk1) Z
    else @(posedge clk0) (-B);
endproperty
```
Here, an equivalent shorthand with non-overlapping implication is shown:
```verilog
// This is equivalent to
// @(posedge clk0) A |->
//   if (D) B ##1 @(posedge clk1) Z
//   else (-B) ;
```

4. Fourth code block:
```verilog
property mclocks;
  @(posedge clk0) A |->
    if (D) @(posedge clk0) B
    else @(posedge clk1) (-B);
endproperty
```
A note explains a change in legality from LRM 2005 to LRM 2012:
```verilog
// This used to be illegal in LRM 2005. But in LRM 2012 it is legal.
// You can indeed have an overlapping operator with two different
// clocks on LHS and RHS of implication operator.
```

The figure caption below the code blocks reads:
```
Fig. 10.8 Multiply clocked properties—clock resolution
```

These excerpts are focused on explaining multiply clocked properties and implications, which are key concepts in writing assertions for hardware verification in SystemVerilog.","
property mclocks;
  @(posedge clk0) A |->
    if (D) @(posedge clk0) B;
endproperty


// This is equivalent to
// @(posedge clk0) A |->
//   if (D) B else (-B) ;


property mclocks;
  @(posedge clk0) A |->
    if (D) @(posedge clk0) B
    else @(posedge clk0) (-B);
endproperty


// This is equivalent to
// @(posedge clk0) A |->
//   if (D) B else (-B) ;


property mclocks;
  @(posedge clk0) A |->
    if (D) @(posedge clk0) B
    ##1 @(posedge clk1) Z
    else @(posedge clk0) (-B);
endproperty


// This is equivalent to
// @(posedge clk0) A |->
//   if (D) B ##1 @(posedge clk1) Z
//   else (-B) ;


property mclocks;
  @(posedge clk0) A |->
    if (D) @(posedge clk0) B
    else @(posedge clk1) (-B);
endproperty


// This used to be illegal in LRM 2005. But in LRM 2012 it is legal.
// You can indeed have an overlapping operator with two different
// clocks on LHS and RHS of implication operator.

0.8 Multiply clocked properties—clock resolution
","""Exploration of multiply clocked properties and clock resolution in Verilog SystemVerilog Assertion (SVA) code examples.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p82.jpg,True,"```verilog
property pr1;
  @(posedge clk) cStart |-> ##2 (gnt==1 && req==0);
endproperty

reqGnt: assert property (pr1) $display($stime,,,""\t\t %m PASS"");
else
  $display($stime,,,""\t\t %m FAIL"");
```","
property pr1;
  @(posedge clk) cStart |-> ##2 (gnt==1 && req==0);
endproperty

reqGnt: assert property (pr1) $display($stime,,,""\t\t %m PASS"");
else
  $display($stime,,,""\t\t %m FAIL"");
","""Explaining the use of the implication operator in SystemVerilog assertions with example code""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p73.jpg,True,"The image contains Verilog code examples with some recommendations on coding practices for simulation. Here is the Verilog code from the image:

Instead of:
```verilog
c_x[23:16] = r_a;
c_x[15:8] = r_b;
c_x[7:0] = r_c;
```
use:
```verilog
c_x = {r_a, r_b, r_c};
```

Instead of:
```verilog
c_ecc_out_1 = c_in[29]^c_in[28]^
              c_in[27]^c_in[26]^c_in[25]^c_in[24]^c_in[23]^
              c_in[22]^c_in[21]^c_in[20]^c_in[19]^c_in[18]^
              c_in[17]^c_in[16]^c_in[15]^c_in[14]^c_in[13]^
              c_in[12]^c_in[11]^c_in[7]^c_in[4]^c_in[1]^
              c_in[0];
```
use:
```verilog
c_ecc_out_1 = (^c_in & 40'h003ff793);
```

Instead of:
```verilog
c_v = c_s << 8; // c_v, c_s are 48 bits wide
```
use:
```verilog
c_v = { c_s[39:0], 8'h00 };
```

The text emphasizes using concatenation and bit masks for better simulation performance.","
c_x[23:16] = r_a;
c_x[15:8] = r_b;
c_x[7:0] = r_c;


c_x = {r_a, r_b, r_c};


c_ecc_out_1 = c_in[29]^c_in[28]^
              c_in[27]^c_in[26]^c_in[25]^c_in[24]^c_in[23]^
              c_in[22]^c_in[21]^c_in[20]^c_in[19]^c_in[18]^
              c_in[17]^c_in[16]^c_in[15]^c_in[14]^c_in[13]^
              c_in[12]^c_in[11]^c_in[7]^c_in[4]^c_in[1]^
              c_in[0];


c_ecc_out_1 = (^c_in & 40'h003ff793);


c_v = c_s << 8; // c_v, c_s are 48 bits wide


c_v = { c_s[39:0], 8'h00 };
","""Optimizing Verilog Code: Using Concatenation and Masks for Improved Simulation Speed""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p700.jpg,True,"The image contains text and diagrammatic representations, but it doesn't contain any executable code snippets. Below are the text details related to functions and properties from the image:

```
int     vpiType      returns vpiIntegerVar, vpiTimeVar, vpiRealVar
bool    vpiArray     the variable is an array (only applies to variables)
                     returns:
int     vpiSize      - the bit size of a variable
                     - the number of words in a variable array
                     - the word size of a var array select
str     vpiName      returns the name of a variable or var array select
str     vpiFullName  returns the full hierarchical path name of a variable or var array
                     select
str     vpiFile      returns file name containing the variable definition or var array
                     select
int     vpiLineNo    returns file line number of the variable definition or var array select

1. For a variable array object, vpiLeftRange and vpiRightRange refer to the starting
   and ending address of the variable array declaration.
2. For a var array select object, vpiLeftRange and vpiRightRange refer to the MSB
   and LSB of the word.
3. The value of a variable or var array select is accessed using vpi_get_value()
   and vpi_put_value().
```

Additionally, there are some diagrammatic elements showing the relationships between different entities such as `vpiPortInst`, `vpiModule`, `vpiScope`, and so on, related to the Verilog Programming Language Interface (PLI). These diagrams are not code.","  vpiType      returns vpiIntegerVar, vpiTimeVar, vpiRealVar
bool    vpiArray     the variable is an array (only applies to variables)
                     returns:
int     vpiSize      - the bit size of a variable
                     - the number of words in a variable array
                     - the word size of a var array select
str     vpiName      returns the name of a variable or var array select
str     vpiFullName  returns the full hierarchical path name of a variable or var array
                     select
str     vpiFile      returns file name containing the variable definition or var array
                     select
int     vpiLineNo    returns file line number of the variable definition or var array select

1. For a variable array object, vpiLeftRange and vpiRightRange refer to the starting
   and ending address of the variable array declaration.
2. For a var array select object, vpiLeftRange and vpiRightRange refer to the MSB
   and LSB of the word.
3. The value of a variable or var array select is accessed using vpi_get_value()
   and vpi_put_value().
","""Excerpt from The Verilog PLI Handbook detailing VPI variable objects, attributes, and access methods for Verilog variables.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p239.jpg,True,"The image contains several snippets of Verilog code. Here they are:

1.
```verilog
sequence cdtr;
    z ##[2:5] cd.triggered;
endsequence
```

2.
```verilog
ftr: assert property (ab |-> nogo until cdtr.triggered);
```

3.
```verilog
sequence e1(a, b, c);
    @(posedge clk) $rose (a) ##1 b ##1 c;
endsequence
```

4.
```verilog
sequence e2;
    @(posedge sysclk) reset ##1 inst ##1:(ready,proc1,proc2).matched;[-1] ##1 branch_back;
endsequence
```

These code snippets are examples of SystemVerilog sequences and properties for verification purposes.","
sequence cdtr;
    z ##[2:5] cd.triggered;
endsequence


ftr: assert property (ab |-> nogo until cdtr.triggered);


sequence e1(a, b, c);
    @(posedge clk) $rose (a) ##1 b ##1 c;
endsequence


sequence e2;
    @(posedge sysclk) reset ##1 inst ##1:(ready,proc1,proc2).matched;[-1] ##1 branch_back;
endsequence
","Caption: ""Overview of Verilog `.matched` construct for specifying sequence endpoints with different source and destination clocks in SystemVerilog assertions.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BeningFoster-Principles of Verifiable RTL Design_p67.jpg,True,"The image contains a table with examples of expression operators in Verilog. Here is the code from the examples column:

```
-a
a * b
a / b
a === b
a !== b
```"," b
a / b
a === b
a !== b
","""Verilog Coding Standards and Library-Only Expression Operators""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p714.jpg,True,"The image contains a section from ""The Verilog PLI Handbook"" and provides information about VPI iterator objects in Verilog. It includes diagrammatic representations and descriptions related to Verilog Programming Language Interface (PLI), but there is no executable code in the image.

At the bottom, there is a description of a function signature related to VPI iterators:

```plaintext
vpi_handle(vpiUse, <iterator_handle>) returns a handle to the reference 
object which created the iterator object when vpi_iterate(<type_constant>, 
<reference_handle>) was called.
```

It also states:

```plaintext
It is possible to have an iterator that does not have a reference object.
```

This text provides information about the API function to retrieve handles but does not contain actual Verilog code that can be compiled or simulated.","xt
vpi_handle(vpiUse, <iterator_handle>) returns a handle to the reference 
object which created the iterator object when vpi_iterate(<type_constant>, 
<reference_handle>) was called.

xt
It is possible to have an iterator that does not have a reference object.
","Diagram of VPI iterator relationships from ""The Verilog PLI Handbook"" with reference page numbers and a note on vpi_handle usage in Verilog.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p337.jpg,True,"Here is the Verilog code present in the image:

```verilog
module counter_09_or_OF (reset_n,clk,count,sel_09);
input reset_n, clk, sel_09;
output [3:0] count;
reg [3:0] count;

always @ (posedge clk)
    if (reset_n==0 || count=='d4' && sel_09=='b1)
        count <= 'd0;
    else
        count <= count + 1;
assert_no_transition # (0,4) valid_count
    (clk, reset_n, count, 'd9, (sel_09 == 1)
    ? 'd10 : 'd0);
endmodule
```

This code defines a Verilog module called `counter_09_or_OF` with inputs `reset_n`, `clk`, `sel_09` and an output `count`. There's also an `always` block that defines the behavior of the `count` register on the positive edge of the `clk`. Additionally, the module uses `assert_no_transition` to specify a condition for transition checking.","
module counter_09_or_OF (reset_n,clk,count,sel_09);
input reset_n, clk, sel_09;
output [3:0] count;
reg [3:0] count;

always @ (posedge clk)
    if (reset_n==0 || count=='d4' && sel_09=='b1)
        count <= 'd0;
    else
        count <= count + 1;
assert_no_transition # (0,4) valid_count
    (clk, reset_n, count, 'd9, (sel_09 == 1)
    ? 'd10 : 'd0);
endmodule
","""Verilog code example demonstrating the use of `assert_no_transition` in a counter module to ensure specific state transitions do not occur.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p323.jpg,True,"The image contains text regarding Verilog and an example of the syntax for an assertion monitor called `assert_next` from the Open Verification Library (OVL). Here is the syntax provided for the `assert_next` monitor:

```
assert_next #([severity_level, num_cks, check_overlapping, only_if, options, msg]) inst_name
            (clk, reset_n, start_event, test_expr);
```

The parameters for this macro are described below in the text, such as `severity_level`, `num_cks`, `check_overlapping`, `only_if`, and so on. These are used to customize the behavior of the assertion in the context of hardware verification.","_next #([severity_level, num_cks, check_overlapping, only_if, options, msg]) inst_name
            (clk, reset_n, start_event, test_expr);
","Caption: ""Documentation excerpt explaining the Verilog 'assert_next' assertion from the Open Verification Library, detailing its syntax and usage for checking cycle relationships in digital design verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p58.jpg,True,"The image includes a section of Verilog code under the title ""Example 2-2 Internal assertion signals."" Here is the code:

```verilog
`ifdef ASSERT_ON
assign assert_valid_pnt = (4'd2 <= pnt) && (pnt <= 4'd8) &&
                          (pnt != 4'd6);
assert_always #(0, 0, 0, ""illegal pointer value"")
              valid_pnt (clk, reset_n, assert_valid_pnt);
`endif
```","
`ifdef ASSERT_ON
assign assert_valid_pnt = (4'd2 <= pnt) && (pnt <= 4'd8) &&
                          (pnt != 4'd6);
assert_always #(0, 0, 0, ""illegal pointer value"")
              valid_pnt (clk, reset_n, assert_valid_pnt);
`endif
","The image displays text about assertion methodology in Verilog, focusing on the use of internal assertions to aid debugging in waveform viewers and tips on maintaining assertion density within RTL designs. The image includes a code snippet demonstrating an assertion in Verilog using `assert_always`.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p403.jpg,True,"The image contains Verilog code. Here is the code:

```verilog
module bus_protocol (input bit clk, reset,
                     output bit dValid, dAck,
                     output logic [7:0] data
);

initial
begin
    $display(""SCENARIO 1"");
    @(negedge clk); dValid='b0; data=8'h0; dAck='b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b1;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b1;
    @(negedge clk); dValid='b0; data=8'h0; dAck='b0;
    @(negedge clk); dValid='b0; data=8'h0; dAck='b0;
    $display(""\n"");

    $display(""SCENARIO 2"");
    @(negedge clk); dValid='b1; data=8'h0; dAck='b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b1;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b1;
    @(negedge clk); dValid='b0; data=8'h0; dAck='b0;
    @(negedge clk); dValid='b0; data=8'h0; dAck='b0;
    $display(""\n"");

    $display(""SCENARIO 3"");
    @(negedge clk); dValid='b1; data=8'h0; dAck='b1;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b1;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b1;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b1;
    @(negedge clk); dValid='b0; data=8'h0; dAck='b0;
    @(negedge clk); dValid='b0; data=8'h0; dAck='b0;
    $display(""\n"");
end
```","
module bus_protocol (input bit clk, reset,
                     output bit dValid, dAck,
                     output logic [7:0] data
);

initial
begin
    $display(""SCENARIO 1"");
    @(negedge clk); dValid='b0; data=8'h0; dAck='b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b1;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b1;
    @(negedge clk); dValid='b0; data=8'h0; dAck='b0;
    @(negedge clk); dValid='b0; data=8'h0; dAck='b0;
    $display(""\n"");

    $display(""SCENARIO 2"");
    @(negedge clk); dValid='b1; data=8'h0; dAck='b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b0;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b1;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b1;
    @(negedge clk); dValid='b0; data=8'h0; dAck='b0;
    @(negedge clk); dValid='b0; data=8'h0; dAck='b0;
    $display(""\n"");

    $display(""SCENARIO 3"");
    @(negedge clk); dValid='b1; data=8'h0; dAck='b1;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b1;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b1;
    @(negedge clk); dValid='b1; data=8'h0; dAck='b1;
    @(negedge clk); dValid='b0; data=8'h0; dAck='b0;
    @(negedge clk); dValid='b0; data=8'h0; dAck='b0;
    $display(""\n"");
end
","""Verilog code snippet illustrating scenarios in a bus protocol simulation.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p135.jpg,True,"The image contains Verilog code related to the discussion about ""The Interface Construct"" and how to use interfaces in Verilog modules. Here is the code presented in the image:

```verilog
module bad_test(arb_if arbif);
    `include ""MyTest.sv""    // Legal include
    `include ""arb_if.sv""    // BAD:Interface hidden in module
    ...
```

```verilog
module top;
    bit clk;
    always #50 clk = ~clk;

    arb_if arbif(clk);
    arb_with_port a1 (.grant (arbif.grant),  // .port (ifc.signal)
                      .request (arbif.request),
                      .rst (arbif.rst),
                      .clk (arbif.clk));
    test_with_ifc t1(arbif);  // From Sample 4-6
endmodule : top
```","
module bad_test(arb_if arbif);
    `include ""MyTest.sv""    // Legal include
    `include ""arb_if.sv""    // BAD:Interface hidden in module
    ...


module top;
    bit clk;
    always #50 clk = ~clk;

    arb_if arbif(clk);
    arb_with_port a1 (.grant (arbif.grant),  // .port (ifc.signal)
                      .request (arbif.request),
                      .rst (arbif.rst),
                      .clk (arbif.clk));
    test_with_ifc t1(arbif);  // From Sample 4-6
endmodule : top
","""Verilog interfaces and the pitfalls of including interface definitions inside modules, with an example of connecting interfaces to legacy ports.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/BallJones-Computer Aided Verification_p183.jpg,True,"The image contains C code and an XML-like control file example. It does not contain any Verilog code. Here's the C code present in the image:

```c
int* f(int a) {
    int *p, *x, *y;
    x = (int*) malloc(sizeof(int));
    y = NULL;
    if (a==0)
        p = x;
    else
        p = y;
    *p = 5;
    return p;
}
```

And here is the XML-like example for the control file, which is presumably used to guide an assertion checker:

```xml
<ControlFile>
  <SourceFile>
    <Name>/ex/f.c</Name><FieldId>1</FieldId>
  </SourceFile>
  <Run><StartPosition><Position>
    <FieldId>1</FieldId><LineNum>1</LineNum>
    <Position><Command>
      <CascadeFunction>cascade_assume
      </CascadeFunction>
      <Argument>a>0</Argument>
    </Command></Position><EndPosition><Position>
      <FieldId>1</FieldId><LineNum>9</LineNum>
    </Position><Command>
      <CascadeFunction>cascade_check_valid_address
      </CascadeFunction>
      <Argument>p</Argument>
    </Command></EndPosition></Run>
</ControlFile>
```","f(int a) {
    int *p, *x, *y;
    x = (int*) malloc(sizeof(int));
    y = NULL;
    if (a==0)
        p = x;
    else
        p = y;
    *p = 5;
    return p;
}

ntrolFile>
  <SourceFile>
    <Name>/ex/f.c</Name><FieldId>1</FieldId>
  </SourceFile>
  <Run><StartPosition><Position>
    <FieldId>1</FieldId><LineNum>1</LineNum>
    <Position><Command>
      <CascadeFunction>cascade_assume
      </CascadeFunction>
      <Argument>a>0</Argument>
    </Command></Position><EndPosition><Position>
      <FieldId>1</FieldId><LineNum>9</LineNum>
    </Position><Command>
      <CascadeFunction>cascade_check_valid_address
      </CascadeFunction>
      <Argument>p</Argument>
    </Command></EndPosition></Run>
</ControlFile>
","Caption: ""Academic paper excerpt showcasing C code and an XML control file example used with the Cascade C assertion checker and deductive engine.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p365.jpg,True,"The image contains Verilog code snippets. Here they are:

1.
```verilog
checker myCheck(a ,b, c);
logic myBus[7:0];

always @(posedge clk) begin
    myBus[1:0] = 2'b0;
    myBus[7:1] = 6'b1;
    // Multiple assignments to the same variable are ILLEGAL. Bit
    // myBus[1] is common and assigned twice.
end

endchecker
```

2.
```verilog
checker myCheck(a, b, c);
logic myBus[7:0];

always @(posedge clk) begin
    myBus[1:0] = 2'b0;
    myBus[7:2] = 6'b1; //Multiple assignments to bits of myBus is assigned
                       //only once. LEGAL
end

endchecker
```

3.
```verilog
checker myCheck(bus, i);
bit [3:0] bus, i;

initial begin
    @(posedge clk) i = 0;
    bus[i]=4'b1111;
end

endchecker
```

4.
```verilog
module myMod
logic [3:0] busIndex;
logic [3:0] datafromBus;
..........
    myCheck m1(datafromBus,busIndex); //busIndex is non-constant ILLEGAL
    myCheck m2(datafromBus,4'b0); //busIndex is constant - LEGAL
endmodule
```","
checker myCheck(a ,b, c);
logic myBus[7:0];

always @(posedge clk) begin
    myBus[1:0] = 2'b0;
    myBus[7:1] = 6'b1;
    // Multiple assignments to the same variable are ILLEGAL. Bit
    // myBus[1] is common and assigned twice.
end

endchecker


checker myCheck(a, b, c);
logic myBus[7:0];

always @(posedge clk) begin
    myBus[1:0] = 2'b0;
    myBus[7:2] = 6'b1; //Multiple assignments to bits of myBus is assigned
                       //only once. LEGAL
end

endchecker


checker myCheck(bus, i);
bit [3:0] bus, i;

initial begin
    @(posedge clk) i = 0;
    bus[i]=4'b1111;
end

endchecker


module myMod
logic [3:0] busIndex;
logic [3:0] datafromBus;
..........
    myCheck m1(datafromBus,busIndex); //busIndex is non-constant ILLEGAL
    myCheck m2(datafromBus,4'b0); //busIndex is constant - LEGAL
endmodule
",Examples of legal and illegal Verilog assignments in system tasks and checkers.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/Vijayaraghavan-A Practical Guide for SystemVerilog Assertions_p202.jpg,True,"The image contains Verilog code. Here it is transcribed:

```verilog
sequence s_datafeeder;
    ##64 $fell (sipo_en) ##2
    latch_en ##1 latch_en;
endsequence
```

```verilog
sequence s_control;
    dp1_en ##1 |dp1_en ##1 dp2_en ##1 |dp2_en ##1
    dp3_en ##1 |dp3_en ##1 dp4_en ##1 |dp4_en ##1
    wr ##1 |wr;
endsequence
```

```verilog
property p_control;
    @(posedge clk) $fell (latch_en) |=> s_control;
endproperty

a_control: assert property(p_control);
```","
sequence s_datafeeder;
    ##64 $fell (sipo_en) ##2
    latch_en ##1 latch_en;
endsequence


sequence s_control;
    dp1_en ##1 |dp1_en ##1 dp2_en ##1 |dp2_en ##1
    dp3_en ##1 |dp3_en ##1 dp4_en ##1 |dp4_en ##1
    wr ##1 |wr;
endsequence


property p_control;
    @(posedge clk) $fell (latch_en) |=> s_control;
endproperty

a_control: assert property(p_control);
","Caption: ""Example of waveform timing and Verilog sequences for data control in a JPEG processing module.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p121.jpg,True,"The image contains Verilog code. Here it is:

```verilog
task automatic load_array(input int len, ref int array[]);
  if (len <= 0) begin
    $display(""Bad len"");
    return;
  end
  // Code for the rest of the task
  ...
endtask

// ...

function bit transmit(input bit [31:0] data);
  // Send transaction
  ...
  return status; // Return status: 0=error
endfunction
```","
task automatic load_array(input int len, ref int array[]);
  if (len <= 0) begin
    $display(""Bad len"");
    return;
  end
  // Code for the rest of the task
  ...
endtask

// ...

function bit transmit(input bit [31:0] data);
  // Send transaction
  ...
  return status; // Return status: 0=error
endfunction
",The image is a textbook page discussing how to use the return statement in Verilog/SystemVerilog to exit routines like tasks and functions. It includes examples of a task and a function illustrating the return statement in use.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p109.jpg,True,"The image contains Verilog code as follows:

```verilog
module test;
    string street[$];

    initial begin
        street = {""Tejon"", ""Bijou"", ""Boulder""};
        $display(""Street[0] = %s"", street[0]);
        street.insert(2, ""Platte"");
        $display(""Street[2] = %s"", street[2]);
        street.push_front(""St. Vrain"");
        $display(""Street[2] = %s"", street[2]);
        $display(""pop_back = %s"", street.pop_back());
        $display(""street.size = %d"", street.size);
    end
endmodule // test
```","
module test;
    string street[$];

    initial begin
        street = {""Tejon"", ""Bijou"", ""Boulder""};
        $display(""Street[0] = %s"", street[0]);
        street.insert(2, ""Platte"");
        $display(""Street[2] = %s"", street[2]);
        street.push_front(""St. Vrain"");
        $display(""Street[2] = %s"", street[2]);
        $display(""pop_back = %s"", street.pop_back());
        $display(""street.size = %d"", street.size);
    end
endmodule // test
","Caption: ""Verilog exercise problems including array declaration, initialization, and accessing, as well as string manipulation in a module test.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p105.jpg,True,"The image contains a snippet of text referencing an assumption in SystemVerilog, which is a hardware description and verification language used in the field of electronic design automation. Here is the code from the image:

```verilog
m1: assume property (@(clk) a dist {1 := 2, 3 := 1, 4 := 5});
```

This code specifies an assumption in a formal verification or simulation context where the variable 'a' takes on the values 1, 3, or 4 with respective weights (or probabilities) of 2, 1, and 5 when observed at the clock edge 'clk'.","
m1: assume property (@(clk) a dist {1 := 2, 3 := 1, 4 := 5});
",An excerpt from a technical document discussing assumptions in formal verification and random simulation with a focus on Verilog code for distribution constraints in SystemVerilog.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p112.jpg,True,"The image contains a portion of C code that interacts with the Verilog Programming Language Interface (PLI). Here's the code:

```c
PLIbook_GetAllSignals(scope_handle, &current_time);
}
else {
    /* completef has already verified arg is scope instance or null */
    while ( (scope_handle = vpi_scan(arg_iterator)) != NULL ) {
        if (vpi_get(vpiType, scope_handle) != vpiModule) {
            /* arg isn't a module instance; assume it is null */
            scope_handle = vpi_handle(vpiScope, systf_handle);
        }
        PLIbook_GetAllSignals(scope_handle, &current_time);
    }
}
return(0);
}

void PLIbook_GetAllSignals(vpiHandle scope_handle, p_vpi_time current_time)
{
    vpiHandle signal_iterator;

    vpi_printf(""\nAt time %2.2f, signals in scope %s (%s):\n"",
        current_time->real,
        vpi_get_str(vpiFullName, scope_handle),
        vpi_get_str(vpiDefName, scope_handle));
    
    /* obtain handles to nets in module and read current value */
    /* nets can only exist if scope is a module */
    if (vpi_get(vpiType, scope_handle) == vpiModule) {
        signal_iterator = vpi_iterate(vpiNet, scope_handle);
        if (signal_iterator != NULL)
            PLIbook_PrintSignalValues(signal_iterator);
    }

    /* obtain handles to regs in scope and read current value */
    signal_iterator = vpi_iterate(vpiReg, scope_handle);
    if (signal_iterator != NULL)
        PLIbook_PrintSignalValues(signal_iterator);

    /* obtain handles to variables in scope and read current value */
    signal_iterator = vpi_iterate(vpiVariables, scope_handle);
    if (signal_iterator != NULL)
        PLIbook_PrintSignalValues(signal_iterator);

    vpi_printf(""\n""); /* add some white space to output */
    return;
}

void PLIbook_PrintSignalValues(vpiHandle signal_iterator)
{
    vpiHandle signal_handle;
    int signal_type;
```

The code is designed to enumerate and print out all signals in a given scope of a Verilog simulation using the Verilog PLI. Note that the function `PLIbook_PrintSignalValues` is declared but not fully defined here; the definition is presumably elsewhere in the text.","ok_GetAllSignals(scope_handle, &current_time);
}
else {
    /* completef has already verified arg is scope instance or null */
    while ( (scope_handle = vpi_scan(arg_iterator)) != NULL ) {
        if (vpi_get(vpiType, scope_handle) != vpiModule) {
            /* arg isn't a module instance; assume it is null */
            scope_handle = vpi_handle(vpiScope, systf_handle);
        }
        PLIbook_GetAllSignals(scope_handle, &current_time);
    }
}
return(0);
}

void PLIbook_GetAllSignals(vpiHandle scope_handle, p_vpi_time current_time)
{
    vpiHandle signal_iterator;

    vpi_printf(""\nAt time %2.2f, signals in scope %s (%s):\n"",
        current_time->real,
        vpi_get_str(vpiFullName, scope_handle),
        vpi_get_str(vpiDefName, scope_handle));
    
    /* obtain handles to nets in module and read current value */
    /* nets can only exist if scope is a module */
    if (vpi_get(vpiType, scope_handle) == vpiModule) {
        signal_iterator = vpi_iterate(vpiNet, scope_handle);
        if (signal_iterator != NULL)
            PLIbook_PrintSignalValues(signal_iterator);
    }

    /* obtain handles to regs in scope and read current value */
    signal_iterator = vpi_iterate(vpiReg, scope_handle);
    if (signal_iterator != NULL)
        PLIbook_PrintSignalValues(signal_iterator);

    /* obtain handles to variables in scope and read current value */
    signal_iterator = vpi_iterate(vpiVariables, scope_handle);
    if (signal_iterator != NULL)
        PLIbook_PrintSignalValues(signal_iterator);

    vpi_printf(""\n""); /* add some white space to output */
    return;
}

void PLIbook_PrintSignalValues(vpiHandle signal_iterator)
{
    vpiHandle signal_handle;
    int signal_type;
","A page from ""The Verilog PLI Handbook"" showing a function for obtaining and printing all signal values in a given Verilog scope using the Verilog Procedural Interface (VPI).",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p359.jpg,True,"The image contains Verilog code, and here it is:

```verilog
//Now let us instantiate module `checkerModule`

checkerModule #(8)
    clk1(.dack_(dataAck_),.oe_(outputEn_),.bMode_(bMode_),.
    bMode_in(bMode_send),.clk(clk),.rst(rst));
endmodule
```

And further down the image in a different section:

```verilog
checker checkerM #(burstSize = 4) (dack_, oe_, bMode, bMode_in, rst, event clk==$inferred_clock);
input dack_, oe_, bMode, bMode_in, rst;

sequence data_transfer;
    ##2 ((dack_==0) && (oe_==0)) [*burstSize];
endsequence

sequence checkbMode;
    (!bMode) throughout data_transfer;
endsequence

property pbrule1;
    @(clk) disable iff (rst) bMode_in |-> checkbMode;
endproperty

checkBurst: assertproperty (pbrule1) else $display($stime,,""Burst Rule Violated"");
endchecker
```

The text also explains certain aspects of Verilog code usage like passing clocks and resets to modules, creating sequences, and utilizing checkers with properties and assertions.","
//Now let us instantiate module `checkerModule`

checkerModule #(8)
    clk1(.dack_(dataAck_),.oe_(outputEn_),.bMode_(bMode_),.
    bMode_in(bMode_send),.clk(clk),.rst(rst));
endmodule


checker checkerM #(burstSize = 4) (dack_, oe_, bMode, bMode_in, rst, event clk==$inferred_clock);
input dack_, oe_, bMode, bMode_in, rst;

sequence data_transfer;
    ##2 ((dack_==0) && (oe_==0)) [*burstSize];
endsequence

sequence checkbMode;
    (!bMode) throughout data_transfer;
endsequence

property pbrule1;
    @(clk) disable iff (rst) bMode_in |-> checkbMode;
endproperty

checkBurst: assertproperty (pbrule1) else $display($stime,,""Burst Rule Violated"");
endchecker
","A textbook page explaining instantiation of a Verilog module, and detailing Verilog sequential and concurrent assertions with code examples.",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p660.jpg,True,"The image includes a fragment of a makefile script. Here is the code from the image:

```makefile
#
# Makefile.nc
#

...

#
# The VPI_USER_C macro should be set to the vpi_user.c file containing
# any user defined 'C' routines for use with VPI (PLI 2.0).
VPI_USER_C=./PLIbook_vpi_user.c
VPI_USER_O=$(TARGETDIR)/vpi_user.o

...
``` 

This makefile excerpt sets two make variables `VPI_USER_C` and `VPI_USER_O` and assigns the path to a C source file and the target object file, respectively.","e
#
# Makefile.nc
#

...

#
# The VPI_USER_C macro should be set to the vpi_user.c file containing
# any user defined 'C' routines for use with VPI (PLI 2.0).
VPI_USER_C=./PLIbook_vpi_user.c
VPI_USER_O=$(TARGETDIR)/vpi_user.o

...
",Page from a manual showing instructions on editing a makefile for Verilog PLI applications with a sample excerpt of a makefile configuration.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p111.jpg,True,"There are Verilog code examples provided in the image. Here they are rewritten for clarity:

```verilog
p1: assert property(@(posedge clk) a) $display(""a is high"");
p2: assume property(@(posedge clk) a) $display(""a is high"");
p3: restrict property(@(posedge clk) a);
p4: cover property(@(posedge clk) a) $display(""a is high"");
p4: cover sequence(@(posedge clk) a) $display(""a is high"");
```

These lines demonstrate various SystemVerilog assertion statements used in hardware verification contexts.","
p1: assert property(@(posedge clk) a) $display(""a is high"");
p2: assume property(@(posedge clk) a) $display(""a is high"");
p3: restrict property(@(posedge clk) a);
p4: cover property(@(posedge clk) a) $display(""a is high"");
p4: cover sequence(@(posedge clk) a) $display(""a is high"");
","""Exploring Verilog Assertions and Properties for Verification Purposes""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p106.jpg,True,"The image contains Verilog code, specifically related to the Verilog Programming Language Interface (PLI). Here is the code from the image:

```verilog
void PLIbook_ShowSignals_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type        = vpiSysTask;
    tf_data.tfname      = ""$show_all_signals"";
    tf_data.calltf      = PLIbook_ShowSignals_calltf;
    tf_data.compiletf   = PLIbook_ShowSignals_compiletf;
    tf_data.sizetf      = NULL;
    vpi_register_systf(&tf_data);
    return;
}

/***********************************************************************
 * compiletf routine
 ***********************************************************************/
int PLIbook_ShowSignals_compiletf(char *user_data)
{
    vpiHandle systf_handle, arg_iterator, arg_handle;
    int       tfarg_type;

    /* obtain a handle to the system task instance */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handles to system task arguments */
    arg_iterator = vpi_iterate(vpiArgument, systf_handle);
    if (arg_iterator == NULL) {
        return(0); /* no arguments OK; skip remaining checks */
    }

    /* check the type of object in system task arguments */
    arg_handle = vpi_scan(arg_iterator);
    tfarg_type = vpi_get(vpiType, arg_handle);
    switch (tfarg_type) {
        case vpiModule:
        case vpiTask:
        case vpiFunction:
        case vpiNamedBegin:
        case vpiNamedFork:
            break; /* arg is a scope instance; continue to next check */
        case vpiOperation:
            if (vpi_get(vpiOpType, arg_handle) == vpiNullOp)
                break; /* null argument OK; continue to next check */
        default:
            /* wrong type specified for an argument */
            vpi_printf(""ERROR: $show_all_signals arg 1"");
            vpi_printf("" must be a scope instance or null\n"");
            vpi_free_object(arg_iterator); /* free iterator memory */
            tf_dofinish(); /* abort simulation */
            return(0);
    }
}
```

This code appears to define functions for registering and compiling a PLI system task named `$show_all_signals`, which is intended for use in Verilog simulations, possibly to display all signals in scope.","
void PLIbook_ShowSignals_register()
{
    s_vpi_systf_data tf_data;

    tf_data.type        = vpiSysTask;
    tf_data.tfname      = ""$show_all_signals"";
    tf_data.calltf      = PLIbook_ShowSignals_calltf;
    tf_data.compiletf   = PLIbook_ShowSignals_compiletf;
    tf_data.sizetf      = NULL;
    vpi_register_systf(&tf_data);
    return;
}

/***********************************************************************
 * compiletf routine
 ***********************************************************************/
int PLIbook_ShowSignals_compiletf(char *user_data)
{
    vpiHandle systf_handle, arg_iterator, arg_handle;
    int       tfarg_type;

    /* obtain a handle to the system task instance */
    systf_handle = vpi_handle(vpiSysTfCall, NULL);

    /* obtain handles to system task arguments */
    arg_iterator = vpi_iterate(vpiArgument, systf_handle);
    if (arg_iterator == NULL) {
        return(0); /* no arguments OK; skip remaining checks */
    }

    /* check the type of object in system task arguments */
    arg_handle = vpi_scan(arg_iterator);
    tfarg_type = vpi_get(vpiType, arg_handle);
    switch (tfarg_type) {
        case vpiModule:
        case vpiTask:
        case vpiFunction:
        case vpiNamedBegin:
        case vpiNamedFork:
            break; /* arg is a scope instance; continue to next check */
        case vpiOperation:
            if (vpi_get(vpiOpType, arg_handle) == vpiNullOp)
                break; /* null argument OK; continue to next check */
        default:
            /* wrong type specified for an argument */
            vpi_printf(""ERROR: $show_all_signals arg 1"");
            vpi_printf("" must be a scope instance or null\n"");
            vpi_free_object(arg_iterator); /* free iterator memory */
            tf_dofinish(); /* abort simulation */
            return(0);
    }
}
",Verilog PLI Code for Registering and Completing a System Task.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p135.jpg,True,"The image contains Verilog code within a text document. Here's the code extracted from the image:

```verilog
/*************************************
* calltf routine setup VCL for clock
*************************************/
int assert_always_ck_calltf(char *user_data)
{
    struct always_t *assertion;
    acc_initialize();
    assertion = (Always *) tf_getworkarea();
    if (assertion == NULL) {
        assertion = (Always *) calloc(1, sizeof(Always));
        assertion->clk_handle = acc_handle_targ(1);
        assertion->instance = tf_getinstance();
        assertion->active = 0;
    }
    assertion->clk = tf_getp(1) & 1;
    tf_setworkarea((char *) assertion);
    if (assertion->active == 0) {
        assertion->active = 1;
        acc_vcl_add(assertion->clk_handle,
                    assert_always_ck_consumer, (char *) vcl_verilog_logic);
    }
    acc_close();
    return (0);
}

/**************************************
* consumer routine to perform check
**************************************/
int assert_always_ck_consumer(p_vc_record vc_record)
{
    int clk;
    struct always_t *assertion;
    assertion = (Always *) vc_record->user_data;
    switch (vc_record->vc_reason) {
    case logic_value_change:
    case register_value_change: {
        clk = tf_getp(1, assertion->instance) & 1;
        if (assertion->clk!=0 & clk!=1) {
            if (tf_igetp(2, assertion->instance)==0 {
                io_printf(""ASSERT ERROR at %s:%s\n"",
                          tf_strgettime(), tf_spname(assertion->instance));
                tf_dofinish(); /* stop simulation */
            }
        }
        assertion->active = 0;
        acc_vcl_delete(assertion->clk_handle,
                       assert_always_ck_consumer, (char *) assertion,
                       vcl_verilog_logic);
    }
    assertion->clk = clk;
    }
    return (0);
}
```

The code shown in the image is part of a Verilog PLI (Programming Language Interface) application. It consists of two routines: a calltf routine called `assert_always_ck_calltf`, which is used to set up VCL (Value Change Link) for a clock signal; and a consumer routine named `assert_always_ck_consumer`, which performs checks based on value changes of that clock signal.

Keep in mind that the actual behavior and integration of this code snippet would depend on the broader context of the Verilog application. Additionally, note that there may be typos due to handwritten copying from an image.","
/*************************************
* calltf routine setup VCL for clock
*************************************/
int assert_always_ck_calltf(char *user_data)
{
    struct always_t *assertion;
    acc_initialize();
    assertion = (Always *) tf_getworkarea();
    if (assertion == NULL) {
        assertion = (Always *) calloc(1, sizeof(Always));
        assertion->clk_handle = acc_handle_targ(1);
        assertion->instance = tf_getinstance();
        assertion->active = 0;
    }
    assertion->clk = tf_getp(1) & 1;
    tf_setworkarea((char *) assertion);
    if (assertion->active == 0) {
        assertion->active = 1;
        acc_vcl_add(assertion->clk_handle,
                    assert_always_ck_consumer, (char *) vcl_verilog_logic);
    }
    acc_close();
    return (0);
}

/**************************************
* consumer routine to perform check
**************************************/
int assert_always_ck_consumer(p_vc_record vc_record)
{
    int clk;
    struct always_t *assertion;
    assertion = (Always *) vc_record->user_data;
    switch (vc_record->vc_reason) {
    case logic_value_change:
    case register_value_change: {
        clk = tf_getp(1, assertion->instance) & 1;
        if (assertion->clk!=0 & clk!=1) {
            if (tf_igetp(2, assertion->instance)==0 {
                io_printf(""ASSERT ERROR at %s:%s\n"",
                          tf_strgettime(), tf_spname(assertion->instance));
                tf_dofinish(); /* stop simulation */
            }
        }
        assertion->active = 0;
        acc_vcl_delete(assertion->clk_handle,
                       assert_always_ck_consumer, (char *) assertion,
                       vcl_verilog_logic);
    }
    assertion->clk = clk;
    }
    return (0);
}
",Example of Verilog PLI callback setup for clock signal assertion checking in simulation.,True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p31.jpg,True,"The image contains Verilog code as follows:

```verilog
module adder (input logic a, b, ci,
              output logic sum, co);
...
endmodule

module top;
    wire a, b, ci, s1, s2, c1;
    adder i1 (.a, .b, .ci, .sum(s1), .co(c1) ); // .name connections
    adder i2 (.sum(s2), .ci(c1), .* ); // .* connections
endmodule
```

The code demonstrates the definition of a Verilog module for an adder as well as the instance connections within another module using both named port connections (`.name`) and the wildcard port connection (`. *`) for inferring connections based on matching names.","
module adder (input logic a, b, ci,
              output logic sum, co);
...
endmodule

module top;
    wire a, b, ci, s1, s2, c1;
    adder i1 (.a, .b, .ci, .sum(s1), .co(c1) ); // .name connections
    adder i2 (.sum(s2), .ci(c1), .* ); // .* connections
endmodule
","Textbook excerpt on Verilog coding practices, showcasing dot-name and dot-star port connections to reduce typographical errors and making use of Emacs editor features for Verilog/SystemVerilog.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p111.jpg,True,"The image contains text that describes legal and illegal assignments in SystemVerilog, as well as different methods of avoiding programming issues when dealing with enumerated types. Here is the code from the image:

```verilog
nstate_e = LOAD;          // legal assignment
nstate_e = state_e;       // legal assignment
nstate_e = 5;             // illegal (not an enum label)
nstate_e = 3'b001;        // illegal (not an enum label)
nstate_e = state_e + 1;   // illegal (not an enum label)

nstate_e = states_t'(state_e + 1); // legal, but GOTCHA!

success_flag = $cast(target_variable, expression)

assert(nstate_e, state_e+1); // increment to next label in list
else nstate_e = LOAD;

nstate_e = state_e.next(1); // increment to next label in list
```","
nstate_e = LOAD;          // legal assignment
nstate_e = state_e;       // legal assignment
nstate_e = 5;             // illegal (not an enum label)
nstate_e = 3'b001;        // illegal (not an enum label)
nstate_e = state_e + 1;   // illegal (not an enum label)

nstate_e = states_t'(state_e + 1); // legal, but GOTCHA!

success_flag = $cast(target_variable, expression)

assert(nstate_e, state_e+1); // increment to next label in list
else nstate_e = LOAD;

nstate_e = state_e.next(1); // increment to next label in list
","""Understanding Verilog RTL Modeling Pitfalls: Enumerated Variable Assignments and SystemVerilog Solutions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SutherlandMills-Verilog and SystemVerilog Gotchas_p105.jpg,True,"Here is the Verilog code from the image:

```verilog
always_comb begin
    if (sel)
        y = a; // do true statements
    //synthesis translate_off
    if (!sel) // opposite of if condition)
    //synthesis translate_on
        y = b; // do the not true statements
    //synthesis translate_off
    else begin
        y = 'bx;
        $display(""if condition tested either an X or Z"");
    end
    //synthesis translate_on
end
```

And here is the SystemVerilog code mentioned:

```verilog
always_comb begin
    assert (!$isunknown(sel)) else $error(""sel = X"");
    if ( sel ) y = a; // 2-to-1 MUX
    else       y = b;
end
```","
always_comb begin
    if (sel)
        y = a; // do true statements
    //synthesis translate_off
    if (!sel) // opposite of if condition)
    //synthesis translate_on
        y = b; // do the not true statements
    //synthesis translate_off
    else begin
        y = 'bx;
        $display(""if condition tested either an X or Z"");
    end
    //synthesis translate_on
end


always_comb begin
    assert (!$isunknown(sel)) else $error(""sel = X"");
    if ( sel ) y = a; // 2-to-1 MUX
    else       y = b;
end
","Caption: ""Comparing traditional Verilog error handling with SystemVerilog Assertions (SVA) for improved RTL modeling.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p486.jpg,True,"Here is the Verilog code from the image:

```verilog
module top;
    import ""DPI-C"" context function void c_display();
    export ""DPI-C"" function sv_display;

    block b1();
    initial c_display();

    function void sv_display();
        $display(""SV: In %m"");
    endfunction
endmodule : top

module block;
    import ""DPI-C"" context function void c_display();
    export ""DPI-C"" function sv_display;

    initial c_display();

    function void sv_display();
        $display(""SV: In %m"");
    endfunction
endmodule : block
```","
module top;
    import ""DPI-C"" context function void c_display();
    export ""DPI-C"" function sv_display;

    block b1();
    initial c_display();

    function void sv_display();
        $display(""SV: In %m"");
    endfunction
endmodule : top

module block;
    import ""DPI-C"" context function void c_display();
    export ""DPI-C"" function sv_display;

    initial c_display();

    function void sv_display();
        $display(""SV: In %m"");
    endfunction
endmodule : block
","""Verilog Code Example Demonstrating the Use of Context in Importing and Exporting Functions Between C and SystemVerilog""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/FosterKrolnikLacey-Assertion-Based Design_p109.jpg,True,"The image contains multiple pieces of code written in SystemVerilog. Here they are:

Example 3-41 System Verilog sequence expression with a range of delays:
```
req ##[2:3] ack
```

Example 3-42 SystemVerilog unary delays relationship to binary delays:
```
(##0 start)  // that is, (start)
(##1 start)  // that is, (1'b1 ##1 start)
(##[1:2] start)  // that is, (1'b1 ##1 start) or (1'b1 ##2 start)
```

Example 3-43 SystemVerilog unary delays relationship to binary delays:
```
req |-> ##[2:3] ack ##3 gnt
```","[2:3] ack

tart)  // that is, (start)
(##1 start)  // that is, (1'b1 ##1 start)
(##[1:2] start)  // that is, (1'b1 ##1 start) or (1'b1 ##2 start)

> ##[2:3] ack ##3 gnt
","Caption: ""Examples of SystemVerilog sequence expressions specifying various delay relationships and sequence implications from a digital design textbook.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p167.jpg,True,"The image contains code snippets written in a format that resembles simulation logs or timing diagrams rather than actual Verilog code. However, I will provide the text that appears like code:

```plaintext
 10 CLK #2 :: clk=1 bMode=0 mtrx=1 tack=1
 20 CLK #3 :: clk=1 bMode=0 mtrx=0 tack=1
 30 CLK #4 :: clk=1 bMode=0 mtrx=0 tack=1
 40 CLK #5 :: clk=1 bMode=0 mtrx=0 tack=0
 50 CLK #6 :: clk=1 bMode=0 mtrx=0 tack=0
 60 CLK #7 :: clk=1 bMode=0 mtrx=0 tack=0
 70 CLK #8 :: clk=1 bMode=0 mtrx=0 tack=0
 80 CLK #9 :: clk=1 bMode=0 mtrx=0 tack=0
 90 CLK #10 :: clk=1 bMode=0 mtrx=0 tack=0
100 CLK #11 :: clk=1 bMode=0 mtrx=0 tack=0
110 property pwin PASS
140 CLK #15 :: clk=1 bMode=1 mtrx=1 tack=1
...
250 CLK #26 :: clk=1 bMode=1 mtrx=1 tack=1
```

Please note that the ellipsis (`...`) indicates omitted text that wasn't fully visible or was cut off in the image. The entries represent clock cycles with various signal values for ""`clk`"" (clock), ""`bMode`"" (a binary mode signal), ""`mtrx`"" (a matrix signal), and ""`tack`"" (likely another control signal). The text ""property pwin PASS"" suggests a property named ""pwin"" that has passed some kind of verification or assertion check within the context of a simulation or testbench scenario. This is not executable Verilog code but represents a formatted output or simulation log that describes signal transitions over time.","xt
 10 CLK #2 :: clk=1 bMode=0 mtrx=1 tack=1
 20 CLK #3 :: clk=1 bMode=0 mtrx=0 tack=1
 30 CLK #4 :: clk=1 bMode=0 mtrx=0 tack=1
 40 CLK #5 :: clk=1 bMode=0 mtrx=0 tack=0
 50 CLK #6 :: clk=1 bMode=0 mtrx=0 tack=0
 60 CLK #7 :: clk=1 bMode=0 mtrx=0 tack=0
 70 CLK #8 :: clk=1 bMode=0 mtrx=0 tack=0
 80 CLK #9 :: clk=1 bMode=0 mtrx=0 tack=0
 90 CLK #10 :: clk=1 bMode=0 mtrx=0 tack=0
100 CLK #11 :: clk=1 bMode=0 mtrx=0 tack=0
110 property pwin PASS
140 CLK #15 :: clk=1 bMode=1 mtrx=1 tack=1
...
250 CLK #26 :: clk=1 bMode=1 mtrx=1 tack=1
","Verilog ""within"" operator examples showing PASS cases for sequence property verification.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p451.jpg,True,"```verilog
function void Environment::build();
  cpu = new(mif, cfg);
  gen = new[numRx];
  drv = new[numRx];
  gen2drv = new[numRx];
  drv2gen = new[numRx];
  scb = new(cfg);
  cov = new();
  foreach(gen[i]) begin
    gen2drv[i] = new();
    gen[i] = new(gen2drv[i], drv2gen[i],
                 cfg.cells_per_chan[i], i);
    drv[i] = new(gen2drv[i], drv2gen[i], Rx[i], i);
  end
  ...
endfunction : build
```","
function void Environment::build();
  cpu = new(mif, cfg);
  gen = new[numRx];
  drv = new[numRx];
  gen2drv = new[numRx];
  drv2gen = new[numRx];
  scb = new(cfg);
  cov = new();
  foreach(gen[i]) begin
    gen2drv[i] = new();
    gen[i] = new(gen2drv[i], drv2gen[i],
                 cfg.cells_per_chan[i], i);
    drv[i] = new(gen2drv[i], drv2gen[i], Rx[i], i);
  end
  ...
endfunction : build
","Caption: ""Excerpt from a technical document showing a list of exercises with a focus on a SystemVerilog testbench, including a snippet of code related to building an 'Environment' using object-oriented programming constructs.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p337.jpg,True,"The image includes two code listings written in Verilog. Here they are transcribed:

```verilog
// Sample 8.26 Base callback class
virtual class Driver_cbs; // Driver callbacks

    virtual task pre_tx(ref Transaction tr, ref bit drop);
        // By default, callback does nothing
    endtask

    virtual task post_tx(ref Transaction tr);
        // By default, callback does nothing
    endtask

endclass
```

And the second piece of code:

```verilog
// Sample 8.27 Driver class with callbacks

// Partial example - see Sample 8-4 for more details
class Driver;
    Driver_cbs cbs[$]; // Queue of callback objects

    task run();
        bit drop;
        Transaction tr;

        forever begin
            drop = 0;
            agt2dvr.get(tr); // Agent to driver mailbox
            foreach (cbs[i]) cbs[i].pre_tx(tr, drop);
            if (drop) continue;
            transmit(tr); // Actual work
            foreach (cbs[i]) cbs[i].post_tx(tr);
        end
    endtask
endclass
```

These examples describe a callback system used in a Verilog testbench context with object-oriented programming constructs.","
// Sample 8.26 Base callback class
virtual class Driver_cbs; // Driver callbacks

    virtual task pre_tx(ref Transaction tr, ref bit drop);
        // By default, callback does nothing
    endtask

    virtual task post_tx(ref Transaction tr);
        // By default, callback does nothing
    endtask

endclass


// Sample 8.27 Driver class with callbacks

// Partial example - see Sample 8-4 for more details
class Driver;
    Driver_cbs cbs[$]; // Queue of callback objects

    task run();
        bit drop;
        Transaction tr;

        forever begin
            drop = 0;
            agt2dvr.get(tr); // Agent to driver mailbox
            foreach (cbs[i]) cbs[i].pre_tx(tr, drop);
            if (drop) continue;
            transmit(tr); // Actual work
            foreach (cbs[i]) cbs[i].post_tx(tr);
        end
    endtask
endclass
","Caption: ""Verilog code examples demonstrating creating and using callbacks in a driver class for hardware verification.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p338.jpg,True,"The image contains Verilog-related information, specifically descriptions of utility TF (task/function) routines that aid in performing mathematical operations on 64-bit values stored as pairs of integers in a Verilog simulation context. The code is provided in comments within the document, for the `mc_scan_plusargs` function and descriptions of the `tf_add_long` and `tf_subtract_long` routines:

```c
if (mc_scan_plusargs(""test1+"")
    /* do something */
```

The descriptions provided in the image are as follows:

- `void tf_add_long(low1, high1, low2, high2)`
  - `int *low1` - pointer to lower 32 bits of first operand.
  - `int *high1` - pointer to upper 32 bits of first operand.
  - `int low2` - lower 32 bits of second operand.
  - `int high2` - upper 32 bits of second operand.

The `tf_add_long()` routine adds two 64-bit values, and deposits the result back into the first operand.

- `void tf_subtract_long(low1, high1, low2, high2)`
  - `int *low1` - pointer to lower 32 bits of first operand.
  - `int *high1` - pointer to upper 32 bits of first operand.
  - `int low2` - lower 32 bits of second operand.
  - `int high2` - upper 32 bits of second operand.

The `tf_subtract_long()` routine subtracts two 64-bit values, and deposits the result back into the first operand.

This image appears to be from a document describing how to use certain routines available in a simulator for the hardware description language Verilog.","c_scan_plusargs(""test1+"")
    /* do something */
",A page from a document describing how to use utility Task Functions (TF) in Verilog for performing 64-bit integer math operations.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p323.jpg,True,"```verilog
class Nearby extends Transaction;
    constraint c_nearby {
        dst inside {[src-100:src+100]};
    }
    // copy method not shown
endclass

program automatic test;
    Environment env;
    initial begin
        env = new();
        env.build(); // Construct generator, etc.

        begin
            Nearby nb = new(); // Create a new blueprint
            env.gen.blueprint = nb; // Replace the blueprint
        end

        env.run(); // Run the test with Nearby
        env.wrap_up(); // Clean up afterwards
    end
endprogram
```","
class Nearby extends Transaction;
    constraint c_nearby {
        dst inside {[src-100:src+100]};
    }
    // copy method not shown
endclass

program automatic test;
    Environment env;
    initial begin
        env = new();
        env.build(); // Construct generator, etc.

        begin
            Nearby nb = new(); // Create a new blueprint
            env.gen.blueprint = nb; // Replace the blueprint
        end

        env.run(); // Run the test with Nearby
        env.wrap_up(); // Clean up afterwards
    end
endprogram
","""Exploring Inheritance and Constraint Addition in Verilog with an Example Code Snippet""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/AshokMehta-System Verilog Assertions and Functional Coverage_p173.jpg,True,"```verilog
sequence ab;
  a ##2 b;
endsequence

sequence cde;
  c ##2 d ##2 e;
endsequence

sequence abcde;
  ab or cde;
endsequence

property ands;
  @(posedge clk) z |-> abcde;
endproperty
```","
sequence ab;
  a ##2 b;
endsequence

sequence cde;
  c ##2 d ##2 e;
endsequence

sequence abcde;
  ab or cde;
endsequence

property ands;
  @(posedge clk) z |-> abcde;
endproperty
","Caption: ""Explanation and example of the 'intersect' operator in Verilog with timing diagrams and code snippets.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p445.jpg,True,"The image contains Verilog (SystemVerilog) code which is a part of a function named `check_actual` and a function named `wrap_up`. Below is the code from the image:

```verilog
function void Scoreboard::check_actual(input NNI_cell c,
                                       input int portn);
    NNI_cell match;
    int match_idx;

    c.display($sformatf(""%0t: Scb check: "", $time));

    if (expect_cells[portn].q.size() == 0) begin
        $display(""%0t: ERROR: %m cell not found, SCB TX%0d empty"", $time, portn);
        c.display(""Not Found: "");
        cfg.nErrors++;
        return;
    end

    expect_cells[portn].iactual++;
    iactual++;

    foreach (expect_cells[portn].q[i]) begin
        if (expect_cells[portn].q[i].compare(c)) begin
            $display(""%0t: Match found for cell"", $time);
            expect_cells[portn].q.delete(i);
            return;
        end
    end

    $display(""%0t: ERROR: %m cell not found"", $time);
    c.display(""Not Found: "");
    cfg.nErrors++;
endfunction : check_actual

// Print end of simulation report
function void Scoreboard::wrap_up();
    $display(""%0t: %m %0d expected cells, %0d actual cells rcvd"", $time, iexpect, iactual);

    // Look for leftover cells
    foreach (expect_cells[i]) begin
        if (expect_cells[i].q.size()) begin
            $display(""%0t: %m cells in SCB Tx%0d at end of test"", $time, i);
            this.display(""Unclaimed: "");
            cfg.nErrors++;
        end
    end
endfunction : wrap_up
```

It's worth noting that this code is for simulating and verifying hardware designs, which is what SystemVerilog is commonly used for. The `check_actual` function seems to check if a given cell (`NNI_cell`) is found in an expected cell queue for a specified port, while the `wrap_up` function is intended to display a summary at the end of a simulation. The code also appears to handle errors and increments an error counter (`cfg.nErrors`) when expectations are not met.","
function void Scoreboard::check_actual(input NNI_cell c,
                                       input int portn);
    NNI_cell match;
    int match_idx;

    c.display($sformatf(""%0t: Scb check: "", $time));

    if (expect_cells[portn].q.size() == 0) begin
        $display(""%0t: ERROR: %m cell not found, SCB TX%0d empty"", $time, portn);
        c.display(""Not Found: "");
        cfg.nErrors++;
        return;
    end

    expect_cells[portn].iactual++;
    iactual++;

    foreach (expect_cells[portn].q[i]) begin
        if (expect_cells[portn].q[i].compare(c)) begin
            $display(""%0t: Match found for cell"", $time);
            expect_cells[portn].q.delete(i);
            return;
        end
    end

    $display(""%0t: ERROR: %m cell not found"", $time);
    c.display(""Not Found: "");
    cfg.nErrors++;
endfunction : check_actual

// Print end of simulation report
function void Scoreboard::wrap_up();
    $display(""%0t: %m %0d expected cells, %0d actual cells rcvd"", $time, iexpect, iactual);

    // Look for leftover cells
    foreach (expect_cells[i]) begin
        if (expect_cells[i].q.size()) begin
            $display(""%0t: %m cells in SCB Tx%0d at end of test"", $time, i);
            this.display(""Unclaimed: "");
            cfg.nErrors++;
        end
    end
endfunction : wrap_up
",Verilog Scoreboard Checking Function from a SystemVerilog Testbench.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p461.jpg,True,"The image contains the following Verilog code:

```verilog
logic a;
always @(posedge clk) a <= !a;
a_stable: assume property (@(posedge clk) nexttime $stable(a));
```

This code snippet is presented as an example related to empty model approximation in formal verification (FV).","
logic a;
always @(posedge clk) a <= !a;
a_stable: assume property (@(posedge clk) nexttime $stable(a));
","A textbook section discussing the concept of an ""Empty Model"" in formal verification with an example of Verilog code illustrating an unstable assumption.",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p476.jpg,True,"The image contains Verilog code. Here is the transcription of the code:

```verilog
#include ""veriuser.h""             /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""             /* IEEE 1364 PLI ACC routine library */
/**********************************************************************
 * checktf application
 **********************************************************************/
int PLIbook_ShowSignals1_checktf()
{
    acc_initialize();
    if (tf_nump() != 1)
        tf_error(""$show_all_signals must have 1 argument."");
    else if (tf_typep(1) == TF_NULLPARAM)
        tf_error(""$show_all_signals arg cannot be null."");
    else if (acc_fetch_type(acc_handle_tfarg(1)) != accModule)
        tf_error(""$show_all_signals arg must be a module instance."");
    acc_close();
    return(0);
}

/**********************************************************************
 * calltf application
 **********************************************************************/
int PLIbook_ShowSignals1_calltf()
{
    handle module_h, signal_h;
    s_acc_value signal_value;
    static s_setval_delay delay_s = {accNoDelay};
    static s_acc_value value_s = {accIntVal, {0}};
    static char *signal_types[6] = {accNet, accReg, accIntegerVar,
                                    accTimeVar, accRealVar, 0 };
    acc_initialize();
    module_h = acc_handle_tfarg(1);
    io_printf(""\nAt time %s, signals in module %s (%s):\n"",
              tf_strgettime(),
              acc_fetch_fullname(module_h),
              acc_fetch_defname(module_h));
    signal_h = null;  /* start with known value for target handle */
    while (signal_h = acc_next(signal_types, module_h, signal_h))
    {
        acc_fetch_value(signal_h, ""%d"", &signal_value.value.integer);
        value_s.value.integer = signal_value.value.integer;
        delay_s.time.type = accSimTime;
        delay_s.time.low = 0;
        delay_s.time.high = 0;
        acc_set_value(signal_h, &value_s, &delay_s);
    }
    acc_close();
    return(0);
}
```

This code snippet seems to be part of an example on how to use the PLI (Programming Language Interface) in Verilog to access and manipulate simulation data, as seen in the context of the image, which is titled ""The Verilog PLI Handbook, Part Two.""","
#include ""veriuser.h""             /* IEEE 1364 PLI TF routine library */
#include ""acc_user.h""             /* IEEE 1364 PLI ACC routine library */
/**********************************************************************
 * checktf application
 **********************************************************************/
int PLIbook_ShowSignals1_checktf()
{
    acc_initialize();
    if (tf_nump() != 1)
        tf_error(""$show_all_signals must have 1 argument."");
    else if (tf_typep(1) == TF_NULLPARAM)
        tf_error(""$show_all_signals arg cannot be null."");
    else if (acc_fetch_type(acc_handle_tfarg(1)) != accModule)
        tf_error(""$show_all_signals arg must be a module instance."");
    acc_close();
    return(0);
}

/**********************************************************************
 * calltf application
 **********************************************************************/
int PLIbook_ShowSignals1_calltf()
{
    handle module_h, signal_h;
    s_acc_value signal_value;
    static s_setval_delay delay_s = {accNoDelay};
    static s_acc_value value_s = {accIntVal, {0}};
    static char *signal_types[6] = {accNet, accReg, accIntegerVar,
                                    accTimeVar, accRealVar, 0 };
    acc_initialize();
    module_h = acc_handle_tfarg(1);
    io_printf(""\nAt time %s, signals in module %s (%s):\n"",
              tf_strgettime(),
              acc_fetch_fullname(module_h),
              acc_fetch_defname(module_h));
    signal_h = null;  /* start with known value for target handle */
    while (signal_h = acc_next(signal_types, module_h, signal_h))
    {
        acc_fetch_value(signal_h, ""%d"", &signal_value.value.integer);
        value_s.value.integer = signal_value.value.integer;
        delay_s.time.type = accSimTime;
        delay_s.time.low = 0;
        delay_s.time.high = 0;
        acc_set_value(signal_h, &value_s, &delay_s);
    }
    acc_close();
    return(0);
}
",Verilog PLI code example demonstrating how to use the acc_next() routine to show all signals in a module.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p310.jpg,True,"The image contains the following code:

```c
s_tfcell veriusertfs[] =
{
    { type, user_data, checktf_app, sizetf_app,
      calltf_app, misctf_app, ""tf_name"", 1, 0, 0 },
    
    { type, user_data, checktf_app, sizetf_app,
      calltf_app, misctf_app, ""tf_name"", 1, 0, 0 },

    ...
    
    {0}, /* first field in final array cell is 0 */
};
```

Each array cell is a `s_tfcell` structure, as mentioned in the image. The fields within each structure initialization represent different parameters for a PLI application in Verilog. The final cell in the array has `{0}` to denote it as the last cell.","ell veriusertfs[] =
{
    { type, user_data, checktf_app, sizetf_app,
      calltf_app, misctf_app, ""tf_name"", 1, 0, 0 },
    
    { type, user_data, checktf_app, sizetf_app,
      calltf_app, misctf_app, ""tf_name"", 1, 0, 0 },

    ...
    
    {0}, /* first field in final array cell is 0 */
};
","""Explanation of the 'veriusertfs' array used in older Verilog simulator implementations for PLI applications, including an example array definition.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p307.jpg,True,"```verilog
module decl_in_clocking_block (logic a, b, c, clk);
  clocking PCLK; @(posedge clk);
    property p3; a |=> p4; endproperty
  endclocking
  property p4; b until c; endproperty
  a1g: assert property (PCLK.p3);
endmodule
```","
module decl_in_clocking_block (logic a, b, c, clk);
  clocking PCLK; @(posedge clk);
    property p3; a |=> p4; endproperty
  endclocking
  property p4; b until c; endproperty
  a1g: assert property (PCLK.p3);
endmodule
","""Verilog Code Example and Exercises on Clocking and Assertions""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/StuartSutherland-The Verilog PLI Handbook_p304.jpg,True,"There is a snippet of Verilog code in the image. Here it is:

```verilog
always @(posedge clock)
    $read_test_vector(""vectors.pat"", in1);
```","
always @(posedge clock)
    $read_test_vector(""vectors.pat"", in1);
",Verilog PLI: Utilizing the `misctf` routine for file operations at simulation start and end.,False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p313.jpg,True,"The image contains two sections of Verilog code. Here they are transcribed:

First section:

```verilog
module m_illegal_disable_nesting(logic reset, a, b, clk);
  default clocking PCLK @(posedge clk); endclocking
  property p_disable;
    disable_iff (reset) a |=> b;
  endproperty
  a_disable: assert property(
    disable iff (reset)
    p_disable
  ) else $error(""FAIL"");
endmodule
```

Second section:

```verilog
property p_inferred_disable(x, y,
  event ck = $inferred_clock,
  logic rst = $inferred_disable);
  disable iff (rst) @ck x |=> y;
endproperty
module m_inferred_disable(logic reset, a, b, clk);
  default disable iff reset;
  default clocking @(posedge clk); endclocking
  a_inferred_disable:
    assert property(p_inferred_disable(a, b))
  else $error(""FAIL"");
endmodule
```

These snippets demonstrate how disabling conditions are nested within properties and modules in Verilog, and also include examples of how default clocking and disabling conditions can be declared in Verilog modules.","
module m_illegal_disable_nesting(logic reset, a, b, clk);
  default clocking PCLK @(posedge clk); endclocking
  property p_disable;
    disable_iff (reset) a |=> b;
  endproperty
  a_disable: assert property(
    disable iff (reset)
    p_disable
  ) else $error(""FAIL"");
endmodule


property p_inferred_disable(x, y,
  event ck = $inferred_clock,
  logic rst = $inferred_disable);
  disable iff (rst) @ck x |=> y;
endproperty
module m_inferred_disable(logic reset, a, b, clk);
  default disable iff reset;
  default clocking @(posedge clk); endclocking
  a_inferred_disable:
    assert property(p_inferred_disable(a, b))
  else $error(""FAIL"");
endmodule
","""Example of Verilog code demonstrating illegal nesting of disable conditions along with a property declaration making use of inferred value functions for resets.""",True
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/CernyDudani-SVA- The Power of Assertions in SystemVerilog_p475.jpg,True,"```verilog
always @(s1global_clock)
    o <= a;
endmodule
```","
always @(s1global_clock)
    o <= a;
endmodule
","Caption: ""Excerpt from a book discussing Verilog in the context of formal verification models, including a snippet of Verilog code and theoretical concepts.""",False
Data/example-code/verilog examples/Textbook SVA/Book-Verilog/paginated/SpearTumbush-SystemVerilog for Verification_p479.jpg,True,"The image contains both documentation text and code. Below are the code segments found in the image.

Verilog code from Sample 12.34:
```verilog
module block;
  import ""DPI-C"" context function void c_display();
  export ""DPI-C"" function sv_display; // No type or args

  initial c_display();

  function void sv_display();
    $display(""SV: in sv_display"");
  endfunction
endmodule : block
```

C code from Sample 12.35:
```c
extern void sv_display();

void c_display() {
  io_printf(""C: in c_display\n"");
  sv_display();
}
```

These code snippets demonstrate how to export a SystemVerilog function to C, and how to call an exported SystemVerilog function from C.","
module block;
  import ""DPI-C"" context function void c_display();
  export ""DPI-C"" function sv_display; // No type or args

  initial c_display();

  function void sv_display();
    $display(""SV: in sv_display"");
  endfunction
endmodule : block

n void sv_display();

void c_display() {
  io_printf(""C: in c_display\n"");
  sv_display();
}
",Exporting a SystemVerilog function for interfacing with C/C++.,False
